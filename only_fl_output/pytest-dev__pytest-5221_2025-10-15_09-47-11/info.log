2025-10-15 09:47:11.554 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 09:47:13.407 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=137, output_tokens=12, cost=0.001730
2025-10-15 09:47:13.408 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 09:47:13.412 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:47:20.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=446, output_tokens=236, cost=0.011540
2025-10-15 09:47:20.414 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:47:22.753 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=590, output_tokens=46, cost=0.007280
2025-10-15 09:47:22.755 | DEBUG    | Extracted a valid json.
2025-10-15 09:47:22.755 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"parse_arguments\")",
        "search_code(\"--fixtures\")",
        "search_method(\"show_fixitures_per_plugin\")"
    ],
    "bug_locations": []
}
2025-10-15 09:47:22.790 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:47:22.791 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:47:39.355 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=964, output_tokens=622, cost=0.028300
2025-10-15 09:47:39.369 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:47:49.622 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1802, output_tokens=341, cost=0.028250
2025-10-15 09:47:49.629 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:47:59.772 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=695, output_tokens=330, cost=0.016850
2025-10-15 09:47:59.773 | DEBUG    | Extracted a valid json.
2025-10-15 09:47:59.773 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/python.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify or extend the logic that processes and displays fixture information for the `--fixtures` command-line argument to include the scope of each fixture. The existing functionality of listing fixture names and descriptions should be preserved while enhancing the output to show each fixture's scope (e.g., function, class, module, session) next to its name. This may involve adjusting how fixture information is retrieved and formatting the output to include scope data."
        },
        {
            "file": "src/_pytest/helpconfig.py",
            "class": "",
            "method": "",
            "intended_behavior": "If this file contains logic for the `--fixtures` argument's help text or processing, ensuring that any enhancements or modifications made in `python.py` regarding fixture scope display are consistent and supported here. The help text might need updating to indicate that fixture scope information will also be displayed."
        },
        {
            "file": "src/_pytest/fixtures.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely defines and manages fixtures. If there are utility methods here that fetch fixture metadata (including scope), ensuring these methods are suitably integrated into the logic that outputs fixture information for `--fixtures`. We may not need to directly modify this file, but it's important to ensure that any changes made are compatible with how fixtures and their scopes are defined and managed here."
        }
    ]
}
2025-10-15 09:47:59.788 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import collections
7 import fnmatch
8 import inspect
9 import os
10 import sys
11 import warnings
12 from functools import partial
13 from textwrap import dedent
14 
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import deprecated
20 from _pytest import fixtures
21 from _pytest import nodes
22 from _pytest._code import filter_traceback
23 from _pytest.compat import ascii_escaped
24 from _pytest.compat import enum
25 from _pytest.compat import get_default_arg_names
26 from _pytest.compat import get_real_func
27 from _pytest.compat import getfslineno
28 from _pytest.compat import getimfunc
29 from _pytest.compat import getlocation
30 from _pytest.compat import is_generator
31 from _pytest.compat import isclass
32 from _pytest.compat import isfunction
33 from _pytest.compat import NoneType
34 from _pytest.compat import NOTSET
35 from _pytest.compat import REGEX_TYPE
36 from _pytest.compat import safe_getattr
37 from _pytest.compat import safe_isclass
38 from _pytest.compat import safe_str
39 from _pytest.compat import STRING_TYPES
40 from _pytest.config import hookimpl
41 from _pytest.main import FSHookProxy
42 from _pytest.mark import MARK_GEN
43 from _pytest.mark.structures import get_unpacked_marks
44 from _pytest.mark.structures import normalize_mark_list
45 from _pytest.outcomes import fail
46 from _pytest.outcomes import skip
47 from _pytest.pathlib import parts
48 from _pytest.warning_types import PytestCollectionWarning
49 from _pytest.warning_types import PytestUnhandledCoroutineWarning
50 
51 
52 def pyobj_property(name):
53     def get(self):
54         node = self.getparent(getattr(__import__("pytest"), name))
55         if node is not None:
56             return node.obj
57 
58     doc = "python %s object this node was collected from (can be None)." % (
59         name.lower(),
60     )
61     return property(get, None, None, doc)
62 
63 
64 def pytest_addoption(parser):
65     group = parser.getgroup("general")
66     group.addoption(
67         "--fixtures",
68         "--funcargs",
69         action="store_true",
70         dest="showfixtures",
71         default=False,
72         help="show available fixtures, sorted by plugin appearance "
73         "(fixtures with leading '_' are only shown with '-v')",
74     )
75     group.addoption(
76         "--fixtures-per-test",
77         action="store_true",
78         dest="show_fixtures_per_test",
79         default=False,
80         help="show fixtures per test",
81     )
82     parser.addini(
83         "usefixtures",
84         type="args",
85         default=[],
86         help="list of default fixtures to be used with this project",
87     )
88     parser.addini(
89         "python_files",
90         type="args",
91         default=["test_*.py", "*_test.py"],
92         help="glob-style file patterns for Python test module discovery",
93     )
94     parser.addini(
95         "python_classes",
96         type="args",
97         default=["Test"],
98         help="prefixes or glob names for Python test class discovery",
99     )
100     parser.addini(
101         "python_functions",
102         type="args",
103         default=["test"],
104         help="prefixes or glob names for Python test function and method discovery",
105     )
106     parser.addini(
107         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
108         type="bool",
109         default=False,
110         help="disable string escape non-ascii characters, might cause unwanted "
111         "side effects(use at your own risk)",
112     )
113 
114     group.addoption(
115         "--import-mode",
116         default="prepend",
117         choices=["prepend", "append"],
118         dest="importmode",
119         help="prepend/append to sys.path when importing test modules, "
120         "default is to prepend.",
121     )
122 
123 
124 def pytest_cmdline_main(config):
125     if config.option.showfixtures:
126         showfixtures(config)
127         return 0
128     if config.option.show_fixtures_per_test:
129         show_fixtures_per_test(config)
130         return 0
131 
132 
133 def pytest_generate_tests(metafunc):
134     # those alternative spellings are common - raise a specific error to alert
135     # the user
136     alt_spellings = ["parameterize", "parametrise", "parameterise"]
137     for mark_name in alt_spellings:
138         if metafunc.definition.get_closest_marker(mark_name):
139             msg = "{0} has '{1}' mark, spelling should be 'parametrize'"
140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)
141     for marker in metafunc.definition.iter_markers(name="parametrize"):
142         metafunc.parametrize(*marker.args, **marker.kwargs)
143 
144 
145 def pytest_configure(config):
146     config.addinivalue_line(
147         "markers",
148         "parametrize(argnames, argvalues): call a test function multiple "
149         "times passing in different arguments in turn. argvalues generally "
150         "needs to be a list of values if argnames specifies only one name "
151         "or a list of tuples of values if argnames specifies multiple names. "
152         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
153         "decorated test function, one with arg1=1 and another with arg1=2."
154         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
155         "and examples.",
156     )
157     config.addinivalue_line(
158         "markers",
159         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
160         "all of the specified fixtures. see "
161         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
162     )
163 
164 
165 @hookimpl(trylast=True)
166 def pytest_pyfunc_call(pyfuncitem):
167     testfunction = pyfuncitem.obj
168     iscoroutinefunction = getattr(inspect, "iscoroutinefunction", None)
169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):
170         msg = "Coroutine functions are not natively supported and have been skipped.\n"
171         msg += "You need to install a suitable plugin for your async framework, for example:\n"
172         msg += "  - pytest-asyncio\n"
173         msg += "  - pytest-trio\n"
174         msg += "  - pytest-tornasync"
175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))
176         skip(msg="coroutine function and no async plugin installed (see warnings)")
177     funcargs = pyfuncitem.funcargs
178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
179     testfunction(**testargs)
180     return True
181 
182 
183 def pytest_collect_file(path, parent):
184     ext = path.ext
185     if ext == ".py":
186         if not parent.session.isinitpath(path):
187             if not path_matches_patterns(
188                 path, parent.config.getini("python_files") + ["__init__.py"]
189             ):
190                 return
191         ihook = parent.session.gethookproxy(path)
192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
193 
194 
195 def path_matches_patterns(path, patterns):
196     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
197     return any(path.fnmatch(pattern) for pattern in patterns)
198 
199 
200 def pytest_pycollect_makemodule(path, parent):
201     if path.basename == "__init__.py":
202         return Package(path, parent)
203     return Module(path, parent)
204 
205 
206 @hookimpl(hookwrapper=True)
207 def pytest_pycollect_makeitem(collector, name, obj):
208     outcome = yield
209     res = outcome.get_result()
210     if res is not None:
211         return
212     # nothing was collected elsewhere, let's do it here
213     if safe_isclass(obj):
214         if collector.istestclass(obj, name):
215             outcome.force_result(Class(name, parent=collector))
216     elif collector.istestfunction(obj, name):
217         # mock seems to store unbound methods (issue473), normalize it
218         obj = getattr(obj, "__func__", obj)
219         # We need to try and unwrap the function if it's a functools.partial
220         # or a funtools.wrapped.
221         # We musn't if it's been wrapped with mock.patch (python 2 only)
222         if not (isfunction(obj) or isfunction(get_real_func(obj))):
223             filename, lineno = getfslineno(obj)
224             warnings.warn_explicit(
225                 message=PytestCollectionWarning(
226                     "cannot collect %r because it is not a function." % name
227                 ),
228                 category=None,
229                 filename=str(filename),
230                 lineno=lineno + 1,
231             )
232         elif getattr(obj, "__test__", True):
233             if is_generator(obj):
234                 res = Function(name, parent=collector)
235                 reason = deprecated.YIELD_TESTS.format(name=name)
236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
237                 res.warn(PytestCollectionWarning(reason))
238             else:
239                 res = list(collector._genfunctions(name, obj))
240             outcome.force_result(res)
241 
242 
243 def pytest_make_parametrize_id(config, val, argname=None):
244     return None
245 
246 
247 class PyobjContext(object):
248     module = pyobj_property("Module")
249     cls = pyobj_property("Class")
250     instance = pyobj_property("Instance")
251 
252 
253 class PyobjMixin(PyobjContext):
254     _ALLOW_MARKERS = True
255 
256     def __init__(self, *k, **kw):
257         super(PyobjMixin, self).__init__(*k, **kw)
258 
259     @property
260     def obj(self):
261         """Underlying Python object."""
262         obj = getattr(self, "_obj", None)
263         if obj is None:
264             self._obj = obj = self._getobj()
265             # XXX evil hack
266             # used to avoid Instance collector marker duplication
267             if self._ALLOW_MARKERS:
268                 self.own_markers.extend(get_unpacked_marks(self.obj))
269         return obj
270 
271     @obj.setter
272     def obj(self, value):
273         self._obj = value
274 
275     def _getobj(self):
276         """Gets the underlying Python object. May be overwritten by subclasses."""
277         return getattr(self.parent.obj, self.name)
278 
279     def getmodpath(self, stopatmodule=True, includemodule=False):
280         """ return python path relative to the containing module. """
281         chain = self.listchain()
282         chain.reverse()
283         parts = []
284         for node in chain:
285             if isinstance(node, Instance):
286                 continue
287             name = node.name
288             if isinstance(node, Module):
289                 name = os.path.splitext(name)[0]
290                 if stopatmodule:
291                     if includemodule:
292                         parts.append(name)
293                     break
294             parts.append(name)
295         parts.reverse()
296         s = ".".join(parts)
297         return s.replace(".[", "[")
298 
299     def reportinfo(self):
300         # XXX caching?
301         obj = self.obj
302         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
303         if isinstance(compat_co_firstlineno, int):
304             # nose compatibility
305             fspath = sys.modules[obj.__module__].__file__
306             if fspath.endswith(".pyc"):
307                 fspath = fspath[:-1]
308             lineno = compat_co_firstlineno
309         else:
310             fspath, lineno = getfslineno(obj)
311         modpath = self.getmodpath()
312         assert isinstance(lineno, int)
313         return fspath, lineno, modpath
314 
315 
316 class PyCollector(PyobjMixin, nodes.Collector):
317     def funcnamefilter(self, name):
318         return self._matches_prefix_or_glob_option("python_functions", name)
319 
320     def isnosetest(self, obj):
321         """ Look for the __test__ attribute, which is applied by the
322         @nose.tools.istest decorator
323         """
324         # We explicitly check for "is True" here to not mistakenly treat
325         # classes with a custom __getattr__ returning something truthy (like a
326         # function) as test classes.
327         return safe_getattr(obj, "__test__", False) is True
328 
329     def classnamefilter(self, name):
330         return self._matches_prefix_or_glob_option("python_classes", name)
331 
332     def istestfunction(self, obj, name):
333         if self.funcnamefilter(name) or self.isnosetest(obj):
334             if isinstance(obj, staticmethod):
335                 # static methods need to be unwrapped
336                 obj = safe_getattr(obj, "__func__", False)
337             return (
338                 safe_getattr(obj, "__call__", False)
339                 and fixtures.getfixturemarker(obj) is None
340             )
341         else:
342             return False
343 
344     def istestclass(self, obj, name):
345         return self.classnamefilter(name) or self.isnosetest(obj)
346 
347     def _matches_prefix_or_glob_option(self, option_name, name):
348         """
349         checks if the given name matches the prefix or glob-pattern defined
350         in ini configuration.
351         """
352         for option in self.config.getini(option_name):
353             if name.startswith(option):
354                 return True
355             # check that name looks like a glob-string before calling fnmatch
356             # because this is called for every name in each collected module,
357             # and fnmatch is somewhat expensive to call
358             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
359                 name, option
360             ):
361                 return True
362         return False
363 
364     def collect(self):
365         if not getattr(self.obj, "__test__", True):
366             return []
367 
368         # NB. we avoid random getattrs and peek in the __dict__ instead
369         # (XXX originally introduced from a PyPy need, still true?)
370         dicts = [getattr(self.obj, "__dict__", {})]
371         for basecls in inspect.getmro(self.obj.__class__):
372             dicts.append(basecls.__dict__)
373         seen = {}
374         values = []
375         for dic in dicts:
376             for name, obj in list(dic.items()):
377                 if name in seen:
378                     continue
379                 seen[name] = True
380                 res = self._makeitem(name, obj)
381                 if res is None:
382                     continue
383                 if not isinstance(res, list):
384                     res = [res]
385                 values.extend(res)
386         values.sort(key=lambda item: item.reportinfo()[:2])
387         return values
388 
389     def _makeitem(self, name, obj):
390         # assert self.ihook.fspath == self.fspath, self
391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
392 
393     def _genfunctions(self, name, funcobj):
394         module = self.getparent(Module).obj
395         clscol = self.getparent(Class)
396         cls = clscol and clscol.obj or None
397         fm = self.session._fixturemanager
398 
399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)
400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)
401 
402         metafunc = Metafunc(
403             definition, fixtureinfo, self.config, cls=cls, module=module
404         )
405         methods = []
406         if hasattr(module, "pytest_generate_tests"):
407             methods.append(module.pytest_generate_tests)
408         if hasattr(cls, "pytest_generate_tests"):
409             methods.append(cls().pytest_generate_tests)
410         if methods:
411             self.ihook.pytest_generate_tests.call_extra(
412                 methods, dict(metafunc=metafunc)
413             )
414         else:
415             self.ihook.pytest_generate_tests(metafunc=metafunc)
416 
417         if not metafunc._calls:
418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)
419         else:
420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
422 
423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
424             # with direct parametrization, so make sure we update what the
425             # function really needs.
426             fixtureinfo.prune_dependency_tree()
427 
428             for callspec in metafunc._calls:
429                 subname = "%s[%s]" % (name, callspec.id)
430                 yield Function(
431                     name=subname,
432                     parent=self,
433                     callspec=callspec,
434                     callobj=funcobj,
435                     fixtureinfo=fixtureinfo,
436                     keywords={callspec.id: True},
437                     originalname=name,
438                 )
439 
440 
441 class Module(nodes.File, PyCollector):
442     """ Collector for test classes and functions. """
443 
444     def _getobj(self):
445         return self._importtestmodule()
446 
447     def collect(self):
448         self._inject_setup_module_fixture()
449         self._inject_setup_function_fixture()
450         self.session._fixturemanager.parsefactories(self)
451         return super(Module, self).collect()
452 
453     def _inject_setup_module_fixture(self):
454         """Injects a hidden autouse, module scoped fixture into the collected module object
455         that invokes setUpModule/tearDownModule if either or both are available.
456 
457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
458         other fixtures (#517).
459         """
460         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
461         if setup_module is None:
462             setup_module = _get_non_fixture_func(self.obj, "setup_module")
463 
464         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
465         if teardown_module is None:
466             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
467 
468         if setup_module is None and teardown_module is None:
469             return
470 
471         @fixtures.fixture(autouse=True, scope="module")
472         def xunit_setup_module_fixture(request):
473             if setup_module is not None:
474                 _call_with_optional_argument(setup_module, request.module)
475             yield
476             if teardown_module is not None:
477                 _call_with_optional_argument(teardown_module, request.module)
478 
479         self.obj.__pytest_setup_module = xunit_setup_module_fixture
480 
481     def _inject_setup_function_fixture(self):
482         """Injects a hidden autouse, function scoped fixture into the collected module object
483         that invokes setup_function/teardown_function if either or both are available.
484 
485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
486         other fixtures (#517).
487         """
488         setup_function = _get_non_fixture_func(self.obj, "setup_function")
489         teardown_function = _get_non_fixture_func(self.obj, "teardown_function")
490         if setup_function is None and teardown_function is None:
491             return
492 
493         @fixtures.fixture(autouse=True, scope="function")
494         def xunit_setup_function_fixture(request):
495             if request.instance is not None:
496                 # in this case we are bound to an instance, so we need to let
497                 # setup_method handle this
498                 yield
499                 return
500             if setup_function is not None:
501                 _call_with_optional_argument(setup_function, request.function)
502             yield
503             if teardown_function is not None:
504                 _call_with_optional_argument(teardown_function, request.function)
505 
506         self.obj.__pytest_setup_function = xunit_setup_function_fixture
507 
508     def _importtestmodule(self):
509         # we assume we are only called once per module
510         importmode = self.config.getoption("--import-mode")
511         try:
512             mod = self.fspath.pyimport(ensuresyspath=importmode)
513         except SyntaxError:
514             raise self.CollectError(
515                 _pytest._code.ExceptionInfo.from_current().getrepr(style="short")
516             )
517         except self.fspath.ImportMismatchError:
518             e = sys.exc_info()[1]
519             raise self.CollectError(
520                 "import file mismatch:\n"
521                 "imported module %r has this __file__ attribute:\n"
522                 "  %s\n"
523                 "which is not the same as the test file we want to collect:\n"
524                 "  %s\n"
525                 "HINT: remove __pycache__ / .pyc files and/or use a "
526                 "unique basename for your test file modules" % e.args
527             )
528         except ImportError:
529             from _pytest._code.code import ExceptionInfo
530 
531             exc_info = ExceptionInfo.from_current()
532             if self.config.getoption("verbose") < 2:
533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
534             exc_repr = (
535                 exc_info.getrepr(style="short")
536                 if exc_info.traceback
537                 else exc_info.exconly()
538             )
539             formatted_tb = safe_str(exc_repr)
540             raise self.CollectError(
541                 "ImportError while importing test module '{fspath}'.\n"
542                 "Hint: make sure your test modules/packages have valid Python names.\n"
543                 "Traceback:\n"
544                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
545             )
546         except _pytest.runner.Skipped as e:
547             if e.allow_module_level:
548                 raise
549             raise self.CollectError(
550                 "Using pytest.skip outside of a test is not allowed. "
551                 "To decorate a test function, use the @pytest.mark.skip "
552                 "or @pytest.mark.skipif decorators instead, and to skip a "
553                 "module use `pytestmark = pytest.mark.{skip,skipif}."
554             )
555         self.config.pluginmanager.consider_module(mod)
556         return mod
557 
558 
559 class Package(Module):
560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):
561         session = parent.session
562         nodes.FSCollector.__init__(
563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
564         )
565         self.name = fspath.dirname
566         self.trace = session.trace
567         self._norecursepatterns = session._norecursepatterns
568         self.fspath = fspath
569 
570     def setup(self):
571         # not using fixtures to call setup_module here because autouse fixtures
572         # from packages are not called automatically (#4085)
573         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
574         if setup_module is None:
575             setup_module = _get_non_fixture_func(self.obj, "setup_module")
576         if setup_module is not None:
577             _call_with_optional_argument(setup_module, self.obj)
578 
579         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
580         if teardown_module is None:
581             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
582         if teardown_module is not None:
583             func = partial(_call_with_optional_argument, teardown_module, self.obj)
584             self.addfinalizer(func)
585 
586     def _recurse(self, dirpath):
587         if dirpath.basename == "__pycache__":
588             return False
589         ihook = self.gethookproxy(dirpath.dirpath())
590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):
591             return
592         for pat in self._norecursepatterns:
593             if dirpath.check(fnmatch=pat):
594                 return False
595         ihook = self.gethookproxy(dirpath)
596         ihook.pytest_collect_directory(path=dirpath, parent=self)
597         return True
598 
599     def gethookproxy(self, fspath):
600         # check if we have the common case of running
601         # hooks with all conftest.py filesall conftest.py
602         pm = self.config.pluginmanager
603         my_conftestmodules = pm._getconftestmodules(fspath)
604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)
605         if remove_mods:
606             # one or more conftests are not in use at this fspath
607             proxy = FSHookProxy(fspath, pm, remove_mods)
608         else:
609             # all plugis are active for this fspath
610             proxy = self.config.hook
611         return proxy
612 
613     def _collectfile(self, path, handle_dupes=True):
614         assert path.isfile(), "%r is not a file (isdir=%r, exists=%r, islink=%r)" % (
615             path,
616             path.isdir(),
617             path.exists(),
618             path.islink(),
619         )
620         ihook = self.gethookproxy(path)
621         if not self.isinitpath(path):
622             if ihook.pytest_ignore_collect(path=path, config=self.config):
623                 return ()
624 
625         if handle_dupes:
626             keepduplicates = self.config.getoption("keepduplicates")
627             if not keepduplicates:
628                 duplicate_paths = self.config.pluginmanager._duplicatepaths
629                 if path in duplicate_paths:
630                     return ()
631                 else:
632                     duplicate_paths.add(path)
633 
634         if self.fspath == path:  # __init__.py
635             return [self]
636 
637         return ihook.pytest_collect_file(path=path, parent=self)
638 
639     def isinitpath(self, path):
640         return path in self.session._initialpaths
641 
642     def collect(self):
643         this_path = self.fspath.dirpath()
644         init_module = this_path.join("__init__.py")
645         if init_module.check(file=1) and path_matches_patterns(
646             init_module, self.config.getini("python_files")
647         ):
648             yield Module(init_module, self)
649         pkg_prefixes = set()
650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
651             # We will visit our own __init__.py file, in which case we skip it.
652             is_file = path.isfile()
653             if is_file:
654                 if path.basename == "__init__.py" and path.dirpath() == this_path:
655                     continue
656 
657             parts_ = parts(path.strpath)
658             if any(
659                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
660                 for pkg_prefix in pkg_prefixes
661             ):
662                 continue
663 
664             if is_file:
665                 for x in self._collectfile(path):
666                     yield x
667             elif not path.isdir():
668                 # Broken symlink or invalid/missing file.
669                 continue
670             elif path.join("__init__.py").check(file=1):
671                 pkg_prefixes.add(path)
672 
673 
674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):
675     """
676     Return a callable to perform xunit-style setup or teardown if
677     the function exists in the ``holder`` object.
678     The ``param_obj`` parameter is the parameter which will be passed to the function
679     when the callable is called without arguments, defaults to the ``holder`` object.
680     Return ``None`` if a suitable callable is not found.
681     """
682     # TODO: only needed because of Package!
683     param_obj = param_obj if param_obj is not None else holder
684     result = _get_non_fixture_func(holder, attr_name)
685     if result is not None:
686         arg_count = result.__code__.co_argcount
687         if inspect.ismethod(result):
688             arg_count -= 1
689         if arg_count:
690             return lambda: result(param_obj)
691         else:
692             return result
693 
694 
695 def _call_with_optional_argument(func, arg):
696     """Call the given function with the given argument if func accepts one argument, otherwise
697     calls func without arguments"""
698     arg_count = func.__code__.co_argcount
699     if inspect.ismethod(func):
700         arg_count -= 1
701     if arg_count:
702         func(arg)
703     else:
704         func()
705 
706 
707 def _get_non_fixture_func(obj, name):
708     """Return the attribute from the given object to be used as a setup/teardown
709     xunit-style function, but only if not marked as a fixture to
710     avoid calling it twice.
711     """
712     meth = getattr(obj, name, None)
713     if fixtures.getfixturemarker(meth) is None:
714         return meth
715 
716 
717 class Class(PyCollector):
718     """ Collector for test methods. """
719 
720     def collect(self):
721         if not safe_getattr(self.obj, "__test__", True):
722             return []
723         if hasinit(self.obj):
724             self.warn(
725                 PytestCollectionWarning(
726                     "cannot collect test class %r because it has a "
727                     "__init__ constructor" % self.obj.__name__
728                 )
729             )
730             return []
731         elif hasnew(self.obj):
732             self.warn(
733                 PytestCollectionWarning(
734                     "cannot collect test class %r because it has a "
735                     "__new__ constructor" % self.obj.__name__
736                 )
737             )
738             return []
739 
740         self._inject_setup_class_fixture()
741         self._inject_setup_method_fixture()
742 
743         return [Instance(name="()", parent=self)]
744 
745     def _inject_setup_class_fixture(self):
746         """Injects a hidden autouse, class scoped fixture into the collected class object
747         that invokes setup_class/teardown_class if either or both are available.
748 
749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
750         other fixtures (#517).
751         """
752         setup_class = _get_non_fixture_func(self.obj, "setup_class")
753         teardown_class = getattr(self.obj, "teardown_class", None)
754         if setup_class is None and teardown_class is None:
755             return
756 
757         @fixtures.fixture(autouse=True, scope="class")
758         def xunit_setup_class_fixture(cls):
759             if setup_class is not None:
760                 func = getimfunc(setup_class)
761                 _call_with_optional_argument(func, self.obj)
762             yield
763             if teardown_class is not None:
764                 func = getimfunc(teardown_class)
765                 _call_with_optional_argument(func, self.obj)
766 
767         self.obj.__pytest_setup_class = xunit_setup_class_fixture
768 
769     def _inject_setup_method_fixture(self):
770         """Injects a hidden autouse, function scoped fixture into the collected class object
771         that invokes setup_method/teardown_method if either or both are available.
772 
773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
774         other fixtures (#517).
775         """
776         setup_method = _get_non_fixture_func(self.obj, "setup_method")
777         teardown_method = getattr(self.obj, "teardown_method", None)
778         if setup_method is None and teardown_method is None:
779             return
780 
781         @fixtures.fixture(autouse=True, scope="function")
782         def xunit_setup_method_fixture(self, request):
783             method = request.function
784             if setup_method is not None:
785                 func = getattr(self, "setup_method")
786                 _call_with_optional_argument(func, method)
787             yield
788             if teardown_method is not None:
789                 func = getattr(self, "teardown_method")
790                 _call_with_optional_argument(func, method)
791 
792         self.obj.__pytest_setup_method = xunit_setup_method_fixture
793 
794 
795 class Instance(PyCollector):
796     _ALLOW_MARKERS = False  # hack, destroy later
797     # instances share the object with their parents in a way
798     # that duplicates markers instances if not taken out
799     # can be removed at node structure reorganization time
800 
801     def _getobj(self):
802         return self.parent.obj()
803 
804     def collect(self):
805         self.session._fixturemanager.parsefactories(self)
806         return super(Instance, self).collect()
807 
808     def newinstance(self):
809         self.obj = self._getobj()
810         return self.obj
811 
812 
813 class FunctionMixin(PyobjMixin):
814     """ mixin for the code common to Function and Generator.
815     """
816 
817     def setup(self):
818         """ perform setup for this test function. """
819         if isinstance(self.parent, Instance):
820             self.parent.newinstance()
821             self.obj = self._getobj()
822 
823     def _prunetraceback(self, excinfo):
824         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
825             code = _pytest._code.Code(get_real_func(self.obj))
826             path, firstlineno = code.path, code.firstlineno
827             traceback = excinfo.traceback
828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
829             if ntraceback == traceback:
830                 ntraceback = ntraceback.cut(path=path)
831                 if ntraceback == traceback:
832                     ntraceback = ntraceback.filter(filter_traceback)
833                     if not ntraceback:
834                         ntraceback = traceback
835 
836             excinfo.traceback = ntraceback.filter()
837             # issue364: mark all but first and last frames to
838             # only show a single-line message for each frame
839             if self.config.getoption("tbstyle", "auto") == "auto":
840                 if len(excinfo.traceback) > 2:
841                     for entry in excinfo.traceback[1:-1]:
842                         entry.set_repr_style("short")
843 
844     def repr_failure(self, excinfo, outerr=None):
845         assert outerr is None, "XXX outerr usage is deprecated"
846         style = self.config.getoption("tbstyle", "auto")
847         if style == "auto":
848             style = "long"
849         return self._repr_failure_py(excinfo, style=style)
850 
851 
852 def hasinit(obj):
853     init = getattr(obj, "__init__", None)
854     if init:
855         return init != object.__init__
856 
857 
858 def hasnew(obj):
859     new = getattr(obj, "__new__", None)
860     if new:
861         return new != object.__new__
862 
863 
864 class CallSpec2(object):
865     def __init__(self, metafunc):
866         self.metafunc = metafunc
867         self.funcargs = {}
868         self._idlist = []
869         self.params = {}
870         self._globalid = NOTSET
871         self._globalparam = NOTSET
872         self._arg2scopenum = {}  # used for sorting parametrized resources
873         self.marks = []
874         self.indices = {}
875 
876     def copy(self):
877         cs = CallSpec2(self.metafunc)
878         cs.funcargs.update(self.funcargs)
879         cs.params.update(self.params)
880         cs.marks.extend(self.marks)
881         cs.indices.update(self.indices)
882         cs._arg2scopenum.update(self._arg2scopenum)
883         cs._idlist = list(self._idlist)
884         cs._globalid = self._globalid
885         cs._globalparam = self._globalparam
886         return cs
887 
888     def _checkargnotcontained(self, arg):
889         if arg in self.params or arg in self.funcargs:
890             raise ValueError("duplicate %r" % (arg,))
891 
892     def getparam(self, name):
893         try:
894             return self.params[name]
895         except KeyError:
896             if self._globalparam is NOTSET:
897                 raise ValueError(name)
898             return self._globalparam
899 
900     @property
901     def id(self):
902         return "-".join(map(str, filter(None, self._idlist)))
903 
904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
905         for arg, val in zip(argnames, valset):
906             self._checkargnotcontained(arg)
907             valtype_for_arg = valtypes[arg]
908             getattr(self, valtype_for_arg)[arg] = val
909             self.indices[arg] = param_index
910             self._arg2scopenum[arg] = scopenum
911         self._idlist.append(id)
912         self.marks.extend(normalize_mark_list(marks))
913 
914     def setall(self, funcargs, id, param):
915         for x in funcargs:
916             self._checkargnotcontained(x)
917         self.funcargs.update(funcargs)
918         if id is not NOTSET:
919             self._idlist.append(id)
920         if param is not NOTSET:
921             assert self._globalparam is NOTSET
922             self._globalparam = param
923         for arg in funcargs:
924             self._arg2scopenum[arg] = fixtures.scopenum_function
925 
926 
927 class Metafunc(fixtures.FuncargnamesCompatAttr):
928     """
929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
930     They help to inspect a test function and to generate tests according to
931     test configuration or values specified in the class or module where a
932     test function is defined.
933     """
934 
935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):
936         assert (
937             isinstance(definition, FunctionDefinition)
938             or type(definition).__name__ == "DefinitionMock"
939         )
940         self.definition = definition
941 
942         #: access to the :class:`_pytest.config.Config` object for the test session
943         self.config = config
944 
945         #: the module object where the test function is defined in.
946         self.module = module
947 
948         #: underlying python test function
949         self.function = definition.obj
950 
951         #: set of fixture names required by the test function
952         self.fixturenames = fixtureinfo.names_closure
953 
954         #: class object where the test function is defined in or ``None``.
955         self.cls = cls
956 
957         self._calls = []
958         self._ids = set()
959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
960 
961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):
962         """ Add new invocations to the underlying test function using the list
963         of argvalues for the given argnames.  Parametrization is performed
964         during the collection phase.  If you need to setup expensive resources
965         see about setting indirect to do it rather at test setup time.
966 
967         :arg argnames: a comma-separated string denoting one or more argument
968                        names, or a list/tuple of argument strings.
969 
970         :arg argvalues: The list of argvalues determines how often a
971             test is invoked with different argument values.  If only one
972             argname was specified argvalues is a list of values.  If N
973             argnames were specified, argvalues must be a list of N-tuples,
974             where each tuple-element specifies a value for its respective
975             argname.
976 
977         :arg indirect: The list of argnames or boolean. A list of arguments'
978             names (subset of argnames). If True the list contains all names from
979             the argnames. Each argvalue corresponding to an argname in this list will
980             be passed as request.param to its respective argname fixture
981             function so that it can perform more expensive setups during the
982             setup phase of a test rather than at collection time.
983 
984         :arg ids: list of string ids, or a callable.
985             If strings, each is corresponding to the argvalues so that they are
986             part of the test id. If None is given as id of specific test, the
987             automatically generated id for that argument will be used.
988             If callable, it should take one argument (a single argvalue) and return
989             a string or return None. If None, the automatically generated id for that
990             argument will be used.
991             If no ids are provided they will be generated automatically from
992             the argvalues.
993 
994         :arg scope: if specified it denotes the scope of the parameters.
995             The scope is used for grouping tests by parameter instances.
996             It will also override any fixture-function defined scope, allowing
997             to set a dynamic scope using test context or configuration.
998         """
999         from _pytest.fixtures import scope2index
1000         from _pytest.mark import ParameterSet
1001 
1002         argnames, parameters = ParameterSet._for_parametrize(
1003             argnames,
1004             argvalues,
1005             self.function,
1006             self.config,
1007             function_definition=self.definition,
1008         )
1009         del argvalues
1010 
1011         if scope is None:
1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
1013 
1014         self._validate_if_using_arg_names(argnames, indirect)
1015 
1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
1017 
1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
1019 
1020         scopenum = scope2index(
1021             scope, descr="parametrize() call in {}".format(self.function.__name__)
1022         )
1023 
1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator
1025         # more than once) then we accumulate those calls generating the cartesian product
1026         # of all calls
1027         newcalls = []
1028         for callspec in self._calls or [CallSpec2(self)]:
1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
1030                 newcallspec = callspec.copy()
1031                 newcallspec.setmulti2(
1032                     arg_values_types,
1033                     argnames,
1034                     param_set.values,
1035                     param_id,
1036                     param_set.marks,
1037                     scopenum,
1038                     param_index,
1039                 )
1040                 newcalls.append(newcallspec)
1041         self._calls = newcalls
1042 
1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):
1044         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
1045         to ``parametrize``.
1046 
1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1048         :param ids: the ids parameter of the parametrized call (see docs).
1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
1050         :param Item item: the item that generated this parametrized call.
1051         :rtype: List[str]
1052         :return: the list of ids for each argname given
1053         """
1054         from _pytest._io.saferepr import saferepr
1055 
1056         idfn = None
1057         if callable(ids):
1058             idfn = ids
1059             ids = None
1060         if ids:
1061             func_name = self.function.__name__
1062             if len(ids) != len(parameters):
1063                 msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)
1065             for id_value in ids:
1066                 if id_value is not None and not isinstance(id_value, six.string_types):
1067                     msg = "In {}: ids must be list of strings, found: {} (type: {!r})"
1068                     fail(
1069                         msg.format(func_name, saferepr(id_value), type(id_value)),
1070                         pytrace=False,
1071                     )
1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)
1073         return ids
1074 
1075     def _resolve_arg_value_types(self, argnames, indirect):
1076         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1077         to the function, based on the ``indirect`` parameter of the parametrized() call.
1078 
1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1081         :rtype: Dict[str, str]
1082             A dict mapping each arg name to either:
1083             * "params" if the argname should be the parameter of a fixture of the same name.
1084             * "funcargs" if the argname should be a parameter to the parametrized test function.
1085         """
1086         valtypes = {}
1087         if indirect is True:
1088             valtypes = dict.fromkeys(argnames, "params")
1089         elif indirect is False:
1090             valtypes = dict.fromkeys(argnames, "funcargs")
1091         elif isinstance(indirect, (tuple, list)):
1092             valtypes = dict.fromkeys(argnames, "funcargs")
1093             for arg in indirect:
1094                 if arg not in argnames:
1095                     fail(
1096                         "In {}: indirect fixture '{}' doesn't exist".format(
1097                             self.function.__name__, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 valtypes[arg] = "params"
1102         return valtypes
1103 
1104     def _validate_if_using_arg_names(self, argnames, indirect):
1105         """
1106         Check if all argnames are being used, by default values, or directly/indirectly.
1107 
1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1110         :raise ValueError: if validation fails.
1111         """
1112         default_arg_names = set(get_default_arg_names(self.function))
1113         func_name = self.function.__name__
1114         for arg in argnames:
1115             if arg not in self.fixturenames:
1116                 if arg in default_arg_names:
1117                     fail(
1118                         "In {}: function already takes an argument '{}' with a default value".format(
1119                             func_name, arg
1120                         ),
1121                         pytrace=False,
1122                     )
1123                 else:
1124                     if isinstance(indirect, (tuple, list)):
1125                         name = "fixture" if arg in indirect else "argument"
1126                     else:
1127                         name = "fixture" if indirect else "argument"
1128                     fail(
1129                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1130                         pytrace=False,
1131                     )
1132 
1133 
1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1135     """Find the most appropriate scope for a parametrized call based on its arguments.
1136 
1137     When there's at least one direct argument, always use "function" scope.
1138 
1139     When a test function is parametrized and all its arguments are indirect
1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1141 
1142     Related to issue #1832, based on code posted by @Kingdread.
1143     """
1144     from _pytest.fixtures import scopes
1145 
1146     if isinstance(indirect, (list, tuple)):
1147         all_arguments_are_fixtures = len(indirect) == len(argnames)
1148     else:
1149         all_arguments_are_fixtures = bool(indirect)
1150 
1151     if all_arguments_are_fixtures:
1152         fixturedefs = arg2fixturedefs or {}
1153         used_scopes = [
1154             fixturedef[0].scope
1155             for name, fixturedef in fixturedefs.items()
1156             if name in argnames
1157         ]
1158         if used_scopes:
1159             # Takes the most narrow scope from used fixtures
1160             for scope in reversed(scopes):
1161                 if scope in used_scopes:
1162                     return scope
1163 
1164     return "function"
1165 
1166 
1167 def _ascii_escaped_by_config(val, config):
1168     if config is None:
1169         escape_option = False
1170     else:
1171         escape_option = config.getini(
1172             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1173         )
1174     return val if escape_option else ascii_escaped(val)
1175 
1176 
1177 def _idval(val, argname, idx, idfn, item, config):
1178     if idfn:
1179         try:
1180             generated_id = idfn(val)
1181             if generated_id is not None:
1182                 val = generated_id
1183         except Exception as e:
1184             # See issue https://github.com/pytest-dev/pytest/issues/2169
1185             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}\n"
1186             msg = msg.format(item.nodeid, argname, idx)
1187             # we only append the exception type and message because on Python 2 reraise does nothing
1188             msg += "  {}: {}\n".format(type(e).__name__, e)
1189             six.raise_from(ValueError(msg), e)
1190     elif config:
1191         hook_id = config.hook.pytest_make_parametrize_id(
1192             config=config, val=val, argname=argname
1193         )
1194         if hook_id:
1195             return hook_id
1196 
1197     if isinstance(val, STRING_TYPES):
1198         return _ascii_escaped_by_config(val, config)
1199     elif isinstance(val, (float, int, bool, NoneType)):
1200         return str(val)
1201     elif isinstance(val, REGEX_TYPE):
1202         return ascii_escaped(val.pattern)
1203     elif enum is not None and isinstance(val, enum.Enum):
1204         return str(val)
1205     elif (isclass(val) or isfunction(val)) and hasattr(val, "__name__"):
1206         return val.__name__
1207     return str(argname) + str(idx)
1208 
1209 
1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):
1211     if parameterset.id is not None:
1212         return parameterset.id
1213     if ids is None or (idx >= len(ids) or ids[idx] is None):
1214         this_id = [
1215             _idval(val, argname, idx, idfn, item=item, config=config)
1216             for val, argname in zip(parameterset.values, argnames)
1217         ]
1218         return "-".join(this_id)
1219     else:
1220         return ascii_escaped(ids[idx])
1221 
1222 
1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):
1224     ids = [
1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1226         for valindex, parameterset in enumerate(parametersets)
1227     ]
1228     if len(set(ids)) != len(ids):
1229         # The ids are not unique
1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]
1231         counters = collections.defaultdict(lambda: 0)
1232         for index, testid in enumerate(ids):
1233             if testid in duplicates:
1234                 ids[index] = testid + str(counters[testid])
1235                 counters[testid] += 1
1236     return ids
1237 
1238 
1239 def show_fixtures_per_test(config):
1240     from _pytest.main import wrap_session
1241 
1242     return wrap_session(config, _show_fixtures_per_test)
1243 
1244 
1245 def _show_fixtures_per_test(config, session):
1246     import _pytest.config
1247 
1248     session.perform_collect()
1249     curdir = py.path.local()
1250     tw = _pytest.config.create_terminal_writer(config)
1251     verbose = config.getvalue("verbose")
1252 
1253     def get_best_relpath(func):
1254         loc = getlocation(func, curdir)
1255         return curdir.bestrelpath(loc)
1256 
1257     def write_fixture(fixture_def):
1258         argname = fixture_def.argname
1259         if verbose <= 0 and argname.startswith("_"):
1260             return
1261         if verbose > 0:
1262             bestrel = get_best_relpath(fixture_def.func)
1263             funcargspec = "{} -- {}".format(argname, bestrel)
1264         else:
1265             funcargspec = argname
1266         tw.line(funcargspec, green=True)
1267         fixture_doc = fixture_def.func.__doc__
1268         if fixture_doc:
1269             write_docstring(tw, fixture_doc)
1270         else:
1271             tw.line("    no docstring available", red=True)
1272 
1273     def write_item(item):
1274         try:
1275             info = item._fixtureinfo
1276         except AttributeError:
1277             # doctests items have no _fixtureinfo attribute
1278             return
1279         if not info.name2fixturedefs:
1280             # this test item does not use any fixtures
1281             return
1282         tw.line()
1283         tw.sep("-", "fixtures used by {}".format(item.name))
1284         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1285         # dict key not used in loop but needed for sorting
1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1287             assert fixturedefs is not None
1288             if not fixturedefs:
1289                 continue
1290             # last item is expected to be the one used by the test item
1291             write_fixture(fixturedefs[-1])
1292 
1293     for session_item in session.items:
1294         write_item(session_item)
1295 
1296 
1297 def showfixtures(config):
1298     from _pytest.main import wrap_session
1299 
1300     return wrap_session(config, _showfixtures_main)
1301 
1302 
1303 def _showfixtures_main(config, session):
1304     import _pytest.config
1305 
1306     session.perform_collect()
1307     curdir = py.path.local()
1308     tw = _pytest.config.create_terminal_writer(config)
1309     verbose = config.getvalue("verbose")
1310 
1311     fm = session._fixturemanager
1312 
1313     available = []
1314     seen = set()
1315 
1316     for argname, fixturedefs in fm._arg2fixturedefs.items():
1317         assert fixturedefs is not None
1318         if not fixturedefs:
1319             continue
1320         for fixturedef in fixturedefs:
1321             loc = getlocation(fixturedef.func, curdir)
1322             if (fixturedef.argname, loc) in seen:
1323                 continue
1324             seen.add((fixturedef.argname, loc))
1325             available.append(
1326                 (
1327                     len(fixturedef.baseid),
1328                     fixturedef.func.__module__,
1329                     curdir.bestrelpath(loc),
1330                     fixturedef.argname,
1331                     fixturedef,
1332                 )
1333             )
1334 
1335     available.sort()
1336     currentmodule = None
1337     for baseid, module, bestrel, argname, fixturedef in available:
1338         if currentmodule != module:
1339             if not module.startswith("_pytest."):
1340                 tw.line()
1341                 tw.sep("-", "fixtures defined from %s" % (module,))
1342                 currentmodule = module
1343         if verbose <= 0 and argname[0] == "_":
1344             continue
1345         if verbose > 0:
1346             funcargspec = "%s -- %s" % (argname, bestrel)
1347         else:
1348             funcargspec = argname
1349         tw.line(funcargspec, green=True)
1350         loc = getlocation(fixturedef.func, curdir)
1351         doc = fixturedef.func.__doc__ or ""
1352         if doc:
1353             write_docstring(tw, doc)
1354         else:
1355             tw.line("    %s: no docstring available" % (loc,), red=True)
1356 
1357 
1358 def write_docstring(tw, doc, indent="    "):
1359     doc = doc.rstrip()
1360     if "\n" in doc:
1361         firstline, rest = doc.split("\n", 1)
1362     else:
1363         firstline, rest = doc, ""
1364 
1365     if firstline.strip():
1366         tw.line(indent + firstline.strip())
1367 
1368     if rest:
1369         for line in dedent(rest).split("\n"):
1370             tw.write(indent + line + "\n")
1371 
1372 
1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):
1374     """ a Function Item is responsible for setting up and executing a
1375     Python test function.
1376     """
1377 
1378     # disable since functions handle it themselves
1379     _ALLOW_MARKERS = False
1380 
1381     def __init__(
1382         self,
1383         name,
1384         parent,
1385         args=None,
1386         config=None,
1387         callspec=None,
1388         callobj=NOTSET,
1389         keywords=None,
1390         session=None,
1391         fixtureinfo=None,
1392         originalname=None,
1393     ):
1394         super(Function, self).__init__(name, parent, config=config, session=session)
1395         self._args = args
1396         if callobj is not NOTSET:
1397             self.obj = callobj
1398 
1399         self.keywords.update(self.obj.__dict__)
1400         self.own_markers.extend(get_unpacked_marks(self.obj))
1401         if callspec:
1402             self.callspec = callspec
1403             # this is total hostile and a mess
1404             # keywords are broken by design by now
1405             # this will be redeemed later
1406             for mark in callspec.marks:
1407                 # feel free to cry, this was broken for years before
1408                 # and keywords cant fix it per design
1409                 self.keywords[mark.name] = mark
1410             self.own_markers.extend(normalize_mark_list(callspec.marks))
1411         if keywords:
1412             self.keywords.update(keywords)
1413 
1414         # todo: this is a hell of a hack
1415         # https://github.com/pytest-dev/pytest/issues/4569
1416 
1417         self.keywords.update(
1418             dict.fromkeys(
1419                 [
1420                     mark.name
1421                     for mark in self.iter_markers()
1422                     if mark.name not in self.keywords
1423                 ],
1424                 True,
1425             )
1426         )
1427 
1428         if fixtureinfo is None:
1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1430                 self, self.obj, self.cls, funcargs=True
1431             )
1432         self._fixtureinfo = fixtureinfo
1433         self.fixturenames = fixtureinfo.names_closure
1434         self._initrequest()
1435 
1436         #: original function name, without any decorations (for example
1437         #: parametrization adds a ``"[...]"`` suffix to function names).
1438         #:
1439         #: .. versionadded:: 3.0
1440         self.originalname = originalname
1441 
1442     def _initrequest(self):
1443         self.funcargs = {}
1444         self._request = fixtures.FixtureRequest(self)
1445 
1446     @property
1447     def function(self):
1448         "underlying python 'function' object"
1449         return getimfunc(self.obj)
1450 
1451     def _getobj(self):
1452         name = self.name
1453         i = name.find("[")  # parametrization
1454         if i != -1:
1455             name = name[:i]
1456         return getattr(self.parent.obj, name)
1457 
1458     @property
1459     def _pyfuncitem(self):
1460         "(compatonly) for code expecting pytest-2.2 style request objects"
1461         return self
1462 
1463     def runtest(self):
1464         """ execute the underlying test function. """
1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1466 
1467     def setup(self):
1468         super(Function, self).setup()
1469         fixtures.fillfixtures(self)
1470 
1471 
1472 class FunctionDefinition(Function):
1473     """
1474     internal hack until we get actual definition nodes instead of the
1475     crappy metafunc hack
1476     """
1477 
1478     def runtest(self):
1479         raise RuntimeError("function definitions are not supposed to be used")
1480 
1481     setup = runtest

</code><intended_behavior>Modify or extend the logic that processes and displays fixture information for the `--fixtures` command-line argument to include the scope of each fixture. The existing functionality of listing fixture names and descriptions should be preserved while enhancing the output to show each fixture's scope (e.g., function, class, module, session) next to its name. This may involve adjusting how fixture information is retrieved and formatting the output to include scope data.</intended_behavior>, <file>src/_pytest/helpconfig.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ version info, help messages, tracing configuration.  """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import os
7 import sys
8 from argparse import Action
9 
10 import py
11 
12 import pytest
13 from _pytest.config import PrintHelp
14 
15 
16 class HelpAction(Action):
17     """This is an argparse Action that will raise an exception in
18     order to skip the rest of the argument parsing when --help is passed.
19     This prevents argparse from quitting due to missing required arguments
20     when any are defined, for example by ``pytest_addoption``.
21     This is similar to the way that the builtin argparse --help option is
22     implemented by raising SystemExit.
23     """
24 
25     def __init__(self, option_strings, dest=None, default=False, help=None):
26         super(HelpAction, self).__init__(
27             option_strings=option_strings,
28             dest=dest,
29             const=True,
30             default=default,
31             nargs=0,
32             help=help,
33         )
34 
35     def __call__(self, parser, namespace, values, option_string=None):
36         setattr(namespace, self.dest, self.const)
37 
38         # We should only skip the rest of the parsing after preparse is done
39         if getattr(parser._parser, "after_preparse", False):
40             raise PrintHelp
41 
42 
43 def pytest_addoption(parser):
44     group = parser.getgroup("debugconfig")
45     group.addoption(
46         "--version",
47         action="store_true",
48         help="display pytest lib version and import information.",
49     )
50     group._addoption(
51         "-h",
52         "--help",
53         action=HelpAction,
54         dest="help",
55         help="show help message and configuration info",
56     )
57     group._addoption(
58         "-p",
59         action="append",
60         dest="plugins",
61         default=[],
62         metavar="name",
63         help="early-load given plugin module name or entry point (multi-allowed). "
64         "To avoid loading of plugins, use the `no:` prefix, e.g. "
65         "`no:doctest`.",
66     )
67     group.addoption(
68         "--traceconfig",
69         "--trace-config",
70         action="store_true",
71         default=False,
72         help="trace considerations of conftest.py files.",
73     ),
74     group.addoption(
75         "--debug",
76         action="store_true",
77         dest="debug",
78         default=False,
79         help="store internal tracing debug information in 'pytestdebug.log'.",
80     )
81     group._addoption(
82         "-o",
83         "--override-ini",
84         dest="override_ini",
85         action="append",
86         help='override ini option with "option=value" style, e.g. `-o xfail_strict=True -o cache_dir=cache`.',
87     )
88 
89 
90 @pytest.hookimpl(hookwrapper=True)
91 def pytest_cmdline_parse():
92     outcome = yield
93     config = outcome.get_result()
94     if config.option.debug:
95         path = os.path.abspath("pytestdebug.log")
96         debugfile = open(path, "w")
97         debugfile.write(
98             "versions pytest-%s, py-%s, "
99             "python-%s\ncwd=%s\nargs=%s\n\n"
100             % (
101                 pytest.__version__,
102                 py.__version__,
103                 ".".join(map(str, sys.version_info)),
104                 os.getcwd(),
105                 config._origargs,
106             )
107         )
108         config.trace.root.setwriter(debugfile.write)
109         undo_tracing = config.pluginmanager.enable_tracing()
110         sys.stderr.write("writing pytestdebug information to %s\n" % path)
111 
112         def unset_tracing():
113             debugfile.close()
114             sys.stderr.write("wrote pytestdebug information to %s\n" % debugfile.name)
115             config.trace.root.setwriter(None)
116             undo_tracing()
117 
118         config.add_cleanup(unset_tracing)
119 
120 
121 def showversion(config):
122     p = py.path.local(pytest.__file__)
123     sys.stderr.write(
124         "This is pytest version %s, imported from %s\n" % (pytest.__version__, p)
125     )
126     plugininfo = getpluginversioninfo(config)
127     if plugininfo:
128         for line in plugininfo:
129             sys.stderr.write(line + "\n")
130 
131 
132 def pytest_cmdline_main(config):
133     if config.option.version:
134         showversion(config)
135         return 0
136     elif config.option.help:
137         config._do_configure()
138         showhelp(config)
139         config._ensure_unconfigure()
140         return 0
141 
142 
143 def showhelp(config):
144     reporter = config.pluginmanager.get_plugin("terminalreporter")
145     tw = reporter._tw
146     tw.write(config._parser.optparser.format_help())
147     tw.line()
148     tw.line()
149     tw.line(
150         "[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:"
151     )
152     tw.line()
153 
154     columns = tw.fullwidth  # costly call
155     for name in config._parser._ininames:
156         help, type, default = config._parser._inidict[name]
157         if type is None:
158             type = "string"
159         spec = "%s (%s)" % (name, type)
160         line = "  %-24s %s" % (spec, help)
161         tw.line(line[:columns])
162 
163     tw.line()
164     tw.line("environment variables:")
165     vars = [
166         ("PYTEST_ADDOPTS", "extra command line options"),
167         ("PYTEST_PLUGINS", "comma-separated plugins to load during startup"),
168         ("PYTEST_DISABLE_PLUGIN_AUTOLOAD", "set to disable plugin auto-loading"),
169         ("PYTEST_DEBUG", "set to enable debug tracing of pytest's internals"),
170     ]
171     for name, help in vars:
172         tw.line("  %-24s %s" % (name, help))
173     tw.line()
174     tw.line()
175 
176     tw.line("to see available markers type: pytest --markers")
177     tw.line("to see available fixtures type: pytest --fixtures")
178     tw.line(
179         "(shown according to specified file_or_dir or current dir "
180         "if not specified; fixtures with leading '_' are only shown "
181         "with the '-v' option"
182     )
183 
184     for warningreport in reporter.stats.get("warnings", []):
185         tw.line("warning : " + warningreport.message, red=True)
186     return
187 
188 
189 conftest_options = [("pytest_plugins", "list of plugin names to load")]
190 
191 
192 def getpluginversioninfo(config):
193     lines = []
194     plugininfo = config.pluginmanager.list_plugin_distinfo()
195     if plugininfo:
196         lines.append("setuptools registered plugins:")
197         for plugin, dist in plugininfo:
198             loc = getattr(plugin, "__file__", repr(plugin))
199             content = "%s-%s at %s" % (dist.project_name, dist.version, loc)
200             lines.append("  " + content)
201     return lines
202 
203 
204 def pytest_report_header(config):
205     lines = []
206     if config.option.debug or config.option.traceconfig:
207         lines.append("using: pytest-%s pylib-%s" % (pytest.__version__, py.__version__))
208 
209         verinfo = getpluginversioninfo(config)
210         if verinfo:
211             lines.extend(verinfo)
212 
213     if config.option.traceconfig:
214         lines.append("active plugins:")
215         items = config.pluginmanager.list_name_plugin()
216         for name, plugin in items:
217             if hasattr(plugin, "__file__"):
218                 r = plugin.__file__
219             else:
220                 r = repr(plugin)
221             lines.append("    %-20s: %s" % (name, r))
222     return lines

</code><intended_behavior>If this file contains logic for the `--fixtures` argument's help text or processing, ensuring that any enhancements or modifications made in `python.py` regarding fixture scope display are consistent and supported here. The help text might need updating to indicate that fixture scope information will also be displayed.</intended_behavior>, <file>src/_pytest/fixtures.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import
2 from __future__ import division
3 from __future__ import print_function
4 
5 import functools
6 import inspect
7 import itertools
8 import sys
9 import warnings
10 from collections import defaultdict
11 from collections import deque
12 from collections import OrderedDict
13 
14 import attr
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import nodes
20 from _pytest._code.code import FormattedExcinfo
21 from _pytest._code.code import TerminalRepr
22 from _pytest.compat import _format_args
23 from _pytest.compat import _PytestWrapper
24 from _pytest.compat import exc_clear
25 from _pytest.compat import FuncargnamesCompatAttr
26 from _pytest.compat import get_real_func
27 from _pytest.compat import get_real_method
28 from _pytest.compat import getfslineno
29 from _pytest.compat import getfuncargnames
30 from _pytest.compat import getimfunc
31 from _pytest.compat import getlocation
32 from _pytest.compat import is_generator
33 from _pytest.compat import isclass
34 from _pytest.compat import NOTSET
35 from _pytest.compat import safe_getattr
36 from _pytest.deprecated import FIXTURE_FUNCTION_CALL
37 from _pytest.deprecated import FIXTURE_NAMED_REQUEST
38 from _pytest.outcomes import fail
39 from _pytest.outcomes import TEST_OUTCOME
40 
41 
42 @attr.s(frozen=True)
43 class PseudoFixtureDef(object):
44     cached_result = attr.ib()
45     scope = attr.ib()
46 
47 
48 def pytest_sessionstart(session):
49     import _pytest.python
50     import _pytest.nodes
51 
52     scopename2class.update(
53         {
54             "package": _pytest.python.Package,
55             "class": _pytest.python.Class,
56             "module": _pytest.python.Module,
57             "function": _pytest.nodes.Item,
58             "session": _pytest.main.Session,
59         }
60     )
61     session._fixturemanager = FixtureManager(session)
62 
63 
64 scopename2class = {}
65 
66 
67 scope2props = dict(session=())
68 scope2props["package"] = ("fspath",)
69 scope2props["module"] = ("fspath", "module")
70 scope2props["class"] = scope2props["module"] + ("cls",)
71 scope2props["instance"] = scope2props["class"] + ("instance",)
72 scope2props["function"] = scope2props["instance"] + ("function", "keywords")
73 
74 
75 def scopeproperty(name=None, doc=None):
76     def decoratescope(func):
77         scopename = name or func.__name__
78 
79         def provide(self):
80             if func.__name__ in scope2props[self.scope]:
81                 return func(self)
82             raise AttributeError(
83                 "%s not available in %s-scoped context" % (scopename, self.scope)
84             )
85 
86         return property(provide, None, None, func.__doc__)
87 
88     return decoratescope
89 
90 
91 def get_scope_package(node, fixturedef):
92     import pytest
93 
94     cls = pytest.Package
95     current = node
96     fixture_package_name = "%s/%s" % (fixturedef.baseid, "__init__.py")
97     while current and (
98         type(current) is not cls or fixture_package_name != current.nodeid
99     ):
100         current = current.parent
101     if current is None:
102         return node.session
103     return current
104 
105 
106 def get_scope_node(node, scope):
107     cls = scopename2class.get(scope)
108     if cls is None:
109         raise ValueError("unknown scope")
110     return node.getparent(cls)
111 
112 
113 def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):
114     # this function will transform all collected calls to a functions
115     # if they use direct funcargs (i.e. direct parametrization)
116     # because we want later test execution to be able to rely on
117     # an existing FixtureDef structure for all arguments.
118     # XXX we can probably avoid this algorithm  if we modify CallSpec2
119     # to directly care for creating the fixturedefs within its methods.
120     if not metafunc._calls[0].funcargs:
121         return  # this function call does not have direct parametrization
122     # collect funcargs of all callspecs into a list of values
123     arg2params = {}
124     arg2scope = {}
125     for callspec in metafunc._calls:
126         for argname, argvalue in callspec.funcargs.items():
127             assert argname not in callspec.params
128             callspec.params[argname] = argvalue
129             arg2params_list = arg2params.setdefault(argname, [])
130             callspec.indices[argname] = len(arg2params_list)
131             arg2params_list.append(argvalue)
132             if argname not in arg2scope:
133                 scopenum = callspec._arg2scopenum.get(argname, scopenum_function)
134                 arg2scope[argname] = scopes[scopenum]
135         callspec.funcargs.clear()
136 
137     # register artificial FixtureDef's so that later at test execution
138     # time we can rely on a proper FixtureDef to exist for fixture setup.
139     arg2fixturedefs = metafunc._arg2fixturedefs
140     for argname, valuelist in arg2params.items():
141         # if we have a scope that is higher than function we need
142         # to make sure we only ever create an according fixturedef on
143         # a per-scope basis. We thus store and cache the fixturedef on the
144         # node related to the scope.
145         scope = arg2scope[argname]
146         node = None
147         if scope != "function":
148             node = get_scope_node(collector, scope)
149             if node is None:
150                 assert scope == "class" and isinstance(collector, _pytest.python.Module)
151                 # use module-level collector for class-scope (for now)
152                 node = collector
153         if node and argname in node._name2pseudofixturedef:
154             arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]
155         else:
156             fixturedef = FixtureDef(
157                 fixturemanager,
158                 "",
159                 argname,
160                 get_direct_param_fixture_func,
161                 arg2scope[argname],
162                 valuelist,
163                 False,
164                 False,
165             )
166             arg2fixturedefs[argname] = [fixturedef]
167             if node is not None:
168                 node._name2pseudofixturedef[argname] = fixturedef
169 
170 
171 def getfixturemarker(obj):
172     """ return fixturemarker or None if it doesn't exist or raised
173     exceptions."""
174     try:
175         return getattr(obj, "_pytestfixturefunction", None)
176     except TEST_OUTCOME:
177         # some objects raise errors like request (from flask import request)
178         # we don't expect them to be fixture functions
179         return None
180 
181 
182 def get_parametrized_fixture_keys(item, scopenum):
183     """ return list of keys for all parametrized arguments which match
184     the specified scope. """
185     assert scopenum < scopenum_function  # function
186     try:
187         cs = item.callspec
188     except AttributeError:
189         pass
190     else:
191         # cs.indices.items() is random order of argnames.  Need to
192         # sort this so that different calls to
193         # get_parametrized_fixture_keys will be deterministic.
194         for argname, param_index in sorted(cs.indices.items()):
195             if cs._arg2scopenum[argname] != scopenum:
196                 continue
197             if scopenum == 0:  # session
198                 key = (argname, param_index)
199             elif scopenum == 1:  # package
200                 key = (argname, param_index, item.fspath.dirpath())
201             elif scopenum == 2:  # module
202                 key = (argname, param_index, item.fspath)
203             elif scopenum == 3:  # class
204                 key = (argname, param_index, item.fspath, item.cls)
205             yield key
206 
207 
208 # algorithm for sorting on a per-parametrized resource setup basis
209 # it is called for scopenum==0 (session) first and performs sorting
210 # down to the lower scopes such as to minimize number of "high scope"
211 # setups and teardowns
212 
213 
214 def reorder_items(items):
215     argkeys_cache = {}
216     items_by_argkey = {}
217     for scopenum in range(0, scopenum_function):
218         argkeys_cache[scopenum] = d = {}
219         items_by_argkey[scopenum] = item_d = defaultdict(deque)
220         for item in items:
221             keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))
222             if keys:
223                 d[item] = keys
224                 for key in keys:
225                     item_d[key].append(item)
226     items = OrderedDict.fromkeys(items)
227     return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))
228 
229 
230 def fix_cache_order(item, argkeys_cache, items_by_argkey):
231     for scopenum in range(0, scopenum_function):
232         for key in argkeys_cache[scopenum].get(item, []):
233             items_by_argkey[scopenum][key].appendleft(item)
234 
235 
236 def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):
237     if scopenum >= scopenum_function or len(items) < 3:
238         return items
239     ignore = set()
240     items_deque = deque(items)
241     items_done = OrderedDict()
242     scoped_items_by_argkey = items_by_argkey[scopenum]
243     scoped_argkeys_cache = argkeys_cache[scopenum]
244     while items_deque:
245         no_argkey_group = OrderedDict()
246         slicing_argkey = None
247         while items_deque:
248             item = items_deque.popleft()
249             if item in items_done or item in no_argkey_group:
250                 continue
251             argkeys = OrderedDict.fromkeys(
252                 k for k in scoped_argkeys_cache.get(item, []) if k not in ignore
253             )
254             if not argkeys:
255                 no_argkey_group[item] = None
256             else:
257                 slicing_argkey, _ = argkeys.popitem()
258                 # we don't have to remove relevant items from later in the deque because they'll just be ignored
259                 matching_items = [
260                     i for i in scoped_items_by_argkey[slicing_argkey] if i in items
261                 ]
262                 for i in reversed(matching_items):
263                     fix_cache_order(i, argkeys_cache, items_by_argkey)
264                     items_deque.appendleft(i)
265                 break
266         if no_argkey_group:
267             no_argkey_group = reorder_items_atscope(
268                 no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1
269             )
270             for item in no_argkey_group:
271                 items_done[item] = None
272         ignore.add(slicing_argkey)
273     return items_done
274 
275 
276 def fillfixtures(function):
277     """ fill missing funcargs for a test function. """
278     try:
279         request = function._request
280     except AttributeError:
281         # XXX this special code path is only expected to execute
282         # with the oejskit plugin.  It uses classes with funcargs
283         # and we thus have to work a bit to allow this.
284         fm = function.session._fixturemanager
285         fi = fm.getfixtureinfo(function.parent, function.obj, None)
286         function._fixtureinfo = fi
287         request = function._request = FixtureRequest(function)
288         request._fillfixtures()
289         # prune out funcargs for jstests
290         newfuncargs = {}
291         for name in fi.argnames:
292             newfuncargs[name] = function.funcargs[name]
293         function.funcargs = newfuncargs
294     else:
295         request._fillfixtures()
296 
297 
298 def get_direct_param_fixture_func(request):
299     return request.param
300 
301 
302 @attr.s(slots=True)
303 class FuncFixtureInfo(object):
304     # original function argument names
305     argnames = attr.ib(type=tuple)
306     # argnames that function immediately requires. These include argnames +
307     # fixture names specified via usefixtures and via autouse=True in fixture
308     # definitions.
309     initialnames = attr.ib(type=tuple)
310     names_closure = attr.ib()  # List[str]
311     name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]
312 
313     def prune_dependency_tree(self):
314         """Recompute names_closure from initialnames and name2fixturedefs
315 
316         Can only reduce names_closure, which means that the new closure will
317         always be a subset of the old one. The order is preserved.
318 
319         This method is needed because direct parametrization may shadow some
320         of the fixtures that were included in the originally built dependency
321         tree. In this way the dependency tree can get pruned, and the closure
322         of argnames may get reduced.
323         """
324         closure = set()
325         working_set = set(self.initialnames)
326         while working_set:
327             argname = working_set.pop()
328             # argname may be smth not included in the original names_closure,
329             # in which case we ignore it. This currently happens with pseudo
330             # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.
331             # So they introduce the new dependency 'request' which might have
332             # been missing in the original tree (closure).
333             if argname not in closure and argname in self.names_closure:
334                 closure.add(argname)
335                 if argname in self.name2fixturedefs:
336                     working_set.update(self.name2fixturedefs[argname][-1].argnames)
337 
338         self.names_closure[:] = sorted(closure, key=self.names_closure.index)
339 
340 
341 class FixtureRequest(FuncargnamesCompatAttr):
342     """ A request for a fixture from a test or fixture function.
343 
344     A request object gives access to the requesting test context
345     and has an optional ``param`` attribute in case
346     the fixture is parametrized indirectly.
347     """
348 
349     def __init__(self, pyfuncitem):
350         self._pyfuncitem = pyfuncitem
351         #: fixture for which this request is being performed
352         self.fixturename = None
353         #: Scope string, one of "function", "class", "module", "session"
354         self.scope = "function"
355         self._fixture_defs = {}  # argname -> FixtureDef
356         fixtureinfo = pyfuncitem._fixtureinfo
357         self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()
358         self._arg2index = {}
359         self._fixturemanager = pyfuncitem.session._fixturemanager
360 
361     @property
362     def fixturenames(self):
363         """names of all active fixtures in this request"""
364         result = list(self._pyfuncitem._fixtureinfo.names_closure)
365         result.extend(set(self._fixture_defs).difference(result))
366         return result
367 
368     @property
369     def node(self):
370         """ underlying collection node (depends on current request scope)"""
371         return self._getscopeitem(self.scope)
372 
373     def _getnextfixturedef(self, argname):
374         fixturedefs = self._arg2fixturedefs.get(argname, None)
375         if fixturedefs is None:
376             # we arrive here because of a dynamic call to
377             # getfixturevalue(argname) usage which was naturally
378             # not known at parsing/collection time
379             parentid = self._pyfuncitem.parent.nodeid
380             fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)
381             self._arg2fixturedefs[argname] = fixturedefs
382         # fixturedefs list is immutable so we maintain a decreasing index
383         index = self._arg2index.get(argname, 0) - 1
384         if fixturedefs is None or (-index > len(fixturedefs)):
385             raise FixtureLookupError(argname, self)
386         self._arg2index[argname] = index
387         return fixturedefs[index]
388 
389     @property
390     def config(self):
391         """ the pytest config object associated with this request. """
392         return self._pyfuncitem.config
393 
394     @scopeproperty()
395     def function(self):
396         """ test function object if the request has a per-function scope. """
397         return self._pyfuncitem.obj
398 
399     @scopeproperty("class")
400     def cls(self):
401         """ class (can be None) where the test function was collected. """
402         clscol = self._pyfuncitem.getparent(_pytest.python.Class)
403         if clscol:
404             return clscol.obj
405 
406     @property
407     def instance(self):
408         """ instance (can be None) on which test function was collected. """
409         # unittest support hack, see _pytest.unittest.TestCaseFunction
410         try:
411             return self._pyfuncitem._testcase
412         except AttributeError:
413             function = getattr(self, "function", None)
414             return getattr(function, "__self__", None)
415 
416     @scopeproperty()
417     def module(self):
418         """ python module object where the test function was collected. """
419         return self._pyfuncitem.getparent(_pytest.python.Module).obj
420 
421     @scopeproperty()
422     def fspath(self):
423         """ the file system path of the test module which collected this test. """
424         return self._pyfuncitem.fspath
425 
426     @property
427     def keywords(self):
428         """ keywords/markers dictionary for the underlying node. """
429         return self.node.keywords
430 
431     @property
432     def session(self):
433         """ pytest session object. """
434         return self._pyfuncitem.session
435 
436     def addfinalizer(self, finalizer):
437         """ add finalizer/teardown function to be called after the
438         last test within the requesting test context finished
439         execution. """
440         # XXX usually this method is shadowed by fixturedef specific ones
441         self._addfinalizer(finalizer, scope=self.scope)
442 
443     def _addfinalizer(self, finalizer, scope):
444         colitem = self._getscopeitem(scope)
445         self._pyfuncitem.session._setupstate.addfinalizer(
446             finalizer=finalizer, colitem=colitem
447         )
448 
449     def applymarker(self, marker):
450         """ Apply a marker to a single test function invocation.
451         This method is useful if you don't want to have a keyword/marker
452         on all function invocations.
453 
454         :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object
455             created by a call to ``pytest.mark.NAME(...)``.
456         """
457         self.node.add_marker(marker)
458 
459     def raiseerror(self, msg):
460         """ raise a FixtureLookupError with the given message. """
461         raise self._fixturemanager.FixtureLookupError(None, self, msg)
462 
463     def _fillfixtures(self):
464         item = self._pyfuncitem
465         fixturenames = getattr(item, "fixturenames", self.fixturenames)
466         for argname in fixturenames:
467             if argname not in item.funcargs:
468                 item.funcargs[argname] = self.getfixturevalue(argname)
469 
470     def getfixturevalue(self, argname):
471         """ Dynamically run a named fixture function.
472 
473         Declaring fixtures via function argument is recommended where possible.
474         But if you can only decide whether to use another fixture at test
475         setup time, you may use this function to retrieve it inside a fixture
476         or test function body.
477         """
478         return self._get_active_fixturedef(argname).cached_result[0]
479 
480     def getfuncargvalue(self, argname):
481         """ Deprecated, use getfixturevalue. """
482         from _pytest import deprecated
483 
484         warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)
485         return self.getfixturevalue(argname)
486 
487     def _get_active_fixturedef(self, argname):
488         try:
489             return self._fixture_defs[argname]
490         except KeyError:
491             try:
492                 fixturedef = self._getnextfixturedef(argname)
493             except FixtureLookupError:
494                 if argname == "request":
495                     cached_result = (self, [0], None)
496                     scope = "function"
497                     return PseudoFixtureDef(cached_result, scope)
498                 raise
499         # remove indent to prevent the python3 exception
500         # from leaking into the call
501         self._compute_fixture_value(fixturedef)
502         self._fixture_defs[argname] = fixturedef
503         return fixturedef
504 
505     def _get_fixturestack(self):
506         current = self
507         values = []
508         while 1:
509             fixturedef = getattr(current, "_fixturedef", None)
510             if fixturedef is None:
511                 values.reverse()
512                 return values
513             values.append(fixturedef)
514             current = current._parent_request
515 
516     def _compute_fixture_value(self, fixturedef):
517         """
518         Creates a SubRequest based on "self" and calls the execute method of the given fixturedef object. This will
519         force the FixtureDef object to throw away any previous results and compute a new fixture value, which
520         will be stored into the FixtureDef object itself.
521 
522         :param FixtureDef fixturedef:
523         """
524         # prepare a subrequest object before calling fixture function
525         # (latter managed by fixturedef)
526         argname = fixturedef.argname
527         funcitem = self._pyfuncitem
528         scope = fixturedef.scope
529         try:
530             param = funcitem.callspec.getparam(argname)
531         except (AttributeError, ValueError):
532             param = NOTSET
533             param_index = 0
534             has_params = fixturedef.params is not None
535             fixtures_not_supported = getattr(funcitem, "nofuncargs", False)
536             if has_params and fixtures_not_supported:
537                 msg = (
538                     "{name} does not support fixtures, maybe unittest.TestCase subclass?\n"
539                     "Node id: {nodeid}\n"
540                     "Function type: {typename}"
541                 ).format(
542                     name=funcitem.name,
543                     nodeid=funcitem.nodeid,
544                     typename=type(funcitem).__name__,
545                 )
546                 fail(msg, pytrace=False)
547             if has_params:
548                 frame = inspect.stack()[3]
549                 frameinfo = inspect.getframeinfo(frame[0])
550                 source_path = frameinfo.filename
551                 source_lineno = frameinfo.lineno
552                 source_path = py.path.local(source_path)
553                 if source_path.relto(funcitem.config.rootdir):
554                     source_path = source_path.relto(funcitem.config.rootdir)
555                 msg = (
556                     "The requested fixture has no parameter defined for test:\n"
557                     "    {}\n\n"
558                     "Requested fixture '{}' defined in:\n{}"
559                     "\n\nRequested here:\n{}:{}".format(
560                         funcitem.nodeid,
561                         fixturedef.argname,
562                         getlocation(fixturedef.func, funcitem.config.rootdir),
563                         source_path,
564                         source_lineno,
565                     )
566                 )
567                 fail(msg, pytrace=False)
568         else:
569             param_index = funcitem.callspec.indices[argname]
570             # if a parametrize invocation set a scope it will override
571             # the static scope defined with the fixture function
572             paramscopenum = funcitem.callspec._arg2scopenum.get(argname)
573             if paramscopenum is not None:
574                 scope = scopes[paramscopenum]
575 
576         subrequest = SubRequest(self, scope, param, param_index, fixturedef)
577 
578         # check if a higher-level scoped fixture accesses a lower level one
579         subrequest._check_scope(argname, self.scope, scope)
580 
581         # clear sys.exc_info before invoking the fixture (python bug?)
582         # if it's not explicitly cleared it will leak into the call
583         exc_clear()
584         try:
585             # call the fixture function
586             fixturedef.execute(request=subrequest)
587         finally:
588             self._schedule_finalizers(fixturedef, subrequest)
589 
590     def _schedule_finalizers(self, fixturedef, subrequest):
591         # if fixture function failed it might have registered finalizers
592         self.session._setupstate.addfinalizer(
593             functools.partial(fixturedef.finish, request=subrequest), subrequest.node
594         )
595 
596     def _check_scope(self, argname, invoking_scope, requested_scope):
597         if argname == "request":
598             return
599         if scopemismatch(invoking_scope, requested_scope):
600             # try to report something helpful
601             lines = self._factorytraceback()
602             fail(
603                 "ScopeMismatch: You tried to access the %r scoped "
604                 "fixture %r with a %r scoped request object, "
605                 "involved factories\n%s"
606                 % ((requested_scope, argname, invoking_scope, "\n".join(lines))),
607                 pytrace=False,
608             )
609 
610     def _factorytraceback(self):
611         lines = []
612         for fixturedef in self._get_fixturestack():
613             factory = fixturedef.func
614             fs, lineno = getfslineno(factory)
615             p = self._pyfuncitem.session.fspath.bestrelpath(fs)
616             args = _format_args(factory)
617             lines.append("%s:%d:  def %s%s" % (p, lineno + 1, factory.__name__, args))
618         return lines
619 
620     def _getscopeitem(self, scope):
621         if scope == "function":
622             # this might also be a non-function Item despite its attribute name
623             return self._pyfuncitem
624         if scope == "package":
625             node = get_scope_package(self._pyfuncitem, self._fixturedef)
626         else:
627             node = get_scope_node(self._pyfuncitem, scope)
628         if node is None and scope == "class":
629             # fallback to function item itself
630             node = self._pyfuncitem
631         assert node, 'Could not obtain a node for scope "{}" for function {!r}'.format(
632             scope, self._pyfuncitem
633         )
634         return node
635 
636     def __repr__(self):
637         return "<FixtureRequest for %r>" % (self.node)
638 
639 
640 class SubRequest(FixtureRequest):
641     """ a sub request for handling getting a fixture from a
642     test function/fixture. """
643 
644     def __init__(self, request, scope, param, param_index, fixturedef):
645         self._parent_request = request
646         self.fixturename = fixturedef.argname
647         if param is not NOTSET:
648             self.param = param
649         self.param_index = param_index
650         self.scope = scope
651         self._fixturedef = fixturedef
652         self._pyfuncitem = request._pyfuncitem
653         self._fixture_defs = request._fixture_defs
654         self._arg2fixturedefs = request._arg2fixturedefs
655         self._arg2index = request._arg2index
656         self._fixturemanager = request._fixturemanager
657 
658     def __repr__(self):
659         return "<SubRequest %r for %r>" % (self.fixturename, self._pyfuncitem)
660 
661     def addfinalizer(self, finalizer):
662         self._fixturedef.addfinalizer(finalizer)
663 
664     def _schedule_finalizers(self, fixturedef, subrequest):
665         # if the executing fixturedef was not explicitly requested in the argument list (via
666         # getfixturevalue inside the fixture call) then ensure this fixture def will be finished
667         # first
668         if fixturedef.argname not in self.funcargnames:
669             fixturedef.addfinalizer(
670                 functools.partial(self._fixturedef.finish, request=self)
671             )
672         super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)
673 
674 
675 scopes = "session package module class function".split()
676 scopenum_function = scopes.index("function")
677 
678 
679 def scopemismatch(currentscope, newscope):
680     return scopes.index(newscope) > scopes.index(currentscope)
681 
682 
683 def scope2index(scope, descr, where=None):
684     """Look up the index of ``scope`` and raise a descriptive value error
685     if not defined.
686     """
687     try:
688         return scopes.index(scope)
689     except ValueError:
690         fail(
691             "{} {}got an unexpected scope value '{}'".format(
692                 descr, "from {} ".format(where) if where else "", scope
693             ),
694             pytrace=False,
695         )
696 
697 
698 class FixtureLookupError(LookupError):
699     """ could not return a requested Fixture (missing or invalid). """
700 
701     def __init__(self, argname, request, msg=None):
702         self.argname = argname
703         self.request = request
704         self.fixturestack = request._get_fixturestack()
705         self.msg = msg
706 
707     def formatrepr(self):
708         tblines = []
709         addline = tblines.append
710         stack = [self.request._pyfuncitem.obj]
711         stack.extend(map(lambda x: x.func, self.fixturestack))
712         msg = self.msg
713         if msg is not None:
714             # the last fixture raise an error, let's present
715             # it at the requesting side
716             stack = stack[:-1]
717         for function in stack:
718             fspath, lineno = getfslineno(function)
719             try:
720                 lines, _ = inspect.getsourcelines(get_real_func(function))
721             except (IOError, IndexError, TypeError):
722                 error_msg = "file %s, line %s: source code not available"
723                 addline(error_msg % (fspath, lineno + 1))
724             else:
725                 addline("file %s, line %s" % (fspath, lineno + 1))
726                 for i, line in enumerate(lines):
727                     line = line.rstrip()
728                     addline("  " + line)
729                     if line.lstrip().startswith("def"):
730                         break
731 
732         if msg is None:
733             fm = self.request._fixturemanager
734             available = set()
735             parentid = self.request._pyfuncitem.parent.nodeid
736             for name, fixturedefs in fm._arg2fixturedefs.items():
737                 faclist = list(fm._matchfactories(fixturedefs, parentid))
738                 if faclist:
739                     available.add(name)
740             if self.argname in available:
741                 msg = " recursive dependency involving fixture '{}' detected".format(
742                     self.argname
743                 )
744             else:
745                 msg = "fixture '{}' not found".format(self.argname)
746             msg += "\n available fixtures: {}".format(", ".join(sorted(available)))
747             msg += "\n use 'pytest --fixtures [testpath]' for help on them."
748 
749         return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)
750 
751 
752 class FixtureLookupErrorRepr(TerminalRepr):
753     def __init__(self, filename, firstlineno, tblines, errorstring, argname):
754         self.tblines = tblines
755         self.errorstring = errorstring
756         self.filename = filename
757         self.firstlineno = firstlineno
758         self.argname = argname
759 
760     def toterminal(self, tw):
761         # tw.line("FixtureLookupError: %s" %(self.argname), red=True)
762         for tbline in self.tblines:
763             tw.line(tbline.rstrip())
764         lines = self.errorstring.split("\n")
765         if lines:
766             tw.line(
767                 "{}       {}".format(FormattedExcinfo.fail_marker, lines[0].strip()),
768                 red=True,
769             )
770             for line in lines[1:]:
771                 tw.line(
772                     "{}       {}".format(FormattedExcinfo.flow_marker, line.strip()),
773                     red=True,
774                 )
775         tw.line()
776         tw.line("%s:%d" % (self.filename, self.firstlineno + 1))
777 
778 
779 def fail_fixturefunc(fixturefunc, msg):
780     fs, lineno = getfslineno(fixturefunc)
781     location = "%s:%s" % (fs, lineno + 1)
782     source = _pytest._code.Source(fixturefunc)
783     fail(msg + ":\n\n" + str(source.indent()) + "\n" + location, pytrace=False)
784 
785 
786 def call_fixture_func(fixturefunc, request, kwargs):
787     yieldctx = is_generator(fixturefunc)
788     if yieldctx:
789         it = fixturefunc(**kwargs)
790         res = next(it)
791         finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)
792         request.addfinalizer(finalizer)
793     else:
794         res = fixturefunc(**kwargs)
795     return res
796 
797 
798 def _teardown_yield_fixture(fixturefunc, it):
799     """Executes the teardown of a fixture function by advancing the iterator after the
800     yield and ensure the iteration ends (if not it means there is more than one yield in the function)"""
801     try:
802         next(it)
803     except StopIteration:
804         pass
805     else:
806         fail_fixturefunc(
807             fixturefunc, "yield_fixture function has more than one 'yield'"
808         )
809 
810 
811 class FixtureDef(object):
812     """ A container for a factory definition. """
813 
814     def __init__(
815         self,
816         fixturemanager,
817         baseid,
818         argname,
819         func,
820         scope,
821         params,
822         unittest=False,
823         ids=None,
824     ):
825         self._fixturemanager = fixturemanager
826         self.baseid = baseid or ""
827         self.has_location = baseid is not None
828         self.func = func
829         self.argname = argname
830         self.scope = scope
831         self.scopenum = scope2index(
832             scope or "function",
833             descr="Fixture '{}'".format(func.__name__),
834             where=baseid,
835         )
836         self.params = params
837         self.argnames = getfuncargnames(func, is_method=unittest)
838         self.unittest = unittest
839         self.ids = ids
840         self._finalizers = []
841 
842     def addfinalizer(self, finalizer):
843         self._finalizers.append(finalizer)
844 
845     def finish(self, request):
846         exceptions = []
847         try:
848             while self._finalizers:
849                 try:
850                     func = self._finalizers.pop()
851                     func()
852                 except:  # noqa
853                     exceptions.append(sys.exc_info())
854             if exceptions:
855                 e = exceptions[0]
856                 del (
857                     exceptions
858                 )  # ensure we don't keep all frames alive because of the traceback
859                 six.reraise(*e)
860 
861         finally:
862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)
864             # even if finalization fails, we invalidate
865             # the cached fixture value and remove
866             # all finalizers because they may be bound methods which will
867             # keep instances alive
868             if hasattr(self, "cached_result"):
869                 del self.cached_result
870             self._finalizers = []
871 
872     def execute(self, request):
873         # get required arguments and register our own finish()
874         # with their finalization
875         for argname in self.argnames:
876             fixturedef = request._get_active_fixturedef(argname)
877             if argname != "request":
878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))
879 
880         my_cache_key = request.param_index
881         cached_result = getattr(self, "cached_result", None)
882         if cached_result is not None:
883             result, cache_key, err = cached_result
884             if my_cache_key == cache_key:
885                 if err is not None:
886                     six.reraise(*err)
887                 else:
888                     return result
889             # we have a previous but differently parametrized fixture instance
890             # so we need to tear it down before creating a new one
891             self.finish(request)
892             assert not hasattr(self, "cached_result")
893 
894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
895         return hook.pytest_fixture_setup(fixturedef=self, request=request)
896 
897     def __repr__(self):
898         return "<FixtureDef argname=%r scope=%r baseid=%r>" % (
899             self.argname,
900             self.scope,
901             self.baseid,
902         )
903 
904 
905 def resolve_fixture_function(fixturedef, request):
906     """Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific
907     instances and bound methods.
908     """
909     fixturefunc = fixturedef.func
910     if fixturedef.unittest:
911         if request.instance is not None:
912             # bind the unbound method to the TestCase instance
913             fixturefunc = fixturedef.func.__get__(request.instance)
914     else:
915         # the fixture function needs to be bound to the actual
916         # request.instance so that code working with "fixturedef" behaves
917         # as expected.
918         if request.instance is not None:
919             fixturefunc = getimfunc(fixturedef.func)
920             if fixturefunc != fixturedef.func:
921                 fixturefunc = fixturefunc.__get__(request.instance)
922     return fixturefunc
923 
924 
925 def pytest_fixture_setup(fixturedef, request):
926     """ Execution of fixture setup. """
927     kwargs = {}
928     for argname in fixturedef.argnames:
929         fixdef = request._get_active_fixturedef(argname)
930         result, arg_cache_key, exc = fixdef.cached_result
931         request._check_scope(argname, request.scope, fixdef.scope)
932         kwargs[argname] = result
933 
934     fixturefunc = resolve_fixture_function(fixturedef, request)
935     my_cache_key = request.param_index
936     try:
937         result = call_fixture_func(fixturefunc, request, kwargs)
938     except TEST_OUTCOME:
939         fixturedef.cached_result = (None, my_cache_key, sys.exc_info())
940         raise
941     fixturedef.cached_result = (result, my_cache_key, None)
942     return result
943 
944 
945 def _ensure_immutable_ids(ids):
946     if ids is None:
947         return
948     if callable(ids):
949         return ids
950     return tuple(ids)
951 
952 
953 def wrap_function_to_error_out_if_called_directly(function, fixture_marker):
954     """Wrap the given fixture function so we can raise an error about it being called directly,
955     instead of used as an argument in a test function.
956     """
957     message = FIXTURE_FUNCTION_CALL.format(
958         name=fixture_marker.name or function.__name__
959     )
960 
961     @six.wraps(function)
962     def result(*args, **kwargs):
963         fail(message, pytrace=False)
964 
965     # keep reference to the original function in our own custom attribute so we don't unwrap
966     # further than this point and lose useful wrappings like @mock.patch (#3774)
967     result.__pytest_wrapped__ = _PytestWrapper(function)
968 
969     return result
970 
971 
972 @attr.s(frozen=True)
973 class FixtureFunctionMarker(object):
974     scope = attr.ib()
975     params = attr.ib(converter=attr.converters.optional(tuple))
976     autouse = attr.ib(default=False)
977     ids = attr.ib(default=None, converter=_ensure_immutable_ids)
978     name = attr.ib(default=None)
979 
980     def __call__(self, function):
981         if isclass(function):
982             raise ValueError("class fixtures not supported (maybe in the future)")
983 
984         if getattr(function, "_pytestfixturefunction", False):
985             raise ValueError(
986                 "fixture is being applied more than once to the same function"
987             )
988 
989         function = wrap_function_to_error_out_if_called_directly(function, self)
990 
991         name = self.name or function.__name__
992         if name == "request":
993             warnings.warn(FIXTURE_NAMED_REQUEST)
994         function._pytestfixturefunction = self
995         return function
996 
997 
998 def fixture(scope="function", params=None, autouse=False, ids=None, name=None):
999     """Decorator to mark a fixture factory function.
1000 
1001     This decorator can be used, with or without parameters, to define a
1002     fixture function.
1003 
1004     The name of the fixture function can later be referenced to cause its
1005     invocation ahead of running tests: test
1006     modules or classes can use the ``pytest.mark.usefixtures(fixturename)``
1007     marker.
1008 
1009     Test functions can directly use fixture names as input
1010     arguments in which case the fixture instance returned from the fixture
1011     function will be injected.
1012 
1013     Fixtures can provide their values to test functions using ``return`` or ``yield``
1014     statements. When using ``yield`` the code block after the ``yield`` statement is executed
1015     as teardown code regardless of the test outcome, and must yield exactly once.
1016 
1017     :arg scope: the scope for which this fixture is shared, one of
1018                 ``"function"`` (default), ``"class"``, ``"module"``,
1019                 ``"package"`` or ``"session"``.
1020 
1021                 ``"package"`` is considered **experimental** at this time.
1022 
1023     :arg params: an optional list of parameters which will cause multiple
1024                 invocations of the fixture function and all of the tests
1025                 using it.
1026                 The current parameter is available in ``request.param``.
1027 
1028     :arg autouse: if True, the fixture func is activated for all tests that
1029                 can see it.  If False (the default) then an explicit
1030                 reference is needed to activate the fixture.
1031 
1032     :arg ids: list of string ids each corresponding to the params
1033                 so that they are part of the test id. If no ids are provided
1034                 they will be generated automatically from the params.
1035 
1036     :arg name: the name of the fixture. This defaults to the name of the
1037                 decorated function. If a fixture is used in the same module in
1038                 which it is defined, the function name of the fixture will be
1039                 shadowed by the function arg that requests the fixture; one way
1040                 to resolve this is to name the decorated function
1041                 ``fixture_<fixturename>`` and then use
1042                 ``@pytest.fixture(name='<fixturename>')``.
1043     """
1044     if callable(scope) and params is None and autouse is False:
1045         # direct decoration
1046         return FixtureFunctionMarker("function", params, autouse, name=name)(scope)
1047     if params is not None and not isinstance(params, (list, tuple)):
1048         params = list(params)
1049     return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)
1050 
1051 
1052 def yield_fixture(scope="function", params=None, autouse=False, ids=None, name=None):
1053     """ (return a) decorator to mark a yield-fixture factory function.
1054 
1055     .. deprecated:: 3.0
1056         Use :py:func:`pytest.fixture` directly instead.
1057     """
1058     return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)
1059 
1060 
1061 defaultfuncargprefixmarker = fixture()
1062 
1063 
1064 @fixture(scope="session")
1065 def pytestconfig(request):
1066     """Session-scoped fixture that returns the :class:`_pytest.config.Config` object.
1067 
1068     Example::
1069 
1070         def test_foo(pytestconfig):
1071             if pytestconfig.getoption("verbose") > 0:
1072                 ...
1073 
1074     """
1075     return request.config
1076 
1077 
1078 class FixtureManager(object):
1079     """
1080     pytest fixtures definitions and information is stored and managed
1081     from this class.
1082 
1083     During collection fm.parsefactories() is called multiple times to parse
1084     fixture function definitions into FixtureDef objects and internal
1085     data structures.
1086 
1087     During collection of test functions, metafunc-mechanics instantiate
1088     a FuncFixtureInfo object which is cached per node/func-name.
1089     This FuncFixtureInfo object is later retrieved by Function nodes
1090     which themselves offer a fixturenames attribute.
1091 
1092     The FuncFixtureInfo object holds information about fixtures and FixtureDefs
1093     relevant for a particular function.  An initial list of fixtures is
1094     assembled like this:
1095 
1096     - ini-defined usefixtures
1097     - autouse-marked fixtures along the collection chain up from the function
1098     - usefixtures markers at module/class/function level
1099     - test function funcargs
1100 
1101     Subsequently the funcfixtureinfo.fixturenames attribute is computed
1102     as the closure of the fixtures needed to setup the initial fixtures,
1103     i. e. fixtures needed by fixture functions themselves are appended
1104     to the fixturenames list.
1105 
1106     Upon the test-setup phases all fixturenames are instantiated, retrieved
1107     by a lookup of their FuncFixtureInfo.
1108     """
1109 
1110     FixtureLookupError = FixtureLookupError
1111     FixtureLookupErrorRepr = FixtureLookupErrorRepr
1112 
1113     def __init__(self, session):
1114         self.session = session
1115         self.config = session.config
1116         self._arg2fixturedefs = {}
1117         self._holderobjseen = set()
1118         self._arg2finish = {}
1119         self._nodeid_and_autousenames = [("", self.config.getini("usefixtures"))]
1120         session.config.pluginmanager.register(self, "funcmanage")
1121 
1122     def getfixtureinfo(self, node, func, cls, funcargs=True):
1123         if funcargs and not getattr(node, "nofuncargs", False):
1124             argnames = getfuncargnames(func, cls=cls)
1125         else:
1126             argnames = ()
1127         usefixtures = itertools.chain.from_iterable(
1128             mark.args for mark in node.iter_markers(name="usefixtures")
1129         )
1130         initialnames = tuple(usefixtures) + argnames
1131         fm = node.session._fixturemanager
1132         initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(
1133             initialnames, node
1134         )
1135         return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)
1136 
1137     def pytest_plugin_registered(self, plugin):
1138         nodeid = None
1139         try:
1140             p = py.path.local(plugin.__file__).realpath()
1141         except AttributeError:
1142             pass
1143         else:
1144             # construct the base nodeid which is later used to check
1145             # what fixtures are visible for particular tests (as denoted
1146             # by their test id)
1147             if p.basename.startswith("conftest.py"):
1148                 nodeid = p.dirpath().relto(self.config.rootdir)
1149                 if p.sep != nodes.SEP:
1150                     nodeid = nodeid.replace(p.sep, nodes.SEP)
1151 
1152         self.parsefactories(plugin, nodeid)
1153 
1154     def _getautousenames(self, nodeid):
1155         """ return a tuple of fixture names to be used. """
1156         autousenames = []
1157         for baseid, basenames in self._nodeid_and_autousenames:
1158             if nodeid.startswith(baseid):
1159                 if baseid:
1160                     i = len(baseid)
1161                     nextchar = nodeid[i : i + 1]
1162                     if nextchar and nextchar not in ":/":
1163                         continue
1164                 autousenames.extend(basenames)
1165         return autousenames
1166 
1167     def getfixtureclosure(self, fixturenames, parentnode):
1168         # collect the closure of all fixtures , starting with the given
1169         # fixturenames as the initial set.  As we have to visit all
1170         # factory definitions anyway, we also return an arg2fixturedefs
1171         # mapping so that the caller can reuse it and does not have
1172         # to re-discover fixturedefs again for each fixturename
1173         # (discovering matching fixtures for a given name/node is expensive)
1174 
1175         parentid = parentnode.nodeid
1176         fixturenames_closure = self._getautousenames(parentid)
1177 
1178         def merge(otherlist):
1179             for arg in otherlist:
1180                 if arg not in fixturenames_closure:
1181                     fixturenames_closure.append(arg)
1182 
1183         merge(fixturenames)
1184 
1185         # at this point, fixturenames_closure contains what we call "initialnames",
1186         # which is a set of fixturenames the function immediately requests. We
1187         # need to return it as well, so save this.
1188         initialnames = tuple(fixturenames_closure)
1189 
1190         arg2fixturedefs = {}
1191         lastlen = -1
1192         while lastlen != len(fixturenames_closure):
1193             lastlen = len(fixturenames_closure)
1194             for argname in fixturenames_closure:
1195                 if argname in arg2fixturedefs:
1196                     continue
1197                 fixturedefs = self.getfixturedefs(argname, parentid)
1198                 if fixturedefs:
1199                     arg2fixturedefs[argname] = fixturedefs
1200                     merge(fixturedefs[-1].argnames)
1201 
1202         def sort_by_scope(arg_name):
1203             try:
1204                 fixturedefs = arg2fixturedefs[arg_name]
1205             except KeyError:
1206                 return scopes.index("function")
1207             else:
1208                 return fixturedefs[-1].scopenum
1209 
1210         fixturenames_closure.sort(key=sort_by_scope)
1211         return initialnames, fixturenames_closure, arg2fixturedefs
1212 
1213     def pytest_generate_tests(self, metafunc):
1214         for argname in metafunc.fixturenames:
1215             faclist = metafunc._arg2fixturedefs.get(argname)
1216             if faclist:
1217                 fixturedef = faclist[-1]
1218                 if fixturedef.params is not None:
1219                     markers = list(metafunc.definition.iter_markers("parametrize"))
1220                     for parametrize_mark in markers:
1221                         if "argnames" in parametrize_mark.kwargs:
1222                             argnames = parametrize_mark.kwargs["argnames"]
1223                         else:
1224                             argnames = parametrize_mark.args[0]
1225 
1226                         if not isinstance(argnames, (tuple, list)):
1227                             argnames = [
1228                                 x.strip() for x in argnames.split(",") if x.strip()
1229                             ]
1230                         if argname in argnames:
1231                             break
1232                     else:
1233                         metafunc.parametrize(
1234                             argname,
1235                             fixturedef.params,
1236                             indirect=True,
1237                             scope=fixturedef.scope,
1238                             ids=fixturedef.ids,
1239                         )
1240             else:
1241                 continue  # will raise FixtureLookupError at setup time
1242 
1243     def pytest_collection_modifyitems(self, items):
1244         # separate parametrized setups
1245         items[:] = reorder_items(items)
1246 
1247     def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):
1248         if nodeid is not NOTSET:
1249             holderobj = node_or_obj
1250         else:
1251             holderobj = node_or_obj.obj
1252             nodeid = node_or_obj.nodeid
1253         if holderobj in self._holderobjseen:
1254             return
1255 
1256         self._holderobjseen.add(holderobj)
1257         autousenames = []
1258         for name in dir(holderobj):
1259             # The attribute can be an arbitrary descriptor, so the attribute
1260             # access below can raise. safe_getatt() ignores such exceptions.
1261             obj = safe_getattr(holderobj, name, None)
1262             marker = getfixturemarker(obj)
1263             if not isinstance(marker, FixtureFunctionMarker):
1264                 # magic globals  with __getattr__ might have got us a wrong
1265                 # fixture attribute
1266                 continue
1267 
1268             if marker.name:
1269                 name = marker.name
1270 
1271             # during fixture definition we wrap the original fixture function
1272             # to issue a warning if called directly, so here we unwrap it in order to not emit the warning
1273             # when pytest itself calls the fixture function
1274             if six.PY2 and unittest:
1275                 # hack on Python 2 because of the unbound methods
1276                 obj = get_real_func(obj)
1277             else:
1278                 obj = get_real_method(obj, holderobj)
1279 
1280             fixture_def = FixtureDef(
1281                 self,
1282                 nodeid,
1283                 name,
1284                 obj,
1285                 marker.scope,
1286                 marker.params,
1287                 unittest=unittest,
1288                 ids=marker.ids,
1289             )
1290 
1291             faclist = self._arg2fixturedefs.setdefault(name, [])
1292             if fixture_def.has_location:
1293                 faclist.append(fixture_def)
1294             else:
1295                 # fixturedefs with no location are at the front
1296                 # so this inserts the current fixturedef after the
1297                 # existing fixturedefs from external plugins but
1298                 # before the fixturedefs provided in conftests.
1299                 i = len([f for f in faclist if not f.has_location])
1300                 faclist.insert(i, fixture_def)
1301             if marker.autouse:
1302                 autousenames.append(name)
1303 
1304         if autousenames:
1305             self._nodeid_and_autousenames.append((nodeid or "", autousenames))
1306 
1307     def getfixturedefs(self, argname, nodeid):
1308         """
1309         Gets a list of fixtures which are applicable to the given node id.
1310 
1311         :param str argname: name of the fixture to search for
1312         :param str nodeid: full node id of the requesting test.
1313         :return: list[FixtureDef]
1314         """
1315         try:
1316             fixturedefs = self._arg2fixturedefs[argname]
1317         except KeyError:
1318             return None
1319         return tuple(self._matchfactories(fixturedefs, nodeid))
1320 
1321     def _matchfactories(self, fixturedefs, nodeid):
1322         for fixturedef in fixturedefs:
1323             if nodes.ischildnode(fixturedef.baseid, nodeid):
1324                 yield fixturedef

</code><intended_behavior>This file likely defines and manages fixtures. If there are utility methods here that fetch fixture metadata (including scope), ensuring these methods are suitably integrated into the logic that outputs fixture information for `--fixtures`. We may not need to directly modify this file, but it's important to ensure that any changes made are compatible with how fixtures and their scopes are defined and managed here.</intended_behavior>]
2025-10-15 09:47:59.789 | INFO     | Search completed. Bug locations: [<file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import collections
7 import fnmatch
8 import inspect
9 import os
10 import sys
11 import warnings
12 from functools import partial
13 from textwrap import dedent
14 
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import deprecated
20 from _pytest import fixtures
21 from _pytest import nodes
22 from _pytest._code import filter_traceback
23 from _pytest.compat import ascii_escaped
24 from _pytest.compat import enum
25 from _pytest.compat import get_default_arg_names
26 from _pytest.compat import get_real_func
27 from _pytest.compat import getfslineno
28 from _pytest.compat import getimfunc
29 from _pytest.compat import getlocation
30 from _pytest.compat import is_generator
31 from _pytest.compat import isclass
32 from _pytest.compat import isfunction
33 from _pytest.compat import NoneType
34 from _pytest.compat import NOTSET
35 from _pytest.compat import REGEX_TYPE
36 from _pytest.compat import safe_getattr
37 from _pytest.compat import safe_isclass
38 from _pytest.compat import safe_str
39 from _pytest.compat import STRING_TYPES
40 from _pytest.config import hookimpl
41 from _pytest.main import FSHookProxy
42 from _pytest.mark import MARK_GEN
43 from _pytest.mark.structures import get_unpacked_marks
44 from _pytest.mark.structures import normalize_mark_list
45 from _pytest.outcomes import fail
46 from _pytest.outcomes import skip
47 from _pytest.pathlib import parts
48 from _pytest.warning_types import PytestCollectionWarning
49 from _pytest.warning_types import PytestUnhandledCoroutineWarning
50 
51 
52 def pyobj_property(name):
53     def get(self):
54         node = self.getparent(getattr(__import__("pytest"), name))
55         if node is not None:
56             return node.obj
57 
58     doc = "python %s object this node was collected from (can be None)." % (
59         name.lower(),
60     )
61     return property(get, None, None, doc)
62 
63 
64 def pytest_addoption(parser):
65     group = parser.getgroup("general")
66     group.addoption(
67         "--fixtures",
68         "--funcargs",
69         action="store_true",
70         dest="showfixtures",
71         default=False,
72         help="show available fixtures, sorted by plugin appearance "
73         "(fixtures with leading '_' are only shown with '-v')",
74     )
75     group.addoption(
76         "--fixtures-per-test",
77         action="store_true",
78         dest="show_fixtures_per_test",
79         default=False,
80         help="show fixtures per test",
81     )
82     parser.addini(
83         "usefixtures",
84         type="args",
85         default=[],
86         help="list of default fixtures to be used with this project",
87     )
88     parser.addini(
89         "python_files",
90         type="args",
91         default=["test_*.py", "*_test.py"],
92         help="glob-style file patterns for Python test module discovery",
93     )
94     parser.addini(
95         "python_classes",
96         type="args",
97         default=["Test"],
98         help="prefixes or glob names for Python test class discovery",
99     )
100     parser.addini(
101         "python_functions",
102         type="args",
103         default=["test"],
104         help="prefixes or glob names for Python test function and method discovery",
105     )
106     parser.addini(
107         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
108         type="bool",
109         default=False,
110         help="disable string escape non-ascii characters, might cause unwanted "
111         "side effects(use at your own risk)",
112     )
113 
114     group.addoption(
115         "--import-mode",
116         default="prepend",
117         choices=["prepend", "append"],
118         dest="importmode",
119         help="prepend/append to sys.path when importing test modules, "
120         "default is to prepend.",
121     )
122 
123 
124 def pytest_cmdline_main(config):
125     if config.option.showfixtures:
126         showfixtures(config)
127         return 0
128     if config.option.show_fixtures_per_test:
129         show_fixtures_per_test(config)
130         return 0
131 
132 
133 def pytest_generate_tests(metafunc):
134     # those alternative spellings are common - raise a specific error to alert
135     # the user
136     alt_spellings = ["parameterize", "parametrise", "parameterise"]
137     for mark_name in alt_spellings:
138         if metafunc.definition.get_closest_marker(mark_name):
139             msg = "{0} has '{1}' mark, spelling should be 'parametrize'"
140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)
141     for marker in metafunc.definition.iter_markers(name="parametrize"):
142         metafunc.parametrize(*marker.args, **marker.kwargs)
143 
144 
145 def pytest_configure(config):
146     config.addinivalue_line(
147         "markers",
148         "parametrize(argnames, argvalues): call a test function multiple "
149         "times passing in different arguments in turn. argvalues generally "
150         "needs to be a list of values if argnames specifies only one name "
151         "or a list of tuples of values if argnames specifies multiple names. "
152         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
153         "decorated test function, one with arg1=1 and another with arg1=2."
154         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
155         "and examples.",
156     )
157     config.addinivalue_line(
158         "markers",
159         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
160         "all of the specified fixtures. see "
161         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
162     )
163 
164 
165 @hookimpl(trylast=True)
166 def pytest_pyfunc_call(pyfuncitem):
167     testfunction = pyfuncitem.obj
168     iscoroutinefunction = getattr(inspect, "iscoroutinefunction", None)
169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):
170         msg = "Coroutine functions are not natively supported and have been skipped.\n"
171         msg += "You need to install a suitable plugin for your async framework, for example:\n"
172         msg += "  - pytest-asyncio\n"
173         msg += "  - pytest-trio\n"
174         msg += "  - pytest-tornasync"
175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))
176         skip(msg="coroutine function and no async plugin installed (see warnings)")
177     funcargs = pyfuncitem.funcargs
178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
179     testfunction(**testargs)
180     return True
181 
182 
183 def pytest_collect_file(path, parent):
184     ext = path.ext
185     if ext == ".py":
186         if not parent.session.isinitpath(path):
187             if not path_matches_patterns(
188                 path, parent.config.getini("python_files") + ["__init__.py"]
189             ):
190                 return
191         ihook = parent.session.gethookproxy(path)
192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
193 
194 
195 def path_matches_patterns(path, patterns):
196     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
197     return any(path.fnmatch(pattern) for pattern in patterns)
198 
199 
200 def pytest_pycollect_makemodule(path, parent):
201     if path.basename == "__init__.py":
202         return Package(path, parent)
203     return Module(path, parent)
204 
205 
206 @hookimpl(hookwrapper=True)
207 def pytest_pycollect_makeitem(collector, name, obj):
208     outcome = yield
209     res = outcome.get_result()
210     if res is not None:
211         return
212     # nothing was collected elsewhere, let's do it here
213     if safe_isclass(obj):
214         if collector.istestclass(obj, name):
215             outcome.force_result(Class(name, parent=collector))
216     elif collector.istestfunction(obj, name):
217         # mock seems to store unbound methods (issue473), normalize it
218         obj = getattr(obj, "__func__", obj)
219         # We need to try and unwrap the function if it's a functools.partial
220         # or a funtools.wrapped.
221         # We musn't if it's been wrapped with mock.patch (python 2 only)
222         if not (isfunction(obj) or isfunction(get_real_func(obj))):
223             filename, lineno = getfslineno(obj)
224             warnings.warn_explicit(
225                 message=PytestCollectionWarning(
226                     "cannot collect %r because it is not a function." % name
227                 ),
228                 category=None,
229                 filename=str(filename),
230                 lineno=lineno + 1,
231             )
232         elif getattr(obj, "__test__", True):
233             if is_generator(obj):
234                 res = Function(name, parent=collector)
235                 reason = deprecated.YIELD_TESTS.format(name=name)
236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
237                 res.warn(PytestCollectionWarning(reason))
238             else:
239                 res = list(collector._genfunctions(name, obj))
240             outcome.force_result(res)
241 
242 
243 def pytest_make_parametrize_id(config, val, argname=None):
244     return None
245 
246 
247 class PyobjContext(object):
248     module = pyobj_property("Module")
249     cls = pyobj_property("Class")
250     instance = pyobj_property("Instance")
251 
252 
253 class PyobjMixin(PyobjContext):
254     _ALLOW_MARKERS = True
255 
256     def __init__(self, *k, **kw):
257         super(PyobjMixin, self).__init__(*k, **kw)
258 
259     @property
260     def obj(self):
261         """Underlying Python object."""
262         obj = getattr(self, "_obj", None)
263         if obj is None:
264             self._obj = obj = self._getobj()
265             # XXX evil hack
266             # used to avoid Instance collector marker duplication
267             if self._ALLOW_MARKERS:
268                 self.own_markers.extend(get_unpacked_marks(self.obj))
269         return obj
270 
271     @obj.setter
272     def obj(self, value):
273         self._obj = value
274 
275     def _getobj(self):
276         """Gets the underlying Python object. May be overwritten by subclasses."""
277         return getattr(self.parent.obj, self.name)
278 
279     def getmodpath(self, stopatmodule=True, includemodule=False):
280         """ return python path relative to the containing module. """
281         chain = self.listchain()
282         chain.reverse()
283         parts = []
284         for node in chain:
285             if isinstance(node, Instance):
286                 continue
287             name = node.name
288             if isinstance(node, Module):
289                 name = os.path.splitext(name)[0]
290                 if stopatmodule:
291                     if includemodule:
292                         parts.append(name)
293                     break
294             parts.append(name)
295         parts.reverse()
296         s = ".".join(parts)
297         return s.replace(".[", "[")
298 
299     def reportinfo(self):
300         # XXX caching?
301         obj = self.obj
302         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
303         if isinstance(compat_co_firstlineno, int):
304             # nose compatibility
305             fspath = sys.modules[obj.__module__].__file__
306             if fspath.endswith(".pyc"):
307                 fspath = fspath[:-1]
308             lineno = compat_co_firstlineno
309         else:
310             fspath, lineno = getfslineno(obj)
311         modpath = self.getmodpath()
312         assert isinstance(lineno, int)
313         return fspath, lineno, modpath
314 
315 
316 class PyCollector(PyobjMixin, nodes.Collector):
317     def funcnamefilter(self, name):
318         return self._matches_prefix_or_glob_option("python_functions", name)
319 
320     def isnosetest(self, obj):
321         """ Look for the __test__ attribute, which is applied by the
322         @nose.tools.istest decorator
323         """
324         # We explicitly check for "is True" here to not mistakenly treat
325         # classes with a custom __getattr__ returning something truthy (like a
326         # function) as test classes.
327         return safe_getattr(obj, "__test__", False) is True
328 
329     def classnamefilter(self, name):
330         return self._matches_prefix_or_glob_option("python_classes", name)
331 
332     def istestfunction(self, obj, name):
333         if self.funcnamefilter(name) or self.isnosetest(obj):
334             if isinstance(obj, staticmethod):
335                 # static methods need to be unwrapped
336                 obj = safe_getattr(obj, "__func__", False)
337             return (
338                 safe_getattr(obj, "__call__", False)
339                 and fixtures.getfixturemarker(obj) is None
340             )
341         else:
342             return False
343 
344     def istestclass(self, obj, name):
345         return self.classnamefilter(name) or self.isnosetest(obj)
346 
347     def _matches_prefix_or_glob_option(self, option_name, name):
348         """
349         checks if the given name matches the prefix or glob-pattern defined
350         in ini configuration.
351         """
352         for option in self.config.getini(option_name):
353             if name.startswith(option):
354                 return True
355             # check that name looks like a glob-string before calling fnmatch
356             # because this is called for every name in each collected module,
357             # and fnmatch is somewhat expensive to call
358             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
359                 name, option
360             ):
361                 return True
362         return False
363 
364     def collect(self):
365         if not getattr(self.obj, "__test__", True):
366             return []
367 
368         # NB. we avoid random getattrs and peek in the __dict__ instead
369         # (XXX originally introduced from a PyPy need, still true?)
370         dicts = [getattr(self.obj, "__dict__", {})]
371         for basecls in inspect.getmro(self.obj.__class__):
372             dicts.append(basecls.__dict__)
373         seen = {}
374         values = []
375         for dic in dicts:
376             for name, obj in list(dic.items()):
377                 if name in seen:
378                     continue
379                 seen[name] = True
380                 res = self._makeitem(name, obj)
381                 if res is None:
382                     continue
383                 if not isinstance(res, list):
384                     res = [res]
385                 values.extend(res)
386         values.sort(key=lambda item: item.reportinfo()[:2])
387         return values
388 
389     def _makeitem(self, name, obj):
390         # assert self.ihook.fspath == self.fspath, self
391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
392 
393     def _genfunctions(self, name, funcobj):
394         module = self.getparent(Module).obj
395         clscol = self.getparent(Class)
396         cls = clscol and clscol.obj or None
397         fm = self.session._fixturemanager
398 
399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)
400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)
401 
402         metafunc = Metafunc(
403             definition, fixtureinfo, self.config, cls=cls, module=module
404         )
405         methods = []
406         if hasattr(module, "pytest_generate_tests"):
407             methods.append(module.pytest_generate_tests)
408         if hasattr(cls, "pytest_generate_tests"):
409             methods.append(cls().pytest_generate_tests)
410         if methods:
411             self.ihook.pytest_generate_tests.call_extra(
412                 methods, dict(metafunc=metafunc)
413             )
414         else:
415             self.ihook.pytest_generate_tests(metafunc=metafunc)
416 
417         if not metafunc._calls:
418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)
419         else:
420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
422 
423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
424             # with direct parametrization, so make sure we update what the
425             # function really needs.
426             fixtureinfo.prune_dependency_tree()
427 
428             for callspec in metafunc._calls:
429                 subname = "%s[%s]" % (name, callspec.id)
430                 yield Function(
431                     name=subname,
432                     parent=self,
433                     callspec=callspec,
434                     callobj=funcobj,
435                     fixtureinfo=fixtureinfo,
436                     keywords={callspec.id: True},
437                     originalname=name,
438                 )
439 
440 
441 class Module(nodes.File, PyCollector):
442     """ Collector for test classes and functions. """
443 
444     def _getobj(self):
445         return self._importtestmodule()
446 
447     def collect(self):
448         self._inject_setup_module_fixture()
449         self._inject_setup_function_fixture()
450         self.session._fixturemanager.parsefactories(self)
451         return super(Module, self).collect()
452 
453     def _inject_setup_module_fixture(self):
454         """Injects a hidden autouse, module scoped fixture into the collected module object
455         that invokes setUpModule/tearDownModule if either or both are available.
456 
457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
458         other fixtures (#517).
459         """
460         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
461         if setup_module is None:
462             setup_module = _get_non_fixture_func(self.obj, "setup_module")
463 
464         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
465         if teardown_module is None:
466             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
467 
468         if setup_module is None and teardown_module is None:
469             return
470 
471         @fixtures.fixture(autouse=True, scope="module")
472         def xunit_setup_module_fixture(request):
473             if setup_module is not None:
474                 _call_with_optional_argument(setup_module, request.module)
475             yield
476             if teardown_module is not None:
477                 _call_with_optional_argument(teardown_module, request.module)
478 
479         self.obj.__pytest_setup_module = xunit_setup_module_fixture
480 
481     def _inject_setup_function_fixture(self):
482         """Injects a hidden autouse, function scoped fixture into the collected module object
483         that invokes setup_function/teardown_function if either or both are available.
484 
485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
486         other fixtures (#517).
487         """
488         setup_function = _get_non_fixture_func(self.obj, "setup_function")
489         teardown_function = _get_non_fixture_func(self.obj, "teardown_function")
490         if setup_function is None and teardown_function is None:
491             return
492 
493         @fixtures.fixture(autouse=True, scope="function")
494         def xunit_setup_function_fixture(request):
495             if request.instance is not None:
496                 # in this case we are bound to an instance, so we need to let
497                 # setup_method handle this
498                 yield
499                 return
500             if setup_function is not None:
501                 _call_with_optional_argument(setup_function, request.function)
502             yield
503             if teardown_function is not None:
504                 _call_with_optional_argument(teardown_function, request.function)
505 
506         self.obj.__pytest_setup_function = xunit_setup_function_fixture
507 
508     def _importtestmodule(self):
509         # we assume we are only called once per module
510         importmode = self.config.getoption("--import-mode")
511         try:
512             mod = self.fspath.pyimport(ensuresyspath=importmode)
513         except SyntaxError:
514             raise self.CollectError(
515                 _pytest._code.ExceptionInfo.from_current().getrepr(style="short")
516             )
517         except self.fspath.ImportMismatchError:
518             e = sys.exc_info()[1]
519             raise self.CollectError(
520                 "import file mismatch:\n"
521                 "imported module %r has this __file__ attribute:\n"
522                 "  %s\n"
523                 "which is not the same as the test file we want to collect:\n"
524                 "  %s\n"
525                 "HINT: remove __pycache__ / .pyc files and/or use a "
526                 "unique basename for your test file modules" % e.args
527             )
528         except ImportError:
529             from _pytest._code.code import ExceptionInfo
530 
531             exc_info = ExceptionInfo.from_current()
532             if self.config.getoption("verbose") < 2:
533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
534             exc_repr = (
535                 exc_info.getrepr(style="short")
536                 if exc_info.traceback
537                 else exc_info.exconly()
538             )
539             formatted_tb = safe_str(exc_repr)
540             raise self.CollectError(
541                 "ImportError while importing test module '{fspath}'.\n"
542                 "Hint: make sure your test modules/packages have valid Python names.\n"
543                 "Traceback:\n"
544                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
545             )
546         except _pytest.runner.Skipped as e:
547             if e.allow_module_level:
548                 raise
549             raise self.CollectError(
550                 "Using pytest.skip outside of a test is not allowed. "
551                 "To decorate a test function, use the @pytest.mark.skip "
552                 "or @pytest.mark.skipif decorators instead, and to skip a "
553                 "module use `pytestmark = pytest.mark.{skip,skipif}."
554             )
555         self.config.pluginmanager.consider_module(mod)
556         return mod
557 
558 
559 class Package(Module):
560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):
561         session = parent.session
562         nodes.FSCollector.__init__(
563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
564         )
565         self.name = fspath.dirname
566         self.trace = session.trace
567         self._norecursepatterns = session._norecursepatterns
568         self.fspath = fspath
569 
570     def setup(self):
571         # not using fixtures to call setup_module here because autouse fixtures
572         # from packages are not called automatically (#4085)
573         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
574         if setup_module is None:
575             setup_module = _get_non_fixture_func(self.obj, "setup_module")
576         if setup_module is not None:
577             _call_with_optional_argument(setup_module, self.obj)
578 
579         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
580         if teardown_module is None:
581             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
582         if teardown_module is not None:
583             func = partial(_call_with_optional_argument, teardown_module, self.obj)
584             self.addfinalizer(func)
585 
586     def _recurse(self, dirpath):
587         if dirpath.basename == "__pycache__":
588             return False
589         ihook = self.gethookproxy(dirpath.dirpath())
590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):
591             return
592         for pat in self._norecursepatterns:
593             if dirpath.check(fnmatch=pat):
594                 return False
595         ihook = self.gethookproxy(dirpath)
596         ihook.pytest_collect_directory(path=dirpath, parent=self)
597         return True
598 
599     def gethookproxy(self, fspath):
600         # check if we have the common case of running
601         # hooks with all conftest.py filesall conftest.py
602         pm = self.config.pluginmanager
603         my_conftestmodules = pm._getconftestmodules(fspath)
604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)
605         if remove_mods:
606             # one or more conftests are not in use at this fspath
607             proxy = FSHookProxy(fspath, pm, remove_mods)
608         else:
609             # all plugis are active for this fspath
610             proxy = self.config.hook
611         return proxy
612 
613     def _collectfile(self, path, handle_dupes=True):
614         assert path.isfile(), "%r is not a file (isdir=%r, exists=%r, islink=%r)" % (
615             path,
616             path.isdir(),
617             path.exists(),
618             path.islink(),
619         )
620         ihook = self.gethookproxy(path)
621         if not self.isinitpath(path):
622             if ihook.pytest_ignore_collect(path=path, config=self.config):
623                 return ()
624 
625         if handle_dupes:
626             keepduplicates = self.config.getoption("keepduplicates")
627             if not keepduplicates:
628                 duplicate_paths = self.config.pluginmanager._duplicatepaths
629                 if path in duplicate_paths:
630                     return ()
631                 else:
632                     duplicate_paths.add(path)
633 
634         if self.fspath == path:  # __init__.py
635             return [self]
636 
637         return ihook.pytest_collect_file(path=path, parent=self)
638 
639     def isinitpath(self, path):
640         return path in self.session._initialpaths
641 
642     def collect(self):
643         this_path = self.fspath.dirpath()
644         init_module = this_path.join("__init__.py")
645         if init_module.check(file=1) and path_matches_patterns(
646             init_module, self.config.getini("python_files")
647         ):
648             yield Module(init_module, self)
649         pkg_prefixes = set()
650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
651             # We will visit our own __init__.py file, in which case we skip it.
652             is_file = path.isfile()
653             if is_file:
654                 if path.basename == "__init__.py" and path.dirpath() == this_path:
655                     continue
656 
657             parts_ = parts(path.strpath)
658             if any(
659                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
660                 for pkg_prefix in pkg_prefixes
661             ):
662                 continue
663 
664             if is_file:
665                 for x in self._collectfile(path):
666                     yield x
667             elif not path.isdir():
668                 # Broken symlink or invalid/missing file.
669                 continue
670             elif path.join("__init__.py").check(file=1):
671                 pkg_prefixes.add(path)
672 
673 
674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):
675     """
676     Return a callable to perform xunit-style setup or teardown if
677     the function exists in the ``holder`` object.
678     The ``param_obj`` parameter is the parameter which will be passed to the function
679     when the callable is called without arguments, defaults to the ``holder`` object.
680     Return ``None`` if a suitable callable is not found.
681     """
682     # TODO: only needed because of Package!
683     param_obj = param_obj if param_obj is not None else holder
684     result = _get_non_fixture_func(holder, attr_name)
685     if result is not None:
686         arg_count = result.__code__.co_argcount
687         if inspect.ismethod(result):
688             arg_count -= 1
689         if arg_count:
690             return lambda: result(param_obj)
691         else:
692             return result
693 
694 
695 def _call_with_optional_argument(func, arg):
696     """Call the given function with the given argument if func accepts one argument, otherwise
697     calls func without arguments"""
698     arg_count = func.__code__.co_argcount
699     if inspect.ismethod(func):
700         arg_count -= 1
701     if arg_count:
702         func(arg)
703     else:
704         func()
705 
706 
707 def _get_non_fixture_func(obj, name):
708     """Return the attribute from the given object to be used as a setup/teardown
709     xunit-style function, but only if not marked as a fixture to
710     avoid calling it twice.
711     """
712     meth = getattr(obj, name, None)
713     if fixtures.getfixturemarker(meth) is None:
714         return meth
715 
716 
717 class Class(PyCollector):
718     """ Collector for test methods. """
719 
720     def collect(self):
721         if not safe_getattr(self.obj, "__test__", True):
722             return []
723         if hasinit(self.obj):
724             self.warn(
725                 PytestCollectionWarning(
726                     "cannot collect test class %r because it has a "
727                     "__init__ constructor" % self.obj.__name__
728                 )
729             )
730             return []
731         elif hasnew(self.obj):
732             self.warn(
733                 PytestCollectionWarning(
734                     "cannot collect test class %r because it has a "
735                     "__new__ constructor" % self.obj.__name__
736                 )
737             )
738             return []
739 
740         self._inject_setup_class_fixture()
741         self._inject_setup_method_fixture()
742 
743         return [Instance(name="()", parent=self)]
744 
745     def _inject_setup_class_fixture(self):
746         """Injects a hidden autouse, class scoped fixture into the collected class object
747         that invokes setup_class/teardown_class if either or both are available.
748 
749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
750         other fixtures (#517).
751         """
752         setup_class = _get_non_fixture_func(self.obj, "setup_class")
753         teardown_class = getattr(self.obj, "teardown_class", None)
754         if setup_class is None and teardown_class is None:
755             return
756 
757         @fixtures.fixture(autouse=True, scope="class")
758         def xunit_setup_class_fixture(cls):
759             if setup_class is not None:
760                 func = getimfunc(setup_class)
761                 _call_with_optional_argument(func, self.obj)
762             yield
763             if teardown_class is not None:
764                 func = getimfunc(teardown_class)
765                 _call_with_optional_argument(func, self.obj)
766 
767         self.obj.__pytest_setup_class = xunit_setup_class_fixture
768 
769     def _inject_setup_method_fixture(self):
770         """Injects a hidden autouse, function scoped fixture into the collected class object
771         that invokes setup_method/teardown_method if either or both are available.
772 
773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
774         other fixtures (#517).
775         """
776         setup_method = _get_non_fixture_func(self.obj, "setup_method")
777         teardown_method = getattr(self.obj, "teardown_method", None)
778         if setup_method is None and teardown_method is None:
779             return
780 
781         @fixtures.fixture(autouse=True, scope="function")
782         def xunit_setup_method_fixture(self, request):
783             method = request.function
784             if setup_method is not None:
785                 func = getattr(self, "setup_method")
786                 _call_with_optional_argument(func, method)
787             yield
788             if teardown_method is not None:
789                 func = getattr(self, "teardown_method")
790                 _call_with_optional_argument(func, method)
791 
792         self.obj.__pytest_setup_method = xunit_setup_method_fixture
793 
794 
795 class Instance(PyCollector):
796     _ALLOW_MARKERS = False  # hack, destroy later
797     # instances share the object with their parents in a way
798     # that duplicates markers instances if not taken out
799     # can be removed at node structure reorganization time
800 
801     def _getobj(self):
802         return self.parent.obj()
803 
804     def collect(self):
805         self.session._fixturemanager.parsefactories(self)
806         return super(Instance, self).collect()
807 
808     def newinstance(self):
809         self.obj = self._getobj()
810         return self.obj
811 
812 
813 class FunctionMixin(PyobjMixin):
814     """ mixin for the code common to Function and Generator.
815     """
816 
817     def setup(self):
818         """ perform setup for this test function. """
819         if isinstance(self.parent, Instance):
820             self.parent.newinstance()
821             self.obj = self._getobj()
822 
823     def _prunetraceback(self, excinfo):
824         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
825             code = _pytest._code.Code(get_real_func(self.obj))
826             path, firstlineno = code.path, code.firstlineno
827             traceback = excinfo.traceback
828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
829             if ntraceback == traceback:
830                 ntraceback = ntraceback.cut(path=path)
831                 if ntraceback == traceback:
832                     ntraceback = ntraceback.filter(filter_traceback)
833                     if not ntraceback:
834                         ntraceback = traceback
835 
836             excinfo.traceback = ntraceback.filter()
837             # issue364: mark all but first and last frames to
838             # only show a single-line message for each frame
839             if self.config.getoption("tbstyle", "auto") == "auto":
840                 if len(excinfo.traceback) > 2:
841                     for entry in excinfo.traceback[1:-1]:
842                         entry.set_repr_style("short")
843 
844     def repr_failure(self, excinfo, outerr=None):
845         assert outerr is None, "XXX outerr usage is deprecated"
846         style = self.config.getoption("tbstyle", "auto")
847         if style == "auto":
848             style = "long"
849         return self._repr_failure_py(excinfo, style=style)
850 
851 
852 def hasinit(obj):
853     init = getattr(obj, "__init__", None)
854     if init:
855         return init != object.__init__
856 
857 
858 def hasnew(obj):
859     new = getattr(obj, "__new__", None)
860     if new:
861         return new != object.__new__
862 
863 
864 class CallSpec2(object):
865     def __init__(self, metafunc):
866         self.metafunc = metafunc
867         self.funcargs = {}
868         self._idlist = []
869         self.params = {}
870         self._globalid = NOTSET
871         self._globalparam = NOTSET
872         self._arg2scopenum = {}  # used for sorting parametrized resources
873         self.marks = []
874         self.indices = {}
875 
876     def copy(self):
877         cs = CallSpec2(self.metafunc)
878         cs.funcargs.update(self.funcargs)
879         cs.params.update(self.params)
880         cs.marks.extend(self.marks)
881         cs.indices.update(self.indices)
882         cs._arg2scopenum.update(self._arg2scopenum)
883         cs._idlist = list(self._idlist)
884         cs._globalid = self._globalid
885         cs._globalparam = self._globalparam
886         return cs
887 
888     def _checkargnotcontained(self, arg):
889         if arg in self.params or arg in self.funcargs:
890             raise ValueError("duplicate %r" % (arg,))
891 
892     def getparam(self, name):
893         try:
894             return self.params[name]
895         except KeyError:
896             if self._globalparam is NOTSET:
897                 raise ValueError(name)
898             return self._globalparam
899 
900     @property
901     def id(self):
902         return "-".join(map(str, filter(None, self._idlist)))
903 
904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
905         for arg, val in zip(argnames, valset):
906             self._checkargnotcontained(arg)
907             valtype_for_arg = valtypes[arg]
908             getattr(self, valtype_for_arg)[arg] = val
909             self.indices[arg] = param_index
910             self._arg2scopenum[arg] = scopenum
911         self._idlist.append(id)
912         self.marks.extend(normalize_mark_list(marks))
913 
914     def setall(self, funcargs, id, param):
915         for x in funcargs:
916             self._checkargnotcontained(x)
917         self.funcargs.update(funcargs)
918         if id is not NOTSET:
919             self._idlist.append(id)
920         if param is not NOTSET:
921             assert self._globalparam is NOTSET
922             self._globalparam = param
923         for arg in funcargs:
924             self._arg2scopenum[arg] = fixtures.scopenum_function
925 
926 
927 class Metafunc(fixtures.FuncargnamesCompatAttr):
928     """
929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
930     They help to inspect a test function and to generate tests according to
931     test configuration or values specified in the class or module where a
932     test function is defined.
933     """
934 
935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):
936         assert (
937             isinstance(definition, FunctionDefinition)
938             or type(definition).__name__ == "DefinitionMock"
939         )
940         self.definition = definition
941 
942         #: access to the :class:`_pytest.config.Config` object for the test session
943         self.config = config
944 
945         #: the module object where the test function is defined in.
946         self.module = module
947 
948         #: underlying python test function
949         self.function = definition.obj
950 
951         #: set of fixture names required by the test function
952         self.fixturenames = fixtureinfo.names_closure
953 
954         #: class object where the test function is defined in or ``None``.
955         self.cls = cls
956 
957         self._calls = []
958         self._ids = set()
959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
960 
961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):
962         """ Add new invocations to the underlying test function using the list
963         of argvalues for the given argnames.  Parametrization is performed
964         during the collection phase.  If you need to setup expensive resources
965         see about setting indirect to do it rather at test setup time.
966 
967         :arg argnames: a comma-separated string denoting one or more argument
968                        names, or a list/tuple of argument strings.
969 
970         :arg argvalues: The list of argvalues determines how often a
971             test is invoked with different argument values.  If only one
972             argname was specified argvalues is a list of values.  If N
973             argnames were specified, argvalues must be a list of N-tuples,
974             where each tuple-element specifies a value for its respective
975             argname.
976 
977         :arg indirect: The list of argnames or boolean. A list of arguments'
978             names (subset of argnames). If True the list contains all names from
979             the argnames. Each argvalue corresponding to an argname in this list will
980             be passed as request.param to its respective argname fixture
981             function so that it can perform more expensive setups during the
982             setup phase of a test rather than at collection time.
983 
984         :arg ids: list of string ids, or a callable.
985             If strings, each is corresponding to the argvalues so that they are
986             part of the test id. If None is given as id of specific test, the
987             automatically generated id for that argument will be used.
988             If callable, it should take one argument (a single argvalue) and return
989             a string or return None. If None, the automatically generated id for that
990             argument will be used.
991             If no ids are provided they will be generated automatically from
992             the argvalues.
993 
994         :arg scope: if specified it denotes the scope of the parameters.
995             The scope is used for grouping tests by parameter instances.
996             It will also override any fixture-function defined scope, allowing
997             to set a dynamic scope using test context or configuration.
998         """
999         from _pytest.fixtures import scope2index
1000         from _pytest.mark import ParameterSet
1001 
1002         argnames, parameters = ParameterSet._for_parametrize(
1003             argnames,
1004             argvalues,
1005             self.function,
1006             self.config,
1007             function_definition=self.definition,
1008         )
1009         del argvalues
1010 
1011         if scope is None:
1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
1013 
1014         self._validate_if_using_arg_names(argnames, indirect)
1015 
1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
1017 
1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
1019 
1020         scopenum = scope2index(
1021             scope, descr="parametrize() call in {}".format(self.function.__name__)
1022         )
1023 
1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator
1025         # more than once) then we accumulate those calls generating the cartesian product
1026         # of all calls
1027         newcalls = []
1028         for callspec in self._calls or [CallSpec2(self)]:
1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
1030                 newcallspec = callspec.copy()
1031                 newcallspec.setmulti2(
1032                     arg_values_types,
1033                     argnames,
1034                     param_set.values,
1035                     param_id,
1036                     param_set.marks,
1037                     scopenum,
1038                     param_index,
1039                 )
1040                 newcalls.append(newcallspec)
1041         self._calls = newcalls
1042 
1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):
1044         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
1045         to ``parametrize``.
1046 
1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1048         :param ids: the ids parameter of the parametrized call (see docs).
1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
1050         :param Item item: the item that generated this parametrized call.
1051         :rtype: List[str]
1052         :return: the list of ids for each argname given
1053         """
1054         from _pytest._io.saferepr import saferepr
1055 
1056         idfn = None
1057         if callable(ids):
1058             idfn = ids
1059             ids = None
1060         if ids:
1061             func_name = self.function.__name__
1062             if len(ids) != len(parameters):
1063                 msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)
1065             for id_value in ids:
1066                 if id_value is not None and not isinstance(id_value, six.string_types):
1067                     msg = "In {}: ids must be list of strings, found: {} (type: {!r})"
1068                     fail(
1069                         msg.format(func_name, saferepr(id_value), type(id_value)),
1070                         pytrace=False,
1071                     )
1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)
1073         return ids
1074 
1075     def _resolve_arg_value_types(self, argnames, indirect):
1076         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1077         to the function, based on the ``indirect`` parameter of the parametrized() call.
1078 
1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1081         :rtype: Dict[str, str]
1082             A dict mapping each arg name to either:
1083             * "params" if the argname should be the parameter of a fixture of the same name.
1084             * "funcargs" if the argname should be a parameter to the parametrized test function.
1085         """
1086         valtypes = {}
1087         if indirect is True:
1088             valtypes = dict.fromkeys(argnames, "params")
1089         elif indirect is False:
1090             valtypes = dict.fromkeys(argnames, "funcargs")
1091         elif isinstance(indirect, (tuple, list)):
1092             valtypes = dict.fromkeys(argnames, "funcargs")
1093             for arg in indirect:
1094                 if arg not in argnames:
1095                     fail(
1096                         "In {}: indirect fixture '{}' doesn't exist".format(
1097                             self.function.__name__, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 valtypes[arg] = "params"
1102         return valtypes
1103 
1104     def _validate_if_using_arg_names(self, argnames, indirect):
1105         """
1106         Check if all argnames are being used, by default values, or directly/indirectly.
1107 
1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1110         :raise ValueError: if validation fails.
1111         """
1112         default_arg_names = set(get_default_arg_names(self.function))
1113         func_name = self.function.__name__
1114         for arg in argnames:
1115             if arg not in self.fixturenames:
1116                 if arg in default_arg_names:
1117                     fail(
1118                         "In {}: function already takes an argument '{}' with a default value".format(
1119                             func_name, arg
1120                         ),
1121                         pytrace=False,
1122                     )
1123                 else:
1124                     if isinstance(indirect, (tuple, list)):
1125                         name = "fixture" if arg in indirect else "argument"
1126                     else:
1127                         name = "fixture" if indirect else "argument"
1128                     fail(
1129                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1130                         pytrace=False,
1131                     )
1132 
1133 
1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1135     """Find the most appropriate scope for a parametrized call based on its arguments.
1136 
1137     When there's at least one direct argument, always use "function" scope.
1138 
1139     When a test function is parametrized and all its arguments are indirect
1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1141 
1142     Related to issue #1832, based on code posted by @Kingdread.
1143     """
1144     from _pytest.fixtures import scopes
1145 
1146     if isinstance(indirect, (list, tuple)):
1147         all_arguments_are_fixtures = len(indirect) == len(argnames)
1148     else:
1149         all_arguments_are_fixtures = bool(indirect)
1150 
1151     if all_arguments_are_fixtures:
1152         fixturedefs = arg2fixturedefs or {}
1153         used_scopes = [
1154             fixturedef[0].scope
1155             for name, fixturedef in fixturedefs.items()
1156             if name in argnames
1157         ]
1158         if used_scopes:
1159             # Takes the most narrow scope from used fixtures
1160             for scope in reversed(scopes):
1161                 if scope in used_scopes:
1162                     return scope
1163 
1164     return "function"
1165 
1166 
1167 def _ascii_escaped_by_config(val, config):
1168     if config is None:
1169         escape_option = False
1170     else:
1171         escape_option = config.getini(
1172             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1173         )
1174     return val if escape_option else ascii_escaped(val)
1175 
1176 
1177 def _idval(val, argname, idx, idfn, item, config):
1178     if idfn:
1179         try:
1180             generated_id = idfn(val)
1181             if generated_id is not None:
1182                 val = generated_id
1183         except Exception as e:
1184             # See issue https://github.com/pytest-dev/pytest/issues/2169
1185             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}\n"
1186             msg = msg.format(item.nodeid, argname, idx)
1187             # we only append the exception type and message because on Python 2 reraise does nothing
1188             msg += "  {}: {}\n".format(type(e).__name__, e)
1189             six.raise_from(ValueError(msg), e)
1190     elif config:
1191         hook_id = config.hook.pytest_make_parametrize_id(
1192             config=config, val=val, argname=argname
1193         )
1194         if hook_id:
1195             return hook_id
1196 
1197     if isinstance(val, STRING_TYPES):
1198         return _ascii_escaped_by_config(val, config)
1199     elif isinstance(val, (float, int, bool, NoneType)):
1200         return str(val)
1201     elif isinstance(val, REGEX_TYPE):
1202         return ascii_escaped(val.pattern)
1203     elif enum is not None and isinstance(val, enum.Enum):
1204         return str(val)
1205     elif (isclass(val) or isfunction(val)) and hasattr(val, "__name__"):
1206         return val.__name__
1207     return str(argname) + str(idx)
1208 
1209 
1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):
1211     if parameterset.id is not None:
1212         return parameterset.id
1213     if ids is None or (idx >= len(ids) or ids[idx] is None):
1214         this_id = [
1215             _idval(val, argname, idx, idfn, item=item, config=config)
1216             for val, argname in zip(parameterset.values, argnames)
1217         ]
1218         return "-".join(this_id)
1219     else:
1220         return ascii_escaped(ids[idx])
1221 
1222 
1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):
1224     ids = [
1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1226         for valindex, parameterset in enumerate(parametersets)
1227     ]
1228     if len(set(ids)) != len(ids):
1229         # The ids are not unique
1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]
1231         counters = collections.defaultdict(lambda: 0)
1232         for index, testid in enumerate(ids):
1233             if testid in duplicates:
1234                 ids[index] = testid + str(counters[testid])
1235                 counters[testid] += 1
1236     return ids
1237 
1238 
1239 def show_fixtures_per_test(config):
1240     from _pytest.main import wrap_session
1241 
1242     return wrap_session(config, _show_fixtures_per_test)
1243 
1244 
1245 def _show_fixtures_per_test(config, session):
1246     import _pytest.config
1247 
1248     session.perform_collect()
1249     curdir = py.path.local()
1250     tw = _pytest.config.create_terminal_writer(config)
1251     verbose = config.getvalue("verbose")
1252 
1253     def get_best_relpath(func):
1254         loc = getlocation(func, curdir)
1255         return curdir.bestrelpath(loc)
1256 
1257     def write_fixture(fixture_def):
1258         argname = fixture_def.argname
1259         if verbose <= 0 and argname.startswith("_"):
1260             return
1261         if verbose > 0:
1262             bestrel = get_best_relpath(fixture_def.func)
1263             funcargspec = "{} -- {}".format(argname, bestrel)
1264         else:
1265             funcargspec = argname
1266         tw.line(funcargspec, green=True)
1267         fixture_doc = fixture_def.func.__doc__
1268         if fixture_doc:
1269             write_docstring(tw, fixture_doc)
1270         else:
1271             tw.line("    no docstring available", red=True)
1272 
1273     def write_item(item):
1274         try:
1275             info = item._fixtureinfo
1276         except AttributeError:
1277             # doctests items have no _fixtureinfo attribute
1278             return
1279         if not info.name2fixturedefs:
1280             # this test item does not use any fixtures
1281             return
1282         tw.line()
1283         tw.sep("-", "fixtures used by {}".format(item.name))
1284         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1285         # dict key not used in loop but needed for sorting
1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1287             assert fixturedefs is not None
1288             if not fixturedefs:
1289                 continue
1290             # last item is expected to be the one used by the test item
1291             write_fixture(fixturedefs[-1])
1292 
1293     for session_item in session.items:
1294         write_item(session_item)
1295 
1296 
1297 def showfixtures(config):
1298     from _pytest.main import wrap_session
1299 
1300     return wrap_session(config, _showfixtures_main)
1301 
1302 
1303 def _showfixtures_main(config, session):
1304     import _pytest.config
1305 
1306     session.perform_collect()
1307     curdir = py.path.local()
1308     tw = _pytest.config.create_terminal_writer(config)
1309     verbose = config.getvalue("verbose")
1310 
1311     fm = session._fixturemanager
1312 
1313     available = []
1314     seen = set()
1315 
1316     for argname, fixturedefs in fm._arg2fixturedefs.items():
1317         assert fixturedefs is not None
1318         if not fixturedefs:
1319             continue
1320         for fixturedef in fixturedefs:
1321             loc = getlocation(fixturedef.func, curdir)
1322             if (fixturedef.argname, loc) in seen:
1323                 continue
1324             seen.add((fixturedef.argname, loc))
1325             available.append(
1326                 (
1327                     len(fixturedef.baseid),
1328                     fixturedef.func.__module__,
1329                     curdir.bestrelpath(loc),
1330                     fixturedef.argname,
1331                     fixturedef,
1332                 )
1333             )
1334 
1335     available.sort()
1336     currentmodule = None
1337     for baseid, module, bestrel, argname, fixturedef in available:
1338         if currentmodule != module:
1339             if not module.startswith("_pytest."):
1340                 tw.line()
1341                 tw.sep("-", "fixtures defined from %s" % (module,))
1342                 currentmodule = module
1343         if verbose <= 0 and argname[0] == "_":
1344             continue
1345         if verbose > 0:
1346             funcargspec = "%s -- %s" % (argname, bestrel)
1347         else:
1348             funcargspec = argname
1349         tw.line(funcargspec, green=True)
1350         loc = getlocation(fixturedef.func, curdir)
1351         doc = fixturedef.func.__doc__ or ""
1352         if doc:
1353             write_docstring(tw, doc)
1354         else:
1355             tw.line("    %s: no docstring available" % (loc,), red=True)
1356 
1357 
1358 def write_docstring(tw, doc, indent="    "):
1359     doc = doc.rstrip()
1360     if "\n" in doc:
1361         firstline, rest = doc.split("\n", 1)
1362     else:
1363         firstline, rest = doc, ""
1364 
1365     if firstline.strip():
1366         tw.line(indent + firstline.strip())
1367 
1368     if rest:
1369         for line in dedent(rest).split("\n"):
1370             tw.write(indent + line + "\n")
1371 
1372 
1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):
1374     """ a Function Item is responsible for setting up and executing a
1375     Python test function.
1376     """
1377 
1378     # disable since functions handle it themselves
1379     _ALLOW_MARKERS = False
1380 
1381     def __init__(
1382         self,
1383         name,
1384         parent,
1385         args=None,
1386         config=None,
1387         callspec=None,
1388         callobj=NOTSET,
1389         keywords=None,
1390         session=None,
1391         fixtureinfo=None,
1392         originalname=None,
1393     ):
1394         super(Function, self).__init__(name, parent, config=config, session=session)
1395         self._args = args
1396         if callobj is not NOTSET:
1397             self.obj = callobj
1398 
1399         self.keywords.update(self.obj.__dict__)
1400         self.own_markers.extend(get_unpacked_marks(self.obj))
1401         if callspec:
1402             self.callspec = callspec
1403             # this is total hostile and a mess
1404             # keywords are broken by design by now
1405             # this will be redeemed later
1406             for mark in callspec.marks:
1407                 # feel free to cry, this was broken for years before
1408                 # and keywords cant fix it per design
1409                 self.keywords[mark.name] = mark
1410             self.own_markers.extend(normalize_mark_list(callspec.marks))
1411         if keywords:
1412             self.keywords.update(keywords)
1413 
1414         # todo: this is a hell of a hack
1415         # https://github.com/pytest-dev/pytest/issues/4569
1416 
1417         self.keywords.update(
1418             dict.fromkeys(
1419                 [
1420                     mark.name
1421                     for mark in self.iter_markers()
1422                     if mark.name not in self.keywords
1423                 ],
1424                 True,
1425             )
1426         )
1427 
1428         if fixtureinfo is None:
1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1430                 self, self.obj, self.cls, funcargs=True
1431             )
1432         self._fixtureinfo = fixtureinfo
1433         self.fixturenames = fixtureinfo.names_closure
1434         self._initrequest()
1435 
1436         #: original function name, without any decorations (for example
1437         #: parametrization adds a ``"[...]"`` suffix to function names).
1438         #:
1439         #: .. versionadded:: 3.0
1440         self.originalname = originalname
1441 
1442     def _initrequest(self):
1443         self.funcargs = {}
1444         self._request = fixtures.FixtureRequest(self)
1445 
1446     @property
1447     def function(self):
1448         "underlying python 'function' object"
1449         return getimfunc(self.obj)
1450 
1451     def _getobj(self):
1452         name = self.name
1453         i = name.find("[")  # parametrization
1454         if i != -1:
1455             name = name[:i]
1456         return getattr(self.parent.obj, name)
1457 
1458     @property
1459     def _pyfuncitem(self):
1460         "(compatonly) for code expecting pytest-2.2 style request objects"
1461         return self
1462 
1463     def runtest(self):
1464         """ execute the underlying test function. """
1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1466 
1467     def setup(self):
1468         super(Function, self).setup()
1469         fixtures.fillfixtures(self)
1470 
1471 
1472 class FunctionDefinition(Function):
1473     """
1474     internal hack until we get actual definition nodes instead of the
1475     crappy metafunc hack
1476     """
1477 
1478     def runtest(self):
1479         raise RuntimeError("function definitions are not supposed to be used")
1480 
1481     setup = runtest

</code><intended_behavior>Modify or extend the logic that processes and displays fixture information for the `--fixtures` command-line argument to include the scope of each fixture. The existing functionality of listing fixture names and descriptions should be preserved while enhancing the output to show each fixture's scope (e.g., function, class, module, session) next to its name. This may involve adjusting how fixture information is retrieved and formatting the output to include scope data.</intended_behavior>, <file>src/_pytest/helpconfig.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ version info, help messages, tracing configuration.  """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import os
7 import sys
8 from argparse import Action
9 
10 import py
11 
12 import pytest
13 from _pytest.config import PrintHelp
14 
15 
16 class HelpAction(Action):
17     """This is an argparse Action that will raise an exception in
18     order to skip the rest of the argument parsing when --help is passed.
19     This prevents argparse from quitting due to missing required arguments
20     when any are defined, for example by ``pytest_addoption``.
21     This is similar to the way that the builtin argparse --help option is
22     implemented by raising SystemExit.
23     """
24 
25     def __init__(self, option_strings, dest=None, default=False, help=None):
26         super(HelpAction, self).__init__(
27             option_strings=option_strings,
28             dest=dest,
29             const=True,
30             default=default,
31             nargs=0,
32             help=help,
33         )
34 
35     def __call__(self, parser, namespace, values, option_string=None):
36         setattr(namespace, self.dest, self.const)
37 
38         # We should only skip the rest of the parsing after preparse is done
39         if getattr(parser._parser, "after_preparse", False):
40             raise PrintHelp
41 
42 
43 def pytest_addoption(parser):
44     group = parser.getgroup("debugconfig")
45     group.addoption(
46         "--version",
47         action="store_true",
48         help="display pytest lib version and import information.",
49     )
50     group._addoption(
51         "-h",
52         "--help",
53         action=HelpAction,
54         dest="help",
55         help="show help message and configuration info",
56     )
57     group._addoption(
58         "-p",
59         action="append",
60         dest="plugins",
61         default=[],
62         metavar="name",
63         help="early-load given plugin module name or entry point (multi-allowed). "
64         "To avoid loading of plugins, use the `no:` prefix, e.g. "
65         "`no:doctest`.",
66     )
67     group.addoption(
68         "--traceconfig",
69         "--trace-config",
70         action="store_true",
71         default=False,
72         help="trace considerations of conftest.py files.",
73     ),
74     group.addoption(
75         "--debug",
76         action="store_true",
77         dest="debug",
78         default=False,
79         help="store internal tracing debug information in 'pytestdebug.log'.",
80     )
81     group._addoption(
82         "-o",
83         "--override-ini",
84         dest="override_ini",
85         action="append",
86         help='override ini option with "option=value" style, e.g. `-o xfail_strict=True -o cache_dir=cache`.',
87     )
88 
89 
90 @pytest.hookimpl(hookwrapper=True)
91 def pytest_cmdline_parse():
92     outcome = yield
93     config = outcome.get_result()
94     if config.option.debug:
95         path = os.path.abspath("pytestdebug.log")
96         debugfile = open(path, "w")
97         debugfile.write(
98             "versions pytest-%s, py-%s, "
99             "python-%s\ncwd=%s\nargs=%s\n\n"
100             % (
101                 pytest.__version__,
102                 py.__version__,
103                 ".".join(map(str, sys.version_info)),
104                 os.getcwd(),
105                 config._origargs,
106             )
107         )
108         config.trace.root.setwriter(debugfile.write)
109         undo_tracing = config.pluginmanager.enable_tracing()
110         sys.stderr.write("writing pytestdebug information to %s\n" % path)
111 
112         def unset_tracing():
113             debugfile.close()
114             sys.stderr.write("wrote pytestdebug information to %s\n" % debugfile.name)
115             config.trace.root.setwriter(None)
116             undo_tracing()
117 
118         config.add_cleanup(unset_tracing)
119 
120 
121 def showversion(config):
122     p = py.path.local(pytest.__file__)
123     sys.stderr.write(
124         "This is pytest version %s, imported from %s\n" % (pytest.__version__, p)
125     )
126     plugininfo = getpluginversioninfo(config)
127     if plugininfo:
128         for line in plugininfo:
129             sys.stderr.write(line + "\n")
130 
131 
132 def pytest_cmdline_main(config):
133     if config.option.version:
134         showversion(config)
135         return 0
136     elif config.option.help:
137         config._do_configure()
138         showhelp(config)
139         config._ensure_unconfigure()
140         return 0
141 
142 
143 def showhelp(config):
144     reporter = config.pluginmanager.get_plugin("terminalreporter")
145     tw = reporter._tw
146     tw.write(config._parser.optparser.format_help())
147     tw.line()
148     tw.line()
149     tw.line(
150         "[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:"
151     )
152     tw.line()
153 
154     columns = tw.fullwidth  # costly call
155     for name in config._parser._ininames:
156         help, type, default = config._parser._inidict[name]
157         if type is None:
158             type = "string"
159         spec = "%s (%s)" % (name, type)
160         line = "  %-24s %s" % (spec, help)
161         tw.line(line[:columns])
162 
163     tw.line()
164     tw.line("environment variables:")
165     vars = [
166         ("PYTEST_ADDOPTS", "extra command line options"),
167         ("PYTEST_PLUGINS", "comma-separated plugins to load during startup"),
168         ("PYTEST_DISABLE_PLUGIN_AUTOLOAD", "set to disable plugin auto-loading"),
169         ("PYTEST_DEBUG", "set to enable debug tracing of pytest's internals"),
170     ]
171     for name, help in vars:
172         tw.line("  %-24s %s" % (name, help))
173     tw.line()
174     tw.line()
175 
176     tw.line("to see available markers type: pytest --markers")
177     tw.line("to see available fixtures type: pytest --fixtures")
178     tw.line(
179         "(shown according to specified file_or_dir or current dir "
180         "if not specified; fixtures with leading '_' are only shown "
181         "with the '-v' option"
182     )
183 
184     for warningreport in reporter.stats.get("warnings", []):
185         tw.line("warning : " + warningreport.message, red=True)
186     return
187 
188 
189 conftest_options = [("pytest_plugins", "list of plugin names to load")]
190 
191 
192 def getpluginversioninfo(config):
193     lines = []
194     plugininfo = config.pluginmanager.list_plugin_distinfo()
195     if plugininfo:
196         lines.append("setuptools registered plugins:")
197         for plugin, dist in plugininfo:
198             loc = getattr(plugin, "__file__", repr(plugin))
199             content = "%s-%s at %s" % (dist.project_name, dist.version, loc)
200             lines.append("  " + content)
201     return lines
202 
203 
204 def pytest_report_header(config):
205     lines = []
206     if config.option.debug or config.option.traceconfig:
207         lines.append("using: pytest-%s pylib-%s" % (pytest.__version__, py.__version__))
208 
209         verinfo = getpluginversioninfo(config)
210         if verinfo:
211             lines.extend(verinfo)
212 
213     if config.option.traceconfig:
214         lines.append("active plugins:")
215         items = config.pluginmanager.list_name_plugin()
216         for name, plugin in items:
217             if hasattr(plugin, "__file__"):
218                 r = plugin.__file__
219             else:
220                 r = repr(plugin)
221             lines.append("    %-20s: %s" % (name, r))
222     return lines

</code><intended_behavior>If this file contains logic for the `--fixtures` argument's help text or processing, ensuring that any enhancements or modifications made in `python.py` regarding fixture scope display are consistent and supported here. The help text might need updating to indicate that fixture scope information will also be displayed.</intended_behavior>, <file>src/_pytest/fixtures.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import
2 from __future__ import division
3 from __future__ import print_function
4 
5 import functools
6 import inspect
7 import itertools
8 import sys
9 import warnings
10 from collections import defaultdict
11 from collections import deque
12 from collections import OrderedDict
13 
14 import attr
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import nodes
20 from _pytest._code.code import FormattedExcinfo
21 from _pytest._code.code import TerminalRepr
22 from _pytest.compat import _format_args
23 from _pytest.compat import _PytestWrapper
24 from _pytest.compat import exc_clear
25 from _pytest.compat import FuncargnamesCompatAttr
26 from _pytest.compat import get_real_func
27 from _pytest.compat import get_real_method
28 from _pytest.compat import getfslineno
29 from _pytest.compat import getfuncargnames
30 from _pytest.compat import getimfunc
31 from _pytest.compat import getlocation
32 from _pytest.compat import is_generator
33 from _pytest.compat import isclass
34 from _pytest.compat import NOTSET
35 from _pytest.compat import safe_getattr
36 from _pytest.deprecated import FIXTURE_FUNCTION_CALL
37 from _pytest.deprecated import FIXTURE_NAMED_REQUEST
38 from _pytest.outcomes import fail
39 from _pytest.outcomes import TEST_OUTCOME
40 
41 
42 @attr.s(frozen=True)
43 class PseudoFixtureDef(object):
44     cached_result = attr.ib()
45     scope = attr.ib()
46 
47 
48 def pytest_sessionstart(session):
49     import _pytest.python
50     import _pytest.nodes
51 
52     scopename2class.update(
53         {
54             "package": _pytest.python.Package,
55             "class": _pytest.python.Class,
56             "module": _pytest.python.Module,
57             "function": _pytest.nodes.Item,
58             "session": _pytest.main.Session,
59         }
60     )
61     session._fixturemanager = FixtureManager(session)
62 
63 
64 scopename2class = {}
65 
66 
67 scope2props = dict(session=())
68 scope2props["package"] = ("fspath",)
69 scope2props["module"] = ("fspath", "module")
70 scope2props["class"] = scope2props["module"] + ("cls",)
71 scope2props["instance"] = scope2props["class"] + ("instance",)
72 scope2props["function"] = scope2props["instance"] + ("function", "keywords")
73 
74 
75 def scopeproperty(name=None, doc=None):
76     def decoratescope(func):
77         scopename = name or func.__name__
78 
79         def provide(self):
80             if func.__name__ in scope2props[self.scope]:
81                 return func(self)
82             raise AttributeError(
83                 "%s not available in %s-scoped context" % (scopename, self.scope)
84             )
85 
86         return property(provide, None, None, func.__doc__)
87 
88     return decoratescope
89 
90 
91 def get_scope_package(node, fixturedef):
92     import pytest
93 
94     cls = pytest.Package
95     current = node
96     fixture_package_name = "%s/%s" % (fixturedef.baseid, "__init__.py")
97     while current and (
98         type(current) is not cls or fixture_package_name != current.nodeid
99     ):
100         current = current.parent
101     if current is None:
102         return node.session
103     return current
104 
105 
106 def get_scope_node(node, scope):
107     cls = scopename2class.get(scope)
108     if cls is None:
109         raise ValueError("unknown scope")
110     return node.getparent(cls)
111 
112 
113 def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):
114     # this function will transform all collected calls to a functions
115     # if they use direct funcargs (i.e. direct parametrization)
116     # because we want later test execution to be able to rely on
117     # an existing FixtureDef structure for all arguments.
118     # XXX we can probably avoid this algorithm  if we modify CallSpec2
119     # to directly care for creating the fixturedefs within its methods.
120     if not metafunc._calls[0].funcargs:
121         return  # this function call does not have direct parametrization
122     # collect funcargs of all callspecs into a list of values
123     arg2params = {}
124     arg2scope = {}
125     for callspec in metafunc._calls:
126         for argname, argvalue in callspec.funcargs.items():
127             assert argname not in callspec.params
128             callspec.params[argname] = argvalue
129             arg2params_list = arg2params.setdefault(argname, [])
130             callspec.indices[argname] = len(arg2params_list)
131             arg2params_list.append(argvalue)
132             if argname not in arg2scope:
133                 scopenum = callspec._arg2scopenum.get(argname, scopenum_function)
134                 arg2scope[argname] = scopes[scopenum]
135         callspec.funcargs.clear()
136 
137     # register artificial FixtureDef's so that later at test execution
138     # time we can rely on a proper FixtureDef to exist for fixture setup.
139     arg2fixturedefs = metafunc._arg2fixturedefs
140     for argname, valuelist in arg2params.items():
141         # if we have a scope that is higher than function we need
142         # to make sure we only ever create an according fixturedef on
143         # a per-scope basis. We thus store and cache the fixturedef on the
144         # node related to the scope.
145         scope = arg2scope[argname]
146         node = None
147         if scope != "function":
148             node = get_scope_node(collector, scope)
149             if node is None:
150                 assert scope == "class" and isinstance(collector, _pytest.python.Module)
151                 # use module-level collector for class-scope (for now)
152                 node = collector
153         if node and argname in node._name2pseudofixturedef:
154             arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]
155         else:
156             fixturedef = FixtureDef(
157                 fixturemanager,
158                 "",
159                 argname,
160                 get_direct_param_fixture_func,
161                 arg2scope[argname],
162                 valuelist,
163                 False,
164                 False,
165             )
166             arg2fixturedefs[argname] = [fixturedef]
167             if node is not None:
168                 node._name2pseudofixturedef[argname] = fixturedef
169 
170 
171 def getfixturemarker(obj):
172     """ return fixturemarker or None if it doesn't exist or raised
173     exceptions."""
174     try:
175         return getattr(obj, "_pytestfixturefunction", None)
176     except TEST_OUTCOME:
177         # some objects raise errors like request (from flask import request)
178         # we don't expect them to be fixture functions
179         return None
180 
181 
182 def get_parametrized_fixture_keys(item, scopenum):
183     """ return list of keys for all parametrized arguments which match
184     the specified scope. """
185     assert scopenum < scopenum_function  # function
186     try:
187         cs = item.callspec
188     except AttributeError:
189         pass
190     else:
191         # cs.indices.items() is random order of argnames.  Need to
192         # sort this so that different calls to
193         # get_parametrized_fixture_keys will be deterministic.
194         for argname, param_index in sorted(cs.indices.items()):
195             if cs._arg2scopenum[argname] != scopenum:
196                 continue
197             if scopenum == 0:  # session
198                 key = (argname, param_index)
199             elif scopenum == 1:  # package
200                 key = (argname, param_index, item.fspath.dirpath())
201             elif scopenum == 2:  # module
202                 key = (argname, param_index, item.fspath)
203             elif scopenum == 3:  # class
204                 key = (argname, param_index, item.fspath, item.cls)
205             yield key
206 
207 
208 # algorithm for sorting on a per-parametrized resource setup basis
209 # it is called for scopenum==0 (session) first and performs sorting
210 # down to the lower scopes such as to minimize number of "high scope"
211 # setups and teardowns
212 
213 
214 def reorder_items(items):
215     argkeys_cache = {}
216     items_by_argkey = {}
217     for scopenum in range(0, scopenum_function):
218         argkeys_cache[scopenum] = d = {}
219         items_by_argkey[scopenum] = item_d = defaultdict(deque)
220         for item in items:
221             keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))
222             if keys:
223                 d[item] = keys
224                 for key in keys:
225                     item_d[key].append(item)
226     items = OrderedDict.fromkeys(items)
227     return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))
228 
229 
230 def fix_cache_order(item, argkeys_cache, items_by_argkey):
231     for scopenum in range(0, scopenum_function):
232         for key in argkeys_cache[scopenum].get(item, []):
233             items_by_argkey[scopenum][key].appendleft(item)
234 
235 
236 def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):
237     if scopenum >= scopenum_function or len(items) < 3:
238         return items
239     ignore = set()
240     items_deque = deque(items)
241     items_done = OrderedDict()
242     scoped_items_by_argkey = items_by_argkey[scopenum]
243     scoped_argkeys_cache = argkeys_cache[scopenum]
244     while items_deque:
245         no_argkey_group = OrderedDict()
246         slicing_argkey = None
247         while items_deque:
248             item = items_deque.popleft()
249             if item in items_done or item in no_argkey_group:
250                 continue
251             argkeys = OrderedDict.fromkeys(
252                 k for k in scoped_argkeys_cache.get(item, []) if k not in ignore
253             )
254             if not argkeys:
255                 no_argkey_group[item] = None
256             else:
257                 slicing_argkey, _ = argkeys.popitem()
258                 # we don't have to remove relevant items from later in the deque because they'll just be ignored
259                 matching_items = [
260                     i for i in scoped_items_by_argkey[slicing_argkey] if i in items
261                 ]
262                 for i in reversed(matching_items):
263                     fix_cache_order(i, argkeys_cache, items_by_argkey)
264                     items_deque.appendleft(i)
265                 break
266         if no_argkey_group:
267             no_argkey_group = reorder_items_atscope(
268                 no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1
269             )
270             for item in no_argkey_group:
271                 items_done[item] = None
272         ignore.add(slicing_argkey)
273     return items_done
274 
275 
276 def fillfixtures(function):
277     """ fill missing funcargs for a test function. """
278     try:
279         request = function._request
280     except AttributeError:
281         # XXX this special code path is only expected to execute
282         # with the oejskit plugin.  It uses classes with funcargs
283         # and we thus have to work a bit to allow this.
284         fm = function.session._fixturemanager
285         fi = fm.getfixtureinfo(function.parent, function.obj, None)
286         function._fixtureinfo = fi
287         request = function._request = FixtureRequest(function)
288         request._fillfixtures()
289         # prune out funcargs for jstests
290         newfuncargs = {}
291         for name in fi.argnames:
292             newfuncargs[name] = function.funcargs[name]
293         function.funcargs = newfuncargs
294     else:
295         request._fillfixtures()
296 
297 
298 def get_direct_param_fixture_func(request):
299     return request.param
300 
301 
302 @attr.s(slots=True)
303 class FuncFixtureInfo(object):
304     # original function argument names
305     argnames = attr.ib(type=tuple)
306     # argnames that function immediately requires. These include argnames +
307     # fixture names specified via usefixtures and via autouse=True in fixture
308     # definitions.
309     initialnames = attr.ib(type=tuple)
310     names_closure = attr.ib()  # List[str]
311     name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]
312 
313     def prune_dependency_tree(self):
314         """Recompute names_closure from initialnames and name2fixturedefs
315 
316         Can only reduce names_closure, which means that the new closure will
317         always be a subset of the old one. The order is preserved.
318 
319         This method is needed because direct parametrization may shadow some
320         of the fixtures that were included in the originally built dependency
321         tree. In this way the dependency tree can get pruned, and the closure
322         of argnames may get reduced.
323         """
324         closure = set()
325         working_set = set(self.initialnames)
326         while working_set:
327             argname = working_set.pop()
328             # argname may be smth not included in the original names_closure,
329             # in which case we ignore it. This currently happens with pseudo
330             # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.
331             # So they introduce the new dependency 'request' which might have
332             # been missing in the original tree (closure).
333             if argname not in closure and argname in self.names_closure:
334                 closure.add(argname)
335                 if argname in self.name2fixturedefs:
336                     working_set.update(self.name2fixturedefs[argname][-1].argnames)
337 
338         self.names_closure[:] = sorted(closure, key=self.names_closure.index)
339 
340 
341 class FixtureRequest(FuncargnamesCompatAttr):
342     """ A request for a fixture from a test or fixture function.
343 
344     A request object gives access to the requesting test context
345     and has an optional ``param`` attribute in case
346     the fixture is parametrized indirectly.
347     """
348 
349     def __init__(self, pyfuncitem):
350         self._pyfuncitem = pyfuncitem
351         #: fixture for which this request is being performed
352         self.fixturename = None
353         #: Scope string, one of "function", "class", "module", "session"
354         self.scope = "function"
355         self._fixture_defs = {}  # argname -> FixtureDef
356         fixtureinfo = pyfuncitem._fixtureinfo
357         self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()
358         self._arg2index = {}
359         self._fixturemanager = pyfuncitem.session._fixturemanager
360 
361     @property
362     def fixturenames(self):
363         """names of all active fixtures in this request"""
364         result = list(self._pyfuncitem._fixtureinfo.names_closure)
365         result.extend(set(self._fixture_defs).difference(result))
366         return result
367 
368     @property
369     def node(self):
370         """ underlying collection node (depends on current request scope)"""
371         return self._getscopeitem(self.scope)
372 
373     def _getnextfixturedef(self, argname):
374         fixturedefs = self._arg2fixturedefs.get(argname, None)
375         if fixturedefs is None:
376             # we arrive here because of a dynamic call to
377             # getfixturevalue(argname) usage which was naturally
378             # not known at parsing/collection time
379             parentid = self._pyfuncitem.parent.nodeid
380             fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)
381             self._arg2fixturedefs[argname] = fixturedefs
382         # fixturedefs list is immutable so we maintain a decreasing index
383         index = self._arg2index.get(argname, 0) - 1
384         if fixturedefs is None or (-index > len(fixturedefs)):
385             raise FixtureLookupError(argname, self)
386         self._arg2index[argname] = index
387         return fixturedefs[index]
388 
389     @property
390     def config(self):
391         """ the pytest config object associated with this request. """
392         return self._pyfuncitem.config
393 
394     @scopeproperty()
395     def function(self):
396         """ test function object if the request has a per-function scope. """
397         return self._pyfuncitem.obj
398 
399     @scopeproperty("class")
400     def cls(self):
401         """ class (can be None) where the test function was collected. """
402         clscol = self._pyfuncitem.getparent(_pytest.python.Class)
403         if clscol:
404             return clscol.obj
405 
406     @property
407     def instance(self):
408         """ instance (can be None) on which test function was collected. """
409         # unittest support hack, see _pytest.unittest.TestCaseFunction
410         try:
411             return self._pyfuncitem._testcase
412         except AttributeError:
413             function = getattr(self, "function", None)
414             return getattr(function, "__self__", None)
415 
416     @scopeproperty()
417     def module(self):
418         """ python module object where the test function was collected. """
419         return self._pyfuncitem.getparent(_pytest.python.Module).obj
420 
421     @scopeproperty()
422     def fspath(self):
423         """ the file system path of the test module which collected this test. """
424         return self._pyfuncitem.fspath
425 
426     @property
427     def keywords(self):
428         """ keywords/markers dictionary for the underlying node. """
429         return self.node.keywords
430 
431     @property
432     def session(self):
433         """ pytest session object. """
434         return self._pyfuncitem.session
435 
436     def addfinalizer(self, finalizer):
437         """ add finalizer/teardown function to be called after the
438         last test within the requesting test context finished
439         execution. """
440         # XXX usually this method is shadowed by fixturedef specific ones
441         self._addfinalizer(finalizer, scope=self.scope)
442 
443     def _addfinalizer(self, finalizer, scope):
444         colitem = self._getscopeitem(scope)
445         self._pyfuncitem.session._setupstate.addfinalizer(
446             finalizer=finalizer, colitem=colitem
447         )
448 
449     def applymarker(self, marker):
450         """ Apply a marker to a single test function invocation.
451         This method is useful if you don't want to have a keyword/marker
452         on all function invocations.
453 
454         :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object
455             created by a call to ``pytest.mark.NAME(...)``.
456         """
457         self.node.add_marker(marker)
458 
459     def raiseerror(self, msg):
460         """ raise a FixtureLookupError with the given message. """
461         raise self._fixturemanager.FixtureLookupError(None, self, msg)
462 
463     def _fillfixtures(self):
464         item = self._pyfuncitem
465         fixturenames = getattr(item, "fixturenames", self.fixturenames)
466         for argname in fixturenames:
467             if argname not in item.funcargs:
468                 item.funcargs[argname] = self.getfixturevalue(argname)
469 
470     def getfixturevalue(self, argname):
471         """ Dynamically run a named fixture function.
472 
473         Declaring fixtures via function argument is recommended where possible.
474         But if you can only decide whether to use another fixture at test
475         setup time, you may use this function to retrieve it inside a fixture
476         or test function body.
477         """
478         return self._get_active_fixturedef(argname).cached_result[0]
479 
480     def getfuncargvalue(self, argname):
481         """ Deprecated, use getfixturevalue. """
482         from _pytest import deprecated
483 
484         warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)
485         return self.getfixturevalue(argname)
486 
487     def _get_active_fixturedef(self, argname):
488         try:
489             return self._fixture_defs[argname]
490         except KeyError:
491             try:
492                 fixturedef = self._getnextfixturedef(argname)
493             except FixtureLookupError:
494                 if argname == "request":
495                     cached_result = (self, [0], None)
496                     scope = "function"
497                     return PseudoFixtureDef(cached_result, scope)
498                 raise
499         # remove indent to prevent the python3 exception
500         # from leaking into the call
501         self._compute_fixture_value(fixturedef)
502         self._fixture_defs[argname] = fixturedef
503         return fixturedef
504 
505     def _get_fixturestack(self):
506         current = self
507         values = []
508         while 1:
509             fixturedef = getattr(current, "_fixturedef", None)
510             if fixturedef is None:
511                 values.reverse()
512                 return values
513             values.append(fixturedef)
514             current = current._parent_request
515 
516     def _compute_fixture_value(self, fixturedef):
517         """
518         Creates a SubRequest based on "self" and calls the execute method of the given fixturedef object. This will
519         force the FixtureDef object to throw away any previous results and compute a new fixture value, which
520         will be stored into the FixtureDef object itself.
521 
522         :param FixtureDef fixturedef:
523         """
524         # prepare a subrequest object before calling fixture function
525         # (latter managed by fixturedef)
526         argname = fixturedef.argname
527         funcitem = self._pyfuncitem
528         scope = fixturedef.scope
529         try:
530             param = funcitem.callspec.getparam(argname)
531         except (AttributeError, ValueError):
532             param = NOTSET
533             param_index = 0
534             has_params = fixturedef.params is not None
535             fixtures_not_supported = getattr(funcitem, "nofuncargs", False)
536             if has_params and fixtures_not_supported:
537                 msg = (
538                     "{name} does not support fixtures, maybe unittest.TestCase subclass?\n"
539                     "Node id: {nodeid}\n"
540                     "Function type: {typename}"
541                 ).format(
542                     name=funcitem.name,
543                     nodeid=funcitem.nodeid,
544                     typename=type(funcitem).__name__,
545                 )
546                 fail(msg, pytrace=False)
547             if has_params:
548                 frame = inspect.stack()[3]
549                 frameinfo = inspect.getframeinfo(frame[0])
550                 source_path = frameinfo.filename
551                 source_lineno = frameinfo.lineno
552                 source_path = py.path.local(source_path)
553                 if source_path.relto(funcitem.config.rootdir):
554                     source_path = source_path.relto(funcitem.config.rootdir)
555                 msg = (
556                     "The requested fixture has no parameter defined for test:\n"
557                     "    {}\n\n"
558                     "Requested fixture '{}' defined in:\n{}"
559                     "\n\nRequested here:\n{}:{}".format(
560                         funcitem.nodeid,
561                         fixturedef.argname,
562                         getlocation(fixturedef.func, funcitem.config.rootdir),
563                         source_path,
564                         source_lineno,
565                     )
566                 )
567                 fail(msg, pytrace=False)
568         else:
569             param_index = funcitem.callspec.indices[argname]
570             # if a parametrize invocation set a scope it will override
571             # the static scope defined with the fixture function
572             paramscopenum = funcitem.callspec._arg2scopenum.get(argname)
573             if paramscopenum is not None:
574                 scope = scopes[paramscopenum]
575 
576         subrequest = SubRequest(self, scope, param, param_index, fixturedef)
577 
578         # check if a higher-level scoped fixture accesses a lower level one
579         subrequest._check_scope(argname, self.scope, scope)
580 
581         # clear sys.exc_info before invoking the fixture (python bug?)
582         # if it's not explicitly cleared it will leak into the call
583         exc_clear()
584         try:
585             # call the fixture function
586             fixturedef.execute(request=subrequest)
587         finally:
588             self._schedule_finalizers(fixturedef, subrequest)
589 
590     def _schedule_finalizers(self, fixturedef, subrequest):
591         # if fixture function failed it might have registered finalizers
592         self.session._setupstate.addfinalizer(
593             functools.partial(fixturedef.finish, request=subrequest), subrequest.node
594         )
595 
596     def _check_scope(self, argname, invoking_scope, requested_scope):
597         if argname == "request":
598             return
599         if scopemismatch(invoking_scope, requested_scope):
600             # try to report something helpful
601             lines = self._factorytraceback()
602             fail(
603                 "ScopeMismatch: You tried to access the %r scoped "
604                 "fixture %r with a %r scoped request object, "
605                 "involved factories\n%s"
606                 % ((requested_scope, argname, invoking_scope, "\n".join(lines))),
607                 pytrace=False,
608             )
609 
610     def _factorytraceback(self):
611         lines = []
612         for fixturedef in self._get_fixturestack():
613             factory = fixturedef.func
614             fs, lineno = getfslineno(factory)
615             p = self._pyfuncitem.session.fspath.bestrelpath(fs)
616             args = _format_args(factory)
617             lines.append("%s:%d:  def %s%s" % (p, lineno + 1, factory.__name__, args))
618         return lines
619 
620     def _getscopeitem(self, scope):
621         if scope == "function":
622             # this might also be a non-function Item despite its attribute name
623             return self._pyfuncitem
624         if scope == "package":
625             node = get_scope_package(self._pyfuncitem, self._fixturedef)
626         else:
627             node = get_scope_node(self._pyfuncitem, scope)
628         if node is None and scope == "class":
629             # fallback to function item itself
630             node = self._pyfuncitem
631         assert node, 'Could not obtain a node for scope "{}" for function {!r}'.format(
632             scope, self._pyfuncitem
633         )
634         return node
635 
636     def __repr__(self):
637         return "<FixtureRequest for %r>" % (self.node)
638 
639 
640 class SubRequest(FixtureRequest):
641     """ a sub request for handling getting a fixture from a
642     test function/fixture. """
643 
644     def __init__(self, request, scope, param, param_index, fixturedef):
645         self._parent_request = request
646         self.fixturename = fixturedef.argname
647         if param is not NOTSET:
648             self.param = param
649         self.param_index = param_index
650         self.scope = scope
651         self._fixturedef = fixturedef
652         self._pyfuncitem = request._pyfuncitem
653         self._fixture_defs = request._fixture_defs
654         self._arg2fixturedefs = request._arg2fixturedefs
655         self._arg2index = request._arg2index
656         self._fixturemanager = request._fixturemanager
657 
658     def __repr__(self):
659         return "<SubRequest %r for %r>" % (self.fixturename, self._pyfuncitem)
660 
661     def addfinalizer(self, finalizer):
662         self._fixturedef.addfinalizer(finalizer)
663 
664     def _schedule_finalizers(self, fixturedef, subrequest):
665         # if the executing fixturedef was not explicitly requested in the argument list (via
666         # getfixturevalue inside the fixture call) then ensure this fixture def will be finished
667         # first
668         if fixturedef.argname not in self.funcargnames:
669             fixturedef.addfinalizer(
670                 functools.partial(self._fixturedef.finish, request=self)
671             )
672         super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)
673 
674 
675 scopes = "session package module class function".split()
676 scopenum_function = scopes.index("function")
677 
678 
679 def scopemismatch(currentscope, newscope):
680     return scopes.index(newscope) > scopes.index(currentscope)
681 
682 
683 def scope2index(scope, descr, where=None):
684     """Look up the index of ``scope`` and raise a descriptive value error
685     if not defined.
686     """
687     try:
688         return scopes.index(scope)
689     except ValueError:
690         fail(
691             "{} {}got an unexpected scope value '{}'".format(
692                 descr, "from {} ".format(where) if where else "", scope
693             ),
694             pytrace=False,
695         )
696 
697 
698 class FixtureLookupError(LookupError):
699     """ could not return a requested Fixture (missing or invalid). """
700 
701     def __init__(self, argname, request, msg=None):
702         self.argname = argname
703         self.request = request
704         self.fixturestack = request._get_fixturestack()
705         self.msg = msg
706 
707     def formatrepr(self):
708         tblines = []
709         addline = tblines.append
710         stack = [self.request._pyfuncitem.obj]
711         stack.extend(map(lambda x: x.func, self.fixturestack))
712         msg = self.msg
713         if msg is not None:
714             # the last fixture raise an error, let's present
715             # it at the requesting side
716             stack = stack[:-1]
717         for function in stack:
718             fspath, lineno = getfslineno(function)
719             try:
720                 lines, _ = inspect.getsourcelines(get_real_func(function))
721             except (IOError, IndexError, TypeError):
722                 error_msg = "file %s, line %s: source code not available"
723                 addline(error_msg % (fspath, lineno + 1))
724             else:
725                 addline("file %s, line %s" % (fspath, lineno + 1))
726                 for i, line in enumerate(lines):
727                     line = line.rstrip()
728                     addline("  " + line)
729                     if line.lstrip().startswith("def"):
730                         break
731 
732         if msg is None:
733             fm = self.request._fixturemanager
734             available = set()
735             parentid = self.request._pyfuncitem.parent.nodeid
736             for name, fixturedefs in fm._arg2fixturedefs.items():
737                 faclist = list(fm._matchfactories(fixturedefs, parentid))
738                 if faclist:
739                     available.add(name)
740             if self.argname in available:
741                 msg = " recursive dependency involving fixture '{}' detected".format(
742                     self.argname
743                 )
744             else:
745                 msg = "fixture '{}' not found".format(self.argname)
746             msg += "\n available fixtures: {}".format(", ".join(sorted(available)))
747             msg += "\n use 'pytest --fixtures [testpath]' for help on them."
748 
749         return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)
750 
751 
752 class FixtureLookupErrorRepr(TerminalRepr):
753     def __init__(self, filename, firstlineno, tblines, errorstring, argname):
754         self.tblines = tblines
755         self.errorstring = errorstring
756         self.filename = filename
757         self.firstlineno = firstlineno
758         self.argname = argname
759 
760     def toterminal(self, tw):
761         # tw.line("FixtureLookupError: %s" %(self.argname), red=True)
762         for tbline in self.tblines:
763             tw.line(tbline.rstrip())
764         lines = self.errorstring.split("\n")
765         if lines:
766             tw.line(
767                 "{}       {}".format(FormattedExcinfo.fail_marker, lines[0].strip()),
768                 red=True,
769             )
770             for line in lines[1:]:
771                 tw.line(
772                     "{}       {}".format(FormattedExcinfo.flow_marker, line.strip()),
773                     red=True,
774                 )
775         tw.line()
776         tw.line("%s:%d" % (self.filename, self.firstlineno + 1))
777 
778 
779 def fail_fixturefunc(fixturefunc, msg):
780     fs, lineno = getfslineno(fixturefunc)
781     location = "%s:%s" % (fs, lineno + 1)
782     source = _pytest._code.Source(fixturefunc)
783     fail(msg + ":\n\n" + str(source.indent()) + "\n" + location, pytrace=False)
784 
785 
786 def call_fixture_func(fixturefunc, request, kwargs):
787     yieldctx = is_generator(fixturefunc)
788     if yieldctx:
789         it = fixturefunc(**kwargs)
790         res = next(it)
791         finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)
792         request.addfinalizer(finalizer)
793     else:
794         res = fixturefunc(**kwargs)
795     return res
796 
797 
798 def _teardown_yield_fixture(fixturefunc, it):
799     """Executes the teardown of a fixture function by advancing the iterator after the
800     yield and ensure the iteration ends (if not it means there is more than one yield in the function)"""
801     try:
802         next(it)
803     except StopIteration:
804         pass
805     else:
806         fail_fixturefunc(
807             fixturefunc, "yield_fixture function has more than one 'yield'"
808         )
809 
810 
811 class FixtureDef(object):
812     """ A container for a factory definition. """
813 
814     def __init__(
815         self,
816         fixturemanager,
817         baseid,
818         argname,
819         func,
820         scope,
821         params,
822         unittest=False,
823         ids=None,
824     ):
825         self._fixturemanager = fixturemanager
826         self.baseid = baseid or ""
827         self.has_location = baseid is not None
828         self.func = func
829         self.argname = argname
830         self.scope = scope
831         self.scopenum = scope2index(
832             scope or "function",
833             descr="Fixture '{}'".format(func.__name__),
834             where=baseid,
835         )
836         self.params = params
837         self.argnames = getfuncargnames(func, is_method=unittest)
838         self.unittest = unittest
839         self.ids = ids
840         self._finalizers = []
841 
842     def addfinalizer(self, finalizer):
843         self._finalizers.append(finalizer)
844 
845     def finish(self, request):
846         exceptions = []
847         try:
848             while self._finalizers:
849                 try:
850                     func = self._finalizers.pop()
851                     func()
852                 except:  # noqa
853                     exceptions.append(sys.exc_info())
854             if exceptions:
855                 e = exceptions[0]
856                 del (
857                     exceptions
858                 )  # ensure we don't keep all frames alive because of the traceback
859                 six.reraise(*e)
860 
861         finally:
862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)
864             # even if finalization fails, we invalidate
865             # the cached fixture value and remove
866             # all finalizers because they may be bound methods which will
867             # keep instances alive
868             if hasattr(self, "cached_result"):
869                 del self.cached_result
870             self._finalizers = []
871 
872     def execute(self, request):
873         # get required arguments and register our own finish()
874         # with their finalization
875         for argname in self.argnames:
876             fixturedef = request._get_active_fixturedef(argname)
877             if argname != "request":
878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))
879 
880         my_cache_key = request.param_index
881         cached_result = getattr(self, "cached_result", None)
882         if cached_result is not None:
883             result, cache_key, err = cached_result
884             if my_cache_key == cache_key:
885                 if err is not None:
886                     six.reraise(*err)
887                 else:
888                     return result
889             # we have a previous but differently parametrized fixture instance
890             # so we need to tear it down before creating a new one
891             self.finish(request)
892             assert not hasattr(self, "cached_result")
893 
894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
895         return hook.pytest_fixture_setup(fixturedef=self, request=request)
896 
897     def __repr__(self):
898         return "<FixtureDef argname=%r scope=%r baseid=%r>" % (
899             self.argname,
900             self.scope,
901             self.baseid,
902         )
903 
904 
905 def resolve_fixture_function(fixturedef, request):
906     """Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific
907     instances and bound methods.
908     """
909     fixturefunc = fixturedef.func
910     if fixturedef.unittest:
911         if request.instance is not None:
912             # bind the unbound method to the TestCase instance
913             fixturefunc = fixturedef.func.__get__(request.instance)
914     else:
915         # the fixture function needs to be bound to the actual
916         # request.instance so that code working with "fixturedef" behaves
917         # as expected.
918         if request.instance is not None:
919             fixturefunc = getimfunc(fixturedef.func)
920             if fixturefunc != fixturedef.func:
921                 fixturefunc = fixturefunc.__get__(request.instance)
922     return fixturefunc
923 
924 
925 def pytest_fixture_setup(fixturedef, request):
926     """ Execution of fixture setup. """
927     kwargs = {}
928     for argname in fixturedef.argnames:
929         fixdef = request._get_active_fixturedef(argname)
930         result, arg_cache_key, exc = fixdef.cached_result
931         request._check_scope(argname, request.scope, fixdef.scope)
932         kwargs[argname] = result
933 
934     fixturefunc = resolve_fixture_function(fixturedef, request)
935     my_cache_key = request.param_index
936     try:
937         result = call_fixture_func(fixturefunc, request, kwargs)
938     except TEST_OUTCOME:
939         fixturedef.cached_result = (None, my_cache_key, sys.exc_info())
940         raise
941     fixturedef.cached_result = (result, my_cache_key, None)
942     return result
943 
944 
945 def _ensure_immutable_ids(ids):
946     if ids is None:
947         return
948     if callable(ids):
949         return ids
950     return tuple(ids)
951 
952 
953 def wrap_function_to_error_out_if_called_directly(function, fixture_marker):
954     """Wrap the given fixture function so we can raise an error about it being called directly,
955     instead of used as an argument in a test function.
956     """
957     message = FIXTURE_FUNCTION_CALL.format(
958         name=fixture_marker.name or function.__name__
959     )
960 
961     @six.wraps(function)
962     def result(*args, **kwargs):
963         fail(message, pytrace=False)
964 
965     # keep reference to the original function in our own custom attribute so we don't unwrap
966     # further than this point and lose useful wrappings like @mock.patch (#3774)
967     result.__pytest_wrapped__ = _PytestWrapper(function)
968 
969     return result
970 
971 
972 @attr.s(frozen=True)
973 class FixtureFunctionMarker(object):
974     scope = attr.ib()
975     params = attr.ib(converter=attr.converters.optional(tuple))
976     autouse = attr.ib(default=False)
977     ids = attr.ib(default=None, converter=_ensure_immutable_ids)
978     name = attr.ib(default=None)
979 
980     def __call__(self, function):
981         if isclass(function):
982             raise ValueError("class fixtures not supported (maybe in the future)")
983 
984         if getattr(function, "_pytestfixturefunction", False):
985             raise ValueError(
986                 "fixture is being applied more than once to the same function"
987             )
988 
989         function = wrap_function_to_error_out_if_called_directly(function, self)
990 
991         name = self.name or function.__name__
992         if name == "request":
993             warnings.warn(FIXTURE_NAMED_REQUEST)
994         function._pytestfixturefunction = self
995         return function
996 
997 
998 def fixture(scope="function", params=None, autouse=False, ids=None, name=None):
999     """Decorator to mark a fixture factory function.
1000 
1001     This decorator can be used, with or without parameters, to define a
1002     fixture function.
1003 
1004     The name of the fixture function can later be referenced to cause its
1005     invocation ahead of running tests: test
1006     modules or classes can use the ``pytest.mark.usefixtures(fixturename)``
1007     marker.
1008 
1009     Test functions can directly use fixture names as input
1010     arguments in which case the fixture instance returned from the fixture
1011     function will be injected.
1012 
1013     Fixtures can provide their values to test functions using ``return`` or ``yield``
1014     statements. When using ``yield`` the code block after the ``yield`` statement is executed
1015     as teardown code regardless of the test outcome, and must yield exactly once.
1016 
1017     :arg scope: the scope for which this fixture is shared, one of
1018                 ``"function"`` (default), ``"class"``, ``"module"``,
1019                 ``"package"`` or ``"session"``.
1020 
1021                 ``"package"`` is considered **experimental** at this time.
1022 
1023     :arg params: an optional list of parameters which will cause multiple
1024                 invocations of the fixture function and all of the tests
1025                 using it.
1026                 The current parameter is available in ``request.param``.
1027 
1028     :arg autouse: if True, the fixture func is activated for all tests that
1029                 can see it.  If False (the default) then an explicit
1030                 reference is needed to activate the fixture.
1031 
1032     :arg ids: list of string ids each corresponding to the params
1033                 so that they are part of the test id. If no ids are provided
1034                 they will be generated automatically from the params.
1035 
1036     :arg name: the name of the fixture. This defaults to the name of the
1037                 decorated function. If a fixture is used in the same module in
1038                 which it is defined, the function name of the fixture will be
1039                 shadowed by the function arg that requests the fixture; one way
1040                 to resolve this is to name the decorated function
1041                 ``fixture_<fixturename>`` and then use
1042                 ``@pytest.fixture(name='<fixturename>')``.
1043     """
1044     if callable(scope) and params is None and autouse is False:
1045         # direct decoration
1046         return FixtureFunctionMarker("function", params, autouse, name=name)(scope)
1047     if params is not None and not isinstance(params, (list, tuple)):
1048         params = list(params)
1049     return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)
1050 
1051 
1052 def yield_fixture(scope="function", params=None, autouse=False, ids=None, name=None):
1053     """ (return a) decorator to mark a yield-fixture factory function.
1054 
1055     .. deprecated:: 3.0
1056         Use :py:func:`pytest.fixture` directly instead.
1057     """
1058     return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)
1059 
1060 
1061 defaultfuncargprefixmarker = fixture()
1062 
1063 
1064 @fixture(scope="session")
1065 def pytestconfig(request):
1066     """Session-scoped fixture that returns the :class:`_pytest.config.Config` object.
1067 
1068     Example::
1069 
1070         def test_foo(pytestconfig):
1071             if pytestconfig.getoption("verbose") > 0:
1072                 ...
1073 
1074     """
1075     return request.config
1076 
1077 
1078 class FixtureManager(object):
1079     """
1080     pytest fixtures definitions and information is stored and managed
1081     from this class.
1082 
1083     During collection fm.parsefactories() is called multiple times to parse
1084     fixture function definitions into FixtureDef objects and internal
1085     data structures.
1086 
1087     During collection of test functions, metafunc-mechanics instantiate
1088     a FuncFixtureInfo object which is cached per node/func-name.
1089     This FuncFixtureInfo object is later retrieved by Function nodes
1090     which themselves offer a fixturenames attribute.
1091 
1092     The FuncFixtureInfo object holds information about fixtures and FixtureDefs
1093     relevant for a particular function.  An initial list of fixtures is
1094     assembled like this:
1095 
1096     - ini-defined usefixtures
1097     - autouse-marked fixtures along the collection chain up from the function
1098     - usefixtures markers at module/class/function level
1099     - test function funcargs
1100 
1101     Subsequently the funcfixtureinfo.fixturenames attribute is computed
1102     as the closure of the fixtures needed to setup the initial fixtures,
1103     i. e. fixtures needed by fixture functions themselves are appended
1104     to the fixturenames list.
1105 
1106     Upon the test-setup phases all fixturenames are instantiated, retrieved
1107     by a lookup of their FuncFixtureInfo.
1108     """
1109 
1110     FixtureLookupError = FixtureLookupError
1111     FixtureLookupErrorRepr = FixtureLookupErrorRepr
1112 
1113     def __init__(self, session):
1114         self.session = session
1115         self.config = session.config
1116         self._arg2fixturedefs = {}
1117         self._holderobjseen = set()
1118         self._arg2finish = {}
1119         self._nodeid_and_autousenames = [("", self.config.getini("usefixtures"))]
1120         session.config.pluginmanager.register(self, "funcmanage")
1121 
1122     def getfixtureinfo(self, node, func, cls, funcargs=True):
1123         if funcargs and not getattr(node, "nofuncargs", False):
1124             argnames = getfuncargnames(func, cls=cls)
1125         else:
1126             argnames = ()
1127         usefixtures = itertools.chain.from_iterable(
1128             mark.args for mark in node.iter_markers(name="usefixtures")
1129         )
1130         initialnames = tuple(usefixtures) + argnames
1131         fm = node.session._fixturemanager
1132         initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(
1133             initialnames, node
1134         )
1135         return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)
1136 
1137     def pytest_plugin_registered(self, plugin):
1138         nodeid = None
1139         try:
1140             p = py.path.local(plugin.__file__).realpath()
1141         except AttributeError:
1142             pass
1143         else:
1144             # construct the base nodeid which is later used to check
1145             # what fixtures are visible for particular tests (as denoted
1146             # by their test id)
1147             if p.basename.startswith("conftest.py"):
1148                 nodeid = p.dirpath().relto(self.config.rootdir)
1149                 if p.sep != nodes.SEP:
1150                     nodeid = nodeid.replace(p.sep, nodes.SEP)
1151 
1152         self.parsefactories(plugin, nodeid)
1153 
1154     def _getautousenames(self, nodeid):
1155         """ return a tuple of fixture names to be used. """
1156         autousenames = []
1157         for baseid, basenames in self._nodeid_and_autousenames:
1158             if nodeid.startswith(baseid):
1159                 if baseid:
1160                     i = len(baseid)
1161                     nextchar = nodeid[i : i + 1]
1162                     if nextchar and nextchar not in ":/":
1163                         continue
1164                 autousenames.extend(basenames)
1165         return autousenames
1166 
1167     def getfixtureclosure(self, fixturenames, parentnode):
1168         # collect the closure of all fixtures , starting with the given
1169         # fixturenames as the initial set.  As we have to visit all
1170         # factory definitions anyway, we also return an arg2fixturedefs
1171         # mapping so that the caller can reuse it and does not have
1172         # to re-discover fixturedefs again for each fixturename
1173         # (discovering matching fixtures for a given name/node is expensive)
1174 
1175         parentid = parentnode.nodeid
1176         fixturenames_closure = self._getautousenames(parentid)
1177 
1178         def merge(otherlist):
1179             for arg in otherlist:
1180                 if arg not in fixturenames_closure:
1181                     fixturenames_closure.append(arg)
1182 
1183         merge(fixturenames)
1184 
1185         # at this point, fixturenames_closure contains what we call "initialnames",
1186         # which is a set of fixturenames the function immediately requests. We
1187         # need to return it as well, so save this.
1188         initialnames = tuple(fixturenames_closure)
1189 
1190         arg2fixturedefs = {}
1191         lastlen = -1
1192         while lastlen != len(fixturenames_closure):
1193             lastlen = len(fixturenames_closure)
1194             for argname in fixturenames_closure:
1195                 if argname in arg2fixturedefs:
1196                     continue
1197                 fixturedefs = self.getfixturedefs(argname, parentid)
1198                 if fixturedefs:
1199                     arg2fixturedefs[argname] = fixturedefs
1200                     merge(fixturedefs[-1].argnames)
1201 
1202         def sort_by_scope(arg_name):
1203             try:
1204                 fixturedefs = arg2fixturedefs[arg_name]
1205             except KeyError:
1206                 return scopes.index("function")
1207             else:
1208                 return fixturedefs[-1].scopenum
1209 
1210         fixturenames_closure.sort(key=sort_by_scope)
1211         return initialnames, fixturenames_closure, arg2fixturedefs
1212 
1213     def pytest_generate_tests(self, metafunc):
1214         for argname in metafunc.fixturenames:
1215             faclist = metafunc._arg2fixturedefs.get(argname)
1216             if faclist:
1217                 fixturedef = faclist[-1]
1218                 if fixturedef.params is not None:
1219                     markers = list(metafunc.definition.iter_markers("parametrize"))
1220                     for parametrize_mark in markers:
1221                         if "argnames" in parametrize_mark.kwargs:
1222                             argnames = parametrize_mark.kwargs["argnames"]
1223                         else:
1224                             argnames = parametrize_mark.args[0]
1225 
1226                         if not isinstance(argnames, (tuple, list)):
1227                             argnames = [
1228                                 x.strip() for x in argnames.split(",") if x.strip()
1229                             ]
1230                         if argname in argnames:
1231                             break
1232                     else:
1233                         metafunc.parametrize(
1234                             argname,
1235                             fixturedef.params,
1236                             indirect=True,
1237                             scope=fixturedef.scope,
1238                             ids=fixturedef.ids,
1239                         )
1240             else:
1241                 continue  # will raise FixtureLookupError at setup time
1242 
1243     def pytest_collection_modifyitems(self, items):
1244         # separate parametrized setups
1245         items[:] = reorder_items(items)
1246 
1247     def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):
1248         if nodeid is not NOTSET:
1249             holderobj = node_or_obj
1250         else:
1251             holderobj = node_or_obj.obj
1252             nodeid = node_or_obj.nodeid
1253         if holderobj in self._holderobjseen:
1254             return
1255 
1256         self._holderobjseen.add(holderobj)
1257         autousenames = []
1258         for name in dir(holderobj):
1259             # The attribute can be an arbitrary descriptor, so the attribute
1260             # access below can raise. safe_getatt() ignores such exceptions.
1261             obj = safe_getattr(holderobj, name, None)
1262             marker = getfixturemarker(obj)
1263             if not isinstance(marker, FixtureFunctionMarker):
1264                 # magic globals  with __getattr__ might have got us a wrong
1265                 # fixture attribute
1266                 continue
1267 
1268             if marker.name:
1269                 name = marker.name
1270 
1271             # during fixture definition we wrap the original fixture function
1272             # to issue a warning if called directly, so here we unwrap it in order to not emit the warning
1273             # when pytest itself calls the fixture function
1274             if six.PY2 and unittest:
1275                 # hack on Python 2 because of the unbound methods
1276                 obj = get_real_func(obj)
1277             else:
1278                 obj = get_real_method(obj, holderobj)
1279 
1280             fixture_def = FixtureDef(
1281                 self,
1282                 nodeid,
1283                 name,
1284                 obj,
1285                 marker.scope,
1286                 marker.params,
1287                 unittest=unittest,
1288                 ids=marker.ids,
1289             )
1290 
1291             faclist = self._arg2fixturedefs.setdefault(name, [])
1292             if fixture_def.has_location:
1293                 faclist.append(fixture_def)
1294             else:
1295                 # fixturedefs with no location are at the front
1296                 # so this inserts the current fixturedef after the
1297                 # existing fixturedefs from external plugins but
1298                 # before the fixturedefs provided in conftests.
1299                 i = len([f for f in faclist if not f.has_location])
1300                 faclist.insert(i, fixture_def)
1301             if marker.autouse:
1302                 autousenames.append(name)
1303 
1304         if autousenames:
1305             self._nodeid_and_autousenames.append((nodeid or "", autousenames))
1306 
1307     def getfixturedefs(self, argname, nodeid):
1308         """
1309         Gets a list of fixtures which are applicable to the given node id.
1310 
1311         :param str argname: name of the fixture to search for
1312         :param str nodeid: full node id of the requesting test.
1313         :return: list[FixtureDef]
1314         """
1315         try:
1316             fixturedefs = self._arg2fixturedefs[argname]
1317         except KeyError:
1318             return None
1319         return tuple(self._matchfactories(fixturedefs, nodeid))
1320 
1321     def _matchfactories(self, fixturedefs, nodeid):
1322         for fixturedef in fixturedefs:
1323             if nodes.ischildnode(fixturedef.baseid, nodeid):
1324                 yield fixturedef

</code><intended_behavior>This file likely defines and manages fixtures. If there are utility methods here that fetch fixture metadata (including scope), ensuring these methods are suitably integrated into the logic that outputs fixture information for `--fixtures`. We may not need to directly modify this file, but it's important to ensure that any changes made are compatible with how fixtures and their scopes are defined and managed here.</intended_behavior>]
2025-10-15 09:47:59.789 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 09:47:59.789 | INFO     | Search-only: skipping patch selection
2025-10-15 09:47:59.860 | INFO     | Task pytest-dev__pytest-5221 completed successfully.
2025-10-15 09:47:59.861 | INFO     | No patch generated. You can try running ACR again.
