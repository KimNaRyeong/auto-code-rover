[
    {
        "rel_file_path": "src/_pytest/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/python.py",
        "start": 1,
        "end": 1481,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Python test discovery, setup and run of test functions. \"\"\"\n2 from __future__ import absolute_import\n3 from __future__ import division\n4 from __future__ import print_function\n5 \n6 import collections\n7 import fnmatch\n8 import inspect\n9 import os\n10 import sys\n11 import warnings\n12 from functools import partial\n13 from textwrap import dedent\n14 \n15 import py\n16 import six\n17 \n18 import _pytest\n19 from _pytest import deprecated\n20 from _pytest import fixtures\n21 from _pytest import nodes\n22 from _pytest._code import filter_traceback\n23 from _pytest.compat import ascii_escaped\n24 from _pytest.compat import enum\n25 from _pytest.compat import get_default_arg_names\n26 from _pytest.compat import get_real_func\n27 from _pytest.compat import getfslineno\n28 from _pytest.compat import getimfunc\n29 from _pytest.compat import getlocation\n30 from _pytest.compat import is_generator\n31 from _pytest.compat import isclass\n32 from _pytest.compat import isfunction\n33 from _pytest.compat import NoneType\n34 from _pytest.compat import NOTSET\n35 from _pytest.compat import REGEX_TYPE\n36 from _pytest.compat import safe_getattr\n37 from _pytest.compat import safe_isclass\n38 from _pytest.compat import safe_str\n39 from _pytest.compat import STRING_TYPES\n40 from _pytest.config import hookimpl\n41 from _pytest.main import FSHookProxy\n42 from _pytest.mark import MARK_GEN\n43 from _pytest.mark.structures import get_unpacked_marks\n44 from _pytest.mark.structures import normalize_mark_list\n45 from _pytest.outcomes import fail\n46 from _pytest.outcomes import skip\n47 from _pytest.pathlib import parts\n48 from _pytest.warning_types import PytestCollectionWarning\n49 from _pytest.warning_types import PytestUnhandledCoroutineWarning\n50 \n51 \n52 def pyobj_property(name):\n53     def get(self):\n54         node = self.getparent(getattr(__import__(\"pytest\"), name))\n55         if node is not None:\n56             return node.obj\n57 \n58     doc = \"python %s object this node was collected from (can be None).\" % (\n59         name.lower(),\n60     )\n61     return property(get, None, None, doc)\n62 \n63 \n64 def pytest_addoption(parser):\n65     group = parser.getgroup(\"general\")\n66     group.addoption(\n67         \"--fixtures\",\n68         \"--funcargs\",\n69         action=\"store_true\",\n70         dest=\"showfixtures\",\n71         default=False,\n72         help=\"show available fixtures, sorted by plugin appearance \"\n73         \"(fixtures with leading '_' are only shown with '-v')\",\n74     )\n75     group.addoption(\n76         \"--fixtures-per-test\",\n77         action=\"store_true\",\n78         dest=\"show_fixtures_per_test\",\n79         default=False,\n80         help=\"show fixtures per test\",\n81     )\n82     parser.addini(\n83         \"usefixtures\",\n84         type=\"args\",\n85         default=[],\n86         help=\"list of default fixtures to be used with this project\",\n87     )\n88     parser.addini(\n89         \"python_files\",\n90         type=\"args\",\n91         default=[\"test_*.py\", \"*_test.py\"],\n92         help=\"glob-style file patterns for Python test module discovery\",\n93     )\n94     parser.addini(\n95         \"python_classes\",\n96         type=\"args\",\n97         default=[\"Test\"],\n98         help=\"prefixes or glob names for Python test class discovery\",\n99     )\n100     parser.addini(\n101         \"python_functions\",\n102         type=\"args\",\n103         default=[\"test\"],\n104         help=\"prefixes or glob names for Python test function and method discovery\",\n105     )\n106     parser.addini(\n107         \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n108         type=\"bool\",\n109         default=False,\n110         help=\"disable string escape non-ascii characters, might cause unwanted \"\n111         \"side effects(use at your own risk)\",\n112     )\n113 \n114     group.addoption(\n115         \"--import-mode\",\n116         default=\"prepend\",\n117         choices=[\"prepend\", \"append\"],\n118         dest=\"importmode\",\n119         help=\"prepend/append to sys.path when importing test modules, \"\n120         \"default is to prepend.\",\n121     )\n122 \n123 \n124 def pytest_cmdline_main(config):\n125     if config.option.showfixtures:\n126         showfixtures(config)\n127         return 0\n128     if config.option.show_fixtures_per_test:\n129         show_fixtures_per_test(config)\n130         return 0\n131 \n132 \n133 def pytest_generate_tests(metafunc):\n134     # those alternative spellings are common - raise a specific error to alert\n135     # the user\n136     alt_spellings = [\"parameterize\", \"parametrise\", \"parameterise\"]\n137     for mark_name in alt_spellings:\n138         if metafunc.definition.get_closest_marker(mark_name):\n139             msg = \"{0} has '{1}' mark, spelling should be 'parametrize'\"\n140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)\n141     for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n142         metafunc.parametrize(*marker.args, **marker.kwargs)\n143 \n144 \n145 def pytest_configure(config):\n146     config.addinivalue_line(\n147         \"markers\",\n148         \"parametrize(argnames, argvalues): call a test function multiple \"\n149         \"times passing in different arguments in turn. argvalues generally \"\n150         \"needs to be a list of values if argnames specifies only one name \"\n151         \"or a list of tuples of values if argnames specifies multiple names. \"\n152         \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n153         \"decorated test function, one with arg1=1 and another with arg1=2.\"\n154         \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n155         \"and examples.\",\n156     )\n157     config.addinivalue_line(\n158         \"markers\",\n159         \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n160         \"all of the specified fixtures. see \"\n161         \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n162     )\n163 \n164 \n165 @hookimpl(trylast=True)\n166 def pytest_pyfunc_call(pyfuncitem):\n167     testfunction = pyfuncitem.obj\n168     iscoroutinefunction = getattr(inspect, \"iscoroutinefunction\", None)\n169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):\n170         msg = \"Coroutine functions are not natively supported and have been skipped.\\n\"\n171         msg += \"You need to install a suitable plugin for your async framework, for example:\\n\"\n172         msg += \"  - pytest-asyncio\\n\"\n173         msg += \"  - pytest-trio\\n\"\n174         msg += \"  - pytest-tornasync\"\n175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))\n176         skip(msg=\"coroutine function and no async plugin installed (see warnings)\")\n177     funcargs = pyfuncitem.funcargs\n178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n179     testfunction(**testargs)\n180     return True\n181 \n182 \n183 def pytest_collect_file(path, parent):\n184     ext = path.ext\n185     if ext == \".py\":\n186         if not parent.session.isinitpath(path):\n187             if not path_matches_patterns(\n188                 path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n189             ):\n190                 return\n191         ihook = parent.session.gethookproxy(path)\n192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n193 \n194 \n195 def path_matches_patterns(path, patterns):\n196     \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n197     return any(path.fnmatch(pattern) for pattern in patterns)\n198 \n199 \n200 def pytest_pycollect_makemodule(path, parent):\n201     if path.basename == \"__init__.py\":\n202         return Package(path, parent)\n203     return Module(path, parent)\n204 \n205 \n206 @hookimpl(hookwrapper=True)\n207 def pytest_pycollect_makeitem(collector, name, obj):\n208     outcome = yield\n209     res = outcome.get_result()\n210     if res is not None:\n211         return\n212     # nothing was collected elsewhere, let's do it here\n213     if safe_isclass(obj):\n214         if collector.istestclass(obj, name):\n215             outcome.force_result(Class(name, parent=collector))\n216     elif collector.istestfunction(obj, name):\n217         # mock seems to store unbound methods (issue473), normalize it\n218         obj = getattr(obj, \"__func__\", obj)\n219         # We need to try and unwrap the function if it's a functools.partial\n220         # or a funtools.wrapped.\n221         # We musn't if it's been wrapped with mock.patch (python 2 only)\n222         if not (isfunction(obj) or isfunction(get_real_func(obj))):\n223             filename, lineno = getfslineno(obj)\n224             warnings.warn_explicit(\n225                 message=PytestCollectionWarning(\n226                     \"cannot collect %r because it is not a function.\" % name\n227                 ),\n228                 category=None,\n229                 filename=str(filename),\n230                 lineno=lineno + 1,\n231             )\n232         elif getattr(obj, \"__test__\", True):\n233             if is_generator(obj):\n234                 res = Function(name, parent=collector)\n235                 reason = deprecated.YIELD_TESTS.format(name=name)\n236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n237                 res.warn(PytestCollectionWarning(reason))\n238             else:\n239                 res = list(collector._genfunctions(name, obj))\n240             outcome.force_result(res)\n241 \n242 \n243 def pytest_make_parametrize_id(config, val, argname=None):\n244     return None\n245 \n246 \n247 class PyobjContext(object):\n248     module = pyobj_property(\"Module\")\n249     cls = pyobj_property(\"Class\")\n250     instance = pyobj_property(\"Instance\")\n251 \n252 \n253 class PyobjMixin(PyobjContext):\n254     _ALLOW_MARKERS = True\n255 \n256     def __init__(self, *k, **kw):\n257         super(PyobjMixin, self).__init__(*k, **kw)\n258 \n259     @property\n260     def obj(self):\n261         \"\"\"Underlying Python object.\"\"\"\n262         obj = getattr(self, \"_obj\", None)\n263         if obj is None:\n264             self._obj = obj = self._getobj()\n265             # XXX evil hack\n266             # used to avoid Instance collector marker duplication\n267             if self._ALLOW_MARKERS:\n268                 self.own_markers.extend(get_unpacked_marks(self.obj))\n269         return obj\n270 \n271     @obj.setter\n272     def obj(self, value):\n273         self._obj = value\n274 \n275     def _getobj(self):\n276         \"\"\"Gets the underlying Python object. May be overwritten by subclasses.\"\"\"\n277         return getattr(self.parent.obj, self.name)\n278 \n279     def getmodpath(self, stopatmodule=True, includemodule=False):\n280         \"\"\" return python path relative to the containing module. \"\"\"\n281         chain = self.listchain()\n282         chain.reverse()\n283         parts = []\n284         for node in chain:\n285             if isinstance(node, Instance):\n286                 continue\n287             name = node.name\n288             if isinstance(node, Module):\n289                 name = os.path.splitext(name)[0]\n290                 if stopatmodule:\n291                     if includemodule:\n292                         parts.append(name)\n293                     break\n294             parts.append(name)\n295         parts.reverse()\n296         s = \".\".join(parts)\n297         return s.replace(\".[\", \"[\")\n298 \n299     def reportinfo(self):\n300         # XXX caching?\n301         obj = self.obj\n302         compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n303         if isinstance(compat_co_firstlineno, int):\n304             # nose compatibility\n305             fspath = sys.modules[obj.__module__].__file__\n306             if fspath.endswith(\".pyc\"):\n307                 fspath = fspath[:-1]\n308             lineno = compat_co_firstlineno\n309         else:\n310             fspath, lineno = getfslineno(obj)\n311         modpath = self.getmodpath()\n312         assert isinstance(lineno, int)\n313         return fspath, lineno, modpath\n314 \n315 \n316 class PyCollector(PyobjMixin, nodes.Collector):\n317     def funcnamefilter(self, name):\n318         return self._matches_prefix_or_glob_option(\"python_functions\", name)\n319 \n320     def isnosetest(self, obj):\n321         \"\"\" Look for the __test__ attribute, which is applied by the\n322         @nose.tools.istest decorator\n323         \"\"\"\n324         # We explicitly check for \"is True\" here to not mistakenly treat\n325         # classes with a custom __getattr__ returning something truthy (like a\n326         # function) as test classes.\n327         return safe_getattr(obj, \"__test__\", False) is True\n328 \n329     def classnamefilter(self, name):\n330         return self._matches_prefix_or_glob_option(\"python_classes\", name)\n331 \n332     def istestfunction(self, obj, name):\n333         if self.funcnamefilter(name) or self.isnosetest(obj):\n334             if isinstance(obj, staticmethod):\n335                 # static methods need to be unwrapped\n336                 obj = safe_getattr(obj, \"__func__\", False)\n337             return (\n338                 safe_getattr(obj, \"__call__\", False)\n339                 and fixtures.getfixturemarker(obj) is None\n340             )\n341         else:\n342             return False\n343 \n344     def istestclass(self, obj, name):\n345         return self.classnamefilter(name) or self.isnosetest(obj)\n346 \n347     def _matches_prefix_or_glob_option(self, option_name, name):\n348         \"\"\"\n349         checks if the given name matches the prefix or glob-pattern defined\n350         in ini configuration.\n351         \"\"\"\n352         for option in self.config.getini(option_name):\n353             if name.startswith(option):\n354                 return True\n355             # check that name looks like a glob-string before calling fnmatch\n356             # because this is called for every name in each collected module,\n357             # and fnmatch is somewhat expensive to call\n358             elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n359                 name, option\n360             ):\n361                 return True\n362         return False\n363 \n364     def collect(self):\n365         if not getattr(self.obj, \"__test__\", True):\n366             return []\n367 \n368         # NB. we avoid random getattrs and peek in the __dict__ instead\n369         # (XXX originally introduced from a PyPy need, still true?)\n370         dicts = [getattr(self.obj, \"__dict__\", {})]\n371         for basecls in inspect.getmro(self.obj.__class__):\n372             dicts.append(basecls.__dict__)\n373         seen = {}\n374         values = []\n375         for dic in dicts:\n376             for name, obj in list(dic.items()):\n377                 if name in seen:\n378                     continue\n379                 seen[name] = True\n380                 res = self._makeitem(name, obj)\n381                 if res is None:\n382                     continue\n383                 if not isinstance(res, list):\n384                     res = [res]\n385                 values.extend(res)\n386         values.sort(key=lambda item: item.reportinfo()[:2])\n387         return values\n388 \n389     def _makeitem(self, name, obj):\n390         # assert self.ihook.fspath == self.fspath, self\n391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)\n392 \n393     def _genfunctions(self, name, funcobj):\n394         module = self.getparent(Module).obj\n395         clscol = self.getparent(Class)\n396         cls = clscol and clscol.obj or None\n397         fm = self.session._fixturemanager\n398 \n399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)\n400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)\n401 \n402         metafunc = Metafunc(\n403             definition, fixtureinfo, self.config, cls=cls, module=module\n404         )\n405         methods = []\n406         if hasattr(module, \"pytest_generate_tests\"):\n407             methods.append(module.pytest_generate_tests)\n408         if hasattr(cls, \"pytest_generate_tests\"):\n409             methods.append(cls().pytest_generate_tests)\n410         if methods:\n411             self.ihook.pytest_generate_tests.call_extra(\n412                 methods, dict(metafunc=metafunc)\n413             )\n414         else:\n415             self.ihook.pytest_generate_tests(metafunc=metafunc)\n416 \n417         if not metafunc._calls:\n418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)\n419         else:\n420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs\n421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n422 \n423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n424             # with direct parametrization, so make sure we update what the\n425             # function really needs.\n426             fixtureinfo.prune_dependency_tree()\n427 \n428             for callspec in metafunc._calls:\n429                 subname = \"%s[%s]\" % (name, callspec.id)\n430                 yield Function(\n431                     name=subname,\n432                     parent=self,\n433                     callspec=callspec,\n434                     callobj=funcobj,\n435                     fixtureinfo=fixtureinfo,\n436                     keywords={callspec.id: True},\n437                     originalname=name,\n438                 )\n439 \n440 \n441 class Module(nodes.File, PyCollector):\n442     \"\"\" Collector for test classes and functions. \"\"\"\n443 \n444     def _getobj(self):\n445         return self._importtestmodule()\n446 \n447     def collect(self):\n448         self._inject_setup_module_fixture()\n449         self._inject_setup_function_fixture()\n450         self.session._fixturemanager.parsefactories(self)\n451         return super(Module, self).collect()\n452 \n453     def _inject_setup_module_fixture(self):\n454         \"\"\"Injects a hidden autouse, module scoped fixture into the collected module object\n455         that invokes setUpModule/tearDownModule if either or both are available.\n456 \n457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n458         other fixtures (#517).\n459         \"\"\"\n460         setup_module = _get_non_fixture_func(self.obj, \"setUpModule\")\n461         if setup_module is None:\n462             setup_module = _get_non_fixture_func(self.obj, \"setup_module\")\n463 \n464         teardown_module = _get_non_fixture_func(self.obj, \"tearDownModule\")\n465         if teardown_module is None:\n466             teardown_module = _get_non_fixture_func(self.obj, \"teardown_module\")\n467 \n468         if setup_module is None and teardown_module is None:\n469             return\n470 \n471         @fixtures.fixture(autouse=True, scope=\"module\")\n472         def xunit_setup_module_fixture(request):\n473             if setup_module is not None:\n474                 _call_with_optional_argument(setup_module, request.module)\n475             yield\n476             if teardown_module is not None:\n477                 _call_with_optional_argument(teardown_module, request.module)\n478 \n479         self.obj.__pytest_setup_module = xunit_setup_module_fixture\n480 \n481     def _inject_setup_function_fixture(self):\n482         \"\"\"Injects a hidden autouse, function scoped fixture into the collected module object\n483         that invokes setup_function/teardown_function if either or both are available.\n484 \n485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n486         other fixtures (#517).\n487         \"\"\"\n488         setup_function = _get_non_fixture_func(self.obj, \"setup_function\")\n489         teardown_function = _get_non_fixture_func(self.obj, \"teardown_function\")\n490         if setup_function is None and teardown_function is None:\n491             return\n492 \n493         @fixtures.fixture(autouse=True, scope=\"function\")\n494         def xunit_setup_function_fixture(request):\n495             if request.instance is not None:\n496                 # in this case we are bound to an instance, so we need to let\n497                 # setup_method handle this\n498                 yield\n499                 return\n500             if setup_function is not None:\n501                 _call_with_optional_argument(setup_function, request.function)\n502             yield\n503             if teardown_function is not None:\n504                 _call_with_optional_argument(teardown_function, request.function)\n505 \n506         self.obj.__pytest_setup_function = xunit_setup_function_fixture\n507 \n508     def _importtestmodule(self):\n509         # we assume we are only called once per module\n510         importmode = self.config.getoption(\"--import-mode\")\n511         try:\n512             mod = self.fspath.pyimport(ensuresyspath=importmode)\n513         except SyntaxError:\n514             raise self.CollectError(\n515                 _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n516             )\n517         except self.fspath.ImportMismatchError:\n518             e = sys.exc_info()[1]\n519             raise self.CollectError(\n520                 \"import file mismatch:\\n\"\n521                 \"imported module %r has this __file__ attribute:\\n\"\n522                 \"  %s\\n\"\n523                 \"which is not the same as the test file we want to collect:\\n\"\n524                 \"  %s\\n\"\n525                 \"HINT: remove __pycache__ / .pyc files and/or use a \"\n526                 \"unique basename for your test file modules\" % e.args\n527             )\n528         except ImportError:\n529             from _pytest._code.code import ExceptionInfo\n530 \n531             exc_info = ExceptionInfo.from_current()\n532             if self.config.getoption(\"verbose\") < 2:\n533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n534             exc_repr = (\n535                 exc_info.getrepr(style=\"short\")\n536                 if exc_info.traceback\n537                 else exc_info.exconly()\n538             )\n539             formatted_tb = safe_str(exc_repr)\n540             raise self.CollectError(\n541                 \"ImportError while importing test module '{fspath}'.\\n\"\n542                 \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n543                 \"Traceback:\\n\"\n544                 \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n545             )\n546         except _pytest.runner.Skipped as e:\n547             if e.allow_module_level:\n548                 raise\n549             raise self.CollectError(\n550                 \"Using pytest.skip outside of a test is not allowed. \"\n551                 \"To decorate a test function, use the @pytest.mark.skip \"\n552                 \"or @pytest.mark.skipif decorators instead, and to skip a \"\n553                 \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n554             )\n555         self.config.pluginmanager.consider_module(mod)\n556         return mod\n557 \n558 \n559 class Package(Module):\n560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n561         session = parent.session\n562         nodes.FSCollector.__init__(\n563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid\n564         )\n565         self.name = fspath.dirname\n566         self.trace = session.trace\n567         self._norecursepatterns = session._norecursepatterns\n568         self.fspath = fspath\n569 \n570     def setup(self):\n571         # not using fixtures to call setup_module here because autouse fixtures\n572         # from packages are not called automatically (#4085)\n573         setup_module = _get_non_fixture_func(self.obj, \"setUpModule\")\n574         if setup_module is None:\n575             setup_module = _get_non_fixture_func(self.obj, \"setup_module\")\n576         if setup_module is not None:\n577             _call_with_optional_argument(setup_module, self.obj)\n578 \n579         teardown_module = _get_non_fixture_func(self.obj, \"tearDownModule\")\n580         if teardown_module is None:\n581             teardown_module = _get_non_fixture_func(self.obj, \"teardown_module\")\n582         if teardown_module is not None:\n583             func = partial(_call_with_optional_argument, teardown_module, self.obj)\n584             self.addfinalizer(func)\n585 \n586     def _recurse(self, dirpath):\n587         if dirpath.basename == \"__pycache__\":\n588             return False\n589         ihook = self.gethookproxy(dirpath.dirpath())\n590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):\n591             return\n592         for pat in self._norecursepatterns:\n593             if dirpath.check(fnmatch=pat):\n594                 return False\n595         ihook = self.gethookproxy(dirpath)\n596         ihook.pytest_collect_directory(path=dirpath, parent=self)\n597         return True\n598 \n599     def gethookproxy(self, fspath):\n600         # check if we have the common case of running\n601         # hooks with all conftest.py filesall conftest.py\n602         pm = self.config.pluginmanager\n603         my_conftestmodules = pm._getconftestmodules(fspath)\n604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n605         if remove_mods:\n606             # one or more conftests are not in use at this fspath\n607             proxy = FSHookProxy(fspath, pm, remove_mods)\n608         else:\n609             # all plugis are active for this fspath\n610             proxy = self.config.hook\n611         return proxy\n612 \n613     def _collectfile(self, path, handle_dupes=True):\n614         assert path.isfile(), \"%r is not a file (isdir=%r, exists=%r, islink=%r)\" % (\n615             path,\n616             path.isdir(),\n617             path.exists(),\n618             path.islink(),\n619         )\n620         ihook = self.gethookproxy(path)\n621         if not self.isinitpath(path):\n622             if ihook.pytest_ignore_collect(path=path, config=self.config):\n623                 return ()\n624 \n625         if handle_dupes:\n626             keepduplicates = self.config.getoption(\"keepduplicates\")\n627             if not keepduplicates:\n628                 duplicate_paths = self.config.pluginmanager._duplicatepaths\n629                 if path in duplicate_paths:\n630                     return ()\n631                 else:\n632                     duplicate_paths.add(path)\n633 \n634         if self.fspath == path:  # __init__.py\n635             return [self]\n636 \n637         return ihook.pytest_collect_file(path=path, parent=self)\n638 \n639     def isinitpath(self, path):\n640         return path in self.session._initialpaths\n641 \n642     def collect(self):\n643         this_path = self.fspath.dirpath()\n644         init_module = this_path.join(\"__init__.py\")\n645         if init_module.check(file=1) and path_matches_patterns(\n646             init_module, self.config.getini(\"python_files\")\n647         ):\n648             yield Module(init_module, self)\n649         pkg_prefixes = set()\n650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):\n651             # We will visit our own __init__.py file, in which case we skip it.\n652             is_file = path.isfile()\n653             if is_file:\n654                 if path.basename == \"__init__.py\" and path.dirpath() == this_path:\n655                     continue\n656 \n657             parts_ = parts(path.strpath)\n658             if any(\n659                 pkg_prefix in parts_ and pkg_prefix.join(\"__init__.py\") != path\n660                 for pkg_prefix in pkg_prefixes\n661             ):\n662                 continue\n663 \n664             if is_file:\n665                 for x in self._collectfile(path):\n666                     yield x\n667             elif not path.isdir():\n668                 # Broken symlink or invalid/missing file.\n669                 continue\n670             elif path.join(\"__init__.py\").check(file=1):\n671                 pkg_prefixes.add(path)\n672 \n673 \n674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):\n675     \"\"\"\n676     Return a callable to perform xunit-style setup or teardown if\n677     the function exists in the ``holder`` object.\n678     The ``param_obj`` parameter is the parameter which will be passed to the function\n679     when the callable is called without arguments, defaults to the ``holder`` object.\n680     Return ``None`` if a suitable callable is not found.\n681     \"\"\"\n682     # TODO: only needed because of Package!\n683     param_obj = param_obj if param_obj is not None else holder\n684     result = _get_non_fixture_func(holder, attr_name)\n685     if result is not None:\n686         arg_count = result.__code__.co_argcount\n687         if inspect.ismethod(result):\n688             arg_count -= 1\n689         if arg_count:\n690             return lambda: result(param_obj)\n691         else:\n692             return result\n693 \n694 \n695 def _call_with_optional_argument(func, arg):\n696     \"\"\"Call the given function with the given argument if func accepts one argument, otherwise\n697     calls func without arguments\"\"\"\n698     arg_count = func.__code__.co_argcount\n699     if inspect.ismethod(func):\n700         arg_count -= 1\n701     if arg_count:\n702         func(arg)\n703     else:\n704         func()\n705 \n706 \n707 def _get_non_fixture_func(obj, name):\n708     \"\"\"Return the attribute from the given object to be used as a setup/teardown\n709     xunit-style function, but only if not marked as a fixture to\n710     avoid calling it twice.\n711     \"\"\"\n712     meth = getattr(obj, name, None)\n713     if fixtures.getfixturemarker(meth) is None:\n714         return meth\n715 \n716 \n717 class Class(PyCollector):\n718     \"\"\" Collector for test methods. \"\"\"\n719 \n720     def collect(self):\n721         if not safe_getattr(self.obj, \"__test__\", True):\n722             return []\n723         if hasinit(self.obj):\n724             self.warn(\n725                 PytestCollectionWarning(\n726                     \"cannot collect test class %r because it has a \"\n727                     \"__init__ constructor\" % self.obj.__name__\n728                 )\n729             )\n730             return []\n731         elif hasnew(self.obj):\n732             self.warn(\n733                 PytestCollectionWarning(\n734                     \"cannot collect test class %r because it has a \"\n735                     \"__new__ constructor\" % self.obj.__name__\n736                 )\n737             )\n738             return []\n739 \n740         self._inject_setup_class_fixture()\n741         self._inject_setup_method_fixture()\n742 \n743         return [Instance(name=\"()\", parent=self)]\n744 \n745     def _inject_setup_class_fixture(self):\n746         \"\"\"Injects a hidden autouse, class scoped fixture into the collected class object\n747         that invokes setup_class/teardown_class if either or both are available.\n748 \n749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n750         other fixtures (#517).\n751         \"\"\"\n752         setup_class = _get_non_fixture_func(self.obj, \"setup_class\")\n753         teardown_class = getattr(self.obj, \"teardown_class\", None)\n754         if setup_class is None and teardown_class is None:\n755             return\n756 \n757         @fixtures.fixture(autouse=True, scope=\"class\")\n758         def xunit_setup_class_fixture(cls):\n759             if setup_class is not None:\n760                 func = getimfunc(setup_class)\n761                 _call_with_optional_argument(func, self.obj)\n762             yield\n763             if teardown_class is not None:\n764                 func = getimfunc(teardown_class)\n765                 _call_with_optional_argument(func, self.obj)\n766 \n767         self.obj.__pytest_setup_class = xunit_setup_class_fixture\n768 \n769     def _inject_setup_method_fixture(self):\n770         \"\"\"Injects a hidden autouse, function scoped fixture into the collected class object\n771         that invokes setup_method/teardown_method if either or both are available.\n772 \n773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n774         other fixtures (#517).\n775         \"\"\"\n776         setup_method = _get_non_fixture_func(self.obj, \"setup_method\")\n777         teardown_method = getattr(self.obj, \"teardown_method\", None)\n778         if setup_method is None and teardown_method is None:\n779             return\n780 \n781         @fixtures.fixture(autouse=True, scope=\"function\")\n782         def xunit_setup_method_fixture(self, request):\n783             method = request.function\n784             if setup_method is not None:\n785                 func = getattr(self, \"setup_method\")\n786                 _call_with_optional_argument(func, method)\n787             yield\n788             if teardown_method is not None:\n789                 func = getattr(self, \"teardown_method\")\n790                 _call_with_optional_argument(func, method)\n791 \n792         self.obj.__pytest_setup_method = xunit_setup_method_fixture\n793 \n794 \n795 class Instance(PyCollector):\n796     _ALLOW_MARKERS = False  # hack, destroy later\n797     # instances share the object with their parents in a way\n798     # that duplicates markers instances if not taken out\n799     # can be removed at node structure reorganization time\n800 \n801     def _getobj(self):\n802         return self.parent.obj()\n803 \n804     def collect(self):\n805         self.session._fixturemanager.parsefactories(self)\n806         return super(Instance, self).collect()\n807 \n808     def newinstance(self):\n809         self.obj = self._getobj()\n810         return self.obj\n811 \n812 \n813 class FunctionMixin(PyobjMixin):\n814     \"\"\" mixin for the code common to Function and Generator.\n815     \"\"\"\n816 \n817     def setup(self):\n818         \"\"\" perform setup for this test function. \"\"\"\n819         if isinstance(self.parent, Instance):\n820             self.parent.newinstance()\n821             self.obj = self._getobj()\n822 \n823     def _prunetraceback(self, excinfo):\n824         if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n825             code = _pytest._code.Code(get_real_func(self.obj))\n826             path, firstlineno = code.path, code.firstlineno\n827             traceback = excinfo.traceback\n828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n829             if ntraceback == traceback:\n830                 ntraceback = ntraceback.cut(path=path)\n831                 if ntraceback == traceback:\n832                     ntraceback = ntraceback.filter(filter_traceback)\n833                     if not ntraceback:\n834                         ntraceback = traceback\n835 \n836             excinfo.traceback = ntraceback.filter()\n837             # issue364: mark all but first and last frames to\n838             # only show a single-line message for each frame\n839             if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n840                 if len(excinfo.traceback) > 2:\n841                     for entry in excinfo.traceback[1:-1]:\n842                         entry.set_repr_style(\"short\")\n843 \n844     def repr_failure(self, excinfo, outerr=None):\n845         assert outerr is None, \"XXX outerr usage is deprecated\"\n846         style = self.config.getoption(\"tbstyle\", \"auto\")\n847         if style == \"auto\":\n848             style = \"long\"\n849         return self._repr_failure_py(excinfo, style=style)\n850 \n851 \n852 def hasinit(obj):\n853     init = getattr(obj, \"__init__\", None)\n854     if init:\n855         return init != object.__init__\n856 \n857 \n858 def hasnew(obj):\n859     new = getattr(obj, \"__new__\", None)\n860     if new:\n861         return new != object.__new__\n862 \n863 \n864 class CallSpec2(object):\n865     def __init__(self, metafunc):\n866         self.metafunc = metafunc\n867         self.funcargs = {}\n868         self._idlist = []\n869         self.params = {}\n870         self._globalid = NOTSET\n871         self._globalparam = NOTSET\n872         self._arg2scopenum = {}  # used for sorting parametrized resources\n873         self.marks = []\n874         self.indices = {}\n875 \n876     def copy(self):\n877         cs = CallSpec2(self.metafunc)\n878         cs.funcargs.update(self.funcargs)\n879         cs.params.update(self.params)\n880         cs.marks.extend(self.marks)\n881         cs.indices.update(self.indices)\n882         cs._arg2scopenum.update(self._arg2scopenum)\n883         cs._idlist = list(self._idlist)\n884         cs._globalid = self._globalid\n885         cs._globalparam = self._globalparam\n886         return cs\n887 \n888     def _checkargnotcontained(self, arg):\n889         if arg in self.params or arg in self.funcargs:\n890             raise ValueError(\"duplicate %r\" % (arg,))\n891 \n892     def getparam(self, name):\n893         try:\n894             return self.params[name]\n895         except KeyError:\n896             if self._globalparam is NOTSET:\n897                 raise ValueError(name)\n898             return self._globalparam\n899 \n900     @property\n901     def id(self):\n902         return \"-\".join(map(str, filter(None, self._idlist)))\n903 \n904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):\n905         for arg, val in zip(argnames, valset):\n906             self._checkargnotcontained(arg)\n907             valtype_for_arg = valtypes[arg]\n908             getattr(self, valtype_for_arg)[arg] = val\n909             self.indices[arg] = param_index\n910             self._arg2scopenum[arg] = scopenum\n911         self._idlist.append(id)\n912         self.marks.extend(normalize_mark_list(marks))\n913 \n914     def setall(self, funcargs, id, param):\n915         for x in funcargs:\n916             self._checkargnotcontained(x)\n917         self.funcargs.update(funcargs)\n918         if id is not NOTSET:\n919             self._idlist.append(id)\n920         if param is not NOTSET:\n921             assert self._globalparam is NOTSET\n922             self._globalparam = param\n923         for arg in funcargs:\n924             self._arg2scopenum[arg] = fixtures.scopenum_function\n925 \n926 \n927 class Metafunc(fixtures.FuncargnamesCompatAttr):\n928     \"\"\"\n929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n930     They help to inspect a test function and to generate tests according to\n931     test configuration or values specified in the class or module where a\n932     test function is defined.\n933     \"\"\"\n934 \n935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):\n936         assert (\n937             isinstance(definition, FunctionDefinition)\n938             or type(definition).__name__ == \"DefinitionMock\"\n939         )\n940         self.definition = definition\n941 \n942         #: access to the :class:`_pytest.config.Config` object for the test session\n943         self.config = config\n944 \n945         #: the module object where the test function is defined in.\n946         self.module = module\n947 \n948         #: underlying python test function\n949         self.function = definition.obj\n950 \n951         #: set of fixture names required by the test function\n952         self.fixturenames = fixtureinfo.names_closure\n953 \n954         #: class object where the test function is defined in or ``None``.\n955         self.cls = cls\n956 \n957         self._calls = []\n958         self._ids = set()\n959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n960 \n961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):\n962         \"\"\" Add new invocations to the underlying test function using the list\n963         of argvalues for the given argnames.  Parametrization is performed\n964         during the collection phase.  If you need to setup expensive resources\n965         see about setting indirect to do it rather at test setup time.\n966 \n967         :arg argnames: a comma-separated string denoting one or more argument\n968                        names, or a list/tuple of argument strings.\n969 \n970         :arg argvalues: The list of argvalues determines how often a\n971             test is invoked with different argument values.  If only one\n972             argname was specified argvalues is a list of values.  If N\n973             argnames were specified, argvalues must be a list of N-tuples,\n974             where each tuple-element specifies a value for its respective\n975             argname.\n976 \n977         :arg indirect: The list of argnames or boolean. A list of arguments'\n978             names (subset of argnames). If True the list contains all names from\n979             the argnames. Each argvalue corresponding to an argname in this list will\n980             be passed as request.param to its respective argname fixture\n981             function so that it can perform more expensive setups during the\n982             setup phase of a test rather than at collection time.\n983 \n984         :arg ids: list of string ids, or a callable.\n985             If strings, each is corresponding to the argvalues so that they are\n986             part of the test id. If None is given as id of specific test, the\n987             automatically generated id for that argument will be used.\n988             If callable, it should take one argument (a single argvalue) and return\n989             a string or return None. If None, the automatically generated id for that\n990             argument will be used.\n991             If no ids are provided they will be generated automatically from\n992             the argvalues.\n993 \n994         :arg scope: if specified it denotes the scope of the parameters.\n995             The scope is used for grouping tests by parameter instances.\n996             It will also override any fixture-function defined scope, allowing\n997             to set a dynamic scope using test context or configuration.\n998         \"\"\"\n999         from _pytest.fixtures import scope2index\n1000         from _pytest.mark import ParameterSet\n1001 \n1002         argnames, parameters = ParameterSet._for_parametrize(\n1003             argnames,\n1004             argvalues,\n1005             self.function,\n1006             self.config,\n1007             function_definition=self.definition,\n1008         )\n1009         del argvalues\n1010 \n1011         if scope is None:\n1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n1013 \n1014         self._validate_if_using_arg_names(argnames, indirect)\n1015 \n1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n1017 \n1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)\n1019 \n1020         scopenum = scope2index(\n1021             scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n1022         )\n1023 \n1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator\n1025         # more than once) then we accumulate those calls generating the cartesian product\n1026         # of all calls\n1027         newcalls = []\n1028         for callspec in self._calls or [CallSpec2(self)]:\n1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n1030                 newcallspec = callspec.copy()\n1031                 newcallspec.setmulti2(\n1032                     arg_values_types,\n1033                     argnames,\n1034                     param_set.values,\n1035                     param_id,\n1036                     param_set.marks,\n1037                     scopenum,\n1038                     param_index,\n1039                 )\n1040                 newcalls.append(newcallspec)\n1041         self._calls = newcalls\n1042 \n1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):\n1044         \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n1045         to ``parametrize``.\n1046 \n1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1048         :param ids: the ids parameter of the parametrized call (see docs).\n1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n1050         :param Item item: the item that generated this parametrized call.\n1051         :rtype: List[str]\n1052         :return: the list of ids for each argname given\n1053         \"\"\"\n1054         from _pytest._io.saferepr import saferepr\n1055 \n1056         idfn = None\n1057         if callable(ids):\n1058             idfn = ids\n1059             ids = None\n1060         if ids:\n1061             func_name = self.function.__name__\n1062             if len(ids) != len(parameters):\n1063                 msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)\n1065             for id_value in ids:\n1066                 if id_value is not None and not isinstance(id_value, six.string_types):\n1067                     msg = \"In {}: ids must be list of strings, found: {} (type: {!r})\"\n1068                     fail(\n1069                         msg.format(func_name, saferepr(id_value), type(id_value)),\n1070                         pytrace=False,\n1071                     )\n1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)\n1073         return ids\n1074 \n1075     def _resolve_arg_value_types(self, argnames, indirect):\n1076         \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n1077         to the function, based on the ``indirect`` parameter of the parametrized() call.\n1078 \n1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1081         :rtype: Dict[str, str]\n1082             A dict mapping each arg name to either:\n1083             * \"params\" if the argname should be the parameter of a fixture of the same name.\n1084             * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n1085         \"\"\"\n1086         valtypes = {}\n1087         if indirect is True:\n1088             valtypes = dict.fromkeys(argnames, \"params\")\n1089         elif indirect is False:\n1090             valtypes = dict.fromkeys(argnames, \"funcargs\")\n1091         elif isinstance(indirect, (tuple, list)):\n1092             valtypes = dict.fromkeys(argnames, \"funcargs\")\n1093             for arg in indirect:\n1094                 if arg not in argnames:\n1095                     fail(\n1096                         \"In {}: indirect fixture '{}' doesn't exist\".format(\n1097                             self.function.__name__, arg\n1098                         ),\n1099                         pytrace=False,\n1100                     )\n1101                 valtypes[arg] = \"params\"\n1102         return valtypes\n1103 \n1104     def _validate_if_using_arg_names(self, argnames, indirect):\n1105         \"\"\"\n1106         Check if all argnames are being used, by default values, or directly/indirectly.\n1107 \n1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1110         :raise ValueError: if validation fails.\n1111         \"\"\"\n1112         default_arg_names = set(get_default_arg_names(self.function))\n1113         func_name = self.function.__name__\n1114         for arg in argnames:\n1115             if arg not in self.fixturenames:\n1116                 if arg in default_arg_names:\n1117                     fail(\n1118                         \"In {}: function already takes an argument '{}' with a default value\".format(\n1119                             func_name, arg\n1120                         ),\n1121                         pytrace=False,\n1122                     )\n1123                 else:\n1124                     if isinstance(indirect, (tuple, list)):\n1125                         name = \"fixture\" if arg in indirect else \"argument\"\n1126                     else:\n1127                         name = \"fixture\" if indirect else \"argument\"\n1128                     fail(\n1129                         \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n1130                         pytrace=False,\n1131                     )\n1132 \n1133 \n1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):\n1135     \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n1136 \n1137     When there's at least one direct argument, always use \"function\" scope.\n1138 \n1139     When a test function is parametrized and all its arguments are indirect\n1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.\n1141 \n1142     Related to issue #1832, based on code posted by @Kingdread.\n1143     \"\"\"\n1144     from _pytest.fixtures import scopes\n1145 \n1146     if isinstance(indirect, (list, tuple)):\n1147         all_arguments_are_fixtures = len(indirect) == len(argnames)\n1148     else:\n1149         all_arguments_are_fixtures = bool(indirect)\n1150 \n1151     if all_arguments_are_fixtures:\n1152         fixturedefs = arg2fixturedefs or {}\n1153         used_scopes = [\n1154             fixturedef[0].scope\n1155             for name, fixturedef in fixturedefs.items()\n1156             if name in argnames\n1157         ]\n1158         if used_scopes:\n1159             # Takes the most narrow scope from used fixtures\n1160             for scope in reversed(scopes):\n1161                 if scope in used_scopes:\n1162                     return scope\n1163 \n1164     return \"function\"\n1165 \n1166 \n1167 def _ascii_escaped_by_config(val, config):\n1168     if config is None:\n1169         escape_option = False\n1170     else:\n1171         escape_option = config.getini(\n1172             \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n1173         )\n1174     return val if escape_option else ascii_escaped(val)\n1175 \n1176 \n1177 def _idval(val, argname, idx, idfn, item, config):\n1178     if idfn:\n1179         try:\n1180             generated_id = idfn(val)\n1181             if generated_id is not None:\n1182                 val = generated_id\n1183         except Exception as e:\n1184             # See issue https://github.com/pytest-dev/pytest/issues/2169\n1185             msg = \"{}: error raised while trying to determine id of parameter '{}' at position {}\\n\"\n1186             msg = msg.format(item.nodeid, argname, idx)\n1187             # we only append the exception type and message because on Python 2 reraise does nothing\n1188             msg += \"  {}: {}\\n\".format(type(e).__name__, e)\n1189             six.raise_from(ValueError(msg), e)\n1190     elif config:\n1191         hook_id = config.hook.pytest_make_parametrize_id(\n1192             config=config, val=val, argname=argname\n1193         )\n1194         if hook_id:\n1195             return hook_id\n1196 \n1197     if isinstance(val, STRING_TYPES):\n1198         return _ascii_escaped_by_config(val, config)\n1199     elif isinstance(val, (float, int, bool, NoneType)):\n1200         return str(val)\n1201     elif isinstance(val, REGEX_TYPE):\n1202         return ascii_escaped(val.pattern)\n1203     elif enum is not None and isinstance(val, enum.Enum):\n1204         return str(val)\n1205     elif (isclass(val) or isfunction(val)) and hasattr(val, \"__name__\"):\n1206         return val.__name__\n1207     return str(argname) + str(idx)\n1208 \n1209 \n1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):\n1211     if parameterset.id is not None:\n1212         return parameterset.id\n1213     if ids is None or (idx >= len(ids) or ids[idx] is None):\n1214         this_id = [\n1215             _idval(val, argname, idx, idfn, item=item, config=config)\n1216             for val, argname in zip(parameterset.values, argnames)\n1217         ]\n1218         return \"-\".join(this_id)\n1219     else:\n1220         return ascii_escaped(ids[idx])\n1221 \n1222 \n1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):\n1224     ids = [\n1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)\n1226         for valindex, parameterset in enumerate(parametersets)\n1227     ]\n1228     if len(set(ids)) != len(ids):\n1229         # The ids are not unique\n1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]\n1231         counters = collections.defaultdict(lambda: 0)\n1232         for index, testid in enumerate(ids):\n1233             if testid in duplicates:\n1234                 ids[index] = testid + str(counters[testid])\n1235                 counters[testid] += 1\n1236     return ids\n1237 \n1238 \n1239 def show_fixtures_per_test(config):\n1240     from _pytest.main import wrap_session\n1241 \n1242     return wrap_session(config, _show_fixtures_per_test)\n1243 \n1244 \n1245 def _show_fixtures_per_test(config, session):\n1246     import _pytest.config\n1247 \n1248     session.perform_collect()\n1249     curdir = py.path.local()\n1250     tw = _pytest.config.create_terminal_writer(config)\n1251     verbose = config.getvalue(\"verbose\")\n1252 \n1253     def get_best_relpath(func):\n1254         loc = getlocation(func, curdir)\n1255         return curdir.bestrelpath(loc)\n1256 \n1257     def write_fixture(fixture_def):\n1258         argname = fixture_def.argname\n1259         if verbose <= 0 and argname.startswith(\"_\"):\n1260             return\n1261         if verbose > 0:\n1262             bestrel = get_best_relpath(fixture_def.func)\n1263             funcargspec = \"{} -- {}\".format(argname, bestrel)\n1264         else:\n1265             funcargspec = argname\n1266         tw.line(funcargspec, green=True)\n1267         fixture_doc = fixture_def.func.__doc__\n1268         if fixture_doc:\n1269             write_docstring(tw, fixture_doc)\n1270         else:\n1271             tw.line(\"    no docstring available\", red=True)\n1272 \n1273     def write_item(item):\n1274         try:\n1275             info = item._fixtureinfo\n1276         except AttributeError:\n1277             # doctests items have no _fixtureinfo attribute\n1278             return\n1279         if not info.name2fixturedefs:\n1280             # this test item does not use any fixtures\n1281             return\n1282         tw.line()\n1283         tw.sep(\"-\", \"fixtures used by {}\".format(item.name))\n1284         tw.sep(\"-\", \"({})\".format(get_best_relpath(item.function)))\n1285         # dict key not used in loop but needed for sorting\n1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n1287             assert fixturedefs is not None\n1288             if not fixturedefs:\n1289                 continue\n1290             # last item is expected to be the one used by the test item\n1291             write_fixture(fixturedefs[-1])\n1292 \n1293     for session_item in session.items:\n1294         write_item(session_item)\n1295 \n1296 \n1297 def showfixtures(config):\n1298     from _pytest.main import wrap_session\n1299 \n1300     return wrap_session(config, _showfixtures_main)\n1301 \n1302 \n1303 def _showfixtures_main(config, session):\n1304     import _pytest.config\n1305 \n1306     session.perform_collect()\n1307     curdir = py.path.local()\n1308     tw = _pytest.config.create_terminal_writer(config)\n1309     verbose = config.getvalue(\"verbose\")\n1310 \n1311     fm = session._fixturemanager\n1312 \n1313     available = []\n1314     seen = set()\n1315 \n1316     for argname, fixturedefs in fm._arg2fixturedefs.items():\n1317         assert fixturedefs is not None\n1318         if not fixturedefs:\n1319             continue\n1320         for fixturedef in fixturedefs:\n1321             loc = getlocation(fixturedef.func, curdir)\n1322             if (fixturedef.argname, loc) in seen:\n1323                 continue\n1324             seen.add((fixturedef.argname, loc))\n1325             available.append(\n1326                 (\n1327                     len(fixturedef.baseid),\n1328                     fixturedef.func.__module__,\n1329                     curdir.bestrelpath(loc),\n1330                     fixturedef.argname,\n1331                     fixturedef,\n1332                 )\n1333             )\n1334 \n1335     available.sort()\n1336     currentmodule = None\n1337     for baseid, module, bestrel, argname, fixturedef in available:\n1338         if currentmodule != module:\n1339             if not module.startswith(\"_pytest.\"):\n1340                 tw.line()\n1341                 tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n1342                 currentmodule = module\n1343         if verbose <= 0 and argname[0] == \"_\":\n1344             continue\n1345         if verbose > 0:\n1346             funcargspec = \"%s -- %s\" % (argname, bestrel)\n1347         else:\n1348             funcargspec = argname\n1349         tw.line(funcargspec, green=True)\n1350         loc = getlocation(fixturedef.func, curdir)\n1351         doc = fixturedef.func.__doc__ or \"\"\n1352         if doc:\n1353             write_docstring(tw, doc)\n1354         else:\n1355             tw.line(\"    %s: no docstring available\" % (loc,), red=True)\n1356 \n1357 \n1358 def write_docstring(tw, doc, indent=\"    \"):\n1359     doc = doc.rstrip()\n1360     if \"\\n\" in doc:\n1361         firstline, rest = doc.split(\"\\n\", 1)\n1362     else:\n1363         firstline, rest = doc, \"\"\n1364 \n1365     if firstline.strip():\n1366         tw.line(indent + firstline.strip())\n1367 \n1368     if rest:\n1369         for line in dedent(rest).split(\"\\n\"):\n1370             tw.write(indent + line + \"\\n\")\n1371 \n1372 \n1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):\n1374     \"\"\" a Function Item is responsible for setting up and executing a\n1375     Python test function.\n1376     \"\"\"\n1377 \n1378     # disable since functions handle it themselves\n1379     _ALLOW_MARKERS = False\n1380 \n1381     def __init__(\n1382         self,\n1383         name,\n1384         parent,\n1385         args=None,\n1386         config=None,\n1387         callspec=None,\n1388         callobj=NOTSET,\n1389         keywords=None,\n1390         session=None,\n1391         fixtureinfo=None,\n1392         originalname=None,\n1393     ):\n1394         super(Function, self).__init__(name, parent, config=config, session=session)\n1395         self._args = args\n1396         if callobj is not NOTSET:\n1397             self.obj = callobj\n1398 \n1399         self.keywords.update(self.obj.__dict__)\n1400         self.own_markers.extend(get_unpacked_marks(self.obj))\n1401         if callspec:\n1402             self.callspec = callspec\n1403             # this is total hostile and a mess\n1404             # keywords are broken by design by now\n1405             # this will be redeemed later\n1406             for mark in callspec.marks:\n1407                 # feel free to cry, this was broken for years before\n1408                 # and keywords cant fix it per design\n1409                 self.keywords[mark.name] = mark\n1410             self.own_markers.extend(normalize_mark_list(callspec.marks))\n1411         if keywords:\n1412             self.keywords.update(keywords)\n1413 \n1414         # todo: this is a hell of a hack\n1415         # https://github.com/pytest-dev/pytest/issues/4569\n1416 \n1417         self.keywords.update(\n1418             dict.fromkeys(\n1419                 [\n1420                     mark.name\n1421                     for mark in self.iter_markers()\n1422                     if mark.name not in self.keywords\n1423                 ],\n1424                 True,\n1425             )\n1426         )\n1427 \n1428         if fixtureinfo is None:\n1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n1430                 self, self.obj, self.cls, funcargs=True\n1431             )\n1432         self._fixtureinfo = fixtureinfo\n1433         self.fixturenames = fixtureinfo.names_closure\n1434         self._initrequest()\n1435 \n1436         #: original function name, without any decorations (for example\n1437         #: parametrization adds a ``\"[...]\"`` suffix to function names).\n1438         #:\n1439         #: .. versionadded:: 3.0\n1440         self.originalname = originalname\n1441 \n1442     def _initrequest(self):\n1443         self.funcargs = {}\n1444         self._request = fixtures.FixtureRequest(self)\n1445 \n1446     @property\n1447     def function(self):\n1448         \"underlying python 'function' object\"\n1449         return getimfunc(self.obj)\n1450 \n1451     def _getobj(self):\n1452         name = self.name\n1453         i = name.find(\"[\")  # parametrization\n1454         if i != -1:\n1455             name = name[:i]\n1456         return getattr(self.parent.obj, name)\n1457 \n1458     @property\n1459     def _pyfuncitem(self):\n1460         \"(compatonly) for code expecting pytest-2.2 style request objects\"\n1461         return self\n1462 \n1463     def runtest(self):\n1464         \"\"\" execute the underlying test function. \"\"\"\n1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n1466 \n1467     def setup(self):\n1468         super(Function, self).setup()\n1469         fixtures.fillfixtures(self)\n1470 \n1471 \n1472 class FunctionDefinition(Function):\n1473     \"\"\"\n1474     internal hack until we get actual definition nodes instead of the\n1475     crappy metafunc hack\n1476     \"\"\"\n1477 \n1478     def runtest(self):\n1479         raise RuntimeError(\"function definitions are not supposed to be used\")\n1480 \n1481     setup = runtest\n",
        "intended_behavior": "Modify or extend the logic that processes and displays fixture information for the `--fixtures` command-line argument to include the scope of each fixture. The existing functionality of listing fixture names and descriptions should be preserved while enhancing the output to show each fixture's scope (e.g., function, class, module, session) next to its name. This may involve adjusting how fixture information is retrieved and formatting the output to include scope data."
    },
    {
        "rel_file_path": "src/_pytest/helpconfig.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/helpconfig.py",
        "start": 1,
        "end": 222,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" version info, help messages, tracing configuration.  \"\"\"\n2 from __future__ import absolute_import\n3 from __future__ import division\n4 from __future__ import print_function\n5 \n6 import os\n7 import sys\n8 from argparse import Action\n9 \n10 import py\n11 \n12 import pytest\n13 from _pytest.config import PrintHelp\n14 \n15 \n16 class HelpAction(Action):\n17     \"\"\"This is an argparse Action that will raise an exception in\n18     order to skip the rest of the argument parsing when --help is passed.\n19     This prevents argparse from quitting due to missing required arguments\n20     when any are defined, for example by ``pytest_addoption``.\n21     This is similar to the way that the builtin argparse --help option is\n22     implemented by raising SystemExit.\n23     \"\"\"\n24 \n25     def __init__(self, option_strings, dest=None, default=False, help=None):\n26         super(HelpAction, self).__init__(\n27             option_strings=option_strings,\n28             dest=dest,\n29             const=True,\n30             default=default,\n31             nargs=0,\n32             help=help,\n33         )\n34 \n35     def __call__(self, parser, namespace, values, option_string=None):\n36         setattr(namespace, self.dest, self.const)\n37 \n38         # We should only skip the rest of the parsing after preparse is done\n39         if getattr(parser._parser, \"after_preparse\", False):\n40             raise PrintHelp\n41 \n42 \n43 def pytest_addoption(parser):\n44     group = parser.getgroup(\"debugconfig\")\n45     group.addoption(\n46         \"--version\",\n47         action=\"store_true\",\n48         help=\"display pytest lib version and import information.\",\n49     )\n50     group._addoption(\n51         \"-h\",\n52         \"--help\",\n53         action=HelpAction,\n54         dest=\"help\",\n55         help=\"show help message and configuration info\",\n56     )\n57     group._addoption(\n58         \"-p\",\n59         action=\"append\",\n60         dest=\"plugins\",\n61         default=[],\n62         metavar=\"name\",\n63         help=\"early-load given plugin module name or entry point (multi-allowed). \"\n64         \"To avoid loading of plugins, use the `no:` prefix, e.g. \"\n65         \"`no:doctest`.\",\n66     )\n67     group.addoption(\n68         \"--traceconfig\",\n69         \"--trace-config\",\n70         action=\"store_true\",\n71         default=False,\n72         help=\"trace considerations of conftest.py files.\",\n73     ),\n74     group.addoption(\n75         \"--debug\",\n76         action=\"store_true\",\n77         dest=\"debug\",\n78         default=False,\n79         help=\"store internal tracing debug information in 'pytestdebug.log'.\",\n80     )\n81     group._addoption(\n82         \"-o\",\n83         \"--override-ini\",\n84         dest=\"override_ini\",\n85         action=\"append\",\n86         help='override ini option with \"option=value\" style, e.g. `-o xfail_strict=True -o cache_dir=cache`.',\n87     )\n88 \n89 \n90 @pytest.hookimpl(hookwrapper=True)\n91 def pytest_cmdline_parse():\n92     outcome = yield\n93     config = outcome.get_result()\n94     if config.option.debug:\n95         path = os.path.abspath(\"pytestdebug.log\")\n96         debugfile = open(path, \"w\")\n97         debugfile.write(\n98             \"versions pytest-%s, py-%s, \"\n99             \"python-%s\\ncwd=%s\\nargs=%s\\n\\n\"\n100             % (\n101                 pytest.__version__,\n102                 py.__version__,\n103                 \".\".join(map(str, sys.version_info)),\n104                 os.getcwd(),\n105                 config._origargs,\n106             )\n107         )\n108         config.trace.root.setwriter(debugfile.write)\n109         undo_tracing = config.pluginmanager.enable_tracing()\n110         sys.stderr.write(\"writing pytestdebug information to %s\\n\" % path)\n111 \n112         def unset_tracing():\n113             debugfile.close()\n114             sys.stderr.write(\"wrote pytestdebug information to %s\\n\" % debugfile.name)\n115             config.trace.root.setwriter(None)\n116             undo_tracing()\n117 \n118         config.add_cleanup(unset_tracing)\n119 \n120 \n121 def showversion(config):\n122     p = py.path.local(pytest.__file__)\n123     sys.stderr.write(\n124         \"This is pytest version %s, imported from %s\\n\" % (pytest.__version__, p)\n125     )\n126     plugininfo = getpluginversioninfo(config)\n127     if plugininfo:\n128         for line in plugininfo:\n129             sys.stderr.write(line + \"\\n\")\n130 \n131 \n132 def pytest_cmdline_main(config):\n133     if config.option.version:\n134         showversion(config)\n135         return 0\n136     elif config.option.help:\n137         config._do_configure()\n138         showhelp(config)\n139         config._ensure_unconfigure()\n140         return 0\n141 \n142 \n143 def showhelp(config):\n144     reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n145     tw = reporter._tw\n146     tw.write(config._parser.optparser.format_help())\n147     tw.line()\n148     tw.line()\n149     tw.line(\n150         \"[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:\"\n151     )\n152     tw.line()\n153 \n154     columns = tw.fullwidth  # costly call\n155     for name in config._parser._ininames:\n156         help, type, default = config._parser._inidict[name]\n157         if type is None:\n158             type = \"string\"\n159         spec = \"%s (%s)\" % (name, type)\n160         line = \"  %-24s %s\" % (spec, help)\n161         tw.line(line[:columns])\n162 \n163     tw.line()\n164     tw.line(\"environment variables:\")\n165     vars = [\n166         (\"PYTEST_ADDOPTS\", \"extra command line options\"),\n167         (\"PYTEST_PLUGINS\", \"comma-separated plugins to load during startup\"),\n168         (\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"set to disable plugin auto-loading\"),\n169         (\"PYTEST_DEBUG\", \"set to enable debug tracing of pytest's internals\"),\n170     ]\n171     for name, help in vars:\n172         tw.line(\"  %-24s %s\" % (name, help))\n173     tw.line()\n174     tw.line()\n175 \n176     tw.line(\"to see available markers type: pytest --markers\")\n177     tw.line(\"to see available fixtures type: pytest --fixtures\")\n178     tw.line(\n179         \"(shown according to specified file_or_dir or current dir \"\n180         \"if not specified; fixtures with leading '_' are only shown \"\n181         \"with the '-v' option\"\n182     )\n183 \n184     for warningreport in reporter.stats.get(\"warnings\", []):\n185         tw.line(\"warning : \" + warningreport.message, red=True)\n186     return\n187 \n188 \n189 conftest_options = [(\"pytest_plugins\", \"list of plugin names to load\")]\n190 \n191 \n192 def getpluginversioninfo(config):\n193     lines = []\n194     plugininfo = config.pluginmanager.list_plugin_distinfo()\n195     if plugininfo:\n196         lines.append(\"setuptools registered plugins:\")\n197         for plugin, dist in plugininfo:\n198             loc = getattr(plugin, \"__file__\", repr(plugin))\n199             content = \"%s-%s at %s\" % (dist.project_name, dist.version, loc)\n200             lines.append(\"  \" + content)\n201     return lines\n202 \n203 \n204 def pytest_report_header(config):\n205     lines = []\n206     if config.option.debug or config.option.traceconfig:\n207         lines.append(\"using: pytest-%s pylib-%s\" % (pytest.__version__, py.__version__))\n208 \n209         verinfo = getpluginversioninfo(config)\n210         if verinfo:\n211             lines.extend(verinfo)\n212 \n213     if config.option.traceconfig:\n214         lines.append(\"active plugins:\")\n215         items = config.pluginmanager.list_name_plugin()\n216         for name, plugin in items:\n217             if hasattr(plugin, \"__file__\"):\n218                 r = plugin.__file__\n219             else:\n220                 r = repr(plugin)\n221             lines.append(\"    %-20s: %s\" % (name, r))\n222     return lines\n",
        "intended_behavior": "If this file contains logic for the `--fixtures` argument's help text or processing, ensuring that any enhancements or modifications made in `python.py` regarding fixture scope display are consistent and supported here. The help text might need updating to indicate that fixture scope information will also be displayed."
    },
    {
        "rel_file_path": "src/_pytest/fixtures.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/fixtures.py",
        "start": 1,
        "end": 1324,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import absolute_import\n2 from __future__ import division\n3 from __future__ import print_function\n4 \n5 import functools\n6 import inspect\n7 import itertools\n8 import sys\n9 import warnings\n10 from collections import defaultdict\n11 from collections import deque\n12 from collections import OrderedDict\n13 \n14 import attr\n15 import py\n16 import six\n17 \n18 import _pytest\n19 from _pytest import nodes\n20 from _pytest._code.code import FormattedExcinfo\n21 from _pytest._code.code import TerminalRepr\n22 from _pytest.compat import _format_args\n23 from _pytest.compat import _PytestWrapper\n24 from _pytest.compat import exc_clear\n25 from _pytest.compat import FuncargnamesCompatAttr\n26 from _pytest.compat import get_real_func\n27 from _pytest.compat import get_real_method\n28 from _pytest.compat import getfslineno\n29 from _pytest.compat import getfuncargnames\n30 from _pytest.compat import getimfunc\n31 from _pytest.compat import getlocation\n32 from _pytest.compat import is_generator\n33 from _pytest.compat import isclass\n34 from _pytest.compat import NOTSET\n35 from _pytest.compat import safe_getattr\n36 from _pytest.deprecated import FIXTURE_FUNCTION_CALL\n37 from _pytest.deprecated import FIXTURE_NAMED_REQUEST\n38 from _pytest.outcomes import fail\n39 from _pytest.outcomes import TEST_OUTCOME\n40 \n41 \n42 @attr.s(frozen=True)\n43 class PseudoFixtureDef(object):\n44     cached_result = attr.ib()\n45     scope = attr.ib()\n46 \n47 \n48 def pytest_sessionstart(session):\n49     import _pytest.python\n50     import _pytest.nodes\n51 \n52     scopename2class.update(\n53         {\n54             \"package\": _pytest.python.Package,\n55             \"class\": _pytest.python.Class,\n56             \"module\": _pytest.python.Module,\n57             \"function\": _pytest.nodes.Item,\n58             \"session\": _pytest.main.Session,\n59         }\n60     )\n61     session._fixturemanager = FixtureManager(session)\n62 \n63 \n64 scopename2class = {}\n65 \n66 \n67 scope2props = dict(session=())\n68 scope2props[\"package\"] = (\"fspath\",)\n69 scope2props[\"module\"] = (\"fspath\", \"module\")\n70 scope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\n71 scope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\n72 scope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n73 \n74 \n75 def scopeproperty(name=None, doc=None):\n76     def decoratescope(func):\n77         scopename = name or func.__name__\n78 \n79         def provide(self):\n80             if func.__name__ in scope2props[self.scope]:\n81                 return func(self)\n82             raise AttributeError(\n83                 \"%s not available in %s-scoped context\" % (scopename, self.scope)\n84             )\n85 \n86         return property(provide, None, None, func.__doc__)\n87 \n88     return decoratescope\n89 \n90 \n91 def get_scope_package(node, fixturedef):\n92     import pytest\n93 \n94     cls = pytest.Package\n95     current = node\n96     fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n97     while current and (\n98         type(current) is not cls or fixture_package_name != current.nodeid\n99     ):\n100         current = current.parent\n101     if current is None:\n102         return node.session\n103     return current\n104 \n105 \n106 def get_scope_node(node, scope):\n107     cls = scopename2class.get(scope)\n108     if cls is None:\n109         raise ValueError(\"unknown scope\")\n110     return node.getparent(cls)\n111 \n112 \n113 def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n114     # this function will transform all collected calls to a functions\n115     # if they use direct funcargs (i.e. direct parametrization)\n116     # because we want later test execution to be able to rely on\n117     # an existing FixtureDef structure for all arguments.\n118     # XXX we can probably avoid this algorithm  if we modify CallSpec2\n119     # to directly care for creating the fixturedefs within its methods.\n120     if not metafunc._calls[0].funcargs:\n121         return  # this function call does not have direct parametrization\n122     # collect funcargs of all callspecs into a list of values\n123     arg2params = {}\n124     arg2scope = {}\n125     for callspec in metafunc._calls:\n126         for argname, argvalue in callspec.funcargs.items():\n127             assert argname not in callspec.params\n128             callspec.params[argname] = argvalue\n129             arg2params_list = arg2params.setdefault(argname, [])\n130             callspec.indices[argname] = len(arg2params_list)\n131             arg2params_list.append(argvalue)\n132             if argname not in arg2scope:\n133                 scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n134                 arg2scope[argname] = scopes[scopenum]\n135         callspec.funcargs.clear()\n136 \n137     # register artificial FixtureDef's so that later at test execution\n138     # time we can rely on a proper FixtureDef to exist for fixture setup.\n139     arg2fixturedefs = metafunc._arg2fixturedefs\n140     for argname, valuelist in arg2params.items():\n141         # if we have a scope that is higher than function we need\n142         # to make sure we only ever create an according fixturedef on\n143         # a per-scope basis. We thus store and cache the fixturedef on the\n144         # node related to the scope.\n145         scope = arg2scope[argname]\n146         node = None\n147         if scope != \"function\":\n148             node = get_scope_node(collector, scope)\n149             if node is None:\n150                 assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n151                 # use module-level collector for class-scope (for now)\n152                 node = collector\n153         if node and argname in node._name2pseudofixturedef:\n154             arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n155         else:\n156             fixturedef = FixtureDef(\n157                 fixturemanager,\n158                 \"\",\n159                 argname,\n160                 get_direct_param_fixture_func,\n161                 arg2scope[argname],\n162                 valuelist,\n163                 False,\n164                 False,\n165             )\n166             arg2fixturedefs[argname] = [fixturedef]\n167             if node is not None:\n168                 node._name2pseudofixturedef[argname] = fixturedef\n169 \n170 \n171 def getfixturemarker(obj):\n172     \"\"\" return fixturemarker or None if it doesn't exist or raised\n173     exceptions.\"\"\"\n174     try:\n175         return getattr(obj, \"_pytestfixturefunction\", None)\n176     except TEST_OUTCOME:\n177         # some objects raise errors like request (from flask import request)\n178         # we don't expect them to be fixture functions\n179         return None\n180 \n181 \n182 def get_parametrized_fixture_keys(item, scopenum):\n183     \"\"\" return list of keys for all parametrized arguments which match\n184     the specified scope. \"\"\"\n185     assert scopenum < scopenum_function  # function\n186     try:\n187         cs = item.callspec\n188     except AttributeError:\n189         pass\n190     else:\n191         # cs.indices.items() is random order of argnames.  Need to\n192         # sort this so that different calls to\n193         # get_parametrized_fixture_keys will be deterministic.\n194         for argname, param_index in sorted(cs.indices.items()):\n195             if cs._arg2scopenum[argname] != scopenum:\n196                 continue\n197             if scopenum == 0:  # session\n198                 key = (argname, param_index)\n199             elif scopenum == 1:  # package\n200                 key = (argname, param_index, item.fspath.dirpath())\n201             elif scopenum == 2:  # module\n202                 key = (argname, param_index, item.fspath)\n203             elif scopenum == 3:  # class\n204                 key = (argname, param_index, item.fspath, item.cls)\n205             yield key\n206 \n207 \n208 # algorithm for sorting on a per-parametrized resource setup basis\n209 # it is called for scopenum==0 (session) first and performs sorting\n210 # down to the lower scopes such as to minimize number of \"high scope\"\n211 # setups and teardowns\n212 \n213 \n214 def reorder_items(items):\n215     argkeys_cache = {}\n216     items_by_argkey = {}\n217     for scopenum in range(0, scopenum_function):\n218         argkeys_cache[scopenum] = d = {}\n219         items_by_argkey[scopenum] = item_d = defaultdict(deque)\n220         for item in items:\n221             keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))\n222             if keys:\n223                 d[item] = keys\n224                 for key in keys:\n225                     item_d[key].append(item)\n226     items = OrderedDict.fromkeys(items)\n227     return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))\n228 \n229 \n230 def fix_cache_order(item, argkeys_cache, items_by_argkey):\n231     for scopenum in range(0, scopenum_function):\n232         for key in argkeys_cache[scopenum].get(item, []):\n233             items_by_argkey[scopenum][key].appendleft(item)\n234 \n235 \n236 def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n237     if scopenum >= scopenum_function or len(items) < 3:\n238         return items\n239     ignore = set()\n240     items_deque = deque(items)\n241     items_done = OrderedDict()\n242     scoped_items_by_argkey = items_by_argkey[scopenum]\n243     scoped_argkeys_cache = argkeys_cache[scopenum]\n244     while items_deque:\n245         no_argkey_group = OrderedDict()\n246         slicing_argkey = None\n247         while items_deque:\n248             item = items_deque.popleft()\n249             if item in items_done or item in no_argkey_group:\n250                 continue\n251             argkeys = OrderedDict.fromkeys(\n252                 k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n253             )\n254             if not argkeys:\n255                 no_argkey_group[item] = None\n256             else:\n257                 slicing_argkey, _ = argkeys.popitem()\n258                 # we don't have to remove relevant items from later in the deque because they'll just be ignored\n259                 matching_items = [\n260                     i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n261                 ]\n262                 for i in reversed(matching_items):\n263                     fix_cache_order(i, argkeys_cache, items_by_argkey)\n264                     items_deque.appendleft(i)\n265                 break\n266         if no_argkey_group:\n267             no_argkey_group = reorder_items_atscope(\n268                 no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n269             )\n270             for item in no_argkey_group:\n271                 items_done[item] = None\n272         ignore.add(slicing_argkey)\n273     return items_done\n274 \n275 \n276 def fillfixtures(function):\n277     \"\"\" fill missing funcargs for a test function. \"\"\"\n278     try:\n279         request = function._request\n280     except AttributeError:\n281         # XXX this special code path is only expected to execute\n282         # with the oejskit plugin.  It uses classes with funcargs\n283         # and we thus have to work a bit to allow this.\n284         fm = function.session._fixturemanager\n285         fi = fm.getfixtureinfo(function.parent, function.obj, None)\n286         function._fixtureinfo = fi\n287         request = function._request = FixtureRequest(function)\n288         request._fillfixtures()\n289         # prune out funcargs for jstests\n290         newfuncargs = {}\n291         for name in fi.argnames:\n292             newfuncargs[name] = function.funcargs[name]\n293         function.funcargs = newfuncargs\n294     else:\n295         request._fillfixtures()\n296 \n297 \n298 def get_direct_param_fixture_func(request):\n299     return request.param\n300 \n301 \n302 @attr.s(slots=True)\n303 class FuncFixtureInfo(object):\n304     # original function argument names\n305     argnames = attr.ib(type=tuple)\n306     # argnames that function immediately requires. These include argnames +\n307     # fixture names specified via usefixtures and via autouse=True in fixture\n308     # definitions.\n309     initialnames = attr.ib(type=tuple)\n310     names_closure = attr.ib()  # List[str]\n311     name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n312 \n313     def prune_dependency_tree(self):\n314         \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n315 \n316         Can only reduce names_closure, which means that the new closure will\n317         always be a subset of the old one. The order is preserved.\n318 \n319         This method is needed because direct parametrization may shadow some\n320         of the fixtures that were included in the originally built dependency\n321         tree. In this way the dependency tree can get pruned, and the closure\n322         of argnames may get reduced.\n323         \"\"\"\n324         closure = set()\n325         working_set = set(self.initialnames)\n326         while working_set:\n327             argname = working_set.pop()\n328             # argname may be smth not included in the original names_closure,\n329             # in which case we ignore it. This currently happens with pseudo\n330             # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n331             # So they introduce the new dependency 'request' which might have\n332             # been missing in the original tree (closure).\n333             if argname not in closure and argname in self.names_closure:\n334                 closure.add(argname)\n335                 if argname in self.name2fixturedefs:\n336                     working_set.update(self.name2fixturedefs[argname][-1].argnames)\n337 \n338         self.names_closure[:] = sorted(closure, key=self.names_closure.index)\n339 \n340 \n341 class FixtureRequest(FuncargnamesCompatAttr):\n342     \"\"\" A request for a fixture from a test or fixture function.\n343 \n344     A request object gives access to the requesting test context\n345     and has an optional ``param`` attribute in case\n346     the fixture is parametrized indirectly.\n347     \"\"\"\n348 \n349     def __init__(self, pyfuncitem):\n350         self._pyfuncitem = pyfuncitem\n351         #: fixture for which this request is being performed\n352         self.fixturename = None\n353         #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n354         self.scope = \"function\"\n355         self._fixture_defs = {}  # argname -> FixtureDef\n356         fixtureinfo = pyfuncitem._fixtureinfo\n357         self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n358         self._arg2index = {}\n359         self._fixturemanager = pyfuncitem.session._fixturemanager\n360 \n361     @property\n362     def fixturenames(self):\n363         \"\"\"names of all active fixtures in this request\"\"\"\n364         result = list(self._pyfuncitem._fixtureinfo.names_closure)\n365         result.extend(set(self._fixture_defs).difference(result))\n366         return result\n367 \n368     @property\n369     def node(self):\n370         \"\"\" underlying collection node (depends on current request scope)\"\"\"\n371         return self._getscopeitem(self.scope)\n372 \n373     def _getnextfixturedef(self, argname):\n374         fixturedefs = self._arg2fixturedefs.get(argname, None)\n375         if fixturedefs is None:\n376             # we arrive here because of a dynamic call to\n377             # getfixturevalue(argname) usage which was naturally\n378             # not known at parsing/collection time\n379             parentid = self._pyfuncitem.parent.nodeid\n380             fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n381             self._arg2fixturedefs[argname] = fixturedefs\n382         # fixturedefs list is immutable so we maintain a decreasing index\n383         index = self._arg2index.get(argname, 0) - 1\n384         if fixturedefs is None or (-index > len(fixturedefs)):\n385             raise FixtureLookupError(argname, self)\n386         self._arg2index[argname] = index\n387         return fixturedefs[index]\n388 \n389     @property\n390     def config(self):\n391         \"\"\" the pytest config object associated with this request. \"\"\"\n392         return self._pyfuncitem.config\n393 \n394     @scopeproperty()\n395     def function(self):\n396         \"\"\" test function object if the request has a per-function scope. \"\"\"\n397         return self._pyfuncitem.obj\n398 \n399     @scopeproperty(\"class\")\n400     def cls(self):\n401         \"\"\" class (can be None) where the test function was collected. \"\"\"\n402         clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n403         if clscol:\n404             return clscol.obj\n405 \n406     @property\n407     def instance(self):\n408         \"\"\" instance (can be None) on which test function was collected. \"\"\"\n409         # unittest support hack, see _pytest.unittest.TestCaseFunction\n410         try:\n411             return self._pyfuncitem._testcase\n412         except AttributeError:\n413             function = getattr(self, \"function\", None)\n414             return getattr(function, \"__self__\", None)\n415 \n416     @scopeproperty()\n417     def module(self):\n418         \"\"\" python module object where the test function was collected. \"\"\"\n419         return self._pyfuncitem.getparent(_pytest.python.Module).obj\n420 \n421     @scopeproperty()\n422     def fspath(self):\n423         \"\"\" the file system path of the test module which collected this test. \"\"\"\n424         return self._pyfuncitem.fspath\n425 \n426     @property\n427     def keywords(self):\n428         \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n429         return self.node.keywords\n430 \n431     @property\n432     def session(self):\n433         \"\"\" pytest session object. \"\"\"\n434         return self._pyfuncitem.session\n435 \n436     def addfinalizer(self, finalizer):\n437         \"\"\" add finalizer/teardown function to be called after the\n438         last test within the requesting test context finished\n439         execution. \"\"\"\n440         # XXX usually this method is shadowed by fixturedef specific ones\n441         self._addfinalizer(finalizer, scope=self.scope)\n442 \n443     def _addfinalizer(self, finalizer, scope):\n444         colitem = self._getscopeitem(scope)\n445         self._pyfuncitem.session._setupstate.addfinalizer(\n446             finalizer=finalizer, colitem=colitem\n447         )\n448 \n449     def applymarker(self, marker):\n450         \"\"\" Apply a marker to a single test function invocation.\n451         This method is useful if you don't want to have a keyword/marker\n452         on all function invocations.\n453 \n454         :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n455             created by a call to ``pytest.mark.NAME(...)``.\n456         \"\"\"\n457         self.node.add_marker(marker)\n458 \n459     def raiseerror(self, msg):\n460         \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n461         raise self._fixturemanager.FixtureLookupError(None, self, msg)\n462 \n463     def _fillfixtures(self):\n464         item = self._pyfuncitem\n465         fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n466         for argname in fixturenames:\n467             if argname not in item.funcargs:\n468                 item.funcargs[argname] = self.getfixturevalue(argname)\n469 \n470     def getfixturevalue(self, argname):\n471         \"\"\" Dynamically run a named fixture function.\n472 \n473         Declaring fixtures via function argument is recommended where possible.\n474         But if you can only decide whether to use another fixture at test\n475         setup time, you may use this function to retrieve it inside a fixture\n476         or test function body.\n477         \"\"\"\n478         return self._get_active_fixturedef(argname).cached_result[0]\n479 \n480     def getfuncargvalue(self, argname):\n481         \"\"\" Deprecated, use getfixturevalue. \"\"\"\n482         from _pytest import deprecated\n483 \n484         warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n485         return self.getfixturevalue(argname)\n486 \n487     def _get_active_fixturedef(self, argname):\n488         try:\n489             return self._fixture_defs[argname]\n490         except KeyError:\n491             try:\n492                 fixturedef = self._getnextfixturedef(argname)\n493             except FixtureLookupError:\n494                 if argname == \"request\":\n495                     cached_result = (self, [0], None)\n496                     scope = \"function\"\n497                     return PseudoFixtureDef(cached_result, scope)\n498                 raise\n499         # remove indent to prevent the python3 exception\n500         # from leaking into the call\n501         self._compute_fixture_value(fixturedef)\n502         self._fixture_defs[argname] = fixturedef\n503         return fixturedef\n504 \n505     def _get_fixturestack(self):\n506         current = self\n507         values = []\n508         while 1:\n509             fixturedef = getattr(current, \"_fixturedef\", None)\n510             if fixturedef is None:\n511                 values.reverse()\n512                 return values\n513             values.append(fixturedef)\n514             current = current._parent_request\n515 \n516     def _compute_fixture_value(self, fixturedef):\n517         \"\"\"\n518         Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n519         force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n520         will be stored into the FixtureDef object itself.\n521 \n522         :param FixtureDef fixturedef:\n523         \"\"\"\n524         # prepare a subrequest object before calling fixture function\n525         # (latter managed by fixturedef)\n526         argname = fixturedef.argname\n527         funcitem = self._pyfuncitem\n528         scope = fixturedef.scope\n529         try:\n530             param = funcitem.callspec.getparam(argname)\n531         except (AttributeError, ValueError):\n532             param = NOTSET\n533             param_index = 0\n534             has_params = fixturedef.params is not None\n535             fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n536             if has_params and fixtures_not_supported:\n537                 msg = (\n538                     \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n539                     \"Node id: {nodeid}\\n\"\n540                     \"Function type: {typename}\"\n541                 ).format(\n542                     name=funcitem.name,\n543                     nodeid=funcitem.nodeid,\n544                     typename=type(funcitem).__name__,\n545                 )\n546                 fail(msg, pytrace=False)\n547             if has_params:\n548                 frame = inspect.stack()[3]\n549                 frameinfo = inspect.getframeinfo(frame[0])\n550                 source_path = frameinfo.filename\n551                 source_lineno = frameinfo.lineno\n552                 source_path = py.path.local(source_path)\n553                 if source_path.relto(funcitem.config.rootdir):\n554                     source_path = source_path.relto(funcitem.config.rootdir)\n555                 msg = (\n556                     \"The requested fixture has no parameter defined for test:\\n\"\n557                     \"    {}\\n\\n\"\n558                     \"Requested fixture '{}' defined in:\\n{}\"\n559                     \"\\n\\nRequested here:\\n{}:{}\".format(\n560                         funcitem.nodeid,\n561                         fixturedef.argname,\n562                         getlocation(fixturedef.func, funcitem.config.rootdir),\n563                         source_path,\n564                         source_lineno,\n565                     )\n566                 )\n567                 fail(msg, pytrace=False)\n568         else:\n569             param_index = funcitem.callspec.indices[argname]\n570             # if a parametrize invocation set a scope it will override\n571             # the static scope defined with the fixture function\n572             paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n573             if paramscopenum is not None:\n574                 scope = scopes[paramscopenum]\n575 \n576         subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n577 \n578         # check if a higher-level scoped fixture accesses a lower level one\n579         subrequest._check_scope(argname, self.scope, scope)\n580 \n581         # clear sys.exc_info before invoking the fixture (python bug?)\n582         # if it's not explicitly cleared it will leak into the call\n583         exc_clear()\n584         try:\n585             # call the fixture function\n586             fixturedef.execute(request=subrequest)\n587         finally:\n588             self._schedule_finalizers(fixturedef, subrequest)\n589 \n590     def _schedule_finalizers(self, fixturedef, subrequest):\n591         # if fixture function failed it might have registered finalizers\n592         self.session._setupstate.addfinalizer(\n593             functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n594         )\n595 \n596     def _check_scope(self, argname, invoking_scope, requested_scope):\n597         if argname == \"request\":\n598             return\n599         if scopemismatch(invoking_scope, requested_scope):\n600             # try to report something helpful\n601             lines = self._factorytraceback()\n602             fail(\n603                 \"ScopeMismatch: You tried to access the %r scoped \"\n604                 \"fixture %r with a %r scoped request object, \"\n605                 \"involved factories\\n%s\"\n606                 % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n607                 pytrace=False,\n608             )\n609 \n610     def _factorytraceback(self):\n611         lines = []\n612         for fixturedef in self._get_fixturestack():\n613             factory = fixturedef.func\n614             fs, lineno = getfslineno(factory)\n615             p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n616             args = _format_args(factory)\n617             lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n618         return lines\n619 \n620     def _getscopeitem(self, scope):\n621         if scope == \"function\":\n622             # this might also be a non-function Item despite its attribute name\n623             return self._pyfuncitem\n624         if scope == \"package\":\n625             node = get_scope_package(self._pyfuncitem, self._fixturedef)\n626         else:\n627             node = get_scope_node(self._pyfuncitem, scope)\n628         if node is None and scope == \"class\":\n629             # fallback to function item itself\n630             node = self._pyfuncitem\n631         assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n632             scope, self._pyfuncitem\n633         )\n634         return node\n635 \n636     def __repr__(self):\n637         return \"<FixtureRequest for %r>\" % (self.node)\n638 \n639 \n640 class SubRequest(FixtureRequest):\n641     \"\"\" a sub request for handling getting a fixture from a\n642     test function/fixture. \"\"\"\n643 \n644     def __init__(self, request, scope, param, param_index, fixturedef):\n645         self._parent_request = request\n646         self.fixturename = fixturedef.argname\n647         if param is not NOTSET:\n648             self.param = param\n649         self.param_index = param_index\n650         self.scope = scope\n651         self._fixturedef = fixturedef\n652         self._pyfuncitem = request._pyfuncitem\n653         self._fixture_defs = request._fixture_defs\n654         self._arg2fixturedefs = request._arg2fixturedefs\n655         self._arg2index = request._arg2index\n656         self._fixturemanager = request._fixturemanager\n657 \n658     def __repr__(self):\n659         return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)\n660 \n661     def addfinalizer(self, finalizer):\n662         self._fixturedef.addfinalizer(finalizer)\n663 \n664     def _schedule_finalizers(self, fixturedef, subrequest):\n665         # if the executing fixturedef was not explicitly requested in the argument list (via\n666         # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n667         # first\n668         if fixturedef.argname not in self.funcargnames:\n669             fixturedef.addfinalizer(\n670                 functools.partial(self._fixturedef.finish, request=self)\n671             )\n672         super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)\n673 \n674 \n675 scopes = \"session package module class function\".split()\n676 scopenum_function = scopes.index(\"function\")\n677 \n678 \n679 def scopemismatch(currentscope, newscope):\n680     return scopes.index(newscope) > scopes.index(currentscope)\n681 \n682 \n683 def scope2index(scope, descr, where=None):\n684     \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n685     if not defined.\n686     \"\"\"\n687     try:\n688         return scopes.index(scope)\n689     except ValueError:\n690         fail(\n691             \"{} {}got an unexpected scope value '{}'\".format(\n692                 descr, \"from {} \".format(where) if where else \"\", scope\n693             ),\n694             pytrace=False,\n695         )\n696 \n697 \n698 class FixtureLookupError(LookupError):\n699     \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n700 \n701     def __init__(self, argname, request, msg=None):\n702         self.argname = argname\n703         self.request = request\n704         self.fixturestack = request._get_fixturestack()\n705         self.msg = msg\n706 \n707     def formatrepr(self):\n708         tblines = []\n709         addline = tblines.append\n710         stack = [self.request._pyfuncitem.obj]\n711         stack.extend(map(lambda x: x.func, self.fixturestack))\n712         msg = self.msg\n713         if msg is not None:\n714             # the last fixture raise an error, let's present\n715             # it at the requesting side\n716             stack = stack[:-1]\n717         for function in stack:\n718             fspath, lineno = getfslineno(function)\n719             try:\n720                 lines, _ = inspect.getsourcelines(get_real_func(function))\n721             except (IOError, IndexError, TypeError):\n722                 error_msg = \"file %s, line %s: source code not available\"\n723                 addline(error_msg % (fspath, lineno + 1))\n724             else:\n725                 addline(\"file %s, line %s\" % (fspath, lineno + 1))\n726                 for i, line in enumerate(lines):\n727                     line = line.rstrip()\n728                     addline(\"  \" + line)\n729                     if line.lstrip().startswith(\"def\"):\n730                         break\n731 \n732         if msg is None:\n733             fm = self.request._fixturemanager\n734             available = set()\n735             parentid = self.request._pyfuncitem.parent.nodeid\n736             for name, fixturedefs in fm._arg2fixturedefs.items():\n737                 faclist = list(fm._matchfactories(fixturedefs, parentid))\n738                 if faclist:\n739                     available.add(name)\n740             if self.argname in available:\n741                 msg = \" recursive dependency involving fixture '{}' detected\".format(\n742                     self.argname\n743                 )\n744             else:\n745                 msg = \"fixture '{}' not found\".format(self.argname)\n746             msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n747             msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n748 \n749         return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)\n750 \n751 \n752 class FixtureLookupErrorRepr(TerminalRepr):\n753     def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n754         self.tblines = tblines\n755         self.errorstring = errorstring\n756         self.filename = filename\n757         self.firstlineno = firstlineno\n758         self.argname = argname\n759 \n760     def toterminal(self, tw):\n761         # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n762         for tbline in self.tblines:\n763             tw.line(tbline.rstrip())\n764         lines = self.errorstring.split(\"\\n\")\n765         if lines:\n766             tw.line(\n767                 \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n768                 red=True,\n769             )\n770             for line in lines[1:]:\n771                 tw.line(\n772                     \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n773                     red=True,\n774                 )\n775         tw.line()\n776         tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))\n777 \n778 \n779 def fail_fixturefunc(fixturefunc, msg):\n780     fs, lineno = getfslineno(fixturefunc)\n781     location = \"%s:%s\" % (fs, lineno + 1)\n782     source = _pytest._code.Source(fixturefunc)\n783     fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)\n784 \n785 \n786 def call_fixture_func(fixturefunc, request, kwargs):\n787     yieldctx = is_generator(fixturefunc)\n788     if yieldctx:\n789         it = fixturefunc(**kwargs)\n790         res = next(it)\n791         finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)\n792         request.addfinalizer(finalizer)\n793     else:\n794         res = fixturefunc(**kwargs)\n795     return res\n796 \n797 \n798 def _teardown_yield_fixture(fixturefunc, it):\n799     \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n800     yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n801     try:\n802         next(it)\n803     except StopIteration:\n804         pass\n805     else:\n806         fail_fixturefunc(\n807             fixturefunc, \"yield_fixture function has more than one 'yield'\"\n808         )\n809 \n810 \n811 class FixtureDef(object):\n812     \"\"\" A container for a factory definition. \"\"\"\n813 \n814     def __init__(\n815         self,\n816         fixturemanager,\n817         baseid,\n818         argname,\n819         func,\n820         scope,\n821         params,\n822         unittest=False,\n823         ids=None,\n824     ):\n825         self._fixturemanager = fixturemanager\n826         self.baseid = baseid or \"\"\n827         self.has_location = baseid is not None\n828         self.func = func\n829         self.argname = argname\n830         self.scope = scope\n831         self.scopenum = scope2index(\n832             scope or \"function\",\n833             descr=\"Fixture '{}'\".format(func.__name__),\n834             where=baseid,\n835         )\n836         self.params = params\n837         self.argnames = getfuncargnames(func, is_method=unittest)\n838         self.unittest = unittest\n839         self.ids = ids\n840         self._finalizers = []\n841 \n842     def addfinalizer(self, finalizer):\n843         self._finalizers.append(finalizer)\n844 \n845     def finish(self, request):\n846         exceptions = []\n847         try:\n848             while self._finalizers:\n849                 try:\n850                     func = self._finalizers.pop()\n851                     func()\n852                 except:  # noqa\n853                     exceptions.append(sys.exc_info())\n854             if exceptions:\n855                 e = exceptions[0]\n856                 del (\n857                     exceptions\n858                 )  # ensure we don't keep all frames alive because of the traceback\n859                 six.reraise(*e)\n860 \n861         finally:\n862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n864             # even if finalization fails, we invalidate\n865             # the cached fixture value and remove\n866             # all finalizers because they may be bound methods which will\n867             # keep instances alive\n868             if hasattr(self, \"cached_result\"):\n869                 del self.cached_result\n870             self._finalizers = []\n871 \n872     def execute(self, request):\n873         # get required arguments and register our own finish()\n874         # with their finalization\n875         for argname in self.argnames:\n876             fixturedef = request._get_active_fixturedef(argname)\n877             if argname != \"request\":\n878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n879 \n880         my_cache_key = request.param_index\n881         cached_result = getattr(self, \"cached_result\", None)\n882         if cached_result is not None:\n883             result, cache_key, err = cached_result\n884             if my_cache_key == cache_key:\n885                 if err is not None:\n886                     six.reraise(*err)\n887                 else:\n888                     return result\n889             # we have a previous but differently parametrized fixture instance\n890             # so we need to tear it down before creating a new one\n891             self.finish(request)\n892             assert not hasattr(self, \"cached_result\")\n893 \n894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n895         return hook.pytest_fixture_setup(fixturedef=self, request=request)\n896 \n897     def __repr__(self):\n898         return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n899             self.argname,\n900             self.scope,\n901             self.baseid,\n902         )\n903 \n904 \n905 def resolve_fixture_function(fixturedef, request):\n906     \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n907     instances and bound methods.\n908     \"\"\"\n909     fixturefunc = fixturedef.func\n910     if fixturedef.unittest:\n911         if request.instance is not None:\n912             # bind the unbound method to the TestCase instance\n913             fixturefunc = fixturedef.func.__get__(request.instance)\n914     else:\n915         # the fixture function needs to be bound to the actual\n916         # request.instance so that code working with \"fixturedef\" behaves\n917         # as expected.\n918         if request.instance is not None:\n919             fixturefunc = getimfunc(fixturedef.func)\n920             if fixturefunc != fixturedef.func:\n921                 fixturefunc = fixturefunc.__get__(request.instance)\n922     return fixturefunc\n923 \n924 \n925 def pytest_fixture_setup(fixturedef, request):\n926     \"\"\" Execution of fixture setup. \"\"\"\n927     kwargs = {}\n928     for argname in fixturedef.argnames:\n929         fixdef = request._get_active_fixturedef(argname)\n930         result, arg_cache_key, exc = fixdef.cached_result\n931         request._check_scope(argname, request.scope, fixdef.scope)\n932         kwargs[argname] = result\n933 \n934     fixturefunc = resolve_fixture_function(fixturedef, request)\n935     my_cache_key = request.param_index\n936     try:\n937         result = call_fixture_func(fixturefunc, request, kwargs)\n938     except TEST_OUTCOME:\n939         fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n940         raise\n941     fixturedef.cached_result = (result, my_cache_key, None)\n942     return result\n943 \n944 \n945 def _ensure_immutable_ids(ids):\n946     if ids is None:\n947         return\n948     if callable(ids):\n949         return ids\n950     return tuple(ids)\n951 \n952 \n953 def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n954     \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n955     instead of used as an argument in a test function.\n956     \"\"\"\n957     message = FIXTURE_FUNCTION_CALL.format(\n958         name=fixture_marker.name or function.__name__\n959     )\n960 \n961     @six.wraps(function)\n962     def result(*args, **kwargs):\n963         fail(message, pytrace=False)\n964 \n965     # keep reference to the original function in our own custom attribute so we don't unwrap\n966     # further than this point and lose useful wrappings like @mock.patch (#3774)\n967     result.__pytest_wrapped__ = _PytestWrapper(function)\n968 \n969     return result\n970 \n971 \n972 @attr.s(frozen=True)\n973 class FixtureFunctionMarker(object):\n974     scope = attr.ib()\n975     params = attr.ib(converter=attr.converters.optional(tuple))\n976     autouse = attr.ib(default=False)\n977     ids = attr.ib(default=None, converter=_ensure_immutable_ids)\n978     name = attr.ib(default=None)\n979 \n980     def __call__(self, function):\n981         if isclass(function):\n982             raise ValueError(\"class fixtures not supported (maybe in the future)\")\n983 \n984         if getattr(function, \"_pytestfixturefunction\", False):\n985             raise ValueError(\n986                 \"fixture is being applied more than once to the same function\"\n987             )\n988 \n989         function = wrap_function_to_error_out_if_called_directly(function, self)\n990 \n991         name = self.name or function.__name__\n992         if name == \"request\":\n993             warnings.warn(FIXTURE_NAMED_REQUEST)\n994         function._pytestfixturefunction = self\n995         return function\n996 \n997 \n998 def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n999     \"\"\"Decorator to mark a fixture factory function.\n1000 \n1001     This decorator can be used, with or without parameters, to define a\n1002     fixture function.\n1003 \n1004     The name of the fixture function can later be referenced to cause its\n1005     invocation ahead of running tests: test\n1006     modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n1007     marker.\n1008 \n1009     Test functions can directly use fixture names as input\n1010     arguments in which case the fixture instance returned from the fixture\n1011     function will be injected.\n1012 \n1013     Fixtures can provide their values to test functions using ``return`` or ``yield``\n1014     statements. When using ``yield`` the code block after the ``yield`` statement is executed\n1015     as teardown code regardless of the test outcome, and must yield exactly once.\n1016 \n1017     :arg scope: the scope for which this fixture is shared, one of\n1018                 ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n1019                 ``\"package\"`` or ``\"session\"``.\n1020 \n1021                 ``\"package\"`` is considered **experimental** at this time.\n1022 \n1023     :arg params: an optional list of parameters which will cause multiple\n1024                 invocations of the fixture function and all of the tests\n1025                 using it.\n1026                 The current parameter is available in ``request.param``.\n1027 \n1028     :arg autouse: if True, the fixture func is activated for all tests that\n1029                 can see it.  If False (the default) then an explicit\n1030                 reference is needed to activate the fixture.\n1031 \n1032     :arg ids: list of string ids each corresponding to the params\n1033                 so that they are part of the test id. If no ids are provided\n1034                 they will be generated automatically from the params.\n1035 \n1036     :arg name: the name of the fixture. This defaults to the name of the\n1037                 decorated function. If a fixture is used in the same module in\n1038                 which it is defined, the function name of the fixture will be\n1039                 shadowed by the function arg that requests the fixture; one way\n1040                 to resolve this is to name the decorated function\n1041                 ``fixture_<fixturename>`` and then use\n1042                 ``@pytest.fixture(name='<fixturename>')``.\n1043     \"\"\"\n1044     if callable(scope) and params is None and autouse is False:\n1045         # direct decoration\n1046         return FixtureFunctionMarker(\"function\", params, autouse, name=name)(scope)\n1047     if params is not None and not isinstance(params, (list, tuple)):\n1048         params = list(params)\n1049     return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)\n1050 \n1051 \n1052 def yield_fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n1053     \"\"\" (return a) decorator to mark a yield-fixture factory function.\n1054 \n1055     .. deprecated:: 3.0\n1056         Use :py:func:`pytest.fixture` directly instead.\n1057     \"\"\"\n1058     return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)\n1059 \n1060 \n1061 defaultfuncargprefixmarker = fixture()\n1062 \n1063 \n1064 @fixture(scope=\"session\")\n1065 def pytestconfig(request):\n1066     \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n1067 \n1068     Example::\n1069 \n1070         def test_foo(pytestconfig):\n1071             if pytestconfig.getoption(\"verbose\") > 0:\n1072                 ...\n1073 \n1074     \"\"\"\n1075     return request.config\n1076 \n1077 \n1078 class FixtureManager(object):\n1079     \"\"\"\n1080     pytest fixtures definitions and information is stored and managed\n1081     from this class.\n1082 \n1083     During collection fm.parsefactories() is called multiple times to parse\n1084     fixture function definitions into FixtureDef objects and internal\n1085     data structures.\n1086 \n1087     During collection of test functions, metafunc-mechanics instantiate\n1088     a FuncFixtureInfo object which is cached per node/func-name.\n1089     This FuncFixtureInfo object is later retrieved by Function nodes\n1090     which themselves offer a fixturenames attribute.\n1091 \n1092     The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n1093     relevant for a particular function.  An initial list of fixtures is\n1094     assembled like this:\n1095 \n1096     - ini-defined usefixtures\n1097     - autouse-marked fixtures along the collection chain up from the function\n1098     - usefixtures markers at module/class/function level\n1099     - test function funcargs\n1100 \n1101     Subsequently the funcfixtureinfo.fixturenames attribute is computed\n1102     as the closure of the fixtures needed to setup the initial fixtures,\n1103     i. e. fixtures needed by fixture functions themselves are appended\n1104     to the fixturenames list.\n1105 \n1106     Upon the test-setup phases all fixturenames are instantiated, retrieved\n1107     by a lookup of their FuncFixtureInfo.\n1108     \"\"\"\n1109 \n1110     FixtureLookupError = FixtureLookupError\n1111     FixtureLookupErrorRepr = FixtureLookupErrorRepr\n1112 \n1113     def __init__(self, session):\n1114         self.session = session\n1115         self.config = session.config\n1116         self._arg2fixturedefs = {}\n1117         self._holderobjseen = set()\n1118         self._arg2finish = {}\n1119         self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n1120         session.config.pluginmanager.register(self, \"funcmanage\")\n1121 \n1122     def getfixtureinfo(self, node, func, cls, funcargs=True):\n1123         if funcargs and not getattr(node, \"nofuncargs\", False):\n1124             argnames = getfuncargnames(func, cls=cls)\n1125         else:\n1126             argnames = ()\n1127         usefixtures = itertools.chain.from_iterable(\n1128             mark.args for mark in node.iter_markers(name=\"usefixtures\")\n1129         )\n1130         initialnames = tuple(usefixtures) + argnames\n1131         fm = node.session._fixturemanager\n1132         initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n1133             initialnames, node\n1134         )\n1135         return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n1136 \n1137     def pytest_plugin_registered(self, plugin):\n1138         nodeid = None\n1139         try:\n1140             p = py.path.local(plugin.__file__).realpath()\n1141         except AttributeError:\n1142             pass\n1143         else:\n1144             # construct the base nodeid which is later used to check\n1145             # what fixtures are visible for particular tests (as denoted\n1146             # by their test id)\n1147             if p.basename.startswith(\"conftest.py\"):\n1148                 nodeid = p.dirpath().relto(self.config.rootdir)\n1149                 if p.sep != nodes.SEP:\n1150                     nodeid = nodeid.replace(p.sep, nodes.SEP)\n1151 \n1152         self.parsefactories(plugin, nodeid)\n1153 \n1154     def _getautousenames(self, nodeid):\n1155         \"\"\" return a tuple of fixture names to be used. \"\"\"\n1156         autousenames = []\n1157         for baseid, basenames in self._nodeid_and_autousenames:\n1158             if nodeid.startswith(baseid):\n1159                 if baseid:\n1160                     i = len(baseid)\n1161                     nextchar = nodeid[i : i + 1]\n1162                     if nextchar and nextchar not in \":/\":\n1163                         continue\n1164                 autousenames.extend(basenames)\n1165         return autousenames\n1166 \n1167     def getfixtureclosure(self, fixturenames, parentnode):\n1168         # collect the closure of all fixtures , starting with the given\n1169         # fixturenames as the initial set.  As we have to visit all\n1170         # factory definitions anyway, we also return an arg2fixturedefs\n1171         # mapping so that the caller can reuse it and does not have\n1172         # to re-discover fixturedefs again for each fixturename\n1173         # (discovering matching fixtures for a given name/node is expensive)\n1174 \n1175         parentid = parentnode.nodeid\n1176         fixturenames_closure = self._getautousenames(parentid)\n1177 \n1178         def merge(otherlist):\n1179             for arg in otherlist:\n1180                 if arg not in fixturenames_closure:\n1181                     fixturenames_closure.append(arg)\n1182 \n1183         merge(fixturenames)\n1184 \n1185         # at this point, fixturenames_closure contains what we call \"initialnames\",\n1186         # which is a set of fixturenames the function immediately requests. We\n1187         # need to return it as well, so save this.\n1188         initialnames = tuple(fixturenames_closure)\n1189 \n1190         arg2fixturedefs = {}\n1191         lastlen = -1\n1192         while lastlen != len(fixturenames_closure):\n1193             lastlen = len(fixturenames_closure)\n1194             for argname in fixturenames_closure:\n1195                 if argname in arg2fixturedefs:\n1196                     continue\n1197                 fixturedefs = self.getfixturedefs(argname, parentid)\n1198                 if fixturedefs:\n1199                     arg2fixturedefs[argname] = fixturedefs\n1200                     merge(fixturedefs[-1].argnames)\n1201 \n1202         def sort_by_scope(arg_name):\n1203             try:\n1204                 fixturedefs = arg2fixturedefs[arg_name]\n1205             except KeyError:\n1206                 return scopes.index(\"function\")\n1207             else:\n1208                 return fixturedefs[-1].scopenum\n1209 \n1210         fixturenames_closure.sort(key=sort_by_scope)\n1211         return initialnames, fixturenames_closure, arg2fixturedefs\n1212 \n1213     def pytest_generate_tests(self, metafunc):\n1214         for argname in metafunc.fixturenames:\n1215             faclist = metafunc._arg2fixturedefs.get(argname)\n1216             if faclist:\n1217                 fixturedef = faclist[-1]\n1218                 if fixturedef.params is not None:\n1219                     markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n1220                     for parametrize_mark in markers:\n1221                         if \"argnames\" in parametrize_mark.kwargs:\n1222                             argnames = parametrize_mark.kwargs[\"argnames\"]\n1223                         else:\n1224                             argnames = parametrize_mark.args[0]\n1225 \n1226                         if not isinstance(argnames, (tuple, list)):\n1227                             argnames = [\n1228                                 x.strip() for x in argnames.split(\",\") if x.strip()\n1229                             ]\n1230                         if argname in argnames:\n1231                             break\n1232                     else:\n1233                         metafunc.parametrize(\n1234                             argname,\n1235                             fixturedef.params,\n1236                             indirect=True,\n1237                             scope=fixturedef.scope,\n1238                             ids=fixturedef.ids,\n1239                         )\n1240             else:\n1241                 continue  # will raise FixtureLookupError at setup time\n1242 \n1243     def pytest_collection_modifyitems(self, items):\n1244         # separate parametrized setups\n1245         items[:] = reorder_items(items)\n1246 \n1247     def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n1248         if nodeid is not NOTSET:\n1249             holderobj = node_or_obj\n1250         else:\n1251             holderobj = node_or_obj.obj\n1252             nodeid = node_or_obj.nodeid\n1253         if holderobj in self._holderobjseen:\n1254             return\n1255 \n1256         self._holderobjseen.add(holderobj)\n1257         autousenames = []\n1258         for name in dir(holderobj):\n1259             # The attribute can be an arbitrary descriptor, so the attribute\n1260             # access below can raise. safe_getatt() ignores such exceptions.\n1261             obj = safe_getattr(holderobj, name, None)\n1262             marker = getfixturemarker(obj)\n1263             if not isinstance(marker, FixtureFunctionMarker):\n1264                 # magic globals  with __getattr__ might have got us a wrong\n1265                 # fixture attribute\n1266                 continue\n1267 \n1268             if marker.name:\n1269                 name = marker.name\n1270 \n1271             # during fixture definition we wrap the original fixture function\n1272             # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n1273             # when pytest itself calls the fixture function\n1274             if six.PY2 and unittest:\n1275                 # hack on Python 2 because of the unbound methods\n1276                 obj = get_real_func(obj)\n1277             else:\n1278                 obj = get_real_method(obj, holderobj)\n1279 \n1280             fixture_def = FixtureDef(\n1281                 self,\n1282                 nodeid,\n1283                 name,\n1284                 obj,\n1285                 marker.scope,\n1286                 marker.params,\n1287                 unittest=unittest,\n1288                 ids=marker.ids,\n1289             )\n1290 \n1291             faclist = self._arg2fixturedefs.setdefault(name, [])\n1292             if fixture_def.has_location:\n1293                 faclist.append(fixture_def)\n1294             else:\n1295                 # fixturedefs with no location are at the front\n1296                 # so this inserts the current fixturedef after the\n1297                 # existing fixturedefs from external plugins but\n1298                 # before the fixturedefs provided in conftests.\n1299                 i = len([f for f in faclist if not f.has_location])\n1300                 faclist.insert(i, fixture_def)\n1301             if marker.autouse:\n1302                 autousenames.append(name)\n1303 \n1304         if autousenames:\n1305             self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n1306 \n1307     def getfixturedefs(self, argname, nodeid):\n1308         \"\"\"\n1309         Gets a list of fixtures which are applicable to the given node id.\n1310 \n1311         :param str argname: name of the fixture to search for\n1312         :param str nodeid: full node id of the requesting test.\n1313         :return: list[FixtureDef]\n1314         \"\"\"\n1315         try:\n1316             fixturedefs = self._arg2fixturedefs[argname]\n1317         except KeyError:\n1318             return None\n1319         return tuple(self._matchfactories(fixturedefs, nodeid))\n1320 \n1321     def _matchfactories(self, fixturedefs, nodeid):\n1322         for fixturedef in fixturedefs:\n1323             if nodes.ischildnode(fixturedef.baseid, nodeid):\n1324                 yield fixturedef\n",
        "intended_behavior": "This file likely defines and manages fixtures. If there are utility methods here that fetch fixture metadata (including scope), ensuring these methods are suitably integrated into the logic that outputs fixture information for `--fixtures`. We may not need to directly modify this file, but it's important to ensure that any changes made are compatible with how fixtures and their scopes are defined and managed here."
    }
]