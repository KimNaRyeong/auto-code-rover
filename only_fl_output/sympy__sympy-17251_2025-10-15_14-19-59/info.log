2025-10-15 14:19:59.190 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 14:20:08.155 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=305, output_tokens=12, cost=0.003410
2025-10-15 14:20:26.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=485, output_tokens=635, cost=0.023900
2025-10-15 14:20:27.714 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:20:32.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=594, output_tokens=165, cost=0.010890
2025-10-15 14:20:32.890 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:20:35.670 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=519, output_tokens=42, cost=0.006450
2025-10-15 14:20:35.671 | DEBUG    | Extracted a valid json.
2025-10-15 14:20:35.671 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"exp\")",
        "search_method(\"simplify\")",
        "search_method(\"expand_complex\")"
    ],
    "bug_locations": []
}
2025-10-15 14:20:35.702 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:20:35.703 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:20:54.475 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1648, output_tokens=556, cost=0.033160
2025-10-15 14:20:54.487 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:21:07.783 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2420, output_tokens=389, cost=0.035870
2025-10-15 14:21:07.791 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:21:18.716 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=743, output_tokens=297, cost=0.016340
2025-10-15 14:21:18.717 | DEBUG    | Extracted a valid json.
2025-10-15 14:21:18.717 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"exp\", \"sympy/functions/elementary/exponential.py\")",
        "search_method_in_file(\"simplify\", \"sympy/simplify/simplify.py\")"
    ],
    "bug_locations":[
        {
            "file": "sympy/functions/elementary/exponential.py",
            "class": "",
            "method": "",
            "intended_behavior": "The method should include logic to detect when its argument is a multiple of `pi * I` (where `I` is the imaginary unit) and simplify based on the periodicity of the exponential function, e.g., using Euler's formula and recognizing that `exp(i * pi * n) = cos(pi * n) + i * sin(pi * n)` for any integer `n`. It should simplify expressions like `exp(I*pi)` to `-1` directly, without needing additional simplification calls."
        },
        {
            "file": "sympy/simplify/simplify.py",
            "class": "",
            "method": "",
            "intended_behavior": "The simplification method should include checks or rules to recognize expressions involving `exp` with purely imaginary arguments and apply periodicity simplifications effectively. This would likely involve detecting patterns where the exponential function's argument is a multiple of `pi * I` and leveraging the properties of exponential functions to simplify these expressions automatically."
        }
    ]
}
2025-10-15 14:21:18.791 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:21:18.792 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:21:43.376 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6069, output_tokens=735, cost=0.082740
2025-10-15 14:21:43.391 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:21:54.661 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7020, output_tokens=388, cost=0.081840
2025-10-15 14:21:54.669 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:22:00.946 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=742, output_tokens=236, cost=0.014500
2025-10-15 14:22:00.947 | DEBUG    | Extracted a valid json.
2025-10-15 14:22:00.948 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/functions/elementary/exponential.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhancements should ensure that `exp` recognizes and simplifies based on its periodicity â€“ specifically, recognizing patterns like `exp(I*pi*n)` to simplify to `-1`, `1`, or utilizing Euler's formula effectively. This might involve augmenting existing methods or implementing new logic within the class that handles `exp` to automatically apply these simplifications before returning the result."
        },
        {
            "file": "sympy/simplify/simplify.py",
            "class": "",
            "method": "simplify",
            "intended_behavior": "The `simplify` method should include additional heuristics or checks to identify and simplify expressions involving the exponential function with imaginary arguments that can be simplified based on the periodicity. This might involve adding specific rules or enhancing current ones to more effectively utilize the properties of exponentials, thereby directly simplifying expressions that exhibit periodic behavior without requiring further intervention."
        }
    ]
}
2025-10-15 14:22:00.959 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/elementary/exponential.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import sympify
4 from sympy.core.add import Add
5 from sympy.core.cache import cacheit
6 from sympy.core.compatibility import range
7 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
8 from sympy.core.logic import fuzzy_not
9 from sympy.core.mul import Mul
10 from sympy.core.numbers import Integer
11 from sympy.core.power import Pow
12 from sympy.core.singleton import S
13 from sympy.core.symbol import Wild, Dummy
14 from sympy.functions.combinatorial.factorials import factorial
15 from sympy.ntheory import multiplicity, perfect_power
16 
17 # NOTE IMPORTANT
18 # The series expansion code in this file is an important part of the gruntz
19 # algorithm for determining limits. _eval_nseries has to return a generalized
20 # power series with coefficients in C(log(x), log).
21 # In more detail, the result of _eval_nseries(self, x, n) must be
22 #   c_0*x**e_0 + ... (finitely many terms)
23 # where e_i are numbers (not necessarily integers) and c_i involve only
24 # numbers, the function log, and log(x). [This also means it must not contain
25 # log(x(1+p)), this *has* to be expanded to log(x)+log(1+p) if x.is_positive and
26 # p.is_positive.]
27 
28 
29 class ExpBase(Function):
30 
31     unbranched = True
32 
33     def inverse(self, argindex=1):
34         """
35         Returns the inverse function of ``exp(x)``.
36         """
37         return log
38 
39     def as_numer_denom(self):
40         """
41         Returns this with a positive exponent as a 2-tuple (a fraction).
42 
43         Examples
44         ========
45 
46         >>> from sympy.functions import exp
47         >>> from sympy.abc import x
48         >>> exp(-x).as_numer_denom()
49         (1, exp(x))
50         >>> exp(x).as_numer_denom()
51         (exp(x), 1)
52         """
53         # this should be the same as Pow.as_numer_denom wrt
54         # exponent handling
55         exp = self.exp
56         neg_exp = exp.is_negative
57         if not neg_exp and not (-exp).is_negative:
58             neg_exp = _coeff_isneg(exp)
59         if neg_exp:
60             return S.One, self.func(-exp)
61         return self, S.One
62 
63     @property
64     def exp(self):
65         """
66         Returns the exponent of the function.
67         """
68         return self.args[0]
69 
70     def as_base_exp(self):
71         """
72         Returns the 2-tuple (base, exponent).
73         """
74         return self.func(1), Mul(*self.args)
75 
76     def _eval_conjugate(self):
77         return self.func(self.args[0].conjugate())
78 
79     def _eval_is_finite(self):
80         arg = self.args[0]
81         if arg.is_infinite:
82             if arg.is_negative:
83                 return True
84             if arg.is_positive:
85                 return False
86         if arg.is_finite:
87             return True
88 
89     def _eval_is_rational(self):
90         s = self.func(*self.args)
91         if s.func == self.func:
92             if s.exp is S.Zero:
93                 return True
94             elif s.exp.is_rational and fuzzy_not(s.exp.is_zero):
95                 return False
96         else:
97             return s.is_rational
98 
99     def _eval_is_zero(self):
100         return (self.args[0] is S.NegativeInfinity)
101 
102     def _eval_power(self, other):
103         """exp(arg)**e -> exp(arg*e) if assumptions allow it.
104         """
105         b, e = self.as_base_exp()
106         return Pow._eval_power(Pow(b, e, evaluate=False), other)
107 
108     def _eval_expand_power_exp(self, **hints):
109         arg = self.args[0]
110         if arg.is_Add and arg.is_commutative:
111             expr = 1
112             for x in arg.args:
113                 expr *= self.func(x)
114             return expr
115         return self.func(arg)
116 
117 
118 class exp_polar(ExpBase):
119     r"""
120     Represent a 'polar number' (see g-function Sphinx documentation).
121 
122     ``exp_polar`` represents the function
123     `Exp: \mathbb{C} \rightarrow \mathcal{S}`, sending the complex number
124     `z = a + bi` to the polar number `r = exp(a), \theta = b`. It is one of
125     the main functions to construct polar numbers.
126 
127     >>> from sympy import exp_polar, pi, I, exp
128 
129     The main difference is that polar numbers don't "wrap around" at `2 \pi`:
130 
131     >>> exp(2*pi*I)
132     1
133     >>> exp_polar(2*pi*I)
134     exp_polar(2*I*pi)
135 
136     apart from that they behave mostly like classical complex numbers:
137 
138     >>> exp_polar(2)*exp_polar(3)
139     exp_polar(5)
140 
141     See Also
142     ========
143 
144     sympy.simplify.simplify.powsimp
145     sympy.functions.elementary.complexes.polar_lift
146     sympy.functions.elementary.complexes.periodic_argument
147     sympy.functions.elementary.complexes.principal_branch
148     """
149 
150     is_polar = True
151     is_comparable = False  # cannot be evalf'd
152 
153     def _eval_Abs(self):   # Abs is never a polar number
154         from sympy.functions.elementary.complexes import re
155         return exp(re(self.args[0]))
156 
157     def _eval_evalf(self, prec):
158         """ Careful! any evalf of polar numbers is flaky """
159         from sympy import im, pi, re
160         i = im(self.args[0])
161         try:
162             bad = (i <= -pi or i > pi)
163         except TypeError:
164             bad = True
165         if bad:
166             return self  # cannot evalf for this argument
167         res = exp(self.args[0])._eval_evalf(prec)
168         if i > 0 and im(res) < 0:
169             # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi
170             return re(res)
171         return res
172 
173     def _eval_power(self, other):
174         return self.func(self.args[0]*other)
175 
176     def _eval_is_extended_real(self):
177         if self.args[0].is_extended_real:
178             return True
179 
180     def as_base_exp(self):
181         # XXX exp_polar(0) is special!
182         if self.args[0] == 0:
183             return self, S(1)
184         return ExpBase.as_base_exp(self)
185 
186 
187 class exp(ExpBase):
188     """
189     The exponential function, :math:`e^x`.
190 
191     See Also
192     ========
193 
194     log
195     """
196 
197     def fdiff(self, argindex=1):
198         """
199         Returns the first derivative of this function.
200         """
201         if argindex == 1:
202             return self
203         else:
204             raise ArgumentIndexError(self, argindex)
205 
206     def _eval_refine(self, assumptions):
207         from sympy.assumptions import ask, Q
208         arg = self.args[0]
209         if arg.is_Mul:
210             Ioo = S.ImaginaryUnit*S.Infinity
211             if arg in [Ioo, -Ioo]:
212                 return S.NaN
213 
214             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
215             if coeff:
216                 if ask(Q.integer(2*coeff)):
217                     if ask(Q.even(coeff)):
218                         return S.One
219                     elif ask(Q.odd(coeff)):
220                         return S.NegativeOne
221                     elif ask(Q.even(coeff + S.Half)):
222                         return -S.ImaginaryUnit
223                     elif ask(Q.odd(coeff + S.Half)):
224                         return S.ImaginaryUnit
225 
226     @classmethod
227     def eval(cls, arg):
228         from sympy.assumptions import ask, Q
229         from sympy.calculus import AccumBounds
230         from sympy.sets.setexpr import SetExpr
231         from sympy.matrices.matrices import MatrixBase
232         from sympy import logcombine
233         if arg.is_Number:
234             if arg is S.NaN:
235                 return S.NaN
236             elif arg is S.Zero:
237                 return S.One
238             elif arg is S.One:
239                 return S.Exp1
240             elif arg is S.Infinity:
241                 return S.Infinity
242             elif arg is S.NegativeInfinity:
243                 return S.Zero
244         elif arg is S.ComplexInfinity:
245             return S.NaN
246         elif isinstance(arg, log):
247             return arg.args[0]
248         elif isinstance(arg, AccumBounds):
249             return AccumBounds(exp(arg.min), exp(arg.max))
250         elif isinstance(arg, SetExpr):
251             return arg._eval_func(cls)
252         elif arg.is_Mul:
253             if arg.is_number or arg.is_Symbol:
254                 coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
255                 if coeff:
256                     if ask(Q.integer(2*coeff)):
257                         if ask(Q.even(coeff)):
258                             return S.One
259                         elif ask(Q.odd(coeff)):
260                             return S.NegativeOne
261                         elif ask(Q.even(coeff + S.Half)):
262                             return -S.ImaginaryUnit
263                         elif ask(Q.odd(coeff + S.Half)):
264                             return S.ImaginaryUnit
265 
266             # Warning: code in risch.py will be very sensitive to changes
267             # in this (see DifferentialExtension).
268 
269             # look for a single log factor
270 
271             coeff, terms = arg.as_coeff_Mul()
272 
273             # but it can't be multiplied by oo
274             if coeff in [S.NegativeInfinity, S.Infinity]:
275                 return None
276 
277             coeffs, log_term = [coeff], None
278             for term in Mul.make_args(terms):
279                 term_ = logcombine(term)
280                 if isinstance(term_, log):
281                     if log_term is None:
282                         log_term = term_.args[0]
283                     else:
284                         return None
285                 elif term.is_comparable:
286                     coeffs.append(term)
287                 else:
288                     return None
289 
290             return log_term**Mul(*coeffs) if log_term else None
291 
292         elif arg.is_Add:
293             out = []
294             add = []
295             for a in arg.args:
296                 if a is S.One:
297                     add.append(a)
298                     continue
299                 newa = cls(a)
300                 if isinstance(newa, cls):
301                     add.append(a)
302                 else:
303                     out.append(newa)
304             if out:
305                 return Mul(*out)*cls(Add(*add), evaluate=False)
306 
307         elif isinstance(arg, MatrixBase):
308             return arg.exp()
309 
310     @property
311     def base(self):
312         """
313         Returns the base of the exponential function.
314         """
315         return S.Exp1
316 
317     @staticmethod
318     @cacheit
319     def taylor_term(n, x, *previous_terms):
320         """
321         Calculates the next term in the Taylor series expansion.
322         """
323         if n < 0:
324             return S.Zero
325         if n == 0:
326             return S.One
327         x = sympify(x)
328         if previous_terms:
329             p = previous_terms[-1]
330             if p is not None:
331                 return p * x / n
332         return x**n/factorial(n)
333 
334     def as_real_imag(self, deep=True, **hints):
335         """
336         Returns this function as a 2-tuple representing a complex number.
337 
338         Examples
339         ========
340 
341         >>> from sympy import I
342         >>> from sympy.abc import x
343         >>> from sympy.functions import exp
344         >>> exp(x).as_real_imag()
345         (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))
346         >>> exp(1).as_real_imag()
347         (E, 0)
348         >>> exp(I).as_real_imag()
349         (cos(1), sin(1))
350         >>> exp(1+I).as_real_imag()
351         (E*cos(1), E*sin(1))
352 
353         See Also
354         ========
355 
356         sympy.functions.elementary.complexes.re
357         sympy.functions.elementary.complexes.im
358         """
359         import sympy
360         re, im = self.args[0].as_real_imag()
361         if deep:
362             re = re.expand(deep, **hints)
363             im = im.expand(deep, **hints)
364         cos, sin = sympy.cos(im), sympy.sin(im)
365         return (exp(re)*cos, exp(re)*sin)
366 
367     def _eval_subs(self, old, new):
368         # keep processing of power-like args centralized in Pow
369         if old.is_Pow:  # handle (exp(3*log(x))).subs(x**2, z) -> z**(3/2)
370             old = exp(old.exp*log(old.base))
371         elif old is S.Exp1 and new.is_Function:
372             old = exp
373         if isinstance(old, exp) or old is S.Exp1:
374             f = lambda a: Pow(*a.as_base_exp(), evaluate=False) if (
375                 a.is_Pow or isinstance(a, exp)) else a
376             return Pow._eval_subs(f(self), f(old), new)
377 
378         if old is exp and not new.is_Function:
379             return new**self.exp._subs(old, new)
380         return Function._eval_subs(self, old, new)
381 
382     def _eval_is_extended_real(self):
383         if self.args[0].is_extended_real:
384             return True
385         elif self.args[0].is_imaginary:
386             arg2 = -S(2) * S.ImaginaryUnit * self.args[0] / S.Pi
387             return arg2.is_even
388 
389     def _eval_is_algebraic(self):
390         s = self.func(*self.args)
391         if s.func == self.func:
392             if fuzzy_not(self.exp.is_zero):
393                 if self.exp.is_algebraic:
394                     return False
395                 elif (self.exp/S.Pi).is_rational:
396                     return False
397         else:
398             return s.is_algebraic
399 
400     def _eval_is_extended_positive(self):
401         if self.args[0].is_extended_real:
402             return not self.args[0] is S.NegativeInfinity
403         elif self.args[0].is_imaginary:
404             arg2 = -S.ImaginaryUnit * self.args[0] / S.Pi
405             return arg2.is_even
406 
407     def _eval_nseries(self, x, n, logx):
408         # NOTE Please see the comment at the beginning of this file, labelled
409         #      IMPORTANT.
410         from sympy import limit, oo, Order, powsimp
411         arg = self.args[0]
412         arg_series = arg._eval_nseries(x, n=n, logx=logx)
413         if arg_series.is_Order:
414             return 1 + arg_series
415         arg0 = limit(arg_series.removeO(), x, 0)
416         if arg0 in [-oo, oo]:
417             return self
418         t = Dummy("t")
419         exp_series = exp(t)._taylor(t, n)
420         o = exp_series.getO()
421         exp_series = exp_series.removeO()
422         r = exp(arg0)*exp_series.subs(t, arg_series - arg0)
423         r += Order(o.expr.subs(t, (arg_series - arg0)), x)
424         r = r.expand()
425         return powsimp(r, deep=True, combine='exp')
426 
427     def _taylor(self, x, n):
428         from sympy import Order
429         l = []
430         g = None
431         for i in range(n):
432             g = self.taylor_term(i, self.args[0], g)
433             g = g.nseries(x, n=n)
434             l.append(g)
435         return Add(*l) + Order(x**n, x)
436 
437     def _eval_as_leading_term(self, x):
438         from sympy import Order
439         arg = self.args[0]
440         if arg.is_Add:
441             return Mul(*[exp(f).as_leading_term(x) for f in arg.args])
442         arg = self.args[0].as_leading_term(x)
443         if Order(1, x).contains(arg):
444             return S.One
445         return exp(arg)
446 
447     def _eval_rewrite_as_sin(self, arg, **kwargs):
448         from sympy import sin
449         I = S.ImaginaryUnit
450         return sin(I*arg + S.Pi/2) - I*sin(I*arg)
451 
452     def _eval_rewrite_as_cos(self, arg, **kwargs):
453         from sympy import cos
454         I = S.ImaginaryUnit
455         return cos(I*arg) + I*cos(I*arg + S.Pi/2)
456 
457     def _eval_rewrite_as_tanh(self, arg, **kwargs):
458         from sympy import tanh
459         return (1 + tanh(arg/2))/(1 - tanh(arg/2))
460 
461     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
462         from sympy.functions.elementary.trigonometric import sin, cos
463         if arg.is_Mul:
464             coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
465             if coeff and coeff.is_number:
466                 cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)
467                 if not isinstance(cosine, cos) and not isinstance (sine, sin):
468                     return cosine + S.ImaginaryUnit*sine
469 
470     def _eval_rewrite_as_Pow(self, arg, **kwargs):
471         if arg.is_Mul:
472             logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]
473             if logs:
474                 return Pow(logs[0].args[0], arg.coeff(logs[0]))
475 
476 
477 class log(Function):
478     r"""
479     The natural logarithm function `\ln(x)` or `\log(x)`.
480     Logarithms are taken with the natural base, `e`. To get
481     a logarithm of a different base ``b``, use ``log(x, b)``,
482     which is essentially short-hand for ``log(x)/log(b)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy import log, S
488     >>> log(8, 2)
489     3
490     >>> log(S(8)/3, 2)
491     -log(3)/log(2) + 3
492 
493     See Also
494     ========
495 
496     exp
497     """
498 
499     def fdiff(self, argindex=1):
500         """
501         Returns the first derivative of the function.
502         """
503         if argindex == 1:
504             return 1/self.args[0]
505         else:
506             raise ArgumentIndexError(self, argindex)
507 
508     def inverse(self, argindex=1):
509         r"""
510         Returns `e^x`, the inverse function of `\log(x)`.
511         """
512         return exp
513 
514     @classmethod
515     def eval(cls, arg, base=None):
516         from sympy import unpolarify
517         from sympy.calculus import AccumBounds
518         from sympy.sets.setexpr import SetExpr
519 
520         arg = sympify(arg)
521 
522         if base is not None:
523             base = sympify(base)
524             if base == 1:
525                 if arg == 1:
526                     return S.NaN
527                 else:
528                     return S.ComplexInfinity
529             try:
530                 # handle extraction of powers of the base now
531                 # or else expand_log in Mul would have to handle this
532                 n = multiplicity(base, arg)
533                 if n:
534                     return n + log(arg / base**n) / log(base)
535                 else:
536                     return log(arg)/log(base)
537             except ValueError:
538                 pass
539             if base is not S.Exp1:
540                 return cls(arg)/cls(base)
541             else:
542                 return cls(arg)
543 
544         if arg.is_Number:
545             if arg is S.Zero:
546                 return S.ComplexInfinity
547             elif arg is S.One:
548                 return S.Zero
549             elif arg is S.Infinity:
550                 return S.Infinity
551             elif arg is S.NegativeInfinity:
552                 return S.Infinity
553             elif arg is S.NaN:
554                 return S.NaN
555             elif arg.is_Rational and arg.p == 1:
556                 return -cls(arg.q)
557 
558         if isinstance(arg, exp) and arg.args[0].is_extended_real:
559             return arg.args[0]
560         elif isinstance(arg, exp_polar):
561             return unpolarify(arg.exp)
562         elif isinstance(arg, AccumBounds):
563             if arg.min.is_positive:
564                 return AccumBounds(log(arg.min), log(arg.max))
565             else:
566                 return
567         elif isinstance(arg, SetExpr):
568             return arg._eval_func(cls)
569 
570         if arg.is_number:
571             if arg.is_negative:
572                 return S.Pi * S.ImaginaryUnit + cls(-arg)
573             elif arg is S.ComplexInfinity:
574                 return S.ComplexInfinity
575             elif arg is S.Exp1:
576                 return S.One
577 
578         # don't autoexpand Pow or Mul (see the issue 3351):
579         if not arg.is_Add:
580             coeff = arg.as_coefficient(S.ImaginaryUnit)
581 
582             if coeff is not None:
583                 if coeff is S.Infinity:
584                     return S.Infinity
585                 elif coeff is S.NegativeInfinity:
586                     return S.Infinity
587                 elif coeff.is_Rational:
588                     if coeff.is_nonnegative:
589                         return S.Pi * S.ImaginaryUnit * S.Half + cls(coeff)
590                     else:
591                         return -S.Pi * S.ImaginaryUnit * S.Half + cls(-coeff)
592 
593     def as_base_exp(self):
594         """
595         Returns this function in the form (base, exponent).
596         """
597         return self, S.One
598 
599     @staticmethod
600     @cacheit
601     def taylor_term(n, x, *previous_terms):  # of log(1+x)
602         r"""
603         Returns the next term in the Taylor series expansion of `\log(1+x)`.
604         """
605         from sympy import powsimp
606         if n < 0:
607             return S.Zero
608         x = sympify(x)
609         if n == 0:
610             return x
611         if previous_terms:
612             p = previous_terms[-1]
613             if p is not None:
614                 return powsimp((-n) * p * x / (n + 1), deep=True, combine='exp')
615         return (1 - 2*(n % 2)) * x**(n + 1)/(n + 1)
616 
617     def _eval_expand_log(self, deep=True, **hints):
618         from sympy import unpolarify, expand_log
619         from sympy.concrete import Sum, Product
620         force = hints.get('force', False)
621         if (len(self.args) == 2):
622             return expand_log(self.func(*self.args), deep=deep, force=force)
623         arg = self.args[0]
624         if arg.is_Integer:
625             # remove perfect powers
626             p = perfect_power(int(arg))
627             if p is not False:
628                 return p[1]*self.func(p[0])
629         elif arg.is_Rational:
630             return log(arg.p) - log(arg.q)
631         elif arg.is_Mul:
632             expr = []
633             nonpos = []
634             for x in arg.args:
635                 if force or x.is_positive or x.is_polar:
636                     a = self.func(x)
637                     if isinstance(a, log):
638                         expr.append(self.func(x)._eval_expand_log(**hints))
639                     else:
640                         expr.append(a)
641                 elif x.is_negative:
642                     a = self.func(-x)
643                     expr.append(a)
644                     nonpos.append(S.NegativeOne)
645                 else:
646                     nonpos.append(x)
647             return Add(*expr) + log(Mul(*nonpos))
648         elif arg.is_Pow or isinstance(arg, exp):
649             if force or (arg.exp.is_extended_real and (arg.base.is_positive or ((arg.exp+1)
650                 .is_positive and (arg.exp-1).is_nonpositive))) or arg.base.is_polar:
651                 b = arg.base
652                 e = arg.exp
653                 a = self.func(b)
654                 if isinstance(a, log):
655                     return unpolarify(e) * a._eval_expand_log(**hints)
656                 else:
657                     return unpolarify(e) * a
658         elif isinstance(arg, Product):
659             if arg.function.is_positive:
660                 return Sum(log(arg.function), *arg.limits)
661 
662         return self.func(arg)
663 
664     def _eval_simplify(self, **kwargs):
665         from sympy.simplify.simplify import expand_log, simplify, inversecombine
666         if len(self.args) == 2:  # it's unevaluated
667             return simplify(self.func(*self.args), **kwargs)
668 
669         expr = self.func(simplify(self.args[0], **kwargs))
670         if kwargs['inverse']:
671             expr = inversecombine(expr)
672         expr = expand_log(expr, deep=True)
673         return min([expr, self], key=kwargs['measure'])
674 
675     def as_real_imag(self, deep=True, **hints):
676         """
677         Returns this function as a complex coordinate.
678 
679         Examples
680         ========
681 
682         >>> from sympy import I
683         >>> from sympy.abc import x
684         >>> from sympy.functions import log
685         >>> log(x).as_real_imag()
686         (log(Abs(x)), arg(x))
687         >>> log(I).as_real_imag()
688         (0, pi/2)
689         >>> log(1 + I).as_real_imag()
690         (log(sqrt(2)), pi/4)
691         >>> log(I*x).as_real_imag()
692         (log(Abs(x)), arg(I*x))
693 
694         """
695         from sympy import Abs, arg
696         if deep:
697             abs = Abs(self.args[0].expand(deep, **hints))
698             arg = arg(self.args[0].expand(deep, **hints))
699         else:
700             abs = Abs(self.args[0])
701             arg = arg(self.args[0])
702         if hints.get('log', False):  # Expand the log
703             hints['complex'] = False
704             return (log(abs).expand(deep, **hints), arg)
705         else:
706             return (log(abs), arg)
707 
708     def _eval_is_rational(self):
709         s = self.func(*self.args)
710         if s.func == self.func:
711             if (self.args[0] - 1).is_zero:
712                 return True
713             if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):
714                 return False
715         else:
716             return s.is_rational
717 
718     def _eval_is_algebraic(self):
719         s = self.func(*self.args)
720         if s.func == self.func:
721             if (self.args[0] - 1).is_zero:
722                 return True
723             elif fuzzy_not((self.args[0] - 1).is_zero):
724                 if self.args[0].is_algebraic:
725                     return False
726         else:
727             return s.is_algebraic
728 
729     def _eval_is_extended_real(self):
730         return self.args[0].is_extended_positive
731 
732     def _eval_is_finite(self):
733         arg = self.args[0]
734         if arg.is_zero:
735             return False
736         return arg.is_finite
737 
738     def _eval_is_extended_positive(self):
739         return (self.args[0] - 1).is_extended_positive
740 
741     def _eval_is_zero(self):
742         return (self.args[0] - 1).is_zero
743 
744     def _eval_is_extended_nonnegative(self):
745         return (self.args[0] - 1).is_extended_nonnegative
746 
747     def _eval_nseries(self, x, n, logx):
748         # NOTE Please see the comment at the beginning of this file, labelled
749         #      IMPORTANT.
750         from sympy import cancel, Order
751         if not logx:
752             logx = log(x)
753         if self.args[0] == x:
754             return logx
755         arg = self.args[0]
756         k, l = Wild("k"), Wild("l")
757         r = arg.match(k*x**l)
758         if r is not None:
759             k, l = r[k], r[l]
760             if l != 0 and not l.has(x) and not k.has(x):
761                 r = log(k) + l*logx  # XXX true regardless of assumptions?
762                 return r
763 
764         # TODO new and probably slow
765         s = self.args[0].nseries(x, n=n, logx=logx)
766         while s.is_Order:
767             n += 1
768             s = self.args[0].nseries(x, n=n, logx=logx)
769         a, b = s.leadterm(x)
770         p = cancel(s/(a*x**b) - 1)
771         g = None
772         l = []
773         for i in range(n + 2):
774             g = log.taylor_term(i, p, g)
775             g = g.nseries(x, n=n, logx=logx)
776             l.append(g)
777         return log(a) + b*logx + Add(*l) + Order(p**n, x)
778 
779     def _eval_as_leading_term(self, x):
780         arg = self.args[0].as_leading_term(x)
781         if arg is S.One:
782             return (self.args[0] - 1).as_leading_term(x)
783         return self.func(arg)
784 
785 
786 class LambertW(Function):
787     r"""
788     The Lambert W function `W(z)` is defined as the inverse
789     function of `w \exp(w)` [1]_.
790 
791     In other words, the value of `W(z)` is such that `z = W(z) \exp(W(z))`
792     for any complex number `z`.  The Lambert W function is a multivalued
793     function with infinitely many branches `W_k(z)`, indexed by
794     `k \in \mathbb{Z}`.  Each branch gives a different solution `w`
795     of the equation `z = w \exp(w)`.
796 
797     The Lambert W function has two partially real branches: the
798     principal branch (`k = 0`) is real for real `z > -1/e`, and the
799     `k = -1` branch is real for `-1/e < z < 0`. All branches except
800     `k = 0` have a logarithmic singularity at `z = 0`.
801 
802     Examples
803     ========
804 
805     >>> from sympy import LambertW
806     >>> LambertW(1.2)
807     0.635564016364870
808     >>> LambertW(1.2, -1).n()
809     -1.34747534407696 - 4.41624341514535*I
810     >>> LambertW(-1).is_real
811     False
812 
813     References
814     ==========
815 
816     .. [1] https://en.wikipedia.org/wiki/Lambert_W_function
817     """
818 
819     @classmethod
820     def eval(cls, x, k=None):
821         if k is S.Zero:
822             return cls(x)
823         elif k is None:
824             k = S.Zero
825 
826         if k is S.Zero:
827             if x is S.Zero:
828                 return S.Zero
829             if x is S.Exp1:
830                 return S.One
831             if x == -1/S.Exp1:
832                 return S.NegativeOne
833             if x == -log(2)/2:
834                 return -log(2)
835             if x is S.Infinity:
836                 return S.Infinity
837 
838         if fuzzy_not(k.is_zero):
839             if x is S.Zero:
840                 return S.NegativeInfinity
841         if k is S.NegativeOne:
842             if x == -S.Pi/2:
843                 return -S.ImaginaryUnit*S.Pi/2
844             elif x == -1/S.Exp1:
845                 return S.NegativeOne
846             elif x == -2*exp(-2):
847                 return -Integer(2)
848 
849     def fdiff(self, argindex=1):
850         """
851         Return the first derivative of this function.
852         """
853         x = self.args[0]
854 
855         if len(self.args) == 1:
856             if argindex == 1:
857                 return LambertW(x)/(x*(1 + LambertW(x)))
858         else:
859             k = self.args[1]
860             if argindex == 1:
861                 return LambertW(x, k)/(x*(1 + LambertW(x, k)))
862 
863         raise ArgumentIndexError(self, argindex)
864 
865     def _eval_is_extended_real(self):
866         x = self.args[0]
867         if len(self.args) == 1:
868             k = S.Zero
869         else:
870             k = self.args[1]
871         if k.is_zero:
872             if (x + 1/S.Exp1).is_positive:
873                 return True
874             elif (x + 1/S.Exp1).is_nonpositive:
875                 return False
876         elif (k + 1).is_zero:
877             if x.is_negative and (x + 1/S.Exp1).is_positive:
878                 return True
879             elif x.is_nonpositive or (x + 1/S.Exp1).is_nonnegative:
880                 return False
881         elif fuzzy_not(k.is_zero) and fuzzy_not((k + 1).is_zero):
882             if x.is_extended_real:
883                 return False
884 
885     def _eval_is_finite(self):
886         return self.args[0].is_finite
887 
888     def _eval_is_algebraic(self):
889         s = self.func(*self.args)
890         if s.func == self.func:
891             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
892                 return False
893         else:
894             return s.is_algebraic

</code><intended_behavior>Enhancements should ensure that `exp` recognizes and simplifies based on its periodicity â€“ specifically, recognizing patterns like `exp(I*pi*n)` to simplify to `-1`, `1`, or utilizing Euler's formula effectively. This might involve augmenting existing methods or implementing new logic within the class that handles `exp` to automatically apply these simplifications before returning the result.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>simplify</method>
<code>
380 def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):
381     """Simplifies the given expression.
382 
383     Simplification is not a well defined term and the exact strategies
384     this function tries can change in the future versions of SymPy. If
385     your algorithm relies on "simplification" (whatever it is), try to
386     determine what you need exactly  -  is it powsimp()?, radsimp()?,
387     together()?, logcombine()?, or something else? And use this particular
388     function directly, because those are well defined and thus your algorithm
389     will be robust.
390 
391     Nonetheless, especially for interactive use, or when you don't know
392     anything about the structure of the expression, simplify() tries to apply
393     intelligent heuristics to make the input expression "simpler".  For
394     example:
395 
396     >>> from sympy import simplify, cos, sin
397     >>> from sympy.abc import x, y
398     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
399     >>> a
400     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
401     >>> simplify(a)
402     x + 1
403 
404     Note that we could have obtained the same result by using specific
405     simplification functions:
406 
407     >>> from sympy import trigsimp, cancel
408     >>> trigsimp(a)
409     (x**2 + x)/x
410     >>> cancel(_)
411     x + 1
412 
413     In some cases, applying :func:`simplify` may actually result in some more
414     complicated expression. The default ``ratio=1.7`` prevents more extreme
415     cases: if (result length)/(input length) > ratio, then input is returned
416     unmodified.  The ``measure`` parameter lets you specify the function used
417     to determine how complex an expression is.  The function should take a
418     single argument as an expression and return a number such that if
419     expression ``a`` is more complex than expression ``b``, then
420     ``measure(a) > measure(b)``.  The default measure function is
421     :func:`count_ops`, which returns the total number of operations in the
422     expression.
423 
424     For example, if ``ratio=1``, ``simplify`` output can't be longer
425     than input.
426 
427     ::
428 
429         >>> from sympy import sqrt, simplify, count_ops, oo
430         >>> root = 1/(sqrt(2)+3)
431 
432     Since ``simplify(root)`` would result in a slightly longer expression,
433     root is returned unchanged instead::
434 
435        >>> simplify(root, ratio=1) == root
436        True
437 
438     If ``ratio=oo``, simplify will be applied anyway::
439 
440         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
441         True
442 
443     Note that the shortest expression is not necessary the simplest, so
444     setting ``ratio`` to 1 may not be a good idea.
445     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
446     choice.
447 
448     You can easily define your own measure function based on what you feel
449     should represent the "size" or "complexity" of the input expression.  Note
450     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
451     good metrics, but have other problems (in this case, the measure function
452     may slow down simplify too much for very large expressions).  If you don't
453     know what a good metric would be, the default, ``count_ops``, is a good
454     one.
455 
456     For example:
457 
458     >>> from sympy import symbols, log
459     >>> a, b = symbols('a b', positive=True)
460     >>> g = log(a) + log(b) + log(a)*log(1/b)
461     >>> h = simplify(g)
462     >>> h
463     log(a*b**(1 - log(a)))
464     >>> count_ops(g)
465     8
466     >>> count_ops(h)
467     5
468 
469     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
470     However, we may not like how ``simplify`` (in this case, using
471     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
472     to reduce this would be to give more weight to powers as operations in
473     ``count_ops``.  We can do this by using the ``visual=True`` option:
474 
475     >>> print(count_ops(g, visual=True))
476     2*ADD + DIV + 4*LOG + MUL
477     >>> print(count_ops(h, visual=True))
478     2*LOG + MUL + POW + SUB
479 
480     >>> from sympy import Symbol, S
481     >>> def my_measure(expr):
482     ...     POW = Symbol('POW')
483     ...     # Discourage powers by giving POW a weight of 10
484     ...     count = count_ops(expr, visual=True).subs(POW, 10)
485     ...     # Every other operation gets a weight of 1 (the default)
486     ...     count = count.replace(Symbol, type(S.One))
487     ...     return count
488     >>> my_measure(g)
489     8
490     >>> my_measure(h)
491     14
492     >>> 15./8 > 1.7 # 1.7 is the default ratio
493     True
494     >>> simplify(g, measure=my_measure)
495     -log(a)*log(b) + log(a) + log(b)
496 
497     Note that because ``simplify()`` internally tries many different
498     simplification strategies and then compares them using the measure
499     function, we get a completely different result that is still different
500     from the input expression by doing this.
501 
502     If rational=True, Floats will be recast as Rationals before simplification.
503     If rational=None, Floats will be recast as Rationals but the result will
504     be recast as Floats. If rational=False(default) then nothing will be done
505     to the Floats.
506 
507     If inverse=True, it will be assumed that a composition of inverse
508     functions, such as sin and asin, can be cancelled in any order.
509     For example, ``asin(sin(x))`` will yield ``x`` without checking whether
510     x belongs to the set where this relation is true. The default is
511     False.
512 
513     Note that ``simplify()`` automatically calls ``doit()`` on the final
514     expression. You can avoid this behavior by passing ``doit=False`` as
515     an argument.
516     """
517     def done(e):
518         return e.doit() if doit else e
519 
520     expr = sympify(expr)
521     kwargs = dict(
522         ratio=kwargs.get('ratio', ratio),
523         measure=kwargs.get('measure', measure),
524         rational=kwargs.get('rational', rational),
525         inverse=kwargs.get('inverse', inverse),
526         doit=kwargs.get('doit', doit))
527     # no routine for Expr needs to check for is_zero
528     if isinstance(expr, Expr) and expr.is_zero and expr*0 is S.Zero:
529         return S.Zero
530 
531     _eval_simplify = getattr(expr, '_eval_simplify', None)
532     if _eval_simplify is not None:
533         return _eval_simplify(**kwargs)
534 
535     original_expr = expr = signsimp(expr)
536 
537     from sympy.simplify.hyperexpand import hyperexpand
538     from sympy.functions.special.bessel import BesselBase
539     from sympy import Sum, Product, Integral
540 
541     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
542         return expr
543 
544     if inverse and expr.has(Function):
545         expr = inversecombine(expr)
546         if not expr.args:  # simplified to atomic
547             return expr
548 
549     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
550         return done(
551             expr.func(*[simplify(x, **kwargs) for x in expr.args]))
552 
553     if not expr.is_commutative:
554         expr = nc_simplify(expr)
555 
556     # TODO: Apply different strategies, considering expression pattern:
557     # is it a purely rational function? Is there any trigonometric function?...
558     # See also https://github.com/sympy/sympy/pull/185.
559 
560     def shorter(*choices):
561         '''Return the choice that has the fewest ops. In case of a tie,
562         the expression listed first is selected.'''
563         if not has_variety(choices):
564             return choices[0]
565         return min(choices, key=measure)
566 
567     # rationalize Floats
568     floats = False
569     if rational is not False and expr.has(Float):
570         floats = True
571         expr = nsimplify(expr, rational=True)
572 
573     expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())
574     expr = Mul(*powsimp(expr).as_content_primitive())
575     _e = cancel(expr)
576     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
577     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
578 
579     if ratio is S.Infinity:
580         expr = expr2
581     else:
582         expr = shorter(expr2, expr1, expr)
583     if not isinstance(expr, Basic):  # XXX: temporary hack
584         return expr
585 
586     expr = factor_terms(expr, sign=False)
587 
588     # hyperexpand automatically only works on hypergeometric terms
589     expr = hyperexpand(expr)
590 
591     expr = piecewise_fold(expr)
592 
593     if expr.has(BesselBase):
594         expr = besselsimp(expr)
595 
596     if expr.has(TrigonometricFunction, HyperbolicFunction):
597         expr = trigsimp(expr, deep=True)
598 
599     if expr.has(log):
600         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
601 
602     if expr.has(CombinatorialFunction, gamma):
603         # expression with gamma functions or non-integer arguments is
604         # automatically passed to gammasimp
605         expr = combsimp(expr)
606 
607     if expr.has(Sum):
608         expr = sum_simplify(expr, **kwargs)
609 
610     if expr.has(Integral):
611         expr = expr.xreplace(dict([
612             (i, factor_terms(i)) for i in expr.atoms(Integral)]))
613 
614     if expr.has(Product):
615         expr = product_simplify(expr)
616 
617     from sympy.physics.units import Quantity
618     from sympy.physics.units.util import quantity_simplify
619 
620     if expr.has(Quantity):
621         expr = quantity_simplify(expr)
622 
623     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
624     short = shorter(short, cancel(short))
625     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
626     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
627         short = exptrigsimp(short)
628 
629     # get rid of hollow 2-arg Mul factorization
630     hollow_mul = Transform(
631         lambda x: Mul(*x.args),
632         lambda x:
633         x.is_Mul and
634         len(x.args) == 2 and
635         x.args[0].is_Number and
636         x.args[1].is_Add and
637         x.is_commutative)
638     expr = short.xreplace(hollow_mul)
639 
640     numer, denom = expr.as_numer_denom()
641     if denom.is_Add:
642         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
643         if n is not S.One:
644             expr = (numer*n).expand()/d
645 
646     if expr.could_extract_minus_sign():
647         n, d = fraction(expr)
648         if d != 0:
649             expr = signsimp(-n/(-d))
650 
651     if measure(expr) > ratio*measure(original_expr):
652         expr = original_expr
653 
654     # restore floats
655     if floats and rational is None:
656         expr = nfloat(expr, exponent=False)
657 
658     return done(expr)

</code><intended_behavior>The `simplify` method should include additional heuristics or checks to identify and simplify expressions involving the exponential function with imaginary arguments that can be simplified based on the periodicity. This might involve adding specific rules or enhancing current ones to more effectively utilize the properties of exponentials, thereby directly simplifying expressions that exhibit periodic behavior without requiring further intervention.</intended_behavior>]
2025-10-15 14:22:00.959 | INFO     | Search completed. Bug locations: [<file>sympy/functions/elementary/exponential.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import sympify
4 from sympy.core.add import Add
5 from sympy.core.cache import cacheit
6 from sympy.core.compatibility import range
7 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
8 from sympy.core.logic import fuzzy_not
9 from sympy.core.mul import Mul
10 from sympy.core.numbers import Integer
11 from sympy.core.power import Pow
12 from sympy.core.singleton import S
13 from sympy.core.symbol import Wild, Dummy
14 from sympy.functions.combinatorial.factorials import factorial
15 from sympy.ntheory import multiplicity, perfect_power
16 
17 # NOTE IMPORTANT
18 # The series expansion code in this file is an important part of the gruntz
19 # algorithm for determining limits. _eval_nseries has to return a generalized
20 # power series with coefficients in C(log(x), log).
21 # In more detail, the result of _eval_nseries(self, x, n) must be
22 #   c_0*x**e_0 + ... (finitely many terms)
23 # where e_i are numbers (not necessarily integers) and c_i involve only
24 # numbers, the function log, and log(x). [This also means it must not contain
25 # log(x(1+p)), this *has* to be expanded to log(x)+log(1+p) if x.is_positive and
26 # p.is_positive.]
27 
28 
29 class ExpBase(Function):
30 
31     unbranched = True
32 
33     def inverse(self, argindex=1):
34         """
35         Returns the inverse function of ``exp(x)``.
36         """
37         return log
38 
39     def as_numer_denom(self):
40         """
41         Returns this with a positive exponent as a 2-tuple (a fraction).
42 
43         Examples
44         ========
45 
46         >>> from sympy.functions import exp
47         >>> from sympy.abc import x
48         >>> exp(-x).as_numer_denom()
49         (1, exp(x))
50         >>> exp(x).as_numer_denom()
51         (exp(x), 1)
52         """
53         # this should be the same as Pow.as_numer_denom wrt
54         # exponent handling
55         exp = self.exp
56         neg_exp = exp.is_negative
57         if not neg_exp and not (-exp).is_negative:
58             neg_exp = _coeff_isneg(exp)
59         if neg_exp:
60             return S.One, self.func(-exp)
61         return self, S.One
62 
63     @property
64     def exp(self):
65         """
66         Returns the exponent of the function.
67         """
68         return self.args[0]
69 
70     def as_base_exp(self):
71         """
72         Returns the 2-tuple (base, exponent).
73         """
74         return self.func(1), Mul(*self.args)
75 
76     def _eval_conjugate(self):
77         return self.func(self.args[0].conjugate())
78 
79     def _eval_is_finite(self):
80         arg = self.args[0]
81         if arg.is_infinite:
82             if arg.is_negative:
83                 return True
84             if arg.is_positive:
85                 return False
86         if arg.is_finite:
87             return True
88 
89     def _eval_is_rational(self):
90         s = self.func(*self.args)
91         if s.func == self.func:
92             if s.exp is S.Zero:
93                 return True
94             elif s.exp.is_rational and fuzzy_not(s.exp.is_zero):
95                 return False
96         else:
97             return s.is_rational
98 
99     def _eval_is_zero(self):
100         return (self.args[0] is S.NegativeInfinity)
101 
102     def _eval_power(self, other):
103         """exp(arg)**e -> exp(arg*e) if assumptions allow it.
104         """
105         b, e = self.as_base_exp()
106         return Pow._eval_power(Pow(b, e, evaluate=False), other)
107 
108     def _eval_expand_power_exp(self, **hints):
109         arg = self.args[0]
110         if arg.is_Add and arg.is_commutative:
111             expr = 1
112             for x in arg.args:
113                 expr *= self.func(x)
114             return expr
115         return self.func(arg)
116 
117 
118 class exp_polar(ExpBase):
119     r"""
120     Represent a 'polar number' (see g-function Sphinx documentation).
121 
122     ``exp_polar`` represents the function
123     `Exp: \mathbb{C} \rightarrow \mathcal{S}`, sending the complex number
124     `z = a + bi` to the polar number `r = exp(a), \theta = b`. It is one of
125     the main functions to construct polar numbers.
126 
127     >>> from sympy import exp_polar, pi, I, exp
128 
129     The main difference is that polar numbers don't "wrap around" at `2 \pi`:
130 
131     >>> exp(2*pi*I)
132     1
133     >>> exp_polar(2*pi*I)
134     exp_polar(2*I*pi)
135 
136     apart from that they behave mostly like classical complex numbers:
137 
138     >>> exp_polar(2)*exp_polar(3)
139     exp_polar(5)
140 
141     See Also
142     ========
143 
144     sympy.simplify.simplify.powsimp
145     sympy.functions.elementary.complexes.polar_lift
146     sympy.functions.elementary.complexes.periodic_argument
147     sympy.functions.elementary.complexes.principal_branch
148     """
149 
150     is_polar = True
151     is_comparable = False  # cannot be evalf'd
152 
153     def _eval_Abs(self):   # Abs is never a polar number
154         from sympy.functions.elementary.complexes import re
155         return exp(re(self.args[0]))
156 
157     def _eval_evalf(self, prec):
158         """ Careful! any evalf of polar numbers is flaky """
159         from sympy import im, pi, re
160         i = im(self.args[0])
161         try:
162             bad = (i <= -pi or i > pi)
163         except TypeError:
164             bad = True
165         if bad:
166             return self  # cannot evalf for this argument
167         res = exp(self.args[0])._eval_evalf(prec)
168         if i > 0 and im(res) < 0:
169             # i ~ pi, but exp(I*i) evaluated to argument slightly bigger than pi
170             return re(res)
171         return res
172 
173     def _eval_power(self, other):
174         return self.func(self.args[0]*other)
175 
176     def _eval_is_extended_real(self):
177         if self.args[0].is_extended_real:
178             return True
179 
180     def as_base_exp(self):
181         # XXX exp_polar(0) is special!
182         if self.args[0] == 0:
183             return self, S(1)
184         return ExpBase.as_base_exp(self)
185 
186 
187 class exp(ExpBase):
188     """
189     The exponential function, :math:`e^x`.
190 
191     See Also
192     ========
193 
194     log
195     """
196 
197     def fdiff(self, argindex=1):
198         """
199         Returns the first derivative of this function.
200         """
201         if argindex == 1:
202             return self
203         else:
204             raise ArgumentIndexError(self, argindex)
205 
206     def _eval_refine(self, assumptions):
207         from sympy.assumptions import ask, Q
208         arg = self.args[0]
209         if arg.is_Mul:
210             Ioo = S.ImaginaryUnit*S.Infinity
211             if arg in [Ioo, -Ioo]:
212                 return S.NaN
213 
214             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
215             if coeff:
216                 if ask(Q.integer(2*coeff)):
217                     if ask(Q.even(coeff)):
218                         return S.One
219                     elif ask(Q.odd(coeff)):
220                         return S.NegativeOne
221                     elif ask(Q.even(coeff + S.Half)):
222                         return -S.ImaginaryUnit
223                     elif ask(Q.odd(coeff + S.Half)):
224                         return S.ImaginaryUnit
225 
226     @classmethod
227     def eval(cls, arg):
228         from sympy.assumptions import ask, Q
229         from sympy.calculus import AccumBounds
230         from sympy.sets.setexpr import SetExpr
231         from sympy.matrices.matrices import MatrixBase
232         from sympy import logcombine
233         if arg.is_Number:
234             if arg is S.NaN:
235                 return S.NaN
236             elif arg is S.Zero:
237                 return S.One
238             elif arg is S.One:
239                 return S.Exp1
240             elif arg is S.Infinity:
241                 return S.Infinity
242             elif arg is S.NegativeInfinity:
243                 return S.Zero
244         elif arg is S.ComplexInfinity:
245             return S.NaN
246         elif isinstance(arg, log):
247             return arg.args[0]
248         elif isinstance(arg, AccumBounds):
249             return AccumBounds(exp(arg.min), exp(arg.max))
250         elif isinstance(arg, SetExpr):
251             return arg._eval_func(cls)
252         elif arg.is_Mul:
253             if arg.is_number or arg.is_Symbol:
254                 coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
255                 if coeff:
256                     if ask(Q.integer(2*coeff)):
257                         if ask(Q.even(coeff)):
258                             return S.One
259                         elif ask(Q.odd(coeff)):
260                             return S.NegativeOne
261                         elif ask(Q.even(coeff + S.Half)):
262                             return -S.ImaginaryUnit
263                         elif ask(Q.odd(coeff + S.Half)):
264                             return S.ImaginaryUnit
265 
266             # Warning: code in risch.py will be very sensitive to changes
267             # in this (see DifferentialExtension).
268 
269             # look for a single log factor
270 
271             coeff, terms = arg.as_coeff_Mul()
272 
273             # but it can't be multiplied by oo
274             if coeff in [S.NegativeInfinity, S.Infinity]:
275                 return None
276 
277             coeffs, log_term = [coeff], None
278             for term in Mul.make_args(terms):
279                 term_ = logcombine(term)
280                 if isinstance(term_, log):
281                     if log_term is None:
282                         log_term = term_.args[0]
283                     else:
284                         return None
285                 elif term.is_comparable:
286                     coeffs.append(term)
287                 else:
288                     return None
289 
290             return log_term**Mul(*coeffs) if log_term else None
291 
292         elif arg.is_Add:
293             out = []
294             add = []
295             for a in arg.args:
296                 if a is S.One:
297                     add.append(a)
298                     continue
299                 newa = cls(a)
300                 if isinstance(newa, cls):
301                     add.append(a)
302                 else:
303                     out.append(newa)
304             if out:
305                 return Mul(*out)*cls(Add(*add), evaluate=False)
306 
307         elif isinstance(arg, MatrixBase):
308             return arg.exp()
309 
310     @property
311     def base(self):
312         """
313         Returns the base of the exponential function.
314         """
315         return S.Exp1
316 
317     @staticmethod
318     @cacheit
319     def taylor_term(n, x, *previous_terms):
320         """
321         Calculates the next term in the Taylor series expansion.
322         """
323         if n < 0:
324             return S.Zero
325         if n == 0:
326             return S.One
327         x = sympify(x)
328         if previous_terms:
329             p = previous_terms[-1]
330             if p is not None:
331                 return p * x / n
332         return x**n/factorial(n)
333 
334     def as_real_imag(self, deep=True, **hints):
335         """
336         Returns this function as a 2-tuple representing a complex number.
337 
338         Examples
339         ========
340 
341         >>> from sympy import I
342         >>> from sympy.abc import x
343         >>> from sympy.functions import exp
344         >>> exp(x).as_real_imag()
345         (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))
346         >>> exp(1).as_real_imag()
347         (E, 0)
348         >>> exp(I).as_real_imag()
349         (cos(1), sin(1))
350         >>> exp(1+I).as_real_imag()
351         (E*cos(1), E*sin(1))
352 
353         See Also
354         ========
355 
356         sympy.functions.elementary.complexes.re
357         sympy.functions.elementary.complexes.im
358         """
359         import sympy
360         re, im = self.args[0].as_real_imag()
361         if deep:
362             re = re.expand(deep, **hints)
363             im = im.expand(deep, **hints)
364         cos, sin = sympy.cos(im), sympy.sin(im)
365         return (exp(re)*cos, exp(re)*sin)
366 
367     def _eval_subs(self, old, new):
368         # keep processing of power-like args centralized in Pow
369         if old.is_Pow:  # handle (exp(3*log(x))).subs(x**2, z) -> z**(3/2)
370             old = exp(old.exp*log(old.base))
371         elif old is S.Exp1 and new.is_Function:
372             old = exp
373         if isinstance(old, exp) or old is S.Exp1:
374             f = lambda a: Pow(*a.as_base_exp(), evaluate=False) if (
375                 a.is_Pow or isinstance(a, exp)) else a
376             return Pow._eval_subs(f(self), f(old), new)
377 
378         if old is exp and not new.is_Function:
379             return new**self.exp._subs(old, new)
380         return Function._eval_subs(self, old, new)
381 
382     def _eval_is_extended_real(self):
383         if self.args[0].is_extended_real:
384             return True
385         elif self.args[0].is_imaginary:
386             arg2 = -S(2) * S.ImaginaryUnit * self.args[0] / S.Pi
387             return arg2.is_even
388 
389     def _eval_is_algebraic(self):
390         s = self.func(*self.args)
391         if s.func == self.func:
392             if fuzzy_not(self.exp.is_zero):
393                 if self.exp.is_algebraic:
394                     return False
395                 elif (self.exp/S.Pi).is_rational:
396                     return False
397         else:
398             return s.is_algebraic
399 
400     def _eval_is_extended_positive(self):
401         if self.args[0].is_extended_real:
402             return not self.args[0] is S.NegativeInfinity
403         elif self.args[0].is_imaginary:
404             arg2 = -S.ImaginaryUnit * self.args[0] / S.Pi
405             return arg2.is_even
406 
407     def _eval_nseries(self, x, n, logx):
408         # NOTE Please see the comment at the beginning of this file, labelled
409         #      IMPORTANT.
410         from sympy import limit, oo, Order, powsimp
411         arg = self.args[0]
412         arg_series = arg._eval_nseries(x, n=n, logx=logx)
413         if arg_series.is_Order:
414             return 1 + arg_series
415         arg0 = limit(arg_series.removeO(), x, 0)
416         if arg0 in [-oo, oo]:
417             return self
418         t = Dummy("t")
419         exp_series = exp(t)._taylor(t, n)
420         o = exp_series.getO()
421         exp_series = exp_series.removeO()
422         r = exp(arg0)*exp_series.subs(t, arg_series - arg0)
423         r += Order(o.expr.subs(t, (arg_series - arg0)), x)
424         r = r.expand()
425         return powsimp(r, deep=True, combine='exp')
426 
427     def _taylor(self, x, n):
428         from sympy import Order
429         l = []
430         g = None
431         for i in range(n):
432             g = self.taylor_term(i, self.args[0], g)
433             g = g.nseries(x, n=n)
434             l.append(g)
435         return Add(*l) + Order(x**n, x)
436 
437     def _eval_as_leading_term(self, x):
438         from sympy import Order
439         arg = self.args[0]
440         if arg.is_Add:
441             return Mul(*[exp(f).as_leading_term(x) for f in arg.args])
442         arg = self.args[0].as_leading_term(x)
443         if Order(1, x).contains(arg):
444             return S.One
445         return exp(arg)
446 
447     def _eval_rewrite_as_sin(self, arg, **kwargs):
448         from sympy import sin
449         I = S.ImaginaryUnit
450         return sin(I*arg + S.Pi/2) - I*sin(I*arg)
451 
452     def _eval_rewrite_as_cos(self, arg, **kwargs):
453         from sympy import cos
454         I = S.ImaginaryUnit
455         return cos(I*arg) + I*cos(I*arg + S.Pi/2)
456 
457     def _eval_rewrite_as_tanh(self, arg, **kwargs):
458         from sympy import tanh
459         return (1 + tanh(arg/2))/(1 - tanh(arg/2))
460 
461     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
462         from sympy.functions.elementary.trigonometric import sin, cos
463         if arg.is_Mul:
464             coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
465             if coeff and coeff.is_number:
466                 cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)
467                 if not isinstance(cosine, cos) and not isinstance (sine, sin):
468                     return cosine + S.ImaginaryUnit*sine
469 
470     def _eval_rewrite_as_Pow(self, arg, **kwargs):
471         if arg.is_Mul:
472             logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]
473             if logs:
474                 return Pow(logs[0].args[0], arg.coeff(logs[0]))
475 
476 
477 class log(Function):
478     r"""
479     The natural logarithm function `\ln(x)` or `\log(x)`.
480     Logarithms are taken with the natural base, `e`. To get
481     a logarithm of a different base ``b``, use ``log(x, b)``,
482     which is essentially short-hand for ``log(x)/log(b)``.
483 
484     Examples
485     ========
486 
487     >>> from sympy import log, S
488     >>> log(8, 2)
489     3
490     >>> log(S(8)/3, 2)
491     -log(3)/log(2) + 3
492 
493     See Also
494     ========
495 
496     exp
497     """
498 
499     def fdiff(self, argindex=1):
500         """
501         Returns the first derivative of the function.
502         """
503         if argindex == 1:
504             return 1/self.args[0]
505         else:
506             raise ArgumentIndexError(self, argindex)
507 
508     def inverse(self, argindex=1):
509         r"""
510         Returns `e^x`, the inverse function of `\log(x)`.
511         """
512         return exp
513 
514     @classmethod
515     def eval(cls, arg, base=None):
516         from sympy import unpolarify
517         from sympy.calculus import AccumBounds
518         from sympy.sets.setexpr import SetExpr
519 
520         arg = sympify(arg)
521 
522         if base is not None:
523             base = sympify(base)
524             if base == 1:
525                 if arg == 1:
526                     return S.NaN
527                 else:
528                     return S.ComplexInfinity
529             try:
530                 # handle extraction of powers of the base now
531                 # or else expand_log in Mul would have to handle this
532                 n = multiplicity(base, arg)
533                 if n:
534                     return n + log(arg / base**n) / log(base)
535                 else:
536                     return log(arg)/log(base)
537             except ValueError:
538                 pass
539             if base is not S.Exp1:
540                 return cls(arg)/cls(base)
541             else:
542                 return cls(arg)
543 
544         if arg.is_Number:
545             if arg is S.Zero:
546                 return S.ComplexInfinity
547             elif arg is S.One:
548                 return S.Zero
549             elif arg is S.Infinity:
550                 return S.Infinity
551             elif arg is S.NegativeInfinity:
552                 return S.Infinity
553             elif arg is S.NaN:
554                 return S.NaN
555             elif arg.is_Rational and arg.p == 1:
556                 return -cls(arg.q)
557 
558         if isinstance(arg, exp) and arg.args[0].is_extended_real:
559             return arg.args[0]
560         elif isinstance(arg, exp_polar):
561             return unpolarify(arg.exp)
562         elif isinstance(arg, AccumBounds):
563             if arg.min.is_positive:
564                 return AccumBounds(log(arg.min), log(arg.max))
565             else:
566                 return
567         elif isinstance(arg, SetExpr):
568             return arg._eval_func(cls)
569 
570         if arg.is_number:
571             if arg.is_negative:
572                 return S.Pi * S.ImaginaryUnit + cls(-arg)
573             elif arg is S.ComplexInfinity:
574                 return S.ComplexInfinity
575             elif arg is S.Exp1:
576                 return S.One
577 
578         # don't autoexpand Pow or Mul (see the issue 3351):
579         if not arg.is_Add:
580             coeff = arg.as_coefficient(S.ImaginaryUnit)
581 
582             if coeff is not None:
583                 if coeff is S.Infinity:
584                     return S.Infinity
585                 elif coeff is S.NegativeInfinity:
586                     return S.Infinity
587                 elif coeff.is_Rational:
588                     if coeff.is_nonnegative:
589                         return S.Pi * S.ImaginaryUnit * S.Half + cls(coeff)
590                     else:
591                         return -S.Pi * S.ImaginaryUnit * S.Half + cls(-coeff)
592 
593     def as_base_exp(self):
594         """
595         Returns this function in the form (base, exponent).
596         """
597         return self, S.One
598 
599     @staticmethod
600     @cacheit
601     def taylor_term(n, x, *previous_terms):  # of log(1+x)
602         r"""
603         Returns the next term in the Taylor series expansion of `\log(1+x)`.
604         """
605         from sympy import powsimp
606         if n < 0:
607             return S.Zero
608         x = sympify(x)
609         if n == 0:
610             return x
611         if previous_terms:
612             p = previous_terms[-1]
613             if p is not None:
614                 return powsimp((-n) * p * x / (n + 1), deep=True, combine='exp')
615         return (1 - 2*(n % 2)) * x**(n + 1)/(n + 1)
616 
617     def _eval_expand_log(self, deep=True, **hints):
618         from sympy import unpolarify, expand_log
619         from sympy.concrete import Sum, Product
620         force = hints.get('force', False)
621         if (len(self.args) == 2):
622             return expand_log(self.func(*self.args), deep=deep, force=force)
623         arg = self.args[0]
624         if arg.is_Integer:
625             # remove perfect powers
626             p = perfect_power(int(arg))
627             if p is not False:
628                 return p[1]*self.func(p[0])
629         elif arg.is_Rational:
630             return log(arg.p) - log(arg.q)
631         elif arg.is_Mul:
632             expr = []
633             nonpos = []
634             for x in arg.args:
635                 if force or x.is_positive or x.is_polar:
636                     a = self.func(x)
637                     if isinstance(a, log):
638                         expr.append(self.func(x)._eval_expand_log(**hints))
639                     else:
640                         expr.append(a)
641                 elif x.is_negative:
642                     a = self.func(-x)
643                     expr.append(a)
644                     nonpos.append(S.NegativeOne)
645                 else:
646                     nonpos.append(x)
647             return Add(*expr) + log(Mul(*nonpos))
648         elif arg.is_Pow or isinstance(arg, exp):
649             if force or (arg.exp.is_extended_real and (arg.base.is_positive or ((arg.exp+1)
650                 .is_positive and (arg.exp-1).is_nonpositive))) or arg.base.is_polar:
651                 b = arg.base
652                 e = arg.exp
653                 a = self.func(b)
654                 if isinstance(a, log):
655                     return unpolarify(e) * a._eval_expand_log(**hints)
656                 else:
657                     return unpolarify(e) * a
658         elif isinstance(arg, Product):
659             if arg.function.is_positive:
660                 return Sum(log(arg.function), *arg.limits)
661 
662         return self.func(arg)
663 
664     def _eval_simplify(self, **kwargs):
665         from sympy.simplify.simplify import expand_log, simplify, inversecombine
666         if len(self.args) == 2:  # it's unevaluated
667             return simplify(self.func(*self.args), **kwargs)
668 
669         expr = self.func(simplify(self.args[0], **kwargs))
670         if kwargs['inverse']:
671             expr = inversecombine(expr)
672         expr = expand_log(expr, deep=True)
673         return min([expr, self], key=kwargs['measure'])
674 
675     def as_real_imag(self, deep=True, **hints):
676         """
677         Returns this function as a complex coordinate.
678 
679         Examples
680         ========
681 
682         >>> from sympy import I
683         >>> from sympy.abc import x
684         >>> from sympy.functions import log
685         >>> log(x).as_real_imag()
686         (log(Abs(x)), arg(x))
687         >>> log(I).as_real_imag()
688         (0, pi/2)
689         >>> log(1 + I).as_real_imag()
690         (log(sqrt(2)), pi/4)
691         >>> log(I*x).as_real_imag()
692         (log(Abs(x)), arg(I*x))
693 
694         """
695         from sympy import Abs, arg
696         if deep:
697             abs = Abs(self.args[0].expand(deep, **hints))
698             arg = arg(self.args[0].expand(deep, **hints))
699         else:
700             abs = Abs(self.args[0])
701             arg = arg(self.args[0])
702         if hints.get('log', False):  # Expand the log
703             hints['complex'] = False
704             return (log(abs).expand(deep, **hints), arg)
705         else:
706             return (log(abs), arg)
707 
708     def _eval_is_rational(self):
709         s = self.func(*self.args)
710         if s.func == self.func:
711             if (self.args[0] - 1).is_zero:
712                 return True
713             if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):
714                 return False
715         else:
716             return s.is_rational
717 
718     def _eval_is_algebraic(self):
719         s = self.func(*self.args)
720         if s.func == self.func:
721             if (self.args[0] - 1).is_zero:
722                 return True
723             elif fuzzy_not((self.args[0] - 1).is_zero):
724                 if self.args[0].is_algebraic:
725                     return False
726         else:
727             return s.is_algebraic
728 
729     def _eval_is_extended_real(self):
730         return self.args[0].is_extended_positive
731 
732     def _eval_is_finite(self):
733         arg = self.args[0]
734         if arg.is_zero:
735             return False
736         return arg.is_finite
737 
738     def _eval_is_extended_positive(self):
739         return (self.args[0] - 1).is_extended_positive
740 
741     def _eval_is_zero(self):
742         return (self.args[0] - 1).is_zero
743 
744     def _eval_is_extended_nonnegative(self):
745         return (self.args[0] - 1).is_extended_nonnegative
746 
747     def _eval_nseries(self, x, n, logx):
748         # NOTE Please see the comment at the beginning of this file, labelled
749         #      IMPORTANT.
750         from sympy import cancel, Order
751         if not logx:
752             logx = log(x)
753         if self.args[0] == x:
754             return logx
755         arg = self.args[0]
756         k, l = Wild("k"), Wild("l")
757         r = arg.match(k*x**l)
758         if r is not None:
759             k, l = r[k], r[l]
760             if l != 0 and not l.has(x) and not k.has(x):
761                 r = log(k) + l*logx  # XXX true regardless of assumptions?
762                 return r
763 
764         # TODO new and probably slow
765         s = self.args[0].nseries(x, n=n, logx=logx)
766         while s.is_Order:
767             n += 1
768             s = self.args[0].nseries(x, n=n, logx=logx)
769         a, b = s.leadterm(x)
770         p = cancel(s/(a*x**b) - 1)
771         g = None
772         l = []
773         for i in range(n + 2):
774             g = log.taylor_term(i, p, g)
775             g = g.nseries(x, n=n, logx=logx)
776             l.append(g)
777         return log(a) + b*logx + Add(*l) + Order(p**n, x)
778 
779     def _eval_as_leading_term(self, x):
780         arg = self.args[0].as_leading_term(x)
781         if arg is S.One:
782             return (self.args[0] - 1).as_leading_term(x)
783         return self.func(arg)
784 
785 
786 class LambertW(Function):
787     r"""
788     The Lambert W function `W(z)` is defined as the inverse
789     function of `w \exp(w)` [1]_.
790 
791     In other words, the value of `W(z)` is such that `z = W(z) \exp(W(z))`
792     for any complex number `z`.  The Lambert W function is a multivalued
793     function with infinitely many branches `W_k(z)`, indexed by
794     `k \in \mathbb{Z}`.  Each branch gives a different solution `w`
795     of the equation `z = w \exp(w)`.
796 
797     The Lambert W function has two partially real branches: the
798     principal branch (`k = 0`) is real for real `z > -1/e`, and the
799     `k = -1` branch is real for `-1/e < z < 0`. All branches except
800     `k = 0` have a logarithmic singularity at `z = 0`.
801 
802     Examples
803     ========
804 
805     >>> from sympy import LambertW
806     >>> LambertW(1.2)
807     0.635564016364870
808     >>> LambertW(1.2, -1).n()
809     -1.34747534407696 - 4.41624341514535*I
810     >>> LambertW(-1).is_real
811     False
812 
813     References
814     ==========
815 
816     .. [1] https://en.wikipedia.org/wiki/Lambert_W_function
817     """
818 
819     @classmethod
820     def eval(cls, x, k=None):
821         if k is S.Zero:
822             return cls(x)
823         elif k is None:
824             k = S.Zero
825 
826         if k is S.Zero:
827             if x is S.Zero:
828                 return S.Zero
829             if x is S.Exp1:
830                 return S.One
831             if x == -1/S.Exp1:
832                 return S.NegativeOne
833             if x == -log(2)/2:
834                 return -log(2)
835             if x is S.Infinity:
836                 return S.Infinity
837 
838         if fuzzy_not(k.is_zero):
839             if x is S.Zero:
840                 return S.NegativeInfinity
841         if k is S.NegativeOne:
842             if x == -S.Pi/2:
843                 return -S.ImaginaryUnit*S.Pi/2
844             elif x == -1/S.Exp1:
845                 return S.NegativeOne
846             elif x == -2*exp(-2):
847                 return -Integer(2)
848 
849     def fdiff(self, argindex=1):
850         """
851         Return the first derivative of this function.
852         """
853         x = self.args[0]
854 
855         if len(self.args) == 1:
856             if argindex == 1:
857                 return LambertW(x)/(x*(1 + LambertW(x)))
858         else:
859             k = self.args[1]
860             if argindex == 1:
861                 return LambertW(x, k)/(x*(1 + LambertW(x, k)))
862 
863         raise ArgumentIndexError(self, argindex)
864 
865     def _eval_is_extended_real(self):
866         x = self.args[0]
867         if len(self.args) == 1:
868             k = S.Zero
869         else:
870             k = self.args[1]
871         if k.is_zero:
872             if (x + 1/S.Exp1).is_positive:
873                 return True
874             elif (x + 1/S.Exp1).is_nonpositive:
875                 return False
876         elif (k + 1).is_zero:
877             if x.is_negative and (x + 1/S.Exp1).is_positive:
878                 return True
879             elif x.is_nonpositive or (x + 1/S.Exp1).is_nonnegative:
880                 return False
881         elif fuzzy_not(k.is_zero) and fuzzy_not((k + 1).is_zero):
882             if x.is_extended_real:
883                 return False
884 
885     def _eval_is_finite(self):
886         return self.args[0].is_finite
887 
888     def _eval_is_algebraic(self):
889         s = self.func(*self.args)
890         if s.func == self.func:
891             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
892                 return False
893         else:
894             return s.is_algebraic

</code><intended_behavior>Enhancements should ensure that `exp` recognizes and simplifies based on its periodicity â€“ specifically, recognizing patterns like `exp(I*pi*n)` to simplify to `-1`, `1`, or utilizing Euler's formula effectively. This might involve augmenting existing methods or implementing new logic within the class that handles `exp` to automatically apply these simplifications before returning the result.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>simplify</method>
<code>
380 def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):
381     """Simplifies the given expression.
382 
383     Simplification is not a well defined term and the exact strategies
384     this function tries can change in the future versions of SymPy. If
385     your algorithm relies on "simplification" (whatever it is), try to
386     determine what you need exactly  -  is it powsimp()?, radsimp()?,
387     together()?, logcombine()?, or something else? And use this particular
388     function directly, because those are well defined and thus your algorithm
389     will be robust.
390 
391     Nonetheless, especially for interactive use, or when you don't know
392     anything about the structure of the expression, simplify() tries to apply
393     intelligent heuristics to make the input expression "simpler".  For
394     example:
395 
396     >>> from sympy import simplify, cos, sin
397     >>> from sympy.abc import x, y
398     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
399     >>> a
400     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
401     >>> simplify(a)
402     x + 1
403 
404     Note that we could have obtained the same result by using specific
405     simplification functions:
406 
407     >>> from sympy import trigsimp, cancel
408     >>> trigsimp(a)
409     (x**2 + x)/x
410     >>> cancel(_)
411     x + 1
412 
413     In some cases, applying :func:`simplify` may actually result in some more
414     complicated expression. The default ``ratio=1.7`` prevents more extreme
415     cases: if (result length)/(input length) > ratio, then input is returned
416     unmodified.  The ``measure`` parameter lets you specify the function used
417     to determine how complex an expression is.  The function should take a
418     single argument as an expression and return a number such that if
419     expression ``a`` is more complex than expression ``b``, then
420     ``measure(a) > measure(b)``.  The default measure function is
421     :func:`count_ops`, which returns the total number of operations in the
422     expression.
423 
424     For example, if ``ratio=1``, ``simplify`` output can't be longer
425     than input.
426 
427     ::
428 
429         >>> from sympy import sqrt, simplify, count_ops, oo
430         >>> root = 1/(sqrt(2)+3)
431 
432     Since ``simplify(root)`` would result in a slightly longer expression,
433     root is returned unchanged instead::
434 
435        >>> simplify(root, ratio=1) == root
436        True
437 
438     If ``ratio=oo``, simplify will be applied anyway::
439 
440         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
441         True
442 
443     Note that the shortest expression is not necessary the simplest, so
444     setting ``ratio`` to 1 may not be a good idea.
445     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
446     choice.
447 
448     You can easily define your own measure function based on what you feel
449     should represent the "size" or "complexity" of the input expression.  Note
450     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
451     good metrics, but have other problems (in this case, the measure function
452     may slow down simplify too much for very large expressions).  If you don't
453     know what a good metric would be, the default, ``count_ops``, is a good
454     one.
455 
456     For example:
457 
458     >>> from sympy import symbols, log
459     >>> a, b = symbols('a b', positive=True)
460     >>> g = log(a) + log(b) + log(a)*log(1/b)
461     >>> h = simplify(g)
462     >>> h
463     log(a*b**(1 - log(a)))
464     >>> count_ops(g)
465     8
466     >>> count_ops(h)
467     5
468 
469     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
470     However, we may not like how ``simplify`` (in this case, using
471     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
472     to reduce this would be to give more weight to powers as operations in
473     ``count_ops``.  We can do this by using the ``visual=True`` option:
474 
475     >>> print(count_ops(g, visual=True))
476     2*ADD + DIV + 4*LOG + MUL
477     >>> print(count_ops(h, visual=True))
478     2*LOG + MUL + POW + SUB
479 
480     >>> from sympy import Symbol, S
481     >>> def my_measure(expr):
482     ...     POW = Symbol('POW')
483     ...     # Discourage powers by giving POW a weight of 10
484     ...     count = count_ops(expr, visual=True).subs(POW, 10)
485     ...     # Every other operation gets a weight of 1 (the default)
486     ...     count = count.replace(Symbol, type(S.One))
487     ...     return count
488     >>> my_measure(g)
489     8
490     >>> my_measure(h)
491     14
492     >>> 15./8 > 1.7 # 1.7 is the default ratio
493     True
494     >>> simplify(g, measure=my_measure)
495     -log(a)*log(b) + log(a) + log(b)
496 
497     Note that because ``simplify()`` internally tries many different
498     simplification strategies and then compares them using the measure
499     function, we get a completely different result that is still different
500     from the input expression by doing this.
501 
502     If rational=True, Floats will be recast as Rationals before simplification.
503     If rational=None, Floats will be recast as Rationals but the result will
504     be recast as Floats. If rational=False(default) then nothing will be done
505     to the Floats.
506 
507     If inverse=True, it will be assumed that a composition of inverse
508     functions, such as sin and asin, can be cancelled in any order.
509     For example, ``asin(sin(x))`` will yield ``x`` without checking whether
510     x belongs to the set where this relation is true. The default is
511     False.
512 
513     Note that ``simplify()`` automatically calls ``doit()`` on the final
514     expression. You can avoid this behavior by passing ``doit=False`` as
515     an argument.
516     """
517     def done(e):
518         return e.doit() if doit else e
519 
520     expr = sympify(expr)
521     kwargs = dict(
522         ratio=kwargs.get('ratio', ratio),
523         measure=kwargs.get('measure', measure),
524         rational=kwargs.get('rational', rational),
525         inverse=kwargs.get('inverse', inverse),
526         doit=kwargs.get('doit', doit))
527     # no routine for Expr needs to check for is_zero
528     if isinstance(expr, Expr) and expr.is_zero and expr*0 is S.Zero:
529         return S.Zero
530 
531     _eval_simplify = getattr(expr, '_eval_simplify', None)
532     if _eval_simplify is not None:
533         return _eval_simplify(**kwargs)
534 
535     original_expr = expr = signsimp(expr)
536 
537     from sympy.simplify.hyperexpand import hyperexpand
538     from sympy.functions.special.bessel import BesselBase
539     from sympy import Sum, Product, Integral
540 
541     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
542         return expr
543 
544     if inverse and expr.has(Function):
545         expr = inversecombine(expr)
546         if not expr.args:  # simplified to atomic
547             return expr
548 
549     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
550         return done(
551             expr.func(*[simplify(x, **kwargs) for x in expr.args]))
552 
553     if not expr.is_commutative:
554         expr = nc_simplify(expr)
555 
556     # TODO: Apply different strategies, considering expression pattern:
557     # is it a purely rational function? Is there any trigonometric function?...
558     # See also https://github.com/sympy/sympy/pull/185.
559 
560     def shorter(*choices):
561         '''Return the choice that has the fewest ops. In case of a tie,
562         the expression listed first is selected.'''
563         if not has_variety(choices):
564             return choices[0]
565         return min(choices, key=measure)
566 
567     # rationalize Floats
568     floats = False
569     if rational is not False and expr.has(Float):
570         floats = True
571         expr = nsimplify(expr, rational=True)
572 
573     expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())
574     expr = Mul(*powsimp(expr).as_content_primitive())
575     _e = cancel(expr)
576     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
577     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
578 
579     if ratio is S.Infinity:
580         expr = expr2
581     else:
582         expr = shorter(expr2, expr1, expr)
583     if not isinstance(expr, Basic):  # XXX: temporary hack
584         return expr
585 
586     expr = factor_terms(expr, sign=False)
587 
588     # hyperexpand automatically only works on hypergeometric terms
589     expr = hyperexpand(expr)
590 
591     expr = piecewise_fold(expr)
592 
593     if expr.has(BesselBase):
594         expr = besselsimp(expr)
595 
596     if expr.has(TrigonometricFunction, HyperbolicFunction):
597         expr = trigsimp(expr, deep=True)
598 
599     if expr.has(log):
600         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
601 
602     if expr.has(CombinatorialFunction, gamma):
603         # expression with gamma functions or non-integer arguments is
604         # automatically passed to gammasimp
605         expr = combsimp(expr)
606 
607     if expr.has(Sum):
608         expr = sum_simplify(expr, **kwargs)
609 
610     if expr.has(Integral):
611         expr = expr.xreplace(dict([
612             (i, factor_terms(i)) for i in expr.atoms(Integral)]))
613 
614     if expr.has(Product):
615         expr = product_simplify(expr)
616 
617     from sympy.physics.units import Quantity
618     from sympy.physics.units.util import quantity_simplify
619 
620     if expr.has(Quantity):
621         expr = quantity_simplify(expr)
622 
623     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
624     short = shorter(short, cancel(short))
625     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
626     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
627         short = exptrigsimp(short)
628 
629     # get rid of hollow 2-arg Mul factorization
630     hollow_mul = Transform(
631         lambda x: Mul(*x.args),
632         lambda x:
633         x.is_Mul and
634         len(x.args) == 2 and
635         x.args[0].is_Number and
636         x.args[1].is_Add and
637         x.is_commutative)
638     expr = short.xreplace(hollow_mul)
639 
640     numer, denom = expr.as_numer_denom()
641     if denom.is_Add:
642         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
643         if n is not S.One:
644             expr = (numer*n).expand()/d
645 
646     if expr.could_extract_minus_sign():
647         n, d = fraction(expr)
648         if d != 0:
649             expr = signsimp(-n/(-d))
650 
651     if measure(expr) > ratio*measure(original_expr):
652         expr = original_expr
653 
654     # restore floats
655     if floats and rational is None:
656         expr = nfloat(expr, exponent=False)
657 
658     return done(expr)

</code><intended_behavior>The `simplify` method should include additional heuristics or checks to identify and simplify expressions involving the exponential function with imaginary arguments that can be simplified based on the periodicity. This might involve adding specific rules or enhancing current ones to more effectively utilize the properties of exponentials, thereby directly simplifying expressions that exhibit periodic behavior without requiring further intervention.</intended_behavior>]
2025-10-15 14:22:00.960 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 14:22:00.960 | INFO     | Search-only: skipping patch selection
2025-10-15 14:22:01.048 | INFO     | Task sympy__sympy-17251 completed successfully.
2025-10-15 14:22:01.049 | INFO     | No patch generated. You can try running ACR again.
