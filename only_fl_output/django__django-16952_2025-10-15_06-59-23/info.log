2025-10-15 06:59:23.986 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 06:59:27.581 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=730, output_tokens=13, cost=0.007690
2025-10-15 06:59:43.548 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=910, output_tokens=617, cost=0.027610
2025-10-15 06:59:44.726 | INFO     | registered non reproducing test 0
2025-10-15 07:00:01.639 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2069, output_tokens=651, cost=0.040220
2025-10-15 07:00:02.821 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:00:10.265 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1002, output_tokens=293, cost=0.018810
2025-10-15 07:00:10.273 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:00:13.151 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=647, output_tokens=79, cost=0.008840
2025-10-15 07:00:13.153 | DEBUG    | Extracted a valid json.
2025-10-15 07:00:13.153 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"ItalianRestaurantManyParents\", \"tests/model_inheritance/models.py\")",
        "search_method_in_file(\"create\", \"/django/django/db/models/query.py\")",
        "search_method_in_file(\"_save_parents\", \"/django/django/db/models/base.py\")"
    ],
    "bug_locations": []
}
2025-10-15 07:00:13.159 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:00:13.160 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:00:26.563 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1515, output_tokens=549, cost=0.031620
2025-10-15 07:00:26.577 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:00:36.786 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2280, output_tokens=430, cost=0.035700
2025-10-15 07:00:36.795 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:00:44.676 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=784, output_tokens=260, cost=0.015640
2025-10-15 07:00:44.677 | DEBUG    | Extracted a valid json.
2025-10-15 07:00:44.677 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class('save', 'Django model base class')",
        "search_method_in_class('_save_parents', 'Django model base class')",
        "search_method('ManyToManyField')",
        "search_code('MTI')"
    ],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "class": "Django model base class or a subclass handling MTI",
            "method": "_save_parents",
            "intended_behavior": "The intended behavior should ensure that during the saving of parent objects in an MTI hierarchy, all attributes, especially those related to `OneToOneField` (used implicitly for linking parent-child in MTI), are correctly handled. The `_save_parents` method should robustly check for the presence of attributes like `attname` on field objects and ensure that any unique attributes of relationship fields (like `OneToOneField`) are correctly referenced and saved without raising `AttributeError`. This might involve implementing additional checks or safeguards within the `_save_parents` method to handle scenarios where a field might not have a directly accessible `attname` attribute, or better handling of field types that are part of complex inheritance chains."
        }
    ]
}
2025-10-15 07:00:44.720 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:00:44.721 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:00:58.421 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3057, output_tokens=579, cost=0.047940
2025-10-15 07:00:58.433 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:01:12.542 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3852, output_tokens=544, cost=0.054840
2025-10-15 07:01:12.552 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:01:19.678 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=898, output_tokens=316, cost=0.018460
2025-10-15 07:01:19.679 | DEBUG    | Extracted a valid json.
2025-10-15 07:01:19.679 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "class": "The Django model base class or any subclass handling MTI",
            "method": "_save_parents",
            "intended_behavior": "This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "RelatedField or a subclass like `ForeignKey` or `OneToOneField`",
            "method": "",
            "intended_behavior": "Adjustment here could involve ensuring that during object creation and saving, all relationship fields, particularly those involved in MTI scenarios, correctly report their attributes and are fully compatible with how parent models are saved. This might include ensuring `attname` and other critical attributes are always accessible and correctly reflect the field's relationship in the database, especially in complex inheritance cases."
        }
    ]
}
2025-10-15 07:01:19.695 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/base.py</file>
<class>None</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 import warnings
4 from functools import partial
5 
6 from django import forms
7 from django.apps import apps
8 from django.conf import SettingsReference, settings
9 from django.core import checks, exceptions
10 from django.db import connection, router
11 from django.db.backends import utils
12 from django.db.models import Q
13 from django.db.models.constants import LOOKUP_SEP
14 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
15 from django.db.models.query_utils import PathInfo
16 from django.db.models.utils import make_model_tuple
17 from django.utils.deprecation import RemovedInDjango60Warning
18 from django.utils.functional import cached_property
19 from django.utils.translation import gettext_lazy as _
20 
21 from . import Field
22 from .mixins import FieldCacheMixin
23 from .related_descriptors import (
24     ForeignKeyDeferredAttribute,
25     ForwardManyToOneDescriptor,
26     ForwardOneToOneDescriptor,
27     ManyToManyDescriptor,
28     ReverseManyToOneDescriptor,
29     ReverseOneToOneDescriptor,
30 )
31 from .related_lookups import (
32     RelatedExact,
33     RelatedGreaterThan,
34     RelatedGreaterThanOrEqual,
35     RelatedIn,
36     RelatedIsNull,
37     RelatedLessThan,
38     RelatedLessThanOrEqual,
39 )
40 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
41 
42 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
43 
44 
45 def resolve_relation(scope_model, relation):
46     """
47     Transform relation into a model or fully-qualified model string of the form
48     "app_label.ModelName", relative to scope_model.
49 
50     The relation argument can be:
51       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
52         the model argument will be returned.
53       * A bare model name without an app_label, in which case scope_model's
54         app_label will be prepended.
55       * An "app_label.ModelName" string.
56       * A model class, which will be returned unchanged.
57     """
58     # Check for recursive relations
59     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
60         relation = scope_model
61 
62     # Look for an "app.Model" relation
63     if isinstance(relation, str):
64         if "." not in relation:
65             relation = "%s.%s" % (scope_model._meta.app_label, relation)
66 
67     return relation
68 
69 
70 def lazy_related_operation(function, model, *related_models, **kwargs):
71     """
72     Schedule `function` to be called once `model` and all `related_models`
73     have been imported and registered with the app registry. `function` will
74     be called with the newly-loaded model classes as its positional arguments,
75     plus any optional keyword arguments.
76 
77     The `model` argument must be a model class. Each subsequent positional
78     argument is another model, or a reference to another model - see
79     `resolve_relation()` for the various forms these may take. Any relative
80     references will be resolved relative to `model`.
81 
82     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
83     registry model used is the one found in `model._meta.apps`.
84     """
85     models = [model] + [resolve_relation(model, rel) for rel in related_models]
86     model_keys = (make_model_tuple(m) for m in models)
87     apps = model._meta.apps
88     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
89 
90 
91 class RelatedField(FieldCacheMixin, Field):
92     """Base class that all relational fields inherit from."""
93 
94     # Field flags
95     one_to_many = False
96     one_to_one = False
97     many_to_many = False
98     many_to_one = False
99 
100     def __init__(
101         self,
102         related_name=None,
103         related_query_name=None,
104         limit_choices_to=None,
105         **kwargs,
106     ):
107         self._related_name = related_name
108         self._related_query_name = related_query_name
109         self._limit_choices_to = limit_choices_to
110         super().__init__(**kwargs)
111 
112     @cached_property
113     def related_model(self):
114         # Can't cache this property until all the models are loaded.
115         apps.check_models_ready()
116         return self.remote_field.model
117 
118     def check(self, **kwargs):
119         return [
120             *super().check(**kwargs),
121             *self._check_related_name_is_valid(),
122             *self._check_related_query_name_is_valid(),
123             *self._check_relation_model_exists(),
124             *self._check_referencing_to_swapped_model(),
125             *self._check_clashes(),
126         ]
127 
128     def _check_related_name_is_valid(self):
129         import keyword
130 
131         related_name = self.remote_field.related_name
132         if related_name is None:
133             return []
134         is_valid_id = (
135             not keyword.iskeyword(related_name) and related_name.isidentifier()
136         )
137         if not (is_valid_id or related_name.endswith("+")):
138             return [
139                 checks.Error(
140                     "The name '%s' is invalid related_name for field %s.%s"
141                     % (
142                         self.remote_field.related_name,
143                         self.model._meta.object_name,
144                         self.name,
145                     ),
146                     hint=(
147                         "Related name must be a valid Python identifier or end with a "
148                         "'+'"
149                     ),
150                     obj=self,
151                     id="fields.E306",
152                 )
153             ]
154         return []
155 
156     def _check_related_query_name_is_valid(self):
157         if self.remote_field.is_hidden():
158             return []
159         rel_query_name = self.related_query_name()
160         errors = []
161         if rel_query_name.endswith("_"):
162             errors.append(
163                 checks.Error(
164                     "Reverse query name '%s' must not end with an underscore."
165                     % rel_query_name,
166                     hint=(
167                         "Add or change a related_name or related_query_name "
168                         "argument for this field."
169                     ),
170                     obj=self,
171                     id="fields.E308",
172                 )
173             )
174         if LOOKUP_SEP in rel_query_name:
175             errors.append(
176                 checks.Error(
177                     "Reverse query name '%s' must not contain '%s'."
178                     % (rel_query_name, LOOKUP_SEP),
179                     hint=(
180                         "Add or change a related_name or related_query_name "
181                         "argument for this field."
182                     ),
183                     obj=self,
184                     id="fields.E309",
185                 )
186             )
187         return errors
188 
189     def _check_relation_model_exists(self):
190         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
191         rel_is_string = isinstance(self.remote_field.model, str)
192         model_name = (
193             self.remote_field.model
194             if rel_is_string
195             else self.remote_field.model._meta.object_name
196         )
197         if rel_is_missing and (
198             rel_is_string or not self.remote_field.model._meta.swapped
199         ):
200             return [
201                 checks.Error(
202                     "Field defines a relation with model '%s', which is either "
203                     "not installed, or is abstract." % model_name,
204                     obj=self,
205                     id="fields.E300",
206                 )
207             ]
208         return []
209 
210     def _check_referencing_to_swapped_model(self):
211         if (
212             self.remote_field.model not in self.opts.apps.get_models()
213             and not isinstance(self.remote_field.model, str)
214             and self.remote_field.model._meta.swapped
215         ):
216             return [
217                 checks.Error(
218                     "Field defines a relation with the model '%s', which has "
219                     "been swapped out." % self.remote_field.model._meta.label,
220                     hint="Update the relation to point at 'settings.%s'."
221                     % self.remote_field.model._meta.swappable,
222                     obj=self,
223                     id="fields.E301",
224                 )
225             ]
226         return []
227 
228     def _check_clashes(self):
229         """Check accessor and reverse query name clashes."""
230         from django.db.models.base import ModelBase
231 
232         errors = []
233         opts = self.model._meta
234 
235         # f.remote_field.model may be a string instead of a model. Skip if
236         # model name is not resolved.
237         if not isinstance(self.remote_field.model, ModelBase):
238             return []
239 
240         # Consider that we are checking field `Model.foreign` and the models
241         # are:
242         #
243         #     class Target(models.Model):
244         #         model = models.IntegerField()
245         #         model_set = models.IntegerField()
246         #
247         #     class Model(models.Model):
248         #         foreign = models.ForeignKey(Target)
249         #         m2m = models.ManyToManyField(Target)
250 
251         # rel_opts.object_name == "Target"
252         rel_opts = self.remote_field.model._meta
253         # If the field doesn't install a backward relation on the target model
254         # (so `is_hidden` returns True), then there are no clashes to check
255         # and we can skip these fields.
256         rel_is_hidden = self.remote_field.is_hidden()
257         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
258         rel_query_name = self.related_query_name()  # i. e. "model"
259         # i.e. "app_label.Model.field".
260         field_name = "%s.%s" % (opts.label, self.name)
261 
262         # Check clashes between accessor or reverse query name of `field`
263         # and any other field name -- i.e. accessor for Model.foreign is
264         # model_set and it clashes with Target.model_set.
265         potential_clashes = rel_opts.fields + rel_opts.many_to_many
266         for clash_field in potential_clashes:
267             # i.e. "app_label.Target.model_set".
268             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
269             if not rel_is_hidden and clash_field.name == rel_name:
270                 errors.append(
271                     checks.Error(
272                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
273                         f"for '{field_name}' clashes with field name "
274                         f"'{clash_name}'.",
275                         hint=(
276                             "Rename field '%s', or add/change a related_name "
277                             "argument to the definition for field '%s'."
278                         )
279                         % (clash_name, field_name),
280                         obj=self,
281                         id="fields.E302",
282                     )
283                 )
284 
285             if clash_field.name == rel_query_name:
286                 errors.append(
287                     checks.Error(
288                         "Reverse query name for '%s' clashes with field name '%s'."
289                         % (field_name, clash_name),
290                         hint=(
291                             "Rename field '%s', or add/change a related_name "
292                             "argument to the definition for field '%s'."
293                         )
294                         % (clash_name, field_name),
295                         obj=self,
296                         id="fields.E303",
297                     )
298                 )
299 
300         # Check clashes between accessors/reverse query names of `field` and
301         # any other field accessor -- i. e. Model.foreign accessor clashes with
302         # Model.m2m accessor.
303         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
304         for clash_field in potential_clashes:
305             # i.e. "app_label.Model.m2m".
306             clash_name = "%s.%s" % (
307                 clash_field.related_model._meta.label,
308                 clash_field.field.name,
309             )
310             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
311                 errors.append(
312                     checks.Error(
313                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
314                         f"for '{field_name}' clashes with reverse accessor for "
315                         f"'{clash_name}'.",
316                         hint=(
317                             "Add or change a related_name argument "
318                             "to the definition for '%s' or '%s'."
319                         )
320                         % (field_name, clash_name),
321                         obj=self,
322                         id="fields.E304",
323                     )
324                 )
325 
326             if clash_field.get_accessor_name() == rel_query_name:
327                 errors.append(
328                     checks.Error(
329                         "Reverse query name for '%s' clashes with reverse query name "
330                         "for '%s'." % (field_name, clash_name),
331                         hint=(
332                             "Add or change a related_name argument "
333                             "to the definition for '%s' or '%s'."
334                         )
335                         % (field_name, clash_name),
336                         obj=self,
337                         id="fields.E305",
338                     )
339                 )
340 
341         return errors
342 
343     def db_type(self, connection):
344         # By default related field will not have a column as it relates to
345         # columns from another table.
346         return None
347 
348     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
349         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
350 
351         self.opts = cls._meta
352 
353         if not cls._meta.abstract:
354             if self.remote_field.related_name:
355                 related_name = self.remote_field.related_name
356             else:
357                 related_name = self.opts.default_related_name
358             if related_name:
359                 related_name %= {
360                     "class": cls.__name__.lower(),
361                     "model_name": cls._meta.model_name.lower(),
362                     "app_label": cls._meta.app_label.lower(),
363                 }
364                 self.remote_field.related_name = related_name
365 
366             if self.remote_field.related_query_name:
367                 related_query_name = self.remote_field.related_query_name % {
368                     "class": cls.__name__.lower(),
369                     "app_label": cls._meta.app_label.lower(),
370                 }
371                 self.remote_field.related_query_name = related_query_name
372 
373             def resolve_related_class(model, related, field):
374                 field.remote_field.model = related
375                 field.do_related_class(related, model)
376 
377             lazy_related_operation(
378                 resolve_related_class, cls, self.remote_field.model, field=self
379             )
380 
381     def deconstruct(self):
382         name, path, args, kwargs = super().deconstruct()
383         if self._limit_choices_to:
384             kwargs["limit_choices_to"] = self._limit_choices_to
385         if self._related_name is not None:
386             kwargs["related_name"] = self._related_name
387         if self._related_query_name is not None:
388             kwargs["related_query_name"] = self._related_query_name
389         return name, path, args, kwargs
390 
391     def get_forward_related_filter(self, obj):
392         """
393         Return the keyword arguments that when supplied to
394         self.model.object.filter(), would select all instances related through
395         this field to the remote obj. This is used to build the querysets
396         returned by related descriptors. obj is an instance of
397         self.related_field.model.
398         """
399         return {
400             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
401             for _, rh_field in self.related_fields
402         }
403 
404     def get_reverse_related_filter(self, obj):
405         """
406         Complement to get_forward_related_filter(). Return the keyword
407         arguments that when passed to self.related_field.model.object.filter()
408         select all instances of self.related_field.model related through
409         this field to obj. obj is an instance of self.model.
410         """
411         base_q = Q.create(
412             [
413                 (rh_field.attname, getattr(obj, lh_field.attname))
414                 for lh_field, rh_field in self.related_fields
415             ]
416         )
417         descriptor_filter = self.get_extra_descriptor_filter(obj)
418         if isinstance(descriptor_filter, dict):
419             return base_q & Q(**descriptor_filter)
420         elif descriptor_filter:
421             return base_q & descriptor_filter
422         return base_q
423 
424     @property
425     def swappable_setting(self):
426         """
427         Get the setting that this is powered from for swapping, or None
428         if it's not swapped in / marked with swappable=False.
429         """
430         if self.swappable:
431             # Work out string form of "to"
432             if isinstance(self.remote_field.model, str):
433                 to_string = self.remote_field.model
434             else:
435                 to_string = self.remote_field.model._meta.label
436             return apps.get_swappable_settings_name(to_string)
437         return None
438 
439     def set_attributes_from_rel(self):
440         self.name = self.name or (
441             self.remote_field.model._meta.model_name
442             + "_"
443             + self.remote_field.model._meta.pk.name
444         )
445         if self.verbose_name is None:
446             self.verbose_name = self.remote_field.model._meta.verbose_name
447         self.remote_field.set_field_name()
448 
449     def do_related_class(self, other, cls):
450         self.set_attributes_from_rel()
451         self.contribute_to_related_class(other, self.remote_field)
452 
453     def get_limit_choices_to(self):
454         """
455         Return ``limit_choices_to`` for this model field.
456 
457         If it is a callable, it will be invoked and the result will be
458         returned.
459         """
460         if callable(self.remote_field.limit_choices_to):
461             return self.remote_field.limit_choices_to()
462         return self.remote_field.limit_choices_to
463 
464     def formfield(self, **kwargs):
465         """
466         Pass ``limit_choices_to`` to the field being constructed.
467 
468         Only passes it if there is a type that supports related fields.
469         This is a similar strategy used to pass the ``queryset`` to the field
470         being constructed.
471         """
472         defaults = {}
473         if hasattr(self.remote_field, "get_related_field"):
474             # If this is a callable, do not invoke it here. Just pass
475             # it in the defaults for when the form class will later be
476             # instantiated.
477             limit_choices_to = self.remote_field.limit_choices_to
478             defaults.update(
479                 {
480                     "limit_choices_to": limit_choices_to,
481                 }
482             )
483         defaults.update(kwargs)
484         return super().formfield(**defaults)
485 
486     def related_query_name(self):
487         """
488         Define the name that can be used to identify this related object in a
489         table-spanning query.
490         """
491         return (
492             self.remote_field.related_query_name
493             or self.remote_field.related_name
494             or self.opts.model_name
495         )
496 
497     @property
498     def target_field(self):
499         """
500         When filtering against this relation, return the field on the remote
501         model against which the filtering should happen.
502         """
503         target_fields = self.path_infos[-1].target_fields
504         if len(target_fields) > 1:
505             raise exceptions.FieldError(
506                 "The relation has multiple target fields, but only single target field "
507                 "was asked for"
508             )
509         return target_fields[0]
510 
511     def get_cache_name(self):
512         return self.name
513 
514 
515 class ForeignObject(RelatedField):
516     """
517     Abstraction of the ForeignKey relation to support multi-column relations.
518     """
519 
520     # Field flags
521     many_to_many = False
522     many_to_one = True
523     one_to_many = False
524     one_to_one = False
525 
526     requires_unique_target = True
527     related_accessor_class = ReverseManyToOneDescriptor
528     forward_related_accessor_class = ForwardManyToOneDescriptor
529     rel_class = ForeignObjectRel
530 
531     def __init__(
532         self,
533         to,
534         on_delete,
535         from_fields,
536         to_fields,
537         rel=None,
538         related_name=None,
539         related_query_name=None,
540         limit_choices_to=None,
541         parent_link=False,
542         swappable=True,
543         **kwargs,
544     ):
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         warnings.warn(
783             "ForeignObject.get_joining_columns() is deprecated. Use "
784             "get_joining_fields() instead.",
785             RemovedInDjango60Warning,
786         )
787         source = self.reverse_related_fields if reverse_join else self.related_fields
788         return tuple(
789             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
790         )
791 
792     def get_reverse_joining_columns(self):
793         warnings.warn(
794             "ForeignObject.get_reverse_joining_columns() is deprecated. Use "
795             "get_reverse_joining_fields() instead.",
796             RemovedInDjango60Warning,
797         )
798         return self.get_joining_columns(reverse_join=True)
799 
800     def get_joining_fields(self, reverse_join=False):
801         return tuple(
802             self.reverse_related_fields if reverse_join else self.related_fields
803         )
804 
805     def get_reverse_joining_fields(self):
806         return self.get_joining_fields(reverse_join=True)
807 
808     def get_extra_descriptor_filter(self, instance):
809         """
810         Return an extra filter condition for related object fetching when
811         user does 'instance.fieldname', that is the extra filter is used in
812         the descriptor of the field.
813 
814         The filter should be either a dict usable in .filter(**kwargs) call or
815         a Q-object. The condition will be ANDed together with the relation's
816         joining columns.
817 
818         A parallel method is get_extra_restriction() which is used in
819         JOIN and subquery conditions.
820         """
821         return {}
822 
823     def get_extra_restriction(self, alias, related_alias):
824         """
825         Return a pair condition used for joining and subquery pushdown. The
826         condition is something that responds to as_sql(compiler, connection)
827         method.
828 
829         Note that currently referring both the 'alias' and 'related_alias'
830         will not work in some conditions, like subquery pushdown.
831 
832         A parallel method is get_extra_descriptor_filter() which is used in
833         instance.fieldname related object fetching.
834         """
835         return None
836 
837     def get_path_info(self, filtered_relation=None):
838         """Get path from this field to the related model."""
839         opts = self.remote_field.model._meta
840         from_opts = self.model._meta
841         return [
842             PathInfo(
843                 from_opts=from_opts,
844                 to_opts=opts,
845                 target_fields=self.foreign_related_fields,
846                 join_field=self,
847                 m2m=False,
848                 direct=True,
849                 filtered_relation=filtered_relation,
850             )
851         ]
852 
853     @cached_property
854     def path_infos(self):
855         return self.get_path_info()
856 
857     def get_reverse_path_info(self, filtered_relation=None):
858         """Get path from the related model to this field's model."""
859         opts = self.model._meta
860         from_opts = self.remote_field.model._meta
861         return [
862             PathInfo(
863                 from_opts=from_opts,
864                 to_opts=opts,
865                 target_fields=(opts.pk,),
866                 join_field=self.remote_field,
867                 m2m=not self.unique,
868                 direct=False,
869                 filtered_relation=filtered_relation,
870             )
871         ]
872 
873     @cached_property
874     def reverse_path_infos(self):
875         return self.get_reverse_path_info()
876 
877     @classmethod
878     @functools.cache
879     def get_class_lookups(cls):
880         bases = inspect.getmro(cls)
881         bases = bases[: bases.index(ForeignObject) + 1]
882         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
883         return cls.merge_dicts(class_lookups)
884 
885     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
886         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
887         setattr(cls, self.name, self.forward_related_accessor_class(self))
888 
889     def contribute_to_related_class(self, cls, related):
890         # Internal FK's - i.e., those with a related name ending with '+' -
891         # and swapped models don't get a related descriptor.
892         if (
893             not self.remote_field.is_hidden()
894             and not related.related_model._meta.swapped
895         ):
896             setattr(
897                 cls._meta.concrete_model,
898                 related.get_accessor_name(),
899                 self.related_accessor_class(related),
900             )
901             # While 'limit_choices_to' might be a callable, simply pass
902             # it along for later - this is too early because it's still
903             # model load time.
904             if self.remote_field.limit_choices_to:
905                 cls._meta.related_fkey_lookups.append(
906                     self.remote_field.limit_choices_to
907                 )
908 
909 
910 ForeignObject.register_lookup(RelatedIn)
911 ForeignObject.register_lookup(RelatedExact)
912 ForeignObject.register_lookup(RelatedLessThan)
913 ForeignObject.register_lookup(RelatedGreaterThan)
914 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
915 ForeignObject.register_lookup(RelatedLessThanOrEqual)
916 ForeignObject.register_lookup(RelatedIsNull)
917 
918 
919 class ForeignKey(ForeignObject):
920     """
921     Provide a many-to-one relation by adding a column to the local model
922     to hold the remote value.
923 
924     By default ForeignKey will target the pk of the remote model but this
925     behavior can be changed by using the ``to_field`` argument.
926     """
927 
928     descriptor_class = ForeignKeyDeferredAttribute
929     # Field flags
930     many_to_many = False
931     many_to_one = True
932     one_to_many = False
933     one_to_one = False
934 
935     rel_class = ManyToOneRel
936 
937     empty_strings_allowed = False
938     default_error_messages = {
939         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
940     }
941     description = _("Foreign Key (type determined by related field)")
942 
943     def __init__(
944         self,
945         to,
946         on_delete,
947         related_name=None,
948         related_query_name=None,
949         limit_choices_to=None,
950         parent_link=False,
951         to_field=None,
952         db_constraint=True,
953         **kwargs,
954     ):
955         try:
956             to._meta.model_name
957         except AttributeError:
958             if not isinstance(to, str):
959                 raise TypeError(
960                     "%s(%r) is invalid. First parameter to ForeignKey must be "
961                     "either a model, a model name, or the string %r"
962                     % (
963                         self.__class__.__name__,
964                         to,
965                         RECURSIVE_RELATIONSHIP_CONSTANT,
966                     )
967                 )
968         else:
969             # For backwards compatibility purposes, we need to *try* and set
970             # the to_field during FK construction. It won't be guaranteed to
971             # be correct until contribute_to_class is called. Refs #12190.
972             to_field = to_field or (to._meta.pk and to._meta.pk.name)
973         if not callable(on_delete):
974             raise TypeError("on_delete must be callable.")
975 
976         kwargs["rel"] = self.rel_class(
977             self,
978             to,
979             to_field,
980             related_name=related_name,
981             related_query_name=related_query_name,
982             limit_choices_to=limit_choices_to,
983             parent_link=parent_link,
984             on_delete=on_delete,
985         )
986         kwargs.setdefault("db_index", True)
987 
988         super().__init__(
989             to,
990             on_delete,
991             related_name=related_name,
992             related_query_name=related_query_name,
993             limit_choices_to=limit_choices_to,
994             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
995             to_fields=[to_field],
996             **kwargs,
997         )
998         self.db_constraint = db_constraint
999 
1000     def __class_getitem__(cls, *args, **kwargs):
1001         return cls
1002 
1003     def check(self, **kwargs):
1004         return [
1005             *super().check(**kwargs),
1006             *self._check_on_delete(),
1007             *self._check_unique(),
1008         ]
1009 
1010     def _check_on_delete(self):
1011         on_delete = getattr(self.remote_field, "on_delete", None)
1012         if on_delete == SET_NULL and not self.null:
1013             return [
1014                 checks.Error(
1015                     "Field specifies on_delete=SET_NULL, but cannot be null.",
1016                     hint=(
1017                         "Set null=True argument on the field, or change the on_delete "
1018                         "rule."
1019                     ),
1020                     obj=self,
1021                     id="fields.E320",
1022                 )
1023             ]
1024         elif on_delete == SET_DEFAULT and not self.has_default():
1025             return [
1026                 checks.Error(
1027                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1028                     hint="Set a default value, or change the on_delete rule.",
1029                     obj=self,
1030                     id="fields.E321",
1031                 )
1032             ]
1033         else:
1034             return []
1035 
1036     def _check_unique(self, **kwargs):
1037         return (
1038             [
1039                 checks.Warning(
1040                     "Setting unique=True on a ForeignKey has the same effect as using "
1041                     "a OneToOneField.",
1042                     hint=(
1043                         "ForeignKey(unique=True) is usually better served by a "
1044                         "OneToOneField."
1045                     ),
1046                     obj=self,
1047                     id="fields.W342",
1048                 )
1049             ]
1050             if self.unique
1051             else []
1052         )
1053 
1054     def deconstruct(self):
1055         name, path, args, kwargs = super().deconstruct()
1056         del kwargs["to_fields"]
1057         del kwargs["from_fields"]
1058         # Handle the simpler arguments
1059         if self.db_index:
1060             del kwargs["db_index"]
1061         else:
1062             kwargs["db_index"] = False
1063         if self.db_constraint is not True:
1064             kwargs["db_constraint"] = self.db_constraint
1065         # Rel needs more work.
1066         to_meta = getattr(self.remote_field.model, "_meta", None)
1067         if self.remote_field.field_name and (
1068             not to_meta
1069             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1070         ):
1071             kwargs["to_field"] = self.remote_field.field_name
1072         return name, path, args, kwargs
1073 
1074     def to_python(self, value):
1075         return self.target_field.to_python(value)
1076 
1077     @property
1078     def target_field(self):
1079         return self.foreign_related_fields[0]
1080 
1081     def validate(self, value, model_instance):
1082         if self.remote_field.parent_link:
1083             return
1084         super().validate(value, model_instance)
1085         if value is None:
1086             return
1087 
1088         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1089         qs = self.remote_field.model._base_manager.using(using).filter(
1090             **{self.remote_field.field_name: value}
1091         )
1092         qs = qs.complex_filter(self.get_limit_choices_to())
1093         if not qs.exists():
1094             raise exceptions.ValidationError(
1095                 self.error_messages["invalid"],
1096                 code="invalid",
1097                 params={
1098                     "model": self.remote_field.model._meta.verbose_name,
1099                     "pk": value,
1100                     "field": self.remote_field.field_name,
1101                     "value": value,
1102                 },  # 'pk' is included for backwards compatibility
1103             )
1104 
1105     def resolve_related_fields(self):
1106         related_fields = super().resolve_related_fields()
1107         for from_field, to_field in related_fields:
1108             if (
1109                 to_field
1110                 and to_field.model != self.remote_field.model._meta.concrete_model
1111             ):
1112                 raise exceptions.FieldError(
1113                     "'%s.%s' refers to field '%s' which is not local to model "
1114                     "'%s'."
1115                     % (
1116                         self.model._meta.label,
1117                         self.name,
1118                         to_field.name,
1119                         self.remote_field.model._meta.concrete_model._meta.label,
1120                     )
1121                 )
1122         return related_fields
1123 
1124     def get_attname(self):
1125         return "%s_id" % self.name
1126 
1127     def get_attname_column(self):
1128         attname = self.get_attname()
1129         column = self.db_column or attname
1130         return attname, column
1131 
1132     def get_default(self):
1133         """Return the to_field if the default value is an object."""
1134         field_default = super().get_default()
1135         if isinstance(field_default, self.remote_field.model):
1136             return getattr(field_default, self.target_field.attname)
1137         return field_default
1138 
1139     def get_db_prep_save(self, value, connection):
1140         if value is None or (
1141             value == ""
1142             and (
1143                 not self.target_field.empty_strings_allowed
1144                 or connection.features.interprets_empty_strings_as_nulls
1145             )
1146         ):
1147             return None
1148         else:
1149             return self.target_field.get_db_prep_save(value, connection=connection)
1150 
1151     def get_db_prep_value(self, value, connection, prepared=False):
1152         return self.target_field.get_db_prep_value(value, connection, prepared)
1153 
1154     def get_prep_value(self, value):
1155         return self.target_field.get_prep_value(value)
1156 
1157     def contribute_to_related_class(self, cls, related):
1158         super().contribute_to_related_class(cls, related)
1159         if self.remote_field.field_name is None:
1160             self.remote_field.field_name = cls._meta.pk.name
1161 
1162     def formfield(self, *, using=None, **kwargs):
1163         if isinstance(self.remote_field.model, str):
1164             raise ValueError(
1165                 "Cannot create form field for %r yet, because "
1166                 "its related model %r has not been loaded yet"
1167                 % (self.name, self.remote_field.model)
1168             )
1169         return super().formfield(
1170             **{
1171                 "form_class": forms.ModelChoiceField,
1172                 "queryset": self.remote_field.model._default_manager.using(using),
1173                 "to_field_name": self.remote_field.field_name,
1174                 **kwargs,
1175                 "blank": self.blank,
1176             }
1177         )
1178 
1179     def db_check(self, connection):
1180         return None
1181 
1182     def db_type(self, connection):
1183         return self.target_field.rel_db_type(connection=connection)
1184 
1185     def cast_db_type(self, connection):
1186         return self.target_field.cast_db_type(connection=connection)
1187 
1188     def db_parameters(self, connection):
1189         target_db_parameters = self.target_field.db_parameters(connection)
1190         return {
1191             "type": self.db_type(connection),
1192             "check": self.db_check(connection),
1193             "collation": target_db_parameters.get("collation"),
1194         }
1195 
1196     def convert_empty_strings(self, value, expression, connection):
1197         if (not value) and isinstance(value, str):
1198             return None
1199         return value
1200 
1201     def get_db_converters(self, connection):
1202         converters = super().get_db_converters(connection)
1203         if connection.features.interprets_empty_strings_as_nulls:
1204             converters += [self.convert_empty_strings]
1205         return converters
1206 
1207     def get_col(self, alias, output_field=None):
1208         if output_field is None:
1209             output_field = self.target_field
1210             while isinstance(output_field, ForeignKey):
1211                 output_field = output_field.target_field
1212                 if output_field is self:
1213                     raise ValueError("Cannot resolve output_field.")
1214         return super().get_col(alias, output_field)
1215 
1216 
1217 class OneToOneField(ForeignKey):
1218     """
1219     A OneToOneField is essentially the same as a ForeignKey, with the exception
1220     that it always carries a "unique" constraint with it and the reverse
1221     relation always returns the object pointed to (since there will only ever
1222     be one), rather than returning a list.
1223     """
1224 
1225     # Field flags
1226     many_to_many = False
1227     many_to_one = False
1228     one_to_many = False
1229     one_to_one = True
1230 
1231     related_accessor_class = ReverseOneToOneDescriptor
1232     forward_related_accessor_class = ForwardOneToOneDescriptor
1233     rel_class = OneToOneRel
1234 
1235     description = _("One-to-one relationship")
1236 
1237     def __init__(self, to, on_delete, to_field=None, **kwargs):
1238         kwargs["unique"] = True
1239         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1240 
1241     def deconstruct(self):
1242         name, path, args, kwargs = super().deconstruct()
1243         if "unique" in kwargs:
1244             del kwargs["unique"]
1245         return name, path, args, kwargs
1246 
1247     def formfield(self, **kwargs):
1248         if self.remote_field.parent_link:
1249             return None
1250         return super().formfield(**kwargs)
1251 
1252     def save_form_data(self, instance, data):
1253         if isinstance(data, self.remote_field.model):
1254             setattr(instance, self.name, data)
1255         else:
1256             setattr(instance, self.attname, data)
1257             # Remote field object must be cleared otherwise Model.save()
1258             # will reassign attname using the related object pk.
1259             if data is None:
1260                 setattr(instance, self.name, data)
1261 
1262     def _check_unique(self, **kwargs):
1263         # Override ForeignKey since check isn't applicable here.
1264         return []
1265 
1266 
1267 def create_many_to_many_intermediary_model(field, klass):
1268     from django.db import models
1269 
1270     def set_managed(model, related, through):
1271         through._meta.managed = model._meta.managed or related._meta.managed
1272 
1273     to_model = resolve_relation(klass, field.remote_field.model)
1274     name = "%s_%s" % (klass._meta.object_name, field.name)
1275     lazy_related_operation(set_managed, klass, to_model, name)
1276 
1277     to = make_model_tuple(to_model)[1]
1278     from_ = klass._meta.model_name
1279     if to == from_:
1280         to = "to_%s" % to
1281         from_ = "from_%s" % from_
1282 
1283     meta = type(
1284         "Meta",
1285         (),
1286         {
1287             "db_table": field._get_m2m_db_table(klass._meta),
1288             "auto_created": klass,
1289             "app_label": klass._meta.app_label,
1290             "db_tablespace": klass._meta.db_tablespace,
1291             "unique_together": (from_, to),
1292             "verbose_name": _("%(from)s-%(to)s relationship")
1293             % {"from": from_, "to": to},
1294             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1295             % {"from": from_, "to": to},
1296             "apps": field.model._meta.apps,
1297         },
1298     )
1299     # Construct and return the new class.
1300     return type(
1301         name,
1302         (models.Model,),
1303         {
1304             "Meta": meta,
1305             "__module__": klass.__module__,
1306             from_: models.ForeignKey(
1307                 klass,
1308                 related_name="%s+" % name,
1309                 db_tablespace=field.db_tablespace,
1310                 db_constraint=field.remote_field.db_constraint,
1311                 on_delete=CASCADE,
1312             ),
1313             to: models.ForeignKey(
1314                 to_model,
1315                 related_name="%s+" % name,
1316                 db_tablespace=field.db_tablespace,
1317                 db_constraint=field.remote_field.db_constraint,
1318                 on_delete=CASCADE,
1319             ),
1320         },
1321     )
1322 
1323 
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>Adjustment here could involve ensuring that during object creation and saving, all relationship fields, particularly those involved in MTI scenarios, correctly report their attributes and are fully compatible with how parent models are saved. This might include ensuring `attname` and other critical attributes are always accessible and correctly reflect the field's relationship in the database, especially in complex inheritance cases.</intended_behavior>]
2025-10-15 07:01:19.696 | INFO     | Search completed. Bug locations: [<file>django/db/models/base.py</file>
<class>None</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 import warnings
4 from functools import partial
5 
6 from django import forms
7 from django.apps import apps
8 from django.conf import SettingsReference, settings
9 from django.core import checks, exceptions
10 from django.db import connection, router
11 from django.db.backends import utils
12 from django.db.models import Q
13 from django.db.models.constants import LOOKUP_SEP
14 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
15 from django.db.models.query_utils import PathInfo
16 from django.db.models.utils import make_model_tuple
17 from django.utils.deprecation import RemovedInDjango60Warning
18 from django.utils.functional import cached_property
19 from django.utils.translation import gettext_lazy as _
20 
21 from . import Field
22 from .mixins import FieldCacheMixin
23 from .related_descriptors import (
24     ForeignKeyDeferredAttribute,
25     ForwardManyToOneDescriptor,
26     ForwardOneToOneDescriptor,
27     ManyToManyDescriptor,
28     ReverseManyToOneDescriptor,
29     ReverseOneToOneDescriptor,
30 )
31 from .related_lookups import (
32     RelatedExact,
33     RelatedGreaterThan,
34     RelatedGreaterThanOrEqual,
35     RelatedIn,
36     RelatedIsNull,
37     RelatedLessThan,
38     RelatedLessThanOrEqual,
39 )
40 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
41 
42 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
43 
44 
45 def resolve_relation(scope_model, relation):
46     """
47     Transform relation into a model or fully-qualified model string of the form
48     "app_label.ModelName", relative to scope_model.
49 
50     The relation argument can be:
51       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
52         the model argument will be returned.
53       * A bare model name without an app_label, in which case scope_model's
54         app_label will be prepended.
55       * An "app_label.ModelName" string.
56       * A model class, which will be returned unchanged.
57     """
58     # Check for recursive relations
59     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
60         relation = scope_model
61 
62     # Look for an "app.Model" relation
63     if isinstance(relation, str):
64         if "." not in relation:
65             relation = "%s.%s" % (scope_model._meta.app_label, relation)
66 
67     return relation
68 
69 
70 def lazy_related_operation(function, model, *related_models, **kwargs):
71     """
72     Schedule `function` to be called once `model` and all `related_models`
73     have been imported and registered with the app registry. `function` will
74     be called with the newly-loaded model classes as its positional arguments,
75     plus any optional keyword arguments.
76 
77     The `model` argument must be a model class. Each subsequent positional
78     argument is another model, or a reference to another model - see
79     `resolve_relation()` for the various forms these may take. Any relative
80     references will be resolved relative to `model`.
81 
82     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
83     registry model used is the one found in `model._meta.apps`.
84     """
85     models = [model] + [resolve_relation(model, rel) for rel in related_models]
86     model_keys = (make_model_tuple(m) for m in models)
87     apps = model._meta.apps
88     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
89 
90 
91 class RelatedField(FieldCacheMixin, Field):
92     """Base class that all relational fields inherit from."""
93 
94     # Field flags
95     one_to_many = False
96     one_to_one = False
97     many_to_many = False
98     many_to_one = False
99 
100     def __init__(
101         self,
102         related_name=None,
103         related_query_name=None,
104         limit_choices_to=None,
105         **kwargs,
106     ):
107         self._related_name = related_name
108         self._related_query_name = related_query_name
109         self._limit_choices_to = limit_choices_to
110         super().__init__(**kwargs)
111 
112     @cached_property
113     def related_model(self):
114         # Can't cache this property until all the models are loaded.
115         apps.check_models_ready()
116         return self.remote_field.model
117 
118     def check(self, **kwargs):
119         return [
120             *super().check(**kwargs),
121             *self._check_related_name_is_valid(),
122             *self._check_related_query_name_is_valid(),
123             *self._check_relation_model_exists(),
124             *self._check_referencing_to_swapped_model(),
125             *self._check_clashes(),
126         ]
127 
128     def _check_related_name_is_valid(self):
129         import keyword
130 
131         related_name = self.remote_field.related_name
132         if related_name is None:
133             return []
134         is_valid_id = (
135             not keyword.iskeyword(related_name) and related_name.isidentifier()
136         )
137         if not (is_valid_id or related_name.endswith("+")):
138             return [
139                 checks.Error(
140                     "The name '%s' is invalid related_name for field %s.%s"
141                     % (
142                         self.remote_field.related_name,
143                         self.model._meta.object_name,
144                         self.name,
145                     ),
146                     hint=(
147                         "Related name must be a valid Python identifier or end with a "
148                         "'+'"
149                     ),
150                     obj=self,
151                     id="fields.E306",
152                 )
153             ]
154         return []
155 
156     def _check_related_query_name_is_valid(self):
157         if self.remote_field.is_hidden():
158             return []
159         rel_query_name = self.related_query_name()
160         errors = []
161         if rel_query_name.endswith("_"):
162             errors.append(
163                 checks.Error(
164                     "Reverse query name '%s' must not end with an underscore."
165                     % rel_query_name,
166                     hint=(
167                         "Add or change a related_name or related_query_name "
168                         "argument for this field."
169                     ),
170                     obj=self,
171                     id="fields.E308",
172                 )
173             )
174         if LOOKUP_SEP in rel_query_name:
175             errors.append(
176                 checks.Error(
177                     "Reverse query name '%s' must not contain '%s'."
178                     % (rel_query_name, LOOKUP_SEP),
179                     hint=(
180                         "Add or change a related_name or related_query_name "
181                         "argument for this field."
182                     ),
183                     obj=self,
184                     id="fields.E309",
185                 )
186             )
187         return errors
188 
189     def _check_relation_model_exists(self):
190         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
191         rel_is_string = isinstance(self.remote_field.model, str)
192         model_name = (
193             self.remote_field.model
194             if rel_is_string
195             else self.remote_field.model._meta.object_name
196         )
197         if rel_is_missing and (
198             rel_is_string or not self.remote_field.model._meta.swapped
199         ):
200             return [
201                 checks.Error(
202                     "Field defines a relation with model '%s', which is either "
203                     "not installed, or is abstract." % model_name,
204                     obj=self,
205                     id="fields.E300",
206                 )
207             ]
208         return []
209 
210     def _check_referencing_to_swapped_model(self):
211         if (
212             self.remote_field.model not in self.opts.apps.get_models()
213             and not isinstance(self.remote_field.model, str)
214             and self.remote_field.model._meta.swapped
215         ):
216             return [
217                 checks.Error(
218                     "Field defines a relation with the model '%s', which has "
219                     "been swapped out." % self.remote_field.model._meta.label,
220                     hint="Update the relation to point at 'settings.%s'."
221                     % self.remote_field.model._meta.swappable,
222                     obj=self,
223                     id="fields.E301",
224                 )
225             ]
226         return []
227 
228     def _check_clashes(self):
229         """Check accessor and reverse query name clashes."""
230         from django.db.models.base import ModelBase
231 
232         errors = []
233         opts = self.model._meta
234 
235         # f.remote_field.model may be a string instead of a model. Skip if
236         # model name is not resolved.
237         if not isinstance(self.remote_field.model, ModelBase):
238             return []
239 
240         # Consider that we are checking field `Model.foreign` and the models
241         # are:
242         #
243         #     class Target(models.Model):
244         #         model = models.IntegerField()
245         #         model_set = models.IntegerField()
246         #
247         #     class Model(models.Model):
248         #         foreign = models.ForeignKey(Target)
249         #         m2m = models.ManyToManyField(Target)
250 
251         # rel_opts.object_name == "Target"
252         rel_opts = self.remote_field.model._meta
253         # If the field doesn't install a backward relation on the target model
254         # (so `is_hidden` returns True), then there are no clashes to check
255         # and we can skip these fields.
256         rel_is_hidden = self.remote_field.is_hidden()
257         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
258         rel_query_name = self.related_query_name()  # i. e. "model"
259         # i.e. "app_label.Model.field".
260         field_name = "%s.%s" % (opts.label, self.name)
261 
262         # Check clashes between accessor or reverse query name of `field`
263         # and any other field name -- i.e. accessor for Model.foreign is
264         # model_set and it clashes with Target.model_set.
265         potential_clashes = rel_opts.fields + rel_opts.many_to_many
266         for clash_field in potential_clashes:
267             # i.e. "app_label.Target.model_set".
268             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
269             if not rel_is_hidden and clash_field.name == rel_name:
270                 errors.append(
271                     checks.Error(
272                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
273                         f"for '{field_name}' clashes with field name "
274                         f"'{clash_name}'.",
275                         hint=(
276                             "Rename field '%s', or add/change a related_name "
277                             "argument to the definition for field '%s'."
278                         )
279                         % (clash_name, field_name),
280                         obj=self,
281                         id="fields.E302",
282                     )
283                 )
284 
285             if clash_field.name == rel_query_name:
286                 errors.append(
287                     checks.Error(
288                         "Reverse query name for '%s' clashes with field name '%s'."
289                         % (field_name, clash_name),
290                         hint=(
291                             "Rename field '%s', or add/change a related_name "
292                             "argument to the definition for field '%s'."
293                         )
294                         % (clash_name, field_name),
295                         obj=self,
296                         id="fields.E303",
297                     )
298                 )
299 
300         # Check clashes between accessors/reverse query names of `field` and
301         # any other field accessor -- i. e. Model.foreign accessor clashes with
302         # Model.m2m accessor.
303         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
304         for clash_field in potential_clashes:
305             # i.e. "app_label.Model.m2m".
306             clash_name = "%s.%s" % (
307                 clash_field.related_model._meta.label,
308                 clash_field.field.name,
309             )
310             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
311                 errors.append(
312                     checks.Error(
313                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
314                         f"for '{field_name}' clashes with reverse accessor for "
315                         f"'{clash_name}'.",
316                         hint=(
317                             "Add or change a related_name argument "
318                             "to the definition for '%s' or '%s'."
319                         )
320                         % (field_name, clash_name),
321                         obj=self,
322                         id="fields.E304",
323                     )
324                 )
325 
326             if clash_field.get_accessor_name() == rel_query_name:
327                 errors.append(
328                     checks.Error(
329                         "Reverse query name for '%s' clashes with reverse query name "
330                         "for '%s'." % (field_name, clash_name),
331                         hint=(
332                             "Add or change a related_name argument "
333                             "to the definition for '%s' or '%s'."
334                         )
335                         % (field_name, clash_name),
336                         obj=self,
337                         id="fields.E305",
338                     )
339                 )
340 
341         return errors
342 
343     def db_type(self, connection):
344         # By default related field will not have a column as it relates to
345         # columns from another table.
346         return None
347 
348     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
349         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
350 
351         self.opts = cls._meta
352 
353         if not cls._meta.abstract:
354             if self.remote_field.related_name:
355                 related_name = self.remote_field.related_name
356             else:
357                 related_name = self.opts.default_related_name
358             if related_name:
359                 related_name %= {
360                     "class": cls.__name__.lower(),
361                     "model_name": cls._meta.model_name.lower(),
362                     "app_label": cls._meta.app_label.lower(),
363                 }
364                 self.remote_field.related_name = related_name
365 
366             if self.remote_field.related_query_name:
367                 related_query_name = self.remote_field.related_query_name % {
368                     "class": cls.__name__.lower(),
369                     "app_label": cls._meta.app_label.lower(),
370                 }
371                 self.remote_field.related_query_name = related_query_name
372 
373             def resolve_related_class(model, related, field):
374                 field.remote_field.model = related
375                 field.do_related_class(related, model)
376 
377             lazy_related_operation(
378                 resolve_related_class, cls, self.remote_field.model, field=self
379             )
380 
381     def deconstruct(self):
382         name, path, args, kwargs = super().deconstruct()
383         if self._limit_choices_to:
384             kwargs["limit_choices_to"] = self._limit_choices_to
385         if self._related_name is not None:
386             kwargs["related_name"] = self._related_name
387         if self._related_query_name is not None:
388             kwargs["related_query_name"] = self._related_query_name
389         return name, path, args, kwargs
390 
391     def get_forward_related_filter(self, obj):
392         """
393         Return the keyword arguments that when supplied to
394         self.model.object.filter(), would select all instances related through
395         this field to the remote obj. This is used to build the querysets
396         returned by related descriptors. obj is an instance of
397         self.related_field.model.
398         """
399         return {
400             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
401             for _, rh_field in self.related_fields
402         }
403 
404     def get_reverse_related_filter(self, obj):
405         """
406         Complement to get_forward_related_filter(). Return the keyword
407         arguments that when passed to self.related_field.model.object.filter()
408         select all instances of self.related_field.model related through
409         this field to obj. obj is an instance of self.model.
410         """
411         base_q = Q.create(
412             [
413                 (rh_field.attname, getattr(obj, lh_field.attname))
414                 for lh_field, rh_field in self.related_fields
415             ]
416         )
417         descriptor_filter = self.get_extra_descriptor_filter(obj)
418         if isinstance(descriptor_filter, dict):
419             return base_q & Q(**descriptor_filter)
420         elif descriptor_filter:
421             return base_q & descriptor_filter
422         return base_q
423 
424     @property
425     def swappable_setting(self):
426         """
427         Get the setting that this is powered from for swapping, or None
428         if it's not swapped in / marked with swappable=False.
429         """
430         if self.swappable:
431             # Work out string form of "to"
432             if isinstance(self.remote_field.model, str):
433                 to_string = self.remote_field.model
434             else:
435                 to_string = self.remote_field.model._meta.label
436             return apps.get_swappable_settings_name(to_string)
437         return None
438 
439     def set_attributes_from_rel(self):
440         self.name = self.name or (
441             self.remote_field.model._meta.model_name
442             + "_"
443             + self.remote_field.model._meta.pk.name
444         )
445         if self.verbose_name is None:
446             self.verbose_name = self.remote_field.model._meta.verbose_name
447         self.remote_field.set_field_name()
448 
449     def do_related_class(self, other, cls):
450         self.set_attributes_from_rel()
451         self.contribute_to_related_class(other, self.remote_field)
452 
453     def get_limit_choices_to(self):
454         """
455         Return ``limit_choices_to`` for this model field.
456 
457         If it is a callable, it will be invoked and the result will be
458         returned.
459         """
460         if callable(self.remote_field.limit_choices_to):
461             return self.remote_field.limit_choices_to()
462         return self.remote_field.limit_choices_to
463 
464     def formfield(self, **kwargs):
465         """
466         Pass ``limit_choices_to`` to the field being constructed.
467 
468         Only passes it if there is a type that supports related fields.
469         This is a similar strategy used to pass the ``queryset`` to the field
470         being constructed.
471         """
472         defaults = {}
473         if hasattr(self.remote_field, "get_related_field"):
474             # If this is a callable, do not invoke it here. Just pass
475             # it in the defaults for when the form class will later be
476             # instantiated.
477             limit_choices_to = self.remote_field.limit_choices_to
478             defaults.update(
479                 {
480                     "limit_choices_to": limit_choices_to,
481                 }
482             )
483         defaults.update(kwargs)
484         return super().formfield(**defaults)
485 
486     def related_query_name(self):
487         """
488         Define the name that can be used to identify this related object in a
489         table-spanning query.
490         """
491         return (
492             self.remote_field.related_query_name
493             or self.remote_field.related_name
494             or self.opts.model_name
495         )
496 
497     @property
498     def target_field(self):
499         """
500         When filtering against this relation, return the field on the remote
501         model against which the filtering should happen.
502         """
503         target_fields = self.path_infos[-1].target_fields
504         if len(target_fields) > 1:
505             raise exceptions.FieldError(
506                 "The relation has multiple target fields, but only single target field "
507                 "was asked for"
508             )
509         return target_fields[0]
510 
511     def get_cache_name(self):
512         return self.name
513 
514 
515 class ForeignObject(RelatedField):
516     """
517     Abstraction of the ForeignKey relation to support multi-column relations.
518     """
519 
520     # Field flags
521     many_to_many = False
522     many_to_one = True
523     one_to_many = False
524     one_to_one = False
525 
526     requires_unique_target = True
527     related_accessor_class = ReverseManyToOneDescriptor
528     forward_related_accessor_class = ForwardManyToOneDescriptor
529     rel_class = ForeignObjectRel
530 
531     def __init__(
532         self,
533         to,
534         on_delete,
535         from_fields,
536         to_fields,
537         rel=None,
538         related_name=None,
539         related_query_name=None,
540         limit_choices_to=None,
541         parent_link=False,
542         swappable=True,
543         **kwargs,
544     ):
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         warnings.warn(
783             "ForeignObject.get_joining_columns() is deprecated. Use "
784             "get_joining_fields() instead.",
785             RemovedInDjango60Warning,
786         )
787         source = self.reverse_related_fields if reverse_join else self.related_fields
788         return tuple(
789             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
790         )
791 
792     def get_reverse_joining_columns(self):
793         warnings.warn(
794             "ForeignObject.get_reverse_joining_columns() is deprecated. Use "
795             "get_reverse_joining_fields() instead.",
796             RemovedInDjango60Warning,
797         )
798         return self.get_joining_columns(reverse_join=True)
799 
800     def get_joining_fields(self, reverse_join=False):
801         return tuple(
802             self.reverse_related_fields if reverse_join else self.related_fields
803         )
804 
805     def get_reverse_joining_fields(self):
806         return self.get_joining_fields(reverse_join=True)
807 
808     def get_extra_descriptor_filter(self, instance):
809         """
810         Return an extra filter condition for related object fetching when
811         user does 'instance.fieldname', that is the extra filter is used in
812         the descriptor of the field.
813 
814         The filter should be either a dict usable in .filter(**kwargs) call or
815         a Q-object. The condition will be ANDed together with the relation's
816         joining columns.
817 
818         A parallel method is get_extra_restriction() which is used in
819         JOIN and subquery conditions.
820         """
821         return {}
822 
823     def get_extra_restriction(self, alias, related_alias):
824         """
825         Return a pair condition used for joining and subquery pushdown. The
826         condition is something that responds to as_sql(compiler, connection)
827         method.
828 
829         Note that currently referring both the 'alias' and 'related_alias'
830         will not work in some conditions, like subquery pushdown.
831 
832         A parallel method is get_extra_descriptor_filter() which is used in
833         instance.fieldname related object fetching.
834         """
835         return None
836 
837     def get_path_info(self, filtered_relation=None):
838         """Get path from this field to the related model."""
839         opts = self.remote_field.model._meta
840         from_opts = self.model._meta
841         return [
842             PathInfo(
843                 from_opts=from_opts,
844                 to_opts=opts,
845                 target_fields=self.foreign_related_fields,
846                 join_field=self,
847                 m2m=False,
848                 direct=True,
849                 filtered_relation=filtered_relation,
850             )
851         ]
852 
853     @cached_property
854     def path_infos(self):
855         return self.get_path_info()
856 
857     def get_reverse_path_info(self, filtered_relation=None):
858         """Get path from the related model to this field's model."""
859         opts = self.model._meta
860         from_opts = self.remote_field.model._meta
861         return [
862             PathInfo(
863                 from_opts=from_opts,
864                 to_opts=opts,
865                 target_fields=(opts.pk,),
866                 join_field=self.remote_field,
867                 m2m=not self.unique,
868                 direct=False,
869                 filtered_relation=filtered_relation,
870             )
871         ]
872 
873     @cached_property
874     def reverse_path_infos(self):
875         return self.get_reverse_path_info()
876 
877     @classmethod
878     @functools.cache
879     def get_class_lookups(cls):
880         bases = inspect.getmro(cls)
881         bases = bases[: bases.index(ForeignObject) + 1]
882         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
883         return cls.merge_dicts(class_lookups)
884 
885     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
886         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
887         setattr(cls, self.name, self.forward_related_accessor_class(self))
888 
889     def contribute_to_related_class(self, cls, related):
890         # Internal FK's - i.e., those with a related name ending with '+' -
891         # and swapped models don't get a related descriptor.
892         if (
893             not self.remote_field.is_hidden()
894             and not related.related_model._meta.swapped
895         ):
896             setattr(
897                 cls._meta.concrete_model,
898                 related.get_accessor_name(),
899                 self.related_accessor_class(related),
900             )
901             # While 'limit_choices_to' might be a callable, simply pass
902             # it along for later - this is too early because it's still
903             # model load time.
904             if self.remote_field.limit_choices_to:
905                 cls._meta.related_fkey_lookups.append(
906                     self.remote_field.limit_choices_to
907                 )
908 
909 
910 ForeignObject.register_lookup(RelatedIn)
911 ForeignObject.register_lookup(RelatedExact)
912 ForeignObject.register_lookup(RelatedLessThan)
913 ForeignObject.register_lookup(RelatedGreaterThan)
914 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
915 ForeignObject.register_lookup(RelatedLessThanOrEqual)
916 ForeignObject.register_lookup(RelatedIsNull)
917 
918 
919 class ForeignKey(ForeignObject):
920     """
921     Provide a many-to-one relation by adding a column to the local model
922     to hold the remote value.
923 
924     By default ForeignKey will target the pk of the remote model but this
925     behavior can be changed by using the ``to_field`` argument.
926     """
927 
928     descriptor_class = ForeignKeyDeferredAttribute
929     # Field flags
930     many_to_many = False
931     many_to_one = True
932     one_to_many = False
933     one_to_one = False
934 
935     rel_class = ManyToOneRel
936 
937     empty_strings_allowed = False
938     default_error_messages = {
939         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
940     }
941     description = _("Foreign Key (type determined by related field)")
942 
943     def __init__(
944         self,
945         to,
946         on_delete,
947         related_name=None,
948         related_query_name=None,
949         limit_choices_to=None,
950         parent_link=False,
951         to_field=None,
952         db_constraint=True,
953         **kwargs,
954     ):
955         try:
956             to._meta.model_name
957         except AttributeError:
958             if not isinstance(to, str):
959                 raise TypeError(
960                     "%s(%r) is invalid. First parameter to ForeignKey must be "
961                     "either a model, a model name, or the string %r"
962                     % (
963                         self.__class__.__name__,
964                         to,
965                         RECURSIVE_RELATIONSHIP_CONSTANT,
966                     )
967                 )
968         else:
969             # For backwards compatibility purposes, we need to *try* and set
970             # the to_field during FK construction. It won't be guaranteed to
971             # be correct until contribute_to_class is called. Refs #12190.
972             to_field = to_field or (to._meta.pk and to._meta.pk.name)
973         if not callable(on_delete):
974             raise TypeError("on_delete must be callable.")
975 
976         kwargs["rel"] = self.rel_class(
977             self,
978             to,
979             to_field,
980             related_name=related_name,
981             related_query_name=related_query_name,
982             limit_choices_to=limit_choices_to,
983             parent_link=parent_link,
984             on_delete=on_delete,
985         )
986         kwargs.setdefault("db_index", True)
987 
988         super().__init__(
989             to,
990             on_delete,
991             related_name=related_name,
992             related_query_name=related_query_name,
993             limit_choices_to=limit_choices_to,
994             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
995             to_fields=[to_field],
996             **kwargs,
997         )
998         self.db_constraint = db_constraint
999 
1000     def __class_getitem__(cls, *args, **kwargs):
1001         return cls
1002 
1003     def check(self, **kwargs):
1004         return [
1005             *super().check(**kwargs),
1006             *self._check_on_delete(),
1007             *self._check_unique(),
1008         ]
1009 
1010     def _check_on_delete(self):
1011         on_delete = getattr(self.remote_field, "on_delete", None)
1012         if on_delete == SET_NULL and not self.null:
1013             return [
1014                 checks.Error(
1015                     "Field specifies on_delete=SET_NULL, but cannot be null.",
1016                     hint=(
1017                         "Set null=True argument on the field, or change the on_delete "
1018                         "rule."
1019                     ),
1020                     obj=self,
1021                     id="fields.E320",
1022                 )
1023             ]
1024         elif on_delete == SET_DEFAULT and not self.has_default():
1025             return [
1026                 checks.Error(
1027                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1028                     hint="Set a default value, or change the on_delete rule.",
1029                     obj=self,
1030                     id="fields.E321",
1031                 )
1032             ]
1033         else:
1034             return []
1035 
1036     def _check_unique(self, **kwargs):
1037         return (
1038             [
1039                 checks.Warning(
1040                     "Setting unique=True on a ForeignKey has the same effect as using "
1041                     "a OneToOneField.",
1042                     hint=(
1043                         "ForeignKey(unique=True) is usually better served by a "
1044                         "OneToOneField."
1045                     ),
1046                     obj=self,
1047                     id="fields.W342",
1048                 )
1049             ]
1050             if self.unique
1051             else []
1052         )
1053 
1054     def deconstruct(self):
1055         name, path, args, kwargs = super().deconstruct()
1056         del kwargs["to_fields"]
1057         del kwargs["from_fields"]
1058         # Handle the simpler arguments
1059         if self.db_index:
1060             del kwargs["db_index"]
1061         else:
1062             kwargs["db_index"] = False
1063         if self.db_constraint is not True:
1064             kwargs["db_constraint"] = self.db_constraint
1065         # Rel needs more work.
1066         to_meta = getattr(self.remote_field.model, "_meta", None)
1067         if self.remote_field.field_name and (
1068             not to_meta
1069             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1070         ):
1071             kwargs["to_field"] = self.remote_field.field_name
1072         return name, path, args, kwargs
1073 
1074     def to_python(self, value):
1075         return self.target_field.to_python(value)
1076 
1077     @property
1078     def target_field(self):
1079         return self.foreign_related_fields[0]
1080 
1081     def validate(self, value, model_instance):
1082         if self.remote_field.parent_link:
1083             return
1084         super().validate(value, model_instance)
1085         if value is None:
1086             return
1087 
1088         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1089         qs = self.remote_field.model._base_manager.using(using).filter(
1090             **{self.remote_field.field_name: value}
1091         )
1092         qs = qs.complex_filter(self.get_limit_choices_to())
1093         if not qs.exists():
1094             raise exceptions.ValidationError(
1095                 self.error_messages["invalid"],
1096                 code="invalid",
1097                 params={
1098                     "model": self.remote_field.model._meta.verbose_name,
1099                     "pk": value,
1100                     "field": self.remote_field.field_name,
1101                     "value": value,
1102                 },  # 'pk' is included for backwards compatibility
1103             )
1104 
1105     def resolve_related_fields(self):
1106         related_fields = super().resolve_related_fields()
1107         for from_field, to_field in related_fields:
1108             if (
1109                 to_field
1110                 and to_field.model != self.remote_field.model._meta.concrete_model
1111             ):
1112                 raise exceptions.FieldError(
1113                     "'%s.%s' refers to field '%s' which is not local to model "
1114                     "'%s'."
1115                     % (
1116                         self.model._meta.label,
1117                         self.name,
1118                         to_field.name,
1119                         self.remote_field.model._meta.concrete_model._meta.label,
1120                     )
1121                 )
1122         return related_fields
1123 
1124     def get_attname(self):
1125         return "%s_id" % self.name
1126 
1127     def get_attname_column(self):
1128         attname = self.get_attname()
1129         column = self.db_column or attname
1130         return attname, column
1131 
1132     def get_default(self):
1133         """Return the to_field if the default value is an object."""
1134         field_default = super().get_default()
1135         if isinstance(field_default, self.remote_field.model):
1136             return getattr(field_default, self.target_field.attname)
1137         return field_default
1138 
1139     def get_db_prep_save(self, value, connection):
1140         if value is None or (
1141             value == ""
1142             and (
1143                 not self.target_field.empty_strings_allowed
1144                 or connection.features.interprets_empty_strings_as_nulls
1145             )
1146         ):
1147             return None
1148         else:
1149             return self.target_field.get_db_prep_save(value, connection=connection)
1150 
1151     def get_db_prep_value(self, value, connection, prepared=False):
1152         return self.target_field.get_db_prep_value(value, connection, prepared)
1153 
1154     def get_prep_value(self, value):
1155         return self.target_field.get_prep_value(value)
1156 
1157     def contribute_to_related_class(self, cls, related):
1158         super().contribute_to_related_class(cls, related)
1159         if self.remote_field.field_name is None:
1160             self.remote_field.field_name = cls._meta.pk.name
1161 
1162     def formfield(self, *, using=None, **kwargs):
1163         if isinstance(self.remote_field.model, str):
1164             raise ValueError(
1165                 "Cannot create form field for %r yet, because "
1166                 "its related model %r has not been loaded yet"
1167                 % (self.name, self.remote_field.model)
1168             )
1169         return super().formfield(
1170             **{
1171                 "form_class": forms.ModelChoiceField,
1172                 "queryset": self.remote_field.model._default_manager.using(using),
1173                 "to_field_name": self.remote_field.field_name,
1174                 **kwargs,
1175                 "blank": self.blank,
1176             }
1177         )
1178 
1179     def db_check(self, connection):
1180         return None
1181 
1182     def db_type(self, connection):
1183         return self.target_field.rel_db_type(connection=connection)
1184 
1185     def cast_db_type(self, connection):
1186         return self.target_field.cast_db_type(connection=connection)
1187 
1188     def db_parameters(self, connection):
1189         target_db_parameters = self.target_field.db_parameters(connection)
1190         return {
1191             "type": self.db_type(connection),
1192             "check": self.db_check(connection),
1193             "collation": target_db_parameters.get("collation"),
1194         }
1195 
1196     def convert_empty_strings(self, value, expression, connection):
1197         if (not value) and isinstance(value, str):
1198             return None
1199         return value
1200 
1201     def get_db_converters(self, connection):
1202         converters = super().get_db_converters(connection)
1203         if connection.features.interprets_empty_strings_as_nulls:
1204             converters += [self.convert_empty_strings]
1205         return converters
1206 
1207     def get_col(self, alias, output_field=None):
1208         if output_field is None:
1209             output_field = self.target_field
1210             while isinstance(output_field, ForeignKey):
1211                 output_field = output_field.target_field
1212                 if output_field is self:
1213                     raise ValueError("Cannot resolve output_field.")
1214         return super().get_col(alias, output_field)
1215 
1216 
1217 class OneToOneField(ForeignKey):
1218     """
1219     A OneToOneField is essentially the same as a ForeignKey, with the exception
1220     that it always carries a "unique" constraint with it and the reverse
1221     relation always returns the object pointed to (since there will only ever
1222     be one), rather than returning a list.
1223     """
1224 
1225     # Field flags
1226     many_to_many = False
1227     many_to_one = False
1228     one_to_many = False
1229     one_to_one = True
1230 
1231     related_accessor_class = ReverseOneToOneDescriptor
1232     forward_related_accessor_class = ForwardOneToOneDescriptor
1233     rel_class = OneToOneRel
1234 
1235     description = _("One-to-one relationship")
1236 
1237     def __init__(self, to, on_delete, to_field=None, **kwargs):
1238         kwargs["unique"] = True
1239         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1240 
1241     def deconstruct(self):
1242         name, path, args, kwargs = super().deconstruct()
1243         if "unique" in kwargs:
1244             del kwargs["unique"]
1245         return name, path, args, kwargs
1246 
1247     def formfield(self, **kwargs):
1248         if self.remote_field.parent_link:
1249             return None
1250         return super().formfield(**kwargs)
1251 
1252     def save_form_data(self, instance, data):
1253         if isinstance(data, self.remote_field.model):
1254             setattr(instance, self.name, data)
1255         else:
1256             setattr(instance, self.attname, data)
1257             # Remote field object must be cleared otherwise Model.save()
1258             # will reassign attname using the related object pk.
1259             if data is None:
1260                 setattr(instance, self.name, data)
1261 
1262     def _check_unique(self, **kwargs):
1263         # Override ForeignKey since check isn't applicable here.
1264         return []
1265 
1266 
1267 def create_many_to_many_intermediary_model(field, klass):
1268     from django.db import models
1269 
1270     def set_managed(model, related, through):
1271         through._meta.managed = model._meta.managed or related._meta.managed
1272 
1273     to_model = resolve_relation(klass, field.remote_field.model)
1274     name = "%s_%s" % (klass._meta.object_name, field.name)
1275     lazy_related_operation(set_managed, klass, to_model, name)
1276 
1277     to = make_model_tuple(to_model)[1]
1278     from_ = klass._meta.model_name
1279     if to == from_:
1280         to = "to_%s" % to
1281         from_ = "from_%s" % from_
1282 
1283     meta = type(
1284         "Meta",
1285         (),
1286         {
1287             "db_table": field._get_m2m_db_table(klass._meta),
1288             "auto_created": klass,
1289             "app_label": klass._meta.app_label,
1290             "db_tablespace": klass._meta.db_tablespace,
1291             "unique_together": (from_, to),
1292             "verbose_name": _("%(from)s-%(to)s relationship")
1293             % {"from": from_, "to": to},
1294             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1295             % {"from": from_, "to": to},
1296             "apps": field.model._meta.apps,
1297         },
1298     )
1299     # Construct and return the new class.
1300     return type(
1301         name,
1302         (models.Model,),
1303         {
1304             "Meta": meta,
1305             "__module__": klass.__module__,
1306             from_: models.ForeignKey(
1307                 klass,
1308                 related_name="%s+" % name,
1309                 db_tablespace=field.db_tablespace,
1310                 db_constraint=field.remote_field.db_constraint,
1311                 on_delete=CASCADE,
1312             ),
1313             to: models.ForeignKey(
1314                 to_model,
1315                 related_name="%s+" % name,
1316                 db_tablespace=field.db_tablespace,
1317                 db_constraint=field.remote_field.db_constraint,
1318                 on_delete=CASCADE,
1319             ),
1320         },
1321     )
1322 
1323 
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>Adjustment here could involve ensuring that during object creation and saving, all relationship fields, particularly those involved in MTI scenarios, correctly report their attributes and are fully compatible with how parent models are saved. This might include ensuring `attname` and other critical attributes are always accessible and correctly reflect the field's relationship in the database, especially in complex inheritance cases.</intended_behavior>]
2025-10-15 07:01:19.696 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:01:19.696 | INFO     | Search-only: skipping patch selection
2025-10-15 07:01:19.855 | INFO     | Task django__django-16952 completed successfully.
2025-10-15 07:01:19.855 | INFO     | No patch generated. You can try running ACR again.
