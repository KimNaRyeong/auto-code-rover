[
    {
        "rel_file_path": "django/core/management/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/management/__init__.py",
        "start": 334,
        "end": 413,
        "class_name": "ManagementUtility",
        "method_name": "execute",
        "code": "334     def execute(self):\n335         \"\"\"\n336         Given the command-line arguments, figure out which subcommand is being\n337         run, create a parser appropriate to that command, and run it.\n338         \"\"\"\n339         try:\n340             subcommand = self.argv[1]\n341         except IndexError:\n342             subcommand = 'help'  # Display help if no arguments were given.\n343 \n344         # Preprocess options to extract --settings and --pythonpath.\n345         # These options could affect the commands that are available, so they\n346         # must be processed early.\n347         parser = CommandParser(\n348             prog=self.prog_name,\n349             usage='%(prog)s subcommand [options] [args]',\n350             add_help=False,\n351             allow_abbrev=False,\n352         )\n353         parser.add_argument('--settings')\n354         parser.add_argument('--pythonpath')\n355         parser.add_argument('args', nargs='*')  # catch-all\n356         try:\n357             options, args = parser.parse_known_args(self.argv[2:])\n358             handle_default_options(options)\n359         except CommandError:\n360             pass  # Ignore any option errors at this point.\n361 \n362         try:\n363             settings.INSTALLED_APPS\n364         except ImproperlyConfigured as exc:\n365             self.settings_exception = exc\n366         except ImportError as exc:\n367             self.settings_exception = exc\n368 \n369         if settings.configured:\n370             # Start the auto-reloading dev server even if the code is broken.\n371             # The hardcoded condition is a code smell but we can't rely on a\n372             # flag on the command class because we haven't located it yet.\n373             if subcommand == 'runserver' and '--noreload' not in self.argv:\n374                 try:\n375                     autoreload.check_errors(django.setup)()\n376                 except Exception:\n377                     # The exception will be raised later in the child process\n378                     # started by the autoreloader. Pretend it didn't happen by\n379                     # loading an empty list of applications.\n380                     apps.all_models = defaultdict(dict)\n381                     apps.app_configs = {}\n382                     apps.apps_ready = apps.models_ready = apps.ready = True\n383 \n384                     # Remove options not compatible with the built-in runserver\n385                     # (e.g. options for the contrib.staticfiles' runserver).\n386                     # Changes here require manually testing as described in\n387                     # #27522.\n388                     _parser = self.fetch_command('runserver').create_parser('django', 'runserver')\n389                     _options, _args = _parser.parse_known_args(self.argv[2:])\n390                     for _arg in _args:\n391                         self.argv.remove(_arg)\n392 \n393             # In all other cases, django.setup() is required to succeed.\n394             else:\n395                 django.setup()\n396 \n397         self.autocomplete()\n398 \n399         if subcommand == 'help':\n400             if '--commands' in args:\n401                 sys.stdout.write(self.main_help_text(commands_only=True) + '\\n')\n402             elif not options.args:\n403                 sys.stdout.write(self.main_help_text() + '\\n')\n404             else:\n405                 self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])\n406         # Special-cases: We want 'django-admin --version' and\n407         # 'django-admin --help' to work, for backwards compatibility.\n408         elif subcommand == 'version' or self.argv[1:] == ['--version']:\n409             sys.stdout.write(django.get_version() + '\\n')\n410         elif self.argv[1:] in (['--help'], ['-h']):\n411             sys.stdout.write(self.main_help_text() + '\\n')\n412         else:\n413             self.fetch_command(subcommand).run_from_argv(self.argv)\n",
        "intended_behavior": "This method should ensure that when a module is specified with the '-m' option for the 'runserver' command, it correctly interprets and maintains the full dotted module path (e.g., 'foo.bar.baz') without truncating it to 'foo.bar'. The autoreloader should correctly recognize and monitor changes in the specific module ('baz.py') for reloading. The handling of the module name parsing needs to be precise to allow for accurate reloading signals to be generated."
    },
    {
        "rel_file_path": "django/core/management/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/management/__init__.py",
        "start": 184,
        "end": 413,
        "class_name": "ManagementUtility",
        "method_name": null,
        "code": "184 class ManagementUtility:\n185     \"\"\"\n186     Encapsulate the logic of the django-admin and manage.py utilities.\n187     \"\"\"\n188     def __init__(self, argv=None):\n189         self.argv = argv or sys.argv[:]\n190         self.prog_name = os.path.basename(self.argv[0])\n191         if self.prog_name == '__main__.py':\n192             self.prog_name = 'python -m django'\n193         self.settings_exception = None\n194 \n195     def main_help_text(self, commands_only=False):\n196         \"\"\"Return the script's main help text, as a string.\"\"\"\n197         if commands_only:\n198             usage = sorted(get_commands())\n199         else:\n200             usage = [\n201                 \"\",\n202                 \"Type '%s help <subcommand>' for help on a specific subcommand.\" % self.prog_name,\n203                 \"\",\n204                 \"Available subcommands:\",\n205             ]\n206             commands_dict = defaultdict(lambda: [])\n207             for name, app in get_commands().items():\n208                 if app == 'django.core':\n209                     app = 'django'\n210                 else:\n211                     app = app.rpartition('.')[-1]\n212                 commands_dict[app].append(name)\n213             style = color_style()\n214             for app in sorted(commands_dict):\n215                 usage.append(\"\")\n216                 usage.append(style.NOTICE(\"[%s]\" % app))\n217                 for name in sorted(commands_dict[app]):\n218                     usage.append(\"    %s\" % name)\n219             # Output an extra note if settings are not properly configured\n220             if self.settings_exception is not None:\n221                 usage.append(style.NOTICE(\n222                     \"Note that only Django core commands are listed \"\n223                     \"as settings are not properly configured (error: %s).\"\n224                     % self.settings_exception))\n225 \n226         return '\\n'.join(usage)\n227 \n228     def fetch_command(self, subcommand):\n229         \"\"\"\n230         Try to fetch the given subcommand, printing a message with the\n231         appropriate command called from the command line (usually\n232         \"django-admin\" or \"manage.py\") if it can't be found.\n233         \"\"\"\n234         # Get commands outside of try block to prevent swallowing exceptions\n235         commands = get_commands()\n236         try:\n237             app_name = commands[subcommand]\n238         except KeyError:\n239             if os.environ.get('DJANGO_SETTINGS_MODULE'):\n240                 # If `subcommand` is missing due to misconfigured settings, the\n241                 # following line will retrigger an ImproperlyConfigured exception\n242                 # (get_commands() swallows the original one) so the user is\n243                 # informed about it.\n244                 settings.INSTALLED_APPS\n245             elif not settings.configured:\n246                 sys.stderr.write(\"No Django settings specified.\\n\")\n247             possible_matches = get_close_matches(subcommand, commands)\n248             sys.stderr.write('Unknown command: %r' % subcommand)\n249             if possible_matches:\n250                 sys.stderr.write('. Did you mean %s?' % possible_matches[0])\n251             sys.stderr.write(\"\\nType '%s help' for usage.\\n\" % self.prog_name)\n252             sys.exit(1)\n253         if isinstance(app_name, BaseCommand):\n254             # If the command is already loaded, use it directly.\n255             klass = app_name\n256         else:\n257             klass = load_command_class(app_name, subcommand)\n258         return klass\n259 \n260     def autocomplete(self):\n261         \"\"\"\n262         Output completion suggestions for BASH.\n263 \n264         The output of this function is passed to BASH's `COMREPLY` variable and\n265         treated as completion suggestions. `COMREPLY` expects a space\n266         separated string as the result.\n267 \n268         The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used\n269         to get information about the cli input. Please refer to the BASH\n270         man-page for more information about this variables.\n271 \n272         Subcommand options are saved as pairs. A pair consists of\n273         the long option string (e.g. '--exclude') and a boolean\n274         value indicating if the option requires arguments. When printing to\n275         stdout, an equal sign is appended to options which require arguments.\n276 \n277         Note: If debugging this function, it is recommended to write the debug\n278         output in a separate file. Otherwise the debug output will be treated\n279         and formatted as potential completion suggestions.\n280         \"\"\"\n281         # Don't complete if user hasn't sourced bash_completion file.\n282         if 'DJANGO_AUTO_COMPLETE' not in os.environ:\n283             return\n284 \n285         cwords = os.environ['COMP_WORDS'].split()[1:]\n286         cword = int(os.environ['COMP_CWORD'])\n287 \n288         try:\n289             curr = cwords[cword - 1]\n290         except IndexError:\n291             curr = ''\n292 \n293         subcommands = [*get_commands(), 'help']\n294         options = [('--help', False)]\n295 \n296         # subcommand\n297         if cword == 1:\n298             print(' '.join(sorted(filter(lambda x: x.startswith(curr), subcommands))))\n299         # subcommand options\n300         # special case: the 'help' subcommand has no options\n301         elif cwords[0] in subcommands and cwords[0] != 'help':\n302             subcommand_cls = self.fetch_command(cwords[0])\n303             # special case: add the names of installed apps to options\n304             if cwords[0] in ('dumpdata', 'sqlmigrate', 'sqlsequencereset', 'test'):\n305                 try:\n306                     app_configs = apps.get_app_configs()\n307                     # Get the last part of the dotted path as the app name.\n308                     options.extend((app_config.label, 0) for app_config in app_configs)\n309                 except ImportError:\n310                     # Fail silently if DJANGO_SETTINGS_MODULE isn't set. The\n311                     # user will find out once they execute the command.\n312                     pass\n313             parser = subcommand_cls.create_parser('', cwords[0])\n314             options.extend(\n315                 (min(s_opt.option_strings), s_opt.nargs != 0)\n316                 for s_opt in parser._actions if s_opt.option_strings\n317             )\n318             # filter out previously specified options from available options\n319             prev_opts = {x.split('=')[0] for x in cwords[1:cword - 1]}\n320             options = (opt for opt in options if opt[0] not in prev_opts)\n321 \n322             # filter options by current input\n323             options = sorted((k, v) for k, v in options if k.startswith(curr))\n324             for opt_label, require_arg in options:\n325                 # append '=' to options which require args\n326                 if require_arg:\n327                     opt_label += '='\n328                 print(opt_label)\n329         # Exit code of the bash completion function is never passed back to\n330         # the user, so it's safe to always exit with 0.\n331         # For more details see #25420.\n332         sys.exit(0)\n333 \n334     def execute(self):\n335         \"\"\"\n336         Given the command-line arguments, figure out which subcommand is being\n337         run, create a parser appropriate to that command, and run it.\n338         \"\"\"\n339         try:\n340             subcommand = self.argv[1]\n341         except IndexError:\n342             subcommand = 'help'  # Display help if no arguments were given.\n343 \n344         # Preprocess options to extract --settings and --pythonpath.\n345         # These options could affect the commands that are available, so they\n346         # must be processed early.\n347         parser = CommandParser(\n348             prog=self.prog_name,\n349             usage='%(prog)s subcommand [options] [args]',\n350             add_help=False,\n351             allow_abbrev=False,\n352         )\n353         parser.add_argument('--settings')\n354         parser.add_argument('--pythonpath')\n355         parser.add_argument('args', nargs='*')  # catch-all\n356         try:\n357             options, args = parser.parse_known_args(self.argv[2:])\n358             handle_default_options(options)\n359         except CommandError:\n360             pass  # Ignore any option errors at this point.\n361 \n362         try:\n363             settings.INSTALLED_APPS\n364         except ImproperlyConfigured as exc:\n365             self.settings_exception = exc\n366         except ImportError as exc:\n367             self.settings_exception = exc\n368 \n369         if settings.configured:\n370             # Start the auto-reloading dev server even if the code is broken.\n371             # The hardcoded condition is a code smell but we can't rely on a\n372             # flag on the command class because we haven't located it yet.\n373             if subcommand == 'runserver' and '--noreload' not in self.argv:\n374                 try:\n375                     autoreload.check_errors(django.setup)()\n376                 except Exception:\n377                     # The exception will be raised later in the child process\n378                     # started by the autoreloader. Pretend it didn't happen by\n379                     # loading an empty list of applications.\n380                     apps.all_models = defaultdict(dict)\n381                     apps.app_configs = {}\n382                     apps.apps_ready = apps.models_ready = apps.ready = True\n383 \n384                     # Remove options not compatible with the built-in runserver\n385                     # (e.g. options for the contrib.staticfiles' runserver).\n386                     # Changes here require manually testing as described in\n387                     # #27522.\n388                     _parser = self.fetch_command('runserver').create_parser('django', 'runserver')\n389                     _options, _args = _parser.parse_known_args(self.argv[2:])\n390                     for _arg in _args:\n391                         self.argv.remove(_arg)\n392 \n393             # In all other cases, django.setup() is required to succeed.\n394             else:\n395                 django.setup()\n396 \n397         self.autocomplete()\n398 \n399         if subcommand == 'help':\n400             if '--commands' in args:\n401                 sys.stdout.write(self.main_help_text(commands_only=True) + '\\n')\n402             elif not options.args:\n403                 sys.stdout.write(self.main_help_text() + '\\n')\n404             else:\n405                 self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])\n406         # Special-cases: We want 'django-admin --version' and\n407         # 'django-admin --help' to work, for backwards compatibility.\n408         elif subcommand == 'version' or self.argv[1:] == ['--version']:\n409             sys.stdout.write(django.get_version() + '\\n')\n410         elif self.argv[1:] in (['--help'], ['-h']):\n411             sys.stdout.write(self.main_help_text() + '\\n')\n412         else:\n413             self.fetch_command(subcommand).run_from_argv(self.argv)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/utils/autoreload.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/utils/autoreload.py",
        "start": 1,
        "end": 639,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import itertools\n3 import logging\n4 import os\n5 import signal\n6 import subprocess\n7 import sys\n8 import threading\n9 import time\n10 import traceback\n11 import weakref\n12 from collections import defaultdict\n13 from pathlib import Path\n14 from types import ModuleType\n15 from zipimport import zipimporter\n16 \n17 import django\n18 from django.apps import apps\n19 from django.core.signals import request_finished\n20 from django.dispatch import Signal\n21 from django.utils.functional import cached_property\n22 from django.utils.version import get_version_tuple\n23 \n24 autoreload_started = Signal()\n25 file_changed = Signal()\n26 \n27 DJANGO_AUTORELOAD_ENV = 'RUN_MAIN'\n28 \n29 logger = logging.getLogger('django.utils.autoreload')\n30 \n31 # If an error is raised while importing a file, it's not placed in sys.modules.\n32 # This means that any future modifications aren't caught. Keep a list of these\n33 # file paths to allow watching them in the future.\n34 _error_files = []\n35 _exception = None\n36 \n37 try:\n38     import termios\n39 except ImportError:\n40     termios = None\n41 \n42 \n43 try:\n44     import pywatchman\n45 except ImportError:\n46     pywatchman = None\n47 \n48 \n49 def is_django_module(module):\n50     \"\"\"Return True if the given module is nested under Django.\"\"\"\n51     return module.__name__.startswith('django.')\n52 \n53 \n54 def is_django_path(path):\n55     \"\"\"Return True if the given file path is nested under Django.\"\"\"\n56     return Path(django.__file__).parent in Path(path).parents\n57 \n58 \n59 def check_errors(fn):\n60     @functools.wraps(fn)\n61     def wrapper(*args, **kwargs):\n62         global _exception\n63         try:\n64             fn(*args, **kwargs)\n65         except Exception:\n66             _exception = sys.exc_info()\n67 \n68             et, ev, tb = _exception\n69 \n70             if getattr(ev, 'filename', None) is None:\n71                 # get the filename from the last item in the stack\n72                 filename = traceback.extract_tb(tb)[-1][0]\n73             else:\n74                 filename = ev.filename\n75 \n76             if filename not in _error_files:\n77                 _error_files.append(filename)\n78 \n79             raise\n80 \n81     return wrapper\n82 \n83 \n84 def raise_last_exception():\n85     global _exception\n86     if _exception is not None:\n87         raise _exception[1]\n88 \n89 \n90 def ensure_echo_on():\n91     \"\"\"\n92     Ensure that echo mode is enabled. Some tools such as PDB disable\n93     it which causes usability issues after reload.\n94     \"\"\"\n95     if not termios or not sys.stdin.isatty():\n96         return\n97     attr_list = termios.tcgetattr(sys.stdin)\n98     if not attr_list[3] & termios.ECHO:\n99         attr_list[3] |= termios.ECHO\n100         if hasattr(signal, 'SIGTTOU'):\n101             old_handler = signal.signal(signal.SIGTTOU, signal.SIG_IGN)\n102         else:\n103             old_handler = None\n104         termios.tcsetattr(sys.stdin, termios.TCSANOW, attr_list)\n105         if old_handler is not None:\n106             signal.signal(signal.SIGTTOU, old_handler)\n107 \n108 \n109 def iter_all_python_module_files():\n110     # This is a hot path during reloading. Create a stable sorted list of\n111     # modules based on the module name and pass it to iter_modules_and_files().\n112     # This ensures cached results are returned in the usual case that modules\n113     # aren't loaded on the fly.\n114     keys = sorted(sys.modules)\n115     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n116     return iter_modules_and_files(modules, frozenset(_error_files))\n117 \n118 \n119 @functools.lru_cache(maxsize=1)\n120 def iter_modules_and_files(modules, extra_files):\n121     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n122     sys_file_paths = []\n123     for module in modules:\n124         # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n125         # are added to sys.modules, however they are types not modules and so\n126         # cause issues here.\n127         if not isinstance(module, ModuleType):\n128             continue\n129         if module.__name__ == '__main__':\n130             # __main__ (usually manage.py) doesn't always have a __spec__ set.\n131             # Handle this by falling back to using __file__, resolved below.\n132             # See https://docs.python.org/reference/import.html#main-spec\n133             # __file__ may not exists, e.g. when running ipdb debugger.\n134             if hasattr(module, '__file__'):\n135                 sys_file_paths.append(module.__file__)\n136             continue\n137         if getattr(module, '__spec__', None) is None:\n138             continue\n139         spec = module.__spec__\n140         # Modules could be loaded from places without a concrete location. If\n141         # this is the case, skip them.\n142         if spec.has_location:\n143             origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n144             sys_file_paths.append(origin)\n145 \n146     results = set()\n147     for filename in itertools.chain(sys_file_paths, extra_files):\n148         if not filename:\n149             continue\n150         path = Path(filename)\n151         try:\n152             if not path.exists():\n153                 # The module could have been removed, don't fail loudly if this\n154                 # is the case.\n155                 continue\n156         except ValueError as e:\n157             # Network filesystems may return null bytes in file paths.\n158             logger.debug('\"%s\" raised when resolving path: \"%s\"', e, path)\n159             continue\n160         resolved_path = path.resolve().absolute()\n161         results.add(resolved_path)\n162     return frozenset(results)\n163 \n164 \n165 @functools.lru_cache(maxsize=1)\n166 def common_roots(paths):\n167     \"\"\"\n168     Return a tuple of common roots that are shared between the given paths.\n169     File system watchers operate on directories and aren't cheap to create.\n170     Try to find the minimum set of directories to watch that encompass all of\n171     the files that need to be watched.\n172     \"\"\"\n173     # Inspired from Werkzeug:\n174     # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n175     # Create a sorted list of the path components, longest first.\n176     path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n177     tree = {}\n178     for chunks in path_parts:\n179         node = tree\n180         # Add each part of the path to the tree.\n181         for chunk in chunks:\n182             node = node.setdefault(chunk, {})\n183         # Clear the last leaf in the tree.\n184         node.clear()\n185 \n186     # Turn the tree into a list of Path instances.\n187     def _walk(node, path):\n188         for prefix, child in node.items():\n189             yield from _walk(child, path + (prefix,))\n190         if not node:\n191             yield Path(*path)\n192 \n193     return tuple(_walk(tree, ()))\n194 \n195 \n196 def sys_path_directories():\n197     \"\"\"\n198     Yield absolute directories from sys.path, ignoring entries that don't\n199     exist.\n200     \"\"\"\n201     for path in sys.path:\n202         path = Path(path)\n203         if not path.exists():\n204             continue\n205         resolved_path = path.resolve().absolute()\n206         # If the path is a file (like a zip file), watch the parent directory.\n207         if resolved_path.is_file():\n208             yield resolved_path.parent\n209         else:\n210             yield resolved_path\n211 \n212 \n213 def get_child_arguments():\n214     \"\"\"\n215     Return the executable. This contains a workaround for Windows if the\n216     executable is reported to not have the .exe extension which can cause bugs\n217     on reloading.\n218     \"\"\"\n219     import __main__\n220     py_script = Path(sys.argv[0])\n221 \n222     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n223     # __spec__ is set when the server was started with the `-m` option,\n224     # see https://docs.python.org/3/reference/import.html#main-spec\n225     # __spec__ may not exist, e.g. when running in a Conda env.\n226     if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:\n227         args += ['-m', __main__.__spec__.parent]\n228         args += sys.argv[1:]\n229     elif not py_script.exists():\n230         # sys.argv[0] may not exist for several reasons on Windows.\n231         # It may exist with a .exe extension or have a -script.py suffix.\n232         exe_entrypoint = py_script.with_suffix('.exe')\n233         if exe_entrypoint.exists():\n234             # Should be executed directly, ignoring sys.executable.\n235             return [exe_entrypoint, *sys.argv[1:]]\n236         script_entrypoint = py_script.with_name('%s-script.py' % py_script.name)\n237         if script_entrypoint.exists():\n238             # Should be executed as usual.\n239             return [*args, script_entrypoint, *sys.argv[1:]]\n240         raise RuntimeError('Script %s does not exist.' % py_script)\n241     else:\n242         args += sys.argv\n243     return args\n244 \n245 \n246 def trigger_reload(filename):\n247     logger.info('%s changed, reloading.', filename)\n248     sys.exit(3)\n249 \n250 \n251 def restart_with_reloader():\n252     new_environ = {**os.environ, DJANGO_AUTORELOAD_ENV: 'true'}\n253     args = get_child_arguments()\n254     while True:\n255         p = subprocess.run(args, env=new_environ, close_fds=False)\n256         if p.returncode != 3:\n257             return p.returncode\n258 \n259 \n260 class BaseReloader:\n261     def __init__(self):\n262         self.extra_files = set()\n263         self.directory_globs = defaultdict(set)\n264         self._stop_condition = threading.Event()\n265 \n266     def watch_dir(self, path, glob):\n267         path = Path(path)\n268         try:\n269             path = path.absolute()\n270         except FileNotFoundError:\n271             logger.debug(\n272                 'Unable to watch directory %s as it cannot be resolved.',\n273                 path,\n274                 exc_info=True,\n275             )\n276             return\n277         logger.debug('Watching dir %s with glob %s.', path, glob)\n278         self.directory_globs[path].add(glob)\n279 \n280     def watched_files(self, include_globs=True):\n281         \"\"\"\n282         Yield all files that need to be watched, including module files and\n283         files within globs.\n284         \"\"\"\n285         yield from iter_all_python_module_files()\n286         yield from self.extra_files\n287         if include_globs:\n288             for directory, patterns in self.directory_globs.items():\n289                 for pattern in patterns:\n290                     yield from directory.glob(pattern)\n291 \n292     def wait_for_apps_ready(self, app_reg, django_main_thread):\n293         \"\"\"\n294         Wait until Django reports that the apps have been loaded. If the given\n295         thread has terminated before the apps are ready, then a SyntaxError or\n296         other non-recoverable error has been raised. In that case, stop waiting\n297         for the apps_ready event and continue processing.\n298 \n299         Return True if the thread is alive and the ready event has been\n300         triggered, or False if the thread is terminated while waiting for the\n301         event.\n302         \"\"\"\n303         while django_main_thread.is_alive():\n304             if app_reg.ready_event.wait(timeout=0.1):\n305                 return True\n306         else:\n307             logger.debug('Main Django thread has terminated before apps are ready.')\n308             return False\n309 \n310     def run(self, django_main_thread):\n311         logger.debug('Waiting for apps ready_event.')\n312         self.wait_for_apps_ready(apps, django_main_thread)\n313         from django.urls import get_resolver\n314 \n315         # Prevent a race condition where URL modules aren't loaded when the\n316         # reloader starts by accessing the urlconf_module property.\n317         try:\n318             get_resolver().urlconf_module\n319         except Exception:\n320             # Loading the urlconf can result in errors during development.\n321             # If this occurs then swallow the error and continue.\n322             pass\n323         logger.debug('Apps ready_event triggered. Sending autoreload_started signal.')\n324         autoreload_started.send(sender=self)\n325         self.run_loop()\n326 \n327     def run_loop(self):\n328         ticker = self.tick()\n329         while not self.should_stop:\n330             try:\n331                 next(ticker)\n332             except StopIteration:\n333                 break\n334         self.stop()\n335 \n336     def tick(self):\n337         \"\"\"\n338         This generator is called in a loop from run_loop. It's important that\n339         the method takes care of pausing or otherwise waiting for a period of\n340         time. This split between run_loop() and tick() is to improve the\n341         testability of the reloader implementations by decoupling the work they\n342         do from the loop.\n343         \"\"\"\n344         raise NotImplementedError('subclasses must implement tick().')\n345 \n346     @classmethod\n347     def check_availability(cls):\n348         raise NotImplementedError('subclasses must implement check_availability().')\n349 \n350     def notify_file_changed(self, path):\n351         results = file_changed.send(sender=self, file_path=path)\n352         logger.debug('%s notified as changed. Signal results: %s.', path, results)\n353         if not any(res[1] for res in results):\n354             trigger_reload(path)\n355 \n356     # These are primarily used for testing.\n357     @property\n358     def should_stop(self):\n359         return self._stop_condition.is_set()\n360 \n361     def stop(self):\n362         self._stop_condition.set()\n363 \n364 \n365 class StatReloader(BaseReloader):\n366     SLEEP_TIME = 1  # Check for changes once per second.\n367 \n368     def tick(self):\n369         mtimes = {}\n370         while True:\n371             for filepath, mtime in self.snapshot_files():\n372                 old_time = mtimes.get(filepath)\n373                 mtimes[filepath] = mtime\n374                 if old_time is None:\n375                     logger.debug('File %s first seen with mtime %s', filepath, mtime)\n376                     continue\n377                 elif mtime > old_time:\n378                     logger.debug('File %s previous mtime: %s, current mtime: %s', filepath, old_time, mtime)\n379                     self.notify_file_changed(filepath)\n380 \n381             time.sleep(self.SLEEP_TIME)\n382             yield\n383 \n384     def snapshot_files(self):\n385         # watched_files may produce duplicate paths if globs overlap.\n386         seen_files = set()\n387         for file in self.watched_files():\n388             if file in seen_files:\n389                 continue\n390             try:\n391                 mtime = file.stat().st_mtime\n392             except OSError:\n393                 # This is thrown when the file does not exist.\n394                 continue\n395             seen_files.add(file)\n396             yield file, mtime\n397 \n398     @classmethod\n399     def check_availability(cls):\n400         return True\n401 \n402 \n403 class WatchmanUnavailable(RuntimeError):\n404     pass\n405 \n406 \n407 class WatchmanReloader(BaseReloader):\n408     def __init__(self):\n409         self.roots = defaultdict(set)\n410         self.processed_request = threading.Event()\n411         self.client_timeout = int(os.environ.get('DJANGO_WATCHMAN_TIMEOUT', 5))\n412         super().__init__()\n413 \n414     @cached_property\n415     def client(self):\n416         return pywatchman.client(timeout=self.client_timeout)\n417 \n418     def _watch_root(self, root):\n419         # In practice this shouldn't occur, however, it's possible that a\n420         # directory that doesn't exist yet is being watched. If it's outside of\n421         # sys.path then this will end up a new root. How to handle this isn't\n422         # clear: Not adding the root will likely break when subscribing to the\n423         # changes, however, as this is currently an internal API,  no files\n424         # will be being watched outside of sys.path. Fixing this by checking\n425         # inside watch_glob() and watch_dir() is expensive, instead this could\n426         # could fall back to the StatReloader if this case is detected? For\n427         # now, watching its parent, if possible, is sufficient.\n428         if not root.exists():\n429             if not root.parent.exists():\n430                 logger.warning('Unable to watch root dir %s as neither it or its parent exist.', root)\n431                 return\n432             root = root.parent\n433         result = self.client.query('watch-project', str(root.absolute()))\n434         if 'warning' in result:\n435             logger.warning('Watchman warning: %s', result['warning'])\n436         logger.debug('Watchman watch-project result: %s', result)\n437         return result['watch'], result.get('relative_path')\n438 \n439     @functools.lru_cache()\n440     def _get_clock(self, root):\n441         return self.client.query('clock', root)['clock']\n442 \n443     def _subscribe(self, directory, name, expression):\n444         root, rel_path = self._watch_root(directory)\n445         # Only receive notifications of files changing, filtering out other types\n446         # like special files: https://facebook.github.io/watchman/docs/type\n447         only_files_expression = [\n448             'allof',\n449             ['anyof', ['type', 'f'], ['type', 'l']],\n450             expression\n451         ]\n452         query = {\n453             'expression': only_files_expression,\n454             'fields': ['name'],\n455             'since': self._get_clock(root),\n456             'dedup_results': True,\n457         }\n458         if rel_path:\n459             query['relative_root'] = rel_path\n460         logger.debug('Issuing watchman subscription %s, for root %s. Query: %s', name, root, query)\n461         self.client.query('subscribe', root, name, query)\n462 \n463     def _subscribe_dir(self, directory, filenames):\n464         if not directory.exists():\n465             if not directory.parent.exists():\n466                 logger.warning('Unable to watch directory %s as neither it or its parent exist.', directory)\n467                 return\n468             prefix = 'files-parent-%s' % directory.name\n469             filenames = ['%s/%s' % (directory.name, filename) for filename in filenames]\n470             directory = directory.parent\n471             expression = ['name', filenames, 'wholename']\n472         else:\n473             prefix = 'files'\n474             expression = ['name', filenames]\n475         self._subscribe(directory, '%s:%s' % (prefix, directory), expression)\n476 \n477     def _watch_glob(self, directory, patterns):\n478         \"\"\"\n479         Watch a directory with a specific glob. If the directory doesn't yet\n480         exist, attempt to watch the parent directory and amend the patterns to\n481         include this. It's important this method isn't called more than one per\n482         directory when updating all subscriptions. Subsequent calls will\n483         overwrite the named subscription, so it must include all possible glob\n484         expressions.\n485         \"\"\"\n486         prefix = 'glob'\n487         if not directory.exists():\n488             if not directory.parent.exists():\n489                 logger.warning('Unable to watch directory %s as neither it or its parent exist.', directory)\n490                 return\n491             prefix = 'glob-parent-%s' % directory.name\n492             patterns = ['%s/%s' % (directory.name, pattern) for pattern in patterns]\n493             directory = directory.parent\n494 \n495         expression = ['anyof']\n496         for pattern in patterns:\n497             expression.append(['match', pattern, 'wholename'])\n498         self._subscribe(directory, '%s:%s' % (prefix, directory), expression)\n499 \n500     def watched_roots(self, watched_files):\n501         extra_directories = self.directory_globs.keys()\n502         watched_file_dirs = [f.parent for f in watched_files]\n503         sys_paths = list(sys_path_directories())\n504         return frozenset((*extra_directories, *watched_file_dirs, *sys_paths))\n505 \n506     def _update_watches(self):\n507         watched_files = list(self.watched_files(include_globs=False))\n508         found_roots = common_roots(self.watched_roots(watched_files))\n509         logger.debug('Watching %s files', len(watched_files))\n510         logger.debug('Found common roots: %s', found_roots)\n511         # Setup initial roots for performance, shortest roots first.\n512         for root in sorted(found_roots):\n513             self._watch_root(root)\n514         for directory, patterns in self.directory_globs.items():\n515             self._watch_glob(directory, patterns)\n516         # Group sorted watched_files by their parent directory.\n517         sorted_files = sorted(watched_files, key=lambda p: p.parent)\n518         for directory, group in itertools.groupby(sorted_files, key=lambda p: p.parent):\n519             # These paths need to be relative to the parent directory.\n520             self._subscribe_dir(directory, [str(p.relative_to(directory)) for p in group])\n521 \n522     def update_watches(self):\n523         try:\n524             self._update_watches()\n525         except Exception as ex:\n526             # If the service is still available, raise the original exception.\n527             if self.check_server_status(ex):\n528                 raise\n529 \n530     def _check_subscription(self, sub):\n531         subscription = self.client.getSubscription(sub)\n532         if not subscription:\n533             return\n534         logger.debug('Watchman subscription %s has results.', sub)\n535         for result in subscription:\n536             # When using watch-project, it's not simple to get the relative\n537             # directory without storing some specific state. Store the full\n538             # path to the directory in the subscription name, prefixed by its\n539             # type (glob, files).\n540             root_directory = Path(result['subscription'].split(':', 1)[1])\n541             logger.debug('Found root directory %s', root_directory)\n542             for file in result.get('files', []):\n543                 self.notify_file_changed(root_directory / file)\n544 \n545     def request_processed(self, **kwargs):\n546         logger.debug('Request processed. Setting update_watches event.')\n547         self.processed_request.set()\n548 \n549     def tick(self):\n550         request_finished.connect(self.request_processed)\n551         self.update_watches()\n552         while True:\n553             if self.processed_request.is_set():\n554                 self.update_watches()\n555                 self.processed_request.clear()\n556             try:\n557                 self.client.receive()\n558             except pywatchman.SocketTimeout:\n559                 pass\n560             except pywatchman.WatchmanError as ex:\n561                 logger.debug('Watchman error: %s, checking server status.', ex)\n562                 self.check_server_status(ex)\n563             else:\n564                 for sub in list(self.client.subs.keys()):\n565                     self._check_subscription(sub)\n566             yield\n567             # Protect against busy loops.\n568             time.sleep(0.1)\n569 \n570     def stop(self):\n571         self.client.close()\n572         super().stop()\n573 \n574     def check_server_status(self, inner_ex=None):\n575         \"\"\"Return True if the server is available.\"\"\"\n576         try:\n577             self.client.query('version')\n578         except Exception:\n579             raise WatchmanUnavailable(str(inner_ex)) from inner_ex\n580         return True\n581 \n582     @classmethod\n583     def check_availability(cls):\n584         if not pywatchman:\n585             raise WatchmanUnavailable('pywatchman not installed.')\n586         client = pywatchman.client(timeout=0.1)\n587         try:\n588             result = client.capabilityCheck()\n589         except Exception:\n590             # The service is down?\n591             raise WatchmanUnavailable('Cannot connect to the watchman service.')\n592         version = get_version_tuple(result['version'])\n593         # Watchman 4.9 includes multiple improvements to watching project\n594         # directories as well as case insensitive filesystems.\n595         logger.debug('Watchman version %s', version)\n596         if version < (4, 9):\n597             raise WatchmanUnavailable('Watchman 4.9 or later is required.')\n598 \n599 \n600 def get_reloader():\n601     \"\"\"Return the most suitable reloader for this environment.\"\"\"\n602     try:\n603         WatchmanReloader.check_availability()\n604     except WatchmanUnavailable:\n605         return StatReloader()\n606     return WatchmanReloader()\n607 \n608 \n609 def start_django(reloader, main_func, *args, **kwargs):\n610     ensure_echo_on()\n611 \n612     main_func = check_errors(main_func)\n613     django_main_thread = threading.Thread(target=main_func, args=args, kwargs=kwargs, name='django-main-thread')\n614     django_main_thread.daemon = True\n615     django_main_thread.start()\n616 \n617     while not reloader.should_stop:\n618         try:\n619             reloader.run(django_main_thread)\n620         except WatchmanUnavailable as ex:\n621             # It's possible that the watchman service shuts down or otherwise\n622             # becomes unavailable. In that case, use the StatReloader.\n623             reloader = StatReloader()\n624             logger.error('Error connecting to Watchman: %s', ex)\n625             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n626 \n627 \n628 def run_with_reloader(main_func, *args, **kwargs):\n629     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n630     try:\n631         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n632             reloader = get_reloader()\n633             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n634             start_django(reloader, main_func, *args, **kwargs)\n635         else:\n636             exit_code = restart_with_reloader()\n637             sys.exit(exit_code)\n638     except KeyboardInterrupt:\n639         pass\n",
        "intended_behavior": "The autoreload utility should have improved logic to handle dotted module names specified with the '-m' option, ensuring that it does not mistakenly reduce 'foo.bar.baz' to 'foo.bar'. This involves accurately tracking the module for changes without assuming it is a package unless it truly is. Enhancing the path resolution and change detection process within this utility will directly impact the ability to autoreload modules started in this manner."
    }
]