2025-10-15 04:26:15.604 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 04:26:18.863 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=158, output_tokens=12, cost=0.001940
2025-10-15 04:26:18.864 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 04:26:18.868 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:26:27.690 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=463, output_tokens=378, cost=0.015970
2025-10-15 04:26:27.740 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:26:29.574 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=48, cost=0.008760
2025-10-15 04:26:29.575 | DEBUG    | Extracted a valid json.
2025-10-15 04:26:29.576 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ModelAdmin\")",
        "search_method_in_class(\"date_hierarchy\", \"ModelAdmin\")",
        "search_code(\"timezone\")"
    ],
    "bug_locations": []
}
2025-10-15 04:26:29.936 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:26:29.936 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:26:47.007 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3170, output_tokens=713, cost=0.053090
2025-10-15 04:26:47.015 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:26:57.454 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4099, output_tokens=487, cost=0.055600
2025-10-15 04:26:57.464 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:27:06.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=841, output_tokens=354, cost=0.019030
2025-10-15 04:27:06.405 | DEBUG    | Extracted a valid json.
2025-10-15 04:27:06.405 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"changelist_view\", \"django/contrib/admin/options.py\")",
        "search_code_in_file(\"date_hierarchy\", \"django/contrib/admin/options.py\")",
        "search_method(\"get_changelist\")",
        "search_method_in_file(\"get_queryset\", \"django/contrib/admin/views/main.py\")"
    ],
    "bug_locations": [
        {
            "file": "django/contrib/admin/views/main.py",
            "class": "ChangeList",
            "method": "get_queryset",
            "intended_behavior": "This method should account for the user's timezone when applying the 'date_hierarchy' filter to ensure that the records returned match the month, day, or year currently selected by the user based on their local time. This might involve adjusting the start and end dates used in the filter to align with the timezone offset, ensuring that viewing the filter at the boundary doesn't introduce records from outside the intended date range. The implementation needs to apply the user's timezone to the datetime values before filtering the queryset."
        },
        {
            "file": "django/utils/timezone.py",
            "class": "",
            "method": "",
            "intended_behavior": "If not an existing issue within the handling of the queryset and more about how Django itself handles time zone conversions when filtering on datetime fields, an investigation here is to ensure that converting datetimes to the correct timezone before filter operations preserves intended filtering boundaries. Enhancements or bug fixes here should ensure that all datetime values, especially those defining boundaries for filters like 'date_hierarchy', are correctly localized to the user's timezone without introducing offsets that could widen or incorrectly shift the filter range."
        }
    ]
}
2025-10-15 04:27:06.499 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:27:06.500 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:27:29.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9705, output_tokens=812, cost=0.121410
2025-10-15 04:27:29.338 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:27:41.639 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10733, output_tokens=487, cost=0.121940
2025-10-15 04:27:41.644 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:27:50.701 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=841, output_tokens=363, cost=0.019300
2025-10-15 04:27:50.701 | DEBUG    | Extracted a valid json.
2025-10-15 04:27:50.701 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/contrib/admin/views/main.py",
            "class": "ChangeList",
            "method": "get_queryset",
            "intended_behavior": "Within the `get_queryset` method, adjustments should be made to respect the timezone of the user when filtering based on `date_hierarchy`. When constructing the date range filter, the start and end dates need to be localized to the user's timezone. This ensures the filtered results accurately reflect the dates relevant to the user's localized day, taking into account their timezone offset. Specifically, before applying filters generated from `date_hierarchy`, the code should ensure date boundaries are converted into the user's local timezone. This might involve integration with Django's timezone handling utilities to convert naive datetime objects to timezone-aware ones, specifically targeting the bounds used in `date_hierarchy` filtering."
        },
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "changelist_view",
            "intended_behavior": "The handling of the context for `date_hierarchy` within `changelist_view` may need to be revisited to ensure that the context's date hierarchy links are generated with awareness of the user's timezone. This might not involve changes within the `changelist_view` method itself but ensuring that any data passed to it, particularly variables related to date filters, are correctly timezone-aware. The goal is to maintain the functionality of generating hierarchical date filters (year, month, day) while ensuring the boundaries of these filters reflect the user's timezone. This would likely require collaboration with how the `ChangeList` class processes `date_hierarchy` to ensure consistent timezone application throughout."
        }
    ]
}
2025-10-15 04:27:50.711 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/views/main.py</file>
<class>ChangeList</class>
<method>get_queryset</method>
<code>
434     def get_queryset(self, request):
435         # First, we collect all the declared list filters.
436         (self.filter_specs, self.has_filters, remaining_lookup_params,
437          filters_use_distinct) = self.get_filters(request)
438 
439         # Then, we let every list filter modify the queryset to its liking.
440         qs = self.root_queryset
441         for filter_spec in self.filter_specs:
442             new_qs = filter_spec.queryset(request, qs)
443             if new_qs is not None:
444                 qs = new_qs
445 
446         try:
447             # Finally, we apply the remaining lookup parameters from the query
448             # string (i.e. those that haven't already been processed by the
449             # filters).
450             qs = qs.filter(**remaining_lookup_params)
451         except (SuspiciousOperation, ImproperlyConfigured):
452             # Allow certain types of errors to be re-raised as-is so that the
453             # caller can treat them in a special way.
454             raise
455         except Exception as e:
456             # Every other error is caught with a naked except, because we don't
457             # have any other way of validating lookup parameters. They might be
458             # invalid if the keyword arguments are incorrect, or if the values
459             # are not in the correct type, so we might get FieldError,
460             # ValueError, ValidationError, or ?.
461             raise IncorrectLookupParameters(e)
462 
463         if not qs.query.select_related:
464             qs = self.apply_select_related(qs)
465 
466         # Set ordering.
467         ordering = self.get_ordering(request, qs)
468         qs = qs.order_by(*ordering)
469 
470         # Apply search results
471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
472 
473         # Remove duplicates from results, if necessary
474         if filters_use_distinct | search_use_distinct:
475             return qs.distinct()
476         else:
477             return qs

</code><intended_behavior>Within the `get_queryset` method, adjustments should be made to respect the timezone of the user when filtering based on `date_hierarchy`. When constructing the date range filter, the start and end dates need to be localized to the user's timezone. This ensures the filtered results accurately reflect the dates relevant to the user's localized day, taking into account their timezone offset. Specifically, before applying filters generated from `date_hierarchy`, the code should ensure date boundaries are converted into the user's local timezone. This might involve integration with Django's timezone handling utilities to convert naive datetime objects to timezone-aware ones, specifically targeting the bounds used in `date_hierarchy` filtering.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>ChangeList</class>
<method>None</method>
<code>
48 class ChangeList:
49     search_form_class = ChangeListSearchForm
50 
51     def __init__(self, request, model, list_display, list_display_links,
52                  list_filter, date_hierarchy, search_fields, list_select_related,
53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):
54         self.model = model
55         self.opts = model._meta
56         self.lookup_opts = self.opts
57         self.root_queryset = model_admin.get_queryset(request)
58         self.list_display = list_display
59         self.list_display_links = list_display_links
60         self.list_filter = list_filter
61         self.has_filters = None
62         self.date_hierarchy = date_hierarchy
63         self.search_fields = search_fields
64         self.list_select_related = list_select_related
65         self.list_per_page = list_per_page
66         self.list_max_show_all = list_max_show_all
67         self.model_admin = model_admin
68         self.preserved_filters = model_admin.get_preserved_filters(request)
69         self.sortable_by = sortable_by
70 
71         # Get search parameters from the query string.
72         _search_form = self.search_form_class(request.GET)
73         if not _search_form.is_valid():
74             for error in _search_form.errors.values():
75                 messages.error(request, ', '.join(error))
76         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''
77         try:
78             self.page_num = int(request.GET.get(PAGE_VAR, 0))
79         except ValueError:
80             self.page_num = 0
81         self.show_all = ALL_VAR in request.GET
82         self.is_popup = IS_POPUP_VAR in request.GET
83         to_field = request.GET.get(TO_FIELD_VAR)
84         if to_field and not model_admin.to_field_allowed(request, to_field):
85             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
86         self.to_field = to_field
87         self.params = dict(request.GET.items())
88         if PAGE_VAR in self.params:
89             del self.params[PAGE_VAR]
90         if ERROR_FLAG in self.params:
91             del self.params[ERROR_FLAG]
92 
93         if self.is_popup:
94             self.list_editable = ()
95         else:
96             self.list_editable = list_editable
97         self.queryset = self.get_queryset(request)
98         self.get_results(request)
99         if self.is_popup:
100             title = gettext('Select %s')
101         elif self.model_admin.has_change_permission(request):
102             title = gettext('Select %s to change')
103         else:
104             title = gettext('Select %s to view')
105         self.title = title % self.opts.verbose_name
106         self.pk_attname = self.lookup_opts.pk.attname
107 
108     def get_filters_params(self, params=None):
109         """
110         Return all params except IGNORED_PARAMS.
111         """
112         params = params or self.params
113         lookup_params = params.copy()  # a dictionary of the query string
114         # Remove all the parameters that are globally and systematically
115         # ignored.
116         for ignored in IGNORED_PARAMS:
117             if ignored in lookup_params:
118                 del lookup_params[ignored]
119         return lookup_params
120 
121     def get_filters(self, request):
122         lookup_params = self.get_filters_params()
123         use_distinct = False
124 
125         for key, value in lookup_params.items():
126             if not self.model_admin.lookup_allowed(key, value):
127                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
128 
129         filter_specs = []
130         for list_filter in self.list_filter:
131             if callable(list_filter):
132                 # This is simply a custom list filter class.
133                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
134             else:
135                 field_path = None
136                 if isinstance(list_filter, (tuple, list)):
137                     # This is a custom FieldListFilter class for a given field.
138                     field, field_list_filter_class = list_filter
139                 else:
140                     # This is simply a field name, so use the default
141                     # FieldListFilter class that has been registered for the
142                     # type of the given field.
143                     field, field_list_filter_class = list_filter, FieldListFilter.create
144                 if not isinstance(field, Field):
145                     field_path = field
146                     field = get_fields_from_path(self.model, field_path)[-1]
147 
148                 lookup_params_count = len(lookup_params)
149                 spec = field_list_filter_class(
150                     field, request, lookup_params,
151                     self.model, self.model_admin, field_path=field_path,
152                 )
153                 # field_list_filter_class removes any lookup_params it
154                 # processes. If that happened, check if distinct() is needed to
155                 # remove duplicate results.
156                 if lookup_params_count > len(lookup_params):
157                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)
158             if spec and spec.has_output():
159                 filter_specs.append(spec)
160 
161         if self.date_hierarchy:
162             # Create bounded lookup parameters so that the query is more
163             # efficient.
164             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)
165             if year is not None:
166                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)
167                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)
168                 try:
169                     from_date = datetime(
170                         int(year),
171                         int(month if month is not None else 1),
172                         int(day if day is not None else 1),
173                     )
174                 except ValueError as e:
175                     raise IncorrectLookupParameters(e) from e
176                 if day:
177                     to_date = from_date + timedelta(days=1)
178                 elif month:
179                     # In this branch, from_date will always be the first of a
180                     # month, so advancing 32 days gives the next month.
181                     to_date = (from_date + timedelta(days=32)).replace(day=1)
182                 else:
183                     to_date = from_date.replace(year=from_date.year + 1)
184                 if settings.USE_TZ:
185                     from_date = make_aware(from_date)
186                     to_date = make_aware(to_date)
187                 lookup_params.update({
188                     '%s__gte' % self.date_hierarchy: from_date,
189                     '%s__lt' % self.date_hierarchy: to_date,
190                 })
191 
192         # At this point, all the parameters used by the various ListFilters
193         # have been removed from lookup_params, which now only contains other
194         # parameters passed via the query string. We now loop through the
195         # remaining parameters both to ensure that all the parameters are valid
196         # fields and to determine if at least one of them needs distinct(). If
197         # the lookup parameters aren't real fields, then bail out.
198         try:
199             for key, value in lookup_params.items():
200                 lookup_params[key] = prepare_lookup_value(key, value)
201                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)
202             return filter_specs, bool(filter_specs), lookup_params, use_distinct
203         except FieldDoesNotExist as e:
204             raise IncorrectLookupParameters(e) from e
205 
206     def get_query_string(self, new_params=None, remove=None):
207         if new_params is None:
208             new_params = {}
209         if remove is None:
210             remove = []
211         p = self.params.copy()
212         for r in remove:
213             for k in list(p):
214                 if k.startswith(r):
215                     del p[k]
216         for k, v in new_params.items():
217             if v is None:
218                 if k in p:
219                     del p[k]
220             else:
221                 p[k] = v
222         return '?%s' % urlencode(sorted(p.items()))
223 
224     def get_results(self, request):
225         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)
226         # Get the number of objects, with admin filters applied.
227         result_count = paginator.count
228 
229         # Get the total number of objects, with no admin filters applied.
230         if self.model_admin.show_full_result_count:
231             full_result_count = self.root_queryset.count()
232         else:
233             full_result_count = None
234         can_show_all = result_count <= self.list_max_show_all
235         multi_page = result_count > self.list_per_page
236 
237         # Get the list of objects to display on this page.
238         if (self.show_all and can_show_all) or not multi_page:
239             result_list = self.queryset._clone()
240         else:
241             try:
242                 result_list = paginator.page(self.page_num + 1).object_list
243             except InvalidPage:
244                 raise IncorrectLookupParameters
245 
246         self.result_count = result_count
247         self.show_full_result_count = self.model_admin.show_full_result_count
248         # Admin actions are shown if there is at least one entry
249         # or if entries are not counted because show_full_result_count is disabled
250         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)
251         self.full_result_count = full_result_count
252         self.result_list = result_list
253         self.can_show_all = can_show_all
254         self.multi_page = multi_page
255         self.paginator = paginator
256 
257     def _get_default_ordering(self):
258         ordering = []
259         if self.model_admin.ordering:
260             ordering = self.model_admin.ordering
261         elif self.lookup_opts.ordering:
262             ordering = self.lookup_opts.ordering
263         return ordering
264 
265     def get_ordering_field(self, field_name):
266         """
267         Return the proper model field name corresponding to the given
268         field_name to use for ordering. field_name may either be the name of a
269         proper model field or the name of a method (on the admin or model) or a
270         callable with the 'admin_order_field' attribute. Return None if no
271         proper model field name can be matched.
272         """
273         try:
274             field = self.lookup_opts.get_field(field_name)
275             return field.name
276         except FieldDoesNotExist:
277             # See whether field_name is a name of a non-field
278             # that allows sorting.
279             if callable(field_name):
280                 attr = field_name
281             elif hasattr(self.model_admin, field_name):
282                 attr = getattr(self.model_admin, field_name)
283             else:
284                 attr = getattr(self.model, field_name)
285             if isinstance(attr, property) and hasattr(attr, 'fget'):
286                 attr = attr.fget
287             return getattr(attr, 'admin_order_field', None)
288 
289     def get_ordering(self, request, queryset):
290         """
291         Return the list of ordering fields for the change list.
292         First check the get_ordering() method in model admin, then check
293         the object's default ordering. Then, any manually-specified ordering
294         from the query string overrides anything. Finally, a deterministic
295         order is guaranteed by calling _get_deterministic_ordering() with the
296         constructed ordering.
297         """
298         params = self.params
299         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())
300         if ORDER_VAR in params:
301             # Clear ordering and used params
302             ordering = []
303             order_params = params[ORDER_VAR].split('.')
304             for p in order_params:
305                 try:
306                     none, pfx, idx = p.rpartition('-')
307                     field_name = self.list_display[int(idx)]
308                     order_field = self.get_ordering_field(field_name)
309                     if not order_field:
310                         continue  # No 'admin_order_field', skip it
311                     if isinstance(order_field, OrderBy):
312                         if pfx == '-':
313                             order_field = order_field.copy()
314                             order_field.reverse_ordering()
315                         ordering.append(order_field)
316                     elif hasattr(order_field, 'resolve_expression'):
317                         # order_field is an expression.
318                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())
319                     # reverse order if order_field has already "-" as prefix
320                     elif order_field.startswith('-') and pfx == '-':
321                         ordering.append(order_field[1:])
322                     else:
323                         ordering.append(pfx + order_field)
324                 except (IndexError, ValueError):
325                     continue  # Invalid ordering specified, skip it.
326 
327         # Add the given query's ordering fields, if any.
328         ordering.extend(queryset.query.order_by)
329 
330         return self._get_deterministic_ordering(ordering)
331 
332     def _get_deterministic_ordering(self, ordering):
333         """
334         Ensure a deterministic order across all database backends. Search for a
335         single field or unique together set of fields providing a total
336         ordering. If these are missing, augment the ordering with a descendant
337         primary key.
338         """
339         ordering = list(ordering)
340         ordering_fields = set()
341         total_ordering_fields = {'pk'} | {
342             field.attname for field in self.lookup_opts.fields
343             if field.unique and not field.null
344         }
345         for part in ordering:
346             # Search for single field providing a total ordering.
347             field_name = None
348             if isinstance(part, str):
349                 field_name = part.lstrip('-')
350             elif isinstance(part, F):
351                 field_name = part.name
352             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
353                 field_name = part.expression.name
354             if field_name:
355                 # Normalize attname references by using get_field().
356                 try:
357                     field = self.lookup_opts.get_field(field_name)
358                 except FieldDoesNotExist:
359                     # Could be "?" for random ordering or a related field
360                     # lookup. Skip this part of introspection for now.
361                     continue
362                 # Ordering by a related field name orders by the referenced
363                 # model's ordering. Skip this part of introspection for now.
364                 if field.remote_field and field_name == field.name:
365                     continue
366                 if field.attname in total_ordering_fields:
367                     break
368                 ordering_fields.add(field.attname)
369         else:
370             # No single total ordering field, try unique_together and total
371             # unique constraints.
372             constraint_field_names = (
373                 *self.lookup_opts.unique_together,
374                 *(
375                     constraint.fields
376                     for constraint in self.lookup_opts.total_unique_constraints
377                 ),
378             )
379             for field_names in constraint_field_names:
380                 # Normalize attname references by using get_field().
381                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]
382                 # Composite unique constraints containing a nullable column
383                 # cannot ensure total ordering.
384                 if any(field.null for field in fields):
385                     continue
386                 if ordering_fields.issuperset(field.attname for field in fields):
387                     break
388             else:
389                 # If no set of unique fields is present in the ordering, rely
390                 # on the primary key to provide total ordering.
391                 ordering.append('-pk')
392         return ordering
393 
394     def get_ordering_field_columns(self):
395         """
396         Return a dictionary of ordering field column numbers and asc/desc.
397         """
398         # We must cope with more than one column having the same underlying sort
399         # field, so we base things on column numbers.
400         ordering = self._get_default_ordering()
401         ordering_fields = {}
402         if ORDER_VAR not in self.params:
403             # for ordering specified on ModelAdmin or model Meta, we don't know
404             # the right column numbers absolutely, because there might be more
405             # than one column associated with that ordering, so we guess.
406             for field in ordering:
407                 if isinstance(field, (Combinable, OrderBy)):
408                     if not isinstance(field, OrderBy):
409                         field = field.asc()
410                     if isinstance(field.expression, F):
411                         order_type = 'desc' if field.descending else 'asc'
412                         field = field.expression.name
413                     else:
414                         continue
415                 elif field.startswith('-'):
416                     field = field[1:]
417                     order_type = 'desc'
418                 else:
419                     order_type = 'asc'
420                 for index, attr in enumerate(self.list_display):
421                     if self.get_ordering_field(attr) == field:
422                         ordering_fields[index] = order_type
423                         break
424         else:
425             for p in self.params[ORDER_VAR].split('.'):
426                 none, pfx, idx = p.rpartition('-')
427                 try:
428                     idx = int(idx)
429                 except ValueError:
430                     continue  # skip it
431                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'
432         return ordering_fields
433 
434     def get_queryset(self, request):
435         # First, we collect all the declared list filters.
436         (self.filter_specs, self.has_filters, remaining_lookup_params,
437          filters_use_distinct) = self.get_filters(request)
438 
439         # Then, we let every list filter modify the queryset to its liking.
440         qs = self.root_queryset
441         for filter_spec in self.filter_specs:
442             new_qs = filter_spec.queryset(request, qs)
443             if new_qs is not None:
444                 qs = new_qs
445 
446         try:
447             # Finally, we apply the remaining lookup parameters from the query
448             # string (i.e. those that haven't already been processed by the
449             # filters).
450             qs = qs.filter(**remaining_lookup_params)
451         except (SuspiciousOperation, ImproperlyConfigured):
452             # Allow certain types of errors to be re-raised as-is so that the
453             # caller can treat them in a special way.
454             raise
455         except Exception as e:
456             # Every other error is caught with a naked except, because we don't
457             # have any other way of validating lookup parameters. They might be
458             # invalid if the keyword arguments are incorrect, or if the values
459             # are not in the correct type, so we might get FieldError,
460             # ValueError, ValidationError, or ?.
461             raise IncorrectLookupParameters(e)
462 
463         if not qs.query.select_related:
464             qs = self.apply_select_related(qs)
465 
466         # Set ordering.
467         ordering = self.get_ordering(request, qs)
468         qs = qs.order_by(*ordering)
469 
470         # Apply search results
471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
472 
473         # Remove duplicates from results, if necessary
474         if filters_use_distinct | search_use_distinct:
475             return qs.distinct()
476         else:
477             return qs
478 
479     def apply_select_related(self, qs):
480         if self.list_select_related is True:
481             return qs.select_related()
482 
483         if self.list_select_related is False:
484             if self.has_related_field_in_list_display():
485                 return qs.select_related()
486 
487         if self.list_select_related:
488             return qs.select_related(*self.list_select_related)
489         return qs
490 
491     def has_related_field_in_list_display(self):
492         for field_name in self.list_display:
493             try:
494                 field = self.lookup_opts.get_field(field_name)
495             except FieldDoesNotExist:
496                 pass
497             else:
498                 if isinstance(field.remote_field, ManyToOneRel):
499                     # <FK>_id field names don't require a join.
500                     if field_name != field.get_attname():
501                         return True
502         return False
503 
504     def url_for_result(self, result):
505         pk = getattr(result, self.pk_attname)
506         return reverse('admin:%s_%s_change' % (self.opts.app_label,
507                                                self.opts.model_name),
508                        args=(quote(pk),),
509                        current_app=self.model_admin.admin_site.name)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>changelist_view</method>
<code>
1669     def changelist_view(self, request, extra_context=None):
1670         """
1671         The 'change list' admin view for this model.
1672         """
1673         from django.contrib.admin.views.main import ERROR_FLAG
1674         opts = self.model._meta
1675         app_label = opts.app_label
1676         if not self.has_view_or_change_permission(request):
1677             raise PermissionDenied
1678 
1679         try:
1680             cl = self.get_changelist_instance(request)
1681         except IncorrectLookupParameters:
1682             # Wacky lookup parameters were given, so redirect to the main
1683             # changelist page, without parameters, and pass an 'invalid=1'
1684             # parameter via the query string. If wacky parameters were given
1685             # and the 'invalid=1' parameter was already in the query string,
1686             # something is screwed up with the database, so display an error
1687             # page.
1688             if ERROR_FLAG in request.GET:
1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1690                     'title': _('Database error'),
1691                 })
1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1693 
1694         # If the request was POSTed, this might be a bulk action or a bulk
1695         # edit. Try to look up an action or confirmation first, but if this
1696         # isn't an action the POST will fall through to the bulk edit check,
1697         # below.
1698         action_failed = False
1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1700 
1701         actions = self.get_actions(request)
1702         # Actions with no confirmation
1703         if (actions and request.method == 'POST' and
1704                 'index' in request.POST and '_save' not in request.POST):
1705             if selected:
1706                 response = self.response_action(request, queryset=cl.get_queryset(request))
1707                 if response:
1708                     return response
1709                 else:
1710                     action_failed = True
1711             else:
1712                 msg = _("Items must be selected in order to perform "
1713                         "actions on them. No items have been changed.")
1714                 self.message_user(request, msg, messages.WARNING)
1715                 action_failed = True
1716 
1717         # Actions with confirmation
1718         if (actions and request.method == 'POST' and
1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1720                 'index' not in request.POST and '_save' not in request.POST):
1721             if selected:
1722                 response = self.response_action(request, queryset=cl.get_queryset(request))
1723                 if response:
1724                     return response
1725                 else:
1726                     action_failed = True
1727 
1728         if action_failed:
1729             # Redirect back to the changelist page to avoid resubmitting the
1730             # form if the user refreshes the browser or uses the "No, take
1731             # me back" button on the action confirmation page.
1732             return HttpResponseRedirect(request.get_full_path())
1733 
1734         # If we're allowing changelist editing, we need to construct a formset
1735         # for the changelist given all the fields to be edited. Then we'll
1736         # use the formset to validate/process POSTed data.
1737         formset = cl.formset = None
1738 
1739         # Handle POSTed bulk-edit data.
1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1741             if not self.has_change_permission(request):
1742                 raise PermissionDenied
1743             FormSet = self.get_changelist_formset(request)
1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1746             if formset.is_valid():
1747                 changecount = 0
1748                 for form in formset.forms:
1749                     if form.has_changed():
1750                         obj = self.save_form(request, form, change=True)
1751                         self.save_model(request, obj, form, change=True)
1752                         self.save_related(request, form, formsets=[], change=True)
1753                         change_msg = self.construct_change_message(request, form, None)
1754                         self.log_change(request, obj, change_msg)
1755                         changecount += 1
1756 
1757                 if changecount:
1758                     msg = ngettext(
1759                         "%(count)s %(name)s was changed successfully.",
1760                         "%(count)s %(name)s were changed successfully.",
1761                         changecount
1762                     ) % {
1763                         'count': changecount,
1764                         'name': model_ngettext(opts, changecount),
1765                     }
1766                     self.message_user(request, msg, messages.SUCCESS)
1767 
1768                 return HttpResponseRedirect(request.get_full_path())
1769 
1770         # Handle GET -- construct a formset for display.
1771         elif cl.list_editable and self.has_change_permission(request):
1772             FormSet = self.get_changelist_formset(request)
1773             formset = cl.formset = FormSet(queryset=cl.result_list)
1774 
1775         # Build the list of media to be used by the formset.
1776         if formset:
1777             media = self.media + formset.media
1778         else:
1779             media = self.media
1780 
1781         # Build the action form and populate it with available actions.
1782         if actions:
1783             action_form = self.action_form(auto_id=None)
1784             action_form.fields['action'].choices = self.get_action_choices(request)
1785             media += action_form.media
1786         else:
1787             action_form = None
1788 
1789         selection_note_all = ngettext(
1790             '%(total_count)s selected',
1791             'All %(total_count)s selected',
1792             cl.result_count
1793         )
1794 
1795         context = {
1796             **self.admin_site.each_context(request),
1797             'module_name': str(opts.verbose_name_plural),
1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1800             'title': cl.title,
1801             'is_popup': cl.is_popup,
1802             'to_field': cl.to_field,
1803             'cl': cl,
1804             'media': media,
1805             'has_add_permission': self.has_add_permission(request),
1806             'opts': cl.opts,
1807             'action_form': action_form,
1808             'actions_on_top': self.actions_on_top,
1809             'actions_on_bottom': self.actions_on_bottom,
1810             'actions_selection_counter': self.actions_selection_counter,
1811             'preserved_filters': self.get_preserved_filters(request),
1812             **(extra_context or {}),
1813         }
1814 
1815         request.current_app = self.admin_site.name
1816 
1817         return TemplateResponse(request, self.change_list_template or [
1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1819             'admin/%s/change_list.html' % app_label,
1820             'admin/change_list.html'
1821         ], context)

</code><intended_behavior>The handling of the context for `date_hierarchy` within `changelist_view` may need to be revisited to ensure that the context's date hierarchy links are generated with awareness of the user's timezone. This might not involve changes within the `changelist_view` method itself but ensuring that any data passed to it, particularly variables related to date filters, are correctly timezone-aware. The goal is to maintain the functionality of generating hierarchical date filters (year, month, day) while ensuring the boundaries of these filters reflect the user's timezone. This would likely require collaboration with how the `ChangeList` class processes `date_hierarchy` to ensure consistent timezone application throughout.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
541 class ModelAdmin(BaseModelAdmin):
542     """Encapsulate all admin options and functionality for a given model."""
543 
544     list_display = ('__str__',)
545     list_display_links = ()
546     list_filter = ()
547     list_select_related = False
548     list_per_page = 100
549     list_max_show_all = 200
550     list_editable = ()
551     search_fields = ()
552     date_hierarchy = None
553     save_as = False
554     save_as_continue = True
555     save_on_top = False
556     paginator = Paginator
557     preserve_filters = True
558     inlines = []
559 
560     # Custom templates (designed to be over-ridden in subclasses)
561     add_form_template = None
562     change_form_template = None
563     change_list_template = None
564     delete_confirmation_template = None
565     delete_selected_confirmation_template = None
566     object_history_template = None
567     popup_response_template = None
568 
569     # Actions
570     actions = []
571     action_form = helpers.ActionForm
572     actions_on_top = True
573     actions_on_bottom = False
574     actions_selection_counter = True
575     checks_class = ModelAdminChecks
576 
577     def __init__(self, model, admin_site):
578         self.model = model
579         self.opts = model._meta
580         self.admin_site = admin_site
581         super().__init__()
582 
583     def __str__(self):
584         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
585 
586     def get_inline_instances(self, request, obj=None):
587         inline_instances = []
588         for inline_class in self.get_inlines(request, obj):
589             inline = inline_class(self.model, self.admin_site)
590             if request:
591                 if not (inline.has_view_or_change_permission(request, obj) or
592                         inline.has_add_permission(request, obj) or
593                         inline.has_delete_permission(request, obj)):
594                     continue
595                 if not inline.has_add_permission(request, obj):
596                     inline.max_num = 0
597             inline_instances.append(inline)
598 
599         return inline_instances
600 
601     def get_urls(self):
602         from django.urls import path
603 
604         def wrap(view):
605             def wrapper(*args, **kwargs):
606                 return self.admin_site.admin_view(view)(*args, **kwargs)
607             wrapper.model_admin = self
608             return update_wrapper(wrapper, view)
609 
610         info = self.model._meta.app_label, self.model._meta.model_name
611 
612         return [
613             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
614             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
615             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
616             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
617             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
618             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
619             # For backwards compatibility (was the change url before 1.9)
620             path('<path:object_id>/', wrap(RedirectView.as_view(
621                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
622             ))),
623         ]
624 
625     @property
626     def urls(self):
627         return self.get_urls()
628 
629     @property
630     def media(self):
631         extra = '' if settings.DEBUG else '.min'
632         js = [
633             'vendor/jquery/jquery%s.js' % extra,
634             'jquery.init.js',
635             'core.js',
636             'admin/RelatedObjectLookups.js',
637             'actions%s.js' % extra,
638             'urlify.js',
639             'prepopulate%s.js' % extra,
640             'vendor/xregexp/xregexp%s.js' % extra,
641         ]
642         return forms.Media(js=['admin/js/%s' % url for url in js])
643 
644     def get_model_perms(self, request):
645         """
646         Return a dict of all perms for this model. This dict has the keys
647         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
648         for each of those actions.
649         """
650         return {
651             'add': self.has_add_permission(request),
652             'change': self.has_change_permission(request),
653             'delete': self.has_delete_permission(request),
654             'view': self.has_view_permission(request),
655         }
656 
657     def _get_form_for_get_fields(self, request, obj):
658         return self.get_form(request, obj, fields=None)
659 
660     def get_form(self, request, obj=None, change=False, **kwargs):
661         """
662         Return a Form class for use in the admin add view. This is used by
663         add_view and change_view.
664         """
665         if 'fields' in kwargs:
666             fields = kwargs.pop('fields')
667         else:
668             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
669         excluded = self.get_exclude(request, obj)
670         exclude = [] if excluded is None else list(excluded)
671         readonly_fields = self.get_readonly_fields(request, obj)
672         exclude.extend(readonly_fields)
673         # Exclude all fields if it's a change form and the user doesn't have
674         # the change permission.
675         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
676             exclude.extend(fields)
677         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
678             # Take the custom ModelForm's Meta.exclude into account only if the
679             # ModelAdmin doesn't define its own.
680             exclude.extend(self.form._meta.exclude)
681         # if exclude is an empty list we pass None to be consistent with the
682         # default on modelform_factory
683         exclude = exclude or None
684 
685         # Remove declared form fields which are in readonly_fields.
686         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
687         form = type(self.form.__name__, (self.form,), new_attrs)
688 
689         defaults = {
690             'form': form,
691             'fields': fields,
692             'exclude': exclude,
693             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
694             **kwargs,
695         }
696 
697         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
698             defaults['fields'] = forms.ALL_FIELDS
699 
700         try:
701             return modelform_factory(self.model, **defaults)
702         except FieldError as e:
703             raise FieldError(
704                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
705                 % (e, self.__class__.__name__)
706             )
707 
708     def get_changelist(self, request, **kwargs):
709         """
710         Return the ChangeList class for use on the changelist page.
711         """
712         from django.contrib.admin.views.main import ChangeList
713         return ChangeList
714 
715     def get_changelist_instance(self, request):
716         """
717         Return a `ChangeList` instance based on `request`. May raise
718         `IncorrectLookupParameters`.
719         """
720         list_display = self.get_list_display(request)
721         list_display_links = self.get_list_display_links(request, list_display)
722         # Add the action checkboxes if any actions are available.
723         if self.get_actions(request):
724             list_display = ['action_checkbox', *list_display]
725         sortable_by = self.get_sortable_by(request)
726         ChangeList = self.get_changelist(request)
727         return ChangeList(
728             request,
729             self.model,
730             list_display,
731             list_display_links,
732             self.get_list_filter(request),
733             self.date_hierarchy,
734             self.get_search_fields(request),
735             self.get_list_select_related(request),
736             self.list_per_page,
737             self.list_max_show_all,
738             self.list_editable,
739             self,
740             sortable_by,
741         )
742 
743     def get_object(self, request, object_id, from_field=None):
744         """
745         Return an instance matching the field and value provided, the primary
746         key is used if no field is provided. Return ``None`` if no match is
747         found or the object_id fails validation.
748         """
749         queryset = self.get_queryset(request)
750         model = queryset.model
751         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
752         try:
753             object_id = field.to_python(object_id)
754             return queryset.get(**{field.name: object_id})
755         except (model.DoesNotExist, ValidationError, ValueError):
756             return None
757 
758     def get_changelist_form(self, request, **kwargs):
759         """
760         Return a Form class for use in the Formset on the changelist page.
761         """
762         defaults = {
763             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
764             **kwargs,
765         }
766         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
767             defaults['fields'] = forms.ALL_FIELDS
768 
769         return modelform_factory(self.model, **defaults)
770 
771     def get_changelist_formset(self, request, **kwargs):
772         """
773         Return a FormSet class for use on the changelist page if list_editable
774         is used.
775         """
776         defaults = {
777             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
778             **kwargs,
779         }
780         return modelformset_factory(
781             self.model, self.get_changelist_form(request), extra=0,
782             fields=self.list_editable, **defaults
783         )
784 
785     def get_formsets_with_inlines(self, request, obj=None):
786         """
787         Yield formsets and the corresponding inlines.
788         """
789         for inline in self.get_inline_instances(request, obj):
790             yield inline.get_formset(request, obj), inline
791 
792     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
793         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
794 
795     def log_addition(self, request, object, message):
796         """
797         Log that an object has been successfully added.
798 
799         The default implementation creates an admin LogEntry object.
800         """
801         from django.contrib.admin.models import LogEntry, ADDITION
802         return LogEntry.objects.log_action(
803             user_id=request.user.pk,
804             content_type_id=get_content_type_for_model(object).pk,
805             object_id=object.pk,
806             object_repr=str(object),
807             action_flag=ADDITION,
808             change_message=message,
809         )
810 
811     def log_change(self, request, object, message):
812         """
813         Log that an object has been successfully changed.
814 
815         The default implementation creates an admin LogEntry object.
816         """
817         from django.contrib.admin.models import LogEntry, CHANGE
818         return LogEntry.objects.log_action(
819             user_id=request.user.pk,
820             content_type_id=get_content_type_for_model(object).pk,
821             object_id=object.pk,
822             object_repr=str(object),
823             action_flag=CHANGE,
824             change_message=message,
825         )
826 
827     def log_deletion(self, request, object, object_repr):
828         """
829         Log that an object will be deleted. Note that this method must be
830         called before the deletion.
831 
832         The default implementation creates an admin LogEntry object.
833         """
834         from django.contrib.admin.models import LogEntry, DELETION
835         return LogEntry.objects.log_action(
836             user_id=request.user.pk,
837             content_type_id=get_content_type_for_model(object).pk,
838             object_id=object.pk,
839             object_repr=object_repr,
840             action_flag=DELETION,
841         )
842 
843     def action_checkbox(self, obj):
844         """
845         A list_display column containing a checkbox widget.
846         """
847         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
848     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
849 
850     def _get_base_actions(self):
851         """Return the list of actions, prior to any request-based filtering."""
852         actions = []
853 
854         # Gather actions from the admin site first
855         for (name, func) in self.admin_site.actions:
856             description = getattr(func, 'short_description', name.replace('_', ' '))
857             actions.append((func, name, description))
858         # Add actions from this ModelAdmin.
859         actions.extend(self.get_action(action) for action in self.actions or [])
860         # get_action might have returned None, so filter any of those out.
861         return filter(None, actions)
862 
863     def _filter_actions_by_permissions(self, request, actions):
864         """Filter out any actions that the user doesn't have access to."""
865         filtered_actions = []
866         for action in actions:
867             callable = action[0]
868             if not hasattr(callable, 'allowed_permissions'):
869                 filtered_actions.append(action)
870                 continue
871             permission_checks = (
872                 getattr(self, 'has_%s_permission' % permission)
873                 for permission in callable.allowed_permissions
874             )
875             if any(has_permission(request) for has_permission in permission_checks):
876                 filtered_actions.append(action)
877         return filtered_actions
878 
879     def get_actions(self, request):
880         """
881         Return a dictionary mapping the names of all actions for this
882         ModelAdmin to a tuple of (callable, name, description) for each action.
883         """
884         # If self.actions is set to None that means actions are disabled on
885         # this page.
886         if self.actions is None or IS_POPUP_VAR in request.GET:
887             return {}
888         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
889         return {name: (func, name, desc) for func, name, desc in actions}
890 
891     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
892         """
893         Return a list of choices for use in a form object.  Each choice is a
894         tuple (name, description).
895         """
896         choices = [] + default_choices
897         for func, name, description in self.get_actions(request).values():
898             choice = (name, description % model_format_dict(self.opts))
899             choices.append(choice)
900         return choices
901 
902     def get_action(self, action):
903         """
904         Return a given action from a parameter, which can either be a callable,
905         or the name of a method on the ModelAdmin.  Return is a tuple of
906         (callable, name, description).
907         """
908         # If the action is a callable, just use it.
909         if callable(action):
910             func = action
911             action = action.__name__
912 
913         # Next, look for a method. Grab it off self.__class__ to get an unbound
914         # method instead of a bound one; this ensures that the calling
915         # conventions are the same for functions and methods.
916         elif hasattr(self.__class__, action):
917             func = getattr(self.__class__, action)
918 
919         # Finally, look for a named method on the admin site
920         else:
921             try:
922                 func = self.admin_site.get_action(action)
923             except KeyError:
924                 return None
925 
926         if hasattr(func, 'short_description'):
927             description = func.short_description
928         else:
929             description = capfirst(action.replace('_', ' '))
930         return func, action, description
931 
932     def get_list_display(self, request):
933         """
934         Return a sequence containing the fields to be displayed on the
935         changelist.
936         """
937         return self.list_display
938 
939     def get_list_display_links(self, request, list_display):
940         """
941         Return a sequence containing the fields to be displayed as links
942         on the changelist. The list_display parameter is the list of fields
943         returned by get_list_display().
944         """
945         if self.list_display_links or self.list_display_links is None or not list_display:
946             return self.list_display_links
947         else:
948             # Use only the first item in list_display as link
949             return list(list_display)[:1]
950 
951     def get_list_filter(self, request):
952         """
953         Return a sequence containing the fields to be displayed as filters in
954         the right sidebar of the changelist page.
955         """
956         return self.list_filter
957 
958     def get_list_select_related(self, request):
959         """
960         Return a list of fields to add to the select_related() part of the
961         changelist items query.
962         """
963         return self.list_select_related
964 
965     def get_search_fields(self, request):
966         """
967         Return a sequence containing the fields to be searched whenever
968         somebody submits a search query.
969         """
970         return self.search_fields
971 
972     def get_search_results(self, request, queryset, search_term):
973         """
974         Return a tuple containing a queryset to implement the search
975         and a boolean indicating if the results may contain duplicates.
976         """
977         # Apply keyword searches.
978         def construct_search(field_name):
979             if field_name.startswith('^'):
980                 return "%s__istartswith" % field_name[1:]
981             elif field_name.startswith('='):
982                 return "%s__iexact" % field_name[1:]
983             elif field_name.startswith('@'):
984                 return "%s__search" % field_name[1:]
985             # Use field_name if it includes a lookup.
986             opts = queryset.model._meta
987             lookup_fields = field_name.split(LOOKUP_SEP)
988             # Go through the fields, following all relations.
989             prev_field = None
990             for path_part in lookup_fields:
991                 if path_part == 'pk':
992                     path_part = opts.pk.name
993                 try:
994                     field = opts.get_field(path_part)
995                 except FieldDoesNotExist:
996                     # Use valid query lookups.
997                     if prev_field and prev_field.get_lookup(path_part):
998                         return field_name
999                 else:
1000                     prev_field = field
1001                     if hasattr(field, 'get_path_info'):
1002                         # Update opts to follow the relation.
1003                         opts = field.get_path_info()[-1].to_opts
1004             # Otherwise, use the field with icontains.
1005             return "%s__icontains" % field_name
1006 
1007         use_distinct = False
1008         search_fields = self.get_search_fields(request)
1009         if search_fields and search_term:
1010             orm_lookups = [construct_search(str(search_field))
1011                            for search_field in search_fields]
1012             for bit in search_term.split():
1013                 or_queries = [models.Q(**{orm_lookup: bit})
1014                               for orm_lookup in orm_lookups]
1015                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1016             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1017 
1018         return queryset, use_distinct
1019 
1020     def get_preserved_filters(self, request):
1021         """
1022         Return the preserved filters querystring.
1023         """
1024         match = request.resolver_match
1025         if self.preserve_filters and match:
1026             opts = self.model._meta
1027             current_url = '%s:%s' % (match.app_name, match.url_name)
1028             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1029             if current_url == changelist_url:
1030                 preserved_filters = request.GET.urlencode()
1031             else:
1032                 preserved_filters = request.GET.get('_changelist_filters')
1033 
1034             if preserved_filters:
1035                 return urlencode({'_changelist_filters': preserved_filters})
1036         return ''
1037 
1038     def construct_change_message(self, request, form, formsets, add=False):
1039         """
1040         Construct a JSON structure describing changes from a changed object.
1041         """
1042         return construct_change_message(form, formsets, add)
1043 
1044     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1045                      fail_silently=False):
1046         """
1047         Send a message to the user. The default implementation
1048         posts a message using the django.contrib.messages backend.
1049 
1050         Exposes almost the same API as messages.add_message(), but accepts the
1051         positional arguments in a different order to maintain backwards
1052         compatibility. For convenience, it accepts the `level` argument as
1053         a string rather than the usual level number.
1054         """
1055         if not isinstance(level, int):
1056             # attempt to get the level if passed a string
1057             try:
1058                 level = getattr(messages.constants, level.upper())
1059             except AttributeError:
1060                 levels = messages.constants.DEFAULT_TAGS.values()
1061                 levels_repr = ', '.join('`%s`' % l for l in levels)
1062                 raise ValueError(
1063                     'Bad message level string: `%s`. Possible values are: %s'
1064                     % (level, levels_repr)
1065                 )
1066 
1067         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1068 
1069     def save_form(self, request, form, change):
1070         """
1071         Given a ModelForm return an unsaved instance. ``change`` is True if
1072         the object is being changed, and False if it's being added.
1073         """
1074         return form.save(commit=False)
1075 
1076     def save_model(self, request, obj, form, change):
1077         """
1078         Given a model instance save it to the database.
1079         """
1080         obj.save()
1081 
1082     def delete_model(self, request, obj):
1083         """
1084         Given a model instance delete it from the database.
1085         """
1086         obj.delete()
1087 
1088     def delete_queryset(self, request, queryset):
1089         """Given a queryset, delete it from the database."""
1090         queryset.delete()
1091 
1092     def save_formset(self, request, form, formset, change):
1093         """
1094         Given an inline formset save it to the database.
1095         """
1096         formset.save()
1097 
1098     def save_related(self, request, form, formsets, change):
1099         """
1100         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1101         list of inline formsets and a boolean value based on whether the
1102         parent is being added or changed, save the related objects to the
1103         database. Note that at this point save_form() and save_model() have
1104         already been called.
1105         """
1106         form.save_m2m()
1107         for formset in formsets:
1108             self.save_formset(request, form, formset, change=change)
1109 
1110     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1111         opts = self.model._meta
1112         app_label = opts.app_label
1113         preserved_filters = self.get_preserved_filters(request)
1114         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1115         view_on_site_url = self.get_view_on_site_url(obj)
1116         has_editable_inline_admin_formsets = False
1117         for inline in context['inline_admin_formsets']:
1118             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1119                 has_editable_inline_admin_formsets = True
1120                 break
1121         context.update({
1122             'add': add,
1123             'change': change,
1124             'has_view_permission': self.has_view_permission(request, obj),
1125             'has_add_permission': self.has_add_permission(request),
1126             'has_change_permission': self.has_change_permission(request, obj),
1127             'has_delete_permission': self.has_delete_permission(request, obj),
1128             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1129             'has_file_field': context['adminform'].form.is_multipart() or any(
1130                 admin_formset.formset.is_multipart()
1131                 for admin_formset in context['inline_admin_formsets']
1132             ),
1133             'has_absolute_url': view_on_site_url is not None,
1134             'absolute_url': view_on_site_url,
1135             'form_url': form_url,
1136             'opts': opts,
1137             'content_type_id': get_content_type_for_model(self.model).pk,
1138             'save_as': self.save_as,
1139             'save_on_top': self.save_on_top,
1140             'to_field_var': TO_FIELD_VAR,
1141             'is_popup_var': IS_POPUP_VAR,
1142             'app_label': app_label,
1143         })
1144         if add and self.add_form_template is not None:
1145             form_template = self.add_form_template
1146         else:
1147             form_template = self.change_form_template
1148 
1149         request.current_app = self.admin_site.name
1150 
1151         return TemplateResponse(request, form_template or [
1152             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1153             "admin/%s/change_form.html" % app_label,
1154             "admin/change_form.html"
1155         ], context)
1156 
1157     def response_add(self, request, obj, post_url_continue=None):
1158         """
1159         Determine the HttpResponse for the add_view stage.
1160         """
1161         opts = obj._meta
1162         preserved_filters = self.get_preserved_filters(request)
1163         obj_url = reverse(
1164             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1165             args=(quote(obj.pk),),
1166             current_app=self.admin_site.name,
1167         )
1168         # Add a link to the object's change form if the user can edit the obj.
1169         if self.has_change_permission(request, obj):
1170             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1171         else:
1172             obj_repr = str(obj)
1173         msg_dict = {
1174             'name': opts.verbose_name,
1175             'obj': obj_repr,
1176         }
1177         # Here, we distinguish between different save types by checking for
1178         # the presence of keys in request.POST.
1179 
1180         if IS_POPUP_VAR in request.POST:
1181             to_field = request.POST.get(TO_FIELD_VAR)
1182             if to_field:
1183                 attr = str(to_field)
1184             else:
1185                 attr = obj._meta.pk.attname
1186             value = obj.serializable_value(attr)
1187             popup_response_data = json.dumps({
1188                 'value': str(value),
1189                 'obj': str(obj),
1190             })
1191             return TemplateResponse(request, self.popup_response_template or [
1192                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1193                 'admin/%s/popup_response.html' % opts.app_label,
1194                 'admin/popup_response.html',
1195             ], {
1196                 'popup_response_data': popup_response_data,
1197             })
1198 
1199         elif "_continue" in request.POST or (
1200                 # Redirecting after "Save as new".
1201                 "_saveasnew" in request.POST and self.save_as_continue and
1202                 self.has_change_permission(request, obj)
1203         ):
1204             msg = _('The {name} “{obj}” was added successfully.')
1205             if self.has_change_permission(request, obj):
1206                 msg += ' ' + _('You may edit it again below.')
1207             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1208             if post_url_continue is None:
1209                 post_url_continue = obj_url
1210             post_url_continue = add_preserved_filters(
1211                 {'preserved_filters': preserved_filters, 'opts': opts},
1212                 post_url_continue
1213             )
1214             return HttpResponseRedirect(post_url_continue)
1215 
1216         elif "_addanother" in request.POST:
1217             msg = format_html(
1218                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1219                 **msg_dict
1220             )
1221             self.message_user(request, msg, messages.SUCCESS)
1222             redirect_url = request.path
1223             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1224             return HttpResponseRedirect(redirect_url)
1225 
1226         else:
1227             msg = format_html(
1228                 _('The {name} “{obj}” was added successfully.'),
1229                 **msg_dict
1230             )
1231             self.message_user(request, msg, messages.SUCCESS)
1232             return self.response_post_save_add(request, obj)
1233 
1234     def response_change(self, request, obj):
1235         """
1236         Determine the HttpResponse for the change_view stage.
1237         """
1238 
1239         if IS_POPUP_VAR in request.POST:
1240             opts = obj._meta
1241             to_field = request.POST.get(TO_FIELD_VAR)
1242             attr = str(to_field) if to_field else opts.pk.attname
1243             value = request.resolver_match.kwargs['object_id']
1244             new_value = obj.serializable_value(attr)
1245             popup_response_data = json.dumps({
1246                 'action': 'change',
1247                 'value': str(value),
1248                 'obj': str(obj),
1249                 'new_value': str(new_value),
1250             })
1251             return TemplateResponse(request, self.popup_response_template or [
1252                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1253                 'admin/%s/popup_response.html' % opts.app_label,
1254                 'admin/popup_response.html',
1255             ], {
1256                 'popup_response_data': popup_response_data,
1257             })
1258 
1259         opts = self.model._meta
1260         preserved_filters = self.get_preserved_filters(request)
1261 
1262         msg_dict = {
1263             'name': opts.verbose_name,
1264             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1265         }
1266         if "_continue" in request.POST:
1267             msg = format_html(
1268                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1269                 **msg_dict
1270             )
1271             self.message_user(request, msg, messages.SUCCESS)
1272             redirect_url = request.path
1273             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1274             return HttpResponseRedirect(redirect_url)
1275 
1276         elif "_saveasnew" in request.POST:
1277             msg = format_html(
1278                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1279                 **msg_dict
1280             )
1281             self.message_user(request, msg, messages.SUCCESS)
1282             redirect_url = reverse('admin:%s_%s_change' %
1283                                    (opts.app_label, opts.model_name),
1284                                    args=(obj.pk,),
1285                                    current_app=self.admin_site.name)
1286             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1287             return HttpResponseRedirect(redirect_url)
1288 
1289         elif "_addanother" in request.POST:
1290             msg = format_html(
1291                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1292                 **msg_dict
1293             )
1294             self.message_user(request, msg, messages.SUCCESS)
1295             redirect_url = reverse('admin:%s_%s_add' %
1296                                    (opts.app_label, opts.model_name),
1297                                    current_app=self.admin_site.name)
1298             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1299             return HttpResponseRedirect(redirect_url)
1300 
1301         else:
1302             msg = format_html(
1303                 _('The {name} “{obj}” was changed successfully.'),
1304                 **msg_dict
1305             )
1306             self.message_user(request, msg, messages.SUCCESS)
1307             return self.response_post_save_change(request, obj)
1308 
1309     def _response_post_save(self, request, obj):
1310         opts = self.model._meta
1311         if self.has_view_or_change_permission(request):
1312             post_url = reverse('admin:%s_%s_changelist' %
1313                                (opts.app_label, opts.model_name),
1314                                current_app=self.admin_site.name)
1315             preserved_filters = self.get_preserved_filters(request)
1316             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1317         else:
1318             post_url = reverse('admin:index',
1319                                current_app=self.admin_site.name)
1320         return HttpResponseRedirect(post_url)
1321 
1322     def response_post_save_add(self, request, obj):
1323         """
1324         Figure out where to redirect after the 'Save' button has been pressed
1325         when adding a new object.
1326         """
1327         return self._response_post_save(request, obj)
1328 
1329     def response_post_save_change(self, request, obj):
1330         """
1331         Figure out where to redirect after the 'Save' button has been pressed
1332         when editing an existing object.
1333         """
1334         return self._response_post_save(request, obj)
1335 
1336     def response_action(self, request, queryset):
1337         """
1338         Handle an admin action. This is called if a request is POSTed to the
1339         changelist; it returns an HttpResponse if the action was handled, and
1340         None otherwise.
1341         """
1342 
1343         # There can be multiple action forms on the page (at the top
1344         # and bottom of the change list, for example). Get the action
1345         # whose button was pushed.
1346         try:
1347             action_index = int(request.POST.get('index', 0))
1348         except ValueError:
1349             action_index = 0
1350 
1351         # Construct the action form.
1352         data = request.POST.copy()
1353         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1354         data.pop("index", None)
1355 
1356         # Use the action whose button was pushed
1357         try:
1358             data.update({'action': data.getlist('action')[action_index]})
1359         except IndexError:
1360             # If we didn't get an action from the chosen form that's invalid
1361             # POST data, so by deleting action it'll fail the validation check
1362             # below. So no need to do anything here
1363             pass
1364 
1365         action_form = self.action_form(data, auto_id=None)
1366         action_form.fields['action'].choices = self.get_action_choices(request)
1367 
1368         # If the form's valid we can handle the action.
1369         if action_form.is_valid():
1370             action = action_form.cleaned_data['action']
1371             select_across = action_form.cleaned_data['select_across']
1372             func = self.get_actions(request)[action][0]
1373 
1374             # Get the list of selected PKs. If nothing's selected, we can't
1375             # perform an action on it, so bail. Except we want to perform
1376             # the action explicitly on all objects.
1377             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1378             if not selected and not select_across:
1379                 # Reminder that something needs to be selected or nothing will happen
1380                 msg = _("Items must be selected in order to perform "
1381                         "actions on them. No items have been changed.")
1382                 self.message_user(request, msg, messages.WARNING)
1383                 return None
1384 
1385             if not select_across:
1386                 # Perform the action only on the selected objects
1387                 queryset = queryset.filter(pk__in=selected)
1388 
1389             response = func(self, request, queryset)
1390 
1391             # Actions may return an HttpResponse-like object, which will be
1392             # used as the response from the POST. If not, we'll be a good
1393             # little HTTP citizen and redirect back to the changelist page.
1394             if isinstance(response, HttpResponseBase):
1395                 return response
1396             else:
1397                 return HttpResponseRedirect(request.get_full_path())
1398         else:
1399             msg = _("No action selected.")
1400             self.message_user(request, msg, messages.WARNING)
1401             return None
1402 
1403     def response_delete(self, request, obj_display, obj_id):
1404         """
1405         Determine the HttpResponse for the delete_view stage.
1406         """
1407         opts = self.model._meta
1408 
1409         if IS_POPUP_VAR in request.POST:
1410             popup_response_data = json.dumps({
1411                 'action': 'delete',
1412                 'value': str(obj_id),
1413             })
1414             return TemplateResponse(request, self.popup_response_template or [
1415                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1416                 'admin/%s/popup_response.html' % opts.app_label,
1417                 'admin/popup_response.html',
1418             ], {
1419                 'popup_response_data': popup_response_data,
1420             })
1421 
1422         self.message_user(
1423             request,
1424             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1425                 'name': opts.verbose_name,
1426                 'obj': obj_display,
1427             },
1428             messages.SUCCESS,
1429         )
1430 
1431         if self.has_change_permission(request, None):
1432             post_url = reverse(
1433                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1434                 current_app=self.admin_site.name,
1435             )
1436             preserved_filters = self.get_preserved_filters(request)
1437             post_url = add_preserved_filters(
1438                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1439             )
1440         else:
1441             post_url = reverse('admin:index', current_app=self.admin_site.name)
1442         return HttpResponseRedirect(post_url)
1443 
1444     def render_delete_form(self, request, context):
1445         opts = self.model._meta
1446         app_label = opts.app_label
1447 
1448         request.current_app = self.admin_site.name
1449         context.update(
1450             to_field_var=TO_FIELD_VAR,
1451             is_popup_var=IS_POPUP_VAR,
1452             media=self.media,
1453         )
1454 
1455         return TemplateResponse(
1456             request,
1457             self.delete_confirmation_template or [
1458                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1459                 "admin/{}/delete_confirmation.html".format(app_label),
1460                 "admin/delete_confirmation.html",
1461             ],
1462             context,
1463         )
1464 
1465     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1466         # Edit permissions on parent model are required for editable inlines.
1467         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1468         inline_admin_formsets = []
1469         for inline, formset in zip(inline_instances, formsets):
1470             fieldsets = list(inline.get_fieldsets(request, obj))
1471             readonly = list(inline.get_readonly_fields(request, obj))
1472             if can_edit_parent:
1473                 has_add_permission = inline.has_add_permission(request, obj)
1474                 has_change_permission = inline.has_change_permission(request, obj)
1475                 has_delete_permission = inline.has_delete_permission(request, obj)
1476             else:
1477                 # Disable all edit-permissions, and overide formset settings.
1478                 has_add_permission = has_change_permission = has_delete_permission = False
1479                 formset.extra = formset.max_num = 0
1480             has_view_permission = inline.has_view_permission(request, obj)
1481             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1482             inline_admin_formset = helpers.InlineAdminFormSet(
1483                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1484                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1485                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1486             )
1487             inline_admin_formsets.append(inline_admin_formset)
1488         return inline_admin_formsets
1489 
1490     def get_changeform_initial_data(self, request):
1491         """
1492         Get the initial form data from the request's GET params.
1493         """
1494         initial = dict(request.GET.items())
1495         for k in initial:
1496             try:
1497                 f = self.model._meta.get_field(k)
1498             except FieldDoesNotExist:
1499                 continue
1500             # We have to special-case M2Ms as a list of comma-separated PKs.
1501             if isinstance(f, models.ManyToManyField):
1502                 initial[k] = initial[k].split(",")
1503         return initial
1504 
1505     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1506         """
1507         Create a message informing the user that the object doesn't exist
1508         and return a redirect to the admin index page.
1509         """
1510         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1511             'name': opts.verbose_name,
1512             'key': unquote(object_id),
1513         }
1514         self.message_user(request, msg, messages.WARNING)
1515         url = reverse('admin:index', current_app=self.admin_site.name)
1516         return HttpResponseRedirect(url)
1517 
1518     @csrf_protect_m
1519     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1520         with transaction.atomic(using=router.db_for_write(self.model)):
1521             return self._changeform_view(request, object_id, form_url, extra_context)
1522 
1523     def _changeform_view(self, request, object_id, form_url, extra_context):
1524         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1525         if to_field and not self.to_field_allowed(request, to_field):
1526             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1527 
1528         model = self.model
1529         opts = model._meta
1530 
1531         if request.method == 'POST' and '_saveasnew' in request.POST:
1532             object_id = None
1533 
1534         add = object_id is None
1535 
1536         if add:
1537             if not self.has_add_permission(request):
1538                 raise PermissionDenied
1539             obj = None
1540 
1541         else:
1542             obj = self.get_object(request, unquote(object_id), to_field)
1543 
1544             if request.method == 'POST':
1545                 if not self.has_change_permission(request, obj):
1546                     raise PermissionDenied
1547             else:
1548                 if not self.has_view_or_change_permission(request, obj):
1549                     raise PermissionDenied
1550 
1551             if obj is None:
1552                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1553 
1554         fieldsets = self.get_fieldsets(request, obj)
1555         ModelForm = self.get_form(
1556             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1557         )
1558         if request.method == 'POST':
1559             form = ModelForm(request.POST, request.FILES, instance=obj)
1560             form_validated = form.is_valid()
1561             if form_validated:
1562                 new_object = self.save_form(request, form, change=not add)
1563             else:
1564                 new_object = form.instance
1565             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1566             if all_valid(formsets) and form_validated:
1567                 self.save_model(request, new_object, form, not add)
1568                 self.save_related(request, form, formsets, not add)
1569                 change_message = self.construct_change_message(request, form, formsets, add)
1570                 if add:
1571                     self.log_addition(request, new_object, change_message)
1572                     return self.response_add(request, new_object)
1573                 else:
1574                     self.log_change(request, new_object, change_message)
1575                     return self.response_change(request, new_object)
1576             else:
1577                 form_validated = False
1578         else:
1579             if add:
1580                 initial = self.get_changeform_initial_data(request)
1581                 form = ModelForm(initial=initial)
1582                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1583             else:
1584                 form = ModelForm(instance=obj)
1585                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1586 
1587         if not add and not self.has_change_permission(request, obj):
1588             readonly_fields = flatten_fieldsets(fieldsets)
1589         else:
1590             readonly_fields = self.get_readonly_fields(request, obj)
1591         adminForm = helpers.AdminForm(
1592             form,
1593             list(fieldsets),
1594             # Clear prepopulated fields on a view-only form to avoid a crash.
1595             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1596             readonly_fields,
1597             model_admin=self)
1598         media = self.media + adminForm.media
1599 
1600         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1601         for inline_formset in inline_formsets:
1602             media = media + inline_formset.media
1603 
1604         if add:
1605             title = _('Add %s')
1606         elif self.has_change_permission(request, obj):
1607             title = _('Change %s')
1608         else:
1609             title = _('View %s')
1610         context = {
1611             **self.admin_site.each_context(request),
1612             'title': title % opts.verbose_name,
1613             'adminform': adminForm,
1614             'object_id': object_id,
1615             'original': obj,
1616             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1617             'to_field': to_field,
1618             'media': media,
1619             'inline_admin_formsets': inline_formsets,
1620             'errors': helpers.AdminErrorList(form, formsets),
1621             'preserved_filters': self.get_preserved_filters(request),
1622         }
1623 
1624         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1625         # previously chosen to prevent the interface from getting confusing.
1626         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1627             context['show_save'] = False
1628             context['show_save_and_continue'] = False
1629             # Use the change template instead of the add template.
1630             add = False
1631 
1632         context.update(extra_context or {})
1633 
1634         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1635 
1636     def autocomplete_view(self, request):
1637         return AutocompleteJsonView.as_view(model_admin=self)(request)
1638 
1639     def add_view(self, request, form_url='', extra_context=None):
1640         return self.changeform_view(request, None, form_url, extra_context)
1641 
1642     def change_view(self, request, object_id, form_url='', extra_context=None):
1643         return self.changeform_view(request, object_id, form_url, extra_context)
1644 
1645     def _get_edited_object_pks(self, request, prefix):
1646         """Return POST data values of list_editable primary keys."""
1647         pk_pattern = re.compile(
1648             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1649         )
1650         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1651 
1652     def _get_list_editable_queryset(self, request, prefix):
1653         """
1654         Based on POST data, return a queryset of the objects that were edited
1655         via list_editable.
1656         """
1657         object_pks = self._get_edited_object_pks(request, prefix)
1658         queryset = self.get_queryset(request)
1659         validate = queryset.model._meta.pk.to_python
1660         try:
1661             for pk in object_pks:
1662                 validate(pk)
1663         except ValidationError:
1664             # Disable the optimization if the POST data was tampered with.
1665             return queryset
1666         return queryset.filter(pk__in=object_pks)
1667 
1668     @csrf_protect_m
1669     def changelist_view(self, request, extra_context=None):
1670         """
1671         The 'change list' admin view for this model.
1672         """
1673         from django.contrib.admin.views.main import ERROR_FLAG
1674         opts = self.model._meta
1675         app_label = opts.app_label
1676         if not self.has_view_or_change_permission(request):
1677             raise PermissionDenied
1678 
1679         try:
1680             cl = self.get_changelist_instance(request)
1681         except IncorrectLookupParameters:
1682             # Wacky lookup parameters were given, so redirect to the main
1683             # changelist page, without parameters, and pass an 'invalid=1'
1684             # parameter via the query string. If wacky parameters were given
1685             # and the 'invalid=1' parameter was already in the query string,
1686             # something is screwed up with the database, so display an error
1687             # page.
1688             if ERROR_FLAG in request.GET:
1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1690                     'title': _('Database error'),
1691                 })
1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1693 
1694         # If the request was POSTed, this might be a bulk action or a bulk
1695         # edit. Try to look up an action or confirmation first, but if this
1696         # isn't an action the POST will fall through to the bulk edit check,
1697         # below.
1698         action_failed = False
1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1700 
1701         actions = self.get_actions(request)
1702         # Actions with no confirmation
1703         if (actions and request.method == 'POST' and
1704                 'index' in request.POST and '_save' not in request.POST):
1705             if selected:
1706                 response = self.response_action(request, queryset=cl.get_queryset(request))
1707                 if response:
1708                     return response
1709                 else:
1710                     action_failed = True
1711             else:
1712                 msg = _("Items must be selected in order to perform "
1713                         "actions on them. No items have been changed.")
1714                 self.message_user(request, msg, messages.WARNING)
1715                 action_failed = True
1716 
1717         # Actions with confirmation
1718         if (actions and request.method == 'POST' and
1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1720                 'index' not in request.POST and '_save' not in request.POST):
1721             if selected:
1722                 response = self.response_action(request, queryset=cl.get_queryset(request))
1723                 if response:
1724                     return response
1725                 else:
1726                     action_failed = True
1727 
1728         if action_failed:
1729             # Redirect back to the changelist page to avoid resubmitting the
1730             # form if the user refreshes the browser or uses the "No, take
1731             # me back" button on the action confirmation page.
1732             return HttpResponseRedirect(request.get_full_path())
1733 
1734         # If we're allowing changelist editing, we need to construct a formset
1735         # for the changelist given all the fields to be edited. Then we'll
1736         # use the formset to validate/process POSTed data.
1737         formset = cl.formset = None
1738 
1739         # Handle POSTed bulk-edit data.
1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1741             if not self.has_change_permission(request):
1742                 raise PermissionDenied
1743             FormSet = self.get_changelist_formset(request)
1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1746             if formset.is_valid():
1747                 changecount = 0
1748                 for form in formset.forms:
1749                     if form.has_changed():
1750                         obj = self.save_form(request, form, change=True)
1751                         self.save_model(request, obj, form, change=True)
1752                         self.save_related(request, form, formsets=[], change=True)
1753                         change_msg = self.construct_change_message(request, form, None)
1754                         self.log_change(request, obj, change_msg)
1755                         changecount += 1
1756 
1757                 if changecount:
1758                     msg = ngettext(
1759                         "%(count)s %(name)s was changed successfully.",
1760                         "%(count)s %(name)s were changed successfully.",
1761                         changecount
1762                     ) % {
1763                         'count': changecount,
1764                         'name': model_ngettext(opts, changecount),
1765                     }
1766                     self.message_user(request, msg, messages.SUCCESS)
1767 
1768                 return HttpResponseRedirect(request.get_full_path())
1769 
1770         # Handle GET -- construct a formset for display.
1771         elif cl.list_editable and self.has_change_permission(request):
1772             FormSet = self.get_changelist_formset(request)
1773             formset = cl.formset = FormSet(queryset=cl.result_list)
1774 
1775         # Build the list of media to be used by the formset.
1776         if formset:
1777             media = self.media + formset.media
1778         else:
1779             media = self.media
1780 
1781         # Build the action form and populate it with available actions.
1782         if actions:
1783             action_form = self.action_form(auto_id=None)
1784             action_form.fields['action'].choices = self.get_action_choices(request)
1785             media += action_form.media
1786         else:
1787             action_form = None
1788 
1789         selection_note_all = ngettext(
1790             '%(total_count)s selected',
1791             'All %(total_count)s selected',
1792             cl.result_count
1793         )
1794 
1795         context = {
1796             **self.admin_site.each_context(request),
1797             'module_name': str(opts.verbose_name_plural),
1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1800             'title': cl.title,
1801             'is_popup': cl.is_popup,
1802             'to_field': cl.to_field,
1803             'cl': cl,
1804             'media': media,
1805             'has_add_permission': self.has_add_permission(request),
1806             'opts': cl.opts,
1807             'action_form': action_form,
1808             'actions_on_top': self.actions_on_top,
1809             'actions_on_bottom': self.actions_on_bottom,
1810             'actions_selection_counter': self.actions_selection_counter,
1811             'preserved_filters': self.get_preserved_filters(request),
1812             **(extra_context or {}),
1813         }
1814 
1815         request.current_app = self.admin_site.name
1816 
1817         return TemplateResponse(request, self.change_list_template or [
1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1819             'admin/%s/change_list.html' % app_label,
1820             'admin/change_list.html'
1821         ], context)
1822 
1823     def get_deleted_objects(self, objs, request):
1824         """
1825         Hook for customizing the delete process for the delete view and the
1826         "delete selected" action.
1827         """
1828         return get_deleted_objects(objs, request, self.admin_site)
1829 
1830     @csrf_protect_m
1831     def delete_view(self, request, object_id, extra_context=None):
1832         with transaction.atomic(using=router.db_for_write(self.model)):
1833             return self._delete_view(request, object_id, extra_context)
1834 
1835     def _delete_view(self, request, object_id, extra_context):
1836         "The 'delete' admin view for this model."
1837         opts = self.model._meta
1838         app_label = opts.app_label
1839 
1840         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1841         if to_field and not self.to_field_allowed(request, to_field):
1842             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1843 
1844         obj = self.get_object(request, unquote(object_id), to_field)
1845 
1846         if not self.has_delete_permission(request, obj):
1847             raise PermissionDenied
1848 
1849         if obj is None:
1850             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1851 
1852         # Populate deleted_objects, a data structure of all related objects that
1853         # will also be deleted.
1854         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1855 
1856         if request.POST and not protected:  # The user has confirmed the deletion.
1857             if perms_needed:
1858                 raise PermissionDenied
1859             obj_display = str(obj)
1860             attr = str(to_field) if to_field else opts.pk.attname
1861             obj_id = obj.serializable_value(attr)
1862             self.log_deletion(request, obj, obj_display)
1863             self.delete_model(request, obj)
1864 
1865             return self.response_delete(request, obj_display, obj_id)
1866 
1867         object_name = str(opts.verbose_name)
1868 
1869         if perms_needed or protected:
1870             title = _("Cannot delete %(name)s") % {"name": object_name}
1871         else:
1872             title = _("Are you sure?")
1873 
1874         context = {
1875             **self.admin_site.each_context(request),
1876             'title': title,
1877             'object_name': object_name,
1878             'object': obj,
1879             'deleted_objects': deleted_objects,
1880             'model_count': dict(model_count).items(),
1881             'perms_lacking': perms_needed,
1882             'protected': protected,
1883             'opts': opts,
1884             'app_label': app_label,
1885             'preserved_filters': self.get_preserved_filters(request),
1886             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1887             'to_field': to_field,
1888             **(extra_context or {}),
1889         }
1890 
1891         return self.render_delete_form(request, context)
1892 
1893     def history_view(self, request, object_id, extra_context=None):
1894         "The 'history' admin view for this model."
1895         from django.contrib.admin.models import LogEntry
1896         # First check if the user can see this history.
1897         model = self.model
1898         obj = self.get_object(request, unquote(object_id))
1899         if obj is None:
1900             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1901 
1902         if not self.has_view_or_change_permission(request, obj):
1903             raise PermissionDenied
1904 
1905         # Then get the history for this object.
1906         opts = model._meta
1907         app_label = opts.app_label
1908         action_list = LogEntry.objects.filter(
1909             object_id=unquote(object_id),
1910             content_type=get_content_type_for_model(model)
1911         ).select_related().order_by('action_time')
1912 
1913         context = {
1914             **self.admin_site.each_context(request),
1915             'title': _('Change history: %s') % obj,
1916             'action_list': action_list,
1917             'module_name': str(capfirst(opts.verbose_name_plural)),
1918             'object': obj,
1919             'opts': opts,
1920             'preserved_filters': self.get_preserved_filters(request),
1921             **(extra_context or {}),
1922         }
1923 
1924         request.current_app = self.admin_site.name
1925 
1926         return TemplateResponse(request, self.object_history_template or [
1927             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1928             "admin/%s/object_history.html" % app_label,
1929             "admin/object_history.html"
1930         ], context)
1931 
1932     def _create_formsets(self, request, obj, change):
1933         "Helper function to generate formsets for add/change_view."
1934         formsets = []
1935         inline_instances = []
1936         prefixes = {}
1937         get_formsets_args = [request]
1938         if change:
1939             get_formsets_args.append(obj)
1940         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1941             prefix = FormSet.get_default_prefix()
1942             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1943             if prefixes[prefix] != 1 or not prefix:
1944                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1945             formset_params = {
1946                 'instance': obj,
1947                 'prefix': prefix,
1948                 'queryset': inline.get_queryset(request),
1949             }
1950             if request.method == 'POST':
1951                 formset_params.update({
1952                     'data': request.POST.copy(),
1953                     'files': request.FILES,
1954                     'save_as_new': '_saveasnew' in request.POST
1955                 })
1956             formset = FormSet(**formset_params)
1957 
1958             def user_deleted_form(request, obj, formset, index):
1959                 """Return whether or not the user deleted the form."""
1960                 return (
1961                     inline.has_delete_permission(request, obj) and
1962                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1963                 )
1964 
1965             # Bypass validation of each view-only inline form (since the form's
1966             # data won't be in request.POST), unless the form was deleted.
1967             if not inline.has_change_permission(request, obj if change else None):
1968                 for index, form in enumerate(formset.initial_forms):
1969                     if user_deleted_form(request, obj, formset, index):
1970                         continue
1971                     form._errors = {}
1972                     form.cleaned_data = form.initial
1973             formsets.append(formset)
1974             inline_instances.append(inline)
1975         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 04:27:50.711 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/views/main.py</file>
<class>ChangeList</class>
<method>get_queryset</method>
<code>
434     def get_queryset(self, request):
435         # First, we collect all the declared list filters.
436         (self.filter_specs, self.has_filters, remaining_lookup_params,
437          filters_use_distinct) = self.get_filters(request)
438 
439         # Then, we let every list filter modify the queryset to its liking.
440         qs = self.root_queryset
441         for filter_spec in self.filter_specs:
442             new_qs = filter_spec.queryset(request, qs)
443             if new_qs is not None:
444                 qs = new_qs
445 
446         try:
447             # Finally, we apply the remaining lookup parameters from the query
448             # string (i.e. those that haven't already been processed by the
449             # filters).
450             qs = qs.filter(**remaining_lookup_params)
451         except (SuspiciousOperation, ImproperlyConfigured):
452             # Allow certain types of errors to be re-raised as-is so that the
453             # caller can treat them in a special way.
454             raise
455         except Exception as e:
456             # Every other error is caught with a naked except, because we don't
457             # have any other way of validating lookup parameters. They might be
458             # invalid if the keyword arguments are incorrect, or if the values
459             # are not in the correct type, so we might get FieldError,
460             # ValueError, ValidationError, or ?.
461             raise IncorrectLookupParameters(e)
462 
463         if not qs.query.select_related:
464             qs = self.apply_select_related(qs)
465 
466         # Set ordering.
467         ordering = self.get_ordering(request, qs)
468         qs = qs.order_by(*ordering)
469 
470         # Apply search results
471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
472 
473         # Remove duplicates from results, if necessary
474         if filters_use_distinct | search_use_distinct:
475             return qs.distinct()
476         else:
477             return qs

</code><intended_behavior>Within the `get_queryset` method, adjustments should be made to respect the timezone of the user when filtering based on `date_hierarchy`. When constructing the date range filter, the start and end dates need to be localized to the user's timezone. This ensures the filtered results accurately reflect the dates relevant to the user's localized day, taking into account their timezone offset. Specifically, before applying filters generated from `date_hierarchy`, the code should ensure date boundaries are converted into the user's local timezone. This might involve integration with Django's timezone handling utilities to convert naive datetime objects to timezone-aware ones, specifically targeting the bounds used in `date_hierarchy` filtering.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>ChangeList</class>
<method>None</method>
<code>
48 class ChangeList:
49     search_form_class = ChangeListSearchForm
50 
51     def __init__(self, request, model, list_display, list_display_links,
52                  list_filter, date_hierarchy, search_fields, list_select_related,
53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):
54         self.model = model
55         self.opts = model._meta
56         self.lookup_opts = self.opts
57         self.root_queryset = model_admin.get_queryset(request)
58         self.list_display = list_display
59         self.list_display_links = list_display_links
60         self.list_filter = list_filter
61         self.has_filters = None
62         self.date_hierarchy = date_hierarchy
63         self.search_fields = search_fields
64         self.list_select_related = list_select_related
65         self.list_per_page = list_per_page
66         self.list_max_show_all = list_max_show_all
67         self.model_admin = model_admin
68         self.preserved_filters = model_admin.get_preserved_filters(request)
69         self.sortable_by = sortable_by
70 
71         # Get search parameters from the query string.
72         _search_form = self.search_form_class(request.GET)
73         if not _search_form.is_valid():
74             for error in _search_form.errors.values():
75                 messages.error(request, ', '.join(error))
76         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''
77         try:
78             self.page_num = int(request.GET.get(PAGE_VAR, 0))
79         except ValueError:
80             self.page_num = 0
81         self.show_all = ALL_VAR in request.GET
82         self.is_popup = IS_POPUP_VAR in request.GET
83         to_field = request.GET.get(TO_FIELD_VAR)
84         if to_field and not model_admin.to_field_allowed(request, to_field):
85             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
86         self.to_field = to_field
87         self.params = dict(request.GET.items())
88         if PAGE_VAR in self.params:
89             del self.params[PAGE_VAR]
90         if ERROR_FLAG in self.params:
91             del self.params[ERROR_FLAG]
92 
93         if self.is_popup:
94             self.list_editable = ()
95         else:
96             self.list_editable = list_editable
97         self.queryset = self.get_queryset(request)
98         self.get_results(request)
99         if self.is_popup:
100             title = gettext('Select %s')
101         elif self.model_admin.has_change_permission(request):
102             title = gettext('Select %s to change')
103         else:
104             title = gettext('Select %s to view')
105         self.title = title % self.opts.verbose_name
106         self.pk_attname = self.lookup_opts.pk.attname
107 
108     def get_filters_params(self, params=None):
109         """
110         Return all params except IGNORED_PARAMS.
111         """
112         params = params or self.params
113         lookup_params = params.copy()  # a dictionary of the query string
114         # Remove all the parameters that are globally and systematically
115         # ignored.
116         for ignored in IGNORED_PARAMS:
117             if ignored in lookup_params:
118                 del lookup_params[ignored]
119         return lookup_params
120 
121     def get_filters(self, request):
122         lookup_params = self.get_filters_params()
123         use_distinct = False
124 
125         for key, value in lookup_params.items():
126             if not self.model_admin.lookup_allowed(key, value):
127                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
128 
129         filter_specs = []
130         for list_filter in self.list_filter:
131             if callable(list_filter):
132                 # This is simply a custom list filter class.
133                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
134             else:
135                 field_path = None
136                 if isinstance(list_filter, (tuple, list)):
137                     # This is a custom FieldListFilter class for a given field.
138                     field, field_list_filter_class = list_filter
139                 else:
140                     # This is simply a field name, so use the default
141                     # FieldListFilter class that has been registered for the
142                     # type of the given field.
143                     field, field_list_filter_class = list_filter, FieldListFilter.create
144                 if not isinstance(field, Field):
145                     field_path = field
146                     field = get_fields_from_path(self.model, field_path)[-1]
147 
148                 lookup_params_count = len(lookup_params)
149                 spec = field_list_filter_class(
150                     field, request, lookup_params,
151                     self.model, self.model_admin, field_path=field_path,
152                 )
153                 # field_list_filter_class removes any lookup_params it
154                 # processes. If that happened, check if distinct() is needed to
155                 # remove duplicate results.
156                 if lookup_params_count > len(lookup_params):
157                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)
158             if spec and spec.has_output():
159                 filter_specs.append(spec)
160 
161         if self.date_hierarchy:
162             # Create bounded lookup parameters so that the query is more
163             # efficient.
164             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)
165             if year is not None:
166                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)
167                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)
168                 try:
169                     from_date = datetime(
170                         int(year),
171                         int(month if month is not None else 1),
172                         int(day if day is not None else 1),
173                     )
174                 except ValueError as e:
175                     raise IncorrectLookupParameters(e) from e
176                 if day:
177                     to_date = from_date + timedelta(days=1)
178                 elif month:
179                     # In this branch, from_date will always be the first of a
180                     # month, so advancing 32 days gives the next month.
181                     to_date = (from_date + timedelta(days=32)).replace(day=1)
182                 else:
183                     to_date = from_date.replace(year=from_date.year + 1)
184                 if settings.USE_TZ:
185                     from_date = make_aware(from_date)
186                     to_date = make_aware(to_date)
187                 lookup_params.update({
188                     '%s__gte' % self.date_hierarchy: from_date,
189                     '%s__lt' % self.date_hierarchy: to_date,
190                 })
191 
192         # At this point, all the parameters used by the various ListFilters
193         # have been removed from lookup_params, which now only contains other
194         # parameters passed via the query string. We now loop through the
195         # remaining parameters both to ensure that all the parameters are valid
196         # fields and to determine if at least one of them needs distinct(). If
197         # the lookup parameters aren't real fields, then bail out.
198         try:
199             for key, value in lookup_params.items():
200                 lookup_params[key] = prepare_lookup_value(key, value)
201                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)
202             return filter_specs, bool(filter_specs), lookup_params, use_distinct
203         except FieldDoesNotExist as e:
204             raise IncorrectLookupParameters(e) from e
205 
206     def get_query_string(self, new_params=None, remove=None):
207         if new_params is None:
208             new_params = {}
209         if remove is None:
210             remove = []
211         p = self.params.copy()
212         for r in remove:
213             for k in list(p):
214                 if k.startswith(r):
215                     del p[k]
216         for k, v in new_params.items():
217             if v is None:
218                 if k in p:
219                     del p[k]
220             else:
221                 p[k] = v
222         return '?%s' % urlencode(sorted(p.items()))
223 
224     def get_results(self, request):
225         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)
226         # Get the number of objects, with admin filters applied.
227         result_count = paginator.count
228 
229         # Get the total number of objects, with no admin filters applied.
230         if self.model_admin.show_full_result_count:
231             full_result_count = self.root_queryset.count()
232         else:
233             full_result_count = None
234         can_show_all = result_count <= self.list_max_show_all
235         multi_page = result_count > self.list_per_page
236 
237         # Get the list of objects to display on this page.
238         if (self.show_all and can_show_all) or not multi_page:
239             result_list = self.queryset._clone()
240         else:
241             try:
242                 result_list = paginator.page(self.page_num + 1).object_list
243             except InvalidPage:
244                 raise IncorrectLookupParameters
245 
246         self.result_count = result_count
247         self.show_full_result_count = self.model_admin.show_full_result_count
248         # Admin actions are shown if there is at least one entry
249         # or if entries are not counted because show_full_result_count is disabled
250         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)
251         self.full_result_count = full_result_count
252         self.result_list = result_list
253         self.can_show_all = can_show_all
254         self.multi_page = multi_page
255         self.paginator = paginator
256 
257     def _get_default_ordering(self):
258         ordering = []
259         if self.model_admin.ordering:
260             ordering = self.model_admin.ordering
261         elif self.lookup_opts.ordering:
262             ordering = self.lookup_opts.ordering
263         return ordering
264 
265     def get_ordering_field(self, field_name):
266         """
267         Return the proper model field name corresponding to the given
268         field_name to use for ordering. field_name may either be the name of a
269         proper model field or the name of a method (on the admin or model) or a
270         callable with the 'admin_order_field' attribute. Return None if no
271         proper model field name can be matched.
272         """
273         try:
274             field = self.lookup_opts.get_field(field_name)
275             return field.name
276         except FieldDoesNotExist:
277             # See whether field_name is a name of a non-field
278             # that allows sorting.
279             if callable(field_name):
280                 attr = field_name
281             elif hasattr(self.model_admin, field_name):
282                 attr = getattr(self.model_admin, field_name)
283             else:
284                 attr = getattr(self.model, field_name)
285             if isinstance(attr, property) and hasattr(attr, 'fget'):
286                 attr = attr.fget
287             return getattr(attr, 'admin_order_field', None)
288 
289     def get_ordering(self, request, queryset):
290         """
291         Return the list of ordering fields for the change list.
292         First check the get_ordering() method in model admin, then check
293         the object's default ordering. Then, any manually-specified ordering
294         from the query string overrides anything. Finally, a deterministic
295         order is guaranteed by calling _get_deterministic_ordering() with the
296         constructed ordering.
297         """
298         params = self.params
299         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())
300         if ORDER_VAR in params:
301             # Clear ordering and used params
302             ordering = []
303             order_params = params[ORDER_VAR].split('.')
304             for p in order_params:
305                 try:
306                     none, pfx, idx = p.rpartition('-')
307                     field_name = self.list_display[int(idx)]
308                     order_field = self.get_ordering_field(field_name)
309                     if not order_field:
310                         continue  # No 'admin_order_field', skip it
311                     if isinstance(order_field, OrderBy):
312                         if pfx == '-':
313                             order_field = order_field.copy()
314                             order_field.reverse_ordering()
315                         ordering.append(order_field)
316                     elif hasattr(order_field, 'resolve_expression'):
317                         # order_field is an expression.
318                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())
319                     # reverse order if order_field has already "-" as prefix
320                     elif order_field.startswith('-') and pfx == '-':
321                         ordering.append(order_field[1:])
322                     else:
323                         ordering.append(pfx + order_field)
324                 except (IndexError, ValueError):
325                     continue  # Invalid ordering specified, skip it.
326 
327         # Add the given query's ordering fields, if any.
328         ordering.extend(queryset.query.order_by)
329 
330         return self._get_deterministic_ordering(ordering)
331 
332     def _get_deterministic_ordering(self, ordering):
333         """
334         Ensure a deterministic order across all database backends. Search for a
335         single field or unique together set of fields providing a total
336         ordering. If these are missing, augment the ordering with a descendant
337         primary key.
338         """
339         ordering = list(ordering)
340         ordering_fields = set()
341         total_ordering_fields = {'pk'} | {
342             field.attname for field in self.lookup_opts.fields
343             if field.unique and not field.null
344         }
345         for part in ordering:
346             # Search for single field providing a total ordering.
347             field_name = None
348             if isinstance(part, str):
349                 field_name = part.lstrip('-')
350             elif isinstance(part, F):
351                 field_name = part.name
352             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
353                 field_name = part.expression.name
354             if field_name:
355                 # Normalize attname references by using get_field().
356                 try:
357                     field = self.lookup_opts.get_field(field_name)
358                 except FieldDoesNotExist:
359                     # Could be "?" for random ordering or a related field
360                     # lookup. Skip this part of introspection for now.
361                     continue
362                 # Ordering by a related field name orders by the referenced
363                 # model's ordering. Skip this part of introspection for now.
364                 if field.remote_field and field_name == field.name:
365                     continue
366                 if field.attname in total_ordering_fields:
367                     break
368                 ordering_fields.add(field.attname)
369         else:
370             # No single total ordering field, try unique_together and total
371             # unique constraints.
372             constraint_field_names = (
373                 *self.lookup_opts.unique_together,
374                 *(
375                     constraint.fields
376                     for constraint in self.lookup_opts.total_unique_constraints
377                 ),
378             )
379             for field_names in constraint_field_names:
380                 # Normalize attname references by using get_field().
381                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]
382                 # Composite unique constraints containing a nullable column
383                 # cannot ensure total ordering.
384                 if any(field.null for field in fields):
385                     continue
386                 if ordering_fields.issuperset(field.attname for field in fields):
387                     break
388             else:
389                 # If no set of unique fields is present in the ordering, rely
390                 # on the primary key to provide total ordering.
391                 ordering.append('-pk')
392         return ordering
393 
394     def get_ordering_field_columns(self):
395         """
396         Return a dictionary of ordering field column numbers and asc/desc.
397         """
398         # We must cope with more than one column having the same underlying sort
399         # field, so we base things on column numbers.
400         ordering = self._get_default_ordering()
401         ordering_fields = {}
402         if ORDER_VAR not in self.params:
403             # for ordering specified on ModelAdmin or model Meta, we don't know
404             # the right column numbers absolutely, because there might be more
405             # than one column associated with that ordering, so we guess.
406             for field in ordering:
407                 if isinstance(field, (Combinable, OrderBy)):
408                     if not isinstance(field, OrderBy):
409                         field = field.asc()
410                     if isinstance(field.expression, F):
411                         order_type = 'desc' if field.descending else 'asc'
412                         field = field.expression.name
413                     else:
414                         continue
415                 elif field.startswith('-'):
416                     field = field[1:]
417                     order_type = 'desc'
418                 else:
419                     order_type = 'asc'
420                 for index, attr in enumerate(self.list_display):
421                     if self.get_ordering_field(attr) == field:
422                         ordering_fields[index] = order_type
423                         break
424         else:
425             for p in self.params[ORDER_VAR].split('.'):
426                 none, pfx, idx = p.rpartition('-')
427                 try:
428                     idx = int(idx)
429                 except ValueError:
430                     continue  # skip it
431                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'
432         return ordering_fields
433 
434     def get_queryset(self, request):
435         # First, we collect all the declared list filters.
436         (self.filter_specs, self.has_filters, remaining_lookup_params,
437          filters_use_distinct) = self.get_filters(request)
438 
439         # Then, we let every list filter modify the queryset to its liking.
440         qs = self.root_queryset
441         for filter_spec in self.filter_specs:
442             new_qs = filter_spec.queryset(request, qs)
443             if new_qs is not None:
444                 qs = new_qs
445 
446         try:
447             # Finally, we apply the remaining lookup parameters from the query
448             # string (i.e. those that haven't already been processed by the
449             # filters).
450             qs = qs.filter(**remaining_lookup_params)
451         except (SuspiciousOperation, ImproperlyConfigured):
452             # Allow certain types of errors to be re-raised as-is so that the
453             # caller can treat them in a special way.
454             raise
455         except Exception as e:
456             # Every other error is caught with a naked except, because we don't
457             # have any other way of validating lookup parameters. They might be
458             # invalid if the keyword arguments are incorrect, or if the values
459             # are not in the correct type, so we might get FieldError,
460             # ValueError, ValidationError, or ?.
461             raise IncorrectLookupParameters(e)
462 
463         if not qs.query.select_related:
464             qs = self.apply_select_related(qs)
465 
466         # Set ordering.
467         ordering = self.get_ordering(request, qs)
468         qs = qs.order_by(*ordering)
469 
470         # Apply search results
471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
472 
473         # Remove duplicates from results, if necessary
474         if filters_use_distinct | search_use_distinct:
475             return qs.distinct()
476         else:
477             return qs
478 
479     def apply_select_related(self, qs):
480         if self.list_select_related is True:
481             return qs.select_related()
482 
483         if self.list_select_related is False:
484             if self.has_related_field_in_list_display():
485                 return qs.select_related()
486 
487         if self.list_select_related:
488             return qs.select_related(*self.list_select_related)
489         return qs
490 
491     def has_related_field_in_list_display(self):
492         for field_name in self.list_display:
493             try:
494                 field = self.lookup_opts.get_field(field_name)
495             except FieldDoesNotExist:
496                 pass
497             else:
498                 if isinstance(field.remote_field, ManyToOneRel):
499                     # <FK>_id field names don't require a join.
500                     if field_name != field.get_attname():
501                         return True
502         return False
503 
504     def url_for_result(self, result):
505         pk = getattr(result, self.pk_attname)
506         return reverse('admin:%s_%s_change' % (self.opts.app_label,
507                                                self.opts.model_name),
508                        args=(quote(pk),),
509                        current_app=self.model_admin.admin_site.name)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>changelist_view</method>
<code>
1669     def changelist_view(self, request, extra_context=None):
1670         """
1671         The 'change list' admin view for this model.
1672         """
1673         from django.contrib.admin.views.main import ERROR_FLAG
1674         opts = self.model._meta
1675         app_label = opts.app_label
1676         if not self.has_view_or_change_permission(request):
1677             raise PermissionDenied
1678 
1679         try:
1680             cl = self.get_changelist_instance(request)
1681         except IncorrectLookupParameters:
1682             # Wacky lookup parameters were given, so redirect to the main
1683             # changelist page, without parameters, and pass an 'invalid=1'
1684             # parameter via the query string. If wacky parameters were given
1685             # and the 'invalid=1' parameter was already in the query string,
1686             # something is screwed up with the database, so display an error
1687             # page.
1688             if ERROR_FLAG in request.GET:
1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1690                     'title': _('Database error'),
1691                 })
1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1693 
1694         # If the request was POSTed, this might be a bulk action or a bulk
1695         # edit. Try to look up an action or confirmation first, but if this
1696         # isn't an action the POST will fall through to the bulk edit check,
1697         # below.
1698         action_failed = False
1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1700 
1701         actions = self.get_actions(request)
1702         # Actions with no confirmation
1703         if (actions and request.method == 'POST' and
1704                 'index' in request.POST and '_save' not in request.POST):
1705             if selected:
1706                 response = self.response_action(request, queryset=cl.get_queryset(request))
1707                 if response:
1708                     return response
1709                 else:
1710                     action_failed = True
1711             else:
1712                 msg = _("Items must be selected in order to perform "
1713                         "actions on them. No items have been changed.")
1714                 self.message_user(request, msg, messages.WARNING)
1715                 action_failed = True
1716 
1717         # Actions with confirmation
1718         if (actions and request.method == 'POST' and
1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1720                 'index' not in request.POST and '_save' not in request.POST):
1721             if selected:
1722                 response = self.response_action(request, queryset=cl.get_queryset(request))
1723                 if response:
1724                     return response
1725                 else:
1726                     action_failed = True
1727 
1728         if action_failed:
1729             # Redirect back to the changelist page to avoid resubmitting the
1730             # form if the user refreshes the browser or uses the "No, take
1731             # me back" button on the action confirmation page.
1732             return HttpResponseRedirect(request.get_full_path())
1733 
1734         # If we're allowing changelist editing, we need to construct a formset
1735         # for the changelist given all the fields to be edited. Then we'll
1736         # use the formset to validate/process POSTed data.
1737         formset = cl.formset = None
1738 
1739         # Handle POSTed bulk-edit data.
1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1741             if not self.has_change_permission(request):
1742                 raise PermissionDenied
1743             FormSet = self.get_changelist_formset(request)
1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1746             if formset.is_valid():
1747                 changecount = 0
1748                 for form in formset.forms:
1749                     if form.has_changed():
1750                         obj = self.save_form(request, form, change=True)
1751                         self.save_model(request, obj, form, change=True)
1752                         self.save_related(request, form, formsets=[], change=True)
1753                         change_msg = self.construct_change_message(request, form, None)
1754                         self.log_change(request, obj, change_msg)
1755                         changecount += 1
1756 
1757                 if changecount:
1758                     msg = ngettext(
1759                         "%(count)s %(name)s was changed successfully.",
1760                         "%(count)s %(name)s were changed successfully.",
1761                         changecount
1762                     ) % {
1763                         'count': changecount,
1764                         'name': model_ngettext(opts, changecount),
1765                     }
1766                     self.message_user(request, msg, messages.SUCCESS)
1767 
1768                 return HttpResponseRedirect(request.get_full_path())
1769 
1770         # Handle GET -- construct a formset for display.
1771         elif cl.list_editable and self.has_change_permission(request):
1772             FormSet = self.get_changelist_formset(request)
1773             formset = cl.formset = FormSet(queryset=cl.result_list)
1774 
1775         # Build the list of media to be used by the formset.
1776         if formset:
1777             media = self.media + formset.media
1778         else:
1779             media = self.media
1780 
1781         # Build the action form and populate it with available actions.
1782         if actions:
1783             action_form = self.action_form(auto_id=None)
1784             action_form.fields['action'].choices = self.get_action_choices(request)
1785             media += action_form.media
1786         else:
1787             action_form = None
1788 
1789         selection_note_all = ngettext(
1790             '%(total_count)s selected',
1791             'All %(total_count)s selected',
1792             cl.result_count
1793         )
1794 
1795         context = {
1796             **self.admin_site.each_context(request),
1797             'module_name': str(opts.verbose_name_plural),
1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1800             'title': cl.title,
1801             'is_popup': cl.is_popup,
1802             'to_field': cl.to_field,
1803             'cl': cl,
1804             'media': media,
1805             'has_add_permission': self.has_add_permission(request),
1806             'opts': cl.opts,
1807             'action_form': action_form,
1808             'actions_on_top': self.actions_on_top,
1809             'actions_on_bottom': self.actions_on_bottom,
1810             'actions_selection_counter': self.actions_selection_counter,
1811             'preserved_filters': self.get_preserved_filters(request),
1812             **(extra_context or {}),
1813         }
1814 
1815         request.current_app = self.admin_site.name
1816 
1817         return TemplateResponse(request, self.change_list_template or [
1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1819             'admin/%s/change_list.html' % app_label,
1820             'admin/change_list.html'
1821         ], context)

</code><intended_behavior>The handling of the context for `date_hierarchy` within `changelist_view` may need to be revisited to ensure that the context's date hierarchy links are generated with awareness of the user's timezone. This might not involve changes within the `changelist_view` method itself but ensuring that any data passed to it, particularly variables related to date filters, are correctly timezone-aware. The goal is to maintain the functionality of generating hierarchical date filters (year, month, day) while ensuring the boundaries of these filters reflect the user's timezone. This would likely require collaboration with how the `ChangeList` class processes `date_hierarchy` to ensure consistent timezone application throughout.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
541 class ModelAdmin(BaseModelAdmin):
542     """Encapsulate all admin options and functionality for a given model."""
543 
544     list_display = ('__str__',)
545     list_display_links = ()
546     list_filter = ()
547     list_select_related = False
548     list_per_page = 100
549     list_max_show_all = 200
550     list_editable = ()
551     search_fields = ()
552     date_hierarchy = None
553     save_as = False
554     save_as_continue = True
555     save_on_top = False
556     paginator = Paginator
557     preserve_filters = True
558     inlines = []
559 
560     # Custom templates (designed to be over-ridden in subclasses)
561     add_form_template = None
562     change_form_template = None
563     change_list_template = None
564     delete_confirmation_template = None
565     delete_selected_confirmation_template = None
566     object_history_template = None
567     popup_response_template = None
568 
569     # Actions
570     actions = []
571     action_form = helpers.ActionForm
572     actions_on_top = True
573     actions_on_bottom = False
574     actions_selection_counter = True
575     checks_class = ModelAdminChecks
576 
577     def __init__(self, model, admin_site):
578         self.model = model
579         self.opts = model._meta
580         self.admin_site = admin_site
581         super().__init__()
582 
583     def __str__(self):
584         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
585 
586     def get_inline_instances(self, request, obj=None):
587         inline_instances = []
588         for inline_class in self.get_inlines(request, obj):
589             inline = inline_class(self.model, self.admin_site)
590             if request:
591                 if not (inline.has_view_or_change_permission(request, obj) or
592                         inline.has_add_permission(request, obj) or
593                         inline.has_delete_permission(request, obj)):
594                     continue
595                 if not inline.has_add_permission(request, obj):
596                     inline.max_num = 0
597             inline_instances.append(inline)
598 
599         return inline_instances
600 
601     def get_urls(self):
602         from django.urls import path
603 
604         def wrap(view):
605             def wrapper(*args, **kwargs):
606                 return self.admin_site.admin_view(view)(*args, **kwargs)
607             wrapper.model_admin = self
608             return update_wrapper(wrapper, view)
609 
610         info = self.model._meta.app_label, self.model._meta.model_name
611 
612         return [
613             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
614             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
615             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
616             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
617             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
618             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
619             # For backwards compatibility (was the change url before 1.9)
620             path('<path:object_id>/', wrap(RedirectView.as_view(
621                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
622             ))),
623         ]
624 
625     @property
626     def urls(self):
627         return self.get_urls()
628 
629     @property
630     def media(self):
631         extra = '' if settings.DEBUG else '.min'
632         js = [
633             'vendor/jquery/jquery%s.js' % extra,
634             'jquery.init.js',
635             'core.js',
636             'admin/RelatedObjectLookups.js',
637             'actions%s.js' % extra,
638             'urlify.js',
639             'prepopulate%s.js' % extra,
640             'vendor/xregexp/xregexp%s.js' % extra,
641         ]
642         return forms.Media(js=['admin/js/%s' % url for url in js])
643 
644     def get_model_perms(self, request):
645         """
646         Return a dict of all perms for this model. This dict has the keys
647         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
648         for each of those actions.
649         """
650         return {
651             'add': self.has_add_permission(request),
652             'change': self.has_change_permission(request),
653             'delete': self.has_delete_permission(request),
654             'view': self.has_view_permission(request),
655         }
656 
657     def _get_form_for_get_fields(self, request, obj):
658         return self.get_form(request, obj, fields=None)
659 
660     def get_form(self, request, obj=None, change=False, **kwargs):
661         """
662         Return a Form class for use in the admin add view. This is used by
663         add_view and change_view.
664         """
665         if 'fields' in kwargs:
666             fields = kwargs.pop('fields')
667         else:
668             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
669         excluded = self.get_exclude(request, obj)
670         exclude = [] if excluded is None else list(excluded)
671         readonly_fields = self.get_readonly_fields(request, obj)
672         exclude.extend(readonly_fields)
673         # Exclude all fields if it's a change form and the user doesn't have
674         # the change permission.
675         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
676             exclude.extend(fields)
677         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
678             # Take the custom ModelForm's Meta.exclude into account only if the
679             # ModelAdmin doesn't define its own.
680             exclude.extend(self.form._meta.exclude)
681         # if exclude is an empty list we pass None to be consistent with the
682         # default on modelform_factory
683         exclude = exclude or None
684 
685         # Remove declared form fields which are in readonly_fields.
686         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
687         form = type(self.form.__name__, (self.form,), new_attrs)
688 
689         defaults = {
690             'form': form,
691             'fields': fields,
692             'exclude': exclude,
693             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
694             **kwargs,
695         }
696 
697         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
698             defaults['fields'] = forms.ALL_FIELDS
699 
700         try:
701             return modelform_factory(self.model, **defaults)
702         except FieldError as e:
703             raise FieldError(
704                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
705                 % (e, self.__class__.__name__)
706             )
707 
708     def get_changelist(self, request, **kwargs):
709         """
710         Return the ChangeList class for use on the changelist page.
711         """
712         from django.contrib.admin.views.main import ChangeList
713         return ChangeList
714 
715     def get_changelist_instance(self, request):
716         """
717         Return a `ChangeList` instance based on `request`. May raise
718         `IncorrectLookupParameters`.
719         """
720         list_display = self.get_list_display(request)
721         list_display_links = self.get_list_display_links(request, list_display)
722         # Add the action checkboxes if any actions are available.
723         if self.get_actions(request):
724             list_display = ['action_checkbox', *list_display]
725         sortable_by = self.get_sortable_by(request)
726         ChangeList = self.get_changelist(request)
727         return ChangeList(
728             request,
729             self.model,
730             list_display,
731             list_display_links,
732             self.get_list_filter(request),
733             self.date_hierarchy,
734             self.get_search_fields(request),
735             self.get_list_select_related(request),
736             self.list_per_page,
737             self.list_max_show_all,
738             self.list_editable,
739             self,
740             sortable_by,
741         )
742 
743     def get_object(self, request, object_id, from_field=None):
744         """
745         Return an instance matching the field and value provided, the primary
746         key is used if no field is provided. Return ``None`` if no match is
747         found or the object_id fails validation.
748         """
749         queryset = self.get_queryset(request)
750         model = queryset.model
751         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
752         try:
753             object_id = field.to_python(object_id)
754             return queryset.get(**{field.name: object_id})
755         except (model.DoesNotExist, ValidationError, ValueError):
756             return None
757 
758     def get_changelist_form(self, request, **kwargs):
759         """
760         Return a Form class for use in the Formset on the changelist page.
761         """
762         defaults = {
763             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
764             **kwargs,
765         }
766         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
767             defaults['fields'] = forms.ALL_FIELDS
768 
769         return modelform_factory(self.model, **defaults)
770 
771     def get_changelist_formset(self, request, **kwargs):
772         """
773         Return a FormSet class for use on the changelist page if list_editable
774         is used.
775         """
776         defaults = {
777             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
778             **kwargs,
779         }
780         return modelformset_factory(
781             self.model, self.get_changelist_form(request), extra=0,
782             fields=self.list_editable, **defaults
783         )
784 
785     def get_formsets_with_inlines(self, request, obj=None):
786         """
787         Yield formsets and the corresponding inlines.
788         """
789         for inline in self.get_inline_instances(request, obj):
790             yield inline.get_formset(request, obj), inline
791 
792     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
793         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
794 
795     def log_addition(self, request, object, message):
796         """
797         Log that an object has been successfully added.
798 
799         The default implementation creates an admin LogEntry object.
800         """
801         from django.contrib.admin.models import LogEntry, ADDITION
802         return LogEntry.objects.log_action(
803             user_id=request.user.pk,
804             content_type_id=get_content_type_for_model(object).pk,
805             object_id=object.pk,
806             object_repr=str(object),
807             action_flag=ADDITION,
808             change_message=message,
809         )
810 
811     def log_change(self, request, object, message):
812         """
813         Log that an object has been successfully changed.
814 
815         The default implementation creates an admin LogEntry object.
816         """
817         from django.contrib.admin.models import LogEntry, CHANGE
818         return LogEntry.objects.log_action(
819             user_id=request.user.pk,
820             content_type_id=get_content_type_for_model(object).pk,
821             object_id=object.pk,
822             object_repr=str(object),
823             action_flag=CHANGE,
824             change_message=message,
825         )
826 
827     def log_deletion(self, request, object, object_repr):
828         """
829         Log that an object will be deleted. Note that this method must be
830         called before the deletion.
831 
832         The default implementation creates an admin LogEntry object.
833         """
834         from django.contrib.admin.models import LogEntry, DELETION
835         return LogEntry.objects.log_action(
836             user_id=request.user.pk,
837             content_type_id=get_content_type_for_model(object).pk,
838             object_id=object.pk,
839             object_repr=object_repr,
840             action_flag=DELETION,
841         )
842 
843     def action_checkbox(self, obj):
844         """
845         A list_display column containing a checkbox widget.
846         """
847         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
848     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
849 
850     def _get_base_actions(self):
851         """Return the list of actions, prior to any request-based filtering."""
852         actions = []
853 
854         # Gather actions from the admin site first
855         for (name, func) in self.admin_site.actions:
856             description = getattr(func, 'short_description', name.replace('_', ' '))
857             actions.append((func, name, description))
858         # Add actions from this ModelAdmin.
859         actions.extend(self.get_action(action) for action in self.actions or [])
860         # get_action might have returned None, so filter any of those out.
861         return filter(None, actions)
862 
863     def _filter_actions_by_permissions(self, request, actions):
864         """Filter out any actions that the user doesn't have access to."""
865         filtered_actions = []
866         for action in actions:
867             callable = action[0]
868             if not hasattr(callable, 'allowed_permissions'):
869                 filtered_actions.append(action)
870                 continue
871             permission_checks = (
872                 getattr(self, 'has_%s_permission' % permission)
873                 for permission in callable.allowed_permissions
874             )
875             if any(has_permission(request) for has_permission in permission_checks):
876                 filtered_actions.append(action)
877         return filtered_actions
878 
879     def get_actions(self, request):
880         """
881         Return a dictionary mapping the names of all actions for this
882         ModelAdmin to a tuple of (callable, name, description) for each action.
883         """
884         # If self.actions is set to None that means actions are disabled on
885         # this page.
886         if self.actions is None or IS_POPUP_VAR in request.GET:
887             return {}
888         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
889         return {name: (func, name, desc) for func, name, desc in actions}
890 
891     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
892         """
893         Return a list of choices for use in a form object.  Each choice is a
894         tuple (name, description).
895         """
896         choices = [] + default_choices
897         for func, name, description in self.get_actions(request).values():
898             choice = (name, description % model_format_dict(self.opts))
899             choices.append(choice)
900         return choices
901 
902     def get_action(self, action):
903         """
904         Return a given action from a parameter, which can either be a callable,
905         or the name of a method on the ModelAdmin.  Return is a tuple of
906         (callable, name, description).
907         """
908         # If the action is a callable, just use it.
909         if callable(action):
910             func = action
911             action = action.__name__
912 
913         # Next, look for a method. Grab it off self.__class__ to get an unbound
914         # method instead of a bound one; this ensures that the calling
915         # conventions are the same for functions and methods.
916         elif hasattr(self.__class__, action):
917             func = getattr(self.__class__, action)
918 
919         # Finally, look for a named method on the admin site
920         else:
921             try:
922                 func = self.admin_site.get_action(action)
923             except KeyError:
924                 return None
925 
926         if hasattr(func, 'short_description'):
927             description = func.short_description
928         else:
929             description = capfirst(action.replace('_', ' '))
930         return func, action, description
931 
932     def get_list_display(self, request):
933         """
934         Return a sequence containing the fields to be displayed on the
935         changelist.
936         """
937         return self.list_display
938 
939     def get_list_display_links(self, request, list_display):
940         """
941         Return a sequence containing the fields to be displayed as links
942         on the changelist. The list_display parameter is the list of fields
943         returned by get_list_display().
944         """
945         if self.list_display_links or self.list_display_links is None or not list_display:
946             return self.list_display_links
947         else:
948             # Use only the first item in list_display as link
949             return list(list_display)[:1]
950 
951     def get_list_filter(self, request):
952         """
953         Return a sequence containing the fields to be displayed as filters in
954         the right sidebar of the changelist page.
955         """
956         return self.list_filter
957 
958     def get_list_select_related(self, request):
959         """
960         Return a list of fields to add to the select_related() part of the
961         changelist items query.
962         """
963         return self.list_select_related
964 
965     def get_search_fields(self, request):
966         """
967         Return a sequence containing the fields to be searched whenever
968         somebody submits a search query.
969         """
970         return self.search_fields
971 
972     def get_search_results(self, request, queryset, search_term):
973         """
974         Return a tuple containing a queryset to implement the search
975         and a boolean indicating if the results may contain duplicates.
976         """
977         # Apply keyword searches.
978         def construct_search(field_name):
979             if field_name.startswith('^'):
980                 return "%s__istartswith" % field_name[1:]
981             elif field_name.startswith('='):
982                 return "%s__iexact" % field_name[1:]
983             elif field_name.startswith('@'):
984                 return "%s__search" % field_name[1:]
985             # Use field_name if it includes a lookup.
986             opts = queryset.model._meta
987             lookup_fields = field_name.split(LOOKUP_SEP)
988             # Go through the fields, following all relations.
989             prev_field = None
990             for path_part in lookup_fields:
991                 if path_part == 'pk':
992                     path_part = opts.pk.name
993                 try:
994                     field = opts.get_field(path_part)
995                 except FieldDoesNotExist:
996                     # Use valid query lookups.
997                     if prev_field and prev_field.get_lookup(path_part):
998                         return field_name
999                 else:
1000                     prev_field = field
1001                     if hasattr(field, 'get_path_info'):
1002                         # Update opts to follow the relation.
1003                         opts = field.get_path_info()[-1].to_opts
1004             # Otherwise, use the field with icontains.
1005             return "%s__icontains" % field_name
1006 
1007         use_distinct = False
1008         search_fields = self.get_search_fields(request)
1009         if search_fields and search_term:
1010             orm_lookups = [construct_search(str(search_field))
1011                            for search_field in search_fields]
1012             for bit in search_term.split():
1013                 or_queries = [models.Q(**{orm_lookup: bit})
1014                               for orm_lookup in orm_lookups]
1015                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1016             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1017 
1018         return queryset, use_distinct
1019 
1020     def get_preserved_filters(self, request):
1021         """
1022         Return the preserved filters querystring.
1023         """
1024         match = request.resolver_match
1025         if self.preserve_filters and match:
1026             opts = self.model._meta
1027             current_url = '%s:%s' % (match.app_name, match.url_name)
1028             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1029             if current_url == changelist_url:
1030                 preserved_filters = request.GET.urlencode()
1031             else:
1032                 preserved_filters = request.GET.get('_changelist_filters')
1033 
1034             if preserved_filters:
1035                 return urlencode({'_changelist_filters': preserved_filters})
1036         return ''
1037 
1038     def construct_change_message(self, request, form, formsets, add=False):
1039         """
1040         Construct a JSON structure describing changes from a changed object.
1041         """
1042         return construct_change_message(form, formsets, add)
1043 
1044     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1045                      fail_silently=False):
1046         """
1047         Send a message to the user. The default implementation
1048         posts a message using the django.contrib.messages backend.
1049 
1050         Exposes almost the same API as messages.add_message(), but accepts the
1051         positional arguments in a different order to maintain backwards
1052         compatibility. For convenience, it accepts the `level` argument as
1053         a string rather than the usual level number.
1054         """
1055         if not isinstance(level, int):
1056             # attempt to get the level if passed a string
1057             try:
1058                 level = getattr(messages.constants, level.upper())
1059             except AttributeError:
1060                 levels = messages.constants.DEFAULT_TAGS.values()
1061                 levels_repr = ', '.join('`%s`' % l for l in levels)
1062                 raise ValueError(
1063                     'Bad message level string: `%s`. Possible values are: %s'
1064                     % (level, levels_repr)
1065                 )
1066 
1067         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1068 
1069     def save_form(self, request, form, change):
1070         """
1071         Given a ModelForm return an unsaved instance. ``change`` is True if
1072         the object is being changed, and False if it's being added.
1073         """
1074         return form.save(commit=False)
1075 
1076     def save_model(self, request, obj, form, change):
1077         """
1078         Given a model instance save it to the database.
1079         """
1080         obj.save()
1081 
1082     def delete_model(self, request, obj):
1083         """
1084         Given a model instance delete it from the database.
1085         """
1086         obj.delete()
1087 
1088     def delete_queryset(self, request, queryset):
1089         """Given a queryset, delete it from the database."""
1090         queryset.delete()
1091 
1092     def save_formset(self, request, form, formset, change):
1093         """
1094         Given an inline formset save it to the database.
1095         """
1096         formset.save()
1097 
1098     def save_related(self, request, form, formsets, change):
1099         """
1100         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1101         list of inline formsets and a boolean value based on whether the
1102         parent is being added or changed, save the related objects to the
1103         database. Note that at this point save_form() and save_model() have
1104         already been called.
1105         """
1106         form.save_m2m()
1107         for formset in formsets:
1108             self.save_formset(request, form, formset, change=change)
1109 
1110     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1111         opts = self.model._meta
1112         app_label = opts.app_label
1113         preserved_filters = self.get_preserved_filters(request)
1114         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1115         view_on_site_url = self.get_view_on_site_url(obj)
1116         has_editable_inline_admin_formsets = False
1117         for inline in context['inline_admin_formsets']:
1118             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1119                 has_editable_inline_admin_formsets = True
1120                 break
1121         context.update({
1122             'add': add,
1123             'change': change,
1124             'has_view_permission': self.has_view_permission(request, obj),
1125             'has_add_permission': self.has_add_permission(request),
1126             'has_change_permission': self.has_change_permission(request, obj),
1127             'has_delete_permission': self.has_delete_permission(request, obj),
1128             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1129             'has_file_field': context['adminform'].form.is_multipart() or any(
1130                 admin_formset.formset.is_multipart()
1131                 for admin_formset in context['inline_admin_formsets']
1132             ),
1133             'has_absolute_url': view_on_site_url is not None,
1134             'absolute_url': view_on_site_url,
1135             'form_url': form_url,
1136             'opts': opts,
1137             'content_type_id': get_content_type_for_model(self.model).pk,
1138             'save_as': self.save_as,
1139             'save_on_top': self.save_on_top,
1140             'to_field_var': TO_FIELD_VAR,
1141             'is_popup_var': IS_POPUP_VAR,
1142             'app_label': app_label,
1143         })
1144         if add and self.add_form_template is not None:
1145             form_template = self.add_form_template
1146         else:
1147             form_template = self.change_form_template
1148 
1149         request.current_app = self.admin_site.name
1150 
1151         return TemplateResponse(request, form_template or [
1152             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1153             "admin/%s/change_form.html" % app_label,
1154             "admin/change_form.html"
1155         ], context)
1156 
1157     def response_add(self, request, obj, post_url_continue=None):
1158         """
1159         Determine the HttpResponse for the add_view stage.
1160         """
1161         opts = obj._meta
1162         preserved_filters = self.get_preserved_filters(request)
1163         obj_url = reverse(
1164             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1165             args=(quote(obj.pk),),
1166             current_app=self.admin_site.name,
1167         )
1168         # Add a link to the object's change form if the user can edit the obj.
1169         if self.has_change_permission(request, obj):
1170             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1171         else:
1172             obj_repr = str(obj)
1173         msg_dict = {
1174             'name': opts.verbose_name,
1175             'obj': obj_repr,
1176         }
1177         # Here, we distinguish between different save types by checking for
1178         # the presence of keys in request.POST.
1179 
1180         if IS_POPUP_VAR in request.POST:
1181             to_field = request.POST.get(TO_FIELD_VAR)
1182             if to_field:
1183                 attr = str(to_field)
1184             else:
1185                 attr = obj._meta.pk.attname
1186             value = obj.serializable_value(attr)
1187             popup_response_data = json.dumps({
1188                 'value': str(value),
1189                 'obj': str(obj),
1190             })
1191             return TemplateResponse(request, self.popup_response_template or [
1192                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1193                 'admin/%s/popup_response.html' % opts.app_label,
1194                 'admin/popup_response.html',
1195             ], {
1196                 'popup_response_data': popup_response_data,
1197             })
1198 
1199         elif "_continue" in request.POST or (
1200                 # Redirecting after "Save as new".
1201                 "_saveasnew" in request.POST and self.save_as_continue and
1202                 self.has_change_permission(request, obj)
1203         ):
1204             msg = _('The {name} “{obj}” was added successfully.')
1205             if self.has_change_permission(request, obj):
1206                 msg += ' ' + _('You may edit it again below.')
1207             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1208             if post_url_continue is None:
1209                 post_url_continue = obj_url
1210             post_url_continue = add_preserved_filters(
1211                 {'preserved_filters': preserved_filters, 'opts': opts},
1212                 post_url_continue
1213             )
1214             return HttpResponseRedirect(post_url_continue)
1215 
1216         elif "_addanother" in request.POST:
1217             msg = format_html(
1218                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1219                 **msg_dict
1220             )
1221             self.message_user(request, msg, messages.SUCCESS)
1222             redirect_url = request.path
1223             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1224             return HttpResponseRedirect(redirect_url)
1225 
1226         else:
1227             msg = format_html(
1228                 _('The {name} “{obj}” was added successfully.'),
1229                 **msg_dict
1230             )
1231             self.message_user(request, msg, messages.SUCCESS)
1232             return self.response_post_save_add(request, obj)
1233 
1234     def response_change(self, request, obj):
1235         """
1236         Determine the HttpResponse for the change_view stage.
1237         """
1238 
1239         if IS_POPUP_VAR in request.POST:
1240             opts = obj._meta
1241             to_field = request.POST.get(TO_FIELD_VAR)
1242             attr = str(to_field) if to_field else opts.pk.attname
1243             value = request.resolver_match.kwargs['object_id']
1244             new_value = obj.serializable_value(attr)
1245             popup_response_data = json.dumps({
1246                 'action': 'change',
1247                 'value': str(value),
1248                 'obj': str(obj),
1249                 'new_value': str(new_value),
1250             })
1251             return TemplateResponse(request, self.popup_response_template or [
1252                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1253                 'admin/%s/popup_response.html' % opts.app_label,
1254                 'admin/popup_response.html',
1255             ], {
1256                 'popup_response_data': popup_response_data,
1257             })
1258 
1259         opts = self.model._meta
1260         preserved_filters = self.get_preserved_filters(request)
1261 
1262         msg_dict = {
1263             'name': opts.verbose_name,
1264             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1265         }
1266         if "_continue" in request.POST:
1267             msg = format_html(
1268                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1269                 **msg_dict
1270             )
1271             self.message_user(request, msg, messages.SUCCESS)
1272             redirect_url = request.path
1273             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1274             return HttpResponseRedirect(redirect_url)
1275 
1276         elif "_saveasnew" in request.POST:
1277             msg = format_html(
1278                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1279                 **msg_dict
1280             )
1281             self.message_user(request, msg, messages.SUCCESS)
1282             redirect_url = reverse('admin:%s_%s_change' %
1283                                    (opts.app_label, opts.model_name),
1284                                    args=(obj.pk,),
1285                                    current_app=self.admin_site.name)
1286             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1287             return HttpResponseRedirect(redirect_url)
1288 
1289         elif "_addanother" in request.POST:
1290             msg = format_html(
1291                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1292                 **msg_dict
1293             )
1294             self.message_user(request, msg, messages.SUCCESS)
1295             redirect_url = reverse('admin:%s_%s_add' %
1296                                    (opts.app_label, opts.model_name),
1297                                    current_app=self.admin_site.name)
1298             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1299             return HttpResponseRedirect(redirect_url)
1300 
1301         else:
1302             msg = format_html(
1303                 _('The {name} “{obj}” was changed successfully.'),
1304                 **msg_dict
1305             )
1306             self.message_user(request, msg, messages.SUCCESS)
1307             return self.response_post_save_change(request, obj)
1308 
1309     def _response_post_save(self, request, obj):
1310         opts = self.model._meta
1311         if self.has_view_or_change_permission(request):
1312             post_url = reverse('admin:%s_%s_changelist' %
1313                                (opts.app_label, opts.model_name),
1314                                current_app=self.admin_site.name)
1315             preserved_filters = self.get_preserved_filters(request)
1316             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1317         else:
1318             post_url = reverse('admin:index',
1319                                current_app=self.admin_site.name)
1320         return HttpResponseRedirect(post_url)
1321 
1322     def response_post_save_add(self, request, obj):
1323         """
1324         Figure out where to redirect after the 'Save' button has been pressed
1325         when adding a new object.
1326         """
1327         return self._response_post_save(request, obj)
1328 
1329     def response_post_save_change(self, request, obj):
1330         """
1331         Figure out where to redirect after the 'Save' button has been pressed
1332         when editing an existing object.
1333         """
1334         return self._response_post_save(request, obj)
1335 
1336     def response_action(self, request, queryset):
1337         """
1338         Handle an admin action. This is called if a request is POSTed to the
1339         changelist; it returns an HttpResponse if the action was handled, and
1340         None otherwise.
1341         """
1342 
1343         # There can be multiple action forms on the page (at the top
1344         # and bottom of the change list, for example). Get the action
1345         # whose button was pushed.
1346         try:
1347             action_index = int(request.POST.get('index', 0))
1348         except ValueError:
1349             action_index = 0
1350 
1351         # Construct the action form.
1352         data = request.POST.copy()
1353         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1354         data.pop("index", None)
1355 
1356         # Use the action whose button was pushed
1357         try:
1358             data.update({'action': data.getlist('action')[action_index]})
1359         except IndexError:
1360             # If we didn't get an action from the chosen form that's invalid
1361             # POST data, so by deleting action it'll fail the validation check
1362             # below. So no need to do anything here
1363             pass
1364 
1365         action_form = self.action_form(data, auto_id=None)
1366         action_form.fields['action'].choices = self.get_action_choices(request)
1367 
1368         # If the form's valid we can handle the action.
1369         if action_form.is_valid():
1370             action = action_form.cleaned_data['action']
1371             select_across = action_form.cleaned_data['select_across']
1372             func = self.get_actions(request)[action][0]
1373 
1374             # Get the list of selected PKs. If nothing's selected, we can't
1375             # perform an action on it, so bail. Except we want to perform
1376             # the action explicitly on all objects.
1377             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1378             if not selected and not select_across:
1379                 # Reminder that something needs to be selected or nothing will happen
1380                 msg = _("Items must be selected in order to perform "
1381                         "actions on them. No items have been changed.")
1382                 self.message_user(request, msg, messages.WARNING)
1383                 return None
1384 
1385             if not select_across:
1386                 # Perform the action only on the selected objects
1387                 queryset = queryset.filter(pk__in=selected)
1388 
1389             response = func(self, request, queryset)
1390 
1391             # Actions may return an HttpResponse-like object, which will be
1392             # used as the response from the POST. If not, we'll be a good
1393             # little HTTP citizen and redirect back to the changelist page.
1394             if isinstance(response, HttpResponseBase):
1395                 return response
1396             else:
1397                 return HttpResponseRedirect(request.get_full_path())
1398         else:
1399             msg = _("No action selected.")
1400             self.message_user(request, msg, messages.WARNING)
1401             return None
1402 
1403     def response_delete(self, request, obj_display, obj_id):
1404         """
1405         Determine the HttpResponse for the delete_view stage.
1406         """
1407         opts = self.model._meta
1408 
1409         if IS_POPUP_VAR in request.POST:
1410             popup_response_data = json.dumps({
1411                 'action': 'delete',
1412                 'value': str(obj_id),
1413             })
1414             return TemplateResponse(request, self.popup_response_template or [
1415                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1416                 'admin/%s/popup_response.html' % opts.app_label,
1417                 'admin/popup_response.html',
1418             ], {
1419                 'popup_response_data': popup_response_data,
1420             })
1421 
1422         self.message_user(
1423             request,
1424             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1425                 'name': opts.verbose_name,
1426                 'obj': obj_display,
1427             },
1428             messages.SUCCESS,
1429         )
1430 
1431         if self.has_change_permission(request, None):
1432             post_url = reverse(
1433                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1434                 current_app=self.admin_site.name,
1435             )
1436             preserved_filters = self.get_preserved_filters(request)
1437             post_url = add_preserved_filters(
1438                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1439             )
1440         else:
1441             post_url = reverse('admin:index', current_app=self.admin_site.name)
1442         return HttpResponseRedirect(post_url)
1443 
1444     def render_delete_form(self, request, context):
1445         opts = self.model._meta
1446         app_label = opts.app_label
1447 
1448         request.current_app = self.admin_site.name
1449         context.update(
1450             to_field_var=TO_FIELD_VAR,
1451             is_popup_var=IS_POPUP_VAR,
1452             media=self.media,
1453         )
1454 
1455         return TemplateResponse(
1456             request,
1457             self.delete_confirmation_template or [
1458                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1459                 "admin/{}/delete_confirmation.html".format(app_label),
1460                 "admin/delete_confirmation.html",
1461             ],
1462             context,
1463         )
1464 
1465     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1466         # Edit permissions on parent model are required for editable inlines.
1467         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1468         inline_admin_formsets = []
1469         for inline, formset in zip(inline_instances, formsets):
1470             fieldsets = list(inline.get_fieldsets(request, obj))
1471             readonly = list(inline.get_readonly_fields(request, obj))
1472             if can_edit_parent:
1473                 has_add_permission = inline.has_add_permission(request, obj)
1474                 has_change_permission = inline.has_change_permission(request, obj)
1475                 has_delete_permission = inline.has_delete_permission(request, obj)
1476             else:
1477                 # Disable all edit-permissions, and overide formset settings.
1478                 has_add_permission = has_change_permission = has_delete_permission = False
1479                 formset.extra = formset.max_num = 0
1480             has_view_permission = inline.has_view_permission(request, obj)
1481             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1482             inline_admin_formset = helpers.InlineAdminFormSet(
1483                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1484                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1485                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1486             )
1487             inline_admin_formsets.append(inline_admin_formset)
1488         return inline_admin_formsets
1489 
1490     def get_changeform_initial_data(self, request):
1491         """
1492         Get the initial form data from the request's GET params.
1493         """
1494         initial = dict(request.GET.items())
1495         for k in initial:
1496             try:
1497                 f = self.model._meta.get_field(k)
1498             except FieldDoesNotExist:
1499                 continue
1500             # We have to special-case M2Ms as a list of comma-separated PKs.
1501             if isinstance(f, models.ManyToManyField):
1502                 initial[k] = initial[k].split(",")
1503         return initial
1504 
1505     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1506         """
1507         Create a message informing the user that the object doesn't exist
1508         and return a redirect to the admin index page.
1509         """
1510         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1511             'name': opts.verbose_name,
1512             'key': unquote(object_id),
1513         }
1514         self.message_user(request, msg, messages.WARNING)
1515         url = reverse('admin:index', current_app=self.admin_site.name)
1516         return HttpResponseRedirect(url)
1517 
1518     @csrf_protect_m
1519     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1520         with transaction.atomic(using=router.db_for_write(self.model)):
1521             return self._changeform_view(request, object_id, form_url, extra_context)
1522 
1523     def _changeform_view(self, request, object_id, form_url, extra_context):
1524         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1525         if to_field and not self.to_field_allowed(request, to_field):
1526             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1527 
1528         model = self.model
1529         opts = model._meta
1530 
1531         if request.method == 'POST' and '_saveasnew' in request.POST:
1532             object_id = None
1533 
1534         add = object_id is None
1535 
1536         if add:
1537             if not self.has_add_permission(request):
1538                 raise PermissionDenied
1539             obj = None
1540 
1541         else:
1542             obj = self.get_object(request, unquote(object_id), to_field)
1543 
1544             if request.method == 'POST':
1545                 if not self.has_change_permission(request, obj):
1546                     raise PermissionDenied
1547             else:
1548                 if not self.has_view_or_change_permission(request, obj):
1549                     raise PermissionDenied
1550 
1551             if obj is None:
1552                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1553 
1554         fieldsets = self.get_fieldsets(request, obj)
1555         ModelForm = self.get_form(
1556             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1557         )
1558         if request.method == 'POST':
1559             form = ModelForm(request.POST, request.FILES, instance=obj)
1560             form_validated = form.is_valid()
1561             if form_validated:
1562                 new_object = self.save_form(request, form, change=not add)
1563             else:
1564                 new_object = form.instance
1565             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1566             if all_valid(formsets) and form_validated:
1567                 self.save_model(request, new_object, form, not add)
1568                 self.save_related(request, form, formsets, not add)
1569                 change_message = self.construct_change_message(request, form, formsets, add)
1570                 if add:
1571                     self.log_addition(request, new_object, change_message)
1572                     return self.response_add(request, new_object)
1573                 else:
1574                     self.log_change(request, new_object, change_message)
1575                     return self.response_change(request, new_object)
1576             else:
1577                 form_validated = False
1578         else:
1579             if add:
1580                 initial = self.get_changeform_initial_data(request)
1581                 form = ModelForm(initial=initial)
1582                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1583             else:
1584                 form = ModelForm(instance=obj)
1585                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1586 
1587         if not add and not self.has_change_permission(request, obj):
1588             readonly_fields = flatten_fieldsets(fieldsets)
1589         else:
1590             readonly_fields = self.get_readonly_fields(request, obj)
1591         adminForm = helpers.AdminForm(
1592             form,
1593             list(fieldsets),
1594             # Clear prepopulated fields on a view-only form to avoid a crash.
1595             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1596             readonly_fields,
1597             model_admin=self)
1598         media = self.media + adminForm.media
1599 
1600         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1601         for inline_formset in inline_formsets:
1602             media = media + inline_formset.media
1603 
1604         if add:
1605             title = _('Add %s')
1606         elif self.has_change_permission(request, obj):
1607             title = _('Change %s')
1608         else:
1609             title = _('View %s')
1610         context = {
1611             **self.admin_site.each_context(request),
1612             'title': title % opts.verbose_name,
1613             'adminform': adminForm,
1614             'object_id': object_id,
1615             'original': obj,
1616             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1617             'to_field': to_field,
1618             'media': media,
1619             'inline_admin_formsets': inline_formsets,
1620             'errors': helpers.AdminErrorList(form, formsets),
1621             'preserved_filters': self.get_preserved_filters(request),
1622         }
1623 
1624         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1625         # previously chosen to prevent the interface from getting confusing.
1626         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1627             context['show_save'] = False
1628             context['show_save_and_continue'] = False
1629             # Use the change template instead of the add template.
1630             add = False
1631 
1632         context.update(extra_context or {})
1633 
1634         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1635 
1636     def autocomplete_view(self, request):
1637         return AutocompleteJsonView.as_view(model_admin=self)(request)
1638 
1639     def add_view(self, request, form_url='', extra_context=None):
1640         return self.changeform_view(request, None, form_url, extra_context)
1641 
1642     def change_view(self, request, object_id, form_url='', extra_context=None):
1643         return self.changeform_view(request, object_id, form_url, extra_context)
1644 
1645     def _get_edited_object_pks(self, request, prefix):
1646         """Return POST data values of list_editable primary keys."""
1647         pk_pattern = re.compile(
1648             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1649         )
1650         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1651 
1652     def _get_list_editable_queryset(self, request, prefix):
1653         """
1654         Based on POST data, return a queryset of the objects that were edited
1655         via list_editable.
1656         """
1657         object_pks = self._get_edited_object_pks(request, prefix)
1658         queryset = self.get_queryset(request)
1659         validate = queryset.model._meta.pk.to_python
1660         try:
1661             for pk in object_pks:
1662                 validate(pk)
1663         except ValidationError:
1664             # Disable the optimization if the POST data was tampered with.
1665             return queryset
1666         return queryset.filter(pk__in=object_pks)
1667 
1668     @csrf_protect_m
1669     def changelist_view(self, request, extra_context=None):
1670         """
1671         The 'change list' admin view for this model.
1672         """
1673         from django.contrib.admin.views.main import ERROR_FLAG
1674         opts = self.model._meta
1675         app_label = opts.app_label
1676         if not self.has_view_or_change_permission(request):
1677             raise PermissionDenied
1678 
1679         try:
1680             cl = self.get_changelist_instance(request)
1681         except IncorrectLookupParameters:
1682             # Wacky lookup parameters were given, so redirect to the main
1683             # changelist page, without parameters, and pass an 'invalid=1'
1684             # parameter via the query string. If wacky parameters were given
1685             # and the 'invalid=1' parameter was already in the query string,
1686             # something is screwed up with the database, so display an error
1687             # page.
1688             if ERROR_FLAG in request.GET:
1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1690                     'title': _('Database error'),
1691                 })
1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1693 
1694         # If the request was POSTed, this might be a bulk action or a bulk
1695         # edit. Try to look up an action or confirmation first, but if this
1696         # isn't an action the POST will fall through to the bulk edit check,
1697         # below.
1698         action_failed = False
1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1700 
1701         actions = self.get_actions(request)
1702         # Actions with no confirmation
1703         if (actions and request.method == 'POST' and
1704                 'index' in request.POST and '_save' not in request.POST):
1705             if selected:
1706                 response = self.response_action(request, queryset=cl.get_queryset(request))
1707                 if response:
1708                     return response
1709                 else:
1710                     action_failed = True
1711             else:
1712                 msg = _("Items must be selected in order to perform "
1713                         "actions on them. No items have been changed.")
1714                 self.message_user(request, msg, messages.WARNING)
1715                 action_failed = True
1716 
1717         # Actions with confirmation
1718         if (actions and request.method == 'POST' and
1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1720                 'index' not in request.POST and '_save' not in request.POST):
1721             if selected:
1722                 response = self.response_action(request, queryset=cl.get_queryset(request))
1723                 if response:
1724                     return response
1725                 else:
1726                     action_failed = True
1727 
1728         if action_failed:
1729             # Redirect back to the changelist page to avoid resubmitting the
1730             # form if the user refreshes the browser or uses the "No, take
1731             # me back" button on the action confirmation page.
1732             return HttpResponseRedirect(request.get_full_path())
1733 
1734         # If we're allowing changelist editing, we need to construct a formset
1735         # for the changelist given all the fields to be edited. Then we'll
1736         # use the formset to validate/process POSTed data.
1737         formset = cl.formset = None
1738 
1739         # Handle POSTed bulk-edit data.
1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1741             if not self.has_change_permission(request):
1742                 raise PermissionDenied
1743             FormSet = self.get_changelist_formset(request)
1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1746             if formset.is_valid():
1747                 changecount = 0
1748                 for form in formset.forms:
1749                     if form.has_changed():
1750                         obj = self.save_form(request, form, change=True)
1751                         self.save_model(request, obj, form, change=True)
1752                         self.save_related(request, form, formsets=[], change=True)
1753                         change_msg = self.construct_change_message(request, form, None)
1754                         self.log_change(request, obj, change_msg)
1755                         changecount += 1
1756 
1757                 if changecount:
1758                     msg = ngettext(
1759                         "%(count)s %(name)s was changed successfully.",
1760                         "%(count)s %(name)s were changed successfully.",
1761                         changecount
1762                     ) % {
1763                         'count': changecount,
1764                         'name': model_ngettext(opts, changecount),
1765                     }
1766                     self.message_user(request, msg, messages.SUCCESS)
1767 
1768                 return HttpResponseRedirect(request.get_full_path())
1769 
1770         # Handle GET -- construct a formset for display.
1771         elif cl.list_editable and self.has_change_permission(request):
1772             FormSet = self.get_changelist_formset(request)
1773             formset = cl.formset = FormSet(queryset=cl.result_list)
1774 
1775         # Build the list of media to be used by the formset.
1776         if formset:
1777             media = self.media + formset.media
1778         else:
1779             media = self.media
1780 
1781         # Build the action form and populate it with available actions.
1782         if actions:
1783             action_form = self.action_form(auto_id=None)
1784             action_form.fields['action'].choices = self.get_action_choices(request)
1785             media += action_form.media
1786         else:
1787             action_form = None
1788 
1789         selection_note_all = ngettext(
1790             '%(total_count)s selected',
1791             'All %(total_count)s selected',
1792             cl.result_count
1793         )
1794 
1795         context = {
1796             **self.admin_site.each_context(request),
1797             'module_name': str(opts.verbose_name_plural),
1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1800             'title': cl.title,
1801             'is_popup': cl.is_popup,
1802             'to_field': cl.to_field,
1803             'cl': cl,
1804             'media': media,
1805             'has_add_permission': self.has_add_permission(request),
1806             'opts': cl.opts,
1807             'action_form': action_form,
1808             'actions_on_top': self.actions_on_top,
1809             'actions_on_bottom': self.actions_on_bottom,
1810             'actions_selection_counter': self.actions_selection_counter,
1811             'preserved_filters': self.get_preserved_filters(request),
1812             **(extra_context or {}),
1813         }
1814 
1815         request.current_app = self.admin_site.name
1816 
1817         return TemplateResponse(request, self.change_list_template or [
1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1819             'admin/%s/change_list.html' % app_label,
1820             'admin/change_list.html'
1821         ], context)
1822 
1823     def get_deleted_objects(self, objs, request):
1824         """
1825         Hook for customizing the delete process for the delete view and the
1826         "delete selected" action.
1827         """
1828         return get_deleted_objects(objs, request, self.admin_site)
1829 
1830     @csrf_protect_m
1831     def delete_view(self, request, object_id, extra_context=None):
1832         with transaction.atomic(using=router.db_for_write(self.model)):
1833             return self._delete_view(request, object_id, extra_context)
1834 
1835     def _delete_view(self, request, object_id, extra_context):
1836         "The 'delete' admin view for this model."
1837         opts = self.model._meta
1838         app_label = opts.app_label
1839 
1840         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1841         if to_field and not self.to_field_allowed(request, to_field):
1842             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1843 
1844         obj = self.get_object(request, unquote(object_id), to_field)
1845 
1846         if not self.has_delete_permission(request, obj):
1847             raise PermissionDenied
1848 
1849         if obj is None:
1850             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1851 
1852         # Populate deleted_objects, a data structure of all related objects that
1853         # will also be deleted.
1854         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1855 
1856         if request.POST and not protected:  # The user has confirmed the deletion.
1857             if perms_needed:
1858                 raise PermissionDenied
1859             obj_display = str(obj)
1860             attr = str(to_field) if to_field else opts.pk.attname
1861             obj_id = obj.serializable_value(attr)
1862             self.log_deletion(request, obj, obj_display)
1863             self.delete_model(request, obj)
1864 
1865             return self.response_delete(request, obj_display, obj_id)
1866 
1867         object_name = str(opts.verbose_name)
1868 
1869         if perms_needed or protected:
1870             title = _("Cannot delete %(name)s") % {"name": object_name}
1871         else:
1872             title = _("Are you sure?")
1873 
1874         context = {
1875             **self.admin_site.each_context(request),
1876             'title': title,
1877             'object_name': object_name,
1878             'object': obj,
1879             'deleted_objects': deleted_objects,
1880             'model_count': dict(model_count).items(),
1881             'perms_lacking': perms_needed,
1882             'protected': protected,
1883             'opts': opts,
1884             'app_label': app_label,
1885             'preserved_filters': self.get_preserved_filters(request),
1886             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1887             'to_field': to_field,
1888             **(extra_context or {}),
1889         }
1890 
1891         return self.render_delete_form(request, context)
1892 
1893     def history_view(self, request, object_id, extra_context=None):
1894         "The 'history' admin view for this model."
1895         from django.contrib.admin.models import LogEntry
1896         # First check if the user can see this history.
1897         model = self.model
1898         obj = self.get_object(request, unquote(object_id))
1899         if obj is None:
1900             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1901 
1902         if not self.has_view_or_change_permission(request, obj):
1903             raise PermissionDenied
1904 
1905         # Then get the history for this object.
1906         opts = model._meta
1907         app_label = opts.app_label
1908         action_list = LogEntry.objects.filter(
1909             object_id=unquote(object_id),
1910             content_type=get_content_type_for_model(model)
1911         ).select_related().order_by('action_time')
1912 
1913         context = {
1914             **self.admin_site.each_context(request),
1915             'title': _('Change history: %s') % obj,
1916             'action_list': action_list,
1917             'module_name': str(capfirst(opts.verbose_name_plural)),
1918             'object': obj,
1919             'opts': opts,
1920             'preserved_filters': self.get_preserved_filters(request),
1921             **(extra_context or {}),
1922         }
1923 
1924         request.current_app = self.admin_site.name
1925 
1926         return TemplateResponse(request, self.object_history_template or [
1927             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1928             "admin/%s/object_history.html" % app_label,
1929             "admin/object_history.html"
1930         ], context)
1931 
1932     def _create_formsets(self, request, obj, change):
1933         "Helper function to generate formsets for add/change_view."
1934         formsets = []
1935         inline_instances = []
1936         prefixes = {}
1937         get_formsets_args = [request]
1938         if change:
1939             get_formsets_args.append(obj)
1940         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1941             prefix = FormSet.get_default_prefix()
1942             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1943             if prefixes[prefix] != 1 or not prefix:
1944                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1945             formset_params = {
1946                 'instance': obj,
1947                 'prefix': prefix,
1948                 'queryset': inline.get_queryset(request),
1949             }
1950             if request.method == 'POST':
1951                 formset_params.update({
1952                     'data': request.POST.copy(),
1953                     'files': request.FILES,
1954                     'save_as_new': '_saveasnew' in request.POST
1955                 })
1956             formset = FormSet(**formset_params)
1957 
1958             def user_deleted_form(request, obj, formset, index):
1959                 """Return whether or not the user deleted the form."""
1960                 return (
1961                     inline.has_delete_permission(request, obj) and
1962                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1963                 )
1964 
1965             # Bypass validation of each view-only inline form (since the form's
1966             # data won't be in request.POST), unless the form was deleted.
1967             if not inline.has_change_permission(request, obj if change else None):
1968                 for index, form in enumerate(formset.initial_forms):
1969                     if user_deleted_form(request, obj, formset, index):
1970                         continue
1971                     form._errors = {}
1972                     form.cleaned_data = form.initial
1973             formsets.append(formset)
1974             inline_instances.append(inline)
1975         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 04:27:50.712 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 04:27:50.712 | INFO     | Search-only: skipping patch selection
2025-10-15 04:27:50.876 | INFO     | Task django__django-12469 completed successfully.
2025-10-15 04:27:50.877 | INFO     | No patch generated. You can try running ACR again.
