2025-10-15 10:03:40.490 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 10:03:42.707 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=196, output_tokens=12, cost=0.002320
2025-10-15 10:03:42.708 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 10:03:42.712 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 10:03:50.495 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=505, output_tokens=220, cost=0.011650
2025-10-15 10:03:50.500 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 10:03:53.739 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=574, output_tokens=42, cost=0.007000
2025-10-15 10:03:53.740 | DEBUG    | Extracted a valid json.
2025-10-15 10:03:53.740 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"set_level\", \"caplog\")",
        "search_code(\"_initial_handler_level\")"
    ],
    "bug_locations": []
}
2025-10-15 10:03:53.759 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 10:03:53.760 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 10:04:07.425 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=910, output_tokens=514, cost=0.024520
2025-10-15 10:04:07.435 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 10:04:19.710 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1640, output_tokens=386, cost=0.027980
2025-10-15 10:04:19.718 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 10:04:31.633 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=740, output_tokens=248, cost=0.014840
2025-10-15 10:04:31.634 | DEBUG    | Extracted a valid json.
2025-10-15 10:04:31.634 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/logging.py",
            "class": "",
            "method": "",
            "intended_behavior": "Within the involved method(s) in src/_pytest/logging.py that manage logging levels via caplog.set_level, ensure that _initial_handler_level dictionary uses setdefault rather than set when updating handler levels for the first time. This change is crucial to ensure that the initial logging level of each handler is captured and preserved correctly before any test manipulates it. When restoring handler levels after a test, the restoration process should reference _initial_handler_level to set each handler's level back to its original state before the first set_level call in the test scope, ensuring true restoration to pre-test conditions. Ensure that if set_level is called multiple times within the same test, _initial_handler_level does not overwrite the initially stored level with subsequent calls. Only the first call's level should be stored as the initial state to be restored post-test. This restoration mechanism ensures that tests which modify logging levels do not interfere with each other by incorrectly setting up logging states based on the modifications made by previous tests within the same session."
        }
    ]
}
2025-10-15 10:04:31.640 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Access and control log capturing."""
2 import logging
3 import os
4 import re
5 import sys
6 from contextlib import contextmanager
7 from io import StringIO
8 from typing import AbstractSet
9 from typing import Dict
10 from typing import Generator
11 from typing import List
12 from typing import Mapping
13 from typing import Optional
14 from typing import Tuple
15 from typing import TypeVar
16 from typing import Union
17 
18 import pytest
19 from _pytest import nodes
20 from _pytest._io import TerminalWriter
21 from _pytest.capture import CaptureManager
22 from _pytest.compat import nullcontext
23 from _pytest.config import _strtobool
24 from _pytest.config import Config
25 from _pytest.config import create_terminal_writer
26 from _pytest.config.argparsing import Parser
27 from _pytest.fixtures import FixtureRequest
28 from _pytest.main import Session
29 from _pytest.pathlib import Path
30 from _pytest.store import StoreKey
31 from _pytest.terminal import TerminalReporter
32 
33 
34 DEFAULT_LOG_FORMAT = "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s"
35 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
36 _ANSI_ESCAPE_SEQ = re.compile(r"\x1b\[[\d;]+m")
37 caplog_handler_key = StoreKey["LogCaptureHandler"]()
38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()
39 
40 
41 def _remove_ansi_escape_sequences(text: str) -> str:
42     return _ANSI_ESCAPE_SEQ.sub("", text)
43 
44 
45 class ColoredLevelFormatter(logging.Formatter):
46     """A logging formatter which colorizes the %(levelname)..s part of the
47     log format passed to __init__."""
48 
49     LOGLEVEL_COLOROPTS = {
50         logging.CRITICAL: {"red"},
51         logging.ERROR: {"red", "bold"},
52         logging.WARNING: {"yellow"},
53         logging.WARN: {"yellow"},
54         logging.INFO: {"green"},
55         logging.DEBUG: {"purple"},
56         logging.NOTSET: set(),
57     }  # type: Mapping[int, AbstractSet[str]]
58     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-.]?\d*s)")
59 
60     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:
61         super().__init__(*args, **kwargs)
62         self._original_fmt = self._style._fmt
63         self._level_to_fmt_mapping = {}  # type: Dict[int, str]
64 
65         assert self._fmt is not None
66         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
67         if not levelname_fmt_match:
68             return
69         levelname_fmt = levelname_fmt_match.group()
70 
71         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
72             formatted_levelname = levelname_fmt % {
73                 "levelname": logging.getLevelName(level)
74             }
75 
76             # add ANSI escape sequences around the formatted levelname
77             color_kwargs = {name: True for name in color_opts}
78             colorized_formatted_levelname = terminalwriter.markup(
79                 formatted_levelname, **color_kwargs
80             )
81             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
82                 colorized_formatted_levelname, self._fmt
83             )
84 
85     def format(self, record: logging.LogRecord) -> str:
86         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
87         self._style._fmt = fmt
88         return super().format(record)
89 
90 
91 class PercentStyleMultiline(logging.PercentStyle):
92     """A logging style with special support for multiline messages.
93 
94     If the message of a record consists of multiple lines, this style
95     formats the message as if each line were logged separately.
96     """
97 
98     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:
99         super().__init__(fmt)
100         self._auto_indent = self._get_auto_indent(auto_indent)
101 
102     @staticmethod
103     def _update_message(
104         record_dict: Dict[str, object], message: str
105     ) -> Dict[str, object]:
106         tmp = record_dict.copy()
107         tmp["message"] = message
108         return tmp
109 
110     @staticmethod
111     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:
112         """Determine the current auto indentation setting.
113 
114         Specify auto indent behavior (on/off/fixed) by passing in
115         extra={"auto_indent": [value]} to the call to logging.log() or
116         using a --log-auto-indent [value] command line or the
117         log_auto_indent [value] config option.
118 
119         Default behavior is auto-indent off.
120 
121         Using the string "True" or "on" or the boolean True as the value
122         turns auto indent on, using the string "False" or "off" or the
123         boolean False or the int 0 turns it off, and specifying a
124         positive integer fixes the indentation position to the value
125         specified.
126 
127         Any other values for the option are invalid, and will silently be
128         converted to the default.
129 
130         :param None|bool|int|str auto_indent_option:
131             User specified option for indentation from command line, config
132             or extra kwarg. Accepts int, bool or str. str option accepts the
133             same range of values as boolean config options, as well as
134             positive integers represented in str form.
135 
136         :returns:
137             Indentation value, which can be
138             -1 (automatically determine indentation) or
139             0 (auto-indent turned off) or
140             >0 (explicitly set indentation position).
141         """
142 
143         if auto_indent_option is None:
144             return 0
145         elif isinstance(auto_indent_option, bool):
146             if auto_indent_option:
147                 return -1
148             else:
149                 return 0
150         elif isinstance(auto_indent_option, int):
151             return int(auto_indent_option)
152         elif isinstance(auto_indent_option, str):
153             try:
154                 return int(auto_indent_option)
155             except ValueError:
156                 pass
157             try:
158                 if _strtobool(auto_indent_option):
159                     return -1
160             except ValueError:
161                 return 0
162 
163         return 0
164 
165     def format(self, record: logging.LogRecord) -> str:
166         if "\n" in record.message:
167             if hasattr(record, "auto_indent"):
168                 # Passed in from the "extra={}" kwarg on the call to logging.log().
169                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined]
170             else:
171                 auto_indent = self._auto_indent
172 
173             if auto_indent:
174                 lines = record.message.splitlines()
175                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])
176 
177                 if auto_indent < 0:
178                     indentation = _remove_ansi_escape_sequences(formatted).find(
179                         lines[0]
180                     )
181                 else:
182                     # Optimizes logging by allowing a fixed indentation.
183                     indentation = auto_indent
184                 lines[0] = formatted
185                 return ("\n" + " " * indentation).join(lines)
186         return self._fmt % record.__dict__
187 
188 
189 def get_option_ini(config: Config, *names: str):
190     for name in names:
191         ret = config.getoption(name)  # 'default' arg won't work as expected
192         if ret is None:
193             ret = config.getini(name)
194         if ret:
195             return ret
196 
197 
198 def pytest_addoption(parser: Parser) -> None:
199     """Add options to control log capturing."""
200     group = parser.getgroup("logging")
201 
202     def add_option_ini(option, dest, default=None, type=None, **kwargs):
203         parser.addini(
204             dest, default=default, type=type, help="default value for " + option
205         )
206         group.addoption(option, dest=dest, **kwargs)
207 
208     add_option_ini(
209         "--log-level",
210         dest="log_level",
211         default=None,
212         metavar="LEVEL",
213         help=(
214             "level of messages to catch/display.\n"
215             "Not set by default, so it depends on the root/parent log handler's"
216             ' effective level, where it is "WARNING" by default.'
217         ),
218     )
219     add_option_ini(
220         "--log-format",
221         dest="log_format",
222         default=DEFAULT_LOG_FORMAT,
223         help="log format as used by the logging module.",
224     )
225     add_option_ini(
226         "--log-date-format",
227         dest="log_date_format",
228         default=DEFAULT_LOG_DATE_FORMAT,
229         help="log date format as used by the logging module.",
230     )
231     parser.addini(
232         "log_cli",
233         default=False,
234         type="bool",
235         help='enable log display during test run (also known as "live logging").',
236     )
237     add_option_ini(
238         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
239     )
240     add_option_ini(
241         "--log-cli-format",
242         dest="log_cli_format",
243         default=None,
244         help="log format as used by the logging module.",
245     )
246     add_option_ini(
247         "--log-cli-date-format",
248         dest="log_cli_date_format",
249         default=None,
250         help="log date format as used by the logging module.",
251     )
252     add_option_ini(
253         "--log-file",
254         dest="log_file",
255         default=None,
256         help="path to a file when logging will be written to.",
257     )
258     add_option_ini(
259         "--log-file-level",
260         dest="log_file_level",
261         default=None,
262         help="log file logging level.",
263     )
264     add_option_ini(
265         "--log-file-format",
266         dest="log_file_format",
267         default=DEFAULT_LOG_FORMAT,
268         help="log format as used by the logging module.",
269     )
270     add_option_ini(
271         "--log-file-date-format",
272         dest="log_file_date_format",
273         default=DEFAULT_LOG_DATE_FORMAT,
274         help="log date format as used by the logging module.",
275     )
276     add_option_ini(
277         "--log-auto-indent",
278         dest="log_auto_indent",
279         default=None,
280         help="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
281     )
282 
283 
284 _HandlerType = TypeVar("_HandlerType", bound=logging.Handler)
285 
286 
287 # Not using @contextmanager for performance reasons.
288 class catching_logs:
289     """Context manager that prepares the whole logging machinery properly."""
290 
291     __slots__ = ("handler", "level", "orig_level")
292 
293     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:
294         self.handler = handler
295         self.level = level
296 
297     def __enter__(self):
298         root_logger = logging.getLogger()
299         if self.level is not None:
300             self.handler.setLevel(self.level)
301         root_logger.addHandler(self.handler)
302         if self.level is not None:
303             self.orig_level = root_logger.level
304             root_logger.setLevel(min(self.orig_level, self.level))
305         return self.handler
306 
307     def __exit__(self, type, value, traceback):
308         root_logger = logging.getLogger()
309         if self.level is not None:
310             root_logger.setLevel(self.orig_level)
311         root_logger.removeHandler(self.handler)
312 
313 
314 class LogCaptureHandler(logging.StreamHandler):
315     """A logging handler that stores log records and the log text."""
316 
317     stream = None  # type: StringIO
318 
319     def __init__(self) -> None:
320         """Create a new log handler."""
321         super().__init__(StringIO())
322         self.records = []  # type: List[logging.LogRecord]
323 
324     def emit(self, record: logging.LogRecord) -> None:
325         """Keep the log records in a list in addition to the log text."""
326         self.records.append(record)
327         super().emit(record)
328 
329     def reset(self) -> None:
330         self.records = []
331         self.stream = StringIO()
332 
333     def handleError(self, record: logging.LogRecord) -> None:
334         if logging.raiseExceptions:
335             # Fail the test if the log message is bad (emit failed).
336             # The default behavior of logging is to print "Logging error"
337             # to stderr with the call stack and some extra details.
338             # pytest wants to make such mistakes visible during testing.
339             raise
340 
341 
342 class LogCaptureFixture:
343     """Provides access and control of log capturing."""
344 
345     def __init__(self, item: nodes.Node) -> None:
346         self._item = item
347         self._initial_handler_level = None  # type: Optional[int]
348         # Dict of log name -> log level.
349         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]
350 
351     def _finalize(self) -> None:
352         """Finalize the fixture.
353 
354         This restores the log levels changed by :meth:`set_level`.
355         """
356         # Restore log levels.
357         if self._initial_handler_level is not None:
358             self.handler.setLevel(self._initial_handler_level)
359         for logger_name, level in self._initial_logger_levels.items():
360             logger = logging.getLogger(logger_name)
361             logger.setLevel(level)
362 
363     @property
364     def handler(self) -> LogCaptureHandler:
365         """Get the logging handler used by the fixture.
366 
367         :rtype: LogCaptureHandler
368         """
369         return self._item._store[caplog_handler_key]
370 
371     def get_records(self, when: str) -> List[logging.LogRecord]:
372         """Get the logging records for one of the possible test phases.
373 
374         :param str when:
375             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
376 
377         :returns: The list of captured records at the given stage.
378         :rtype: List[logging.LogRecord]
379 
380         .. versionadded:: 3.4
381         """
382         return self._item._store[caplog_records_key].get(when, [])
383 
384     @property
385     def text(self) -> str:
386         """The formatted log text."""
387         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())
388 
389     @property
390     def records(self) -> List[logging.LogRecord]:
391         """The list of log records."""
392         return self.handler.records
393 
394     @property
395     def record_tuples(self) -> List[Tuple[str, int, str]]:
396         """A list of a stripped down version of log records intended
397         for use in assertion comparison.
398 
399         The format of the tuple is:
400 
401             (logger_name, log_level, message)
402         """
403         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
404 
405     @property
406     def messages(self) -> List[str]:
407         """A list of format-interpolated log messages.
408 
409         Unlike 'records', which contains the format string and parameters for
410         interpolation, log messages in this list are all interpolated.
411 
412         Unlike 'text', which contains the output from the handler, log
413         messages in this list are unadorned with levels, timestamps, etc,
414         making exact comparisons more reliable.
415 
416         Note that traceback or stack info (from :func:`logging.exception` or
417         the `exc_info` or `stack_info` arguments to the logging functions) is
418         not included, as this is added by the formatter in the handler.
419 
420         .. versionadded:: 3.7
421         """
422         return [r.getMessage() for r in self.records]
423 
424     def clear(self) -> None:
425         """Reset the list of log records and the captured log text."""
426         self.handler.reset()
427 
428     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:
429         """Set the level of a logger for the duration of a test.
430 
431         .. versionchanged:: 3.4
432             The levels of the loggers changed by this function will be
433             restored to their initial values at the end of the test.
434 
435         :param int level: The level.
436         :param str logger: The logger to update. If not given, the root logger.
437         """
438         logger_obj = logging.getLogger(logger)
439         # Save the original log-level to restore it during teardown.
440         self._initial_logger_levels.setdefault(logger, logger_obj.level)
441         logger_obj.setLevel(level)
442         self._initial_handler_level = self.handler.level
443         self.handler.setLevel(level)
444 
445     @contextmanager
446     def at_level(
447         self, level: int, logger: Optional[str] = None
448     ) -> Generator[None, None, None]:
449         """Context manager that sets the level for capturing of logs. After
450         the end of the 'with' statement the level is restored to its original
451         value.
452 
453         :param int level: The level.
454         :param str logger: The logger to update. If not given, the root logger.
455         """
456         logger_obj = logging.getLogger(logger)
457         orig_level = logger_obj.level
458         logger_obj.setLevel(level)
459         handler_orig_level = self.handler.level
460         self.handler.setLevel(level)
461         try:
462             yield
463         finally:
464             logger_obj.setLevel(orig_level)
465             self.handler.setLevel(handler_orig_level)
466 
467 
468 @pytest.fixture
469 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:
470     """Access and control log capturing.
471 
472     Captured logs are available through the following properties/methods::
473 
474     * caplog.messages        -> list of format-interpolated log messages
475     * caplog.text            -> string containing formatted log output
476     * caplog.records         -> list of logging.LogRecord instances
477     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
478     * caplog.clear()         -> clear captured records and formatted log output string
479     """
480     result = LogCaptureFixture(request.node)
481     yield result
482     result._finalize()
483 
484 
485 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:
486     for setting_name in setting_names:
487         log_level = config.getoption(setting_name)
488         if log_level is None:
489             log_level = config.getini(setting_name)
490         if log_level:
491             break
492     else:
493         return None
494 
495     if isinstance(log_level, str):
496         log_level = log_level.upper()
497     try:
498         return int(getattr(logging, log_level, log_level))
499     except ValueError as e:
500         # Python logging does not recognise this as a logging level
501         raise pytest.UsageError(
502             "'{}' is not recognized as a logging level name for "
503             "'{}'. Please consider passing the "
504             "logging level num instead.".format(log_level, setting_name)
505         ) from e
506 
507 
508 # run after terminalreporter/capturemanager are configured
509 @pytest.hookimpl(trylast=True)
510 def pytest_configure(config: Config) -> None:
511     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
512 
513 
514 class LoggingPlugin:
515     """Attaches to the logging module and captures log messages for each test."""
516 
517     def __init__(self, config: Config) -> None:
518         """Create a new plugin to capture log messages.
519 
520         The formatter can be safely shared across all handlers so
521         create a single one for the entire test session here.
522         """
523         self._config = config
524 
525         # Report logging.
526         self.formatter = self._create_formatter(
527             get_option_ini(config, "log_format"),
528             get_option_ini(config, "log_date_format"),
529             get_option_ini(config, "log_auto_indent"),
530         )
531         self.log_level = get_log_level_for_setting(config, "log_level")
532         self.caplog_handler = LogCaptureHandler()
533         self.caplog_handler.setFormatter(self.formatter)
534         self.report_handler = LogCaptureHandler()
535         self.report_handler.setFormatter(self.formatter)
536 
537         # File logging.
538         self.log_file_level = get_log_level_for_setting(config, "log_file_level")
539         log_file = get_option_ini(config, "log_file") or os.devnull
540         if log_file != os.devnull:
541             directory = os.path.dirname(os.path.abspath(log_file))
542             if not os.path.isdir(directory):
543                 os.makedirs(directory)
544 
545         self.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
546         log_file_format = get_option_ini(config, "log_file_format", "log_format")
547         log_file_date_format = get_option_ini(
548             config, "log_file_date_format", "log_date_format"
549         )
550 
551         log_file_formatter = logging.Formatter(
552             log_file_format, datefmt=log_file_date_format
553         )
554         self.log_file_handler.setFormatter(log_file_formatter)
555 
556         # CLI/live logging.
557         self.log_cli_level = get_log_level_for_setting(
558             config, "log_cli_level", "log_level"
559         )
560         if self._log_cli_enabled():
561             terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
562             capture_manager = config.pluginmanager.get_plugin("capturemanager")
563             # if capturemanager plugin is disabled, live logging still works.
564             self.log_cli_handler = _LiveLoggingStreamHandler(
565                 terminal_reporter, capture_manager
566             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]
567         else:
568             self.log_cli_handler = _LiveLoggingNullHandler()
569         log_cli_formatter = self._create_formatter(
570             get_option_ini(config, "log_cli_format", "log_format"),
571             get_option_ini(config, "log_cli_date_format", "log_date_format"),
572             get_option_ini(config, "log_auto_indent"),
573         )
574         self.log_cli_handler.setFormatter(log_cli_formatter)
575 
576     def _create_formatter(self, log_format, log_date_format, auto_indent):
577         # Color option doesn't exist if terminal plugin is disabled.
578         color = getattr(self._config.option, "color", "no")
579         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
580             log_format
581         ):
582             formatter = ColoredLevelFormatter(
583                 create_terminal_writer(self._config), log_format, log_date_format
584             )  # type: logging.Formatter
585         else:
586             formatter = logging.Formatter(log_format, log_date_format)
587 
588         formatter._style = PercentStyleMultiline(
589             formatter._style._fmt, auto_indent=auto_indent
590         )
591 
592         return formatter
593 
594     def set_log_path(self, fname: str) -> None:
595         """Set the filename parameter for Logging.FileHandler().
596 
597         Creates parent directory if it does not exist.
598 
599         .. warning::
600             This is an experimental API.
601         """
602         fpath = Path(fname)
603 
604         if not fpath.is_absolute():
605             fpath = Path(str(self._config.rootdir), fpath)
606 
607         if not fpath.parent.exists():
608             fpath.parent.mkdir(exist_ok=True, parents=True)
609 
610         stream = fpath.open(mode="w", encoding="UTF-8")
611         if sys.version_info >= (3, 7):
612             old_stream = self.log_file_handler.setStream(stream)
613         else:
614             old_stream = self.log_file_handler.stream
615             self.log_file_handler.acquire()
616             try:
617                 self.log_file_handler.flush()
618                 self.log_file_handler.stream = stream
619             finally:
620                 self.log_file_handler.release()
621         if old_stream:
622             old_stream.close()
623 
624     def _log_cli_enabled(self):
625         """Return whether live logging is enabled."""
626         enabled = self._config.getoption(
627             "--log-cli-level"
628         ) is not None or self._config.getini("log_cli")
629         if not enabled:
630             return False
631 
632         terminal_reporter = self._config.pluginmanager.get_plugin("terminalreporter")
633         if terminal_reporter is None:
634             # terminal reporter is disabled e.g. by pytest-xdist.
635             return False
636 
637         return True
638 
639     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
640     def pytest_sessionstart(self) -> Generator[None, None, None]:
641         self.log_cli_handler.set_when("sessionstart")
642 
643         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
644             with catching_logs(self.log_file_handler, level=self.log_file_level):
645                 yield
646 
647     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
648     def pytest_collection(self) -> Generator[None, None, None]:
649         self.log_cli_handler.set_when("collection")
650 
651         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
652             with catching_logs(self.log_file_handler, level=self.log_file_level):
653                 yield
654 
655     @pytest.hookimpl(hookwrapper=True)
656     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:
657         if session.config.option.collectonly:
658             yield
659             return
660 
661         if self._log_cli_enabled() and self._config.getoption("verbose") < 1:
662             # The verbose flag is needed to avoid messy test progress output.
663             self._config.option.verbose = 1
664 
665         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
666             with catching_logs(self.log_file_handler, level=self.log_file_level):
667                 yield  # Run all the tests.
668 
669     @pytest.hookimpl
670     def pytest_runtest_logstart(self) -> None:
671         self.log_cli_handler.reset()
672         self.log_cli_handler.set_when("start")
673 
674     @pytest.hookimpl
675     def pytest_runtest_logreport(self) -> None:
676         self.log_cli_handler.set_when("logreport")
677 
678     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
679         """Implement the internals of the pytest_runtest_xxx() hooks."""
680         with catching_logs(
681             self.caplog_handler, level=self.log_level,
682         ) as caplog_handler, catching_logs(
683             self.report_handler, level=self.log_level,
684         ) as report_handler:
685             caplog_handler.reset()
686             report_handler.reset()
687             item._store[caplog_records_key][when] = caplog_handler.records
688             item._store[caplog_handler_key] = caplog_handler
689 
690             yield
691 
692             log = report_handler.stream.getvalue().strip()
693             item.add_report_section(when, "log", log)
694 
695     @pytest.hookimpl(hookwrapper=True)
696     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:
697         self.log_cli_handler.set_when("setup")
698 
699         empty = {}  # type: Dict[str, List[logging.LogRecord]]
700         item._store[caplog_records_key] = empty
701         yield from self._runtest_for(item, "setup")
702 
703     @pytest.hookimpl(hookwrapper=True)
704     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
705         self.log_cli_handler.set_when("call")
706 
707         yield from self._runtest_for(item, "call")
708 
709     @pytest.hookimpl(hookwrapper=True)
710     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
711         self.log_cli_handler.set_when("teardown")
712 
713         yield from self._runtest_for(item, "teardown")
714         del item._store[caplog_records_key]
715         del item._store[caplog_handler_key]
716 
717     @pytest.hookimpl
718     def pytest_runtest_logfinish(self) -> None:
719         self.log_cli_handler.set_when("finish")
720 
721     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
722     def pytest_sessionfinish(self) -> Generator[None, None, None]:
723         self.log_cli_handler.set_when("sessionfinish")
724 
725         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
726             with catching_logs(self.log_file_handler, level=self.log_file_level):
727                 yield
728 
729     @pytest.hookimpl
730     def pytest_unconfigure(self) -> None:
731         # Close the FileHandler explicitly.
732         # (logging.shutdown might have lost the weakref?!)
733         self.log_file_handler.close()
734 
735 
736 class _FileHandler(logging.FileHandler):
737     """A logging FileHandler with pytest tweaks."""
738 
739     def handleError(self, record: logging.LogRecord) -> None:
740         # Handled by LogCaptureHandler.
741         pass
742 
743 
744 class _LiveLoggingStreamHandler(logging.StreamHandler):
745     """A logging StreamHandler used by the live logging feature: it will
746     write a newline before the first log message in each test.
747 
748     During live logging we must also explicitly disable stdout/stderr
749     capturing otherwise it will get captured and won't appear in the
750     terminal.
751     """
752 
753     # Officially stream needs to be a IO[str], but TerminalReporter
754     # isn't. So force it.
755     stream = None  # type: TerminalReporter # type: ignore
756 
757     def __init__(
758         self,
759         terminal_reporter: TerminalReporter,
760         capture_manager: Optional[CaptureManager],
761     ) -> None:
762         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type]
763         self.capture_manager = capture_manager
764         self.reset()
765         self.set_when(None)
766         self._test_outcome_written = False
767 
768     def reset(self) -> None:
769         """Reset the handler; should be called before the start of each test."""
770         self._first_record_emitted = False
771 
772     def set_when(self, when: Optional[str]) -> None:
773         """Prepare for the given test phase (setup/call/teardown)."""
774         self._when = when
775         self._section_name_shown = False
776         if when == "start":
777             self._test_outcome_written = False
778 
779     def emit(self, record: logging.LogRecord) -> None:
780         ctx_manager = (
781             self.capture_manager.global_and_fixture_disabled()
782             if self.capture_manager
783             else nullcontext()
784         )
785         with ctx_manager:
786             if not self._first_record_emitted:
787                 self.stream.write("\n")
788                 self._first_record_emitted = True
789             elif self._when in ("teardown", "finish"):
790                 if not self._test_outcome_written:
791                     self._test_outcome_written = True
792                     self.stream.write("\n")
793             if not self._section_name_shown and self._when:
794                 self.stream.section("live log " + self._when, sep="-", bold=True)
795                 self._section_name_shown = True
796             super().emit(record)
797 
798     def handleError(self, record: logging.LogRecord) -> None:
799         # Handled by LogCaptureHandler.
800         pass
801 
802 
803 class _LiveLoggingNullHandler(logging.NullHandler):
804     """A logging handler used when live logging is disabled."""
805 
806     def reset(self) -> None:
807         pass
808 
809     def set_when(self, when: str) -> None:
810         pass
811 
812     def handleError(self, record: logging.LogRecord) -> None:
813         # Handled by LogCaptureHandler.
814         pass

</code><intended_behavior>Within the involved method(s) in src/_pytest/logging.py that manage logging levels via caplog.set_level, ensure that _initial_handler_level dictionary uses setdefault rather than set when updating handler levels for the first time. This change is crucial to ensure that the initial logging level of each handler is captured and preserved correctly before any test manipulates it. When restoring handler levels after a test, the restoration process should reference _initial_handler_level to set each handler's level back to its original state before the first set_level call in the test scope, ensuring true restoration to pre-test conditions. Ensure that if set_level is called multiple times within the same test, _initial_handler_level does not overwrite the initially stored level with subsequent calls. Only the first call's level should be stored as the initial state to be restored post-test. This restoration mechanism ensures that tests which modify logging levels do not interfere with each other by incorrectly setting up logging states based on the modifications made by previous tests within the same session.</intended_behavior>]
2025-10-15 10:04:31.641 | INFO     | Search completed. Bug locations: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Access and control log capturing."""
2 import logging
3 import os
4 import re
5 import sys
6 from contextlib import contextmanager
7 from io import StringIO
8 from typing import AbstractSet
9 from typing import Dict
10 from typing import Generator
11 from typing import List
12 from typing import Mapping
13 from typing import Optional
14 from typing import Tuple
15 from typing import TypeVar
16 from typing import Union
17 
18 import pytest
19 from _pytest import nodes
20 from _pytest._io import TerminalWriter
21 from _pytest.capture import CaptureManager
22 from _pytest.compat import nullcontext
23 from _pytest.config import _strtobool
24 from _pytest.config import Config
25 from _pytest.config import create_terminal_writer
26 from _pytest.config.argparsing import Parser
27 from _pytest.fixtures import FixtureRequest
28 from _pytest.main import Session
29 from _pytest.pathlib import Path
30 from _pytest.store import StoreKey
31 from _pytest.terminal import TerminalReporter
32 
33 
34 DEFAULT_LOG_FORMAT = "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s"
35 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
36 _ANSI_ESCAPE_SEQ = re.compile(r"\x1b\[[\d;]+m")
37 caplog_handler_key = StoreKey["LogCaptureHandler"]()
38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()
39 
40 
41 def _remove_ansi_escape_sequences(text: str) -> str:
42     return _ANSI_ESCAPE_SEQ.sub("", text)
43 
44 
45 class ColoredLevelFormatter(logging.Formatter):
46     """A logging formatter which colorizes the %(levelname)..s part of the
47     log format passed to __init__."""
48 
49     LOGLEVEL_COLOROPTS = {
50         logging.CRITICAL: {"red"},
51         logging.ERROR: {"red", "bold"},
52         logging.WARNING: {"yellow"},
53         logging.WARN: {"yellow"},
54         logging.INFO: {"green"},
55         logging.DEBUG: {"purple"},
56         logging.NOTSET: set(),
57     }  # type: Mapping[int, AbstractSet[str]]
58     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-.]?\d*s)")
59 
60     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:
61         super().__init__(*args, **kwargs)
62         self._original_fmt = self._style._fmt
63         self._level_to_fmt_mapping = {}  # type: Dict[int, str]
64 
65         assert self._fmt is not None
66         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
67         if not levelname_fmt_match:
68             return
69         levelname_fmt = levelname_fmt_match.group()
70 
71         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
72             formatted_levelname = levelname_fmt % {
73                 "levelname": logging.getLevelName(level)
74             }
75 
76             # add ANSI escape sequences around the formatted levelname
77             color_kwargs = {name: True for name in color_opts}
78             colorized_formatted_levelname = terminalwriter.markup(
79                 formatted_levelname, **color_kwargs
80             )
81             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
82                 colorized_formatted_levelname, self._fmt
83             )
84 
85     def format(self, record: logging.LogRecord) -> str:
86         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
87         self._style._fmt = fmt
88         return super().format(record)
89 
90 
91 class PercentStyleMultiline(logging.PercentStyle):
92     """A logging style with special support for multiline messages.
93 
94     If the message of a record consists of multiple lines, this style
95     formats the message as if each line were logged separately.
96     """
97 
98     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:
99         super().__init__(fmt)
100         self._auto_indent = self._get_auto_indent(auto_indent)
101 
102     @staticmethod
103     def _update_message(
104         record_dict: Dict[str, object], message: str
105     ) -> Dict[str, object]:
106         tmp = record_dict.copy()
107         tmp["message"] = message
108         return tmp
109 
110     @staticmethod
111     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:
112         """Determine the current auto indentation setting.
113 
114         Specify auto indent behavior (on/off/fixed) by passing in
115         extra={"auto_indent": [value]} to the call to logging.log() or
116         using a --log-auto-indent [value] command line or the
117         log_auto_indent [value] config option.
118 
119         Default behavior is auto-indent off.
120 
121         Using the string "True" or "on" or the boolean True as the value
122         turns auto indent on, using the string "False" or "off" or the
123         boolean False or the int 0 turns it off, and specifying a
124         positive integer fixes the indentation position to the value
125         specified.
126 
127         Any other values for the option are invalid, and will silently be
128         converted to the default.
129 
130         :param None|bool|int|str auto_indent_option:
131             User specified option for indentation from command line, config
132             or extra kwarg. Accepts int, bool or str. str option accepts the
133             same range of values as boolean config options, as well as
134             positive integers represented in str form.
135 
136         :returns:
137             Indentation value, which can be
138             -1 (automatically determine indentation) or
139             0 (auto-indent turned off) or
140             >0 (explicitly set indentation position).
141         """
142 
143         if auto_indent_option is None:
144             return 0
145         elif isinstance(auto_indent_option, bool):
146             if auto_indent_option:
147                 return -1
148             else:
149                 return 0
150         elif isinstance(auto_indent_option, int):
151             return int(auto_indent_option)
152         elif isinstance(auto_indent_option, str):
153             try:
154                 return int(auto_indent_option)
155             except ValueError:
156                 pass
157             try:
158                 if _strtobool(auto_indent_option):
159                     return -1
160             except ValueError:
161                 return 0
162 
163         return 0
164 
165     def format(self, record: logging.LogRecord) -> str:
166         if "\n" in record.message:
167             if hasattr(record, "auto_indent"):
168                 # Passed in from the "extra={}" kwarg on the call to logging.log().
169                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined]
170             else:
171                 auto_indent = self._auto_indent
172 
173             if auto_indent:
174                 lines = record.message.splitlines()
175                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])
176 
177                 if auto_indent < 0:
178                     indentation = _remove_ansi_escape_sequences(formatted).find(
179                         lines[0]
180                     )
181                 else:
182                     # Optimizes logging by allowing a fixed indentation.
183                     indentation = auto_indent
184                 lines[0] = formatted
185                 return ("\n" + " " * indentation).join(lines)
186         return self._fmt % record.__dict__
187 
188 
189 def get_option_ini(config: Config, *names: str):
190     for name in names:
191         ret = config.getoption(name)  # 'default' arg won't work as expected
192         if ret is None:
193             ret = config.getini(name)
194         if ret:
195             return ret
196 
197 
198 def pytest_addoption(parser: Parser) -> None:
199     """Add options to control log capturing."""
200     group = parser.getgroup("logging")
201 
202     def add_option_ini(option, dest, default=None, type=None, **kwargs):
203         parser.addini(
204             dest, default=default, type=type, help="default value for " + option
205         )
206         group.addoption(option, dest=dest, **kwargs)
207 
208     add_option_ini(
209         "--log-level",
210         dest="log_level",
211         default=None,
212         metavar="LEVEL",
213         help=(
214             "level of messages to catch/display.\n"
215             "Not set by default, so it depends on the root/parent log handler's"
216             ' effective level, where it is "WARNING" by default.'
217         ),
218     )
219     add_option_ini(
220         "--log-format",
221         dest="log_format",
222         default=DEFAULT_LOG_FORMAT,
223         help="log format as used by the logging module.",
224     )
225     add_option_ini(
226         "--log-date-format",
227         dest="log_date_format",
228         default=DEFAULT_LOG_DATE_FORMAT,
229         help="log date format as used by the logging module.",
230     )
231     parser.addini(
232         "log_cli",
233         default=False,
234         type="bool",
235         help='enable log display during test run (also known as "live logging").',
236     )
237     add_option_ini(
238         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
239     )
240     add_option_ini(
241         "--log-cli-format",
242         dest="log_cli_format",
243         default=None,
244         help="log format as used by the logging module.",
245     )
246     add_option_ini(
247         "--log-cli-date-format",
248         dest="log_cli_date_format",
249         default=None,
250         help="log date format as used by the logging module.",
251     )
252     add_option_ini(
253         "--log-file",
254         dest="log_file",
255         default=None,
256         help="path to a file when logging will be written to.",
257     )
258     add_option_ini(
259         "--log-file-level",
260         dest="log_file_level",
261         default=None,
262         help="log file logging level.",
263     )
264     add_option_ini(
265         "--log-file-format",
266         dest="log_file_format",
267         default=DEFAULT_LOG_FORMAT,
268         help="log format as used by the logging module.",
269     )
270     add_option_ini(
271         "--log-file-date-format",
272         dest="log_file_date_format",
273         default=DEFAULT_LOG_DATE_FORMAT,
274         help="log date format as used by the logging module.",
275     )
276     add_option_ini(
277         "--log-auto-indent",
278         dest="log_auto_indent",
279         default=None,
280         help="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
281     )
282 
283 
284 _HandlerType = TypeVar("_HandlerType", bound=logging.Handler)
285 
286 
287 # Not using @contextmanager for performance reasons.
288 class catching_logs:
289     """Context manager that prepares the whole logging machinery properly."""
290 
291     __slots__ = ("handler", "level", "orig_level")
292 
293     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:
294         self.handler = handler
295         self.level = level
296 
297     def __enter__(self):
298         root_logger = logging.getLogger()
299         if self.level is not None:
300             self.handler.setLevel(self.level)
301         root_logger.addHandler(self.handler)
302         if self.level is not None:
303             self.orig_level = root_logger.level
304             root_logger.setLevel(min(self.orig_level, self.level))
305         return self.handler
306 
307     def __exit__(self, type, value, traceback):
308         root_logger = logging.getLogger()
309         if self.level is not None:
310             root_logger.setLevel(self.orig_level)
311         root_logger.removeHandler(self.handler)
312 
313 
314 class LogCaptureHandler(logging.StreamHandler):
315     """A logging handler that stores log records and the log text."""
316 
317     stream = None  # type: StringIO
318 
319     def __init__(self) -> None:
320         """Create a new log handler."""
321         super().__init__(StringIO())
322         self.records = []  # type: List[logging.LogRecord]
323 
324     def emit(self, record: logging.LogRecord) -> None:
325         """Keep the log records in a list in addition to the log text."""
326         self.records.append(record)
327         super().emit(record)
328 
329     def reset(self) -> None:
330         self.records = []
331         self.stream = StringIO()
332 
333     def handleError(self, record: logging.LogRecord) -> None:
334         if logging.raiseExceptions:
335             # Fail the test if the log message is bad (emit failed).
336             # The default behavior of logging is to print "Logging error"
337             # to stderr with the call stack and some extra details.
338             # pytest wants to make such mistakes visible during testing.
339             raise
340 
341 
342 class LogCaptureFixture:
343     """Provides access and control of log capturing."""
344 
345     def __init__(self, item: nodes.Node) -> None:
346         self._item = item
347         self._initial_handler_level = None  # type: Optional[int]
348         # Dict of log name -> log level.
349         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]
350 
351     def _finalize(self) -> None:
352         """Finalize the fixture.
353 
354         This restores the log levels changed by :meth:`set_level`.
355         """
356         # Restore log levels.
357         if self._initial_handler_level is not None:
358             self.handler.setLevel(self._initial_handler_level)
359         for logger_name, level in self._initial_logger_levels.items():
360             logger = logging.getLogger(logger_name)
361             logger.setLevel(level)
362 
363     @property
364     def handler(self) -> LogCaptureHandler:
365         """Get the logging handler used by the fixture.
366 
367         :rtype: LogCaptureHandler
368         """
369         return self._item._store[caplog_handler_key]
370 
371     def get_records(self, when: str) -> List[logging.LogRecord]:
372         """Get the logging records for one of the possible test phases.
373 
374         :param str when:
375             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
376 
377         :returns: The list of captured records at the given stage.
378         :rtype: List[logging.LogRecord]
379 
380         .. versionadded:: 3.4
381         """
382         return self._item._store[caplog_records_key].get(when, [])
383 
384     @property
385     def text(self) -> str:
386         """The formatted log text."""
387         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())
388 
389     @property
390     def records(self) -> List[logging.LogRecord]:
391         """The list of log records."""
392         return self.handler.records
393 
394     @property
395     def record_tuples(self) -> List[Tuple[str, int, str]]:
396         """A list of a stripped down version of log records intended
397         for use in assertion comparison.
398 
399         The format of the tuple is:
400 
401             (logger_name, log_level, message)
402         """
403         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
404 
405     @property
406     def messages(self) -> List[str]:
407         """A list of format-interpolated log messages.
408 
409         Unlike 'records', which contains the format string and parameters for
410         interpolation, log messages in this list are all interpolated.
411 
412         Unlike 'text', which contains the output from the handler, log
413         messages in this list are unadorned with levels, timestamps, etc,
414         making exact comparisons more reliable.
415 
416         Note that traceback or stack info (from :func:`logging.exception` or
417         the `exc_info` or `stack_info` arguments to the logging functions) is
418         not included, as this is added by the formatter in the handler.
419 
420         .. versionadded:: 3.7
421         """
422         return [r.getMessage() for r in self.records]
423 
424     def clear(self) -> None:
425         """Reset the list of log records and the captured log text."""
426         self.handler.reset()
427 
428     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:
429         """Set the level of a logger for the duration of a test.
430 
431         .. versionchanged:: 3.4
432             The levels of the loggers changed by this function will be
433             restored to their initial values at the end of the test.
434 
435         :param int level: The level.
436         :param str logger: The logger to update. If not given, the root logger.
437         """
438         logger_obj = logging.getLogger(logger)
439         # Save the original log-level to restore it during teardown.
440         self._initial_logger_levels.setdefault(logger, logger_obj.level)
441         logger_obj.setLevel(level)
442         self._initial_handler_level = self.handler.level
443         self.handler.setLevel(level)
444 
445     @contextmanager
446     def at_level(
447         self, level: int, logger: Optional[str] = None
448     ) -> Generator[None, None, None]:
449         """Context manager that sets the level for capturing of logs. After
450         the end of the 'with' statement the level is restored to its original
451         value.
452 
453         :param int level: The level.
454         :param str logger: The logger to update. If not given, the root logger.
455         """
456         logger_obj = logging.getLogger(logger)
457         orig_level = logger_obj.level
458         logger_obj.setLevel(level)
459         handler_orig_level = self.handler.level
460         self.handler.setLevel(level)
461         try:
462             yield
463         finally:
464             logger_obj.setLevel(orig_level)
465             self.handler.setLevel(handler_orig_level)
466 
467 
468 @pytest.fixture
469 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:
470     """Access and control log capturing.
471 
472     Captured logs are available through the following properties/methods::
473 
474     * caplog.messages        -> list of format-interpolated log messages
475     * caplog.text            -> string containing formatted log output
476     * caplog.records         -> list of logging.LogRecord instances
477     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
478     * caplog.clear()         -> clear captured records and formatted log output string
479     """
480     result = LogCaptureFixture(request.node)
481     yield result
482     result._finalize()
483 
484 
485 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:
486     for setting_name in setting_names:
487         log_level = config.getoption(setting_name)
488         if log_level is None:
489             log_level = config.getini(setting_name)
490         if log_level:
491             break
492     else:
493         return None
494 
495     if isinstance(log_level, str):
496         log_level = log_level.upper()
497     try:
498         return int(getattr(logging, log_level, log_level))
499     except ValueError as e:
500         # Python logging does not recognise this as a logging level
501         raise pytest.UsageError(
502             "'{}' is not recognized as a logging level name for "
503             "'{}'. Please consider passing the "
504             "logging level num instead.".format(log_level, setting_name)
505         ) from e
506 
507 
508 # run after terminalreporter/capturemanager are configured
509 @pytest.hookimpl(trylast=True)
510 def pytest_configure(config: Config) -> None:
511     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
512 
513 
514 class LoggingPlugin:
515     """Attaches to the logging module and captures log messages for each test."""
516 
517     def __init__(self, config: Config) -> None:
518         """Create a new plugin to capture log messages.
519 
520         The formatter can be safely shared across all handlers so
521         create a single one for the entire test session here.
522         """
523         self._config = config
524 
525         # Report logging.
526         self.formatter = self._create_formatter(
527             get_option_ini(config, "log_format"),
528             get_option_ini(config, "log_date_format"),
529             get_option_ini(config, "log_auto_indent"),
530         )
531         self.log_level = get_log_level_for_setting(config, "log_level")
532         self.caplog_handler = LogCaptureHandler()
533         self.caplog_handler.setFormatter(self.formatter)
534         self.report_handler = LogCaptureHandler()
535         self.report_handler.setFormatter(self.formatter)
536 
537         # File logging.
538         self.log_file_level = get_log_level_for_setting(config, "log_file_level")
539         log_file = get_option_ini(config, "log_file") or os.devnull
540         if log_file != os.devnull:
541             directory = os.path.dirname(os.path.abspath(log_file))
542             if not os.path.isdir(directory):
543                 os.makedirs(directory)
544 
545         self.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
546         log_file_format = get_option_ini(config, "log_file_format", "log_format")
547         log_file_date_format = get_option_ini(
548             config, "log_file_date_format", "log_date_format"
549         )
550 
551         log_file_formatter = logging.Formatter(
552             log_file_format, datefmt=log_file_date_format
553         )
554         self.log_file_handler.setFormatter(log_file_formatter)
555 
556         # CLI/live logging.
557         self.log_cli_level = get_log_level_for_setting(
558             config, "log_cli_level", "log_level"
559         )
560         if self._log_cli_enabled():
561             terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
562             capture_manager = config.pluginmanager.get_plugin("capturemanager")
563             # if capturemanager plugin is disabled, live logging still works.
564             self.log_cli_handler = _LiveLoggingStreamHandler(
565                 terminal_reporter, capture_manager
566             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]
567         else:
568             self.log_cli_handler = _LiveLoggingNullHandler()
569         log_cli_formatter = self._create_formatter(
570             get_option_ini(config, "log_cli_format", "log_format"),
571             get_option_ini(config, "log_cli_date_format", "log_date_format"),
572             get_option_ini(config, "log_auto_indent"),
573         )
574         self.log_cli_handler.setFormatter(log_cli_formatter)
575 
576     def _create_formatter(self, log_format, log_date_format, auto_indent):
577         # Color option doesn't exist if terminal plugin is disabled.
578         color = getattr(self._config.option, "color", "no")
579         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
580             log_format
581         ):
582             formatter = ColoredLevelFormatter(
583                 create_terminal_writer(self._config), log_format, log_date_format
584             )  # type: logging.Formatter
585         else:
586             formatter = logging.Formatter(log_format, log_date_format)
587 
588         formatter._style = PercentStyleMultiline(
589             formatter._style._fmt, auto_indent=auto_indent
590         )
591 
592         return formatter
593 
594     def set_log_path(self, fname: str) -> None:
595         """Set the filename parameter for Logging.FileHandler().
596 
597         Creates parent directory if it does not exist.
598 
599         .. warning::
600             This is an experimental API.
601         """
602         fpath = Path(fname)
603 
604         if not fpath.is_absolute():
605             fpath = Path(str(self._config.rootdir), fpath)
606 
607         if not fpath.parent.exists():
608             fpath.parent.mkdir(exist_ok=True, parents=True)
609 
610         stream = fpath.open(mode="w", encoding="UTF-8")
611         if sys.version_info >= (3, 7):
612             old_stream = self.log_file_handler.setStream(stream)
613         else:
614             old_stream = self.log_file_handler.stream
615             self.log_file_handler.acquire()
616             try:
617                 self.log_file_handler.flush()
618                 self.log_file_handler.stream = stream
619             finally:
620                 self.log_file_handler.release()
621         if old_stream:
622             old_stream.close()
623 
624     def _log_cli_enabled(self):
625         """Return whether live logging is enabled."""
626         enabled = self._config.getoption(
627             "--log-cli-level"
628         ) is not None or self._config.getini("log_cli")
629         if not enabled:
630             return False
631 
632         terminal_reporter = self._config.pluginmanager.get_plugin("terminalreporter")
633         if terminal_reporter is None:
634             # terminal reporter is disabled e.g. by pytest-xdist.
635             return False
636 
637         return True
638 
639     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
640     def pytest_sessionstart(self) -> Generator[None, None, None]:
641         self.log_cli_handler.set_when("sessionstart")
642 
643         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
644             with catching_logs(self.log_file_handler, level=self.log_file_level):
645                 yield
646 
647     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
648     def pytest_collection(self) -> Generator[None, None, None]:
649         self.log_cli_handler.set_when("collection")
650 
651         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
652             with catching_logs(self.log_file_handler, level=self.log_file_level):
653                 yield
654 
655     @pytest.hookimpl(hookwrapper=True)
656     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:
657         if session.config.option.collectonly:
658             yield
659             return
660 
661         if self._log_cli_enabled() and self._config.getoption("verbose") < 1:
662             # The verbose flag is needed to avoid messy test progress output.
663             self._config.option.verbose = 1
664 
665         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
666             with catching_logs(self.log_file_handler, level=self.log_file_level):
667                 yield  # Run all the tests.
668 
669     @pytest.hookimpl
670     def pytest_runtest_logstart(self) -> None:
671         self.log_cli_handler.reset()
672         self.log_cli_handler.set_when("start")
673 
674     @pytest.hookimpl
675     def pytest_runtest_logreport(self) -> None:
676         self.log_cli_handler.set_when("logreport")
677 
678     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
679         """Implement the internals of the pytest_runtest_xxx() hooks."""
680         with catching_logs(
681             self.caplog_handler, level=self.log_level,
682         ) as caplog_handler, catching_logs(
683             self.report_handler, level=self.log_level,
684         ) as report_handler:
685             caplog_handler.reset()
686             report_handler.reset()
687             item._store[caplog_records_key][when] = caplog_handler.records
688             item._store[caplog_handler_key] = caplog_handler
689 
690             yield
691 
692             log = report_handler.stream.getvalue().strip()
693             item.add_report_section(when, "log", log)
694 
695     @pytest.hookimpl(hookwrapper=True)
696     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:
697         self.log_cli_handler.set_when("setup")
698 
699         empty = {}  # type: Dict[str, List[logging.LogRecord]]
700         item._store[caplog_records_key] = empty
701         yield from self._runtest_for(item, "setup")
702 
703     @pytest.hookimpl(hookwrapper=True)
704     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
705         self.log_cli_handler.set_when("call")
706 
707         yield from self._runtest_for(item, "call")
708 
709     @pytest.hookimpl(hookwrapper=True)
710     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
711         self.log_cli_handler.set_when("teardown")
712 
713         yield from self._runtest_for(item, "teardown")
714         del item._store[caplog_records_key]
715         del item._store[caplog_handler_key]
716 
717     @pytest.hookimpl
718     def pytest_runtest_logfinish(self) -> None:
719         self.log_cli_handler.set_when("finish")
720 
721     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
722     def pytest_sessionfinish(self) -> Generator[None, None, None]:
723         self.log_cli_handler.set_when("sessionfinish")
724 
725         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
726             with catching_logs(self.log_file_handler, level=self.log_file_level):
727                 yield
728 
729     @pytest.hookimpl
730     def pytest_unconfigure(self) -> None:
731         # Close the FileHandler explicitly.
732         # (logging.shutdown might have lost the weakref?!)
733         self.log_file_handler.close()
734 
735 
736 class _FileHandler(logging.FileHandler):
737     """A logging FileHandler with pytest tweaks."""
738 
739     def handleError(self, record: logging.LogRecord) -> None:
740         # Handled by LogCaptureHandler.
741         pass
742 
743 
744 class _LiveLoggingStreamHandler(logging.StreamHandler):
745     """A logging StreamHandler used by the live logging feature: it will
746     write a newline before the first log message in each test.
747 
748     During live logging we must also explicitly disable stdout/stderr
749     capturing otherwise it will get captured and won't appear in the
750     terminal.
751     """
752 
753     # Officially stream needs to be a IO[str], but TerminalReporter
754     # isn't. So force it.
755     stream = None  # type: TerminalReporter # type: ignore
756 
757     def __init__(
758         self,
759         terminal_reporter: TerminalReporter,
760         capture_manager: Optional[CaptureManager],
761     ) -> None:
762         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type]
763         self.capture_manager = capture_manager
764         self.reset()
765         self.set_when(None)
766         self._test_outcome_written = False
767 
768     def reset(self) -> None:
769         """Reset the handler; should be called before the start of each test."""
770         self._first_record_emitted = False
771 
772     def set_when(self, when: Optional[str]) -> None:
773         """Prepare for the given test phase (setup/call/teardown)."""
774         self._when = when
775         self._section_name_shown = False
776         if when == "start":
777             self._test_outcome_written = False
778 
779     def emit(self, record: logging.LogRecord) -> None:
780         ctx_manager = (
781             self.capture_manager.global_and_fixture_disabled()
782             if self.capture_manager
783             else nullcontext()
784         )
785         with ctx_manager:
786             if not self._first_record_emitted:
787                 self.stream.write("\n")
788                 self._first_record_emitted = True
789             elif self._when in ("teardown", "finish"):
790                 if not self._test_outcome_written:
791                     self._test_outcome_written = True
792                     self.stream.write("\n")
793             if not self._section_name_shown and self._when:
794                 self.stream.section("live log " + self._when, sep="-", bold=True)
795                 self._section_name_shown = True
796             super().emit(record)
797 
798     def handleError(self, record: logging.LogRecord) -> None:
799         # Handled by LogCaptureHandler.
800         pass
801 
802 
803 class _LiveLoggingNullHandler(logging.NullHandler):
804     """A logging handler used when live logging is disabled."""
805 
806     def reset(self) -> None:
807         pass
808 
809     def set_when(self, when: str) -> None:
810         pass
811 
812     def handleError(self, record: logging.LogRecord) -> None:
813         # Handled by LogCaptureHandler.
814         pass

</code><intended_behavior>Within the involved method(s) in src/_pytest/logging.py that manage logging levels via caplog.set_level, ensure that _initial_handler_level dictionary uses setdefault rather than set when updating handler levels for the first time. This change is crucial to ensure that the initial logging level of each handler is captured and preserved correctly before any test manipulates it. When restoring handler levels after a test, the restoration process should reference _initial_handler_level to set each handler's level back to its original state before the first set_level call in the test scope, ensuring true restoration to pre-test conditions. Ensure that if set_level is called multiple times within the same test, _initial_handler_level does not overwrite the initially stored level with subsequent calls. Only the first call's level should be stored as the initial state to be restored post-test. This restoration mechanism ensures that tests which modify logging levels do not interfere with each other by incorrectly setting up logging states based on the modifications made by previous tests within the same session.</intended_behavior>]
2025-10-15 10:04:31.641 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 10:04:31.641 | INFO     | Search-only: skipping patch selection
2025-10-15 10:04:31.722 | INFO     | Task pytest-dev__pytest-7673 completed successfully.
2025-10-15 10:04:31.722 | INFO     | No patch generated. You can try running ACR again.
