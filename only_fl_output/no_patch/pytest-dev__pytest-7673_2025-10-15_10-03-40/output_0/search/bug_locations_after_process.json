[
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.0/src/_pytest/logging.py",
        "start": 1,
        "end": 814,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Access and control log capturing.\"\"\"\n2 import logging\n3 import os\n4 import re\n5 import sys\n6 from contextlib import contextmanager\n7 from io import StringIO\n8 from typing import AbstractSet\n9 from typing import Dict\n10 from typing import Generator\n11 from typing import List\n12 from typing import Mapping\n13 from typing import Optional\n14 from typing import Tuple\n15 from typing import TypeVar\n16 from typing import Union\n17 \n18 import pytest\n19 from _pytest import nodes\n20 from _pytest._io import TerminalWriter\n21 from _pytest.capture import CaptureManager\n22 from _pytest.compat import nullcontext\n23 from _pytest.config import _strtobool\n24 from _pytest.config import Config\n25 from _pytest.config import create_terminal_writer\n26 from _pytest.config.argparsing import Parser\n27 from _pytest.fixtures import FixtureRequest\n28 from _pytest.main import Session\n29 from _pytest.pathlib import Path\n30 from _pytest.store import StoreKey\n31 from _pytest.terminal import TerminalReporter\n32 \n33 \n34 DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n35 DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n36 _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n37 caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()\n38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()\n39 \n40 \n41 def _remove_ansi_escape_sequences(text: str) -> str:\n42     return _ANSI_ESCAPE_SEQ.sub(\"\", text)\n43 \n44 \n45 class ColoredLevelFormatter(logging.Formatter):\n46     \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n47     log format passed to __init__.\"\"\"\n48 \n49     LOGLEVEL_COLOROPTS = {\n50         logging.CRITICAL: {\"red\"},\n51         logging.ERROR: {\"red\", \"bold\"},\n52         logging.WARNING: {\"yellow\"},\n53         logging.WARN: {\"yellow\"},\n54         logging.INFO: {\"green\"},\n55         logging.DEBUG: {\"purple\"},\n56         logging.NOTSET: set(),\n57     }  # type: Mapping[int, AbstractSet[str]]\n58     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n59 \n60     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n61         super().__init__(*args, **kwargs)\n62         self._original_fmt = self._style._fmt\n63         self._level_to_fmt_mapping = {}  # type: Dict[int, str]\n64 \n65         assert self._fmt is not None\n66         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n67         if not levelname_fmt_match:\n68             return\n69         levelname_fmt = levelname_fmt_match.group()\n70 \n71         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n72             formatted_levelname = levelname_fmt % {\n73                 \"levelname\": logging.getLevelName(level)\n74             }\n75 \n76             # add ANSI escape sequences around the formatted levelname\n77             color_kwargs = {name: True for name in color_opts}\n78             colorized_formatted_levelname = terminalwriter.markup(\n79                 formatted_levelname, **color_kwargs\n80             )\n81             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n82                 colorized_formatted_levelname, self._fmt\n83             )\n84 \n85     def format(self, record: logging.LogRecord) -> str:\n86         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n87         self._style._fmt = fmt\n88         return super().format(record)\n89 \n90 \n91 class PercentStyleMultiline(logging.PercentStyle):\n92     \"\"\"A logging style with special support for multiline messages.\n93 \n94     If the message of a record consists of multiple lines, this style\n95     formats the message as if each line were logged separately.\n96     \"\"\"\n97 \n98     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:\n99         super().__init__(fmt)\n100         self._auto_indent = self._get_auto_indent(auto_indent)\n101 \n102     @staticmethod\n103     def _update_message(\n104         record_dict: Dict[str, object], message: str\n105     ) -> Dict[str, object]:\n106         tmp = record_dict.copy()\n107         tmp[\"message\"] = message\n108         return tmp\n109 \n110     @staticmethod\n111     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:\n112         \"\"\"Determine the current auto indentation setting.\n113 \n114         Specify auto indent behavior (on/off/fixed) by passing in\n115         extra={\"auto_indent\": [value]} to the call to logging.log() or\n116         using a --log-auto-indent [value] command line or the\n117         log_auto_indent [value] config option.\n118 \n119         Default behavior is auto-indent off.\n120 \n121         Using the string \"True\" or \"on\" or the boolean True as the value\n122         turns auto indent on, using the string \"False\" or \"off\" or the\n123         boolean False or the int 0 turns it off, and specifying a\n124         positive integer fixes the indentation position to the value\n125         specified.\n126 \n127         Any other values for the option are invalid, and will silently be\n128         converted to the default.\n129 \n130         :param None|bool|int|str auto_indent_option:\n131             User specified option for indentation from command line, config\n132             or extra kwarg. Accepts int, bool or str. str option accepts the\n133             same range of values as boolean config options, as well as\n134             positive integers represented in str form.\n135 \n136         :returns:\n137             Indentation value, which can be\n138             -1 (automatically determine indentation) or\n139             0 (auto-indent turned off) or\n140             >0 (explicitly set indentation position).\n141         \"\"\"\n142 \n143         if auto_indent_option is None:\n144             return 0\n145         elif isinstance(auto_indent_option, bool):\n146             if auto_indent_option:\n147                 return -1\n148             else:\n149                 return 0\n150         elif isinstance(auto_indent_option, int):\n151             return int(auto_indent_option)\n152         elif isinstance(auto_indent_option, str):\n153             try:\n154                 return int(auto_indent_option)\n155             except ValueError:\n156                 pass\n157             try:\n158                 if _strtobool(auto_indent_option):\n159                     return -1\n160             except ValueError:\n161                 return 0\n162 \n163         return 0\n164 \n165     def format(self, record: logging.LogRecord) -> str:\n166         if \"\\n\" in record.message:\n167             if hasattr(record, \"auto_indent\"):\n168                 # Passed in from the \"extra={}\" kwarg on the call to logging.log().\n169                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined]\n170             else:\n171                 auto_indent = self._auto_indent\n172 \n173             if auto_indent:\n174                 lines = record.message.splitlines()\n175                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])\n176 \n177                 if auto_indent < 0:\n178                     indentation = _remove_ansi_escape_sequences(formatted).find(\n179                         lines[0]\n180                     )\n181                 else:\n182                     # Optimizes logging by allowing a fixed indentation.\n183                     indentation = auto_indent\n184                 lines[0] = formatted\n185                 return (\"\\n\" + \" \" * indentation).join(lines)\n186         return self._fmt % record.__dict__\n187 \n188 \n189 def get_option_ini(config: Config, *names: str):\n190     for name in names:\n191         ret = config.getoption(name)  # 'default' arg won't work as expected\n192         if ret is None:\n193             ret = config.getini(name)\n194         if ret:\n195             return ret\n196 \n197 \n198 def pytest_addoption(parser: Parser) -> None:\n199     \"\"\"Add options to control log capturing.\"\"\"\n200     group = parser.getgroup(\"logging\")\n201 \n202     def add_option_ini(option, dest, default=None, type=None, **kwargs):\n203         parser.addini(\n204             dest, default=default, type=type, help=\"default value for \" + option\n205         )\n206         group.addoption(option, dest=dest, **kwargs)\n207 \n208     add_option_ini(\n209         \"--log-level\",\n210         dest=\"log_level\",\n211         default=None,\n212         metavar=\"LEVEL\",\n213         help=(\n214             \"level of messages to catch/display.\\n\"\n215             \"Not set by default, so it depends on the root/parent log handler's\"\n216             ' effective level, where it is \"WARNING\" by default.'\n217         ),\n218     )\n219     add_option_ini(\n220         \"--log-format\",\n221         dest=\"log_format\",\n222         default=DEFAULT_LOG_FORMAT,\n223         help=\"log format as used by the logging module.\",\n224     )\n225     add_option_ini(\n226         \"--log-date-format\",\n227         dest=\"log_date_format\",\n228         default=DEFAULT_LOG_DATE_FORMAT,\n229         help=\"log date format as used by the logging module.\",\n230     )\n231     parser.addini(\n232         \"log_cli\",\n233         default=False,\n234         type=\"bool\",\n235         help='enable log display during test run (also known as \"live logging\").',\n236     )\n237     add_option_ini(\n238         \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n239     )\n240     add_option_ini(\n241         \"--log-cli-format\",\n242         dest=\"log_cli_format\",\n243         default=None,\n244         help=\"log format as used by the logging module.\",\n245     )\n246     add_option_ini(\n247         \"--log-cli-date-format\",\n248         dest=\"log_cli_date_format\",\n249         default=None,\n250         help=\"log date format as used by the logging module.\",\n251     )\n252     add_option_ini(\n253         \"--log-file\",\n254         dest=\"log_file\",\n255         default=None,\n256         help=\"path to a file when logging will be written to.\",\n257     )\n258     add_option_ini(\n259         \"--log-file-level\",\n260         dest=\"log_file_level\",\n261         default=None,\n262         help=\"log file logging level.\",\n263     )\n264     add_option_ini(\n265         \"--log-file-format\",\n266         dest=\"log_file_format\",\n267         default=DEFAULT_LOG_FORMAT,\n268         help=\"log format as used by the logging module.\",\n269     )\n270     add_option_ini(\n271         \"--log-file-date-format\",\n272         dest=\"log_file_date_format\",\n273         default=DEFAULT_LOG_DATE_FORMAT,\n274         help=\"log date format as used by the logging module.\",\n275     )\n276     add_option_ini(\n277         \"--log-auto-indent\",\n278         dest=\"log_auto_indent\",\n279         default=None,\n280         help=\"Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.\",\n281     )\n282 \n283 \n284 _HandlerType = TypeVar(\"_HandlerType\", bound=logging.Handler)\n285 \n286 \n287 # Not using @contextmanager for performance reasons.\n288 class catching_logs:\n289     \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n290 \n291     __slots__ = (\"handler\", \"level\", \"orig_level\")\n292 \n293     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:\n294         self.handler = handler\n295         self.level = level\n296 \n297     def __enter__(self):\n298         root_logger = logging.getLogger()\n299         if self.level is not None:\n300             self.handler.setLevel(self.level)\n301         root_logger.addHandler(self.handler)\n302         if self.level is not None:\n303             self.orig_level = root_logger.level\n304             root_logger.setLevel(min(self.orig_level, self.level))\n305         return self.handler\n306 \n307     def __exit__(self, type, value, traceback):\n308         root_logger = logging.getLogger()\n309         if self.level is not None:\n310             root_logger.setLevel(self.orig_level)\n311         root_logger.removeHandler(self.handler)\n312 \n313 \n314 class LogCaptureHandler(logging.StreamHandler):\n315     \"\"\"A logging handler that stores log records and the log text.\"\"\"\n316 \n317     stream = None  # type: StringIO\n318 \n319     def __init__(self) -> None:\n320         \"\"\"Create a new log handler.\"\"\"\n321         super().__init__(StringIO())\n322         self.records = []  # type: List[logging.LogRecord]\n323 \n324     def emit(self, record: logging.LogRecord) -> None:\n325         \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n326         self.records.append(record)\n327         super().emit(record)\n328 \n329     def reset(self) -> None:\n330         self.records = []\n331         self.stream = StringIO()\n332 \n333     def handleError(self, record: logging.LogRecord) -> None:\n334         if logging.raiseExceptions:\n335             # Fail the test if the log message is bad (emit failed).\n336             # The default behavior of logging is to print \"Logging error\"\n337             # to stderr with the call stack and some extra details.\n338             # pytest wants to make such mistakes visible during testing.\n339             raise\n340 \n341 \n342 class LogCaptureFixture:\n343     \"\"\"Provides access and control of log capturing.\"\"\"\n344 \n345     def __init__(self, item: nodes.Node) -> None:\n346         self._item = item\n347         self._initial_handler_level = None  # type: Optional[int]\n348         # Dict of log name -> log level.\n349         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n350 \n351     def _finalize(self) -> None:\n352         \"\"\"Finalize the fixture.\n353 \n354         This restores the log levels changed by :meth:`set_level`.\n355         \"\"\"\n356         # Restore log levels.\n357         if self._initial_handler_level is not None:\n358             self.handler.setLevel(self._initial_handler_level)\n359         for logger_name, level in self._initial_logger_levels.items():\n360             logger = logging.getLogger(logger_name)\n361             logger.setLevel(level)\n362 \n363     @property\n364     def handler(self) -> LogCaptureHandler:\n365         \"\"\"Get the logging handler used by the fixture.\n366 \n367         :rtype: LogCaptureHandler\n368         \"\"\"\n369         return self._item._store[caplog_handler_key]\n370 \n371     def get_records(self, when: str) -> List[logging.LogRecord]:\n372         \"\"\"Get the logging records for one of the possible test phases.\n373 \n374         :param str when:\n375             Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n376 \n377         :returns: The list of captured records at the given stage.\n378         :rtype: List[logging.LogRecord]\n379 \n380         .. versionadded:: 3.4\n381         \"\"\"\n382         return self._item._store[caplog_records_key].get(when, [])\n383 \n384     @property\n385     def text(self) -> str:\n386         \"\"\"The formatted log text.\"\"\"\n387         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n388 \n389     @property\n390     def records(self) -> List[logging.LogRecord]:\n391         \"\"\"The list of log records.\"\"\"\n392         return self.handler.records\n393 \n394     @property\n395     def record_tuples(self) -> List[Tuple[str, int, str]]:\n396         \"\"\"A list of a stripped down version of log records intended\n397         for use in assertion comparison.\n398 \n399         The format of the tuple is:\n400 \n401             (logger_name, log_level, message)\n402         \"\"\"\n403         return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n404 \n405     @property\n406     def messages(self) -> List[str]:\n407         \"\"\"A list of format-interpolated log messages.\n408 \n409         Unlike 'records', which contains the format string and parameters for\n410         interpolation, log messages in this list are all interpolated.\n411 \n412         Unlike 'text', which contains the output from the handler, log\n413         messages in this list are unadorned with levels, timestamps, etc,\n414         making exact comparisons more reliable.\n415 \n416         Note that traceback or stack info (from :func:`logging.exception` or\n417         the `exc_info` or `stack_info` arguments to the logging functions) is\n418         not included, as this is added by the formatter in the handler.\n419 \n420         .. versionadded:: 3.7\n421         \"\"\"\n422         return [r.getMessage() for r in self.records]\n423 \n424     def clear(self) -> None:\n425         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n426         self.handler.reset()\n427 \n428     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n429         \"\"\"Set the level of a logger for the duration of a test.\n430 \n431         .. versionchanged:: 3.4\n432             The levels of the loggers changed by this function will be\n433             restored to their initial values at the end of the test.\n434 \n435         :param int level: The level.\n436         :param str logger: The logger to update. If not given, the root logger.\n437         \"\"\"\n438         logger_obj = logging.getLogger(logger)\n439         # Save the original log-level to restore it during teardown.\n440         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n441         logger_obj.setLevel(level)\n442         self._initial_handler_level = self.handler.level\n443         self.handler.setLevel(level)\n444 \n445     @contextmanager\n446     def at_level(\n447         self, level: int, logger: Optional[str] = None\n448     ) -> Generator[None, None, None]:\n449         \"\"\"Context manager that sets the level for capturing of logs. After\n450         the end of the 'with' statement the level is restored to its original\n451         value.\n452 \n453         :param int level: The level.\n454         :param str logger: The logger to update. If not given, the root logger.\n455         \"\"\"\n456         logger_obj = logging.getLogger(logger)\n457         orig_level = logger_obj.level\n458         logger_obj.setLevel(level)\n459         handler_orig_level = self.handler.level\n460         self.handler.setLevel(level)\n461         try:\n462             yield\n463         finally:\n464             logger_obj.setLevel(orig_level)\n465             self.handler.setLevel(handler_orig_level)\n466 \n467 \n468 @pytest.fixture\n469 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n470     \"\"\"Access and control log capturing.\n471 \n472     Captured logs are available through the following properties/methods::\n473 \n474     * caplog.messages        -> list of format-interpolated log messages\n475     * caplog.text            -> string containing formatted log output\n476     * caplog.records         -> list of logging.LogRecord instances\n477     * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n478     * caplog.clear()         -> clear captured records and formatted log output string\n479     \"\"\"\n480     result = LogCaptureFixture(request.node)\n481     yield result\n482     result._finalize()\n483 \n484 \n485 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\n486     for setting_name in setting_names:\n487         log_level = config.getoption(setting_name)\n488         if log_level is None:\n489             log_level = config.getini(setting_name)\n490         if log_level:\n491             break\n492     else:\n493         return None\n494 \n495     if isinstance(log_level, str):\n496         log_level = log_level.upper()\n497     try:\n498         return int(getattr(logging, log_level, log_level))\n499     except ValueError as e:\n500         # Python logging does not recognise this as a logging level\n501         raise pytest.UsageError(\n502             \"'{}' is not recognized as a logging level name for \"\n503             \"'{}'. Please consider passing the \"\n504             \"logging level num instead.\".format(log_level, setting_name)\n505         ) from e\n506 \n507 \n508 # run after terminalreporter/capturemanager are configured\n509 @pytest.hookimpl(trylast=True)\n510 def pytest_configure(config: Config) -> None:\n511     config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n512 \n513 \n514 class LoggingPlugin:\n515     \"\"\"Attaches to the logging module and captures log messages for each test.\"\"\"\n516 \n517     def __init__(self, config: Config) -> None:\n518         \"\"\"Create a new plugin to capture log messages.\n519 \n520         The formatter can be safely shared across all handlers so\n521         create a single one for the entire test session here.\n522         \"\"\"\n523         self._config = config\n524 \n525         # Report logging.\n526         self.formatter = self._create_formatter(\n527             get_option_ini(config, \"log_format\"),\n528             get_option_ini(config, \"log_date_format\"),\n529             get_option_ini(config, \"log_auto_indent\"),\n530         )\n531         self.log_level = get_log_level_for_setting(config, \"log_level\")\n532         self.caplog_handler = LogCaptureHandler()\n533         self.caplog_handler.setFormatter(self.formatter)\n534         self.report_handler = LogCaptureHandler()\n535         self.report_handler.setFormatter(self.formatter)\n536 \n537         # File logging.\n538         self.log_file_level = get_log_level_for_setting(config, \"log_file_level\")\n539         log_file = get_option_ini(config, \"log_file\") or os.devnull\n540         if log_file != os.devnull:\n541             directory = os.path.dirname(os.path.abspath(log_file))\n542             if not os.path.isdir(directory):\n543                 os.makedirs(directory)\n544 \n545         self.log_file_handler = _FileHandler(log_file, mode=\"w\", encoding=\"UTF-8\")\n546         log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n547         log_file_date_format = get_option_ini(\n548             config, \"log_file_date_format\", \"log_date_format\"\n549         )\n550 \n551         log_file_formatter = logging.Formatter(\n552             log_file_format, datefmt=log_file_date_format\n553         )\n554         self.log_file_handler.setFormatter(log_file_formatter)\n555 \n556         # CLI/live logging.\n557         self.log_cli_level = get_log_level_for_setting(\n558             config, \"log_cli_level\", \"log_level\"\n559         )\n560         if self._log_cli_enabled():\n561             terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n562             capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n563             # if capturemanager plugin is disabled, live logging still works.\n564             self.log_cli_handler = _LiveLoggingStreamHandler(\n565                 terminal_reporter, capture_manager\n566             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]\n567         else:\n568             self.log_cli_handler = _LiveLoggingNullHandler()\n569         log_cli_formatter = self._create_formatter(\n570             get_option_ini(config, \"log_cli_format\", \"log_format\"),\n571             get_option_ini(config, \"log_cli_date_format\", \"log_date_format\"),\n572             get_option_ini(config, \"log_auto_indent\"),\n573         )\n574         self.log_cli_handler.setFormatter(log_cli_formatter)\n575 \n576     def _create_formatter(self, log_format, log_date_format, auto_indent):\n577         # Color option doesn't exist if terminal plugin is disabled.\n578         color = getattr(self._config.option, \"color\", \"no\")\n579         if color != \"no\" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(\n580             log_format\n581         ):\n582             formatter = ColoredLevelFormatter(\n583                 create_terminal_writer(self._config), log_format, log_date_format\n584             )  # type: logging.Formatter\n585         else:\n586             formatter = logging.Formatter(log_format, log_date_format)\n587 \n588         formatter._style = PercentStyleMultiline(\n589             formatter._style._fmt, auto_indent=auto_indent\n590         )\n591 \n592         return formatter\n593 \n594     def set_log_path(self, fname: str) -> None:\n595         \"\"\"Set the filename parameter for Logging.FileHandler().\n596 \n597         Creates parent directory if it does not exist.\n598 \n599         .. warning::\n600             This is an experimental API.\n601         \"\"\"\n602         fpath = Path(fname)\n603 \n604         if not fpath.is_absolute():\n605             fpath = Path(str(self._config.rootdir), fpath)\n606 \n607         if not fpath.parent.exists():\n608             fpath.parent.mkdir(exist_ok=True, parents=True)\n609 \n610         stream = fpath.open(mode=\"w\", encoding=\"UTF-8\")\n611         if sys.version_info >= (3, 7):\n612             old_stream = self.log_file_handler.setStream(stream)\n613         else:\n614             old_stream = self.log_file_handler.stream\n615             self.log_file_handler.acquire()\n616             try:\n617                 self.log_file_handler.flush()\n618                 self.log_file_handler.stream = stream\n619             finally:\n620                 self.log_file_handler.release()\n621         if old_stream:\n622             old_stream.close()\n623 \n624     def _log_cli_enabled(self):\n625         \"\"\"Return whether live logging is enabled.\"\"\"\n626         enabled = self._config.getoption(\n627             \"--log-cli-level\"\n628         ) is not None or self._config.getini(\"log_cli\")\n629         if not enabled:\n630             return False\n631 \n632         terminal_reporter = self._config.pluginmanager.get_plugin(\"terminalreporter\")\n633         if terminal_reporter is None:\n634             # terminal reporter is disabled e.g. by pytest-xdist.\n635             return False\n636 \n637         return True\n638 \n639     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n640     def pytest_sessionstart(self) -> Generator[None, None, None]:\n641         self.log_cli_handler.set_when(\"sessionstart\")\n642 \n643         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n644             with catching_logs(self.log_file_handler, level=self.log_file_level):\n645                 yield\n646 \n647     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n648     def pytest_collection(self) -> Generator[None, None, None]:\n649         self.log_cli_handler.set_when(\"collection\")\n650 \n651         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n652             with catching_logs(self.log_file_handler, level=self.log_file_level):\n653                 yield\n654 \n655     @pytest.hookimpl(hookwrapper=True)\n656     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:\n657         if session.config.option.collectonly:\n658             yield\n659             return\n660 \n661         if self._log_cli_enabled() and self._config.getoption(\"verbose\") < 1:\n662             # The verbose flag is needed to avoid messy test progress output.\n663             self._config.option.verbose = 1\n664 \n665         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n666             with catching_logs(self.log_file_handler, level=self.log_file_level):\n667                 yield  # Run all the tests.\n668 \n669     @pytest.hookimpl\n670     def pytest_runtest_logstart(self) -> None:\n671         self.log_cli_handler.reset()\n672         self.log_cli_handler.set_when(\"start\")\n673 \n674     @pytest.hookimpl\n675     def pytest_runtest_logreport(self) -> None:\n676         self.log_cli_handler.set_when(\"logreport\")\n677 \n678     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:\n679         \"\"\"Implement the internals of the pytest_runtest_xxx() hooks.\"\"\"\n680         with catching_logs(\n681             self.caplog_handler, level=self.log_level,\n682         ) as caplog_handler, catching_logs(\n683             self.report_handler, level=self.log_level,\n684         ) as report_handler:\n685             caplog_handler.reset()\n686             report_handler.reset()\n687             item._store[caplog_records_key][when] = caplog_handler.records\n688             item._store[caplog_handler_key] = caplog_handler\n689 \n690             yield\n691 \n692             log = report_handler.stream.getvalue().strip()\n693             item.add_report_section(when, \"log\", log)\n694 \n695     @pytest.hookimpl(hookwrapper=True)\n696     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:\n697         self.log_cli_handler.set_when(\"setup\")\n698 \n699         empty = {}  # type: Dict[str, List[logging.LogRecord]]\n700         item._store[caplog_records_key] = empty\n701         yield from self._runtest_for(item, \"setup\")\n702 \n703     @pytest.hookimpl(hookwrapper=True)\n704     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:\n705         self.log_cli_handler.set_when(\"call\")\n706 \n707         yield from self._runtest_for(item, \"call\")\n708 \n709     @pytest.hookimpl(hookwrapper=True)\n710     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:\n711         self.log_cli_handler.set_when(\"teardown\")\n712 \n713         yield from self._runtest_for(item, \"teardown\")\n714         del item._store[caplog_records_key]\n715         del item._store[caplog_handler_key]\n716 \n717     @pytest.hookimpl\n718     def pytest_runtest_logfinish(self) -> None:\n719         self.log_cli_handler.set_when(\"finish\")\n720 \n721     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n722     def pytest_sessionfinish(self) -> Generator[None, None, None]:\n723         self.log_cli_handler.set_when(\"sessionfinish\")\n724 \n725         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n726             with catching_logs(self.log_file_handler, level=self.log_file_level):\n727                 yield\n728 \n729     @pytest.hookimpl\n730     def pytest_unconfigure(self) -> None:\n731         # Close the FileHandler explicitly.\n732         # (logging.shutdown might have lost the weakref?!)\n733         self.log_file_handler.close()\n734 \n735 \n736 class _FileHandler(logging.FileHandler):\n737     \"\"\"A logging FileHandler with pytest tweaks.\"\"\"\n738 \n739     def handleError(self, record: logging.LogRecord) -> None:\n740         # Handled by LogCaptureHandler.\n741         pass\n742 \n743 \n744 class _LiveLoggingStreamHandler(logging.StreamHandler):\n745     \"\"\"A logging StreamHandler used by the live logging feature: it will\n746     write a newline before the first log message in each test.\n747 \n748     During live logging we must also explicitly disable stdout/stderr\n749     capturing otherwise it will get captured and won't appear in the\n750     terminal.\n751     \"\"\"\n752 \n753     # Officially stream needs to be a IO[str], but TerminalReporter\n754     # isn't. So force it.\n755     stream = None  # type: TerminalReporter # type: ignore\n756 \n757     def __init__(\n758         self,\n759         terminal_reporter: TerminalReporter,\n760         capture_manager: Optional[CaptureManager],\n761     ) -> None:\n762         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type]\n763         self.capture_manager = capture_manager\n764         self.reset()\n765         self.set_when(None)\n766         self._test_outcome_written = False\n767 \n768     def reset(self) -> None:\n769         \"\"\"Reset the handler; should be called before the start of each test.\"\"\"\n770         self._first_record_emitted = False\n771 \n772     def set_when(self, when: Optional[str]) -> None:\n773         \"\"\"Prepare for the given test phase (setup/call/teardown).\"\"\"\n774         self._when = when\n775         self._section_name_shown = False\n776         if when == \"start\":\n777             self._test_outcome_written = False\n778 \n779     def emit(self, record: logging.LogRecord) -> None:\n780         ctx_manager = (\n781             self.capture_manager.global_and_fixture_disabled()\n782             if self.capture_manager\n783             else nullcontext()\n784         )\n785         with ctx_manager:\n786             if not self._first_record_emitted:\n787                 self.stream.write(\"\\n\")\n788                 self._first_record_emitted = True\n789             elif self._when in (\"teardown\", \"finish\"):\n790                 if not self._test_outcome_written:\n791                     self._test_outcome_written = True\n792                     self.stream.write(\"\\n\")\n793             if not self._section_name_shown and self._when:\n794                 self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\n795                 self._section_name_shown = True\n796             super().emit(record)\n797 \n798     def handleError(self, record: logging.LogRecord) -> None:\n799         # Handled by LogCaptureHandler.\n800         pass\n801 \n802 \n803 class _LiveLoggingNullHandler(logging.NullHandler):\n804     \"\"\"A logging handler used when live logging is disabled.\"\"\"\n805 \n806     def reset(self) -> None:\n807         pass\n808 \n809     def set_when(self, when: str) -> None:\n810         pass\n811 \n812     def handleError(self, record: logging.LogRecord) -> None:\n813         # Handled by LogCaptureHandler.\n814         pass\n",
        "intended_behavior": "Within the involved method(s) in src/_pytest/logging.py that manage logging levels via caplog.set_level, ensure that _initial_handler_level dictionary uses setdefault rather than set when updating handler levels for the first time. This change is crucial to ensure that the initial logging level of each handler is captured and preserved correctly before any test manipulates it. When restoring handler levels after a test, the restoration process should reference _initial_handler_level to set each handler's level back to its original state before the first set_level call in the test scope, ensuring true restoration to pre-test conditions. Ensure that if set_level is called multiple times within the same test, _initial_handler_level does not overwrite the initially stored level with subsequent calls. Only the first call's level should be stored as the initial state to be restored post-test. This restoration mechanism ensures that tests which modify logging levels do not interfere with each other by incorrectly setting up logging states based on the modifications made by previous tests within the same session."
    }
]