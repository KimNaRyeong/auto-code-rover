[
    {
        "rel_file_path": "sympy/simplify/trigsimp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/simplify/trigsimp.py",
        "start": 1,
        "end": 1188,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 \n5 from sympy.core.cache import cacheit\n6 from sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n7     Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\n8 from sympy.core.compatibility import reduce, iterable\n9 from sympy.core.numbers import I, Integer\n10 from sympy.core.function import count_ops, _mexpand\n11 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n12 from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n13 from sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n14 \n15 from sympy.strategies.core import identity\n16 from sympy.strategies.tree import greedy\n17 \n18 from sympy.polys import Poly\n19 from sympy.polys.polyerrors import PolificationFailed\n20 from sympy.polys.polytools import groebner\n21 from sympy.polys.domains import ZZ\n22 from sympy.polys import factor, cancel, parallel_poly_from_expr\n23 \n24 from sympy.utilities.misc import debug\n25 \n26 \n27 \n28 def trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n29                       polynomial=False):\n30     \"\"\"\n31     Simplify trigonometric expressions using a groebner basis algorithm.\n32 \n33     This routine takes a fraction involving trigonometric or hyperbolic\n34     expressions, and tries to simplify it. The primary metric is the\n35     total degree. Some attempts are made to choose the simplest possible\n36     expression of the minimal degree, but this is non-rigorous, and also\n37     very slow (see the ``quick=True`` option).\n38 \n39     If ``polynomial`` is set to True, instead of simplifying numerator and\n40     denominator together, this function just brings numerator and denominator\n41     into a canonical form. This is much faster, but has potentially worse\n42     results. However, if the input is a polynomial, then the result is\n43     guaranteed to be an equivalent polynomial of minimal degree.\n44 \n45     The most important option is hints. Its entries can be any of the\n46     following:\n47 \n48     - a natural number\n49     - a function\n50     - an iterable of the form (func, var1, var2, ...)\n51     - anything else, interpreted as a generator\n52 \n53     A number is used to indicate that the search space should be increased.\n54     A function is used to indicate that said function is likely to occur in a\n55     simplified expression.\n56     An iterable is used indicate that func(var1 + var2 + ...) is likely to\n57     occur in a simplified .\n58     An additional generator also indicates that it is likely to occur.\n59     (See examples below).\n60 \n61     This routine carries out various computationally intensive algorithms.\n62     The option ``quick=True`` can be used to suppress one particularly slow\n63     step (at the expense of potentially more complicated results, but never at\n64     the expense of increased total degree).\n65 \n66     Examples\n67     ========\n68 \n69     >>> from sympy.abc import x, y\n70     >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n71     >>> from sympy.simplify.trigsimp import trigsimp_groebner\n72 \n73     Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n74 \n75     >>> ex = sin(x)*cos(x)\n76     >>> trigsimp_groebner(ex)\n77     sin(x)*cos(x)\n78 \n79     This is because ``trigsimp_groebner`` only looks for a simplification\n80     involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n81     ``2*x`` by passing ``hints=[2]``:\n82 \n83     >>> trigsimp_groebner(ex, hints=[2])\n84     sin(2*x)/2\n85     >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n86     -cos(2*x)\n87 \n88     Increasing the search space this way can quickly become expensive. A much\n89     faster way is to give a specific expression that is likely to occur:\n90 \n91     >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n92     sin(2*x)/2\n93 \n94     Hyperbolic expressions are similarly supported:\n95 \n96     >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n97     2*cosh(x)\n98 \n99     Note how no hints had to be passed, since the expression already involved\n100     ``2*x``.\n101 \n102     The tangent function is also supported. You can either pass ``tan`` in the\n103     hints, to indicate that than should be tried whenever cosine or sine are,\n104     or you can pass a specific generator:\n105 \n106     >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n107     tan(x)\n108     >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n109     tanh(x)\n110 \n111     Finally, you can use the iterable form to suggest that angle sum formulae\n112     should be tried:\n113 \n114     >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n115     >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n116     tan(x + y)\n117     \"\"\"\n118     # TODO\n119     #  - preprocess by replacing everything by funcs we can handle\n120     # - optionally use cot instead of tan\n121     # - more intelligent hinting.\n122     #     For example, if the ideal is small, and we have sin(x), sin(y),\n123     #     add sin(x + y) automatically... ?\n124     # - algebraic numbers ...\n125     # - expressions of lowest degree are not distinguished properly\n126     #   e.g. 1 - sin(x)**2\n127     # - we could try to order the generators intelligently, so as to influence\n128     #   which monomials appear in the quotient basis\n129 \n130     # THEORY\n131     # ------\n132     # Ratsimpmodprime above can be used to \"simplify\" a rational function\n133     # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n134     # expression of lower total degree.\n135     #\n136     # We intend to use this to simplify trigonometric functions. To do that,\n137     # we need to decide (a) which ring to use, and (b) modulo which ideal to\n138     # simplify. In practice, (a) means settling on a list of \"generators\"\n139     # a, b, c, ..., such that the fraction we want to simplify is a rational\n140     # function in a, b, c, ..., with coefficients in ZZ (integers).\n141     # (2) means that we have to decide what relations to impose on the\n142     # generators. There are two practical problems:\n143     #   (1) The ideal has to be *prime* (a technical term).\n144     #   (2) The relations have to be polynomials in the generators.\n145     #\n146     # We typically have two kinds of generators:\n147     # - trigonometric expressions, like sin(x), cos(5*x), etc\n148     # - \"everything else\", like gamma(x), pi, etc.\n149     #\n150     # Since this function is trigsimp, we will concentrate on what to do with\n151     # trigonometric expressions. We can also simplify hyperbolic expressions,\n152     # but the extensions should be clear.\n153     #\n154     # One crucial point is that all *other* generators really should behave\n155     # like indeterminates. In particular if (say) \"I\" is one of them, then\n156     # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n157     # expressions. However, we can work with a dummy and add the relation\n158     # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n159     #\n160     # Now regarding trigonometric generators. We split them into groups,\n161     # according to the argument of the trigonometric functions. We want to\n162     # organise this in such a way that most trigonometric identities apply in\n163     # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n164     # group as [sin(x), cos(2*x)] and [cos(y)].\n165     #\n166     # Our prime ideal will be built in three steps:\n167     # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n168     #     Geometrically prime means that it generates a prime ideal in\n169     #     CC[gens], not just ZZ[gens].\n170     # (2) Take the union of all the generators of the ideals for all groups.\n171     #     By the geometric primality condition, this is still prime.\n172     # (3) Add further inter-group relations which preserve primality.\n173     #\n174     # Step (1) works as follows. We will isolate common factors in the\n175     # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n176     # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n177     # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n178     # X**2 + Y**2 - 1 is irreducible over CC.\n179     # Now, if we have a generator sin(n*x), than we can, using trig identities,\n180     # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n181     # relation to the ideal, preserving geometric primality, since the quotient\n182     # ring is unchanged.\n183     # Thus we have treated all sin and cos terms.\n184     # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n185     # (This requires of course that we already have relations for cos(n*x) and\n186     # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n187     # primality.\n188     # XXX A real proof would be nice. HELP!\n189     #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n190     #     CC[S, C, T]:\n191     #     - it suffices to show that the projective closure in CP**3 is\n192     #       irreducible\n193     #     - using the half-angle substitutions, we can express sin(x), tan(x),\n194     #       cos(x) as rational functions in tan(x/2)\n195     #     - from this, we get a rational map from CP**1 to our curve\n196     #     - this is a morphism, hence the curve is prime\n197     #\n198     # Step (2) is trivial.\n199     #\n200     # Step (3) works by adding selected relations of the form\n201     # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n202     # preserved by the same argument as before.\n203 \n204     def parse_hints(hints):\n205         \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n206         n = 1\n207         funcs, iterables, gens = [], [], []\n208         for e in hints:\n209             if isinstance(e, (int, Integer)):\n210                 n = e\n211             elif isinstance(e, FunctionClass):\n212                 funcs.append(e)\n213             elif iterable(e):\n214                 iterables.append((e[0], e[1:]))\n215                 # XXX sin(x+2y)?\n216                 # Note: we go through polys so e.g.\n217                 # sin(-x) -> -sin(x) -> sin(x)\n218                 gens.extend(parallel_poly_from_expr(\n219                     [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n220             else:\n221                 gens.append(e)\n222         return n, funcs, iterables, gens\n223 \n224     def build_ideal(x, terms):\n225         \"\"\"\n226         Build generators for our ideal. Terms is an iterable with elements of\n227         the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n228 \n229         If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n230         to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n231         sin(n*x) and cos(n*x) are guaranteed.\n232         \"\"\"\n233         gens = []\n234         I = []\n235         y = Dummy('y')\n236         for fn, coeff in terms:\n237             for c, s, t, rel in (\n238                     [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n239                     [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n240                 if coeff == 1 and fn in [c, s]:\n241                     I.append(rel)\n242                 elif fn == t:\n243                     I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n244                 elif fn in [c, s]:\n245                     cn = fn(coeff*y).expand(trig=True).subs(y, x)\n246                     I.append(fn(coeff*x) - cn)\n247         return list(set(I))\n248 \n249     def analyse_gens(gens, hints):\n250         \"\"\"\n251         Analyse the generators ``gens``, using the hints ``hints``.\n252 \n253         The meaning of ``hints`` is described in the main docstring.\n254         Return a new list of generators, and also the ideal we should\n255         work with.\n256         \"\"\"\n257         # First parse the hints\n258         n, funcs, iterables, extragens = parse_hints(hints)\n259         debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n260               iterables, 'extragens:', extragens)\n261 \n262         # We just add the extragens to gens and analyse them as before\n263         gens = list(gens)\n264         gens.extend(extragens)\n265 \n266         # remove duplicates\n267         funcs = list(set(funcs))\n268         iterables = list(set(iterables))\n269         gens = list(set(gens))\n270 \n271         # all the functions we can do anything with\n272         allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n273         # sin(3*x) -> ((3, x), sin)\n274         trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n275                      if g.func in allfuncs]\n276         # Our list of new generators - start with anything that we cannot\n277         # work with (i.e. is not a trigonometric term)\n278         freegens = [g for g in gens if g.func not in allfuncs]\n279         newgens = []\n280         trigdict = {}\n281         for (coeff, var), fn in trigterms:\n282             trigdict.setdefault(var, []).append((coeff, fn))\n283         res = [] # the ideal\n284 \n285         for key, val in trigdict.items():\n286             # We have now assembeled a dictionary. Its keys are common\n287             # arguments in trigonometric expressions, and values are lists of\n288             # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n289             # need to deal with fn(coeff*x0). We take the rational gcd of the\n290             # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n291             # all other arguments are integral multiples thereof.\n292             # We will build an ideal which works with sin(x), cos(x).\n293             # If hint tan is provided, also work with tan(x). Moreover, if\n294             # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n295             # (and tan if the hint is provided). Finally, any generators which\n296             # the ideal does not work with but we need to accomodate (either\n297             # because it was in expr or because it was provided as a hint)\n298             # we also build into the ideal.\n299             # This selection process is expressed in the list ``terms``.\n300             # build_ideal then generates the actual relations in our ideal,\n301             # from this list.\n302             fns = [x[1] for x in val]\n303             val = [x[0] for x in val]\n304             gcd = reduce(igcd, val)\n305             terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n306             fs = set(funcs + fns)\n307             for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n308                 if any(x in fs for x in (c, s, t)):\n309                     fs.add(c)\n310                     fs.add(s)\n311             for fn in fs:\n312                 for k in range(1, n + 1):\n313                     terms.append((fn, k))\n314             extra = []\n315             for fn, v in terms:\n316                 if fn == tan:\n317                     extra.append((sin, v))\n318                     extra.append((cos, v))\n319                 if fn in [sin, cos] and tan in fs:\n320                     extra.append((tan, v))\n321                 if fn == tanh:\n322                     extra.append((sinh, v))\n323                     extra.append((cosh, v))\n324                 if fn in [sinh, cosh] and tanh in fs:\n325                     extra.append((tanh, v))\n326             terms.extend(extra)\n327             x = gcd*Mul(*key)\n328             r = build_ideal(x, terms)\n329             res.extend(r)\n330             newgens.extend(set(fn(v*x) for fn, v in terms))\n331 \n332         # Add generators for compound expressions from iterables\n333         for fn, args in iterables:\n334             if fn == tan:\n335                 # Tan expressions are recovered from sin and cos.\n336                 iterables.extend([(sin, args), (cos, args)])\n337             elif fn == tanh:\n338                 # Tanh expressions are recovered from sihn and cosh.\n339                 iterables.extend([(sinh, args), (cosh, args)])\n340             else:\n341                 dummys = symbols('d:%i' % len(args), cls=Dummy)\n342                 expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n343                 res.append(fn(Add(*args)) - expr)\n344 \n345         if myI in gens:\n346             res.append(myI**2 + 1)\n347             freegens.remove(myI)\n348             newgens.append(myI)\n349 \n350         return res, freegens, newgens\n351 \n352     myI = Dummy('I')\n353     expr = expr.subs(S.ImaginaryUnit, myI)\n354     subs = [(myI, S.ImaginaryUnit)]\n355 \n356     num, denom = cancel(expr).as_numer_denom()\n357     try:\n358         (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n359     except PolificationFailed:\n360         return expr\n361     debug('initial gens:', opt.gens)\n362     ideal, freegens, gens = analyse_gens(opt.gens, hints)\n363     debug('ideal:', ideal)\n364     debug('new gens:', gens, \" -- len\", len(gens))\n365     debug('free gens:', freegens, \" -- len\", len(gens))\n366     # NOTE we force the domain to be ZZ to stop polys from injecting generators\n367     #      (which is usually a sign of a bug in the way we build the ideal)\n368     if not gens:\n369         return expr\n370     G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n371     debug('groebner basis:', list(G), \" -- len\", len(G))\n372 \n373     # If our fraction is a polynomial in the free generators, simplify all\n374     # coefficients separately:\n375 \n376     from sympy.simplify.ratsimp import ratsimpmodprime\n377 \n378     if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n379         num = Poly(num, gens=gens+freegens).eject(*gens)\n380         res = []\n381         for monom, coeff in num.terms():\n382             ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n383             # We compute the transitive closure of all generators that can\n384             # be reached from our generators through relations in the ideal.\n385             changed = True\n386             while changed:\n387                 changed = False\n388                 for p in ideal:\n389                     p = Poly(p)\n390                     if not ourgens.issuperset(p.gens) and \\\n391                        not p.has_only_gens(*set(p.gens).difference(ourgens)):\n392                         changed = True\n393                         ourgens.update(p.exclude().gens)\n394             # NOTE preserve order!\n395             realgens = [x for x in gens if x in ourgens]\n396             # The generators of the ideal have now been (implicitely) split\n397             # into two groups: those involving ourgens and those that don't.\n398             # Since we took the transitive closure above, these two groups\n399             # live in subgrings generated by a *disjoint* set of variables.\n400             # Any sensible groebner basis algorithm will preserve this disjoint\n401             # structure (i.e. the elements of the groebner basis can be split\n402             # similarly), and and the two subsets of the groebner basis then\n403             # form groebner bases by themselves. (For the smaller generating\n404             # sets, of course.)\n405             ourG = [g.as_expr() for g in G.polys if\n406                     g.has_only_gens(*ourgens.intersection(g.gens))]\n407             res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n408                        ratsimpmodprime(coeff/denom, ourG, order=order,\n409                                        gens=realgens, quick=quick, domain=ZZ,\n410                                        polynomial=polynomial).subs(subs))\n411         return Add(*res)\n412         # NOTE The following is simpler and has less assumptions on the\n413         #      groebner basis algorithm. If the above turns out to be broken,\n414         #      use this.\n415         return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n416                      ratsimpmodprime(coeff/denom, list(G), order=order,\n417                                      gens=gens, quick=quick, domain=ZZ)\n418                      for monom, coeff in num.terms()])\n419     else:\n420         return ratsimpmodprime(\n421             expr, list(G), order=order, gens=freegens+gens,\n422             quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n423 \n424 \n425 _trigs = (TrigonometricFunction, HyperbolicFunction)\n426 \n427 \n428 def trigsimp(expr, **opts):\n429     \"\"\"\n430     reduces expression by using known trig identities\n431 \n432     Notes\n433     =====\n434 \n435     method:\n436     - Determine the method to use. Valid choices are 'matching' (default),\n437     'groebner', 'combined', and 'fu'. If 'matching', simplify the\n438     expression recursively by targeting common patterns. If 'groebner', apply\n439     an experimental groebner basis algorithm. In this case further options\n440     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n441     If 'combined', first run the groebner basis algorithm with small\n442     default parameters, then run the 'matching' algorithm. 'fu' runs the\n443     collection of trigonometric transformations described by Fu, et al.\n444     (see the `fu` docstring).\n445 \n446 \n447     Examples\n448     ========\n449 \n450     >>> from sympy import trigsimp, sin, cos, log\n451     >>> from sympy.abc import x, y\n452     >>> e = 2*sin(x)**2 + 2*cos(x)**2\n453     >>> trigsimp(e)\n454     2\n455 \n456     Simplification occurs wherever trigonometric functions are located.\n457 \n458     >>> trigsimp(log(e))\n459     log(2)\n460 \n461     Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n462     simplification.\n463 \n464     The old trigsimp routine can be accessed as with method 'old'.\n465 \n466     >>> from sympy import coth, tanh\n467     >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n468     >>> trigsimp(t, method='old') == t\n469     True\n470     >>> trigsimp(t)\n471     tanh(x)**7\n472 \n473     \"\"\"\n474     from sympy.simplify.fu import fu\n475 \n476     expr = sympify(expr)\n477 \n478     try:\n479         return expr._eval_trigsimp(**opts)\n480     except AttributeError:\n481         pass\n482 \n483     old = opts.pop('old', False)\n484     if not old:\n485         opts.pop('deep', None)\n486         recursive = opts.pop('recursive', None)\n487         method = opts.pop('method', 'matching')\n488     else:\n489         method = 'old'\n490 \n491     def groebnersimp(ex, **opts):\n492         def traverse(e):\n493             if e.is_Atom:\n494                 return e\n495             args = [traverse(x) for x in e.args]\n496             if e.is_Function or e.is_Pow:\n497                 args = [trigsimp_groebner(x, **opts) for x in args]\n498             return e.func(*args)\n499         new = traverse(ex)\n500         if not isinstance(new, Expr):\n501             return new\n502         return trigsimp_groebner(new, **opts)\n503 \n504     trigsimpfunc = {\n505         'fu': (lambda x: fu(x, **opts)),\n506         'matching': (lambda x: futrig(x)),\n507         'groebner': (lambda x: groebnersimp(x, **opts)),\n508         'combined': (lambda x: futrig(groebnersimp(x,\n509                                polynomial=True, hints=[2, tan]))),\n510         'old': lambda x: trigsimp_old(x, **opts),\n511                    }[method]\n512 \n513     return trigsimpfunc(expr)\n514 \n515 \n516 def exptrigsimp(expr):\n517     \"\"\"\n518     Simplifies exponential / trigonometric / hyperbolic functions.\n519 \n520     Examples\n521     ========\n522 \n523     >>> from sympy import exptrigsimp, exp, cosh, sinh\n524     >>> from sympy.abc import z\n525 \n526     >>> exptrigsimp(exp(z) + exp(-z))\n527     2*cosh(z)\n528     >>> exptrigsimp(cosh(z) - sinh(z))\n529     exp(-z)\n530     \"\"\"\n531     from sympy.simplify.fu import hyper_as_trig, TR2i\n532     from sympy.simplify.simplify import bottom_up\n533 \n534     def exp_trig(e):\n535         # select the better of e, and e rewritten in terms of exp or trig\n536         # functions\n537         choices = [e]\n538         if e.has(*_trigs):\n539             choices.append(e.rewrite(exp))\n540         choices.append(e.rewrite(cos))\n541         return min(*choices, key=count_ops)\n542     newexpr = bottom_up(expr, exp_trig)\n543 \n544     def f(rv):\n545         if not rv.is_Mul:\n546             return rv\n547         rvd = rv.as_powers_dict()\n548         newd = rvd.copy()\n549 \n550         def signlog(expr, sign=1):\n551             if expr is S.Exp1:\n552                 return sign, 1\n553             elif isinstance(expr, exp):\n554                 return sign, expr.args[0]\n555             elif sign == 1:\n556                 return signlog(-expr, sign=-1)\n557             else:\n558                 return None, None\n559 \n560         ee = rvd[S.Exp1]\n561         for k in rvd:\n562             if k.is_Add and len(k.args) == 2:\n563                 # k == c*(1 + sign*E**x)\n564                 c = k.args[0]\n565                 sign, x = signlog(k.args[1]/c)\n566                 if not x:\n567                     continue\n568                 m = rvd[k]\n569                 newd[k] -= m\n570                 if ee == -x*m/2:\n571                     # sinh and cosh\n572                     newd[S.Exp1] -= ee\n573                     ee = 0\n574                     if sign == 1:\n575                         newd[2*c*cosh(x/2)] += m\n576                     else:\n577                         newd[-2*c*sinh(x/2)] += m\n578                 elif newd[1 - sign*S.Exp1**x] == -m:\n579                     # tanh\n580                     del newd[1 - sign*S.Exp1**x]\n581                     if sign == 1:\n582                         newd[-c/tanh(x/2)] += m\n583                     else:\n584                         newd[-c*tanh(x/2)] += m\n585                 else:\n586                     newd[1 + sign*S.Exp1**x] += m\n587                     newd[c] += m\n588 \n589         return Mul(*[k**newd[k] for k in newd])\n590     newexpr = bottom_up(newexpr, f)\n591 \n592     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n593     if newexpr.has(HyperbolicFunction):\n594         e, f = hyper_as_trig(newexpr)\n595         newexpr = f(TR2i(e))\n596     if newexpr.has(TrigonometricFunction):\n597         newexpr = TR2i(newexpr)\n598 \n599     # can we ever generate an I where there was none previously?\n600     if not (newexpr.has(I) and not expr.has(I)):\n601         expr = newexpr\n602     return expr\n603 \n604 #-------------------- the old trigsimp routines ---------------------\n605 \n606 def trigsimp_old(expr, **opts):\n607     \"\"\"\n608     reduces expression by using known trig identities\n609 \n610     Notes\n611     =====\n612 \n613     deep:\n614     - Apply trigsimp inside all objects with arguments\n615 \n616     recursive:\n617     - Use common subexpression elimination (cse()) and apply\n618     trigsimp recursively (this is quite expensive if the\n619     expression is large)\n620 \n621     method:\n622     - Determine the method to use. Valid choices are 'matching' (default),\n623     'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n624     expression recursively by pattern matching. If 'groebner', apply an\n625     experimental groebner basis algorithm. In this case further options\n626     are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n627     If 'combined', first run the groebner basis algorithm with small\n628     default parameters, then run the 'matching' algorithm. 'fu' runs the\n629     collection of trigonometric transformations described by Fu, et al.\n630     (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n631     that mimic the behavior of `trigsimp`.\n632 \n633     compare:\n634     - show input and output from `trigsimp` and `futrig` when different,\n635     but returns the `trigsimp` value.\n636 \n637     Examples\n638     ========\n639 \n640     >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n641     >>> from sympy.abc import x, y\n642     >>> e = 2*sin(x)**2 + 2*cos(x)**2\n643     >>> trigsimp(e, old=True)\n644     2\n645     >>> trigsimp(log(e), old=True)\n646     log(2*sin(x)**2 + 2*cos(x)**2)\n647     >>> trigsimp(log(e), deep=True, old=True)\n648     log(2)\n649 \n650     Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n651     more simplification:\n652 \n653     >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n654     >>> trigsimp(e, old=True)\n655     (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n656     >>> trigsimp(e, method=\"groebner\", old=True)\n657     2/cos(x)\n658 \n659     >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n660           futrig: tan(x)**2\n661     cot(x)**(-2)\n662 \n663     \"\"\"\n664     old = expr\n665     first = opts.pop('first', True)\n666     if first:\n667         if not expr.has(*_trigs):\n668             return expr\n669 \n670         trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n671         if len(trigsyms) > 1:\n672             d = separatevars(expr)\n673             if d.is_Mul:\n674                 d = separatevars(d, dict=True) or d\n675             if isinstance(d, dict):\n676                 expr = 1\n677                 for k, v in d.items():\n678                     # remove hollow factoring\n679                     was = v\n680                     v = expand_mul(v)\n681                     opts['first'] = False\n682                     vnew = trigsimp(v, **opts)\n683                     if vnew == v:\n684                         vnew = was\n685                     expr *= vnew\n686                 old = expr\n687             else:\n688                 if d.is_Add:\n689                     for s in trigsyms:\n690                         r, e = expr.as_independent(s)\n691                         if r:\n692                             opts['first'] = False\n693                             expr = r + trigsimp(e, **opts)\n694                             if not expr.is_Add:\n695                                 break\n696                     old = expr\n697 \n698     recursive = opts.pop('recursive', False)\n699     deep = opts.pop('deep', False)\n700     method = opts.pop('method', 'matching')\n701 \n702     def groebnersimp(ex, deep, **opts):\n703         def traverse(e):\n704             if e.is_Atom:\n705                 return e\n706             args = [traverse(x) for x in e.args]\n707             if e.is_Function or e.is_Pow:\n708                 args = [trigsimp_groebner(x, **opts) for x in args]\n709             return e.func(*args)\n710         if deep:\n711             ex = traverse(ex)\n712         return trigsimp_groebner(ex, **opts)\n713 \n714     trigsimpfunc = {\n715         'matching': (lambda x, d: _trigsimp(x, d)),\n716         'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n717         'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n718                                        d, polynomial=True, hints=[2, tan]),\n719                                    d))\n720                    }[method]\n721 \n722     if recursive:\n723         w, g = cse(expr)\n724         g = trigsimpfunc(g[0], deep)\n725 \n726         for sub in reversed(w):\n727             g = g.subs(sub[0], sub[1])\n728             g = trigsimpfunc(g, deep)\n729         result = g\n730     else:\n731         result = trigsimpfunc(expr, deep)\n732 \n733     if opts.get('compare', False):\n734         f = futrig(old)\n735         if f != result:\n736             print('\\tfutrig:', f)\n737 \n738     return result\n739 \n740 \n741 def _dotrig(a, b):\n742     \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n743     of symbols in them -- no need to test hyperbolic patterns against\n744     expressions that have no hyperbolics in them.\"\"\"\n745     return a.func == b.func and (\n746         a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n747         a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n748 \n749 \n750 _trigpat = None\n751 def _trigpats():\n752     global _trigpat\n753     a, b, c = symbols('a b c', cls=Wild)\n754     d = Wild('d', commutative=False)\n755 \n756     # for the simplifications like sinh/cosh -> tanh:\n757     # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n758     # order in _match_div_rewrite.\n759     matchers_division = (\n760         (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n761         (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n762         (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n763         (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n764         (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n765         (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n766         (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n767             a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n768         (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n769             a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n770 \n771         (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n772         (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n773         (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n774         (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n775         (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n776         (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n777 \n778         (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n779             tanh(a + b)*c, S.One, S.One),\n780     )\n781 \n782     matchers_add = (\n783         (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n784         (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n785         (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n786         (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n787         (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n788         (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n789     )\n790 \n791     # for cos(x)**2 + sin(x)**2 -> 1\n792     matchers_identity = (\n793         (a*sin(b)**2, a - a*cos(b)**2),\n794         (a*tan(b)**2, a*(1/cos(b))**2 - a),\n795         (a*cot(b)**2, a*(1/sin(b))**2 - a),\n796         (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n797         (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n798         (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n799 \n800         (a*sinh(b)**2, a*cosh(b)**2 - a),\n801         (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n802         (a*coth(b)**2, a + a*(1/sinh(b))**2),\n803         (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n804         (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n805         (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n806 \n807     )\n808 \n809     # Reduce any lingering artifacts, such as sin(x)**2 changing\n810     # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n811     artifacts = (\n812         (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n813         (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n814         (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n815 \n816         (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n817         (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n818         (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n819 \n820         # same as above but with noncommutative prefactor\n821         (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n822         (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n823         (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n824 \n825         (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n826         (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n827         (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n828     )\n829 \n830     _trigpat = (a, b, c, d, matchers_division, matchers_add,\n831         matchers_identity, artifacts)\n832     return _trigpat\n833 \n834 \n835 def _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n836     \"\"\"Helper for _match_div_rewrite.\n837 \n838     Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n839     and g(b_) are both positive or if c_ is an integer.\n840     \"\"\"\n841     # assert expr.is_Mul and expr.is_commutative and f != g\n842     fargs = defaultdict(int)\n843     gargs = defaultdict(int)\n844     args = []\n845     for x in expr.args:\n846         if x.is_Pow or x.func in (f, g):\n847             b, e = x.as_base_exp()\n848             if b.is_positive or e.is_integer:\n849                 if b.func == f:\n850                     fargs[b.args[0]] += e\n851                     continue\n852                 elif b.func == g:\n853                     gargs[b.args[0]] += e\n854                     continue\n855         args.append(x)\n856     common = set(fargs) & set(gargs)\n857     hit = False\n858     while common:\n859         key = common.pop()\n860         fe = fargs.pop(key)\n861         ge = gargs.pop(key)\n862         if fe == rexp(ge):\n863             args.append(h(key)**rexph(fe))\n864             hit = True\n865         else:\n866             fargs[key] = fe\n867             gargs[key] = ge\n868     if not hit:\n869         return expr\n870     while fargs:\n871         key, e = fargs.popitem()\n872         args.append(f(key)**e)\n873     while gargs:\n874         key, e = gargs.popitem()\n875         args.append(g(key)**e)\n876     return Mul(*args)\n877 \n878 \n879 _idn = lambda x: x\n880 _midn = lambda x: -x\n881 _one = lambda x: S.One\n882 \n883 def _match_div_rewrite(expr, i):\n884     \"\"\"helper for __trigsimp\"\"\"\n885     if i == 0:\n886         expr = _replace_mul_fpowxgpow(expr, sin, cos,\n887             _midn, tan, _idn)\n888     elif i == 1:\n889         expr = _replace_mul_fpowxgpow(expr, tan, cos,\n890             _idn, sin, _idn)\n891     elif i == 2:\n892         expr = _replace_mul_fpowxgpow(expr, cot, sin,\n893             _idn, cos, _idn)\n894     elif i == 3:\n895         expr = _replace_mul_fpowxgpow(expr, tan, sin,\n896             _midn, cos, _midn)\n897     elif i == 4:\n898         expr = _replace_mul_fpowxgpow(expr, cot, cos,\n899             _midn, sin, _midn)\n900     elif i == 5:\n901         expr = _replace_mul_fpowxgpow(expr, cot, tan,\n902             _idn, _one, _idn)\n903     # i in (6, 7) is skipped\n904     elif i == 8:\n905         expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n906             _midn, tanh, _idn)\n907     elif i == 9:\n908         expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n909             _idn, sinh, _idn)\n910     elif i == 10:\n911         expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n912             _idn, cosh, _idn)\n913     elif i == 11:\n914         expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n915             _midn, cosh, _midn)\n916     elif i == 12:\n917         expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n918             _midn, sinh, _midn)\n919     elif i == 13:\n920         expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n921             _idn, _one, _idn)\n922     else:\n923         return None\n924     return expr\n925 \n926 \n927 def _trigsimp(expr, deep=False):\n928     # protect the cache from non-trig patterns; we only allow\n929     # trig patterns to enter the cache\n930     if expr.has(*_trigs):\n931         return __trigsimp(expr, deep)\n932     return expr\n933 \n934 \n935 @cacheit\n936 def __trigsimp(expr, deep=False):\n937     \"\"\"recursive helper for trigsimp\"\"\"\n938     from sympy.simplify.fu import TR10i\n939 \n940     if _trigpat is None:\n941         _trigpats()\n942     a, b, c, d, matchers_division, matchers_add, \\\n943     matchers_identity, artifacts = _trigpat\n944 \n945     if expr.is_Mul:\n946         # do some simplifications like sin/cos -> tan:\n947         if not expr.is_commutative:\n948             com, nc = expr.args_cnc()\n949             expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n950         else:\n951             for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n952                 if not _dotrig(expr, pattern):\n953                     continue\n954 \n955                 newexpr = _match_div_rewrite(expr, i)\n956                 if newexpr is not None:\n957                     if newexpr != expr:\n958                         expr = newexpr\n959                         break\n960                     else:\n961                         continue\n962 \n963                 # use SymPy matching instead\n964                 res = expr.match(pattern)\n965                 if res and res.get(c, 0):\n966                     if not res[c].is_integer:\n967                         ok = ok1.subs(res)\n968                         if not ok.is_positive:\n969                             continue\n970                         ok = ok2.subs(res)\n971                         if not ok.is_positive:\n972                             continue\n973                     # if \"a\" contains any of trig or hyperbolic funcs with\n974                     # argument \"b\" then skip the simplification\n975                     if any(w.args[0] == res[b] for w in res[a].atoms(\n976                             TrigonometricFunction, HyperbolicFunction)):\n977                         continue\n978                     # simplify and finish:\n979                     expr = simp.subs(res)\n980                     break  # process below\n981 \n982     if expr.is_Add:\n983         args = []\n984         for term in expr.args:\n985             if not term.is_commutative:\n986                 com, nc = term.args_cnc()\n987                 nc = Mul._from_args(nc)\n988                 term = Mul._from_args(com)\n989             else:\n990                 nc = S.One\n991             term = _trigsimp(term, deep)\n992             for pattern, result in matchers_identity:\n993                 res = term.match(pattern)\n994                 if res is not None:\n995                     term = result.subs(res)\n996                     break\n997             args.append(term*nc)\n998         if args != expr.args:\n999             expr = Add(*args)\n1000             expr = min(expr, expand(expr), key=count_ops)\n1001         if expr.is_Add:\n1002             for pattern, result in matchers_add:\n1003                 if not _dotrig(expr, pattern):\n1004                     continue\n1005                 expr = TR10i(expr)\n1006                 if expr.has(HyperbolicFunction):\n1007                     res = expr.match(pattern)\n1008                     # if \"d\" contains any trig or hyperbolic funcs with\n1009                     # argument \"a\" or \"b\" then skip the simplification;\n1010                     # this isn't perfect -- see tests\n1011                     if res is None or not (a in res and b in res) or any(\n1012                         w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n1013                             TrigonometricFunction, HyperbolicFunction)):\n1014                         continue\n1015                     expr = result.subs(res)\n1016                     break\n1017 \n1018         # Reduce any lingering artifacts, such as sin(x)**2 changing\n1019         # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n1020         for pattern, result, ex in artifacts:\n1021             if not _dotrig(expr, pattern):\n1022                 continue\n1023             # Substitute a new wild that excludes some function(s)\n1024             # to help influence a better match. This is because\n1025             # sometimes, for example, 'a' would match sec(x)**2\n1026             a_t = Wild('a', exclude=[ex])\n1027             pattern = pattern.subs(a, a_t)\n1028             result = result.subs(a, a_t)\n1029 \n1030             m = expr.match(pattern)\n1031             was = None\n1032             while m and was != expr:\n1033                 was = expr\n1034                 if m[a_t] == 0 or \\\n1035                         -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n1036                     break\n1037                 if d in m and m[a_t]*m[d] + m[c] == 0:\n1038                     break\n1039                 expr = result.subs(m)\n1040                 m = expr.match(pattern)\n1041                 m.setdefault(c, S.Zero)\n1042 \n1043     elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n1044         expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n1045 \n1046     try:\n1047         if not expr.has(*_trigs):\n1048             raise TypeError\n1049         e = expr.atoms(exp)\n1050         new = expr.rewrite(exp, deep=deep)\n1051         if new == e:\n1052             raise TypeError\n1053         fnew = factor(new)\n1054         if fnew != new:\n1055             new = sorted([new, factor(new)], key=count_ops)[0]\n1056         # if all exp that were introduced disappeared then accept it\n1057         if not (new.atoms(exp) - e):\n1058             expr = new\n1059     except TypeError:\n1060         pass\n1061 \n1062     return expr\n1063 #------------------- end of old trigsimp routines --------------------\n1064 \n1065 \n1066 def futrig(e, **kwargs):\n1067     \"\"\"Return simplified ``e`` using Fu-like transformations.\n1068     This is not the \"Fu\" algorithm. This is called by default\n1069     from ``trigsimp``. By default, hyperbolics subexpressions\n1070     will be simplified, but this can be disabled by setting\n1071     ``hyper=False``.\n1072 \n1073     Examples\n1074     ========\n1075 \n1076     >>> from sympy import trigsimp, tan, sinh, tanh\n1077     >>> from sympy.simplify.trigsimp import futrig\n1078     >>> from sympy.abc import x\n1079     >>> trigsimp(1/tan(x)**2)\n1080     tan(x)**(-2)\n1081 \n1082     >>> futrig(sinh(x)/tanh(x))\n1083     cosh(x)\n1084 \n1085     \"\"\"\n1086     from sympy.simplify.fu import hyper_as_trig\n1087     from sympy.simplify.simplify import bottom_up\n1088 \n1089     e = sympify(e)\n1090 \n1091     if not isinstance(e, Basic):\n1092         return e\n1093 \n1094     if not e.args:\n1095         return e\n1096 \n1097     old = e\n1098     e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n1099 \n1100     if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n1101         e, f = hyper_as_trig(e)\n1102         e = f(_futrig(e))\n1103 \n1104     if e != old and e.is_Mul and e.args[0].is_Rational:\n1105         # redistribute leading coeff on 2-arg Add\n1106         e = Mul(*e.as_coeff_Mul())\n1107     return e\n1108 \n1109 \n1110 def _futrig(e, **kwargs):\n1111     \"\"\"Helper for futrig.\"\"\"\n1112     from sympy.simplify.fu import (\n1113         TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n1114         TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n1115         TR12)\n1116     from sympy.core.compatibility import _nodes\n1117 \n1118     if not e.has(TrigonometricFunction):\n1119         return e\n1120 \n1121     if e.is_Mul:\n1122         coeff, e = e.as_independent(TrigonometricFunction)\n1123     else:\n1124         coeff = S.One\n1125 \n1126     Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n1127     trigs = lambda x: x.has(TrigonometricFunction)\n1128 \n1129     tree = [identity,\n1130         (\n1131         TR3,  # canonical angles\n1132         TR1,  # sec-csc -> cos-sin\n1133         TR12,  # expand tan of sum\n1134         lambda x: _eapply(factor, x, trigs),\n1135         TR2,  # tan-cot -> sin-cos\n1136         [identity, lambda x: _eapply(_mexpand, x, trigs)],\n1137         TR2i,  # sin-cos ratio -> tan\n1138         lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n1139         TR14,  # factored identities\n1140         TR5,  # sin-pow -> cos_pow\n1141         TR10,  # sin-cos of sums -> sin-cos prod\n1142         TR11, TR6, # reduce double angles and rewrite cos pows\n1143         lambda x: _eapply(factor, x, trigs),\n1144         TR14,  # factored powers of identities\n1145         [identity, lambda x: _eapply(_mexpand, x, trigs)],\n1146         TRmorrie,\n1147         TR10i,  # sin-cos products > sin-cos of sums\n1148         [identity, TR8],  # sin-cos products -> sin-cos of sums\n1149         [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n1150         [\n1151             lambda x: _eapply(expand_mul, TR5(x), trigs),\n1152             lambda x: _eapply(\n1153                 expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n1154         [\n1155             lambda x:  _eapply(expand_mul, TR6(x), trigs),\n1156             lambda x:  _eapply(\n1157                 expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n1158         TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n1159         [identity, TR2i],  # sin-cos ratio to tan\n1160         [identity, lambda x: _eapply(\n1161             expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n1162         TR1, TR2, TR2i,\n1163         [identity, lambda x: _eapply(\n1164             factor_terms, TR12(x), trigs)],  # expand tan of sum\n1165         )]\n1166     e = greedy(tree, objective=Lops)(e)\n1167 \n1168     return coeff*e\n1169 \n1170 \n1171 def _is_Expr(e):\n1172     \"\"\"_eapply helper to tell whether ``e`` and all its args\n1173     are Exprs.\"\"\"\n1174     if not isinstance(e, Expr):\n1175         return False\n1176     return all(_is_Expr(i) for i in e.args)\n1177 \n1178 \n1179 def _eapply(func, e, cond=None):\n1180     \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n1181     apply it to those args that *are* Exprs.\"\"\"\n1182     if not isinstance(e, Expr):\n1183         return e\n1184     if _is_Expr(e) or not e.args:\n1185         return func(e)\n1186     return e.func(*[\n1187         _eapply(func, ei) if (cond is None or cond(ei)) else ei\n1188         for ei in e.args])\n",
        "intended_behavior": "Ensure the simplification logic correctly identifies and processes trigonometric functions with complex arguments, particularly avoiding incorrect transformations into cosh functions unless mathematically valid."
    },
    {
        "rel_file_path": "sympy/functions/elementary/trigonometric.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/functions/elementary/trigonometric.py",
        "start": 1,
        "end": 2813,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core.add import Add\n4 from sympy.core.basic import sympify, cacheit\n5 from sympy.core.function import Function, ArgumentIndexError\n6 from sympy.core.numbers import igcdex, Rational, pi\n7 from sympy.core.singleton import S\n8 from sympy.core.symbol import Symbol, Wild\n9 from sympy.core.logic import fuzzy_not\n10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max\n12 from sympy.functions.elementary.exponential import log, exp\n13 from sympy.functions.elementary.integers import floor\n14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,\n15     coth, HyperbolicFunction, sinh, tanh)\n16 from sympy.sets.sets import FiniteSet\n17 from sympy.utilities.iterables import numbered_symbols\n18 from sympy.core.compatibility import range\n19 \n20 ###############################################################################\n21 ########################## TRIGONOMETRIC FUNCTIONS ############################\n22 ###############################################################################\n23 \n24 \n25 class TrigonometricFunction(Function):\n26     \"\"\"Base class for trigonometric functions. \"\"\"\n27 \n28     unbranched = True\n29 \n30     def _eval_is_rational(self):\n31         s = self.func(*self.args)\n32         if s.func == self.func:\n33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):\n34                 return False\n35         else:\n36             return s.is_rational\n37 \n38     def _eval_is_algebraic(self):\n39         s = self.func(*self.args)\n40         if s.func == self.func:\n41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:\n42                 return False\n43             pi_coeff = _pi_coeff(self.args[0])\n44             if pi_coeff is not None and pi_coeff.is_rational:\n45                 return True\n46         else:\n47             return s.is_algebraic\n48 \n49     def _eval_expand_complex(self, deep=True, **hints):\n50         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n51         return re_part + im_part*S.ImaginaryUnit\n52 \n53     def _as_real_imag(self, deep=True, **hints):\n54         if self.args[0].is_real:\n55             if deep:\n56                 hints['complex'] = False\n57                 return (self.args[0].expand(deep, **hints), S.Zero)\n58             else:\n59                 return (self.args[0], S.Zero)\n60         if deep:\n61             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n62         else:\n63             re, im = self.args[0].as_real_imag()\n64         return (re, im)\n65 \n66     def _period(self, general_period, symbol=None):\n67         f = self.args[0]\n68         if symbol is None:\n69             symbol = tuple(f.free_symbols)[0]\n70 \n71         if not f.has(symbol):\n72             return S.Zero\n73 \n74         if f == symbol:\n75             return general_period\n76 \n77         if symbol in f.free_symbols:\n78             p, q = Wild('p'), Wild('q')\n79             if f.is_Mul:\n80                 g, h = f.as_independent(symbol)\n81                 if h == symbol:\n82                     return general_period/abs(g)\n83 \n84             if f.is_Add:\n85                 a, h = f.as_independent(symbol)\n86                 g, h = h.as_independent(symbol, as_Add=False)\n87                 if h == symbol:\n88                     return general_period/abs(g)\n89 \n90         raise NotImplementedError(\"Use the periodicity function instead.\")\n91 \n92 \n93 def _peeloff_pi(arg):\n94     \"\"\"\n95     Split ARG into two parts, a \"rest\" and a multiple of pi/2.\n96     This assumes ARG to be an Add.\n97     The multiple of pi returned in the second position is always a Rational.\n98 \n99     Examples\n100     ========\n101 \n102     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel\n103     >>> from sympy import pi\n104     >>> from sympy.abc import x, y\n105     >>> peel(x + pi/2)\n106     (x, pi/2)\n107     >>> peel(x + 2*pi/3 + pi*y)\n108     (x + pi*y + pi/6, pi/2)\n109     \"\"\"\n110     for a in Add.make_args(arg):\n111         if a is S.Pi:\n112             K = S.One\n113             break\n114         elif a.is_Mul:\n115             K, p = a.as_two_terms()\n116             if p is S.Pi and K.is_Rational:\n117                 break\n118     else:\n119         return arg, S.Zero\n120 \n121     m1 = (K % S.Half) * S.Pi\n122     m2 = K*S.Pi - m1\n123     return arg - m2, m2\n124 \n125 \n126 def _pi_coeff(arg, cycles=1):\n127     \"\"\"\n128     When arg is a Number times pi (e.g. 3*pi/2) then return the Number\n129     normalized to be in the range [0, 2], else None.\n130 \n131     When an even multiple of pi is encountered, if it is multiplying\n132     something with known parity then the multiple is returned as 0 otherwise\n133     as 2.\n134 \n135     Examples\n136     ========\n137 \n138     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff\n139     >>> from sympy import pi, Dummy\n140     >>> from sympy.abc import x, y\n141     >>> coeff(3*x*pi)\n142     3*x\n143     >>> coeff(11*pi/7)\n144     11/7\n145     >>> coeff(-11*pi/7)\n146     3/7\n147     >>> coeff(4*pi)\n148     0\n149     >>> coeff(5*pi)\n150     1\n151     >>> coeff(5.0*pi)\n152     1\n153     >>> coeff(5.5*pi)\n154     3/2\n155     >>> coeff(2 + pi)\n156 \n157     >>> coeff(2*Dummy(integer=True)*pi)\n158     2\n159     >>> coeff(2*Dummy(even=True)*pi)\n160     0\n161     \"\"\"\n162     arg = sympify(arg)\n163     if arg is S.Pi:\n164         return S.One\n165     elif not arg:\n166         return S.Zero\n167     elif arg.is_Mul:\n168         cx = arg.coeff(S.Pi)\n169         if cx:\n170             c, x = cx.as_coeff_Mul()  # pi is not included as coeff\n171             if c.is_Float:\n172                 # recast exact binary fractions to Rationals\n173                 f = abs(c) % 1\n174                 if f != 0:\n175                     p = -int(round(log(f, 2).evalf()))\n176                     m = 2**p\n177                     cm = c*m\n178                     i = int(cm)\n179                     if i == cm:\n180                         c = Rational(i, m)\n181                         cx = c*x\n182                 else:\n183                     c = Rational(int(c))\n184                     cx = c*x\n185             if x.is_integer:\n186                 c2 = c % 2\n187                 if c2 == 1:\n188                     return x\n189                 elif not c2:\n190                     if x.is_even is not None:  # known parity\n191                         return S.Zero\n192                     return S(2)\n193                 else:\n194                     return c2*x\n195             return cx\n196 \n197 \n198 class sin(TrigonometricFunction):\n199     \"\"\"\n200     The sine function.\n201 \n202     Returns the sine of x (measured in radians).\n203 \n204     Notes\n205     =====\n206 \n207     This function will evaluate automatically in the\n208     case x/pi is some rational number [4]_.  For example,\n209     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.\n210 \n211     Examples\n212     ========\n213 \n214     >>> from sympy import sin, pi\n215     >>> from sympy.abc import x\n216     >>> sin(x**2).diff(x)\n217     2*x*cos(x**2)\n218     >>> sin(1).diff(x)\n219     0\n220     >>> sin(pi)\n221     0\n222     >>> sin(pi/2)\n223     1\n224     >>> sin(pi/6)\n225     1/2\n226     >>> sin(pi/12)\n227     -sqrt(2)/4 + sqrt(6)/4\n228 \n229 \n230     See Also\n231     ========\n232 \n233     csc, cos, sec, tan, cot\n234     asin, acsc, acos, asec, atan, acot, atan2\n235 \n236     References\n237     ==========\n238 \n239     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n240     .. [2] http://dlmf.nist.gov/4.14\n241     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin\n242     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html\n243     \"\"\"\n244 \n245     def period(self, symbol=None):\n246         return self._period(2*pi, symbol)\n247 \n248     def fdiff(self, argindex=1):\n249         if argindex == 1:\n250             return cos(self.args[0])\n251         else:\n252             raise ArgumentIndexError(self, argindex)\n253 \n254     @classmethod\n255     def eval(cls, arg):\n256         from sympy.calculus import AccumBounds\n257         if arg.is_Number:\n258             if arg is S.NaN:\n259                 return S.NaN\n260             elif arg is S.Zero:\n261                 return S.Zero\n262             elif arg is S.Infinity or arg is S.NegativeInfinity:\n263                 return AccumBounds(-1, 1)\n264 \n265         if isinstance(arg, AccumBounds):\n266             min, max = arg.min, arg.max\n267             d = floor(min/(2*S.Pi))\n268             if min is not S.NegativeInfinity:\n269                 min = min - d*2*S.Pi\n270             if max is not S.Infinity:\n271                 max = max - d*2*S.Pi\n272             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n273                     is not S.EmptySet and \\\n274                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,\n275                         7*S.Pi/2)) is not S.EmptySet:\n276                 return AccumBounds(-1, 1)\n277             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n278                     is not S.EmptySet:\n279                 return AccumBounds(Min(sin(min), sin(max)), 1)\n280             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \\\n281                         is not S.EmptySet:\n282                 return AccumBounds(-1, Max(sin(min), sin(max)))\n283             else:\n284                 return AccumBounds(Min(sin(min), sin(max)),\n285                                 Max(sin(min), sin(max)))\n286 \n287         if arg.could_extract_minus_sign():\n288             return -cls(-arg)\n289 \n290         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n291         if i_coeff is not None:\n292             return S.ImaginaryUnit * sinh(i_coeff)\n293 \n294         pi_coeff = _pi_coeff(arg)\n295         if pi_coeff is not None:\n296             if pi_coeff.is_integer:\n297                 return S.Zero\n298 \n299             if (2*pi_coeff).is_integer:\n300                 if pi_coeff.is_even:\n301                     return S.Zero\n302                 elif pi_coeff.is_even is False:\n303                     return S.NegativeOne**(pi_coeff - S.Half)\n304 \n305             if not pi_coeff.is_Rational:\n306                 narg = pi_coeff*S.Pi\n307                 if narg != arg:\n308                     return cls(narg)\n309                 return None\n310 \n311             # https://github.com/sympy/sympy/issues/6048\n312             # transform a sine to a cosine, to avoid redundant code\n313             if pi_coeff.is_Rational:\n314                 x = pi_coeff % 2\n315                 if x > 1:\n316                     return -cls((x % 1)*S.Pi)\n317                 if 2*x > 1:\n318                     return cls((1 - x)*S.Pi)\n319                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi\n320                 result = cos(narg)\n321                 if not isinstance(result, cos):\n322                     return result\n323                 if pi_coeff*S.Pi != arg:\n324                     return cls(pi_coeff*S.Pi)\n325                 return None\n326 \n327         if arg.is_Add:\n328             x, m = _peeloff_pi(arg)\n329             if m:\n330                 return sin(m)*cos(x) + cos(m)*sin(x)\n331 \n332         if arg.func is asin:\n333             return arg.args[0]\n334 \n335         if arg.func is atan:\n336             x = arg.args[0]\n337             return x / sqrt(1 + x**2)\n338 \n339         if arg.func is atan2:\n340             y, x = arg.args\n341             return y / sqrt(x**2 + y**2)\n342 \n343         if arg.func is acos:\n344             x = arg.args[0]\n345             return sqrt(1 - x**2)\n346 \n347         if arg.func is acot:\n348             x = arg.args[0]\n349             return 1 / (sqrt(1 + 1 / x**2) * x)\n350 \n351         if arg.func is acsc:\n352             x = arg.args[0]\n353             return 1 / x\n354 \n355         if arg.func is asec:\n356             x = arg.args[0]\n357             return sqrt(1 - 1 / x**2)\n358 \n359     @staticmethod\n360     @cacheit\n361     def taylor_term(n, x, *previous_terms):\n362         if n < 0 or n % 2 == 0:\n363             return S.Zero\n364         else:\n365             x = sympify(x)\n366 \n367             if len(previous_terms) > 2:\n368                 p = previous_terms[-2]\n369                 return -p * x**2 / (n*(n - 1))\n370             else:\n371                 return (-1)**(n//2) * x**(n)/factorial(n)\n372 \n373     def _eval_rewrite_as_exp(self, arg):\n374         I = S.ImaginaryUnit\n375         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n376             arg = arg.func(arg.args[0]).rewrite(exp)\n377         return (exp(arg*I) - exp(-arg*I)) / (2*I)\n378 \n379     def _eval_rewrite_as_Pow(self, arg):\n380         if arg.func is log:\n381             I = S.ImaginaryUnit\n382             x = arg.args[0]\n383             return I*x**-I / 2 - I*x**I /2\n384 \n385     def _eval_rewrite_as_cos(self, arg):\n386         return cos(arg - S.Pi / 2, evaluate=False)\n387 \n388     def _eval_rewrite_as_tan(self, arg):\n389         tan_half = tan(S.Half*arg)\n390         return 2*tan_half/(1 + tan_half**2)\n391 \n392     def _eval_rewrite_as_sincos(self, arg):\n393         return sin(arg)*cos(arg)/cos(arg)\n394 \n395     def _eval_rewrite_as_cot(self, arg):\n396         cot_half = cot(S.Half*arg)\n397         return 2*cot_half/(1 + cot_half**2)\n398 \n399     def _eval_rewrite_as_pow(self, arg):\n400         return self.rewrite(cos).rewrite(pow)\n401 \n402     def _eval_rewrite_as_sqrt(self, arg):\n403         return self.rewrite(cos).rewrite(sqrt)\n404 \n405     def _eval_rewrite_as_csc(self, arg):\n406         return 1/csc(arg)\n407 \n408     def _eval_rewrite_as_sec(self, arg):\n409         return 1 / sec(arg - S.Pi / 2, evaluate=False)\n410 \n411     def _eval_conjugate(self):\n412         return self.func(self.args[0].conjugate())\n413 \n414     def as_real_imag(self, deep=True, **hints):\n415         re, im = self._as_real_imag(deep=deep, **hints)\n416         return (sin(re)*cosh(im), cos(re)*sinh(im))\n417 \n418     def _eval_expand_trig(self, **hints):\n419         from sympy import expand_mul\n420         from sympy.functions.special.polynomials import chebyshevt, chebyshevu\n421         arg = self.args[0]\n422         x = None\n423         if arg.is_Add:  # TODO, implement more if deep stuff here\n424             # TODO: Do this more efficiently for more than two terms\n425             x, y = arg.as_two_terms()\n426             sx = sin(x, evaluate=False)._eval_expand_trig()\n427             sy = sin(y, evaluate=False)._eval_expand_trig()\n428             cx = cos(x, evaluate=False)._eval_expand_trig()\n429             cy = cos(y, evaluate=False)._eval_expand_trig()\n430             return sx*cy + sy*cx\n431         else:\n432             n, x = arg.as_coeff_Mul(rational=True)\n433             if n.is_Integer:  # n will be positive because of .eval\n434                 # canonicalization\n435 \n436                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html\n437                 if n.is_odd:\n438                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))\n439                 else:\n440                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -\n441                         1, sin(x)), deep=False)\n442             pi_coeff = _pi_coeff(arg)\n443             if pi_coeff is not None:\n444                 if pi_coeff.is_Rational:\n445                     return self.rewrite(sqrt)\n446         return sin(arg)\n447 \n448     def _eval_as_leading_term(self, x):\n449         from sympy import Order\n450         arg = self.args[0].as_leading_term(x)\n451 \n452         if x in arg.free_symbols and Order(1, x).contains(arg):\n453             return arg\n454         else:\n455             return self.func(arg)\n456 \n457     def _eval_is_real(self):\n458         return self.args[0].is_real\n459 \n460     def _eval_is_finite(self):\n461         arg = self.args[0]\n462         if arg.is_real:\n463             return True\n464 \n465 \n466 class cos(TrigonometricFunction):\n467     \"\"\"\n468     The cosine function.\n469 \n470     Returns the cosine of x (measured in radians).\n471 \n472     Notes\n473     =====\n474 \n475     See :func:`sin` for notes about automatic evaluation.\n476 \n477     Examples\n478     ========\n479 \n480     >>> from sympy import cos, pi\n481     >>> from sympy.abc import x\n482     >>> cos(x**2).diff(x)\n483     -2*x*sin(x**2)\n484     >>> cos(1).diff(x)\n485     0\n486     >>> cos(pi)\n487     -1\n488     >>> cos(pi/2)\n489     0\n490     >>> cos(2*pi/3)\n491     -1/2\n492     >>> cos(pi/12)\n493     sqrt(2)/4 + sqrt(6)/4\n494 \n495     See Also\n496     ========\n497 \n498     sin, csc, sec, tan, cot\n499     asin, acsc, acos, asec, atan, acot, atan2\n500 \n501     References\n502     ==========\n503 \n504     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n505     .. [2] http://dlmf.nist.gov/4.14\n506     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos\n507     \"\"\"\n508 \n509     def period(self, symbol=None):\n510         return self._period(2*pi, symbol)\n511 \n512     def fdiff(self, argindex=1):\n513         if argindex == 1:\n514             return -sin(self.args[0])\n515         else:\n516             raise ArgumentIndexError(self, argindex)\n517 \n518     @classmethod\n519     def eval(cls, arg):\n520         from sympy.functions.special.polynomials import chebyshevt\n521         from sympy.calculus.util import AccumBounds\n522         if arg.is_Number:\n523             if arg is S.NaN:\n524                 return S.NaN\n525             elif arg is S.Zero:\n526                 return S.One\n527             elif arg is S.Infinity or arg is S.NegativeInfinity:\n528                 # In this case it is better to return AccumBounds(-1, 1)\n529                 # rather than returning S.NaN, since AccumBounds(-1, 1)\n530                 # preserves the information that sin(oo) is between\n531                 # -1 and 1, where S.NaN does not do that.\n532                 return AccumBounds(-1, 1)\n533 \n534         if isinstance(arg, AccumBounds):\n535             return sin(arg + S.Pi/2)\n536 \n537         if arg.could_extract_minus_sign():\n538             return cls(-arg)\n539 \n540         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n541         if i_coeff is not None:\n542             return cosh(i_coeff)\n543 \n544         pi_coeff = _pi_coeff(arg)\n545         if pi_coeff is not None:\n546             if pi_coeff.is_integer:\n547                 return (S.NegativeOne)**pi_coeff\n548 \n549             if (2*pi_coeff).is_integer:\n550                 if pi_coeff.is_even:\n551                     return (S.NegativeOne)**(pi_coeff/2)\n552                 elif pi_coeff.is_even is False:\n553                     return S.Zero\n554 \n555             if not pi_coeff.is_Rational:\n556                 narg = pi_coeff*S.Pi\n557                 if narg != arg:\n558                     return cls(narg)\n559                 return None\n560 \n561             # cosine formula #####################\n562             # https://github.com/sympy/sympy/issues/6048\n563             # explicit calculations are preformed for\n564             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120\n565             # Some other exact values like cos(k pi/240) can be\n566             # calculated using a partial-fraction decomposition\n567             # by calling cos( X ).rewrite(sqrt)\n568             cst_table_some = {\n569                 3: S.Half,\n570                 5: (sqrt(5) + 1)/4,\n571             }\n572             if pi_coeff.is_Rational:\n573                 q = pi_coeff.q\n574                 p = pi_coeff.p % (2*q)\n575                 if p > q:\n576                     narg = (pi_coeff - 1)*S.Pi\n577                     return -cls(narg)\n578                 if 2*p > q:\n579                     narg = (1 - pi_coeff)*S.Pi\n580                     return -cls(narg)\n581 \n582                 # If nested sqrt's are worse than un-evaluation\n583                 # you can require q to be in (1, 2, 3, 4, 6, 12)\n584                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return\n585                 # expressions with 2 or fewer sqrt nestings.\n586                 table2 = {\n587                     12: (3, 4),\n588                     20: (4, 5),\n589                     30: (5, 6),\n590                     15: (6, 10),\n591                     24: (6, 8),\n592                     40: (8, 10),\n593                     60: (20, 30),\n594                     120: (40, 60)\n595                     }\n596                 if q in table2:\n597                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]\n598                     nvala, nvalb = cls(a), cls(b)\n599                     if None == nvala or None == nvalb:\n600                         return None\n601                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)\n602 \n603                 if q > 12:\n604                     return None\n605 \n606                 if q in cst_table_some:\n607                     cts = cst_table_some[pi_coeff.q]\n608                     return chebyshevt(pi_coeff.p, cts).expand()\n609 \n610                 if 0 == q % 2:\n611                     narg = (pi_coeff*2)*S.Pi\n612                     nval = cls(narg)\n613                     if None == nval:\n614                         return None\n615                     x = (2*pi_coeff + 1)/2\n616                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))\n617                     return sign_cos*sqrt( (1 + nval)/2 )\n618             return None\n619 \n620         if arg.is_Add:\n621             x, m = _peeloff_pi(arg)\n622             if m:\n623                 return cos(m)*cos(x) - sin(m)*sin(x)\n624 \n625         if arg.func is acos:\n626             return arg.args[0]\n627 \n628         if arg.func is atan:\n629             x = arg.args[0]\n630             return 1 / sqrt(1 + x**2)\n631 \n632         if arg.func is atan2:\n633             y, x = arg.args\n634             return x / sqrt(x**2 + y**2)\n635 \n636         if arg.func is asin:\n637             x = arg.args[0]\n638             return sqrt(1 - x ** 2)\n639 \n640         if arg.func is acot:\n641             x = arg.args[0]\n642             return 1 / sqrt(1 + 1 / x**2)\n643 \n644         if arg.func is acsc:\n645             x = arg.args[0]\n646             return sqrt(1 - 1 / x**2)\n647 \n648         if arg.func is asec:\n649             x = arg.args[0]\n650             return 1 / x\n651 \n652     @staticmethod\n653     @cacheit\n654     def taylor_term(n, x, *previous_terms):\n655         if n < 0 or n % 2 == 1:\n656             return S.Zero\n657         else:\n658             x = sympify(x)\n659 \n660             if len(previous_terms) > 2:\n661                 p = previous_terms[-2]\n662                 return -p * x**2 / (n*(n - 1))\n663             else:\n664                 return (-1)**(n//2)*x**(n)/factorial(n)\n665 \n666     def _eval_rewrite_as_exp(self, arg):\n667         I = S.ImaginaryUnit\n668         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n669             arg = arg.func(arg.args[0]).rewrite(exp)\n670         return (exp(arg*I) + exp(-arg*I)) / 2\n671 \n672     def _eval_rewrite_as_Pow(self, arg):\n673         if arg.func is log:\n674             I = S.ImaginaryUnit\n675             x = arg.args[0]\n676             return x**I/2 + x**-I/2\n677 \n678     def _eval_rewrite_as_sin(self, arg):\n679         return sin(arg + S.Pi / 2, evaluate=False)\n680 \n681     def _eval_rewrite_as_tan(self, arg):\n682         tan_half = tan(S.Half*arg)**2\n683         return (1 - tan_half)/(1 + tan_half)\n684 \n685     def _eval_rewrite_as_sincos(self, arg):\n686         return sin(arg)*cos(arg)/sin(arg)\n687 \n688     def _eval_rewrite_as_cot(self, arg):\n689         cot_half = cot(S.Half*arg)**2\n690         return (cot_half - 1)/(cot_half + 1)\n691 \n692     def _eval_rewrite_as_pow(self, arg):\n693         return self._eval_rewrite_as_sqrt(arg)\n694 \n695     def _eval_rewrite_as_sqrt(self, arg):\n696         from sympy.functions.special.polynomials import chebyshevt\n697 \n698         def migcdex(x):\n699             # recursive calcuation of gcd and linear combination\n700             # for a sequence of integers.\n701             # Given  (x1, x2, x3)\n702             # Returns (y1, y1, y3, g)\n703             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0\n704             # Note, that this is only one such linear combination.\n705             if len(x) == 1:\n706                 return (1, x[0])\n707             if len(x) == 2:\n708                 return igcdex(x[0], x[-1])\n709             g = migcdex(x[1:])\n710             u, v, h = igcdex(x[0], g[-1])\n711             return tuple([u] + [v*i for i in g[0:-1] ] + [h])\n712 \n713         def ipartfrac(r, factors=None):\n714             from sympy.ntheory import factorint\n715             if isinstance(r, int):\n716                 return r\n717             if not isinstance(r, Rational):\n718                 raise TypeError(\"r is not rational\")\n719             n = r.q\n720             if 2 > r.q*r.q:\n721                 return r.q\n722 \n723             if None == factors:\n724                 a = [n//x**y for x, y in factorint(r.q).items()]\n725             else:\n726                 a = [n//x for x in factors]\n727             if len(a) == 1:\n728                 return [ r ]\n729             h = migcdex(a)\n730             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]\n731             assert r == sum(ans)\n732             return ans\n733         pi_coeff = _pi_coeff(arg)\n734         if pi_coeff is None:\n735             return None\n736 \n737         if pi_coeff.is_integer:\n738             # it was unevaluated\n739             return self.func(pi_coeff*S.Pi)\n740 \n741         if not pi_coeff.is_Rational:\n742             return None\n743 \n744         def _cospi257():\n745             \"\"\" Express cos(pi/257) explicitly as a function of radicals\n746                 Based upon the equations in\n747                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals\n748                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt\n749             \"\"\"\n750             def f1(a, b):\n751                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2\n752 \n753             def f2(a, b):\n754                 return (a - sqrt(a**2 + b))/2\n755 \n756             t1, t2 = f1(-1, 256)\n757             z1, z3 = f1(t1, 64)\n758             z2, z4 = f1(t2, 64)\n759             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))\n760             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))\n761             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))\n762             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))\n763             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))\n764             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))\n765             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))\n766             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))\n767             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))\n768             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))\n769             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))\n770             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))\n771             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))\n772             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))\n773             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))\n774             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))\n775             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))\n776             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))\n777             u1 = -f2(-v1, -4*(v2 + v3))\n778             u2 = -f2(-v4, -4*(v5 + v6))\n779             w1 = -2*f2(-u1, -4*u2)\n780             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)\n781 \n782         cst_table_some = {\n783             3: S.Half,\n784             5: (sqrt(5) + 1)/4,\n785             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +\n786                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))\n787                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),\n788             257: _cospi257()\n789             # 65537 is the only other known Fermat prime and the very\n790             # large expression is intentionally omitted from SymPy; see\n791             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt\n792         }\n793 \n794         def _fermatCoords(n):\n795             # if n can be factored in terms of Fermat primes with\n796             # multiplicity of each being 1, return those primes, else\n797             # False\n798             primes = []\n799             for p_i in cst_table_some:\n800                 quotient, remainder = divmod(n, p_i)\n801                 if remainder == 0:\n802                     n = quotient\n803                     primes.append(p_i)\n804                     if n == 1:\n805                         return tuple(primes)\n806             return False\n807 \n808         if pi_coeff.q in cst_table_some:\n809             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])\n810             if pi_coeff.q < 257:\n811                 rv = rv.expand()\n812             return rv\n813 \n814         if not pi_coeff.q % 2:  # recursively remove factors of 2\n815             pico2 = pi_coeff*2\n816             nval = cos(pico2*S.Pi).rewrite(sqrt)\n817             x = (pico2 + 1)/2\n818             sign_cos = -1 if int(x) % 2 else 1\n819             return sign_cos*sqrt( (1 + nval)/2 )\n820 \n821         FC = _fermatCoords(pi_coeff.q)\n822         if FC:\n823             decomp = ipartfrac(pi_coeff, FC)\n824             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n825             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n826             return pcls.rewrite(sqrt)\n827         else:\n828             decomp = ipartfrac(pi_coeff)\n829             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n830             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n831             return pcls\n832 \n833     def _eval_rewrite_as_sec(self, arg):\n834         return 1/sec(arg)\n835 \n836     def _eval_rewrite_as_csc(self, arg):\n837         return 1 / sec(arg)._eval_rewrite_as_csc(arg)\n838 \n839     def _eval_conjugate(self):\n840         return self.func(self.args[0].conjugate())\n841 \n842     def as_real_imag(self, deep=True, **hints):\n843         re, im = self._as_real_imag(deep=deep, **hints)\n844         return (cos(re)*cosh(im), -sin(re)*sinh(im))\n845 \n846     def _eval_expand_trig(self, **hints):\n847         from sympy.functions.special.polynomials import chebyshevt\n848         arg = self.args[0]\n849         x = None\n850         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms\n851             x, y = arg.as_two_terms()\n852             sx = sin(x, evaluate=False)._eval_expand_trig()\n853             sy = sin(y, evaluate=False)._eval_expand_trig()\n854             cx = cos(x, evaluate=False)._eval_expand_trig()\n855             cy = cos(y, evaluate=False)._eval_expand_trig()\n856             return cx*cy - sx*sy\n857         else:\n858             coeff, terms = arg.as_coeff_Mul(rational=True)\n859             if coeff.is_Integer:\n860                 return chebyshevt(coeff, cos(terms))\n861             pi_coeff = _pi_coeff(arg)\n862             if pi_coeff is not None:\n863                 if pi_coeff.is_Rational:\n864                     return self.rewrite(sqrt)\n865         return cos(arg)\n866 \n867     def _eval_as_leading_term(self, x):\n868         from sympy import Order\n869         arg = self.args[0].as_leading_term(x)\n870 \n871         if x in arg.free_symbols and Order(1, x).contains(arg):\n872             return S.One\n873         else:\n874             return self.func(arg)\n875 \n876     def _eval_is_real(self):\n877         return self.args[0].is_real\n878 \n879     def _eval_is_finite(self):\n880         arg = self.args[0]\n881 \n882         if arg.is_real:\n883             return True\n884 \n885 \n886 class tan(TrigonometricFunction):\n887     \"\"\"\n888     The tangent function.\n889 \n890     Returns the tangent of x (measured in radians).\n891 \n892     Notes\n893     =====\n894 \n895     See :func:`sin` for notes about automatic evaluation.\n896 \n897     Examples\n898     ========\n899 \n900     >>> from sympy import tan, pi\n901     >>> from sympy.abc import x\n902     >>> tan(x**2).diff(x)\n903     2*x*(tan(x**2)**2 + 1)\n904     >>> tan(1).diff(x)\n905     0\n906     >>> tan(pi/8).expand()\n907     -1 + sqrt(2)\n908 \n909     See Also\n910     ========\n911 \n912     sin, csc, cos, sec, cot\n913     asin, acsc, acos, asec, atan, acot, atan2\n914 \n915     References\n916     ==========\n917 \n918     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n919     .. [2] http://dlmf.nist.gov/4.14\n920     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan\n921     \"\"\"\n922 \n923     def period(self, symbol=None):\n924         return self._period(pi, symbol)\n925 \n926     def fdiff(self, argindex=1):\n927         if argindex == 1:\n928             return S.One + self**2\n929         else:\n930             raise ArgumentIndexError(self, argindex)\n931 \n932     def inverse(self, argindex=1):\n933         \"\"\"\n934         Returns the inverse of this function.\n935         \"\"\"\n936         return atan\n937 \n938     @classmethod\n939     def eval(cls, arg):\n940         from sympy.calculus.util import AccumBounds\n941         if arg.is_Number:\n942             if arg is S.NaN:\n943                 return S.NaN\n944             elif arg is S.Zero:\n945                 return S.Zero\n946             elif arg is S.Infinity or arg is S.NegativeInfinity:\n947                 return AccumBounds(S.NegativeInfinity, S.Infinity)\n948 \n949         if isinstance(arg, AccumBounds):\n950             min, max = arg.min, arg.max\n951             d = floor(min/S.Pi)\n952             if min is not S.NegativeInfinity:\n953                 min = min - d*S.Pi\n954             if max is not S.Infinity:\n955                 max = max - d*S.Pi\n956             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):\n957                 return AccumBounds(S.NegativeInfinity, S.Infinity)\n958             else:\n959                 return AccumBounds(tan(min), tan(max))\n960 \n961         if arg.could_extract_minus_sign():\n962             return -cls(-arg)\n963 \n964         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n965         if i_coeff is not None:\n966             return S.ImaginaryUnit * tanh(i_coeff)\n967 \n968         pi_coeff = _pi_coeff(arg, 2)\n969         if pi_coeff is not None:\n970             if pi_coeff.is_integer:\n971                 return S.Zero\n972 \n973             if not pi_coeff.is_Rational:\n974                 narg = pi_coeff*S.Pi\n975                 if narg != arg:\n976                     return cls(narg)\n977                 return None\n978 \n979             if pi_coeff.is_Rational:\n980                 if not pi_coeff.q % 2:\n981                     narg = pi_coeff*S.Pi*2\n982                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n983                     if not isinstance(cresult, cos) \\\n984                             and not isinstance(sresult, cos):\n985                         if sresult == 0:\n986                             return S.ComplexInfinity\n987                         return (1 - cresult)/sresult\n988                 table2 = {\n989                     12: (3, 4),\n990                     20: (4, 5),\n991                     30: (5, 6),\n992                     15: (6, 10),\n993                     24: (6, 8),\n994                     40: (8, 10),\n995                     60: (20, 30),\n996                     120: (40, 60)\n997                     }\n998                 q = pi_coeff.q\n999                 p = pi_coeff.p % q\n1000                 if q in table2:\n1001                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])\n1002                     if None == nvala or None == nvalb:\n1003                         return None\n1004                     return (nvala - nvalb)/(1 + nvala*nvalb)\n1005                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi\n1006                 # see cos() to specify which expressions should  be\n1007                 # expanded automatically in terms of radicals\n1008                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n1009                 if not isinstance(cresult, cos) \\\n1010                         and not isinstance(sresult, cos):\n1011                     if cresult == 0:\n1012                         return S.ComplexInfinity\n1013                     return (sresult/cresult)\n1014                 if narg != arg:\n1015                     return cls(narg)\n1016 \n1017         if arg.is_Add:\n1018             x, m = _peeloff_pi(arg)\n1019             if m:\n1020                 tanm = tan(m)\n1021                 tanx = tan(x)\n1022                 if tanm is S.ComplexInfinity:\n1023                     return -cot(x)\n1024                 return (tanm + tanx)/(1 - tanm*tanx)\n1025 \n1026         if arg.func is atan:\n1027             return arg.args[0]\n1028 \n1029         if arg.func is atan2:\n1030             y, x = arg.args\n1031             return y/x\n1032 \n1033         if arg.func is asin:\n1034             x = arg.args[0]\n1035             return x / sqrt(1 - x**2)\n1036 \n1037         if arg.func is acos:\n1038             x = arg.args[0]\n1039             return sqrt(1 - x**2) / x\n1040 \n1041         if arg.func is acot:\n1042             x = arg.args[0]\n1043             return 1 / x\n1044 \n1045         if arg.func is acsc:\n1046             x = arg.args[0]\n1047             return 1 / (sqrt(1 - 1 / x**2) * x)\n1048 \n1049         if arg.func is asec:\n1050             x = arg.args[0]\n1051             return sqrt(1 - 1 / x**2) * x\n1052 \n1053     @staticmethod\n1054     @cacheit\n1055     def taylor_term(n, x, *previous_terms):\n1056         from sympy import bernoulli\n1057         if n < 0 or n % 2 == 0:\n1058             return S.Zero\n1059         else:\n1060             x = sympify(x)\n1061 \n1062             a, b = ((n - 1)//2), 2**(n + 1)\n1063 \n1064             B = bernoulli(n + 1)\n1065             F = factorial(n + 1)\n1066 \n1067             return (-1)**a * b*(b - 1) * B/F * x**n\n1068 \n1069     def _eval_nseries(self, x, n, logx):\n1070         i = self.args[0].limit(x, 0)*2/S.Pi\n1071         if i and i.is_Integer:\n1072             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)\n1073         return Function._eval_nseries(self, x, n=n, logx=logx)\n1074 \n1075     def _eval_rewrite_as_Pow(self, arg):\n1076         if arg.func is log:\n1077             I = S.ImaginaryUnit\n1078             x = arg.args[0]\n1079             return I*(x**-I - x**I)/(x**-I + x**I)\n1080 \n1081     def _eval_conjugate(self):\n1082         return self.func(self.args[0].conjugate())\n1083 \n1084     def as_real_imag(self, deep=True, **hints):\n1085         re, im = self._as_real_imag(deep=deep, **hints)\n1086         if im:\n1087             denom = cos(2*re) + cosh(2*im)\n1088             return (sin(2*re)/denom, sinh(2*im)/denom)\n1089         else:\n1090             return (self.func(re), S.Zero)\n1091 \n1092     def _eval_expand_trig(self, **hints):\n1093         from sympy import im, re\n1094         arg = self.args[0]\n1095         x = None\n1096         if arg.is_Add:\n1097             from sympy import symmetric_poly\n1098             n = len(arg.args)\n1099             TX = []\n1100             for x in arg.args:\n1101                 tx = tan(x, evaluate=False)._eval_expand_trig()\n1102                 TX.append(tx)\n1103 \n1104             Yg = numbered_symbols('Y')\n1105             Y = [ next(Yg) for i in range(n) ]\n1106 \n1107             p = [0, 0]\n1108             for i in range(n + 1):\n1109                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)\n1110             return (p[0]/p[1]).subs(list(zip(Y, TX)))\n1111 \n1112         else:\n1113             coeff, terms = arg.as_coeff_Mul(rational=True)\n1114             if coeff.is_Integer and coeff > 1:\n1115                 I = S.ImaginaryUnit\n1116                 z = Symbol('dummy', real=True)\n1117                 P = ((1 + I*z)**coeff).expand()\n1118                 return (im(P)/re(P)).subs([(z, tan(terms))])\n1119         return tan(arg)\n1120 \n1121     def _eval_rewrite_as_exp(self, arg):\n1122         I = S.ImaginaryUnit\n1123         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n1124             arg = arg.func(arg.args[0]).rewrite(exp)\n1125         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)\n1126         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)\n1127 \n1128     def _eval_rewrite_as_sin(self, x):\n1129         return 2*sin(x)**2/sin(2*x)\n1130 \n1131     def _eval_rewrite_as_cos(self, x):\n1132         return cos(x - S.Pi / 2, evaluate=False) / cos(x)\n1133 \n1134     def _eval_rewrite_as_sincos(self, arg):\n1135         return sin(arg)/cos(arg)\n1136 \n1137     def _eval_rewrite_as_cot(self, arg):\n1138         return 1/cot(arg)\n1139 \n1140     def _eval_rewrite_as_sec(self, arg):\n1141         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)\n1142         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)\n1143         return sin_in_sec_form / cos_in_sec_form\n1144 \n1145     def _eval_rewrite_as_csc(self, arg):\n1146         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)\n1147         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)\n1148         return sin_in_csc_form / cos_in_csc_form\n1149 \n1150     def _eval_rewrite_as_pow(self, arg):\n1151         y = self.rewrite(cos).rewrite(pow)\n1152         if y.has(cos):\n1153             return None\n1154         return y\n1155 \n1156     def _eval_rewrite_as_sqrt(self, arg):\n1157         y = self.rewrite(cos).rewrite(sqrt)\n1158         if y.has(cos):\n1159             return None\n1160         return y\n1161 \n1162     def _eval_as_leading_term(self, x):\n1163         from sympy import Order\n1164         arg = self.args[0].as_leading_term(x)\n1165 \n1166         if x in arg.free_symbols and Order(1, x).contains(arg):\n1167             return arg\n1168         else:\n1169             return self.func(arg)\n1170 \n1171     def _eval_is_real(self):\n1172         return self.args[0].is_real\n1173 \n1174     def _eval_is_finite(self):\n1175         arg = self.args[0]\n1176 \n1177         if arg.is_imaginary:\n1178             return True\n1179 \n1180 \n1181 class cot(TrigonometricFunction):\n1182     \"\"\"\n1183     The cotangent function.\n1184 \n1185     Returns the cotangent of x (measured in radians).\n1186 \n1187     Notes\n1188     =====\n1189 \n1190     See :func:`sin` for notes about automatic evaluation.\n1191 \n1192     Examples\n1193     ========\n1194 \n1195     >>> from sympy import cot, pi\n1196     >>> from sympy.abc import x\n1197     >>> cot(x**2).diff(x)\n1198     2*x*(-cot(x**2)**2 - 1)\n1199     >>> cot(1).diff(x)\n1200     0\n1201     >>> cot(pi/12)\n1202     sqrt(3) + 2\n1203 \n1204     See Also\n1205     ========\n1206 \n1207     sin, csc, cos, sec, tan\n1208     asin, acsc, acos, asec, atan, acot, atan2\n1209 \n1210     References\n1211     ==========\n1212 \n1213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1214     .. [2] http://dlmf.nist.gov/4.14\n1215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot\n1216     \"\"\"\n1217 \n1218     def period(self, symbol=None):\n1219         return self._period(pi, symbol)\n1220 \n1221     def fdiff(self, argindex=1):\n1222         if argindex == 1:\n1223             return S.NegativeOne - self**2\n1224         else:\n1225             raise ArgumentIndexError(self, argindex)\n1226 \n1227     def inverse(self, argindex=1):\n1228         \"\"\"\n1229         Returns the inverse of this function.\n1230         \"\"\"\n1231         return acot\n1232 \n1233     @classmethod\n1234     def eval(cls, arg):\n1235         from sympy.calculus.util import AccumBounds\n1236         if arg.is_Number:\n1237             if arg is S.NaN:\n1238                 return S.NaN\n1239             if arg is S.Zero:\n1240                 return S.ComplexInfinity\n1241 \n1242         if isinstance(arg, AccumBounds):\n1243             return -tan(arg + S.Pi/2)\n1244 \n1245         if arg.could_extract_minus_sign():\n1246             return -cls(-arg)\n1247 \n1248         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1249         if i_coeff is not None:\n1250             return -S.ImaginaryUnit * coth(i_coeff)\n1251 \n1252         pi_coeff = _pi_coeff(arg, 2)\n1253         if pi_coeff is not None:\n1254             if pi_coeff.is_integer:\n1255                 return S.ComplexInfinity\n1256 \n1257             if not pi_coeff.is_Rational:\n1258                 narg = pi_coeff*S.Pi\n1259                 if narg != arg:\n1260                     return cls(narg)\n1261                 return None\n1262 \n1263             if pi_coeff.is_Rational:\n1264                 if pi_coeff.q > 2 and not pi_coeff.q % 2:\n1265                     narg = pi_coeff*S.Pi*2\n1266                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n1267                     if not isinstance(cresult, cos) \\\n1268                             and not isinstance(sresult, cos):\n1269                         return (1 + cresult)/sresult\n1270                 table2 = {\n1271                     12: (3, 4),\n1272                     20: (4, 5),\n1273                     30: (5, 6),\n1274                     15: (6, 10),\n1275                     24: (6, 8),\n1276                     40: (8, 10),\n1277                     60: (20, 30),\n1278                     120: (40, 60)\n1279                     }\n1280                 q = pi_coeff.q\n1281                 p = pi_coeff.p % q\n1282                 if q in table2:\n1283                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])\n1284                     if None == nvala or None == nvalb:\n1285                         return None\n1286                     return (1 + nvala*nvalb)/(nvalb - nvala)\n1287                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi\n1288                 # see cos() to specify which expressions should be\n1289                 # expanded automatically in terms of radicals\n1290                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)\n1291                 if not isinstance(cresult, cos) \\\n1292                         and not isinstance(sresult, cos):\n1293                     if sresult == 0:\n1294                         return S.ComplexInfinity\n1295                     return cresult / sresult\n1296                 if narg != arg:\n1297                     return cls(narg)\n1298 \n1299         if arg.is_Add:\n1300             x, m = _peeloff_pi(arg)\n1301             if m:\n1302                 cotm = cot(m)\n1303                 if cotm == 0:\n1304                     return -tan(x)\n1305                 cotx = cot(x)\n1306                 if cotm is S.ComplexInfinity:\n1307                     return cotx\n1308                 if cotm.is_Rational:\n1309                     return (cotm*cotx - 1) / (cotm + cotx)\n1310             return None\n1311 \n1312         if arg.func is acot:\n1313             return arg.args[0]\n1314 \n1315         if arg.func is atan:\n1316             x = arg.args[0]\n1317             return 1 / x\n1318 \n1319         if arg.func is atan2:\n1320             y, x = arg.args\n1321             return x/y\n1322 \n1323         if arg.func is asin:\n1324             x = arg.args[0]\n1325             return sqrt(1 - x**2) / x\n1326 \n1327         if arg.func is acos:\n1328             x = arg.args[0]\n1329             return x / sqrt(1 - x**2)\n1330 \n1331         if arg.func is acsc:\n1332             x = arg.args[0]\n1333             return sqrt(1 - 1 / x**2) * x\n1334 \n1335         if arg.func is asec:\n1336             x = arg.args[0]\n1337             return 1 / (sqrt(1 - 1 / x**2) * x)\n1338 \n1339     @staticmethod\n1340     @cacheit\n1341     def taylor_term(n, x, *previous_terms):\n1342         from sympy import bernoulli\n1343         if n == 0:\n1344             return 1 / sympify(x)\n1345         elif n < 0 or n % 2 == 0:\n1346             return S.Zero\n1347         else:\n1348             x = sympify(x)\n1349 \n1350             B = bernoulli(n + 1)\n1351             F = factorial(n + 1)\n1352 \n1353             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n\n1354 \n1355     def _eval_nseries(self, x, n, logx):\n1356         i = self.args[0].limit(x, 0)/S.Pi\n1357         if i and i.is_Integer:\n1358             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)\n1359         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)\n1360 \n1361     def _eval_conjugate(self):\n1362         return self.func(self.args[0].conjugate())\n1363 \n1364     def as_real_imag(self, deep=True, **hints):\n1365         re, im = self._as_real_imag(deep=deep, **hints)\n1366         if im:\n1367             denom = cos(2*re) - cosh(2*im)\n1368             return (-sin(2*re)/denom, -sinh(2*im)/denom)\n1369         else:\n1370             return (self.func(re), S.Zero)\n1371 \n1372     def _eval_rewrite_as_exp(self, arg):\n1373         I = S.ImaginaryUnit\n1374         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n1375             arg = arg.func(arg.args[0]).rewrite(exp)\n1376         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)\n1377         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)\n1378 \n1379     def _eval_rewrite_as_Pow(self, arg):\n1380         if arg.func is log:\n1381             I = S.ImaginaryUnit\n1382             x = arg.args[0]\n1383             return -I*(x**-I + x**I)/(x**-I - x**I)\n1384 \n1385     def _eval_rewrite_as_sin(self, x):\n1386         return 2*sin(2*x)/sin(x)**2\n1387 \n1388     def _eval_rewrite_as_cos(self, x):\n1389         return cos(x) / cos(x - S.Pi / 2, evaluate=False)\n1390 \n1391     def _eval_rewrite_as_sincos(self, arg):\n1392         return cos(arg)/sin(arg)\n1393 \n1394     def _eval_rewrite_as_tan(self, arg):\n1395         return 1/tan(arg)\n1396 \n1397     def _eval_rewrite_as_sec(self, arg):\n1398         cos_in_sec_form = cos(arg)._eval_rewrite_as_sec(arg)\n1399         sin_in_sec_form = sin(arg)._eval_rewrite_as_sec(arg)\n1400         return cos_in_sec_form / sin_in_sec_form\n1401 \n1402     def _eval_rewrite_as_csc(self, arg):\n1403         cos_in_csc_form = cos(arg)._eval_rewrite_as_csc(arg)\n1404         sin_in_csc_form = sin(arg)._eval_rewrite_as_csc(arg)\n1405         return cos_in_csc_form / sin_in_csc_form\n1406 \n1407     def _eval_rewrite_as_pow(self, arg):\n1408         y = self.rewrite(cos).rewrite(pow)\n1409         if y.has(cos):\n1410             return None\n1411         return y\n1412 \n1413     def _eval_rewrite_as_sqrt(self, arg):\n1414         y = self.rewrite(cos).rewrite(sqrt)\n1415         if y.has(cos):\n1416             return None\n1417         return y\n1418 \n1419     def _eval_as_leading_term(self, x):\n1420         from sympy import Order\n1421         arg = self.args[0].as_leading_term(x)\n1422 \n1423         if x in arg.free_symbols and Order(1, x).contains(arg):\n1424             return 1/arg\n1425         else:\n1426             return self.func(arg)\n1427 \n1428     def _eval_is_real(self):\n1429         return self.args[0].is_real\n1430 \n1431     def _eval_expand_trig(self, **hints):\n1432         from sympy import im, re\n1433         arg = self.args[0]\n1434         x = None\n1435         if arg.is_Add:\n1436             from sympy import symmetric_poly\n1437             n = len(arg.args)\n1438             CX = []\n1439             for x in arg.args:\n1440                 cx = cot(x, evaluate=False)._eval_expand_trig()\n1441                 CX.append(cx)\n1442 \n1443             Yg = numbered_symbols('Y')\n1444             Y = [ next(Yg) for i in range(n) ]\n1445 \n1446             p = [0, 0]\n1447             for i in range(n, -1, -1):\n1448                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)\n1449             return (p[0]/p[1]).subs(list(zip(Y, CX)))\n1450         else:\n1451             coeff, terms = arg.as_coeff_Mul(rational=True)\n1452             if coeff.is_Integer and coeff > 1:\n1453                 I = S.ImaginaryUnit\n1454                 z = Symbol('dummy', real=True)\n1455                 P = ((z + I)**coeff).expand()\n1456                 return (re(P)/im(P)).subs([(z, cot(terms))])\n1457         return cot(arg)\n1458 \n1459     def _eval_is_finite(self):\n1460         arg = self.args[0]\n1461         if arg.is_imaginary:\n1462             return True\n1463 \n1464     def _eval_subs(self, old, new):\n1465         if self == old:\n1466             return new\n1467         arg = self.args[0]\n1468         argnew = arg.subs(old, new)\n1469         if arg != argnew and (argnew/S.Pi).is_integer:\n1470             return S.ComplexInfinity\n1471         return cot(argnew)\n1472 \n1473 \n1474 class ReciprocalTrigonometricFunction(TrigonometricFunction):\n1475     \"\"\"Base class for reciprocal functions of trigonometric functions. \"\"\"\n1476 \n1477     _reciprocal_of = None       # mandatory, to be defined in subclass\n1478 \n1479     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)\n1480     # TODO refactor into TrigonometricFunction common parts of\n1481     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.\n1482     _is_even = None  # optional, to be defined in subclass\n1483     _is_odd = None   # optional, to be defined in subclass\n1484 \n1485     @classmethod\n1486     def eval(cls, arg):\n1487         if arg.could_extract_minus_sign():\n1488             if cls._is_even:\n1489                 return cls(-arg)\n1490             if cls._is_odd:\n1491                 return -cls(-arg)\n1492 \n1493         pi_coeff = _pi_coeff(arg)\n1494         if (pi_coeff is not None\n1495             and not (2*pi_coeff).is_integer\n1496             and pi_coeff.is_Rational):\n1497                 q = pi_coeff.q\n1498                 p = pi_coeff.p % (2*q)\n1499                 if p > q:\n1500                     narg = (pi_coeff - 1)*S.Pi\n1501                     return -cls(narg)\n1502                 if 2*p > q:\n1503                     narg = (1 - pi_coeff)*S.Pi\n1504                     if cls._is_odd:\n1505                         return cls(narg)\n1506                     elif cls._is_even:\n1507                         return -cls(narg)\n1508 \n1509         t = cls._reciprocal_of.eval(arg)\n1510         if hasattr(arg, 'inverse') and arg.inverse() == cls:\n1511             return arg.args[0]\n1512         return 1/t if t != None else t\n1513 \n1514     def _call_reciprocal(self, method_name, *args, **kwargs):\n1515         # Calls method_name on _reciprocal_of\n1516         o = self._reciprocal_of(self.args[0])\n1517         return getattr(o, method_name)(*args, **kwargs)\n1518 \n1519     def _calculate_reciprocal(self, method_name, *args, **kwargs):\n1520         # If calling method_name on _reciprocal_of returns a value != None\n1521         # then return the reciprocal of that value\n1522         t = self._call_reciprocal(method_name, *args, **kwargs)\n1523         return 1/t if t != None else t\n1524 \n1525     def _rewrite_reciprocal(self, method_name, arg):\n1526         # Special handling for rewrite functions. If reciprocal rewrite returns\n1527         # unmodified expression, then return None\n1528         t = self._call_reciprocal(method_name, arg)\n1529         if t != None and t != self._reciprocal_of(arg):\n1530             return 1/t\n1531 \n1532     def _period(self, symbol):\n1533         f = self.args[0]\n1534         return self._reciprocal_of(f).period(symbol)\n1535 \n1536     def fdiff(self, argindex=1):\n1537         return -self._calculate_reciprocal(\"fdiff\", argindex)/self**2\n1538 \n1539     def _eval_rewrite_as_exp(self, arg):\n1540         return self._rewrite_reciprocal(\"_eval_rewrite_as_exp\", arg)\n1541 \n1542     def _eval_rewrite_as_Pow(self, arg):\n1543         return self._rewrite_reciprocal(\"_eval_rewrite_as_Pow\", arg)\n1544 \n1545     def _eval_rewrite_as_sin(self, arg):\n1546         return self._rewrite_reciprocal(\"_eval_rewrite_as_sin\", arg)\n1547 \n1548     def _eval_rewrite_as_cos(self, arg):\n1549         return self._rewrite_reciprocal(\"_eval_rewrite_as_cos\", arg)\n1550 \n1551     def _eval_rewrite_as_tan(self, arg):\n1552         return self._rewrite_reciprocal(\"_eval_rewrite_as_tan\", arg)\n1553 \n1554     def _eval_rewrite_as_pow(self, arg):\n1555         return self._rewrite_reciprocal(\"_eval_rewrite_as_pow\", arg)\n1556 \n1557     def _eval_rewrite_as_sqrt(self, arg):\n1558         return self._rewrite_reciprocal(\"_eval_rewrite_as_sqrt\", arg)\n1559 \n1560     def _eval_conjugate(self):\n1561         return self.func(self.args[0].conjugate())\n1562 \n1563     def as_real_imag(self, deep=True, **hints):\n1564         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,\n1565                                                                   **hints)\n1566 \n1567     def _eval_expand_trig(self, **hints):\n1568         return self._calculate_reciprocal(\"_eval_expand_trig\", **hints)\n1569 \n1570     def _eval_is_real(self):\n1571         return self._reciprocal_of(self.args[0])._eval_is_real()\n1572 \n1573     def _eval_as_leading_term(self, x):\n1574         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)\n1575 \n1576     def _eval_is_finite(self):\n1577         return (1/self._reciprocal_of(self.args[0])).is_finite\n1578 \n1579     def _eval_nseries(self, x, n, logx):\n1580         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)\n1581 \n1582 \n1583 class sec(ReciprocalTrigonometricFunction):\n1584     \"\"\"\n1585     The secant function.\n1586 \n1587     Returns the secant of x (measured in radians).\n1588 \n1589     Notes\n1590     =====\n1591 \n1592     See :func:`sin` for notes about automatic evaluation.\n1593 \n1594     Examples\n1595     ========\n1596 \n1597     >>> from sympy import sec\n1598     >>> from sympy.abc import x\n1599     >>> sec(x**2).diff(x)\n1600     2*x*tan(x**2)*sec(x**2)\n1601     >>> sec(1).diff(x)\n1602     0\n1603 \n1604     See Also\n1605     ========\n1606 \n1607     sin, csc, cos, tan, cot\n1608     asin, acsc, acos, asec, atan, acot, atan2\n1609 \n1610     References\n1611     ==========\n1612 \n1613     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1614     .. [2] http://dlmf.nist.gov/4.14\n1615     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec\n1616     \"\"\"\n1617 \n1618     _reciprocal_of = cos\n1619     _is_even = True\n1620 \n1621     def period(self, symbol=None):\n1622         return self._period(symbol)\n1623 \n1624     def _eval_rewrite_as_cot(self, arg):\n1625         cot_half_sq = cot(arg/2)**2\n1626         return (cot_half_sq + 1)/(cot_half_sq - 1)\n1627 \n1628     def _eval_rewrite_as_cos(self, arg):\n1629         return (1/cos(arg))\n1630 \n1631     def _eval_rewrite_as_sincos(self, arg):\n1632         return sin(arg)/(cos(arg)*sin(arg))\n1633 \n1634     def _eval_rewrite_as_sin(self, arg):\n1635         return (1 / cos(arg)._eval_rewrite_as_sin(arg))\n1636 \n1637     def _eval_rewrite_as_tan(self, arg):\n1638         return (1 / cos(arg)._eval_rewrite_as_tan(arg))\n1639 \n1640     def _eval_rewrite_as_csc(self, arg):\n1641         return csc(pi / 2 - arg, evaluate=False)\n1642 \n1643     def fdiff(self, argindex=1):\n1644         if argindex == 1:\n1645             return tan(self.args[0])*sec(self.args[0])\n1646         else:\n1647             raise ArgumentIndexError(self, argindex)\n1648 \n1649     @staticmethod\n1650     @cacheit\n1651     def taylor_term(n, x, *previous_terms):\n1652         # Reference Formula:\n1653         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/\n1654         from sympy.functions.combinatorial.numbers import euler\n1655         if n < 0 or n % 2 == 1:\n1656             return S.Zero\n1657         else:\n1658             x = sympify(x)\n1659             k = n//2\n1660             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)\n1661 \n1662 \n1663 class csc(ReciprocalTrigonometricFunction):\n1664     \"\"\"\n1665     The cosecant function.\n1666 \n1667     Returns the cosecant of x (measured in radians).\n1668 \n1669     Notes\n1670     =====\n1671 \n1672     See :func:`sin` for notes about automatic evaluation.\n1673 \n1674     Examples\n1675     ========\n1676 \n1677     >>> from sympy import csc\n1678     >>> from sympy.abc import x\n1679     >>> csc(x**2).diff(x)\n1680     -2*x*cot(x**2)*csc(x**2)\n1681     >>> csc(1).diff(x)\n1682     0\n1683 \n1684     See Also\n1685     ========\n1686 \n1687     sin, cos, sec, tan, cot\n1688     asin, acsc, acos, asec, atan, acot, atan2\n1689 \n1690     References\n1691     ==========\n1692 \n1693     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n1694     .. [2] http://dlmf.nist.gov/4.14\n1695     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc\n1696     \"\"\"\n1697 \n1698     _reciprocal_of = sin\n1699     _is_odd = True\n1700 \n1701     def period(self, symbol=None):\n1702         return self._period(symbol)\n1703 \n1704     def _eval_rewrite_as_sin(self, arg):\n1705         return (1/sin(arg))\n1706 \n1707     def _eval_rewrite_as_sincos(self, arg):\n1708         return cos(arg)/(sin(arg)*cos(arg))\n1709 \n1710     def _eval_rewrite_as_cot(self, arg):\n1711         cot_half = cot(arg/2)\n1712         return (1 + cot_half**2)/(2*cot_half)\n1713 \n1714     def _eval_rewrite_as_cos(self, arg):\n1715         return (1 / sin(arg)._eval_rewrite_as_cos(arg))\n1716 \n1717     def _eval_rewrite_as_sec(self, arg):\n1718         return sec(pi / 2 - arg, evaluate=False)\n1719 \n1720     def _eval_rewrite_as_tan(self, arg):\n1721         return (1 / sin(arg)._eval_rewrite_as_tan(arg))\n1722 \n1723     def fdiff(self, argindex=1):\n1724         if argindex == 1:\n1725             return -cot(self.args[0])*csc(self.args[0])\n1726         else:\n1727             raise ArgumentIndexError(self, argindex)\n1728 \n1729     @staticmethod\n1730     @cacheit\n1731     def taylor_term(n, x, *previous_terms):\n1732         from sympy import bernoulli\n1733         if n == 0:\n1734             return 1/sympify(x)\n1735         elif n < 0 or n % 2 == 0:\n1736             return S.Zero\n1737         else:\n1738             x = sympify(x)\n1739             k = n//2 + 1\n1740             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*\n1741                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))\n1742 \n1743 \n1744 class sinc(TrigonometricFunction):\n1745     r\"\"\"Represents unnormalized sinc function\n1746 \n1747     Examples\n1748     ========\n1749 \n1750     >>> from sympy import sinc, oo, jn, Product, Symbol\n1751     >>> from sympy.abc import x\n1752     >>> sinc(x)\n1753     sinc(x)\n1754 \n1755     * Automated Evaluation\n1756 \n1757     >>> sinc(0)\n1758     1\n1759     >>> sinc(oo)\n1760     0\n1761 \n1762     * Differentiation\n1763 \n1764     >>> sinc(x).diff()\n1765     (x*cos(x) - sin(x))/x**2\n1766 \n1767     * Series Expansion\n1768 \n1769     >>> sinc(x).series()\n1770     1 - x**2/6 + x**4/120 + O(x**6)\n1771 \n1772     * As zero'th order spherical Bessel Function\n1773 \n1774     >>> sinc(x).rewrite(jn)\n1775     jn(0, x)\n1776 \n1777     References\n1778     ==========\n1779 \n1780     .. [1] http://en.wikipedia.org/wiki/Sinc_function\n1781 \n1782     \"\"\"\n1783 \n1784     def fdiff(self, argindex=1):\n1785         x = self.args[0]\n1786         if argindex == 1:\n1787             return (x*cos(x) - sin(x)) / x**2\n1788         else:\n1789             raise ArgumentIndexError(self, argindex)\n1790 \n1791     @classmethod\n1792     def eval(cls, arg):\n1793         if arg.is_zero:\n1794             return S.One\n1795         if arg.is_Number:\n1796             if arg in [S.Infinity, -S.Infinity]:\n1797                 return S.Zero\n1798             elif arg is S.NaN:\n1799                 return S.NaN\n1800 \n1801         if arg is S.ComplexInfinity:\n1802             return S.NaN\n1803 \n1804         if arg.could_extract_minus_sign():\n1805             return cls(-arg)\n1806 \n1807         pi_coeff = _pi_coeff(arg)\n1808         if pi_coeff is not None:\n1809             if pi_coeff.is_integer:\n1810                 if fuzzy_not(arg.is_zero):\n1811                     return S.Zero\n1812             elif (2*pi_coeff).is_integer:\n1813                 return S.NegativeOne**(pi_coeff - S.Half) / arg\n1814 \n1815     def _eval_nseries(self, x, n, logx):\n1816         x = self.args[0]\n1817         return (sin(x)/x)._eval_nseries(x, n, logx)\n1818 \n1819     def _eval_rewrite_as_jn(self, arg):\n1820         from sympy.functions.special.bessel import jn\n1821         return jn(0, arg)\n1822 \n1823     def _eval_rewrite_as_sin(self, arg):\n1824         return sin(arg) / arg\n1825 \n1826 \n1827 ###############################################################################\n1828 ########################### TRIGONOMETRIC INVERSES ############################\n1829 ###############################################################################\n1830 \n1831 \n1832 class InverseTrigonometricFunction(Function):\n1833     \"\"\"Base class for inverse trigonometric functions.\"\"\"\n1834 \n1835     pass\n1836 \n1837 \n1838 class asin(InverseTrigonometricFunction):\n1839     \"\"\"\n1840     The inverse sine function.\n1841 \n1842     Returns the arcsine of x in radians.\n1843 \n1844     Notes\n1845     =====\n1846 \n1847     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,\n1848     -1 and for some instances when the result is a rational multiple\n1849     of pi (see the eval class method).\n1850 \n1851     Examples\n1852     ========\n1853 \n1854     >>> from sympy import asin, oo, pi\n1855     >>> asin(1)\n1856     pi/2\n1857     >>> asin(-1)\n1858     -pi/2\n1859 \n1860     See Also\n1861     ========\n1862 \n1863     sin, csc, cos, sec, tan, cot\n1864     acsc, acos, asec, atan, acot, atan2\n1865 \n1866     References\n1867     ==========\n1868 \n1869     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n1870     .. [2] http://dlmf.nist.gov/4.23\n1871     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin\n1872     \"\"\"\n1873 \n1874     def fdiff(self, argindex=1):\n1875         if argindex == 1:\n1876             return 1/sqrt(1 - self.args[0]**2)\n1877         else:\n1878             raise ArgumentIndexError(self, argindex)\n1879 \n1880     def _eval_is_rational(self):\n1881         s = self.func(*self.args)\n1882         if s.func == self.func:\n1883             if s.args[0].is_rational:\n1884                 return False\n1885         else:\n1886             return s.is_rational\n1887 \n1888     def _eval_is_positive(self):\n1889         if self.args[0].is_positive:\n1890             return (self.args[0] - 1).is_negative\n1891         if self.args[0].is_negative:\n1892             return not (self.args[0] + 1).is_positive\n1893 \n1894     @classmethod\n1895     def eval(cls, arg):\n1896         if arg.is_Number:\n1897             if arg is S.NaN:\n1898                 return S.NaN\n1899             elif arg is S.Infinity:\n1900                 return S.NegativeInfinity * S.ImaginaryUnit\n1901             elif arg is S.NegativeInfinity:\n1902                 return S.Infinity * S.ImaginaryUnit\n1903             elif arg is S.Zero:\n1904                 return S.Zero\n1905             elif arg is S.One:\n1906                 return S.Pi / 2\n1907             elif arg is S.NegativeOne:\n1908                 return -S.Pi / 2\n1909 \n1910         if arg.could_extract_minus_sign():\n1911             return -cls(-arg)\n1912 \n1913         if arg.is_number:\n1914             cst_table = {\n1915                 sqrt(3)/2: 3,\n1916                 -sqrt(3)/2: -3,\n1917                 sqrt(2)/2: 4,\n1918                 -sqrt(2)/2: -4,\n1919                 1/sqrt(2): 4,\n1920                 -1/sqrt(2): -4,\n1921                 sqrt((5 - sqrt(5))/8): 5,\n1922                 -sqrt((5 - sqrt(5))/8): -5,\n1923                 S.Half: 6,\n1924                 -S.Half: -6,\n1925                 sqrt(2 - sqrt(2))/2: 8,\n1926                 -sqrt(2 - sqrt(2))/2: -8,\n1927                 (sqrt(5) - 1)/4: 10,\n1928                 (1 - sqrt(5))/4: -10,\n1929                 (sqrt(3) - 1)/sqrt(2**3): 12,\n1930                 (1 - sqrt(3))/sqrt(2**3): -12,\n1931                 (sqrt(5) + 1)/4: S(10)/3,\n1932                 -(sqrt(5) + 1)/4: -S(10)/3\n1933             }\n1934 \n1935             if arg in cst_table:\n1936                 return S.Pi / cst_table[arg]\n1937 \n1938         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1939         if i_coeff is not None:\n1940             return S.ImaginaryUnit * asinh(i_coeff)\n1941 \n1942     @staticmethod\n1943     @cacheit\n1944     def taylor_term(n, x, *previous_terms):\n1945         if n < 0 or n % 2 == 0:\n1946             return S.Zero\n1947         else:\n1948             x = sympify(x)\n1949             if len(previous_terms) >= 2 and n > 2:\n1950                 p = previous_terms[-2]\n1951                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n1952             else:\n1953                 k = (n - 1) // 2\n1954                 R = RisingFactorial(S.Half, k)\n1955                 F = factorial(k)\n1956                 return R / F * x**n / n\n1957 \n1958     def _eval_as_leading_term(self, x):\n1959         from sympy import Order\n1960         arg = self.args[0].as_leading_term(x)\n1961 \n1962         if x in arg.free_symbols and Order(1, x).contains(arg):\n1963             return arg\n1964         else:\n1965             return self.func(arg)\n1966 \n1967     def _eval_rewrite_as_acos(self, x):\n1968         return S.Pi/2 - acos(x)\n1969 \n1970     def _eval_rewrite_as_atan(self, x):\n1971         return 2*atan(x/(1 + sqrt(1 - x**2)))\n1972 \n1973     def _eval_rewrite_as_log(self, x):\n1974         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))\n1975 \n1976     def _eval_rewrite_as_acot(self, arg):\n1977         return 2*acot((1 + sqrt(1 - arg**2))/arg)\n1978 \n1979     def _eval_rewrite_as_asec(self, arg):\n1980         return S.Pi/2 - asec(1/arg)\n1981 \n1982     def _eval_rewrite_as_acsc(self, arg):\n1983         return acsc(1/arg)\n1984 \n1985     def _eval_is_real(self):\n1986         x = self.args[0]\n1987         return x.is_real and (1 - abs(x)).is_nonnegative\n1988 \n1989     def inverse(self, argindex=1):\n1990         \"\"\"\n1991         Returns the inverse of this function.\n1992         \"\"\"\n1993         return sin\n1994 \n1995 \n1996 class acos(InverseTrigonometricFunction):\n1997     \"\"\"\n1998     The inverse cosine function.\n1999 \n2000     Returns the arc cosine of x (measured in radians).\n2001 \n2002     Notes\n2003     =====\n2004 \n2005     ``acos(x)`` will evaluate automatically in the cases\n2006     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.\n2007 \n2008     ``acos(zoo)`` evaluates to ``zoo``\n2009     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)\n2010 \n2011     Examples\n2012     ========\n2013 \n2014     >>> from sympy import acos, oo, pi\n2015     >>> acos(1)\n2016     0\n2017     >>> acos(0)\n2018     pi/2\n2019     >>> acos(oo)\n2020     oo*I\n2021 \n2022     See Also\n2023     ========\n2024 \n2025     sin, csc, cos, sec, tan, cot\n2026     asin, acsc, asec, atan, acot, atan2\n2027 \n2028     References\n2029     ==========\n2030 \n2031     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2032     .. [2] http://dlmf.nist.gov/4.23\n2033     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos\n2034     \"\"\"\n2035 \n2036     def fdiff(self, argindex=1):\n2037         if argindex == 1:\n2038             return -1/sqrt(1 - self.args[0]**2)\n2039         else:\n2040             raise ArgumentIndexError(self, argindex)\n2041 \n2042     def _eval_is_rational(self):\n2043         s = self.func(*self.args)\n2044         if s.func == self.func:\n2045             if s.args[0].is_rational:\n2046                 return False\n2047         else:\n2048             return s.is_rational\n2049 \n2050     def _eval_is_positive(self):\n2051         x = self.args[0]\n2052         return (1 - abs(x)).is_nonnegative\n2053 \n2054     @classmethod\n2055     def eval(cls, arg):\n2056         if arg.is_Number:\n2057             if arg is S.NaN:\n2058                 return S.NaN\n2059             elif arg is S.Infinity:\n2060                 return S.Infinity * S.ImaginaryUnit\n2061             elif arg is S.NegativeInfinity:\n2062                 return S.NegativeInfinity * S.ImaginaryUnit\n2063             elif arg is S.Zero:\n2064                 return S.Pi / 2\n2065             elif arg is S.One:\n2066                 return S.Zero\n2067             elif arg is S.NegativeOne:\n2068                 return S.Pi\n2069 \n2070         if arg is S.ComplexInfinity:\n2071             return S.ComplexInfinity\n2072 \n2073         if arg.is_number:\n2074             cst_table = {\n2075                 S.Half: S.Pi/3,\n2076                 -S.Half: 2*S.Pi/3,\n2077                 sqrt(2)/2: S.Pi/4,\n2078                 -sqrt(2)/2: 3*S.Pi/4,\n2079                 1/sqrt(2): S.Pi/4,\n2080                 -1/sqrt(2): 3*S.Pi/4,\n2081                 sqrt(3)/2: S.Pi/6,\n2082                 -sqrt(3)/2: 5*S.Pi/6,\n2083             }\n2084 \n2085             if arg in cst_table:\n2086                 return cst_table[arg]\n2087 \n2088     @staticmethod\n2089     @cacheit\n2090     def taylor_term(n, x, *previous_terms):\n2091         if n == 0:\n2092             return S.Pi / 2\n2093         elif n < 0 or n % 2 == 0:\n2094             return S.Zero\n2095         else:\n2096             x = sympify(x)\n2097             if len(previous_terms) >= 2 and n > 2:\n2098                 p = previous_terms[-2]\n2099                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n2100             else:\n2101                 k = (n - 1) // 2\n2102                 R = RisingFactorial(S.Half, k)\n2103                 F = factorial(k)\n2104                 return -R / F * x**n / n\n2105 \n2106     def _eval_as_leading_term(self, x):\n2107         from sympy import Order\n2108         arg = self.args[0].as_leading_term(x)\n2109 \n2110         if x in arg.free_symbols and Order(1, x).contains(arg):\n2111             return arg\n2112         else:\n2113             return self.func(arg)\n2114 \n2115     def _eval_is_real(self):\n2116         x = self.args[0]\n2117         return x.is_real and (1 - abs(x)).is_nonnegative\n2118 \n2119     def _eval_rewrite_as_log(self, x):\n2120         return S.Pi/2 + S.ImaginaryUnit * \\\n2121             log(S.ImaginaryUnit * x + sqrt(1 - x**2))\n2122 \n2123     def _eval_rewrite_as_asin(self, x):\n2124         return S.Pi/2 - asin(x)\n2125 \n2126     def _eval_rewrite_as_atan(self, x):\n2127         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))\n2128 \n2129     def inverse(self, argindex=1):\n2130         \"\"\"\n2131         Returns the inverse of this function.\n2132         \"\"\"\n2133         return cos\n2134 \n2135     def _eval_rewrite_as_acot(self, arg):\n2136         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)\n2137 \n2138     def _eval_rewrite_as_asec(self, arg):\n2139         return asec(1/arg)\n2140 \n2141     def _eval_rewrite_as_acsc(self, arg):\n2142         return S.Pi/2 - acsc(1/arg)\n2143 \n2144     def _eval_conjugate(self):\n2145         z = self.args[0]\n2146         r = self.func(self.args[0].conjugate())\n2147         if z.is_real is False:\n2148             return r\n2149         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:\n2150             return r\n2151 \n2152 \n2153 class atan(InverseTrigonometricFunction):\n2154     \"\"\"\n2155     The inverse tangent function.\n2156 \n2157     Returns the arc tangent of x (measured in radians).\n2158 \n2159     Notes\n2160     =====\n2161 \n2162     atan(x) will evaluate automatically in the cases\n2163     oo, -oo, 0, 1, -1.\n2164 \n2165     Examples\n2166     ========\n2167 \n2168     >>> from sympy import atan, oo, pi\n2169     >>> atan(0)\n2170     0\n2171     >>> atan(1)\n2172     pi/4\n2173     >>> atan(oo)\n2174     pi/2\n2175 \n2176     See Also\n2177     ========\n2178 \n2179     sin, csc, cos, sec, tan, cot\n2180     asin, acsc, acos, asec, acot, atan2\n2181 \n2182     References\n2183     ==========\n2184 \n2185     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2186     .. [2] http://dlmf.nist.gov/4.23\n2187     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan\n2188     \"\"\"\n2189 \n2190     def fdiff(self, argindex=1):\n2191         if argindex == 1:\n2192             return 1/(1 + self.args[0]**2)\n2193         else:\n2194             raise ArgumentIndexError(self, argindex)\n2195 \n2196     def _eval_is_rational(self):\n2197         s = self.func(*self.args)\n2198         if s.func == self.func:\n2199             if s.args[0].is_rational:\n2200                 return False\n2201         else:\n2202             return s.is_rational\n2203 \n2204     def _eval_is_positive(self):\n2205         return self.args[0].is_positive\n2206 \n2207     def _eval_is_nonnegative(self):\n2208         return self.args[0].is_nonnegative\n2209 \n2210     @classmethod\n2211     def eval(cls, arg):\n2212         if arg.is_Number:\n2213             if arg is S.NaN:\n2214                 return S.NaN\n2215             elif arg is S.Infinity:\n2216                 return S.Pi / 2\n2217             elif arg is S.NegativeInfinity:\n2218                 return -S.Pi / 2\n2219             elif arg is S.Zero:\n2220                 return S.Zero\n2221             elif arg is S.One:\n2222                 return S.Pi / 4\n2223             elif arg is S.NegativeOne:\n2224                 return -S.Pi / 4\n2225         if arg.could_extract_minus_sign():\n2226             return -cls(-arg)\n2227 \n2228         if arg.is_number:\n2229             cst_table = {\n2230                 sqrt(3)/3: 6,\n2231                 -sqrt(3)/3: -6,\n2232                 1/sqrt(3): 6,\n2233                 -1/sqrt(3): -6,\n2234                 sqrt(3): 3,\n2235                 -sqrt(3): -3,\n2236                 (1 + sqrt(2)): S(8)/3,\n2237                 -(1 + sqrt(2)): S(8)/3,\n2238                 (sqrt(2) - 1): 8,\n2239                 (1 - sqrt(2)): -8,\n2240                 sqrt((5 + 2*sqrt(5))): S(5)/2,\n2241                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,\n2242                 (2 - sqrt(3)): 12,\n2243                 -(2 - sqrt(3)): -12\n2244             }\n2245 \n2246             if arg in cst_table:\n2247                 return S.Pi / cst_table[arg]\n2248 \n2249         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n2250         if i_coeff is not None:\n2251             return S.ImaginaryUnit * atanh(i_coeff)\n2252 \n2253     @staticmethod\n2254     @cacheit\n2255     def taylor_term(n, x, *previous_terms):\n2256         if n < 0 or n % 2 == 0:\n2257             return S.Zero\n2258         else:\n2259             x = sympify(x)\n2260             return (-1)**((n - 1)//2) * x**n / n\n2261 \n2262     def _eval_as_leading_term(self, x):\n2263         from sympy import Order\n2264         arg = self.args[0].as_leading_term(x)\n2265 \n2266         if x in arg.free_symbols and Order(1, x).contains(arg):\n2267             return arg\n2268         else:\n2269             return self.func(arg)\n2270 \n2271     def _eval_is_real(self):\n2272         return self.args[0].is_real\n2273 \n2274     def _eval_rewrite_as_log(self, x):\n2275         return S.ImaginaryUnit/2 * (log(S(1) - S.ImaginaryUnit * x)\n2276             - log(S(1) + S.ImaginaryUnit * x))\n2277 \n2278     def _eval_aseries(self, n, args0, x, logx):\n2279         if args0[0] == S.Infinity:\n2280             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)\n2281         elif args0[0] == S.NegativeInfinity:\n2282             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)\n2283         else:\n2284             return super(atan, self)._eval_aseries(n, args0, x, logx)\n2285 \n2286     def inverse(self, argindex=1):\n2287         \"\"\"\n2288         Returns the inverse of this function.\n2289         \"\"\"\n2290         return tan\n2291 \n2292     def _eval_rewrite_as_asin(self, arg):\n2293         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))\n2294 \n2295     def _eval_rewrite_as_acos(self, arg):\n2296         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))\n2297 \n2298     def _eval_rewrite_as_acot(self, arg):\n2299         return acot(1/arg)\n2300 \n2301     def _eval_rewrite_as_asec(self, arg):\n2302         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))\n2303 \n2304     def _eval_rewrite_as_acsc(self, arg):\n2305         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))\n2306 \n2307 \n2308 class acot(InverseTrigonometricFunction):\n2309     \"\"\"\n2310     The inverse cotangent function.\n2311 \n2312     Returns the arc cotangent of x (measured in radians).\n2313 \n2314     See Also\n2315     ========\n2316 \n2317     sin, csc, cos, sec, tan, cot\n2318     asin, acsc, acos, asec, atan, atan2\n2319 \n2320     References\n2321     ==========\n2322 \n2323     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2324     .. [2] http://dlmf.nist.gov/4.23\n2325     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot\n2326     \"\"\"\n2327 \n2328     def fdiff(self, argindex=1):\n2329         if argindex == 1:\n2330             return -1 / (1 + self.args[0]**2)\n2331         else:\n2332             raise ArgumentIndexError(self, argindex)\n2333 \n2334     def _eval_is_rational(self):\n2335         s = self.func(*self.args)\n2336         if s.func == self.func:\n2337             if s.args[0].is_rational:\n2338                 return False\n2339         else:\n2340             return s.is_rational\n2341 \n2342     def _eval_is_positive(self):\n2343         return self.args[0].is_real\n2344 \n2345     @classmethod\n2346     def eval(cls, arg):\n2347         if arg.is_Number:\n2348             if arg is S.NaN:\n2349                 return S.NaN\n2350             elif arg is S.Infinity:\n2351                 return S.Zero\n2352             elif arg is S.NegativeInfinity:\n2353                 return S.Zero\n2354             elif arg is S.Zero:\n2355                 return S.Pi/ 2\n2356             elif arg is S.One:\n2357                 return S.Pi / 4\n2358             elif arg is S.NegativeOne:\n2359                 return -S.Pi / 4\n2360 \n2361         if arg.could_extract_minus_sign():\n2362             return -cls(-arg)\n2363 \n2364         if arg.is_number:\n2365             cst_table = {\n2366                 sqrt(3)/3: 3,\n2367                 -sqrt(3)/3: -3,\n2368                 1/sqrt(3): 3,\n2369                 -1/sqrt(3): -3,\n2370                 sqrt(3): 6,\n2371                 -sqrt(3): -6,\n2372                 (1 + sqrt(2)): 8,\n2373                 -(1 + sqrt(2)): -8,\n2374                 (1 - sqrt(2)): -S(8)/3,\n2375                 (sqrt(2) - 1): S(8)/3,\n2376                 sqrt(5 + 2*sqrt(5)): 10,\n2377                 -sqrt(5 + 2*sqrt(5)): -10,\n2378                 (2 + sqrt(3)): 12,\n2379                 -(2 + sqrt(3)): -12,\n2380                 (2 - sqrt(3)): S(12)/5,\n2381                 -(2 - sqrt(3)): -S(12)/5,\n2382             }\n2383 \n2384             if arg in cst_table:\n2385                 return S.Pi / cst_table[arg]\n2386 \n2387         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n2388         if i_coeff is not None:\n2389             return -S.ImaginaryUnit * acoth(i_coeff)\n2390 \n2391     @staticmethod\n2392     @cacheit\n2393     def taylor_term(n, x, *previous_terms):\n2394         if n == 0:\n2395             return S.Pi / 2  # FIX THIS\n2396         elif n < 0 or n % 2 == 0:\n2397             return S.Zero\n2398         else:\n2399             x = sympify(x)\n2400             return (-1)**((n + 1)//2) * x**n / n\n2401 \n2402     def _eval_as_leading_term(self, x):\n2403         from sympy import Order\n2404         arg = self.args[0].as_leading_term(x)\n2405 \n2406         if x in arg.free_symbols and Order(1, x).contains(arg):\n2407             return arg\n2408         else:\n2409             return self.func(arg)\n2410 \n2411     def _eval_is_real(self):\n2412         return self.args[0].is_real\n2413 \n2414     def _eval_aseries(self, n, args0, x, logx):\n2415         if args0[0] == S.Infinity:\n2416             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)\n2417         elif args0[0] == S.NegativeInfinity:\n2418             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)\n2419         else:\n2420             return super(atan, self)._eval_aseries(n, args0, x, logx)\n2421 \n2422     def _eval_rewrite_as_log(self, x):\n2423         return S.ImaginaryUnit/2 * (log(1 - S.ImaginaryUnit/x)\n2424             - log(1 + S.ImaginaryUnit/x))\n2425 \n2426     def inverse(self, argindex=1):\n2427         \"\"\"\n2428         Returns the inverse of this function.\n2429         \"\"\"\n2430         return cot\n2431 \n2432     def _eval_rewrite_as_asin(self, arg):\n2433         return (arg*sqrt(1/arg**2)*\n2434                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))\n2435 \n2436     def _eval_rewrite_as_acos(self, arg):\n2437         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))\n2438 \n2439     def _eval_rewrite_as_atan(self, arg):\n2440         return atan(1/arg)\n2441 \n2442     def _eval_rewrite_as_asec(self, arg):\n2443         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))\n2444 \n2445     def _eval_rewrite_as_acsc(self, arg):\n2446         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))\n2447 \n2448 \n2449 class asec(InverseTrigonometricFunction):\n2450     r\"\"\"\n2451     The inverse secant function.\n2452 \n2453     Returns the arc secant of x (measured in radians).\n2454 \n2455     Notes\n2456     =====\n2457 \n2458     ``asec(x)`` will evaluate automatically in the cases\n2459     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.\n2460 \n2461     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,\n2462     it can be defined [4]_ as\n2463 \n2464     .. math::\n2465         sec^{-1}(z) = -i*(log(\\sqrt{1 - z^2} + 1) / z)\n2466 \n2467     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For\n2468     negative branch cut, the limit\n2469 \n2470     .. math::\n2471         \\lim_{z \\to 0}-i*(log(-\\sqrt{1 - z^2} + 1) / z)\n2472 \n2473     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to\n2474     ``zoo``.\n2475 \n2476     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for\n2477     ``acos(x)``.\n2478 \n2479     Examples\n2480     ========\n2481 \n2482     >>> from sympy import asec, oo, pi\n2483     >>> asec(1)\n2484     0\n2485     >>> asec(-1)\n2486     pi\n2487 \n2488     See Also\n2489     ========\n2490 \n2491     sin, csc, cos, sec, tan, cot\n2492     asin, acsc, acos, atan, acot, atan2\n2493 \n2494     References\n2495     ==========\n2496 \n2497     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2498     .. [2] http://dlmf.nist.gov/4.23\n2499     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec\n2500     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html\n2501     \"\"\"\n2502 \n2503     @classmethod\n2504     def eval(cls, arg):\n2505         if arg.is_zero:\n2506             return S.ComplexInfinity\n2507         if arg.is_Number:\n2508             if arg is S.NaN:\n2509                 return S.NaN\n2510             elif arg is S.One:\n2511                 return S.Zero\n2512             elif arg is S.NegativeOne:\n2513                 return S.Pi\n2514         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:\n2515             return S.Pi/2\n2516 \n2517     def fdiff(self, argindex=1):\n2518         if argindex == 1:\n2519             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))\n2520         else:\n2521             raise ArgumentIndexError(self, argindex)\n2522 \n2523     def inverse(self, argindex=1):\n2524         \"\"\"\n2525         Returns the inverse of this function.\n2526         \"\"\"\n2527         return sec\n2528 \n2529     def _eval_as_leading_term(self, x):\n2530         from sympy import Order\n2531         arg = self.args[0].as_leading_term(x)\n2532         if Order(1,x).contains(arg):\n2533             return log(arg)\n2534         else:\n2535             return self.func(arg)\n2536 \n2537     def _eval_is_real(self):\n2538         x = self.args[0]\n2539         if x.is_real is False:\n2540             return False\n2541         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative\n2542 \n2543     def _eval_rewrite_as_log(self, arg):\n2544         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))\n2545 \n2546     def _eval_rewrite_as_asin(self, arg):\n2547         return S.Pi/2 - asin(1/arg)\n2548 \n2549     def _eval_rewrite_as_acos(self, arg):\n2550         return acos(1/arg)\n2551 \n2552     def _eval_rewrite_as_atan(self, arg):\n2553         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))\n2554 \n2555     def _eval_rewrite_as_acot(self, arg):\n2556         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))\n2557 \n2558     def _eval_rewrite_as_acsc(self, arg):\n2559         return S.Pi/2 - acsc(arg)\n2560 \n2561 \n2562 class acsc(InverseTrigonometricFunction):\n2563     \"\"\"\n2564     The inverse cosecant function.\n2565 \n2566     Returns the arc cosecant of x (measured in radians).\n2567 \n2568     Notes\n2569     =====\n2570 \n2571     acsc(x) will evaluate automatically in the cases\n2572     oo, -oo, 0, 1, -1.\n2573 \n2574     Examples\n2575     ========\n2576 \n2577     >>> from sympy import acsc, oo, pi\n2578     >>> acsc(1)\n2579     pi/2\n2580     >>> acsc(-1)\n2581     -pi/2\n2582 \n2583     See Also\n2584     ========\n2585 \n2586     sin, csc, cos, sec, tan, cot\n2587     asin, acos, asec, atan, acot, atan2\n2588 \n2589     References\n2590     ==========\n2591 \n2592     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2593     .. [2] http://dlmf.nist.gov/4.23\n2594     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc\n2595     \"\"\"\n2596 \n2597     @classmethod\n2598     def eval(cls, arg):\n2599         if arg.is_Number:\n2600             if arg is S.NaN:\n2601                 return S.NaN\n2602             elif arg is S.One:\n2603                 return S.Pi/2\n2604             elif arg is S.NegativeOne:\n2605                 return -S.Pi/2\n2606         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:\n2607             return S.Zero\n2608 \n2609     def fdiff(self, argindex=1):\n2610         if argindex == 1:\n2611             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))\n2612         else:\n2613             raise ArgumentIndexError(self, argindex)\n2614 \n2615     def inverse(self, argindex=1):\n2616         \"\"\"\n2617         Returns the inverse of this function.\n2618         \"\"\"\n2619         return csc\n2620 \n2621     def _eval_as_leading_term(self, x):\n2622         from sympy import Order\n2623         arg = self.args[0].as_leading_term(x)\n2624         if Order(1,x).contains(arg):\n2625             return log(arg)\n2626         else:\n2627             return self.func(arg)\n2628 \n2629     def _eval_rewrite_as_log(self, arg):\n2630         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))\n2631 \n2632     def _eval_rewrite_as_asin(self, arg):\n2633         return asin(1/arg)\n2634 \n2635     def _eval_rewrite_as_acos(self, arg):\n2636         return S.Pi/2 - acos(1/arg)\n2637 \n2638     def _eval_rewrite_as_atan(self, arg):\n2639         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))\n2640 \n2641     def _eval_rewrite_as_acot(self, arg):\n2642         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))\n2643 \n2644     def _eval_rewrite_as_asec(self, arg):\n2645         return S.Pi/2 - asec(arg)\n2646 \n2647 \n2648 class atan2(InverseTrigonometricFunction):\n2649     r\"\"\"\n2650     The function ``atan2(y, x)`` computes `\\operatorname{atan}(y/x)` taking\n2651     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to\n2652     determine the appropriate quadrant of `\\operatorname{atan}(y/x)`.\n2653     The range is `(-\\pi, \\pi]`. The complete definition reads as follows:\n2654 \n2655     .. math::\n2656 \n2657         \\operatorname{atan2}(y, x) =\n2658         \\begin{cases}\n2659           \\arctan\\left(\\frac y x\\right) & \\qquad x > 0 \\\\\n2660           \\arctan\\left(\\frac y x\\right) + \\pi& \\qquad y \\ge 0 , x < 0 \\\\\n2661           \\arctan\\left(\\frac y x\\right) - \\pi& \\qquad y < 0 , x < 0 \\\\\n2662           +\\frac{\\pi}{2} & \\qquad y > 0 , x = 0 \\\\\n2663           -\\frac{\\pi}{2} & \\qquad y < 0 , x = 0 \\\\\n2664           \\text{undefined} & \\qquad y = 0, x = 0\n2665         \\end{cases}\n2666 \n2667     Attention: Note the role reversal of both arguments. The `y`-coordinate\n2668     is the first argument and the `x`-coordinate the second.\n2669 \n2670     Examples\n2671     ========\n2672 \n2673     Going counter-clock wise around the origin we find the\n2674     following angles:\n2675 \n2676     >>> from sympy import atan2\n2677     >>> atan2(0, 1)\n2678     0\n2679     >>> atan2(1, 1)\n2680     pi/4\n2681     >>> atan2(1, 0)\n2682     pi/2\n2683     >>> atan2(1, -1)\n2684     3*pi/4\n2685     >>> atan2(0, -1)\n2686     pi\n2687     >>> atan2(-1, -1)\n2688     -3*pi/4\n2689     >>> atan2(-1, 0)\n2690     -pi/2\n2691     >>> atan2(-1, 1)\n2692     -pi/4\n2693 \n2694     which are all correct. Compare this to the results of the ordinary\n2695     `\\operatorname{atan}` function for the point `(x, y) = (-1, 1)`\n2696 \n2697     >>> from sympy import atan, S\n2698     >>> atan(S(1) / -1)\n2699     -pi/4\n2700     >>> atan2(1, -1)\n2701     3*pi/4\n2702 \n2703     where only the `\\operatorname{atan2}` function reurns what we expect.\n2704     We can differentiate the function with respect to both arguments:\n2705 \n2706     >>> from sympy import diff\n2707     >>> from sympy.abc import x, y\n2708     >>> diff(atan2(y, x), x)\n2709     -y/(x**2 + y**2)\n2710 \n2711     >>> diff(atan2(y, x), y)\n2712     x/(x**2 + y**2)\n2713 \n2714     We can express the `\\operatorname{atan2}` function in terms of\n2715     complex logarithms:\n2716 \n2717     >>> from sympy import log\n2718     >>> atan2(y, x).rewrite(log)\n2719     -I*log((x + I*y)/sqrt(x**2 + y**2))\n2720 \n2721     and in terms of `\\operatorname(atan)`:\n2722 \n2723     >>> from sympy import atan\n2724     >>> atan2(y, x).rewrite(atan)\n2725     2*atan(y/(x + sqrt(x**2 + y**2)))\n2726 \n2727     but note that this form is undefined on the negative real axis.\n2728 \n2729     See Also\n2730     ========\n2731 \n2732     sin, csc, cos, sec, tan, cot\n2733     asin, acsc, acos, asec, atan, acot\n2734 \n2735     References\n2736     ==========\n2737 \n2738     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions\n2739     .. [2] http://en.wikipedia.org/wiki/Atan2\n2740     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2\n2741     \"\"\"\n2742 \n2743     @classmethod\n2744     def eval(cls, y, x):\n2745         from sympy import Heaviside, im, re\n2746         if x is S.NegativeInfinity:\n2747             if y.is_zero:\n2748                 # Special case y = 0 because we define Heaviside(0) = 1/2\n2749                 return S.Pi\n2750             return 2*S.Pi*(Heaviside(re(y))) - S.Pi\n2751         elif x is S.Infinity:\n2752             return S.Zero\n2753         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:\n2754             x = im(x)\n2755             y = im(y)\n2756 \n2757         if x.is_real and y.is_real:\n2758             if x.is_positive:\n2759                 return atan(y / x)\n2760             elif x.is_negative:\n2761                 if y.is_negative:\n2762                     return atan(y / x) - S.Pi\n2763                 elif y.is_nonnegative:\n2764                     return atan(y / x) + S.Pi\n2765             elif x.is_zero:\n2766                 if y.is_positive:\n2767                     return S.Pi/2\n2768                 elif y.is_negative:\n2769                     return -S.Pi/2\n2770                 elif y.is_zero:\n2771                     return S.NaN\n2772         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):\n2773             return S.Pi * (S.One - Heaviside(x))\n2774         if x.is_number and y.is_number:\n2775             return -S.ImaginaryUnit*log(\n2776                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))\n2777 \n2778     def _eval_rewrite_as_log(self, y, x):\n2779         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))\n2780 \n2781     def _eval_rewrite_as_atan(self, y, x):\n2782         return 2*atan(y / (sqrt(x**2 + y**2) + x))\n2783 \n2784     def _eval_rewrite_as_arg(self, y, x):\n2785         from sympy import arg\n2786         if x.is_real and y.is_real:\n2787             return arg(x + y*S.ImaginaryUnit)\n2788         I = S.ImaginaryUnit\n2789         n = x + I*y\n2790         d = x**2 + y**2\n2791         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))\n2792 \n2793     def _eval_is_real(self):\n2794         return self.args[0].is_real and self.args[1].is_real\n2795 \n2796     def _eval_conjugate(self):\n2797         return self.func(self.args[0].conjugate(), self.args[1].conjugate())\n2798 \n2799     def fdiff(self, argindex):\n2800         y, x = self.args\n2801         if argindex == 1:\n2802             # Diff wrt y\n2803             return x/(x**2 + y**2)\n2804         elif argindex == 2:\n2805             # Diff wrt x\n2806             return -y/(x**2 + y**2)\n2807         else:\n2808             raise ArgumentIndexError(self, argindex)\n2809 \n2810     def _eval_evalf(self, prec):\n2811         y, x = self.args\n2812         if x.is_real and y.is_real:\n2813             super(atan2, self)._eval_evalf(prec)\n",
        "intended_behavior": "The evaluation and simplification logic should correctly handle complex arguments, avoiding incorrect transformations or assumptions about trigonometric and hyperbolic functions."
    },
    {
        "rel_file_path": "sympy/functions/elementary/hyperbolic.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/functions/elementary/hyperbolic.py",
        "start": 1,
        "end": 1341,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core import S, sympify, cacheit\n4 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg\n5 \n6 from sympy.functions.elementary.miscellaneous import sqrt\n7 \n8 from sympy.functions.elementary.exponential import exp, log\n9 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n10 \n11 \n12 def _rewrite_hyperbolics_as_exp(expr):\n13     expr = sympify(expr)\n14     return expr.xreplace(dict([(h, h.rewrite(exp))\n15         for h in expr.atoms(HyperbolicFunction)]))\n16 \n17 \n18 ###############################################################################\n19 ########################### HYPERBOLIC FUNCTIONS ##############################\n20 ###############################################################################\n21 \n22 \n23 class HyperbolicFunction(Function):\n24     \"\"\"\n25     Base class for hyperbolic functions.\n26 \n27     See Also\n28     ========\n29 \n30     sinh, cosh, tanh, coth\n31     \"\"\"\n32 \n33     unbranched = True\n34 \n35 \n36 class sinh(HyperbolicFunction):\n37     r\"\"\"\n38     The hyperbolic sine function, `\\frac{e^x - e^{-x}}{2}`.\n39 \n40     * sinh(x) -> Returns the hyperbolic sine of x\n41 \n42     See Also\n43     ========\n44 \n45     cosh, tanh, asinh\n46     \"\"\"\n47 \n48     def fdiff(self, argindex=1):\n49         \"\"\"\n50         Returns the first derivative of this function.\n51         \"\"\"\n52         if argindex == 1:\n53             return cosh(self.args[0])\n54         else:\n55             raise ArgumentIndexError(self, argindex)\n56 \n57     def inverse(self, argindex=1):\n58         \"\"\"\n59         Returns the inverse of this function.\n60         \"\"\"\n61         return asinh\n62 \n63     @classmethod\n64     def eval(cls, arg):\n65         from sympy import sin\n66 \n67         arg = sympify(arg)\n68 \n69         if arg.is_Number:\n70             if arg is S.NaN:\n71                 return S.NaN\n72             elif arg is S.Infinity:\n73                 return S.Infinity\n74             elif arg is S.NegativeInfinity:\n75                 return S.NegativeInfinity\n76             elif arg is S.Zero:\n77                 return S.Zero\n78             elif arg.is_negative:\n79                 return -cls(-arg)\n80         else:\n81             if arg is S.ComplexInfinity:\n82                 return S.NaN\n83 \n84             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n85 \n86             if i_coeff is not None:\n87                 return S.ImaginaryUnit * sin(i_coeff)\n88             else:\n89                 if _coeff_isneg(arg):\n90                     return -cls(-arg)\n91 \n92             if arg.func == asinh:\n93                 return arg.args[0]\n94 \n95             if arg.func == acosh:\n96                 x = arg.args[0]\n97                 return sqrt(x - 1) * sqrt(x + 1)\n98 \n99             if arg.func == atanh:\n100                 x = arg.args[0]\n101                 return x/sqrt(1 - x**2)\n102 \n103             if arg.func == acoth:\n104                 x = arg.args[0]\n105                 return 1/(sqrt(x - 1) * sqrt(x + 1))\n106 \n107     @staticmethod\n108     @cacheit\n109     def taylor_term(n, x, *previous_terms):\n110         \"\"\"\n111         Returns the next term in the Taylor series expansion.\n112         \"\"\"\n113         if n < 0 or n % 2 == 0:\n114             return S.Zero\n115         else:\n116             x = sympify(x)\n117 \n118             if len(previous_terms) > 2:\n119                 p = previous_terms[-2]\n120                 return p * x**2 / (n*(n - 1))\n121             else:\n122                 return x**(n) / factorial(n)\n123 \n124     def _eval_conjugate(self):\n125         return self.func(self.args[0].conjugate())\n126 \n127     def as_real_imag(self, deep=True, **hints):\n128         \"\"\"\n129         Returns this function as a complex coordinate.\n130         \"\"\"\n131         from sympy import cos, sin\n132         if self.args[0].is_real:\n133             if deep:\n134                 hints['complex'] = False\n135                 return (self.expand(deep, **hints), S.Zero)\n136             else:\n137                 return (self, S.Zero)\n138         if deep:\n139             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n140         else:\n141             re, im = self.args[0].as_real_imag()\n142         return (sinh(re)*cos(im), cosh(re)*sin(im))\n143 \n144     def _eval_expand_complex(self, deep=True, **hints):\n145         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n146         return re_part + im_part*S.ImaginaryUnit\n147 \n148     def _eval_expand_trig(self, deep=True, **hints):\n149         if deep:\n150             arg = self.args[0].expand(deep, **hints)\n151         else:\n152             arg = self.args[0]\n153         x = None\n154         if arg.is_Add: # TODO, implement more if deep stuff here\n155             x, y = arg.as_two_terms()\n156         else:\n157             coeff, terms = arg.as_coeff_Mul(rational=True)\n158             if coeff is not S.One and coeff.is_Integer and terms is not S.One:\n159                 x = terms\n160                 y = (coeff - 1)*x\n161         if x is not None:\n162             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)\n163         return sinh(arg)\n164 \n165     def _eval_rewrite_as_tractable(self, arg):\n166         return (exp(arg) - exp(-arg)) / 2\n167 \n168     def _eval_rewrite_as_exp(self, arg):\n169         return (exp(arg) - exp(-arg)) / 2\n170 \n171     def _eval_rewrite_as_cosh(self, arg):\n172         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)\n173 \n174     def _eval_rewrite_as_tanh(self, arg):\n175         tanh_half = tanh(S.Half*arg)\n176         return 2*tanh_half/(1 - tanh_half**2)\n177 \n178     def _eval_rewrite_as_coth(self, arg):\n179         coth_half = coth(S.Half*arg)\n180         return 2*coth_half/(coth_half**2 - 1)\n181 \n182     def _eval_as_leading_term(self, x):\n183         from sympy import Order\n184         arg = self.args[0].as_leading_term(x)\n185 \n186         if x in arg.free_symbols and Order(1, x).contains(arg):\n187             return arg\n188         else:\n189             return self.func(arg)\n190 \n191     def _eval_is_real(self):\n192         return self.args[0].is_real\n193 \n194     def _eval_is_finite(self):\n195         arg = self.args[0]\n196         if arg.is_imaginary:\n197             return True\n198 \n199 \n200 class cosh(HyperbolicFunction):\n201     r\"\"\"\n202     The hyperbolic cosine function, `\\frac{e^x + e^{-x}}{2}`.\n203 \n204     * cosh(x) -> Returns the hyperbolic cosine of x\n205 \n206     See Also\n207     ========\n208 \n209     sinh, tanh, acosh\n210     \"\"\"\n211 \n212     def fdiff(self, argindex=1):\n213         if argindex == 1:\n214             return sinh(self.args[0])\n215         else:\n216             raise ArgumentIndexError(self, argindex)\n217 \n218     @classmethod\n219     def eval(cls, arg):\n220         from sympy import cos\n221         arg = sympify(arg)\n222 \n223         if arg.is_Number:\n224             if arg is S.NaN:\n225                 return S.NaN\n226             elif arg is S.Infinity:\n227                 return S.Infinity\n228             elif arg is S.NegativeInfinity:\n229                 return S.Infinity\n230             elif arg is S.Zero:\n231                 return S.One\n232             elif arg.is_negative:\n233                 return cls(-arg)\n234         else:\n235             if arg is S.ComplexInfinity:\n236                 return S.NaN\n237 \n238             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n239 \n240             if i_coeff is not None:\n241                 return cos(i_coeff)\n242             else:\n243                 if _coeff_isneg(arg):\n244                     return cls(-arg)\n245 \n246             if arg.func == asinh:\n247                 return sqrt(1 + arg.args[0]**2)\n248 \n249             if arg.func == acosh:\n250                 return arg.args[0]\n251 \n252             if arg.func == atanh:\n253                 return 1/sqrt(1 - arg.args[0]**2)\n254 \n255             if arg.func == acoth:\n256                 x = arg.args[0]\n257                 return x/(sqrt(x - 1) * sqrt(x + 1))\n258 \n259     @staticmethod\n260     @cacheit\n261     def taylor_term(n, x, *previous_terms):\n262         if n < 0 or n % 2 == 1:\n263             return S.Zero\n264         else:\n265             x = sympify(x)\n266 \n267             if len(previous_terms) > 2:\n268                 p = previous_terms[-2]\n269                 return p * x**2 / (n*(n - 1))\n270             else:\n271                 return x**(n)/factorial(n)\n272 \n273     def _eval_conjugate(self):\n274         return self.func(self.args[0].conjugate())\n275 \n276     def as_real_imag(self, deep=True, **hints):\n277         from sympy import cos, sin\n278         if self.args[0].is_real:\n279             if deep:\n280                 hints['complex'] = False\n281                 return (self.expand(deep, **hints), S.Zero)\n282             else:\n283                 return (self, S.Zero)\n284         if deep:\n285             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n286         else:\n287             re, im = self.args[0].as_real_imag()\n288 \n289         return (cosh(re)*cos(im), sinh(re)*sin(im))\n290 \n291     def _eval_expand_complex(self, deep=True, **hints):\n292         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n293         return re_part + im_part*S.ImaginaryUnit\n294 \n295     def _eval_expand_trig(self, deep=True, **hints):\n296         if deep:\n297             arg = self.args[0].expand(deep, **hints)\n298         else:\n299             arg = self.args[0]\n300         x = None\n301         if arg.is_Add: # TODO, implement more if deep stuff here\n302             x, y = arg.as_two_terms()\n303         else:\n304             coeff, terms = arg.as_coeff_Mul(rational=True)\n305             if coeff is not S.One and coeff.is_Integer and terms is not S.One:\n306                 x = terms\n307                 y = (coeff - 1)*x\n308         if x is not None:\n309             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)\n310         return cosh(arg)\n311 \n312     def _eval_rewrite_as_tractable(self, arg):\n313         return (exp(arg) + exp(-arg)) / 2\n314 \n315     def _eval_rewrite_as_exp(self, arg):\n316         return (exp(arg) + exp(-arg)) / 2\n317 \n318     def _eval_rewrite_as_sinh(self, arg):\n319         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)\n320 \n321     def _eval_rewrite_as_tanh(self, arg):\n322         tanh_half = tanh(S.Half*arg)**2\n323         return (1 + tanh_half)/(1 - tanh_half)\n324 \n325     def _eval_rewrite_as_coth(self, arg):\n326         coth_half = coth(S.Half*arg)**2\n327         return (coth_half + 1)/(coth_half - 1)\n328 \n329     def _eval_as_leading_term(self, x):\n330         from sympy import Order\n331         arg = self.args[0].as_leading_term(x)\n332 \n333         if x in arg.free_symbols and Order(1, x).contains(arg):\n334             return S.One\n335         else:\n336             return self.func(arg)\n337 \n338     def _eval_is_real(self):\n339         return self.args[0].is_real\n340 \n341     def _eval_is_finite(self):\n342         arg = self.args[0]\n343         if arg.is_imaginary:\n344             return True\n345 \n346 \n347 class tanh(HyperbolicFunction):\n348     r\"\"\"\n349     The hyperbolic tangent function, `\\frac{\\sinh(x)}{\\cosh(x)}`.\n350 \n351     * tanh(x) -> Returns the hyperbolic tangent of x\n352 \n353     See Also\n354     ========\n355 \n356     sinh, cosh, atanh\n357     \"\"\"\n358 \n359     def fdiff(self, argindex=1):\n360         if argindex == 1:\n361             return S.One - tanh(self.args[0])**2\n362         else:\n363             raise ArgumentIndexError(self, argindex)\n364 \n365     def inverse(self, argindex=1):\n366         \"\"\"\n367         Returns the inverse of this function.\n368         \"\"\"\n369         return atanh\n370 \n371     @classmethod\n372     def eval(cls, arg):\n373         from sympy import tan\n374         arg = sympify(arg)\n375 \n376         if arg.is_Number:\n377             if arg is S.NaN:\n378                 return S.NaN\n379             elif arg is S.Infinity:\n380                 return S.One\n381             elif arg is S.NegativeInfinity:\n382                 return S.NegativeOne\n383             elif arg is S.Zero:\n384                 return S.Zero\n385             elif arg.is_negative:\n386                 return -cls(-arg)\n387         else:\n388             if arg is S.ComplexInfinity:\n389                 return S.NaN\n390 \n391             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n392 \n393             if i_coeff is not None:\n394                 if _coeff_isneg(i_coeff):\n395                     return -S.ImaginaryUnit * tan(-i_coeff)\n396                 return S.ImaginaryUnit * tan(i_coeff)\n397             else:\n398                 if _coeff_isneg(arg):\n399                     return -cls(-arg)\n400 \n401             if arg.func == asinh:\n402                 x = arg.args[0]\n403                 return x/sqrt(1 + x**2)\n404 \n405             if arg.func == acosh:\n406                 x = arg.args[0]\n407                 return sqrt(x - 1) * sqrt(x + 1) / x\n408 \n409             if arg.func == atanh:\n410                 return arg.args[0]\n411 \n412             if arg.func == acoth:\n413                 return 1/arg.args[0]\n414 \n415     @staticmethod\n416     @cacheit\n417     def taylor_term(n, x, *previous_terms):\n418         from sympy import bernoulli\n419         if n < 0 or n % 2 == 0:\n420             return S.Zero\n421         else:\n422             x = sympify(x)\n423 \n424             a = 2**(n + 1)\n425 \n426             B = bernoulli(n + 1)\n427             F = factorial(n + 1)\n428 \n429             return a*(a - 1) * B/F * x**n\n430 \n431     def _eval_conjugate(self):\n432         return self.func(self.args[0].conjugate())\n433 \n434     def as_real_imag(self, deep=True, **hints):\n435         from sympy import cos, sin\n436         if self.args[0].is_real:\n437             if deep:\n438                 hints['complex'] = False\n439                 return (self.expand(deep, **hints), S.Zero)\n440             else:\n441                 return (self, S.Zero)\n442         if deep:\n443             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n444         else:\n445             re, im = self.args[0].as_real_imag()\n446         denom = sinh(re)**2 + cos(im)**2\n447         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)\n448 \n449     def _eval_rewrite_as_tractable(self, arg):\n450         neg_exp, pos_exp = exp(-arg), exp(arg)\n451         return (pos_exp - neg_exp)/(pos_exp + neg_exp)\n452 \n453     def _eval_rewrite_as_exp(self, arg):\n454         neg_exp, pos_exp = exp(-arg), exp(arg)\n455         return (pos_exp - neg_exp)/(pos_exp + neg_exp)\n456 \n457     def _eval_rewrite_as_sinh(self, arg):\n458         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)\n459 \n460     def _eval_rewrite_as_cosh(self, arg):\n461         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)\n462 \n463     def _eval_rewrite_as_coth(self, arg):\n464         return 1/coth(arg)\n465 \n466     def _eval_as_leading_term(self, x):\n467         from sympy import Order\n468         arg = self.args[0].as_leading_term(x)\n469 \n470         if x in arg.free_symbols and Order(1, x).contains(arg):\n471             return arg\n472         else:\n473             return self.func(arg)\n474 \n475     def _eval_is_real(self):\n476         return self.args[0].is_real\n477 \n478     def _eval_is_finite(self):\n479         arg = self.args[0]\n480         if arg.is_real:\n481             return True\n482 \n483 \n484 class coth(HyperbolicFunction):\n485     r\"\"\"\n486     The hyperbolic cotangent function, `\\frac{\\cosh(x)}{\\sinh(x)}`.\n487 \n488     * coth(x) -> Returns the hyperbolic cotangent of x\n489     \"\"\"\n490 \n491     def fdiff(self, argindex=1):\n492         if argindex == 1:\n493             return -1/sinh(self.args[0])**2\n494         else:\n495             raise ArgumentIndexError(self, argindex)\n496 \n497     def inverse(self, argindex=1):\n498         \"\"\"\n499         Returns the inverse of this function.\n500         \"\"\"\n501         return acoth\n502 \n503     @classmethod\n504     def eval(cls, arg):\n505         from sympy import cot\n506         arg = sympify(arg)\n507 \n508         if arg.is_Number:\n509             if arg is S.NaN:\n510                 return S.NaN\n511             elif arg is S.Infinity:\n512                 return S.One\n513             elif arg is S.NegativeInfinity:\n514                 return S.NegativeOne\n515             elif arg is S.Zero:\n516                 return S.ComplexInfinity\n517             elif arg.is_negative:\n518                 return -cls(-arg)\n519         else:\n520             if arg is S.ComplexInfinity:\n521                 return S.NaN\n522 \n523             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n524 \n525             if i_coeff is not None:\n526                 if _coeff_isneg(i_coeff):\n527                     return S.ImaginaryUnit * cot(-i_coeff)\n528                 return -S.ImaginaryUnit * cot(i_coeff)\n529             else:\n530                 if _coeff_isneg(arg):\n531                     return -cls(-arg)\n532 \n533             if arg.func == asinh:\n534                 x = arg.args[0]\n535                 return sqrt(1 + x**2)/x\n536 \n537             if arg.func == acosh:\n538                 x = arg.args[0]\n539                 return x/(sqrt(x - 1) * sqrt(x + 1))\n540 \n541             if arg.func == atanh:\n542                 return 1/arg.args[0]\n543 \n544             if arg.func == acoth:\n545                 return arg.args[0]\n546 \n547     @staticmethod\n548     @cacheit\n549     def taylor_term(n, x, *previous_terms):\n550         from sympy import bernoulli\n551         if n == 0:\n552             return 1 / sympify(x)\n553         elif n < 0 or n % 2 == 0:\n554             return S.Zero\n555         else:\n556             x = sympify(x)\n557 \n558             B = bernoulli(n + 1)\n559             F = factorial(n + 1)\n560 \n561             return 2**(n + 1) * B/F * x**n\n562 \n563     def _eval_conjugate(self):\n564         return self.func(self.args[0].conjugate())\n565 \n566     def as_real_imag(self, deep=True, **hints):\n567         from sympy import cos, sin\n568         if self.args[0].is_real:\n569             if deep:\n570                 hints['complex'] = False\n571                 return (self.expand(deep, **hints), S.Zero)\n572             else:\n573                 return (self, S.Zero)\n574         if deep:\n575             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n576         else:\n577             re, im = self.args[0].as_real_imag()\n578         denom = sinh(re)**2 + sin(im)**2\n579         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)\n580 \n581     def _eval_rewrite_as_tractable(self, arg):\n582         neg_exp, pos_exp = exp(-arg), exp(arg)\n583         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n584 \n585     def _eval_rewrite_as_exp(self, arg):\n586         neg_exp, pos_exp = exp(-arg), exp(arg)\n587         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n588 \n589     def _eval_rewrite_as_sinh(self, arg):\n590         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)\n591 \n592     def _eval_rewrite_as_cosh(self, arg):\n593         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)\n594 \n595     def _eval_rewrite_as_tanh(self, arg):\n596         return 1/tanh(arg)\n597 \n598     def _eval_as_leading_term(self, x):\n599         from sympy import Order\n600         arg = self.args[0].as_leading_term(x)\n601 \n602         if x in arg.free_symbols and Order(1, x).contains(arg):\n603             return 1/arg\n604         else:\n605             return self.func(arg)\n606 \n607 \n608 class ReciprocalHyperbolicFunction(HyperbolicFunction):\n609     \"\"\"Base class for reciprocal functions of hyperbolic functions. \"\"\"\n610 \n611     #To be defined in class\n612     _reciprocal_of = None\n613     _is_even = None\n614     _is_odd = None\n615 \n616     @classmethod\n617     def eval(cls, arg):\n618         if arg.could_extract_minus_sign():\n619             if cls._is_even:\n620                 return cls(-arg)\n621             if cls._is_odd:\n622                 return -cls(-arg)\n623 \n624         t = cls._reciprocal_of.eval(arg)\n625         if hasattr(arg, 'inverse') and arg.inverse() == cls:\n626             return arg.args[0]\n627         return 1/t if t != None else t\n628 \n629     def _call_reciprocal(self, method_name, *args, **kwargs):\n630         # Calls method_name on _reciprocal_of\n631         o = self._reciprocal_of(self.args[0])\n632         return getattr(o, method_name)(*args, **kwargs)\n633 \n634     def _calculate_reciprocal(self, method_name, *args, **kwargs):\n635         # If calling method_name on _reciprocal_of returns a value != None\n636         # then return the reciprocal of that value\n637         t = self._call_reciprocal(method_name, *args, **kwargs)\n638         return 1/t if t != None else t\n639 \n640     def _rewrite_reciprocal(self, method_name, arg):\n641         # Special handling for rewrite functions. If reciprocal rewrite returns\n642         # unmodified expression, then return None\n643         t = self._call_reciprocal(method_name, arg)\n644         if t != None and t != self._reciprocal_of(arg):\n645             return 1/t\n646 \n647     def _eval_rewrite_as_exp(self, arg):\n648         return self._rewrite_reciprocal(\"_eval_rewrite_as_exp\", arg)\n649 \n650     def _eval_rewrite_as_tractable(self, arg):\n651         return self._rewrite_reciprocal(\"_eval_rewrite_as_tractable\", arg)\n652 \n653     def _eval_rewrite_as_tanh(self, arg):\n654         return self._rewrite_reciprocal(\"_eval_rewrite_as_tanh\", arg)\n655 \n656     def _eval_rewrite_as_coth(self, arg):\n657         return self._rewrite_reciprocal(\"_eval_rewrite_as_coth\", arg)\n658 \n659     def as_real_imag(self, deep = True, **hints):\n660         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)\n661 \n662     def _eval_conjugate(self):\n663         return self.func(self.args[0].conjugate())\n664 \n665     def _eval_expand_complex(self, deep=True, **hints):\n666         re_part, im_part = self.as_real_imag(deep=True, **hints)\n667         return re_part + S.ImaginaryUnit*im_part\n668 \n669     def _eval_as_leading_term(self, x):\n670         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)\n671 \n672     def _eval_is_real(self):\n673         return self._reciprocal_of(self.args[0]).is_real\n674 \n675     def _eval_is_finite(self):\n676         return (1/self._reciprocal_of(self.args[0])).is_finite\n677 \n678 \n679 class csch(ReciprocalHyperbolicFunction):\n680     r\"\"\"\n681     The hyperbolic cosecant function, `\\frac{2}{e^x - e^{-x}}`\n682 \n683     * csch(x) -> Returns the hyperbolic cosecant of x\n684 \n685     See Also\n686     ========\n687 \n688     sinh, cosh, tanh, sech, asinh, acosh\n689     \"\"\"\n690 \n691     _reciprocal_of = sinh\n692     _is_odd = True\n693 \n694     def fdiff(self, argindex=1):\n695         \"\"\"\n696         Returns the first derivative of this function\n697         \"\"\"\n698         if argindex == 1:\n699             return -coth(self.args[0]) * csch(self.args[0])\n700         else:\n701             raise ArgumentIndexError(self, argindex)\n702 \n703     @staticmethod\n704     @cacheit\n705     def taylor_term(n, x, *previous_terms):\n706         \"\"\"\n707         Returns the next term in the Taylor series expansion\n708         \"\"\"\n709         from sympy import bernoulli\n710         if n == 0:\n711             return 1/sympify(x)\n712         elif n < 0 or n % 2 == 0:\n713             return S.Zero\n714         else:\n715             x = sympify(x)\n716 \n717             B = bernoulli(n + 1)\n718             F = factorial(n + 1)\n719 \n720             return 2 * (1 - 2**n) * B/F * x**n\n721 \n722     def _eval_rewrite_as_cosh(self, arg):\n723         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)\n724 \n725     def _sage_(self):\n726         import sage.all as sage\n727         return sage.csch(self.args[0]._sage_())\n728 \n729 \n730 class sech(ReciprocalHyperbolicFunction):\n731     r\"\"\"\n732     The hyperbolic secant function, `\\frac{2}{e^x + e^{-x}}`\n733 \n734     * sech(x) -> Returns the hyperbolic secant of x\n735 \n736     See Also\n737     ========\n738 \n739     sinh, cosh, tanh, coth, csch, asinh, acosh\n740     \"\"\"\n741 \n742     _reciprocal_of = cosh\n743     _is_even = True\n744 \n745     def fdiff(self, argindex=1):\n746         if argindex == 1:\n747             return - tanh(self.args[0])*sech(self.args[0])\n748         else:\n749             raise ArgumentIndexError(self, argindex)\n750 \n751     @staticmethod\n752     @cacheit\n753     def taylor_term(n, x, *previous_terms):\n754         from sympy.functions.combinatorial.numbers import euler\n755         if n < 0 or n % 2 == 1:\n756             return S.Zero\n757         else:\n758             x = sympify(x)\n759             return euler(n) / factorial(n) * x**(n)\n760 \n761     def _eval_rewrite_as_sinh(self, arg):\n762         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)\n763 \n764     def _sage_(self):\n765         import sage.all as sage\n766         return sage.sech(self.args[0]._sage_())\n767 \n768 \n769 \n770 ###############################################################################\n771 ############################# HYPERBOLIC INVERSES #############################\n772 ###############################################################################\n773 \n774 class InverseHyperbolicFunction(Function):\n775     \"\"\"Base class for inverse hyperbolic functions.\"\"\"\n776 \n777     pass\n778 \n779 \n780 class asinh(InverseHyperbolicFunction):\n781     \"\"\"\n782     The inverse hyperbolic sine function.\n783 \n784     * asinh(x) -> Returns the inverse hyperbolic sine of x\n785 \n786     See Also\n787     ========\n788 \n789     acosh, atanh, sinh\n790     \"\"\"\n791 \n792     def fdiff(self, argindex=1):\n793         if argindex == 1:\n794             return 1/sqrt(self.args[0]**2 + 1)\n795         else:\n796             raise ArgumentIndexError(self, argindex)\n797 \n798     @classmethod\n799     def eval(cls, arg):\n800         from sympy import asin\n801         arg = sympify(arg)\n802 \n803         if arg.is_Number:\n804             if arg is S.NaN:\n805                 return S.NaN\n806             elif arg is S.Infinity:\n807                 return S.Infinity\n808             elif arg is S.NegativeInfinity:\n809                 return S.NegativeInfinity\n810             elif arg is S.Zero:\n811                 return S.Zero\n812             elif arg is S.One:\n813                 return log(sqrt(2) + 1)\n814             elif arg is S.NegativeOne:\n815                 return log(sqrt(2) - 1)\n816             elif arg.is_negative:\n817                 return -cls(-arg)\n818         else:\n819             if arg is S.ComplexInfinity:\n820                 return S.ComplexInfinity\n821 \n822             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n823 \n824             if i_coeff is not None:\n825                 return S.ImaginaryUnit * asin(i_coeff)\n826             else:\n827                 if _coeff_isneg(arg):\n828                     return -cls(-arg)\n829 \n830     @staticmethod\n831     @cacheit\n832     def taylor_term(n, x, *previous_terms):\n833         if n < 0 or n % 2 == 0:\n834             return S.Zero\n835         else:\n836             x = sympify(x)\n837             if len(previous_terms) >= 2 and n > 2:\n838                 p = previous_terms[-2]\n839                 return -p * (n - 2)**2/(n*(n - 1)) * x**2\n840             else:\n841                 k = (n - 1) // 2\n842                 R = RisingFactorial(S.Half, k)\n843                 F = factorial(k)\n844                 return (-1)**k * R / F * x**n / n\n845 \n846     def _eval_as_leading_term(self, x):\n847         from sympy import Order\n848         arg = self.args[0].as_leading_term(x)\n849 \n850         if x in arg.free_symbols and Order(1, x).contains(arg):\n851             return arg\n852         else:\n853             return self.func(arg)\n854 \n855     def _eval_rewrite_as_log(self, x):\n856         return log(x + sqrt(x**2 + 1))\n857 \n858     def inverse(self, argindex=1):\n859         \"\"\"\n860         Returns the inverse of this function.\n861         \"\"\"\n862         return sinh\n863 \n864 \n865 class acosh(InverseHyperbolicFunction):\n866     \"\"\"\n867     The inverse hyperbolic cosine function.\n868 \n869     * acosh(x) -> Returns the inverse hyperbolic cosine of x\n870 \n871     See Also\n872     ========\n873 \n874     asinh, atanh, cosh\n875     \"\"\"\n876 \n877     def fdiff(self, argindex=1):\n878         if argindex == 1:\n879             return 1/sqrt(self.args[0]**2 - 1)\n880         else:\n881             raise ArgumentIndexError(self, argindex)\n882 \n883     @classmethod\n884     def eval(cls, arg):\n885         arg = sympify(arg)\n886 \n887         if arg.is_Number:\n888             if arg is S.NaN:\n889                 return S.NaN\n890             elif arg is S.Infinity:\n891                 return S.Infinity\n892             elif arg is S.NegativeInfinity:\n893                 return S.Infinity\n894             elif arg is S.Zero:\n895                 return S.Pi*S.ImaginaryUnit / 2\n896             elif arg is S.One:\n897                 return S.Zero\n898             elif arg is S.NegativeOne:\n899                 return S.Pi*S.ImaginaryUnit\n900 \n901         if arg.is_number:\n902             cst_table = {\n903                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),\n904                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),\n905                 S.Half: S.Pi/3,\n906                 -S.Half: 2*S.Pi/3,\n907                 sqrt(2)/2: S.Pi/4,\n908                 -sqrt(2)/2: 3*S.Pi/4,\n909                 1/sqrt(2): S.Pi/4,\n910                 -1/sqrt(2): 3*S.Pi/4,\n911                 sqrt(3)/2: S.Pi/6,\n912                 -sqrt(3)/2: 5*S.Pi/6,\n913                 (sqrt(3) - 1)/sqrt(2**3): 5*S.Pi/12,\n914                 -(sqrt(3) - 1)/sqrt(2**3): 7*S.Pi/12,\n915                 sqrt(2 + sqrt(2))/2: S.Pi/8,\n916                 -sqrt(2 + sqrt(2))/2: 7*S.Pi/8,\n917                 sqrt(2 - sqrt(2))/2: 3*S.Pi/8,\n918                 -sqrt(2 - sqrt(2))/2: 5*S.Pi/8,\n919                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,\n920                 -(1 + sqrt(3))/(2*sqrt(2)): 11*S.Pi/12,\n921                 (sqrt(5) + 1)/4: S.Pi/5,\n922                 -(sqrt(5) + 1)/4: 4*S.Pi/5\n923             }\n924 \n925             if arg in cst_table:\n926                 if arg.is_real:\n927                     return cst_table[arg]*S.ImaginaryUnit\n928                 return cst_table[arg]\n929 \n930         if arg.is_infinite:\n931             return S.Infinity\n932 \n933     @staticmethod\n934     @cacheit\n935     def taylor_term(n, x, *previous_terms):\n936         if n == 0:\n937             return S.Pi*S.ImaginaryUnit / 2\n938         elif n < 0 or n % 2 == 0:\n939             return S.Zero\n940         else:\n941             x = sympify(x)\n942             if len(previous_terms) >= 2 and n > 2:\n943                 p = previous_terms[-2]\n944                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n945             else:\n946                 k = (n - 1) // 2\n947                 R = RisingFactorial(S.Half, k)\n948                 F = factorial(k)\n949                 return -R / F * S.ImaginaryUnit * x**n / n\n950 \n951     def _eval_as_leading_term(self, x):\n952         from sympy import Order\n953         arg = self.args[0].as_leading_term(x)\n954 \n955         if x in arg.free_symbols and Order(1, x).contains(arg):\n956             return S.ImaginaryUnit*S.Pi/2\n957         else:\n958             return self.func(arg)\n959 \n960     def _eval_rewrite_as_log(self, x):\n961         return log(x + sqrt(x + 1) * sqrt(x - 1))\n962 \n963     def inverse(self, argindex=1):\n964         \"\"\"\n965         Returns the inverse of this function.\n966         \"\"\"\n967         return cosh\n968 \n969 \n970 class atanh(InverseHyperbolicFunction):\n971     \"\"\"\n972     The inverse hyperbolic tangent function.\n973 \n974     * atanh(x) -> Returns the inverse hyperbolic tangent of x\n975 \n976     See Also\n977     ========\n978 \n979     asinh, acosh, tanh\n980     \"\"\"\n981 \n982     def fdiff(self, argindex=1):\n983         if argindex == 1:\n984             return 1/(1 - self.args[0]**2)\n985         else:\n986             raise ArgumentIndexError(self, argindex)\n987 \n988     @classmethod\n989     def eval(cls, arg):\n990         from sympy import atan\n991         arg = sympify(arg)\n992 \n993         if arg.is_Number:\n994             if arg is S.NaN:\n995                 return S.NaN\n996             elif arg is S.Zero:\n997                 return S.Zero\n998             elif arg is S.One:\n999                 return S.Infinity\n1000             elif arg is S.NegativeOne:\n1001                 return S.NegativeInfinity\n1002             elif arg is S.Infinity:\n1003                 return -S.ImaginaryUnit * atan(arg)\n1004             elif arg is S.NegativeInfinity:\n1005                 return S.ImaginaryUnit * atan(-arg)\n1006             elif arg.is_negative:\n1007                 return -cls(-arg)\n1008         else:\n1009             if arg is S.ComplexInfinity:\n1010                 return S.NaN\n1011 \n1012             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1013 \n1014             if i_coeff is not None:\n1015                 return S.ImaginaryUnit * atan(i_coeff)\n1016             else:\n1017                 if _coeff_isneg(arg):\n1018                     return -cls(-arg)\n1019 \n1020     @staticmethod\n1021     @cacheit\n1022     def taylor_term(n, x, *previous_terms):\n1023         if n < 0 or n % 2 == 0:\n1024             return S.Zero\n1025         else:\n1026             x = sympify(x)\n1027             return x**n / n\n1028 \n1029     def _eval_as_leading_term(self, x):\n1030         from sympy import Order\n1031         arg = self.args[0].as_leading_term(x)\n1032 \n1033         if x in arg.free_symbols and Order(1, x).contains(arg):\n1034             return arg\n1035         else:\n1036             return self.func(arg)\n1037 \n1038     def _eval_rewrite_as_log(self, x):\n1039         return (log(1 + x) - log(1 - x)) / 2\n1040 \n1041     def inverse(self, argindex=1):\n1042         \"\"\"\n1043         Returns the inverse of this function.\n1044         \"\"\"\n1045         return tanh\n1046 \n1047 \n1048 class acoth(InverseHyperbolicFunction):\n1049     \"\"\"\n1050     The inverse hyperbolic cotangent function.\n1051 \n1052     * acoth(x) -> Returns the inverse hyperbolic cotangent of x\n1053     \"\"\"\n1054 \n1055     def fdiff(self, argindex=1):\n1056         if argindex == 1:\n1057             return 1/(1 - self.args[0]**2)\n1058         else:\n1059             raise ArgumentIndexError(self, argindex)\n1060 \n1061     @classmethod\n1062     def eval(cls, arg):\n1063         from sympy import acot\n1064         arg = sympify(arg)\n1065 \n1066         if arg.is_Number:\n1067             if arg is S.NaN:\n1068                 return S.NaN\n1069             elif arg is S.Infinity:\n1070                 return S.Zero\n1071             elif arg is S.NegativeInfinity:\n1072                 return S.Zero\n1073             elif arg is S.Zero:\n1074                 return S.Pi*S.ImaginaryUnit / 2\n1075             elif arg is S.One:\n1076                 return S.Infinity\n1077             elif arg is S.NegativeOne:\n1078                 return S.NegativeInfinity\n1079             elif arg.is_negative:\n1080                 return -cls(-arg)\n1081         else:\n1082             if arg is S.ComplexInfinity:\n1083                 return 0\n1084 \n1085             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1086 \n1087             if i_coeff is not None:\n1088                 return -S.ImaginaryUnit * acot(i_coeff)\n1089             else:\n1090                 if _coeff_isneg(arg):\n1091                     return -cls(-arg)\n1092 \n1093     @staticmethod\n1094     @cacheit\n1095     def taylor_term(n, x, *previous_terms):\n1096         if n == 0:\n1097             return S.Pi*S.ImaginaryUnit / 2\n1098         elif n < 0 or n % 2 == 0:\n1099             return S.Zero\n1100         else:\n1101             x = sympify(x)\n1102             return x**n / n\n1103 \n1104     def _eval_as_leading_term(self, x):\n1105         from sympy import Order\n1106         arg = self.args[0].as_leading_term(x)\n1107 \n1108         if x in arg.free_symbols and Order(1, x).contains(arg):\n1109             return S.ImaginaryUnit*S.Pi/2\n1110         else:\n1111             return self.func(arg)\n1112 \n1113     def _eval_rewrite_as_log(self, x):\n1114         return (log(1 + 1/x) - log(1 - 1/x)) / 2\n1115 \n1116     def inverse(self, argindex=1):\n1117         \"\"\"\n1118         Returns the inverse of this function.\n1119         \"\"\"\n1120         return coth\n1121 \n1122 \n1123 class asech(InverseHyperbolicFunction):\n1124     \"\"\"\n1125     The inverse hyperbolic secant function.\n1126 \n1127     * asech(x) -> Returns the inverse hyperbolic secant of x\n1128 \n1129     Examples\n1130     ========\n1131 \n1132     >>> from sympy import asech, sqrt, S\n1133     >>> from sympy.abc import x\n1134     >>> asech(x).diff(x)\n1135     -1/(x*sqrt(-x**2 + 1))\n1136     >>> asech(1).diff(x)\n1137     0\n1138     >>> asech(1)\n1139     0\n1140     >>> asech(S(2))\n1141     I*pi/3\n1142     >>> asech(-sqrt(2))\n1143     3*I*pi/4\n1144     >>> asech((sqrt(6) - sqrt(2)))\n1145     I*pi/12\n1146 \n1147     See Also\n1148     ========\n1149 \n1150     asinh, atanh, cosh, acoth\n1151 \n1152     References\n1153     ==========\n1154 \n1155     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function\n1156     .. [2] http://dlmf.nist.gov/4.37\n1157     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/\n1158 \n1159     \"\"\"\n1160 \n1161     def fdiff(self, argindex=1):\n1162         if argindex == 1:\n1163             z = self.args[0]\n1164             return -1/(z*sqrt(1 - z**2))\n1165         else:\n1166             raise ArgumentIndexError(self, argindex)\n1167 \n1168     @classmethod\n1169     def eval(cls, arg):\n1170         arg = sympify(arg)\n1171 \n1172         if arg.is_Number:\n1173             if arg is S.NaN:\n1174                 return S.NaN\n1175             elif arg is S.Infinity:\n1176                 return S.Pi*S.ImaginaryUnit / 2\n1177             elif arg is S.NegativeInfinity:\n1178                 return S.Pi*S.ImaginaryUnit / 2\n1179             elif arg is S.Zero:\n1180                 return S.Infinity\n1181             elif arg is S.One:\n1182                 return S.Zero\n1183             elif arg is S.NegativeOne:\n1184                 return S.Pi*S.ImaginaryUnit\n1185 \n1186         if arg.is_number:\n1187             cst_table = {\n1188                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),\n1189                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),\n1190                 (sqrt(6) - sqrt(2)): S.Pi / 12,\n1191                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,\n1192                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,\n1193                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,\n1194                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,\n1195                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,\n1196                 2 / sqrt(3): S.Pi / 6,\n1197                 -2 / sqrt(3): 5*S.Pi / 6,\n1198                 (sqrt(5) - 1): S.Pi / 5,\n1199                 (1 - sqrt(5)): 4*S.Pi / 5,\n1200                 sqrt(2): S.Pi / 4,\n1201                 -sqrt(2): 3*S.Pi / 4,\n1202                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,\n1203                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,\n1204                 S(2): S.Pi / 3,\n1205                 -S(2): 2*S.Pi / 3,\n1206                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,\n1207                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,\n1208                 (1 + sqrt(5)): 2*S.Pi / 5,\n1209                 (-1 - sqrt(5)): 3*S.Pi / 5,\n1210                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,\n1211                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,\n1212             }\n1213 \n1214             if arg in cst_table:\n1215                 if arg.is_real:\n1216                     return cst_table[arg]*S.ImaginaryUnit\n1217                 return cst_table[arg]\n1218 \n1219         if arg is S.ComplexInfinity:\n1220             return S.NaN\n1221 \n1222     @staticmethod\n1223     @cacheit\n1224     def expansion_term(n, x, *previous_terms):\n1225         if n == 0:\n1226             return log(2 / x)\n1227         elif n < 0 or n % 2 == 1:\n1228             return S.Zero\n1229         else:\n1230             x = sympify(x)\n1231             if len(previous_terms) > 2 and n > 2:\n1232                 p = previous_terms[-2]\n1233                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4\n1234             else:\n1235                 k = n // 2\n1236                 R = RisingFactorial(S.Half , k) *  n\n1237                 F = factorial(k) * n // 2 * n // 2\n1238                 return -1 * R / F * x**n / 4\n1239 \n1240     def inverse(self, argindex=1):\n1241         \"\"\"\n1242         Returns the inverse of this function.\n1243         \"\"\"\n1244         return sech\n1245 \n1246     def _eval_rewrite_as_log(self, arg):\n1247         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))\n1248 \n1249 \n1250 class acsch(InverseHyperbolicFunction):\n1251     \"\"\"\n1252     The inverse hyperbolic cosecant function.\n1253 \n1254     * acsch(x) -> Returns the inverse hyperbolic cosecant of x\n1255 \n1256     Examples\n1257     ========\n1258 \n1259     >>> from sympy import acsch, sqrt, S\n1260     >>> from sympy.abc import x\n1261     >>> acsch(x).diff(x)\n1262     -1/(x**2*sqrt(1 + x**(-2)))\n1263     >>> acsch(1).diff(x)\n1264     0\n1265     >>> acsch(1)\n1266     log(1 + sqrt(2))\n1267     >>> acsch(S.ImaginaryUnit)\n1268     -I*pi/2\n1269     >>> acsch(-2*S.ImaginaryUnit)\n1270     I*pi/6\n1271     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))\n1272     -5*I*pi/12\n1273 \n1274     References\n1275     ==========\n1276 \n1277     .. [1] http://en.wikipedia.org/wiki/Hyperbolic_function\n1278     .. [2] http://dlmf.nist.gov/4.37\n1279     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/\n1280 \n1281     \"\"\"\n1282 \n1283     def fdiff(self, argindex=1):\n1284         if argindex == 1:\n1285             z = self.args[0]\n1286             return -1/(z**2*sqrt(1 + 1/z**2))\n1287         else:\n1288             raise ArgumentIndexError(self, argindex)\n1289 \n1290     @classmethod\n1291     def eval(cls, arg):\n1292         arg = sympify(arg)\n1293 \n1294         if arg.is_Number:\n1295             if arg is S.NaN:\n1296                 return S.NaN\n1297             elif arg is S.Infinity:\n1298                 return S.Zero\n1299             elif arg is S.NegativeInfinity:\n1300                 return S.Zero\n1301             elif arg is S.Zero:\n1302                 return S.ComplexInfinity\n1303             elif arg is S.One:\n1304                 return log(1 + sqrt(2))\n1305             elif arg is S.NegativeOne:\n1306                 return - log(1 + sqrt(2))\n1307 \n1308         if arg.is_number:\n1309             cst_table = {\n1310                 S.ImaginaryUnit: -S.Pi / 2,\n1311                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,\n1312                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,\n1313                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,\n1314                 S.ImaginaryUnit*2: -S.Pi / 6,\n1315                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,\n1316                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,\n1317                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,\n1318                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,\n1319                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,\n1320                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,\n1321                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,\n1322                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),\n1323             }\n1324 \n1325             if arg in cst_table:\n1326                 return cst_table[arg]*S.ImaginaryUnit\n1327 \n1328         if arg is S.ComplexInfinity:\n1329             return S.Zero\n1330 \n1331         if _coeff_isneg(arg):\n1332             return -cls(-arg)\n1333 \n1334     def inverse(self, argindex=1):\n1335         \"\"\"\n1336         Returns the inverse of this function.\n1337         \"\"\"\n1338         return csch\n1339 \n1340     def _eval_rewrite_as_log(self, arg):\n1341         return log(1/arg + sqrt(1/arg**2 + 1))\n",
        "intended_behavior": "Review and potentially enhance the logic dealing with the interplay between trigonometric functions and complex arguments to ensure correct application of mathematical principles."
    }
]