[
    {
        "rel_file_path": "sphinx/environment/adapters/toctree.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/environment/adapters/toctree.py",
        "start": 1,
        "end": 336,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.environment.adapters.toctree\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Toctree adapter for sphinx.environment.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Iterable, List\n12 from typing import cast\n13 \n14 from docutils import nodes\n15 from docutils.nodes import Element, Node\n16 \n17 from sphinx import addnodes\n18 from sphinx.locale import __\n19 from sphinx.util import url_re, logging\n20 from sphinx.util.matching import Matcher\n21 from sphinx.util.nodes import clean_astext, process_only_nodes\n22 \n23 if False:\n24     # For type annotation\n25     from sphinx.builders import Builder\n26     from sphinx.environment import BuildEnvironment\n27 \n28 \n29 logger = logging.getLogger(__name__)\n30 \n31 \n32 class TocTree:\n33     def __init__(self, env: \"BuildEnvironment\") -> None:\n34         self.env = env\n35 \n36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:\n37         \"\"\"Note a TOC tree directive in a document and gather information about\n38         file relations from it.\n39         \"\"\"\n40         if toctreenode['glob']:\n41             self.env.glob_toctrees.add(docname)\n42         if toctreenode.get('numbered'):\n43             self.env.numbered_toctrees.add(docname)\n44         includefiles = toctreenode['includefiles']\n45         for includefile in includefiles:\n46             # note that if the included file is rebuilt, this one must be\n47             # too (since the TOC of the included file could have changed)\n48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)\n49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)\n50 \n51     def resolve(self, docname: str, builder: \"Builder\", toctree: addnodes.toctree,\n52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,\n53                 collapse: bool = False, includehidden: bool = False) -> Element:\n54         \"\"\"Resolve a *toctree* node into individual bullet lists with titles\n55         as items, returning None (if no containing titles are found) or\n56         a new node.\n57 \n58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,\n59         to the value of the *maxdepth* option on the *toctree* node.\n60         If *titles_only* is True, only toplevel document titles will be in the\n61         resulting tree.\n62         If *collapse* is True, all branches not containing docname will\n63         be collapsed.\n64         \"\"\"\n65         if toctree.get('hidden', False) and not includehidden:\n66             return None\n67 \n68         # For reading the following two helper function, it is useful to keep\n69         # in mind the node structure of a toctree (using HTML-like node names\n70         # for brevity):\n71         #\n72         # <ul>\n73         #   <li>\n74         #     <p><a></p>\n75         #     <p><a></p>\n76         #     ...\n77         #     <ul>\n78         #       ...\n79         #     </ul>\n80         #   </li>\n81         # </ul>\n82         #\n83         # The transformation is made in two passes in order to avoid\n84         # interactions between marking and pruning the tree (see bug #1046).\n85 \n86         toctree_ancestors = self.get_toctree_ancestors(docname)\n87         excluded = Matcher(self.env.config.exclude_patterns)\n88 \n89         def _toctree_add_classes(node: Element, depth: int) -> None:\n90             \"\"\"Add 'toctree-l%d' and 'current' classes to the toctree.\"\"\"\n91             for subnode in node.children:\n92                 if isinstance(subnode, (addnodes.compact_paragraph,\n93                                         nodes.list_item)):\n94                     # for <p> and <li>, indicate the depth level and recurse\n95                     subnode['classes'].append('toctree-l%d' % (depth - 1))\n96                     _toctree_add_classes(subnode, depth)\n97                 elif isinstance(subnode, nodes.bullet_list):\n98                     # for <ul>, just recurse\n99                     _toctree_add_classes(subnode, depth + 1)\n100                 elif isinstance(subnode, nodes.reference):\n101                     # for <a>, identify which entries point to the current\n102                     # document and therefore may not be collapsed\n103                     if subnode['refuri'] == docname:\n104                         if not subnode['anchorname']:\n105                             # give the whole branch a 'current' class\n106                             # (useful for styling it differently)\n107                             branchnode = subnode  # type: Element\n108                             while branchnode:\n109                                 branchnode['classes'].append('current')\n110                                 branchnode = branchnode.parent\n111                         # mark the list_item as \"on current page\"\n112                         if subnode.parent.parent.get('iscurrent'):\n113                             # but only if it's not already done\n114                             return\n115                         while subnode:\n116                             subnode['iscurrent'] = True\n117                             subnode = subnode.parent\n118 \n119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],\n120                                   separate: bool = False, subtree: bool = False\n121                                   ) -> List[Element]:\n122             \"\"\"Return TOC entries for a toctree node.\"\"\"\n123             refs = [(e[0], e[1]) for e in toctreenode['entries']]\n124             entries = []  # type: List[Element]\n125             for (title, ref) in refs:\n126                 try:\n127                     refdoc = None\n128                     if url_re.match(ref):\n129                         if title is None:\n130                             title = ref\n131                         reference = nodes.reference('', '', internal=False,\n132                                                     refuri=ref, anchorname='',\n133                                                     *[nodes.Text(title)])\n134                         para = addnodes.compact_paragraph('', '', reference)\n135                         item = nodes.list_item('', para)\n136                         toc = nodes.bullet_list('', item)\n137                     elif ref == 'self':\n138                         # 'self' refers to the document from which this\n139                         # toctree originates\n140                         ref = toctreenode['parent']\n141                         if not title:\n142                             title = clean_astext(self.env.titles[ref])\n143                         reference = nodes.reference('', '', internal=True,\n144                                                     refuri=ref,\n145                                                     anchorname='',\n146                                                     *[nodes.Text(title)])\n147                         para = addnodes.compact_paragraph('', '', reference)\n148                         item = nodes.list_item('', para)\n149                         # don't show subitems\n150                         toc = nodes.bullet_list('', item)\n151                     else:\n152                         if ref in parents:\n153                             logger.warning(__('circular toctree references '\n154                                               'detected, ignoring: %s <- %s'),\n155                                            ref, ' <- '.join(parents),\n156                                            location=ref)\n157                             continue\n158                         refdoc = ref\n159                         toc = self.env.tocs[ref].deepcopy()\n160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)\n161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):\n162                             self._toctree_prune(toc, 2, maxdepth, collapse)\n163                         process_only_nodes(toc, builder.tags)\n164                         if title and toc.children and len(toc.children) == 1:\n165                             child = toc.children[0]\n166                             for refnode in child.traverse(nodes.reference):\n167                                 if refnode['refuri'] == ref and \\\n168                                    not refnode['anchorname']:\n169                                     refnode.children = [nodes.Text(title)]\n170                     if not toc.children:\n171                         # empty toc means: no titles will show up in the toctree\n172                         logger.warning(__('toctree contains reference to document %r that '\n173                                           'doesn\\'t have a title: no link will be generated'),\n174                                        ref, location=toctreenode)\n175                 except KeyError:\n176                     # this is raised if the included file does not exist\n177                     if excluded(self.env.doc2path(ref, None)):\n178                         message = __('toctree contains reference to excluded document %r')\n179                     else:\n180                         message = __('toctree contains reference to nonexisting document %r')\n181 \n182                     logger.warning(message, ref, location=toctreenode)\n183                 else:\n184                     # if titles_only is given, only keep the main title and\n185                     # sub-toctrees\n186                     if titles_only:\n187                         # children of toc are:\n188                         # - list_item + compact_paragraph + (reference and subtoc)\n189                         # - only + subtoc\n190                         # - toctree\n191                         children = cast(Iterable[nodes.Element], toc)\n192 \n193                         # delete everything but the toplevel title(s)\n194                         # and toctrees\n195                         for toplevel in children:\n196                             # nodes with length 1 don't have any children anyway\n197                             if len(toplevel) > 1:\n198                                 subtrees = toplevel.traverse(addnodes.toctree)\n199                                 if subtrees:\n200                                     toplevel[1][:] = subtrees  # type: ignore\n201                                 else:\n202                                     toplevel.pop(1)\n203                     # resolve all sub-toctrees\n204                     for subtocnode in toc.traverse(addnodes.toctree):\n205                         if not (subtocnode.get('hidden', False) and\n206                                 not includehidden):\n207                             i = subtocnode.parent.index(subtocnode) + 1\n208                             for entry in _entries_from_toctree(\n209                                     subtocnode, [refdoc] + parents,\n210                                     subtree=True):\n211                                 subtocnode.parent.insert(i, entry)\n212                                 i += 1\n213                             subtocnode.parent.remove(subtocnode)\n214                     if separate:\n215                         entries.append(toc)\n216                     else:\n217                         children = cast(Iterable[nodes.Element], toc)\n218                         entries.extend(children)\n219             if not subtree and not separate:\n220                 ret = nodes.bullet_list()\n221                 ret += entries\n222                 return [ret]\n223             return entries\n224 \n225         maxdepth = maxdepth or toctree.get('maxdepth', -1)\n226         if not titles_only and toctree.get('titlesonly', False):\n227             titles_only = True\n228         if not includehidden and toctree.get('includehidden', False):\n229             includehidden = True\n230 \n231         # NOTE: previously, this was separate=True, but that leads to artificial\n232         # separation when two or more toctree entries form a logical unit, so\n233         # separating mode is no longer used -- it's kept here for history's sake\n234         tocentries = _entries_from_toctree(toctree, [], separate=False)\n235         if not tocentries:\n236             return None\n237 \n238         newnode = addnodes.compact_paragraph('', '')\n239         caption = toctree.attributes.get('caption')\n240         if caption:\n241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])\n242             caption_node.line = toctree.line\n243             caption_node.source = toctree.source\n244             caption_node.rawsource = toctree['rawcaption']\n245             if hasattr(toctree, 'uid'):\n246                 # move uid to caption_node to translate it\n247                 caption_node.uid = toctree.uid  # type: ignore\n248                 del toctree.uid  # type: ignore\n249             newnode += caption_node\n250         newnode.extend(tocentries)\n251         newnode['toctree'] = True\n252 \n253         # prune the tree to maxdepth, also set toc depth and current classes\n254         _toctree_add_classes(newnode, 1)\n255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)\n256 \n257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found\n258             return None\n259 \n260         # set the target paths in the toctrees (they are not known at TOC\n261         # generation time)\n262         for refnode in newnode.traverse(nodes.reference):\n263             if not url_re.match(refnode['refuri']):\n264                 refnode['refuri'] = builder.get_relative_uri(\n265                     docname, refnode['refuri']) + refnode['anchorname']\n266         return newnode\n267 \n268     def get_toctree_ancestors(self, docname: str) -> List[str]:\n269         parent = {}\n270         for p, children in self.env.toctree_includes.items():\n271             for child in children:\n272                 parent[child] = p\n273         ancestors = []  # type: List[str]\n274         d = docname\n275         while d in parent and d not in ancestors:\n276             ancestors.append(d)\n277             d = parent[d]\n278         return ancestors\n279 \n280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False\n281                        ) -> None:\n282         \"\"\"Utility: Cut a TOC at a specified depth.\"\"\"\n283         for subnode in node.children[:]:\n284             if isinstance(subnode, (addnodes.compact_paragraph,\n285                                     nodes.list_item)):\n286                 # for <p> and <li>, just recurse\n287                 self._toctree_prune(subnode, depth, maxdepth, collapse)\n288             elif isinstance(subnode, nodes.bullet_list):\n289                 # for <ul>, determine if the depth is too large or if the\n290                 # entry is to be collapsed\n291                 if maxdepth > 0 and depth > maxdepth:\n292                     subnode.parent.replace(subnode, [])\n293                 else:\n294                     # cull sub-entries whose parents aren't 'current'\n295                     if (collapse and depth > 1 and\n296                             'iscurrent' not in subnode.parent):\n297                         subnode.parent.remove(subnode)\n298                     else:\n299                         # recurse on visible children\n300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)\n301 \n302     def get_toc_for(self, docname: str, builder: \"Builder\") -> Node:\n303         \"\"\"Return a TOC nodetree -- for use on the same page only!\"\"\"\n304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)\n305         try:\n306             toc = self.env.tocs[docname].deepcopy()\n307             self._toctree_prune(toc, 2, tocdepth)\n308         except KeyError:\n309             # the document does not exist anymore: return a dummy node that\n310             # renders to nothing\n311             return nodes.paragraph()\n312         process_only_nodes(toc, builder.tags)\n313         for node in toc.traverse(nodes.reference):\n314             node['refuri'] = node['anchorname'] or '#'\n315         return toc\n316 \n317     def get_toctree_for(self, docname: str, builder: \"Builder\", collapse: bool,\n318                         **kwargs: Any) -> Element:\n319         \"\"\"Return the global TOC nodetree.\"\"\"\n320         doctree = self.env.get_doctree(self.env.config.master_doc)\n321         toctrees = []  # type: List[Element]\n322         if 'includehidden' not in kwargs:\n323             kwargs['includehidden'] = True\n324         if 'maxdepth' not in kwargs:\n325             kwargs['maxdepth'] = 0\n326         kwargs['collapse'] = collapse\n327         for toctreenode in doctree.traverse(addnodes.toctree):\n328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)\n329             if toctree:\n330                 toctrees.append(toctree)\n331         if not toctrees:\n332             return None\n333         result = toctrees[0]\n334         for toctree in toctrees[1:]:\n335             result.extend(toctree.children)\n336         return result\n",
        "intended_behavior": "This file and its methods, particularly those processing the toctree entries, should include logic to handle file priorities based on their extensions when multiple files with the same name exist. An ideal enhancement would be a configuration option allowing users to specify the order of preference for file extensions. In the absence of such a specification, the system should log a warning when deciding which file to include, promoting transparency in the file selection process."
    },
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/config.py",
        "start": 81,
        "end": 307,
        "class_name": "Config",
        "method_name": null,
        "code": "81 class Config:\n82     \"\"\"Configuration file abstraction.\n83 \n84     The config object makes the values of all config values available as\n85     attributes.\n86 \n87     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n89     to get the value of :confval:`language`, use either ``app.config.language``\n90     or ``env.config.language``.\n91     \"\"\"\n92 \n93     # the values are: (default, what needs to be rebuilt if changed)\n94 \n95     # If you add a value here, don't forget to include it in the\n96     # quickstart.py file template as well as in the docs!\n97 \n98     config_values = {\n99         # general options\n100         'project': ('Python', 'env', []),\n101         'author': ('unknown', 'env', []),\n102         'copyright': ('', 'html', []),\n103         'version': ('', 'env', []),\n104         'release': ('', 'env', []),\n105         'today': ('', 'env', []),\n106         # the real default is locale-dependent\n107         'today_fmt': (None, 'env', [str]),\n108 \n109         'language': (None, 'env', [str]),\n110         'locale_dirs': (['locales'], 'env', []),\n111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n112 \n113         'master_doc': ('index', 'env', []),\n114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n115         'source_encoding': ('utf-8-sig', 'env', []),\n116         'source_parsers': ({}, 'env', []),\n117         'exclude_patterns': ([], 'env', []),\n118         'default_role': (None, 'env', [str]),\n119         'add_function_parentheses': (True, 'env', []),\n120         'add_module_names': (True, 'env', []),\n121         'trim_footnote_reference_space': (False, 'env', []),\n122         'show_authors': (False, 'env', []),\n123         'pygments_style': (None, 'html', [str]),\n124         'highlight_language': ('default', 'env', []),\n125         'highlight_options': ({}, 'env', []),\n126         'templates_path': ([], 'html', []),\n127         'template_bridge': (None, 'html', [str]),\n128         'keep_warnings': (False, 'env', []),\n129         'suppress_warnings': ([], 'env', []),\n130         'modindex_common_prefix': ([], 'html', []),\n131         'rst_epilog': (None, 'env', [str]),\n132         'rst_prolog': (None, 'env', [str]),\n133         'trim_doctest_flags': (True, 'env', []),\n134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n135         'needs_sphinx': (None, None, [str]),\n136         'needs_extensions': ({}, None, []),\n137         'manpages_url': (None, 'env', []),\n138         'nitpicky': (False, None, []),\n139         'nitpick_ignore': ([], None, []),\n140         'numfig': (False, 'env', []),\n141         'numfig_secnum_depth': (1, 'env', []),\n142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n143 \n144         'math_number_all': (False, 'env', []),\n145         'math_eqref_format': (None, 'env', [str]),\n146         'math_numfig': (True, 'env', []),\n147         'tls_verify': (True, 'env', []),\n148         'tls_cacerts': (None, 'env', []),\n149         'user_agent': (None, 'env', [str]),\n150         'smartquotes': (True, 'env', []),\n151         'smartquotes_action': ('qDe', 'env', []),\n152         'smartquotes_excludes': ({'languages': ['ja'],\n153                                   'builders': ['man', 'text']},\n154                                  'env', []),\n155     }  # type: Dict[str, Tuple]\n156 \n157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n158         self.overrides = dict(overrides)\n159         self.values = Config.config_values.copy()\n160         self._raw_config = config\n161         self.setup = config.get('setup', None)  # type: Callable\n162 \n163         if 'extensions' in self.overrides:\n164             if isinstance(self.overrides['extensions'], str):\n165                 config['extensions'] = self.overrides.pop('extensions').split(',')\n166             else:\n167                 config['extensions'] = self.overrides.pop('extensions')\n168         self.extensions = config.get('extensions', [])  # type: List[str]\n169 \n170     @classmethod\n171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n172         \"\"\"Create a Config object from configuration file.\"\"\"\n173         filename = path.join(confdir, CONFIG_FILENAME)\n174         namespace = eval_config_file(filename, tags)\n175         return cls(namespace, overrides or {})\n176 \n177     def convert_overrides(self, name: str, value: Any) -> Any:\n178         if not isinstance(value, str):\n179             return value\n180         else:\n181             defvalue = self.values[name][0]\n182             if self.values[name][2] == Any:\n183                 return value\n184             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n185                 if value == '0':\n186                     # given falsy string from command line option\n187                     return False\n188                 else:\n189                     return bool(value)\n190             elif isinstance(defvalue, dict):\n191                 raise ValueError(__('cannot override dictionary config setting %r, '\n192                                     'ignoring (use %r to set individual elements)') %\n193                                  (name, name + '.key=value'))\n194             elif isinstance(defvalue, list):\n195                 return value.split(',')\n196             elif isinstance(defvalue, int):\n197                 try:\n198                     return int(value)\n199                 except ValueError:\n200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n201                                      (value, name))\n202             elif hasattr(defvalue, '__call__'):\n203                 return value\n204             elif defvalue is not None and not isinstance(defvalue, str):\n205                 raise ValueError(__('cannot override config setting %r with unsupported '\n206                                     'type, ignoring') % name)\n207             else:\n208                 return value\n209 \n210     def pre_init_values(self) -> None:\n211         \"\"\"\n212         Initialize some limited config variables before initialize i18n and loading extensions\n213         \"\"\"\n214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n215         for name in variables:\n216             try:\n217                 if name in self.overrides:\n218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n219                 elif name in self._raw_config:\n220                     self.__dict__[name] = self._raw_config[name]\n221             except ValueError as exc:\n222                 logger.warning(\"%s\", exc)\n223 \n224     def init_values(self) -> None:\n225         config = self._raw_config\n226         for valname, value in self.overrides.items():\n227             try:\n228                 if '.' in valname:\n229                     realvalname, key = valname.split('.', 1)\n230                     config.setdefault(realvalname, {})[key] = value\n231                     continue\n232                 elif valname not in self.values:\n233                     logger.warning(__('unknown config value %r in override, ignoring'),\n234                                    valname)\n235                     continue\n236                 if isinstance(value, str):\n237                     config[valname] = self.convert_overrides(valname, value)\n238                 else:\n239                     config[valname] = value\n240             except ValueError as exc:\n241                 logger.warning(\"%s\", exc)\n242         for name in config:\n243             if name in self.values:\n244                 self.__dict__[name] = config[name]\n245 \n246     def __getattr__(self, name: str) -> Any:\n247         if name.startswith('_'):\n248             raise AttributeError(name)\n249         if name not in self.values:\n250             raise AttributeError(__('No such config value: %s') % name)\n251         default = self.values[name][0]\n252         if hasattr(default, '__call__'):\n253             return default(self)\n254         return default\n255 \n256     def __getitem__(self, name: str) -> str:\n257         return getattr(self, name)\n258 \n259     def __setitem__(self, name: str, value: Any) -> None:\n260         setattr(self, name, value)\n261 \n262     def __delitem__(self, name: str) -> None:\n263         delattr(self, name)\n264 \n265     def __contains__(self, name: str) -> bool:\n266         return name in self.values\n267 \n268     def __iter__(self) -> Generator[ConfigValue, None, None]:\n269         for name, value in self.values.items():\n270             yield ConfigValue(name, getattr(self, name), value[1])\n271 \n272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n273         if name in self.values:\n274             raise ExtensionError(__('Config value %r already present') % name)\n275         else:\n276             self.values[name] = (default, rebuild, types)\n277 \n278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n279         if isinstance(rebuild, str):\n280             rebuild = [rebuild]\n281         return (value for value in self if value.rebuild in rebuild)\n282 \n283     def __getstate__(self) -> Dict:\n284         \"\"\"Obtains serializable data for pickling.\"\"\"\n285         # remove potentially pickling-problematic values from config\n286         __dict__ = {}\n287         for key, value in self.__dict__.items():\n288             if key.startswith('_') or not is_serializable(value):\n289                 pass\n290             else:\n291                 __dict__[key] = value\n292 \n293         # create a picklable copy of values list\n294         __dict__['values'] = {}\n295         for key, value in self.values.items():\n296             real_value = getattr(self, key)\n297             if not is_serializable(real_value):\n298                 # omit unserializable value\n299                 real_value = None\n300 \n301             # types column is also omitted\n302             __dict__['values'][key] = (real_value, value[1], None)\n303 \n304         return __dict__\n305 \n306     def __setstate__(self, state: Dict) -> None:\n307         self.__dict__.update(state)\n",
        "intended_behavior": "Enhance the Config class to support new configuration options that allow specifying the order of preference for file extensions. This would directly address the user's need to influence Sphinx\u2019s behavior regarding file selection when similar filenames exist with different extensions."
    },
    {
        "rel_file_path": "sphinx/registry.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/registry.py",
        "start": 1,
        "end": 462,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.registry\n3     ~~~~~~~~~~~~~~~\n4 \n5     Sphinx component registry.\n6 \n7     :copyright: Copyright 2007-2016 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import traceback\n12 from importlib import import_module\n13 from types import MethodType\n14 from typing import Any, Callable, Dict, Iterator, List, Tuple, Union\n15 \n16 from docutils import nodes\n17 from docutils.io import Input\n18 from docutils.nodes import Element, Node, TextElement\n19 from docutils.parsers import Parser\n20 from docutils.parsers.rst import Directive\n21 from docutils.transforms import Transform\n22 from pkg_resources import iter_entry_points\n23 \n24 from sphinx.builders import Builder\n25 from sphinx.config import Config\n26 from sphinx.domains import Domain, Index, ObjType\n27 from sphinx.domains.std import GenericObject, Target\n28 from sphinx.environment import BuildEnvironment\n29 from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError\n30 from sphinx.extension import Extension\n31 from sphinx.locale import __\n32 from sphinx.parsers import Parser as SphinxParser\n33 from sphinx.roles import XRefRole\n34 from sphinx.util import logging\n35 from sphinx.util.logging import prefixed_warnings\n36 from sphinx.util.typing import RoleFunction, TitleGetter\n37 \n38 if False:\n39     # For type annotation\n40     from typing import Type  # for python3.5.1\n41     from sphinx.application import Sphinx\n42     from sphinx.ext.autodoc import Documenter\n43 \n44 logger = logging.getLogger(__name__)\n45 \n46 # list of deprecated extensions. Keys are extension name.\n47 # Values are Sphinx version that merge the extension.\n48 EXTENSION_BLACKLIST = {\n49     \"sphinxjp.themecore\": \"1.2\"\n50 }\n51 \n52 \n53 class SphinxComponentRegistry:\n54     def __init__(self) -> None:\n55         #: special attrgetter for autodoc; class object -> attrgetter\n56         self.autodoc_attrgettrs = {}    # type: Dict[Type, Callable[[Any, str, Any], Any]]\n57 \n58         #: builders; a dict of builder name -> bulider class\n59         self.builders = {}              # type: Dict[str, Type[Builder]]\n60 \n61         #: autodoc documenters; a dict of documenter name -> documenter class\n62         self.documenters = {}           # type: Dict[str, Type[Documenter]]\n63 \n64         #: css_files; a list of tuple of filename and attributes\n65         self.css_files = []             # type: List[Tuple[str, Dict[str, str]]]\n66 \n67         #: domains; a dict of domain name -> domain class\n68         self.domains = {}               # type: Dict[str, Type[Domain]]\n69 \n70         #: additional directives for domains\n71         #: a dict of domain name -> dict of directive name -> directive\n72         self.domain_directives = {}     # type: Dict[str, Dict[str, Any]]\n73 \n74         #: additional indices for domains\n75         #: a dict of domain name -> list of index class\n76         self.domain_indices = {}        # type: Dict[str, List[Type[Index]]]\n77 \n78         #: additional object types for domains\n79         #: a dict of domain name -> dict of objtype name -> objtype\n80         self.domain_object_types = {}   # type: Dict[str, Dict[str, ObjType]]\n81 \n82         #: additional roles for domains\n83         #: a dict of domain name -> dict of role name -> role impl.\n84         self.domain_roles = {}          # type: Dict[str, Dict[str, Union[RoleFunction, XRefRole]]]  # NOQA\n85 \n86         #: additional enumerable nodes\n87         #: a dict of node class -> tuple of figtype and title_getter function\n88         self.enumerable_nodes = {}      # type: Dict[Type[Node], Tuple[str, TitleGetter]]\n89 \n90         #: HTML inline and block math renderers\n91         #: a dict of name -> tuple of visit function and depart function\n92         self.html_inline_math_renderers = {}    # type: Dict[str, Tuple[Callable, Callable]]\n93         self.html_block_math_renderers = {}     # type: Dict[str, Tuple[Callable, Callable]]\n94 \n95         #: js_files; list of JS paths or URLs\n96         self.js_files = []              # type: List[Tuple[str, Dict[str, str]]]\n97 \n98         #: LaTeX packages; list of package names and its options\n99         self.latex_packages = []        # type: List[Tuple[str, str]]\n100 \n101         #: post transforms; list of transforms\n102         self.post_transforms = []       # type: List[Type[Transform]]\n103 \n104         #: source paresrs; file type -> parser class\n105         self.source_parsers = {}        # type: Dict[str, Type[Parser]]\n106 \n107         #: source inputs; file type -> input class\n108         self.source_inputs = {}         # type: Dict[str, Type[Input]]\n109 \n110         #: source suffix: suffix -> file type\n111         self.source_suffix = {}         # type: Dict[str, str]\n112 \n113         #: custom translators; builder name -> translator class\n114         self.translators = {}           # type: Dict[str, Type[nodes.NodeVisitor]]\n115 \n116         #: custom handlers for translators\n117         #: a dict of builder name -> dict of node name -> visitor and departure functions\n118         self.translation_handlers = {}  # type: Dict[str, Dict[str, Tuple[Callable, Callable]]]\n119 \n120         #: additional transforms; list of transforms\n121         self.transforms = []            # type: List[Type[Transform]]\n122 \n123     def add_builder(self, builder: \"Type[Builder]\", override: bool = False) -> None:\n124         logger.debug('[app] adding builder: %r', builder)\n125         if not hasattr(builder, 'name'):\n126             raise ExtensionError(__('Builder class %s has no \"name\" attribute') % builder)\n127         if builder.name in self.builders and not override:\n128             raise ExtensionError(__('Builder %r already exists (in module %s)') %\n129                                  (builder.name, self.builders[builder.name].__module__))\n130         self.builders[builder.name] = builder\n131 \n132     def preload_builder(self, app: \"Sphinx\", name: str) -> None:\n133         if name is None:\n134             return\n135 \n136         if name not in self.builders:\n137             entry_points = iter_entry_points('sphinx.builders', name)\n138             try:\n139                 entry_point = next(entry_points)\n140             except StopIteration:\n141                 raise SphinxError(__('Builder name %s not registered or available'\n142                                      ' through entry point') % name)\n143 \n144             self.load_extension(app, entry_point.module_name)\n145 \n146     def create_builder(self, app: \"Sphinx\", name: str) -> Builder:\n147         if name not in self.builders:\n148             raise SphinxError(__('Builder name %s not registered') % name)\n149 \n150         return self.builders[name](app)\n151 \n152     def add_domain(self, domain: \"Type[Domain]\", override: bool = False) -> None:\n153         logger.debug('[app] adding domain: %r', domain)\n154         if domain.name in self.domains and not override:\n155             raise ExtensionError(__('domain %s already registered') % domain.name)\n156         self.domains[domain.name] = domain\n157 \n158     def has_domain(self, domain: str) -> bool:\n159         return domain in self.domains\n160 \n161     def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:\n162         for DomainClass in self.domains.values():\n163             domain = DomainClass(env)\n164 \n165             # transplant components added by extensions\n166             domain.directives.update(self.domain_directives.get(domain.name, {}))\n167             domain.roles.update(self.domain_roles.get(domain.name, {}))\n168             domain.indices.extend(self.domain_indices.get(domain.name, []))\n169             for name, objtype in self.domain_object_types.get(domain.name, {}).items():\n170                 domain.add_object_type(name, objtype)\n171 \n172             yield domain\n173 \n174     def add_directive_to_domain(self, domain: str, name: str,\n175                                 cls: \"Type[Directive]\", override: bool = False) -> None:\n176         logger.debug('[app] adding directive to domain: %r', (domain, name, cls))\n177         if domain not in self.domains:\n178             raise ExtensionError(__('domain %s not yet registered') % domain)\n179 \n180         directives = self.domain_directives.setdefault(domain, {})\n181         if name in directives and not override:\n182             raise ExtensionError(__('The %r directive is already registered to domain %s') %\n183                                  (name, domain))\n184         directives[name] = cls\n185 \n186     def add_role_to_domain(self, domain: str, name: str,\n187                            role: Union[RoleFunction, XRefRole], override: bool = False\n188                            ) -> None:\n189         logger.debug('[app] adding role to domain: %r', (domain, name, role))\n190         if domain not in self.domains:\n191             raise ExtensionError(__('domain %s not yet registered') % domain)\n192         roles = self.domain_roles.setdefault(domain, {})\n193         if name in roles and not override:\n194             raise ExtensionError(__('The %r role is already registered to domain %s') %\n195                                  (name, domain))\n196         roles[name] = role\n197 \n198     def add_index_to_domain(self, domain: str, index: \"Type[Index]\",\n199                             override: bool = False) -> None:\n200         logger.debug('[app] adding index to domain: %r', (domain, index))\n201         if domain not in self.domains:\n202             raise ExtensionError(__('domain %s not yet registered') % domain)\n203         indices = self.domain_indices.setdefault(domain, [])\n204         if index in indices and not override:\n205             raise ExtensionError(__('The %r index is already registered to domain %s') %\n206                                  (index.name, domain))\n207         indices.append(index)\n208 \n209     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',\n210                         parse_node: Callable = None, ref_nodeclass: \"Type[TextElement]\" = None,\n211                         objname: str = '', doc_field_types: List = [], override: bool = False\n212                         ) -> None:\n213         logger.debug('[app] adding object type: %r',\n214                      (directivename, rolename, indextemplate, parse_node,\n215                       ref_nodeclass, objname, doc_field_types))\n216 \n217         # create a subclass of GenericObject as the new directive\n218         directive = type(directivename,\n219                          (GenericObject, object),\n220                          {'indextemplate': indextemplate,\n221                           'parse_node': staticmethod(parse_node),\n222                           'doc_field_types': doc_field_types})\n223 \n224         self.add_directive_to_domain('std', directivename, directive)\n225         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))\n226 \n227         object_types = self.domain_object_types.setdefault('std', {})\n228         if directivename in object_types and not override:\n229             raise ExtensionError(__('The %r object_type is already registered') %\n230                                  directivename)\n231         object_types[directivename] = ObjType(objname or directivename, rolename)\n232 \n233     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',\n234                           ref_nodeclass: \"Type[TextElement]\" = None, objname: str = '',\n235                           override: bool = False) -> None:\n236         logger.debug('[app] adding crossref type: %r',\n237                      (directivename, rolename, indextemplate, ref_nodeclass, objname))\n238 \n239         # create a subclass of Target as the new directive\n240         directive = type(directivename,\n241                          (Target, object),\n242                          {'indextemplate': indextemplate})\n243 \n244         self.add_directive_to_domain('std', directivename, directive)\n245         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))\n246 \n247         object_types = self.domain_object_types.setdefault('std', {})\n248         if directivename in object_types and not override:\n249             raise ExtensionError(__('The %r crossref_type is already registered') %\n250                                  directivename)\n251         object_types[directivename] = ObjType(objname or directivename, rolename)\n252 \n253     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:\n254         logger.debug('[app] adding source_suffix: %r, %r', suffix, filetype)\n255         if suffix in self.source_suffix and not override:\n256             raise ExtensionError(__('source_suffix %r is already registered') % suffix)\n257         else:\n258             self.source_suffix[suffix] = filetype\n259 \n260     def add_source_parser(self, parser: \"Type[Parser]\", **kwargs: Any) -> None:\n261         logger.debug('[app] adding search source_parser: %r', parser)\n262 \n263         # create a map from filetype to parser\n264         for filetype in parser.supported:\n265             if filetype in self.source_parsers and not kwargs.get('override'):\n266                 raise ExtensionError(__('source_parser for %r is already registered') %\n267                                      filetype)\n268             else:\n269                 self.source_parsers[filetype] = parser\n270 \n271     def get_source_parser(self, filetype: str) -> \"Type[Parser]\":\n272         try:\n273             return self.source_parsers[filetype]\n274         except KeyError:\n275             raise SphinxError(__('Source parser for %s not registered') % filetype)\n276 \n277     def get_source_parsers(self) -> Dict[str, \"Type[Parser]\"]:\n278         return self.source_parsers\n279 \n280     def create_source_parser(self, app: \"Sphinx\", filename: str) -> Parser:\n281         parser_class = self.get_source_parser(filename)\n282         parser = parser_class()\n283         if isinstance(parser, SphinxParser):\n284             parser.set_application(app)\n285         return parser\n286 \n287     def get_source_input(self, filetype: str) -> \"Type[Input]\":\n288         try:\n289             return self.source_inputs[filetype]\n290         except KeyError:\n291             try:\n292                 # use special source_input for unknown filetype\n293                 return self.source_inputs['*']\n294             except KeyError:\n295                 return None\n296 \n297     def add_translator(self, name: str, translator: \"Type[nodes.NodeVisitor]\",\n298                        override: bool = False) -> None:\n299         logger.debug('[app] Change of translator for the %s builder.', name)\n300         if name in self.translators and not override:\n301             raise ExtensionError(__('Translator for %r already exists') % name)\n302         self.translators[name] = translator\n303 \n304     def add_translation_handlers(self, node: \"Type[Element]\",\n305                                  **kwargs: Tuple[Callable, Callable]) -> None:\n306         logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)\n307         for builder_name, handlers in kwargs.items():\n308             translation_handlers = self.translation_handlers.setdefault(builder_name, {})\n309             try:\n310                 visit, depart = handlers  # unpack once for assertion\n311                 translation_handlers[node.__name__] = (visit, depart)\n312             except ValueError:\n313                 raise ExtensionError(__('kwargs for add_node() must be a (visit, depart) '\n314                                         'function tuple: %r=%r') % (builder_name, handlers))\n315 \n316     def get_translator_class(self, builder: Builder) -> \"Type[nodes.NodeVisitor]\":\n317         return self.translators.get(builder.name,\n318                                     builder.default_translator_class)\n319 \n320     def create_translator(self, builder: Builder, *args: Any) -> nodes.NodeVisitor:\n321         translator_class = self.get_translator_class(builder)\n322         assert translator_class, \"translator not found for %s\" % builder.name\n323         translator = translator_class(*args)\n324 \n325         # transplant handlers for custom nodes to translator instance\n326         handlers = self.translation_handlers.get(builder.name, None)\n327         if handlers is None:\n328             # retry with builder.format\n329             handlers = self.translation_handlers.get(builder.format, {})\n330 \n331         for name, (visit, depart) in handlers.items():\n332             setattr(translator, 'visit_' + name, MethodType(visit, translator))\n333             if depart:\n334                 setattr(translator, 'depart_' + name, MethodType(depart, translator))\n335 \n336         return translator\n337 \n338     def add_transform(self, transform: \"Type[Transform]\") -> None:\n339         logger.debug('[app] adding transform: %r', transform)\n340         self.transforms.append(transform)\n341 \n342     def get_transforms(self) -> List[\"Type[Transform]\"]:\n343         return self.transforms\n344 \n345     def add_post_transform(self, transform: \"Type[Transform]\") -> None:\n346         logger.debug('[app] adding post transform: %r', transform)\n347         self.post_transforms.append(transform)\n348 \n349     def get_post_transforms(self) -> List[\"Type[Transform]\"]:\n350         return self.post_transforms\n351 \n352     def add_documenter(self, objtype: str, documenter: \"Type[Documenter]\") -> None:\n353         self.documenters[objtype] = documenter\n354 \n355     def add_autodoc_attrgetter(self, typ: \"Type\",\n356                                attrgetter: Callable[[Any, str, Any], Any]) -> None:\n357         self.autodoc_attrgettrs[typ] = attrgetter\n358 \n359     def add_css_files(self, filename: str, **attributes: str) -> None:\n360         self.css_files.append((filename, attributes))\n361 \n362     def add_js_file(self, filename: str, **attributes: str) -> None:\n363         logger.debug('[app] adding js_file: %r, %r', filename, attributes)\n364         self.js_files.append((filename, attributes))\n365 \n366     def add_latex_package(self, name: str, options: str) -> None:\n367         logger.debug('[app] adding latex package: %r', name)\n368         self.latex_packages.append((name, options))\n369 \n370     def add_enumerable_node(self, node: \"Type[Node]\", figtype: str,\n371                             title_getter: TitleGetter = None, override: bool = False) -> None:\n372         logger.debug('[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter)\n373         if node in self.enumerable_nodes and not override:\n374             raise ExtensionError(__('enumerable_node %r already registered') % node)\n375         self.enumerable_nodes[node] = (figtype, title_getter)\n376 \n377     def add_html_math_renderer(self, name: str,\n378                                inline_renderers: Tuple[Callable, Callable],\n379                                block_renderers: Tuple[Callable, Callable]) -> None:\n380         logger.debug('[app] adding html_math_renderer: %s, %r, %r',\n381                      name, inline_renderers, block_renderers)\n382         if name in self.html_inline_math_renderers:\n383             raise ExtensionError(__('math renderer %s is already registred') % name)\n384 \n385         self.html_inline_math_renderers[name] = inline_renderers\n386         self.html_block_math_renderers[name] = block_renderers\n387 \n388     def load_extension(self, app: \"Sphinx\", extname: str) -> None:\n389         \"\"\"Load a Sphinx extension.\"\"\"\n390         if extname in app.extensions:  # alread loaded\n391             return\n392         if extname in EXTENSION_BLACKLIST:\n393             logger.warning(__('the extension %r was already merged with Sphinx since '\n394                               'version %s; this extension is ignored.'),\n395                            extname, EXTENSION_BLACKLIST[extname])\n396             return\n397 \n398         # update loading context\n399         prefix = __('while setting up extension %s:') % extname\n400         with prefixed_warnings(prefix):\n401             try:\n402                 mod = import_module(extname)\n403             except ImportError as err:\n404                 logger.verbose(__('Original exception:\\n') + traceback.format_exc())\n405                 raise ExtensionError(__('Could not import extension %s') % extname, err)\n406 \n407             setup = getattr(mod, 'setup', None)\n408             if setup is None:\n409                 logger.warning(__('extension %r has no setup() function; is it really '\n410                                   'a Sphinx extension module?'), extname)\n411                 metadata = {}  # type: Dict[str, Any]\n412             else:\n413                 try:\n414                     metadata = setup(app)\n415                 except VersionRequirementError as err:\n416                     # add the extension name to the version required\n417                     raise VersionRequirementError(\n418                         __('The %s extension used by this project needs at least '\n419                            'Sphinx v%s; it therefore cannot be built with this '\n420                            'version.') % (extname, err)\n421                     )\n422 \n423             if metadata is None:\n424                 metadata = {}\n425             elif not isinstance(metadata, dict):\n426                 logger.warning(__('extension %r returned an unsupported object from '\n427                                   'its setup() function; it should return None or a '\n428                                   'metadata dictionary'), extname)\n429                 metadata = {}\n430 \n431             app.extensions[extname] = Extension(extname, mod, **metadata)\n432 \n433     def get_envversion(self, app: \"Sphinx\") -> Dict[str, str]:\n434         from sphinx.environment import ENV_VERSION\n435         envversion = {ext.name: ext.metadata['env_version'] for ext in app.extensions.values()\n436                       if ext.metadata.get('env_version')}\n437         envversion['sphinx'] = ENV_VERSION\n438         return envversion\n439 \n440 \n441 def merge_source_suffix(app: \"Sphinx\", config: Config) -> None:\n442     \"\"\"Merge source_suffix which specified by user and added by extensions.\"\"\"\n443     for suffix, filetype in app.registry.source_suffix.items():\n444         if suffix not in app.config.source_suffix:\n445             app.config.source_suffix[suffix] = filetype\n446         elif app.config.source_suffix[suffix] is None:\n447             # filetype is not specified (default filetype).\n448             # So it overrides default filetype by extensions setting.\n449             app.config.source_suffix[suffix] = filetype\n450 \n451     # copy config.source_suffix to registry\n452     app.registry.source_suffix = app.config.source_suffix\n453 \n454 \n455 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n456     app.connect('config-inited', merge_source_suffix)\n457 \n458     return {\n459         'version': 'builtin',\n460         'parallel_read_safe': True,\n461         'parallel_write_safe': True,\n462     }\n",
        "intended_behavior": "Ensure that the method responsible for registering new parsers, such as .md parsers, correctly respects the file extension preferences specified in the configuration. This might involve adjusting how Sphinx prioritizes file extensions when multiple parsers are capable of processing a given file."
    }
]