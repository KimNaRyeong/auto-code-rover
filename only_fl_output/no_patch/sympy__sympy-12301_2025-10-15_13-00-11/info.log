2025-10-15 13:00:11.683 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 13:00:16.417 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=304, output_tokens=12, cost=0.003400
2025-10-15 13:00:31.921 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=484, output_tokens=533, cost=0.020830
2025-10-15 13:02:32.066 | INFO     | registered non reproducing test 0
2025-10-15 13:02:48.610 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1290, output_tokens=666, cost=0.032880
2025-10-15 13:02:49.789 | INFO     | registered non reproducing test 1
2025-10-15 13:03:06.371 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1966, output_tokens=643, cost=0.038950
2025-10-15 13:03:07.633 | INFO     | registered non reproducing test 2
2025-10-15 13:03:07.633 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 13:03:07.639 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:03:17.829 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=374, cost=0.017330
2025-10-15 13:03:17.835 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:03:20.887 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=728, output_tokens=75, cost=0.009530
2025-10-15 13:03:20.889 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/simplify/tests/test_cse.py", 433, 5)': old result is ['sympy/simplify/tests/test_cse.py', '433', '5'], new result  is ['sympy/simplify/tests/test_cse.py', 433, 5]
2025-10-15 13:03:20.890 | DEBUG    | Extracted a valid json.
2025-10-15 13:03:20.890 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "get_code_around_line(\"sympy/simplify/tests/test_cse.py\", 433, 5)",
        "search_class(\"Mul\")",
        "search_method_in_file(\"test_issue_11230\", \"sympy/simplify/tests/test_cse.py\")"
    ],
    "bug_locations": []
}
2025-10-15 13:03:20.893 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/simplify/tests/test_cse.py", 433, 5)': old result is ['sympy/simplify/tests/test_cse.py', '433', '5'], new result  is ['sympy/simplify/tests/test_cse.py', 433, 5]
2025-10-15 13:03:20.924 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:03:20.925 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:03:44.437 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1905, output_tokens=814, cost=0.043470
2025-10-15 13:03:44.452 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:03:56.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2935, output_tokens=446, cost=0.042730
2025-10-15 13:03:56.130 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:04:00.113 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=108, cost=0.011240
2025-10-15 13:04:00.114 | DEBUG    | Extracted a valid json.
2025-10-15 13:04:00.114 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/mul.py",
            "class": "Mul",
            "method": "",
            "intended_behavior": "The intended behavior around `Mul` should ensure that any simplification or transformation processes that involve `Mul` instances are correctly identified and processed. This includes correctly preserving, transforming, or simplifying `Mul` instances in ways consistent with the expectations of the sympy simplification tests."
        }
    ]
}
2025-10-15 13:04:00.121 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())

</code><intended_behavior>The intended behavior around `Mul` should ensure that any simplification or transformation processes that involve `Mul` instances are correctly identified and processed. This includes correctly preserving, transforming, or simplifying `Mul` instances in ways consistent with the expectations of the sympy simplification tests.</intended_behavior>]
2025-10-15 13:04:00.122 | INFO     | Search completed. Bug locations: [<file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())

</code><intended_behavior>The intended behavior around `Mul` should ensure that any simplification or transformation processes that involve `Mul` instances are correctly identified and processed. This includes correctly preserving, transforming, or simplifying `Mul` instances in ways consistent with the expectations of the sympy simplification tests.</intended_behavior>]
2025-10-15 13:04:00.122 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 13:04:00.122 | INFO     | Search-only: skipping patch selection
2025-10-15 13:04:00.198 | INFO     | Task sympy__sympy-12301 completed successfully.
2025-10-15 13:04:00.199 | INFO     | No patch generated. You can try running ACR again.
