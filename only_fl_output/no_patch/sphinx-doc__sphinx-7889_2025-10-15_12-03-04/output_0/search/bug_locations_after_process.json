[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2125,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import importlib\n14 import re\n15 import warnings\n16 from inspect import Parameter, Signature\n17 from types import ModuleType\n18 from typing import (\n19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union\n20 )\n21 \n22 from docutils.statemachine import StringList\n23 \n24 import sphinx\n25 from sphinx.application import Sphinx\n26 from sphinx.config import Config, ENUM\n27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n28 from sphinx.environment import BuildEnvironment\n29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members\n30 from sphinx.ext.autodoc.mock import mock\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect\n34 from sphinx.util import logging\n35 from sphinx.util import split_full_qualified_name\n36 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43     from sphinx.ext.autodoc.directive import DocumenterBridge\n44 \n45 \n46 logger = logging.getLogger(__name__)\n47 \n48 \n49 # This type isn't exposed directly in any modules, but can be found\n50 # here in most Python versions\n51 MethodDescriptorType = type(type.__subclasses__)\n52 \n53 \n54 #: extended signature RE: with explicit module name separated by ::\n55 py_ext_sig_re = re.compile(\n56     r'''^ ([\\w.]+::)?            # explicit module name\n57           ([\\w.]+\\.)?            # module and/or class name(s)\n58           (\\w+)  \\s*             # thing name\n59           (?: \\((.*)\\)           # optional: arguments\n60            (?:\\s* -> \\s* (.*))?  #           return annotation\n61           )? $                   # and nothing more\n62           ''', re.VERBOSE)\n63 \n64 \n65 def identity(x: Any) -> Any:\n66     return x\n67 \n68 \n69 ALL = object()\n70 UNINITIALIZED_ATTR = object()\n71 INSTANCEATTR = object()\n72 SLOTSATTR = object()\n73 \n74 \n75 def members_option(arg: Any) -> Union[object, List[str]]:\n76     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n77     if arg is None or arg is True:\n78         return ALL\n79     return [x.strip() for x in arg.split(',') if x.strip()]\n80 \n81 \n82 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n83     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n84     if arg is None:\n85         return ALL\n86     return {x.strip() for x in arg.split(',') if x.strip()}\n87 \n88 \n89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n90     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n91     if arg is None:\n92         return 'object'\n93     else:\n94         return arg\n95 \n96 \n97 def member_order_option(arg: Any) -> Optional[str]:\n98     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n99     if arg is None:\n100         return None\n101     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n102         return arg\n103     else:\n104         raise ValueError(__('invalid value for member-order option: %s') % arg)\n105 \n106 \n107 SUPPRESS = object()\n108 \n109 \n110 def annotation_option(arg: Any) -> Any:\n111     if arg is None:\n112         # suppress showing the representation of the object\n113         return SUPPRESS\n114     else:\n115         return arg\n116 \n117 \n118 def bool_option(arg: Any) -> bool:\n119     \"\"\"Used to convert flag options to auto directives.  (Instead of\n120     directives.flag(), which returns None).\n121     \"\"\"\n122     return True\n123 \n124 \n125 def merge_special_members_option(options: Dict) -> None:\n126     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n127     if 'special-members' in options and options['special-members'] is not ALL:\n128         if options.get('members') is ALL:\n129             pass\n130         elif options.get('members'):\n131             for member in options['special-members']:\n132                 if member not in options['members']:\n133                     options['members'].append(member)\n134         else:\n135             options['members'] = options['special-members']\n136 \n137 \n138 # Some useful event listener factories for autodoc-process-docstring.\n139 \n140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n141     \"\"\"Return a listener that removes the first *pre* and last *post*\n142     lines of every docstring.  If *what* is a sequence of strings,\n143     only docstrings of a type in *what* will be processed.\n144 \n145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n146 \n147        from sphinx.ext.autodoc import cut_lines\n148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n149 \n150     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n151     \"\"\"\n152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n153                 ) -> None:\n154         if what and what_ not in what:\n155             return\n156         del lines[:pre]\n157         if post:\n158             # remove one trailing blank line.\n159             if lines and not lines[-1]:\n160                 lines.pop(-1)\n161             del lines[-post:]\n162         # make sure there is a blank line at the end\n163         if lines and lines[-1]:\n164             lines.append('')\n165     return process\n166 \n167 \n168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n169             exclude: bool = False) -> Callable:\n170     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n171     lines between lines that match the *marker* regular expression.  If no line\n172     matches, the resulting docstring would be empty, so no change will be made\n173     unless *keepempty* is true.\n174 \n175     If *what* is a sequence of strings, only docstrings of a type in *what* will\n176     be processed.\n177     \"\"\"\n178     marker_re = re.compile(marker)\n179 \n180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n181                 ) -> None:\n182         if what and what_ not in what:\n183             return\n184         deleted = 0\n185         delete = not exclude\n186         orig_lines = lines[:]\n187         for i, line in enumerate(orig_lines):\n188             if delete:\n189                 lines.pop(i - deleted)\n190                 deleted += 1\n191             if marker_re.match(line):\n192                 delete = not delete\n193                 if delete:\n194                     lines.pop(i - deleted)\n195                     deleted += 1\n196         if not lines and not keepempty:\n197             lines[:] = orig_lines\n198         # make sure there is a blank line at the end\n199         if lines and lines[-1]:\n200             lines.append('')\n201     return process\n202 \n203 \n204 # This class is used only in ``sphinx.ext.autodoc.directive``,\n205 # But we define this class here to keep compatibility (see #4538)\n206 class Options(dict):\n207     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n208     def __getattr__(self, name: str) -> Any:\n209         try:\n210             return self[name.replace('_', '-')]\n211         except KeyError:\n212             return None\n213 \n214 \n215 class Documenter:\n216     \"\"\"\n217     A Documenter knows how to autodocument a single object type.  When\n218     registered with the AutoDirective, it will be used to document objects\n219     of that type when needed by autodoc.\n220 \n221     Its *objtype* attribute selects what auto directive it is assigned to\n222     (the directive name is 'auto' + objtype), and what directive it generates\n223     by default, though that can be overridden by an attribute called\n224     *directivetype*.\n225 \n226     A Documenter has an *option_spec* that works like a docutils directive's;\n227     in fact, it will be used to parse an auto directive's options that matches\n228     the documenter.\n229     \"\"\"\n230     #: name by which the directive is called (auto...) and the default\n231     #: generated directive name\n232     objtype = 'object'\n233     #: indentation by which to indent the directive content\n234     content_indent = '   '\n235     #: priority if multiple documenters return True from can_document_member\n236     priority = 0\n237     #: order if autodoc_member_order is set to 'groupwise'\n238     member_order = 0\n239     #: true if the generated content may contain titles\n240     titles_allowed = False\n241 \n242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n243 \n244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n245         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n247 \n248     @classmethod\n249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n250                             ) -> bool:\n251         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n252         raise NotImplementedError('must be implemented in subclasses')\n253 \n254     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n255         self.directive = directive\n256         self.env = directive.env    # type: BuildEnvironment\n257         self.options = directive.genopt\n258         self.name = name\n259         self.indent = indent\n260         # the module and object path within the module, and the fully\n261         # qualified name (all set after resolve_name succeeds)\n262         self.modname = None         # type: str\n263         self.module = None          # type: ModuleType\n264         self.objpath = None         # type: List[str]\n265         self.fullname = None        # type: str\n266         # extra signature items (arguments and return annotation,\n267         # also set after resolve_name succeeds)\n268         self.args = None            # type: str\n269         self.retann = None          # type: str\n270         # the object to document (set after import_object succeeds)\n271         self.object = None          # type: Any\n272         self.object_name = None     # type: str\n273         # the parent/owner of the object to document\n274         self.parent = None          # type: Any\n275         # the module analyzer to get at attribute docs, or None\n276         self.analyzer = None        # type: ModuleAnalyzer\n277 \n278     @property\n279     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n280         \"\"\"Returns registered Documenter classes\"\"\"\n281         return self.env.app.registry.documenters\n282 \n283     def add_line(self, line: str, source: str, *lineno: int) -> None:\n284         \"\"\"Append one line of generated reST to the output.\"\"\"\n285         if line.strip():  # not a blank line\n286             self.directive.result.append(self.indent + line, source, *lineno)\n287         else:\n288             self.directive.result.append('', source, *lineno)\n289 \n290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n291                      ) -> Tuple[str, List[str]]:\n292         \"\"\"Resolve the module and name of the object to document given by the\n293         arguments and the current module/class.\n294 \n295         Must return a pair of the module name and a chain of attributes; for\n296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n297         ``zipfile.ZipFile.open`` method.\n298         \"\"\"\n299         raise NotImplementedError('must be implemented in subclasses')\n300 \n301     def parse_name(self) -> bool:\n302         \"\"\"Determine what module to import and what attribute to document.\n303 \n304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n305         *self.args* and *self.retann* if parsing and resolving was successful.\n306         \"\"\"\n307         # first, parse the definition -- auto directives for classes and\n308         # functions can contain a signature which is then used instead of\n309         # an autogenerated one\n310         try:\n311             explicit_modname, path, base, args, retann = \\\n312                 py_ext_sig_re.match(self.name).groups()\n313         except AttributeError:\n314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n315                            type='autodoc')\n316             return False\n317 \n318         # support explicit module and class name separation via ::\n319         if explicit_modname is not None:\n320             modname = explicit_modname[:-2]\n321             parents = path.rstrip('.').split('.') if path else []\n322         else:\n323             modname = None\n324             parents = []\n325 \n326         with mock(self.env.config.autodoc_mock_imports):\n327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n328 \n329         if not self.modname:\n330             return False\n331 \n332         self.args = args\n333         self.retann = retann\n334         self.fullname = (self.modname or '') + \\\n335                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n336         return True\n337 \n338     def import_object(self) -> bool:\n339         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n340         it as *self.object*.\n341 \n342         Returns True if successful, False if an error occurred.\n343         \"\"\"\n344         with mock(self.env.config.autodoc_mock_imports):\n345             try:\n346                 ret = import_object(self.modname, self.objpath, self.objtype,\n347                                     attrgetter=self.get_attr,\n348                                     warningiserror=self.env.config.autodoc_warningiserror)\n349                 self.module, self.parent, self.object_name, self.object = ret\n350                 return True\n351             except ImportError as exc:\n352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n353                 self.env.note_reread()\n354                 return False\n355 \n356     def get_real_modname(self) -> str:\n357         \"\"\"Get the real module name of an object to document.\n358 \n359         It can differ from the name of the module through which the object was\n360         imported.\n361         \"\"\"\n362         return self.get_attr(self.object, '__module__', None) or self.modname\n363 \n364     def check_module(self) -> bool:\n365         \"\"\"Check if *self.object* is really defined in the module given by\n366         *self.modname*.\n367         \"\"\"\n368         if self.options.imported_members:\n369             return True\n370 \n371         subject = inspect.unpartial(self.object)\n372         modname = self.get_attr(subject, '__module__', None)\n373         if modname and modname != self.modname:\n374             return False\n375         return True\n376 \n377     def format_args(self, **kwargs: Any) -> str:\n378         \"\"\"Format the argument signature of *self.object*.\n379 \n380         Should return None if the object does not have a signature.\n381         \"\"\"\n382         return None\n383 \n384     def format_name(self) -> str:\n385         \"\"\"Format the name of *self.object*.\n386 \n387         This normally should be something that can be parsed by the generated\n388         directive, but doesn't need to be (Sphinx will display it unparsed\n389         then).\n390         \"\"\"\n391         # normally the name doesn't contain the module (except for module\n392         # directives of course)\n393         return '.'.join(self.objpath) or self.modname\n394 \n395     def _call_format_args(self, **kwargs: Any) -> str:\n396         if kwargs:\n397             try:\n398                 return self.format_args(**kwargs)\n399             except TypeError:\n400                 # avoid chaining exceptions, by putting nothing here\n401                 pass\n402 \n403         # retry without arguments for old documenters\n404         return self.format_args()\n405 \n406     def format_signature(self, **kwargs: Any) -> str:\n407         \"\"\"Format the signature (arguments and return annotation) of the object.\n408 \n409         Let the user process it via the ``autodoc-process-signature`` event.\n410         \"\"\"\n411         if self.args is not None:\n412             # signature given explicitly\n413             args = \"(%s)\" % self.args\n414             retann = self.retann\n415         else:\n416             # try to introspect the signature\n417             try:\n418                 retann = None\n419                 args = self._call_format_args(**kwargs)\n420                 if args:\n421                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n422                     if matched:\n423                         args = matched.group(1)\n424                         retann = matched.group(2)\n425             except Exception as exc:\n426                 logger.warning(__('error while formatting arguments for %s: %s'),\n427                                self.fullname, exc, type='autodoc')\n428                 args = None\n429 \n430         result = self.env.events.emit_firstresult('autodoc-process-signature',\n431                                                   self.objtype, self.fullname,\n432                                                   self.object, self.options, args, retann)\n433         if result:\n434             args, retann = result\n435 \n436         if args is not None:\n437             return args + ((' -> %s' % retann) if retann else '')\n438         else:\n439             return ''\n440 \n441     def add_directive_header(self, sig: str) -> None:\n442         \"\"\"Add the directive header and options to the generated content.\"\"\"\n443         domain = getattr(self, 'domain', 'py')\n444         directive = getattr(self, 'directivetype', self.objtype)\n445         name = self.format_name()\n446         sourcename = self.get_sourcename()\n447 \n448         # one signature per line, indented by column\n449         prefix = '.. %s:%s:: ' % (domain, directive)\n450         for i, sig_line in enumerate(sig.split(\"\\n\")):\n451             self.add_line('%s%s%s' % (prefix, name, sig_line),\n452                           sourcename)\n453             if i == 0:\n454                 prefix = \" \" * len(prefix)\n455 \n456         if self.options.noindex:\n457             self.add_line('   :noindex:', sourcename)\n458         if self.objpath:\n459             # Be explicit about the module, this is necessary since .. class::\n460             # etc. don't support a prepended module name\n461             self.add_line('   :module: %s' % self.modname, sourcename)\n462 \n463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n464         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n465         if encoding is not None:\n466             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n467                           % self.__class__.__name__,\n468                           RemovedInSphinx40Warning, stacklevel=2)\n469         if ignore is not None:\n470             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n471                           % self.__class__.__name__,\n472                           RemovedInSphinx50Warning, stacklevel=2)\n473         docstring = getdoc(self.object, self.get_attr,\n474                            self.env.config.autodoc_inherit_docstrings,\n475                            self.parent, self.object_name)\n476         if docstring:\n477             tab_width = self.directive.state.document.settings.tab_width\n478             return [prepare_docstring(docstring, ignore, tab_width)]\n479         return []\n480 \n481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n482         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n483         for docstringlines in docstrings:\n484             if self.env.app:\n485                 # let extensions preprocess docstrings\n486                 self.env.app.emit('autodoc-process-docstring',\n487                                   self.objtype, self.fullname, self.object,\n488                                   self.options, docstringlines)\n489             yield from docstringlines\n490 \n491     def get_sourcename(self) -> str:\n492         if self.analyzer:\n493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n494         return 'docstring of %s' % self.fullname\n495 \n496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n497         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n498         # set sourcename and add content from attribute documentation\n499         sourcename = self.get_sourcename()\n500         if self.analyzer:\n501             attr_docs = self.analyzer.find_attr_docs()\n502             if self.objpath:\n503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n504                 if key in attr_docs:\n505                     no_docstring = True\n506                     # make a copy of docstring for attributes to avoid cache\n507                     # the change of autodoc-process-docstring event.\n508                     docstrings = [list(attr_docs[key])]\n509 \n510                     for i, line in enumerate(self.process_doc(docstrings)):\n511                         self.add_line(line, sourcename, i)\n512 \n513         # add content from docstrings\n514         if not no_docstring:\n515             docstrings = self.get_doc()\n516             if not docstrings:\n517                 # append at least a dummy docstring, so that the event\n518                 # autodoc-process-docstring is fired and can add some\n519                 # content if desired\n520                 docstrings.append([])\n521             for i, line in enumerate(self.process_doc(docstrings)):\n522                 self.add_line(line, sourcename, i)\n523 \n524         # add additional content (e.g. from document), if present\n525         if more_content:\n526             for line, src in zip(more_content.data, more_content.items):\n527                 self.add_line(line, src[0], src[1])\n528 \n529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n530         \"\"\"Return `(members_check_module, members)` where `members` is a\n531         list of `(membername, member)` pairs of the members of *self.object*.\n532 \n533         If *want_all* is True, return all members.  Else, only return those\n534         members given by *self.options.members* (which may also be none).\n535         \"\"\"\n536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n537         if not want_all:\n538             if not self.options.members:\n539                 return False, []\n540             # specific members given\n541             selected = []\n542             for name in self.options.members:\n543                 if name in members:\n544                     selected.append((name, members[name].value))\n545                 else:\n546                     logger.warning(__('missing attribute %s in object %s') %\n547                                    (name, self.fullname), type='autodoc')\n548             return False, selected\n549         elif self.options.inherited_members:\n550             return False, [(m.name, m.value) for m in members.values()]\n551         else:\n552             return False, [(m.name, m.value) for m in members.values()\n553                            if m.directly_defined]\n554 \n555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n556                        ) -> List[Tuple[str, Any, bool]]:\n557         \"\"\"Filter the given member list.\n558 \n559         Members are skipped if\n560 \n561         - they are private (except if given explicitly or the private-members\n562           option is set)\n563         - they are special methods (except if given explicitly or the\n564           special-members option is set)\n565         - they are undocumented (except if the undoc-members option is set)\n566 \n567         The user can override the skipping decision by connecting to the\n568         ``autodoc-skip-member`` event.\n569         \"\"\"\n570         def is_filtered_inherited_member(name: str) -> bool:\n571             if inspect.isclass(self.object):\n572                 for cls in self.object.__mro__:\n573                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n574                         # given member is a member of specified *super class*\n575                         return True\n576                     elif name in cls.__dict__:\n577                         return False\n578 \n579             return False\n580 \n581         ret = []\n582 \n583         # search for members in source code too\n584         namespace = '.'.join(self.objpath)  # will be empty for modules\n585 \n586         if self.analyzer:\n587             attr_docs = self.analyzer.find_attr_docs()\n588         else:\n589             attr_docs = {}\n590 \n591         # process members and determine which to skip\n592         for (membername, member) in members:\n593             # if isattr is True, the member is documented as an attribute\n594             if member is INSTANCEATTR:\n595                 isattr = True\n596             else:\n597                 isattr = False\n598 \n599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n600                          self.parent, self.object_name)\n601             if not isinstance(doc, str):\n602                 # Ignore non-string __doc__\n603                 doc = None\n604 \n605             # if the member __doc__ is the same as self's __doc__, it's just\n606             # inherited and therefore not the member's doc\n607             cls = self.get_attr(member, '__class__', None)\n608             if cls:\n609                 cls_doc = self.get_attr(cls, '__doc__', None)\n610                 if cls_doc == doc:\n611                     doc = None\n612             has_doc = bool(doc)\n613 \n614             metadata = extract_metadata(doc)\n615             if 'private' in metadata:\n616                 # consider a member private if docstring has \"private\" metadata\n617                 isprivate = True\n618             elif 'public' in metadata:\n619                 # consider a member public if docstring has \"public\" metadata\n620                 isprivate = False\n621             else:\n622                 isprivate = membername.startswith('_')\n623 \n624             keep = False\n625             if safe_getattr(member, '__sphinx_mock__', False):\n626                 # mocked module or object\n627                 pass\n628             elif want_all and membername.startswith('__') and \\\n629                     membername.endswith('__') and len(membername) > 4:\n630                 # special __methods__\n631                 if self.options.special_members is ALL:\n632                     if membername == '__doc__':\n633                         keep = False\n634                     elif is_filtered_inherited_member(membername):\n635                         keep = False\n636                     else:\n637                         keep = has_doc or self.options.undoc_members\n638                 elif self.options.special_members:\n639                     if membername in self.options.special_members:\n640                         keep = has_doc or self.options.undoc_members\n641             elif (namespace, membername) in attr_docs:\n642                 if want_all and isprivate:\n643                     # ignore members whose name starts with _ by default\n644                     keep = self.options.private_members\n645                 else:\n646                     # keep documented attributes\n647                     keep = True\n648                 isattr = True\n649             elif want_all and isprivate:\n650                 # ignore members whose name starts with _ by default\n651                 keep = self.options.private_members and \\\n652                     (has_doc or self.options.undoc_members)\n653             else:\n654                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n655                     keep = False\n656                 else:\n657                     # ignore undocumented members if :undoc-members: is not given\n658                     keep = has_doc or self.options.undoc_members\n659 \n660             # give the user a chance to decide whether this member\n661             # should be skipped\n662             if self.env.app:\n663                 # let extensions preprocess docstrings\n664                 try:\n665                     skip_user = self.env.app.emit_firstresult(\n666                         'autodoc-skip-member', self.objtype, membername, member,\n667                         not keep, self.options)\n668                     if skip_user is not None:\n669                         keep = not skip_user\n670                 except Exception as exc:\n671                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n672                                       'the following exception was raised:\\n%s'),\n673                                    member, exc, type='autodoc')\n674                     keep = False\n675 \n676             if keep:\n677                 ret.append((membername, member, isattr))\n678 \n679         return ret\n680 \n681     def document_members(self, all_members: bool = False) -> None:\n682         \"\"\"Generate reST for member documentation.\n683 \n684         If *all_members* is True, do all members, else those given by\n685         *self.options.members*.\n686         \"\"\"\n687         # set current namespace for finding members\n688         self.env.temp_data['autodoc:module'] = self.modname\n689         if self.objpath:\n690             self.env.temp_data['autodoc:class'] = self.objpath[0]\n691 \n692         want_all = all_members or self.options.inherited_members or \\\n693             self.options.members is ALL\n694         # find out which members are documentable\n695         members_check_module, members = self.get_object_members(want_all)\n696 \n697         # remove members given by exclude-members\n698         if self.options.exclude_members:\n699             members = [\n700                 (membername, member) for (membername, member) in members\n701                 if (\n702                     self.options.exclude_members is ALL or\n703                     membername not in self.options.exclude_members\n704                 )\n705             ]\n706 \n707         # document non-skipped members\n708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n709         for (mname, member, isattr) in self.filter_members(members, want_all):\n710             classes = [cls for cls in self.documenters.values()\n711                        if cls.can_document_member(member, mname, isattr, self)]\n712             if not classes:\n713                 # don't know how to document this member\n714                 continue\n715             # prefer the documenter with the highest priority\n716             classes.sort(key=lambda cls: cls.priority)\n717             # give explicitly separated module name, so that members\n718             # of inner classes can be documented\n719             full_mname = self.modname + '::' + \\\n720                 '.'.join(self.objpath + [mname])\n721             documenter = classes[-1](self.directive, full_mname, self.indent)\n722             memberdocumenters.append((documenter, isattr))\n723 \n724         member_order = self.options.member_order or self.env.config.autodoc_member_order\n725         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n726 \n727         for documenter, isattr in memberdocumenters:\n728             documenter.generate(\n729                 all_members=True, real_modname=self.real_modname,\n730                 check_module=members_check_module and not isattr)\n731 \n732         # reset current objects\n733         self.env.temp_data['autodoc:module'] = None\n734         self.env.temp_data['autodoc:class'] = None\n735 \n736     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n737                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n738         \"\"\"Sort the given member list.\"\"\"\n739         if order == 'groupwise':\n740             # sort by group; alphabetically within groups\n741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n742         elif order == 'bysource':\n743             if self.analyzer:\n744                 # sort by source order, by virtue of the module analyzer\n745                 tagorder = self.analyzer.tagorder\n746 \n747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n748                     fullname = entry[0].name.split('::')[1]\n749                     return tagorder.get(fullname, len(tagorder))\n750                 documenters.sort(key=keyfunc)\n751             else:\n752                 # Assume that member discovery order matches source order.\n753                 # This is a reasonable assumption in Python 3.6 and up, where\n754                 # module.__dict__ is insertion-ordered.\n755                 pass\n756         else:  # alphabetical\n757             documenters.sort(key=lambda e: e[0].name)\n758 \n759         return documenters\n760 \n761     def generate(self, more_content: Any = None, real_modname: str = None,\n762                  check_module: bool = False, all_members: bool = False) -> None:\n763         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n764         its members.\n765 \n766         If *more_content* is given, include that content. If *real_modname* is\n767         given, use that module name to find attribute docs. If *check_module* is\n768         True, only generate if the object is defined in the module name it is\n769         imported from. If *all_members* is True, document all members.\n770         \"\"\"\n771         if not self.parse_name():\n772             # need a module to import\n773             logger.warning(\n774                 __('don\\'t know which module to import for autodocumenting '\n775                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n776                    'in the document, or giving an explicit module name)') %\n777                 self.name, type='autodoc')\n778             return\n779 \n780         # now, import the module and get object to document\n781         if not self.import_object():\n782             return\n783 \n784         # If there is no real module defined, figure out which to use.\n785         # The real module is used in the module analyzer to look up the module\n786         # where the attribute documentation would actually be found in.\n787         # This is used for situations where you have a module that collects the\n788         # functions and classes of internal submodules.\n789         guess_modname = self.get_real_modname()\n790         self.real_modname = real_modname or guess_modname\n791 \n792         # try to also get a source code analyzer for attribute docs\n793         try:\n794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n795             # parse right now, to get PycodeErrors on parsing (results will\n796             # be cached anyway)\n797             self.analyzer.find_attr_docs()\n798         except PycodeError as exc:\n799             logger.debug('[autodoc] module analyzer failed: %s', exc)\n800             # no source file -- e.g. for builtin and C modules\n801             self.analyzer = None\n802             # at least add the module.__file__ as a dependency\n803             if hasattr(self.module, '__file__') and self.module.__file__:\n804                 self.directive.filename_set.add(self.module.__file__)\n805         else:\n806             self.directive.filename_set.add(self.analyzer.srcname)\n807 \n808         if self.real_modname != guess_modname:\n809             # Add module to dependency list if target object is defined in other module.\n810             try:\n811                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n812                 self.directive.filename_set.add(analyzer.srcname)\n813             except PycodeError:\n814                 pass\n815 \n816         # check __module__ of object (for members not given explicitly)\n817         if check_module:\n818             if not self.check_module():\n819                 return\n820 \n821         sourcename = self.get_sourcename()\n822 \n823         # make sure that the result starts with an empty line.  This is\n824         # necessary for some situations where another directive preprocesses\n825         # reST and no starting newline is present\n826         self.add_line('', sourcename)\n827 \n828         # format the object's signature, if any\n829         sig = self.format_signature()\n830 \n831         # generate the directive header and options, if applicable\n832         self.add_directive_header(sig)\n833         self.add_line('', sourcename)\n834 \n835         # e.g. the module directive doesn't have content\n836         self.indent += self.content_indent\n837 \n838         # add all content (from docstrings, attribute docs etc.)\n839         self.add_content(more_content)\n840 \n841         # document members, if possible\n842         self.document_members(all_members)\n843 \n844 \n845 class ModuleDocumenter(Documenter):\n846     \"\"\"\n847     Specialized Documenter subclass for modules.\n848     \"\"\"\n849     objtype = 'module'\n850     content_indent = ''\n851     titles_allowed = True\n852 \n853     option_spec = {\n854         'members': members_option, 'undoc-members': bool_option,\n855         'noindex': bool_option, 'inherited-members': inherited_members_option,\n856         'show-inheritance': bool_option, 'synopsis': identity,\n857         'platform': identity, 'deprecated': bool_option,\n858         'member-order': member_order_option, 'exclude-members': members_set_option,\n859         'private-members': bool_option, 'special-members': members_option,\n860         'imported-members': bool_option, 'ignore-module-all': bool_option\n861     }  # type: Dict[str, Callable]\n862 \n863     def __init__(self, *args: Any) -> None:\n864         super().__init__(*args)\n865         merge_special_members_option(self.options)\n866         self.__all__ = None\n867 \n868     @classmethod\n869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n870                             ) -> bool:\n871         # don't document submodules automatically\n872         return False\n873 \n874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n875                      ) -> Tuple[str, List[str]]:\n876         if modname is not None:\n877             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n878                            type='autodoc')\n879         return (path or '') + base, []\n880 \n881     def parse_name(self) -> bool:\n882         ret = super().parse_name()\n883         if self.args or self.retann:\n884             logger.warning(__('signature arguments or return annotation '\n885                               'given for automodule %s') % self.fullname,\n886                            type='autodoc')\n887         return ret\n888 \n889     def import_object(self) -> Any:\n890         def is_valid_module_all(__all__: Any) -> bool:\n891             \"\"\"Check the given *__all__* is valid for a module.\"\"\"\n892             if (isinstance(__all__, (list, tuple)) and\n893                     all(isinstance(e, str) for e in __all__)):\n894                 return True\n895             else:\n896                 return False\n897 \n898         ret = super().import_object()\n899 \n900         if not self.options.ignore_module_all:\n901             __all__ = getattr(self.object, '__all__', None)\n902             if is_valid_module_all(__all__):\n903                 # valid __all__ found. copy it to self.__all__\n904                 self.__all__ = __all__\n905             elif __all__:\n906                 # invalid __all__ found.\n907                 logger.warning(__('__all__ should be a list of strings, not %r '\n908                                   '(in module %s) -- ignoring __all__') %\n909                                (__all__, self.fullname), type='autodoc')\n910 \n911         return ret\n912 \n913     def add_directive_header(self, sig: str) -> None:\n914         Documenter.add_directive_header(self, sig)\n915 \n916         sourcename = self.get_sourcename()\n917 \n918         # add some module-specific options\n919         if self.options.synopsis:\n920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n921         if self.options.platform:\n922             self.add_line('   :platform: ' + self.options.platform, sourcename)\n923         if self.options.deprecated:\n924             self.add_line('   :deprecated:', sourcename)\n925 \n926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n927         if want_all:\n928             if self.__all__:\n929                 memberlist = self.__all__\n930             else:\n931                 # for implicit module members, check __module__ to avoid\n932                 # documenting imported objects\n933                 return True, get_module_members(self.object)\n934         else:\n935             memberlist = self.options.members or []\n936         ret = []\n937         for mname in memberlist:\n938             try:\n939                 ret.append((mname, safe_getattr(self.object, mname)))\n940             except AttributeError:\n941                 logger.warning(\n942                     __('missing attribute mentioned in :members: or __all__: '\n943                        'module %s, attribute %s') %\n944                     (safe_getattr(self.object, '__name__', '???'), mname),\n945                     type='autodoc'\n946                 )\n947         return False, ret\n948 \n949     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n950                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n951         if order == 'bysource' and self.__all__:\n952             # Sort alphabetically first (for members not listed on the __all__)\n953             documenters.sort(key=lambda e: e[0].name)\n954 \n955             # Sort by __all__\n956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n957                 name = entry[0].name.split('::')[1]\n958                 if name in self.__all__:\n959                     return self.__all__.index(name)\n960                 else:\n961                     return len(self.__all__)\n962             documenters.sort(key=keyfunc)\n963 \n964             return documenters\n965         else:\n966             return super().sort_members(documenters, order)\n967 \n968 \n969 class ModuleLevelDocumenter(Documenter):\n970     \"\"\"\n971     Specialized Documenter subclass for objects on module level (functions,\n972     classes, data/constants).\n973     \"\"\"\n974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n975                      ) -> Tuple[str, List[str]]:\n976         if modname is None:\n977             if path:\n978                 stripped = path.rstrip('.')\n979                 modname, qualname = split_full_qualified_name(stripped)\n980                 if qualname:\n981                     parents = qualname.split(\".\")\n982                 else:\n983                     parents = []\n984 \n985             if modname is None:\n986                 # if documenting a toplevel object without explicit module,\n987                 # it can be contained in another auto directive ...\n988                 modname = self.env.temp_data.get('autodoc:module')\n989                 # ... or in the scope of a module directive\n990                 if not modname:\n991                     modname = self.env.ref_context.get('py:module')\n992                 # ... else, it stays None, which means invalid\n993         return modname, parents + [base]\n994 \n995 \n996 class ClassLevelDocumenter(Documenter):\n997     \"\"\"\n998     Specialized Documenter subclass for objects on class level (methods,\n999     attributes).\n1000     \"\"\"\n1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1002                      ) -> Tuple[str, List[str]]:\n1003         if modname is None:\n1004             if path:\n1005                 mod_cls = path.rstrip('.')\n1006             else:\n1007                 mod_cls = None\n1008                 # if documenting a class-level object without path,\n1009                 # there must be a current class, either from a parent\n1010                 # auto directive ...\n1011                 mod_cls = self.env.temp_data.get('autodoc:class')\n1012                 # ... or from a class directive\n1013                 if mod_cls is None:\n1014                     mod_cls = self.env.ref_context.get('py:class')\n1015                 # ... if still None, there's no way to know\n1016                 if mod_cls is None:\n1017                     return None, []\n1018 \n1019             try:\n1020                 modname, qualname = split_full_qualified_name(mod_cls)\n1021                 parents = qualname.split(\".\") if qualname else []\n1022             except ImportError:\n1023                 parents = mod_cls.split(\".\")\n1024 \n1025             # if the module name is still missing, get it like above\n1026             if not modname:\n1027                 modname = self.env.temp_data.get('autodoc:module')\n1028             if not modname:\n1029                 modname = self.env.ref_context.get('py:module')\n1030             # ... else, it stays None, which means invalid\n1031         return modname, parents + [base]\n1032 \n1033 \n1034 class DocstringSignatureMixin:\n1035     \"\"\"\n1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1037     feature of reading the signature from the docstring.\n1038     \"\"\"\n1039     _new_docstrings = None  # type: List[List[str]]\n1040     _signatures = None      # type: List[str]\n1041 \n1042     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1043         if encoding is not None:\n1044             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1045                           \"deprecated.\" % self.__class__.__name__,\n1046                           RemovedInSphinx40Warning, stacklevel=2)\n1047 \n1048         # candidates of the object name\n1049         valid_names = [self.objpath[-1]]  # type: ignore\n1050         if isinstance(self, ClassDocumenter):\n1051             valid_names.append('__init__')\n1052             if hasattr(self.object, '__mro__'):\n1053                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1054 \n1055         docstrings = self.get_doc()\n1056         self._new_docstrings = docstrings[:]\n1057         self._signatures = []\n1058         result = None\n1059         for i, doclines in enumerate(docstrings):\n1060             for j, line in enumerate(doclines):\n1061                 if not line:\n1062                     # no lines in docstring, no match\n1063                     break\n1064 \n1065                 if line.endswith('\\\\'):\n1066                     multiline = True\n1067                     line = line.rstrip('\\\\').rstrip()\n1068                 else:\n1069                     multiline = False\n1070 \n1071                 # match first line of docstring against signature RE\n1072                 match = py_ext_sig_re.match(line)\n1073                 if not match:\n1074                     continue\n1075                 exmod, path, base, args, retann = match.groups()\n1076 \n1077                 # the base name must match ours\n1078                 if base not in valid_names:\n1079                     continue\n1080 \n1081                 # re-prepare docstring to ignore more leading indentation\n1082                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1083                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1084                                                             tabsize=tab_width)\n1085 \n1086                 if result is None:\n1087                     # first signature\n1088                     result = args, retann\n1089                 else:\n1090                     # subsequent signatures\n1091                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1092 \n1093                 if multiline:\n1094                     # the signature have multiple signatures on docstring\n1095                     continue\n1096                 else:\n1097                     # don't look any further\n1098                     break\n1099 \n1100             if result:\n1101                 # finish the loop when signature found\n1102                 break\n1103 \n1104         return result\n1105 \n1106     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1107         if encoding is not None:\n1108             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1109                           % self.__class__.__name__,\n1110                           RemovedInSphinx40Warning, stacklevel=2)\n1111         if self._new_docstrings is not None:\n1112             return self._new_docstrings\n1113         return super().get_doc(None, ignore)  # type: ignore\n1114 \n1115     def format_signature(self, **kwargs: Any) -> str:\n1116         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1117             # only act if a signature is not explicitly given already, and if\n1118             # the feature is enabled\n1119             result = self._find_signature()\n1120             if result is not None:\n1121                 self.args, self.retann = result\n1122         sig = super().format_signature(**kwargs)  # type: ignore\n1123         if self._signatures:\n1124             return \"\\n\".join([sig] + self._signatures)\n1125         else:\n1126             return sig\n1127 \n1128 \n1129 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1130     \"\"\"\n1131     Mixin for AttributeDocumenter to provide the\n1132     feature of stripping any function signature from the docstring.\n1133     \"\"\"\n1134     def format_signature(self, **kwargs: Any) -> str:\n1135         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1136             # only act if a signature is not explicitly given already, and if\n1137             # the feature is enabled\n1138             result = self._find_signature()\n1139             if result is not None:\n1140                 # Discarding _args is a only difference with\n1141                 # DocstringSignatureMixin.format_signature.\n1142                 # Documenter.format_signature use self.args value to format.\n1143                 _args, self.retann = result\n1144         return super().format_signature(**kwargs)\n1145 \n1146 \n1147 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1148     \"\"\"\n1149     Specialized Documenter subclass for functions.\n1150     \"\"\"\n1151     objtype = 'function'\n1152     member_order = 30\n1153 \n1154     @classmethod\n1155     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1156                             ) -> bool:\n1157         # supports functions, builtins and bound methods exported at the module level\n1158         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1159                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1160 \n1161     def format_args(self, **kwargs: Any) -> str:\n1162         if self.env.config.autodoc_typehints in ('none', 'description'):\n1163             kwargs.setdefault('show_annotation', False)\n1164 \n1165         try:\n1166             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1167             if inspect.is_singledispatch_function(self.object):\n1168                 sig = inspect.signature(self.object, follow_wrapped=True)\n1169             else:\n1170                 sig = inspect.signature(self.object)\n1171             args = stringify_signature(sig, **kwargs)\n1172         except TypeError as exc:\n1173             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1174                            self.fullname, exc)\n1175             return None\n1176         except ValueError:\n1177             args = ''\n1178 \n1179         if self.env.config.strip_signature_backslash:\n1180             # escape backslashes for reST\n1181             args = args.replace('\\\\', '\\\\\\\\')\n1182         return args\n1183 \n1184     def document_members(self, all_members: bool = False) -> None:\n1185         pass\n1186 \n1187     def add_directive_header(self, sig: str) -> None:\n1188         sourcename = self.get_sourcename()\n1189         super().add_directive_header(sig)\n1190 \n1191         if inspect.iscoroutinefunction(self.object):\n1192             self.add_line('   :async:', sourcename)\n1193 \n1194     def format_signature(self, **kwargs: Any) -> str:\n1195         sigs = []\n1196         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n1197             # Use signatures for overloaded functions instead of the implementation function.\n1198             overloaded = True\n1199         else:\n1200             overloaded = False\n1201             sig = super().format_signature(**kwargs)\n1202             sigs.append(sig)\n1203 \n1204         if inspect.is_singledispatch_function(self.object):\n1205             # append signature of singledispatch'ed functions\n1206             for typ, func in self.object.registry.items():\n1207                 if typ is object:\n1208                     pass  # default implementation. skipped.\n1209                 else:\n1210                     self.annotate_to_first_argument(func, typ)\n1211 \n1212                     documenter = FunctionDocumenter(self.directive, '')\n1213                     documenter.object = func\n1214                     documenter.objpath = [None]\n1215                     sigs.append(documenter.format_signature())\n1216         if overloaded:\n1217             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1218                 sig = stringify_signature(overload, **kwargs)\n1219                 sigs.append(sig)\n1220 \n1221         return \"\\n\".join(sigs)\n1222 \n1223     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1224         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1225         try:\n1226             sig = inspect.signature(func)\n1227         except TypeError as exc:\n1228             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1229                            self.fullname, exc)\n1230             return\n1231         except ValueError:\n1232             return\n1233 \n1234         if len(sig.parameters) == 0:\n1235             return\n1236 \n1237         params = list(sig.parameters.values())\n1238         if params[0].annotation is Parameter.empty:\n1239             params[0] = params[0].replace(annotation=typ)\n1240             try:\n1241                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1242             except TypeError:\n1243                 # failed to update signature (ex. built-in or extension types)\n1244                 return\n1245 \n1246 \n1247 class SingledispatchFunctionDocumenter(FunctionDocumenter):\n1248     \"\"\"\n1249     Used to be a specialized Documenter subclass for singledispatch'ed functions.\n1250 \n1251     Retained for backwards compatibility, now does the same as the FunctionDocumenter\n1252     \"\"\"\n1253 \n1254 \n1255 class DecoratorDocumenter(FunctionDocumenter):\n1256     \"\"\"\n1257     Specialized Documenter subclass for decorator functions.\n1258     \"\"\"\n1259     objtype = 'decorator'\n1260 \n1261     # must be lower than FunctionDocumenter\n1262     priority = -1\n1263 \n1264     def format_args(self, **kwargs: Any) -> Any:\n1265         args = super().format_args(**kwargs)\n1266         if ',' in args:\n1267             return args\n1268         else:\n1269             return None\n1270 \n1271 \n1272 # Types which have confusing metaclass signatures it would be best not to show.\n1273 # These are listed by name, rather than storing the objects themselves, to avoid\n1274 # needing to import the modules.\n1275 _METACLASS_CALL_BLACKLIST = [\n1276     'enum.EnumMeta.__call__',\n1277 ]\n1278 \n1279 \n1280 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1281     \"\"\"\n1282     Specialized Documenter subclass for classes.\n1283     \"\"\"\n1284     objtype = 'class'\n1285     member_order = 20\n1286     option_spec = {\n1287         'members': members_option, 'undoc-members': bool_option,\n1288         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1289         'show-inheritance': bool_option, 'member-order': member_order_option,\n1290         'exclude-members': members_set_option,\n1291         'private-members': bool_option, 'special-members': members_option,\n1292     }  # type: Dict[str, Callable]\n1293 \n1294     _signature_class = None  # type: Any\n1295     _signature_method_name = None  # type: str\n1296 \n1297     def __init__(self, *args: Any) -> None:\n1298         super().__init__(*args)\n1299         merge_special_members_option(self.options)\n1300 \n1301     @classmethod\n1302     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1303                             ) -> bool:\n1304         return isinstance(member, type)\n1305 \n1306     def import_object(self) -> Any:\n1307         ret = super().import_object()\n1308         # if the class is documented under another name, document it\n1309         # as data/attribute\n1310         if ret:\n1311             if hasattr(self.object, '__name__'):\n1312                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1313             else:\n1314                 self.doc_as_attr = True\n1315         return ret\n1316 \n1317     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1318         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1319             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1320             if inspect.is_builtin_class_method(obj, attr):\n1321                 return None\n1322             attr = self.get_attr(obj, attr, None)\n1323             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1324                 return None\n1325             return attr\n1326 \n1327         # This sequence is copied from inspect._signature_from_callable.\n1328         # ValueError means that no signature could be found, so we keep going.\n1329 \n1330         # First, let's see if it has an overloaded __call__ defined\n1331         # in its metaclass\n1332         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1333 \n1334         if call is not None:\n1335             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1336                 call = None\n1337 \n1338         if call is not None:\n1339             self.env.app.emit('autodoc-before-process-signature', call, True)\n1340             try:\n1341                 sig = inspect.signature(call, bound_method=True)\n1342                 return type(self.object), '__call__', sig\n1343             except ValueError:\n1344                 pass\n1345 \n1346         # Now we check if the 'obj' class has a '__new__' method\n1347         new = get_user_defined_function_or_method(self.object, '__new__')\n1348         if new is not None:\n1349             self.env.app.emit('autodoc-before-process-signature', new, True)\n1350             try:\n1351                 sig = inspect.signature(new, bound_method=True)\n1352                 return self.object, '__new__', sig\n1353             except ValueError:\n1354                 pass\n1355 \n1356         # Finally, we should have at least __init__ implemented\n1357         init = get_user_defined_function_or_method(self.object, '__init__')\n1358         if init is not None:\n1359             self.env.app.emit('autodoc-before-process-signature', init, True)\n1360             try:\n1361                 sig = inspect.signature(init, bound_method=True)\n1362                 return self.object, '__init__', sig\n1363             except ValueError:\n1364                 pass\n1365 \n1366         # None of the attributes are user-defined, so fall back to let inspect\n1367         # handle it.\n1368         # We don't know the exact method that inspect.signature will read\n1369         # the signature from, so just pass the object itself to our hook.\n1370         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1371         try:\n1372             sig = inspect.signature(self.object, bound_method=False)\n1373             return None, None, sig\n1374         except ValueError:\n1375             pass\n1376 \n1377         # Still no signature: happens e.g. for old-style classes\n1378         # with __init__ in C and no `__text_signature__`.\n1379         return None, None, None\n1380 \n1381     def format_args(self, **kwargs: Any) -> str:\n1382         if self.env.config.autodoc_typehints in ('none', 'description'):\n1383             kwargs.setdefault('show_annotation', False)\n1384 \n1385         try:\n1386             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1387         except TypeError as exc:\n1388             # __signature__ attribute contained junk\n1389             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1390                            self.fullname, exc)\n1391             return None\n1392 \n1393         if sig is None:\n1394             return None\n1395 \n1396         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1397 \n1398     def format_signature(self, **kwargs: Any) -> str:\n1399         if self.doc_as_attr:\n1400             return ''\n1401 \n1402         sig = super().format_signature()\n1403 \n1404         overloaded = False\n1405         qualname = None\n1406         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)\n1407         if self._signature_class and self._signature_method_name and self.analyzer:\n1408             qualname = '.'.join([self._signature_class.__qualname__,\n1409                                  self._signature_method_name])\n1410             if qualname in self.analyzer.overloads:\n1411                 overloaded = True\n1412 \n1413         sigs = []\n1414         if overloaded:\n1415             # Use signatures for overloaded methods instead of the implementation method.\n1416             for overload in self.analyzer.overloads.get(qualname):\n1417                 parameters = list(overload.parameters.values())\n1418                 overload = overload.replace(parameters=parameters[1:],\n1419                                             return_annotation=Parameter.empty)\n1420                 sig = stringify_signature(overload, **kwargs)\n1421                 sigs.append(sig)\n1422         else:\n1423             sigs.append(sig)\n1424 \n1425         return \"\\n\".join(sigs)\n1426 \n1427     def add_directive_header(self, sig: str) -> None:\n1428         sourcename = self.get_sourcename()\n1429 \n1430         if self.doc_as_attr:\n1431             self.directivetype = 'attribute'\n1432         super().add_directive_header(sig)\n1433 \n1434         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1435             self.add_line('   :final:', sourcename)\n1436 \n1437         # add inheritance info, if wanted\n1438         if not self.doc_as_attr and self.options.show_inheritance:\n1439             sourcename = self.get_sourcename()\n1440             self.add_line('', sourcename)\n1441             if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1442                 bases = [':class:`%s`' % b.__name__\n1443                          if b.__module__ in ('__builtin__', 'builtins')\n1444                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)\n1445                          for b in self.object.__bases__]\n1446                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),\n1447                               sourcename)\n1448 \n1449     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1450         if encoding is not None:\n1451             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1452                           % self.__class__.__name__,\n1453                           RemovedInSphinx40Warning, stacklevel=2)\n1454         lines = getattr(self, '_new_docstrings', None)\n1455         if lines is not None:\n1456             return lines\n1457 \n1458         content = self.env.config.autoclass_content\n1459 \n1460         docstrings = []\n1461         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1462         if attrdocstring:\n1463             docstrings.append(attrdocstring)\n1464 \n1465         # for classes, what the \"docstring\" is can be controlled via a\n1466         # config value; the default is only the class docstring\n1467         if content in ('both', 'init'):\n1468             __init__ = self.get_attr(self.object, '__init__', None)\n1469             initdocstring = getdoc(__init__, self.get_attr,\n1470                                    self.env.config.autodoc_inherit_docstrings,\n1471                                    self.parent, self.object_name)\n1472             # for new-style classes, no __init__ means default __init__\n1473             if (initdocstring is not None and\n1474                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1475                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1476                 initdocstring = None\n1477             if not initdocstring:\n1478                 # try __new__\n1479                 __new__ = self.get_attr(self.object, '__new__', None)\n1480                 initdocstring = getdoc(__new__, self.get_attr,\n1481                                        self.env.config.autodoc_inherit_docstrings,\n1482                                        self.parent, self.object_name)\n1483                 # for new-style classes, no __new__ means default __new__\n1484                 if (initdocstring is not None and\n1485                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1486                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1487                     initdocstring = None\n1488             if initdocstring:\n1489                 if content == 'init':\n1490                     docstrings = [initdocstring]\n1491                 else:\n1492                     docstrings.append(initdocstring)\n1493 \n1494         tab_width = self.directive.state.document.settings.tab_width\n1495         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1496 \n1497     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1498         if self.doc_as_attr:\n1499             classname = safe_getattr(self.object, '__qualname__', None)\n1500             if not classname:\n1501                 classname = safe_getattr(self.object, '__name__', None)\n1502             if classname:\n1503                 module = safe_getattr(self.object, '__module__', None)\n1504                 parentmodule = safe_getattr(self.parent, '__module__', None)\n1505                 if module and module != parentmodule:\n1506                     classname = str(module) + '.' + str(classname)\n1507                 content = StringList([_('alias of :class:`%s`') % classname], source='')\n1508                 super().add_content(content, no_docstring=True)\n1509         else:\n1510             super().add_content(more_content)\n1511 \n1512     def document_members(self, all_members: bool = False) -> None:\n1513         if self.doc_as_attr:\n1514             return\n1515         super().document_members(all_members)\n1516 \n1517     def generate(self, more_content: Any = None, real_modname: str = None,\n1518                  check_module: bool = False, all_members: bool = False) -> None:\n1519         # Do not pass real_modname and use the name from the __module__\n1520         # attribute of the class.\n1521         # If a class gets imported into the module real_modname\n1522         # the analyzer won't find the source of the class, if\n1523         # it looks in real_modname.\n1524         return super().generate(more_content=more_content,\n1525                                 check_module=check_module,\n1526                                 all_members=all_members)\n1527 \n1528 \n1529 class ExceptionDocumenter(ClassDocumenter):\n1530     \"\"\"\n1531     Specialized ClassDocumenter subclass for exceptions.\n1532     \"\"\"\n1533     objtype = 'exception'\n1534     member_order = 10\n1535 \n1536     # needs a higher priority than ClassDocumenter\n1537     priority = 10\n1538 \n1539     @classmethod\n1540     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1541                             ) -> bool:\n1542         return isinstance(member, type) and issubclass(member, BaseException)\n1543 \n1544 \n1545 class DataDocumenter(ModuleLevelDocumenter):\n1546     \"\"\"\n1547     Specialized Documenter subclass for data items.\n1548     \"\"\"\n1549     objtype = 'data'\n1550     member_order = 40\n1551     priority = -10\n1552     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1553     option_spec[\"annotation\"] = annotation_option\n1554 \n1555     @classmethod\n1556     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1557                             ) -> bool:\n1558         return isinstance(parent, ModuleDocumenter) and isattr\n1559 \n1560     def add_directive_header(self, sig: str) -> None:\n1561         super().add_directive_header(sig)\n1562         sourcename = self.get_sourcename()\n1563         if not self.options.annotation:\n1564             # obtain annotation for this data\n1565             annotations = getattr(self.parent, '__annotations__', {})\n1566             if annotations and self.objpath[-1] in annotations:\n1567                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1568                 self.add_line('   :type: ' + objrepr, sourcename)\n1569             else:\n1570                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1571                 if self.analyzer and key in self.analyzer.annotations:\n1572                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1573                                   sourcename)\n1574 \n1575             try:\n1576                 if self.object is UNINITIALIZED_ATTR:\n1577                     pass\n1578                 else:\n1579                     objrepr = object_description(self.object)\n1580                     self.add_line('   :value: ' + objrepr, sourcename)\n1581             except ValueError:\n1582                 pass\n1583         elif self.options.annotation is SUPPRESS:\n1584             pass\n1585         else:\n1586             self.add_line('   :annotation: %s' % self.options.annotation,\n1587                           sourcename)\n1588 \n1589     def document_members(self, all_members: bool = False) -> None:\n1590         pass\n1591 \n1592     def get_real_modname(self) -> str:\n1593         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1594             or self.modname\n1595 \n1596 \n1597 class DataDeclarationDocumenter(DataDocumenter):\n1598     \"\"\"\n1599     Specialized Documenter subclass for data that cannot be imported\n1600     because they are declared without initial value (refs: PEP-526).\n1601     \"\"\"\n1602     objtype = 'datadecl'\n1603     directivetype = 'data'\n1604     member_order = 60\n1605 \n1606     # must be higher than AttributeDocumenter\n1607     priority = 11\n1608 \n1609     @classmethod\n1610     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1611                             ) -> bool:\n1612         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1613         return (isinstance(parent, ModuleDocumenter) and\n1614                 isattr and\n1615                 member is INSTANCEATTR)\n1616 \n1617     def import_object(self) -> bool:\n1618         \"\"\"Never import anything.\"\"\"\n1619         # disguise as a data\n1620         self.objtype = 'data'\n1621         self.object = UNINITIALIZED_ATTR\n1622         try:\n1623             # import module to obtain type annotation\n1624             self.parent = importlib.import_module(self.modname)\n1625         except ImportError:\n1626             pass\n1627 \n1628         return True\n1629 \n1630     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1631         \"\"\"Never try to get a docstring from the object.\"\"\"\n1632         super().add_content(more_content, no_docstring=True)\n1633 \n1634 \n1635 class GenericAliasDocumenter(DataDocumenter):\n1636     \"\"\"\n1637     Specialized Documenter subclass for GenericAliases.\n1638     \"\"\"\n1639 \n1640     objtype = 'genericalias'\n1641     directivetype = 'data'\n1642     priority = DataDocumenter.priority + 1\n1643 \n1644     @classmethod\n1645     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1646                             ) -> bool:\n1647         return inspect.isgenericalias(member)\n1648 \n1649     def add_directive_header(self, sig: str) -> None:\n1650         self.options.annotation = SUPPRESS  # type: ignore\n1651         super().add_directive_header(sig)\n1652 \n1653     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1654         name = stringify_typehint(self.object)\n1655         content = StringList([_('alias of %s') % name], source='')\n1656         super().add_content(content)\n1657 \n1658 \n1659 class TypeVarDocumenter(DataDocumenter):\n1660     \"\"\"\n1661     Specialized Documenter subclass for TypeVars.\n1662     \"\"\"\n1663 \n1664     objtype = 'typevar'\n1665     directivetype = 'data'\n1666     priority = DataDocumenter.priority + 1\n1667 \n1668     @classmethod\n1669     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1670                             ) -> bool:\n1671         return isinstance(member, TypeVar) and isattr  # type: ignore\n1672 \n1673     def add_directive_header(self, sig: str) -> None:\n1674         self.options.annotation = SUPPRESS  # type: ignore\n1675         super().add_directive_header(sig)\n1676 \n1677     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1678         if ignore is not None:\n1679             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1680                           % self.__class__.__name__,\n1681                           RemovedInSphinx50Warning, stacklevel=2)\n1682 \n1683         if self.object.__doc__ != TypeVar.__doc__:\n1684             return super().get_doc()\n1685         else:\n1686             return []\n1687 \n1688     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1689         attrs = [repr(self.object.__name__)]\n1690         for constraint in self.object.__constraints__:\n1691             attrs.append(stringify_typehint(constraint))\n1692         if self.object.__covariant__:\n1693             attrs.append(\"covariant=True\")\n1694         if self.object.__contravariant__:\n1695             attrs.append(\"contravariant=True\")\n1696 \n1697         content = StringList([_('alias of TypeVar(%s)') % \", \".join(attrs)], source='')\n1698         super().add_content(content)\n1699 \n1700 \n1701 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1702     \"\"\"\n1703     Specialized Documenter subclass for methods (normal, static and class).\n1704     \"\"\"\n1705     objtype = 'method'\n1706     directivetype = 'method'\n1707     member_order = 50\n1708     priority = 1  # must be more than FunctionDocumenter\n1709 \n1710     @classmethod\n1711     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1712                             ) -> bool:\n1713         return inspect.isroutine(member) and \\\n1714             not isinstance(parent, ModuleDocumenter)\n1715 \n1716     def import_object(self) -> Any:\n1717         ret = super().import_object()\n1718         if not ret:\n1719             return ret\n1720 \n1721         # to distinguish classmethod/staticmethod\n1722         obj = self.parent.__dict__.get(self.object_name)\n1723         if obj is None:\n1724             obj = self.object\n1725 \n1726         if (inspect.isclassmethod(obj) or\n1727                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n1728             # document class and static members before ordinary ones\n1729             self.member_order = self.member_order - 1\n1730 \n1731         return ret\n1732 \n1733     def format_args(self, **kwargs: Any) -> str:\n1734         if self.env.config.autodoc_typehints in ('none', 'description'):\n1735             kwargs.setdefault('show_annotation', False)\n1736 \n1737         try:\n1738             if self.object == object.__init__ and self.parent != object:\n1739                 # Classes not having own __init__() method are shown as no arguments.\n1740                 #\n1741                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n1742                 #       But it makes users confused.\n1743                 args = '()'\n1744             else:\n1745                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n1746                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1747                     sig = inspect.signature(self.object, bound_method=False)\n1748                 else:\n1749                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n1750 \n1751                     meth = self.parent.__dict__.get(self.objpath[-1], None)\n1752                     if meth and inspect.is_singledispatch_method(meth):\n1753                         sig = inspect.signature(self.object, bound_method=True,\n1754                                                 follow_wrapped=True)\n1755                     else:\n1756                         sig = inspect.signature(self.object, bound_method=True)\n1757                 args = stringify_signature(sig, **kwargs)\n1758         except TypeError as exc:\n1759             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1760                            self.fullname, exc)\n1761             return None\n1762         except ValueError:\n1763             args = ''\n1764 \n1765         if self.env.config.strip_signature_backslash:\n1766             # escape backslashes for reST\n1767             args = args.replace('\\\\', '\\\\\\\\')\n1768         return args\n1769 \n1770     def add_directive_header(self, sig: str) -> None:\n1771         super().add_directive_header(sig)\n1772 \n1773         sourcename = self.get_sourcename()\n1774         obj = self.parent.__dict__.get(self.object_name, self.object)\n1775         if inspect.isabstractmethod(obj):\n1776             self.add_line('   :abstractmethod:', sourcename)\n1777         if inspect.iscoroutinefunction(obj):\n1778             self.add_line('   :async:', sourcename)\n1779         if inspect.isclassmethod(obj):\n1780             self.add_line('   :classmethod:', sourcename)\n1781         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n1782             self.add_line('   :staticmethod:', sourcename)\n1783         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1784             self.add_line('   :final:', sourcename)\n1785 \n1786     def document_members(self, all_members: bool = False) -> None:\n1787         pass\n1788 \n1789     def format_signature(self, **kwargs: Any) -> str:\n1790         sigs = []\n1791         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n1792             # Use signatures for overloaded methods instead of the implementation method.\n1793             overloaded = True\n1794         else:\n1795             overloaded = False\n1796             sig = super().format_signature(**kwargs)\n1797             sigs.append(sig)\n1798 \n1799         meth = self.parent.__dict__.get(self.objpath[-1])\n1800         if inspect.is_singledispatch_method(meth):\n1801             # append signature of singledispatch'ed functions\n1802             for typ, func in meth.dispatcher.registry.items():\n1803                 if typ is object:\n1804                     pass  # default implementation. skipped.\n1805                 else:\n1806                     self.annotate_to_first_argument(func, typ)\n1807 \n1808                     documenter = MethodDocumenter(self.directive, '')\n1809                     documenter.parent = self.parent\n1810                     documenter.object = func\n1811                     documenter.objpath = [None]\n1812                     sigs.append(documenter.format_signature())\n1813         if overloaded:\n1814             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1815                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n1816                                               name=self.object_name):\n1817                     parameters = list(overload.parameters.values())\n1818                     overload = overload.replace(parameters=parameters[1:])\n1819                 sig = stringify_signature(overload, **kwargs)\n1820                 sigs.append(sig)\n1821 \n1822         return \"\\n\".join(sigs)\n1823 \n1824     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1825         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1826         try:\n1827             sig = inspect.signature(func)\n1828         except TypeError as exc:\n1829             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1830                            self.fullname, exc)\n1831             return\n1832         except ValueError:\n1833             return\n1834         if len(sig.parameters) == 1:\n1835             return\n1836 \n1837         params = list(sig.parameters.values())\n1838         if params[1].annotation is Parameter.empty:\n1839             params[1] = params[1].replace(annotation=typ)\n1840             try:\n1841                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1842             except TypeError:\n1843                 # failed to update signature (ex. built-in or extension types)\n1844                 return\n1845 \n1846 \n1847 class SingledispatchMethodDocumenter(MethodDocumenter):\n1848     \"\"\"\n1849     Used to be a specialized Documenter subclass for singledispatch'ed methods.\n1850 \n1851     Retained for backwards compatibility, now does the same as the MethodDocumenter\n1852     \"\"\"\n1853 \n1854 \n1855 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1856     \"\"\"\n1857     Specialized Documenter subclass for attributes.\n1858     \"\"\"\n1859     objtype = 'attribute'\n1860     member_order = 60\n1861     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1862     option_spec[\"annotation\"] = annotation_option\n1863 \n1864     # must be higher than the MethodDocumenter, else it will recognize\n1865     # some non-data descriptors as methods\n1866     priority = 10\n1867 \n1868     @staticmethod\n1869     def is_function_or_method(obj: Any) -> bool:\n1870         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n1871 \n1872     @classmethod\n1873     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1874                             ) -> bool:\n1875         if inspect.isattributedescriptor(member):\n1876             return True\n1877         elif (not isinstance(parent, ModuleDocumenter) and\n1878               not inspect.isroutine(member) and\n1879               not isinstance(member, type)):\n1880             return True\n1881         else:\n1882             return False\n1883 \n1884     def document_members(self, all_members: bool = False) -> None:\n1885         pass\n1886 \n1887     def import_object(self) -> Any:\n1888         ret = super().import_object()\n1889         if inspect.isenumattribute(self.object):\n1890             self.object = self.object.value\n1891         if inspect.isattributedescriptor(self.object):\n1892             self._datadescriptor = True\n1893         else:\n1894             # if it's not a data descriptor\n1895             self._datadescriptor = False\n1896         return ret\n1897 \n1898     def get_real_modname(self) -> str:\n1899         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1900             or self.modname\n1901 \n1902     def add_directive_header(self, sig: str) -> None:\n1903         super().add_directive_header(sig)\n1904         sourcename = self.get_sourcename()\n1905         if not self.options.annotation:\n1906             # obtain type annotation for this attribute\n1907             annotations = getattr(self.parent, '__annotations__', {})\n1908             if annotations and self.objpath[-1] in annotations:\n1909                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1910                 self.add_line('   :type: ' + objrepr, sourcename)\n1911             else:\n1912                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1913                 if self.analyzer and key in self.analyzer.annotations:\n1914                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1915                                   sourcename)\n1916 \n1917             # data descriptors do not have useful values\n1918             if not self._datadescriptor:\n1919                 try:\n1920                     if self.object is INSTANCEATTR:\n1921                         pass\n1922                     else:\n1923                         objrepr = object_description(self.object)\n1924                         self.add_line('   :value: ' + objrepr, sourcename)\n1925                 except ValueError:\n1926                     pass\n1927         elif self.options.annotation is SUPPRESS:\n1928             pass\n1929         else:\n1930             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n1931 \n1932     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1933         try:\n1934             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n1935             # a docstring from the value which descriptor returns unexpectedly.\n1936             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n1937             orig = self.env.config.autodoc_inherit_docstrings\n1938             self.env.config.autodoc_inherit_docstrings = False  # type: ignore\n1939             return super().get_doc(encoding, ignore)\n1940         finally:\n1941             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore\n1942 \n1943     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1944         if not self._datadescriptor:\n1945             # if it's not a data descriptor, its docstring is very probably the\n1946             # wrong thing to display\n1947             no_docstring = True\n1948         super().add_content(more_content, no_docstring)\n1949 \n1950 \n1951 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1952     \"\"\"\n1953     Specialized Documenter subclass for properties.\n1954     \"\"\"\n1955     objtype = 'property'\n1956     directivetype = 'method'\n1957     member_order = 60\n1958 \n1959     # before AttributeDocumenter\n1960     priority = AttributeDocumenter.priority + 1\n1961 \n1962     @classmethod\n1963     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1964                             ) -> bool:\n1965         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n1966 \n1967     def document_members(self, all_members: bool = False) -> None:\n1968         pass\n1969 \n1970     def get_real_modname(self) -> str:\n1971         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1972             or self.modname\n1973 \n1974     def add_directive_header(self, sig: str) -> None:\n1975         super().add_directive_header(sig)\n1976         sourcename = self.get_sourcename()\n1977         if inspect.isabstractmethod(self.object):\n1978             self.add_line('   :abstractmethod:', sourcename)\n1979         self.add_line('   :property:', sourcename)\n1980 \n1981 \n1982 class InstanceAttributeDocumenter(AttributeDocumenter):\n1983     \"\"\"\n1984     Specialized Documenter subclass for attributes that cannot be imported\n1985     because they are instance attributes (e.g. assigned in __init__).\n1986     \"\"\"\n1987     objtype = 'instanceattribute'\n1988     directivetype = 'attribute'\n1989     member_order = 60\n1990 \n1991     # must be higher than AttributeDocumenter\n1992     priority = 11\n1993 \n1994     @classmethod\n1995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1996                             ) -> bool:\n1997         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1998         return (not isinstance(parent, ModuleDocumenter) and\n1999                 isattr and\n2000                 member is INSTANCEATTR)\n2001 \n2002     def import_object(self) -> bool:\n2003         \"\"\"Never import anything.\"\"\"\n2004         # disguise as an attribute\n2005         self.objtype = 'attribute'\n2006         self.object = INSTANCEATTR\n2007         self._datadescriptor = False\n2008         return True\n2009 \n2010     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n2011         \"\"\"Never try to get a docstring from the object.\"\"\"\n2012         super().add_content(more_content, no_docstring=True)\n2013 \n2014 \n2015 class SlotsAttributeDocumenter(AttributeDocumenter):\n2016     \"\"\"\n2017     Specialized Documenter subclass for attributes that cannot be imported\n2018     because they are attributes in __slots__.\n2019     \"\"\"\n2020     objtype = 'slotsattribute'\n2021     directivetype = 'attribute'\n2022     member_order = 60\n2023 \n2024     # must be higher than AttributeDocumenter\n2025     priority = 11\n2026 \n2027     @classmethod\n2028     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2029                             ) -> bool:\n2030         \"\"\"This documents only SLOTSATTR members.\"\"\"\n2031         return member is SLOTSATTR\n2032 \n2033     def import_object(self) -> Any:\n2034         \"\"\"Never import anything.\"\"\"\n2035         # disguise as an attribute\n2036         self.objtype = 'attribute'\n2037         self._datadescriptor = True\n2038 \n2039         with mock(self.env.config.autodoc_mock_imports):\n2040             try:\n2041                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2042                                     attrgetter=self.get_attr,\n2043                                     warningiserror=self.env.config.autodoc_warningiserror)\n2044                 self.module, _, _, self.parent = ret\n2045                 return True\n2046             except ImportError as exc:\n2047                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2048                 self.env.note_reread()\n2049                 return False\n2050 \n2051     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n2052         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n2053         if ignore is not None:\n2054             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n2055                           % self.__class__.__name__,\n2056                           RemovedInSphinx50Warning, stacklevel=2)\n2057         name = self.objpath[-1]\n2058         __slots__ = safe_getattr(self.parent, '__slots__', [])\n2059         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):\n2060             docstring = prepare_docstring(__slots__[name])\n2061             return [docstring]\n2062         else:\n2063             return []\n2064 \n2065 \n2066 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n2067     \"\"\"Returns registered Documenter classes\"\"\"\n2068     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2069     return app.registry.documenters\n2070 \n2071 \n2072 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2073     \"\"\"Alternative getattr() for types\"\"\"\n2074     for typ, func in app.registry.autodoc_attrgettrs.items():\n2075         if isinstance(obj, typ):\n2076             return func(obj, name, *defargs)\n2077 \n2078     return safe_getattr(obj, name, *defargs)\n2079 \n2080 \n2081 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2082     if config.autodoc_member_order == 'alphabetic':\n2083         # RemovedInSphinx50Warning\n2084         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2085                           'instead of \"alphabetic\". Please update your setting.'))\n2086         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2087 \n2088 \n2089 def setup(app: Sphinx) -> Dict[str, Any]:\n2090     app.add_autodocumenter(ModuleDocumenter)\n2091     app.add_autodocumenter(ClassDocumenter)\n2092     app.add_autodocumenter(ExceptionDocumenter)\n2093     app.add_autodocumenter(DataDocumenter)\n2094     app.add_autodocumenter(DataDeclarationDocumenter)\n2095     app.add_autodocumenter(GenericAliasDocumenter)\n2096     app.add_autodocumenter(TypeVarDocumenter)\n2097     app.add_autodocumenter(FunctionDocumenter)\n2098     app.add_autodocumenter(DecoratorDocumenter)\n2099     app.add_autodocumenter(MethodDocumenter)\n2100     app.add_autodocumenter(AttributeDocumenter)\n2101     app.add_autodocumenter(PropertyDocumenter)\n2102     app.add_autodocumenter(InstanceAttributeDocumenter)\n2103     app.add_autodocumenter(SlotsAttributeDocumenter)\n2104 \n2105     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2106     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2107                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2108     app.add_config_value('autodoc_default_options', {}, True)\n2109     app.add_config_value('autodoc_docstring_signature', True, True)\n2110     app.add_config_value('autodoc_mock_imports', [], True)\n2111     app.add_config_value('autodoc_typehints', \"signature\", True,\n2112                          ENUM(\"signature\", \"description\", \"none\"))\n2113     app.add_config_value('autodoc_warningiserror', True, True)\n2114     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2115     app.add_event('autodoc-before-process-signature')\n2116     app.add_event('autodoc-process-docstring')\n2117     app.add_event('autodoc-process-signature')\n2118     app.add_event('autodoc-skip-member')\n2119 \n2120     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2121 \n2122     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2123     app.setup_extension('sphinx.ext.autodoc.typehints')\n2124 \n2125     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "The code within this file that interacts with `TypeVar` for generically-typed classes needs to handle these types correctly during documentation generation. Specifically, when creating subclass mocks or processing type annotations, it should preserve the generic nature of the class without causing type errors. Any concatenation of type names for the purpose of mock generation or documentation display must handle `TypeVar` intelligently, ensuring that generic parameters are correctly represented in the output. The fix should ensure that when generically-typed classes are encountered, their documentation is generated without errors, reflecting the generic types accurately."
    },
    {
        "rel_file_path": "sphinx/util/typing.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/util/typing.py",
        "start": 1,
        "end": 212,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.typing\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     The composit types for Sphinx.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import sys\n12 import typing\n13 from typing import Any, Callable, Dict, List, Tuple, TypeVar, Union\n14 \n15 from docutils import nodes\n16 from docutils.parsers.rst.states import Inliner\n17 \n18 \n19 # An entry of Directive.option_spec\n20 DirectiveOption = Callable[[str], Any]\n21 \n22 # Text like nodes which are initialized with text and rawsource\n23 TextlikeNode = Union[nodes.Text, nodes.TextElement]\n24 \n25 # type of None\n26 NoneType = type(None)\n27 \n28 # path matcher\n29 PathMatcher = Callable[[str], bool]\n30 \n31 # common role functions\n32 RoleFunction = Callable[[str, str, str, int, Inliner, Dict[str, Any], List[str]],\n33                         Tuple[List[nodes.Node], List[nodes.system_message]]]\n34 \n35 # title getter functions for enumerable nodes (see sphinx.domains.std)\n36 TitleGetter = Callable[[nodes.Node], str]\n37 \n38 # inventory data on memory\n39 Inventory = Dict[str, Dict[str, Tuple[str, str, str, str]]]\n40 \n41 \n42 def is_system_TypeVar(typ: Any) -> bool:\n43     \"\"\"Check *typ* is system defined TypeVar.\"\"\"\n44     modname = getattr(typ, '__module__', '')\n45     return modname == 'typing' and isinstance(typ, TypeVar)  # type: ignore\n46 \n47 \n48 def stringify(annotation: Any) -> str:\n49     \"\"\"Stringify type annotation object.\"\"\"\n50     if isinstance(annotation, str):\n51         return annotation\n52     elif isinstance(annotation, TypeVar):  # type: ignore\n53         return annotation.__name__\n54     elif not annotation:\n55         return repr(annotation)\n56     elif annotation is NoneType:\n57         return 'None'\n58     elif (getattr(annotation, '__module__', None) == 'builtins' and\n59           hasattr(annotation, '__qualname__')):\n60         return annotation.__qualname__\n61     elif annotation is Ellipsis:\n62         return '...'\n63 \n64     if sys.version_info >= (3, 7):  # py37+\n65         return _stringify_py37(annotation)\n66     else:\n67         return _stringify_py36(annotation)\n68 \n69 \n70 def _stringify_py37(annotation: Any) -> str:\n71     \"\"\"stringify() for py37+.\"\"\"\n72     module = getattr(annotation, '__module__', None)\n73     if module == 'typing':\n74         if getattr(annotation, '_name', None):\n75             qualname = annotation._name\n76         elif getattr(annotation, '__qualname__', None):\n77             qualname = annotation.__qualname__\n78         elif getattr(annotation, '__forward_arg__', None):\n79             qualname = annotation.__forward_arg__\n80         else:\n81             qualname = stringify(annotation.__origin__)  # ex. Union\n82     elif hasattr(annotation, '__qualname__'):\n83         qualname = '%s.%s' % (module, annotation.__qualname__)\n84     elif hasattr(annotation, '__origin__'):\n85         # instantiated generic provided by a user\n86         qualname = stringify(annotation.__origin__)\n87     else:\n88         # we weren't able to extract the base type, appending arguments would\n89         # only make them appear twice\n90         return repr(annotation)\n91 \n92     if getattr(annotation, '__args__', None):\n93         if qualname == 'Union':\n94             if len(annotation.__args__) > 1 and annotation.__args__[-1] is NoneType:\n95                 if len(annotation.__args__) > 2:\n96                     args = ', '.join(stringify(a) for a in annotation.__args__[:-1])\n97                     return 'Optional[Union[%s]]' % args\n98                 else:\n99                     return 'Optional[%s]' % stringify(annotation.__args__[0])\n100             else:\n101                 args = ', '.join(stringify(a) for a in annotation.__args__)\n102                 return 'Union[%s]' % args\n103         elif qualname == 'Callable':\n104             args = ', '.join(stringify(a) for a in annotation.__args__[:-1])\n105             returns = stringify(annotation.__args__[-1])\n106             return '%s[[%s], %s]' % (qualname, args, returns)\n107         elif str(annotation).startswith('typing.Annotated'):  # for py39+\n108             return stringify(annotation.__args__[0])\n109         elif all(is_system_TypeVar(a) for a in annotation.__args__):\n110             # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n111             return qualname\n112         else:\n113             args = ', '.join(stringify(a) for a in annotation.__args__)\n114             return '%s[%s]' % (qualname, args)\n115 \n116     return qualname\n117 \n118 \n119 def _stringify_py36(annotation: Any) -> str:\n120     \"\"\"stringify() for py35 and py36.\"\"\"\n121     module = getattr(annotation, '__module__', None)\n122     if module == 'typing':\n123         if getattr(annotation, '_name', None):\n124             qualname = annotation._name\n125         elif getattr(annotation, '__qualname__', None):\n126             qualname = annotation.__qualname__\n127         elif getattr(annotation, '__forward_arg__', None):\n128             qualname = annotation.__forward_arg__\n129         elif getattr(annotation, '__origin__', None):\n130             qualname = stringify(annotation.__origin__)  # ex. Union\n131         else:\n132             qualname = repr(annotation).replace('typing.', '')\n133     elif hasattr(annotation, '__qualname__'):\n134         qualname = '%s.%s' % (module, annotation.__qualname__)\n135     else:\n136         qualname = repr(annotation)\n137 \n138     if (isinstance(annotation, typing.TupleMeta) and  # type: ignore\n139             not hasattr(annotation, '__tuple_params__')):  # for Python 3.6\n140         params = annotation.__args__\n141         if params:\n142             param_str = ', '.join(stringify(p) for p in params)\n143             return '%s[%s]' % (qualname, param_str)\n144         else:\n145             return qualname\n146     elif isinstance(annotation, typing.GenericMeta):\n147         params = None\n148         if hasattr(annotation, '__args__'):\n149             # for Python 3.5.2+\n150             if annotation.__args__ is None or len(annotation.__args__) <= 2:  # type: ignore  # NOQA\n151                 params = annotation.__args__  # type: ignore\n152             else:  # typing.Callable\n153                 args = ', '.join(stringify(arg) for arg\n154                                  in annotation.__args__[:-1])  # type: ignore\n155                 result = stringify(annotation.__args__[-1])  # type: ignore\n156                 return '%s[[%s], %s]' % (qualname, args, result)\n157         elif hasattr(annotation, '__parameters__'):\n158             # for Python 3.5.0 and 3.5.1\n159             params = annotation.__parameters__  # type: ignore\n160         if params is not None:\n161             param_str = ', '.join(stringify(p) for p in params)\n162             return '%s[%s]' % (qualname, param_str)\n163     elif (hasattr(typing, 'UnionMeta') and\n164           isinstance(annotation, typing.UnionMeta) and  # type: ignore\n165           hasattr(annotation, '__union_params__')):  # for Python 3.5\n166         params = annotation.__union_params__\n167         if params is not None:\n168             if len(params) == 2 and params[1] is NoneType:\n169                 return 'Optional[%s]' % stringify(params[0])\n170             else:\n171                 param_str = ', '.join(stringify(p) for p in params)\n172                 return '%s[%s]' % (qualname, param_str)\n173     elif (hasattr(annotation, '__origin__') and\n174           annotation.__origin__ is typing.Union):  # for Python 3.5.2+\n175         params = annotation.__args__\n176         if params is not None:\n177             if len(params) > 1 and params[-1] is NoneType:\n178                 if len(params) > 2:\n179                     param_str = \", \".join(stringify(p) for p in params[:-1])\n180                     return 'Optional[Union[%s]]' % param_str\n181                 else:\n182                     return 'Optional[%s]' % stringify(params[0])\n183             else:\n184                 param_str = ', '.join(stringify(p) for p in params)\n185                 return 'Union[%s]' % param_str\n186     elif (isinstance(annotation, typing.CallableMeta) and  # type: ignore\n187           getattr(annotation, '__args__', None) is not None and\n188           hasattr(annotation, '__result__')):  # for Python 3.5\n189         # Skipped in the case of plain typing.Callable\n190         args = annotation.__args__\n191         if args is None:\n192             return qualname\n193         elif args is Ellipsis:\n194             args_str = '...'\n195         else:\n196             formatted_args = (stringify(a) for a in args)\n197             args_str = '[%s]' % ', '.join(formatted_args)\n198         return '%s[%s, %s]' % (qualname,\n199                                args_str,\n200                                stringify(annotation.__result__))\n201     elif (isinstance(annotation, typing.TupleMeta) and  # type: ignore\n202           hasattr(annotation, '__tuple_params__') and\n203           hasattr(annotation, '__tuple_use_ellipsis__')):  # for Python 3.5\n204         params = annotation.__tuple_params__\n205         if params is not None:\n206             param_strings = [stringify(p) for p in params]\n207             if annotation.__tuple_use_ellipsis__:\n208                 param_strings.append('...')\n209             return '%s[%s]' % (qualname,\n210                                ', '.join(param_strings))\n211 \n212     return qualname\n",
        "intended_behavior": "This utility file should accurately process and represent generic types (`TypeVar`) in a way that Autodoc can utilize without causing `TypeError`s. It should provide robust mechanisms for identifying, parsing, and representing generic types so that when Autodoc generates documentation for classes using these types, it can do so accurately. Enhancements here might involve better parsing of complex type annotations or providing fallback representations that avoid concatenation errors. The utility's handling of generics should be compatible with all ways Autodoc might use this information, ensuring types are always displayed in an understandable and correct format in the generated documentation."
    }
]