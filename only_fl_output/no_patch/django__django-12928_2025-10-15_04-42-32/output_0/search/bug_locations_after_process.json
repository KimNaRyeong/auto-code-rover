[
    {
        "rel_file_path": "django/template/backends/django.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/backends/django.py",
        "start": 18,
        "end": 27,
        "class_name": "DjangoTemplates",
        "method_name": "__init__",
        "code": "18     def __init__(self, params):\n19         params = params.copy()\n20         options = params.pop('OPTIONS').copy()\n21         options.setdefault('autoescape', True)\n22         options.setdefault('debug', settings.DEBUG)\n23         options.setdefault('file_charset', 'utf-8')\n24         libraries = options.get('libraries', {})\n25         options['libraries'] = self.get_templatetag_libraries(libraries)\n26         super().__init__(params)\n27         self.engine = Engine(self.dirs, self.app_dirs, **options)\n",
        "intended_behavior": "The `__init__` method should be updated to handle new configuration options (e.g., `autoreload`) passed via the `TEMPLATES` settings in Django. When the `autoreload` option is set to `True`, this should enable the template backend to utilize a caching mechanism that also supports checking for changes in template files. The existing functionality for initializing the backend and configuring it based on provided parameters should be preserved, while adding the capability to register or acknowledge an autoreload mechanism."
    },
    {
        "rel_file_path": "django/template/backends/django.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/backends/django.py",
        "start": 14,
        "end": 45,
        "class_name": "DjangoTemplates",
        "method_name": null,
        "code": "14 class DjangoTemplates(BaseEngine):\n15 \n16     app_dirname = 'templates'\n17 \n18     def __init__(self, params):\n19         params = params.copy()\n20         options = params.pop('OPTIONS').copy()\n21         options.setdefault('autoescape', True)\n22         options.setdefault('debug', settings.DEBUG)\n23         options.setdefault('file_charset', 'utf-8')\n24         libraries = options.get('libraries', {})\n25         options['libraries'] = self.get_templatetag_libraries(libraries)\n26         super().__init__(params)\n27         self.engine = Engine(self.dirs, self.app_dirs, **options)\n28 \n29     def from_string(self, template_code):\n30         return Template(self.engine.from_string(template_code), self)\n31 \n32     def get_template(self, template_name):\n33         try:\n34             return Template(self.engine.get_template(template_name), self)\n35         except TemplateDoesNotExist as exc:\n36             reraise(exc, self)\n37 \n38     def get_templatetag_libraries(self, custom_libraries):\n39         \"\"\"\n40         Return a collation of template tag libraries from installed\n41         applications and the supplied custom_libraries argument.\n42         \"\"\"\n43         libraries = get_installed_libraries()\n44         libraries.update(custom_libraries)\n45         return libraries\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/template/loaders/cached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/loaders/cached.py",
        "start": 1,
        "end": 92,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Wrapper class that takes a list of template loaders as an argument and attempts\n3 to load templates from them in order, caching the result.\n4 \"\"\"\n5 \n6 import hashlib\n7 \n8 from django.template import TemplateDoesNotExist\n9 from django.template.backends.django import copy_exception\n10 \n11 from .base import Loader as BaseLoader\n12 \n13 \n14 class Loader(BaseLoader):\n15 \n16     def __init__(self, engine, loaders):\n17         self.get_template_cache = {}\n18         self.loaders = engine.get_template_loaders(loaders)\n19         super().__init__(engine)\n20 \n21     def get_contents(self, origin):\n22         return origin.loader.get_contents(origin)\n23 \n24     def get_template(self, template_name, skip=None):\n25         \"\"\"\n26         Perform the caching that gives this loader its name. Often many of the\n27         templates attempted will be missing, so memory use is of concern here.\n28         To keep it in check, caching behavior is a little complicated when a\n29         template is not found. See ticket #26306 for more details.\n30 \n31         With template debugging disabled, cache the TemplateDoesNotExist class\n32         for every missing template and raise a new instance of it after\n33         fetching it from the cache.\n34 \n35         With template debugging enabled, a unique TemplateDoesNotExist object\n36         is cached for each missing template to preserve debug data. When\n37         raising an exception, Python sets __traceback__, __context__, and\n38         __cause__ attributes on it. Those attributes can contain references to\n39         all sorts of objects up the call chain and caching them creates a\n40         memory leak. Thus, unraised copies of the exceptions are cached and\n41         copies of those copies are raised after they're fetched from the cache.\n42         \"\"\"\n43         key = self.cache_key(template_name, skip)\n44         cached = self.get_template_cache.get(key)\n45         if cached:\n46             if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n47                 raise cached(template_name)\n48             elif isinstance(cached, TemplateDoesNotExist):\n49                 raise copy_exception(cached)\n50             return cached\n51 \n52         try:\n53             template = super().get_template(template_name, skip)\n54         except TemplateDoesNotExist as e:\n55             self.get_template_cache[key] = copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n56             raise\n57         else:\n58             self.get_template_cache[key] = template\n59 \n60         return template\n61 \n62     def get_template_sources(self, template_name):\n63         for loader in self.loaders:\n64             yield from loader.get_template_sources(template_name)\n65 \n66     def cache_key(self, template_name, skip=None):\n67         \"\"\"\n68         Generate a cache key for the template name and skip.\n69 \n70         If skip is provided, only origins that match template_name are included\n71         in the cache key. This ensures each template is only parsed and cached\n72         once if contained in different extend chains like:\n73 \n74             x -> a -> a\n75             y -> a -> a\n76             z -> a -> a\n77         \"\"\"\n78         skip_prefix = ''\n79 \n80         if skip:\n81             matching = [origin.name for origin in skip if origin.template_name == template_name]\n82             if matching:\n83                 skip_prefix = self.generate_hash(matching)\n84 \n85         return '-'.join(s for s in (str(template_name), skip_prefix) if s)\n86 \n87     def generate_hash(self, values):\n88         return hashlib.sha1('|'.join(values).encode()).hexdigest()\n89 \n90     def reset(self):\n91         \"Empty the template cache.\"\n92         self.get_template_cache.clear()\n",
        "intended_behavior": "Considering there was no direct reference to a `CachedLoader` class in the provided API search results, but assuming its existence based on Django's naming and implementation patterns, the intended behavior here would be to enhance or ensure the `get_template` method (or equivalent functionality within the cached loading mechanism) supports autoreloading. This means implementing a check for template file changes before serving a cached version of a template. If a change is detected, the loader should refresh its cache for the changed template. This behavior should only be activated when the `autoreload` option is enabled in the backend configuration to avoid affecting performance in production environments."
    }
]