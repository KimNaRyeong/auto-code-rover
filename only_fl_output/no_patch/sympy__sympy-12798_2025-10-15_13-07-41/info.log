2025-10-15 13:07:41.231 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 13:07:45.551 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=125, output_tokens=12, cost=0.001610
2025-10-15 13:07:45.551 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 13:07:45.555 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:07:49.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=433, output_tokens=128, cost=0.008170
2025-10-15 13:07:49.841 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:07:51.480 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=482, output_tokens=27, cost=0.005630
2025-10-15 13:07:51.481 | DEBUG    | Extracted a valid json.
2025-10-15 13:07:51.481 | DEBUG    | Agent proxy return the following json: {
  "API_calls": ["search_method(\"ff\")", "search_method(\"rf\")"],
  "bug_locations": []
}
2025-10-15 13:07:51.487 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:07:51.488 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:08:01.293 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=708, output_tokens=309, cost=0.016350
2025-10-15 13:08:01.303 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:08:04.503 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1233, output_tokens=85, cost=0.014880
2025-10-15 13:08:04.506 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:08:07.036 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=439, output_tokens=32, cost=0.005350
2025-10-15 13:08:07.037 | DEBUG    | Extracted a valid json.
2025-10-15 13:08:07.042 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"ff\")",
        "search_method(\"rf\")"
    ],
    "bug_locations": []
}
2025-10-15 13:08:07.047 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:08:07.048 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:08:18.710 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1465, output_tokens=439, cost=0.027820
2025-10-15 13:08:18.722 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:08:19.747 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2120, output_tokens=17, cost=0.021710
2025-10-15 13:08:19.750 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:08:21.442 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=371, output_tokens=35, cost=0.004760
2025-10-15 13:08:21.443 | DEBUG    | Extracted a valid json.
2025-10-15 13:08:21.443 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"falling factorial\")",
        "search_code(\"rising factorial\")"
    ],
    "bug_locations": []
}
2025-10-15 13:08:21.535 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:08:21.535 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:08:38.426 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2497, output_tokens=604, cost=0.043090
2025-10-15 13:08:38.436 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:08:46.707 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3317, output_tokens=303, cost=0.042260
2025-10-15 13:08:46.714 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:08:55.454 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=657, output_tokens=251, cost=0.014100
2025-10-15 13:08:55.455 | DEBUG    | Extracted a valid json.
2025-10-15 13:08:55.455 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/polys/polytools.py",
            "class": "",
            "method": "gff",
            "intended_behavior": "The `gff` function, while currently raising a `NotImplementedError`, suggests a placeholder for future implementation of symbolic falling factorial operations. While not directly a bug, the placeholder indicates an area of future development. The intended functionality here should, eventually, accurately compute the greatest factorial factorization for given inputs in symbolic form, aligning with the mathematical definition of falling factorials."
        },
        {
            "file": "sympy/functions/combinatorial/factorials.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file, which likely includes implementations of rising and potentially falling factorial functions (`rf` and possibly `ff`), should ensure that the definitions and computational logic for these factorials conform to established mathematical standards. If changes were made that diverge from these standards, the intended behavior would involve reverting such changes or ensuring the computations are mathematically accurate, efficient, and reflective of the functions' respective definitions."
        }
    ]
}
2025-10-15 13:08:55.464 | DEBUG    | Bug location extracted successfully: [<file>sympy/polys/polytools.py</file>
<class>None</class>
<method>gff</method>
<code>
5647 def gff(f, *gens, **args):
5648     """Compute greatest factorial factorization of ``f``. """
5649     raise NotImplementedError('symbolic falling factorial')

</code><intended_behavior>The `gff` function, while currently raising a `NotImplementedError`, suggests a placeholder for future implementation of symbolic falling factorial operations. While not directly a bug, the placeholder indicates an area of future development. The intended functionality here should, eventually, accurately compute the greatest factorial factorization for given inputs in symbolic form, aligning with the mathematical definition of falling factorials.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, Dummy, Mod
4 from sympy.core.function import Function, ArgumentIndexError
5 from sympy.core.logic import fuzzy_and
6 from sympy.core.numbers import Integer, pi
7 from sympy.core.relational import Eq
8 
9 from sympy.ntheory import sieve
10 
11 from math import sqrt as _sqrt
12 
13 from sympy.core.compatibility import reduce, range, HAS_GMPY
14 from sympy.core.cache import cacheit
15 
16 from sympy.polys.polytools import poly_from_expr
17 from sympy.polys.polyerrors import PolificationFailed
18 
19 
20 class CombinatorialFunction(Function):
21     """Base class for combinatorial functions. """
22 
23     def _eval_simplify(self, ratio, measure):
24         from sympy.simplify.simplify import combsimp
25         expr = combsimp(self)
26         if measure(expr) <= ratio*measure(self):
27             return expr
28         return self
29 
30 ###############################################################################
31 ######################## FACTORIAL and MULTI-FACTORIAL ########################
32 ###############################################################################
33 
34 
35 class factorial(CombinatorialFunction):
36     """Implementation of factorial function over nonnegative integers.
37        By convention (consistent with the gamma function and the binomial
38        coefficients), factorial of a negative integer is complex infinity.
39 
40        The factorial is very important in combinatorics where it gives
41        the number of ways in which `n` objects can be permuted. It also
42        arises in calculus, probability, number theory, etc.
43 
44        There is strict relation of factorial with gamma function. In
45        fact n! = gamma(n+1) for nonnegative integers. Rewrite of this
46        kind is very useful in case of combinatorial simplification.
47 
48        Computation of the factorial is done using two algorithms. For
49        small arguments a precomputed look up table is used. However for bigger
50        input algorithm Prime-Swing is used. It is the fastest algorithm
51        known and computes n! via prime factorization of special class
52        of numbers, called here the 'Swing Numbers'.
53 
54        Examples
55        ========
56 
57        >>> from sympy import Symbol, factorial, S
58        >>> n = Symbol('n', integer=True)
59 
60        >>> factorial(0)
61        1
62 
63        >>> factorial(7)
64        5040
65 
66        >>> factorial(-2)
67        zoo
68 
69        >>> factorial(n)
70        factorial(n)
71 
72        >>> factorial(2*n)
73        factorial(2*n)
74 
75        >>> factorial(S(1)/2)
76        factorial(1/2)
77 
78        See Also
79        ========
80 
81        factorial2, RisingFactorial, FallingFactorial
82     """
83 
84     def fdiff(self, argindex=1):
85         from sympy import gamma, polygamma
86         if argindex == 1:
87             return gamma(self.args[0] + 1)*polygamma(0, self.args[0] + 1)
88         else:
89             raise ArgumentIndexError(self, argindex)
90 
91     _small_swing = [
92         1, 1, 1, 3, 3, 15, 5, 35, 35, 315, 63, 693, 231, 3003, 429, 6435, 6435, 109395,
93         12155, 230945, 46189, 969969, 88179, 2028117, 676039, 16900975, 1300075,
94         35102025, 5014575, 145422675, 9694845, 300540195, 300540195
95     ]
96 
97     _small_factorials = []
98 
99     @classmethod
100     def _swing(cls, n):
101         if n < 33:
102             return cls._small_swing[n]
103         else:
104             N, primes = int(_sqrt(n)), []
105 
106             for prime in sieve.primerange(3, N + 1):
107                 p, q = 1, n
108 
109                 while True:
110                     q //= prime
111 
112                     if q > 0:
113                         if q & 1 == 1:
114                             p *= prime
115                     else:
116                         break
117 
118                 if p > 1:
119                     primes.append(p)
120 
121             for prime in sieve.primerange(N + 1, n//3 + 1):
122                 if (n // prime) & 1 == 1:
123                     primes.append(prime)
124 
125             L_product = R_product = 1
126 
127             for prime in sieve.primerange(n//2 + 1, n + 1):
128                 L_product *= prime
129 
130             for prime in primes:
131                 R_product *= prime
132 
133             return L_product*R_product
134 
135     @classmethod
136     def _recursive(cls, n):
137         if n < 2:
138             return 1
139         else:
140             return (cls._recursive(n//2)**2)*cls._swing(n)
141 
142     @classmethod
143     def eval(cls, n):
144         n = sympify(n)
145 
146         if n.is_Number:
147             if n is S.Zero:
148                 return S.One
149             elif n is S.Infinity:
150                 return S.Infinity
151             elif n.is_Integer:
152                 if n.is_negative:
153                     return S.ComplexInfinity
154                 else:
155                     n = n.p
156 
157                     if n < 20:
158                         if not cls._small_factorials:
159                             result = 1
160                             for i in range(1, 20):
161                                 result *= i
162                                 cls._small_factorials.append(result)
163                         result = cls._small_factorials[n-1]
164 
165                     # GMPY factorial is faster, use it when available
166                     elif HAS_GMPY:
167                         from sympy.core.compatibility import gmpy
168                         result = gmpy.fac(n)
169 
170                     else:
171                         bits = bin(n).count('1')
172                         result = cls._recursive(n)*2**(n - bits)
173 
174                     return Integer(result)
175 
176     def _eval_rewrite_as_gamma(self, n):
177         from sympy import gamma
178         return gamma(n + 1)
179 
180     def _eval_rewrite_as_Product(self, n):
181         from sympy import Product
182         if n.is_nonnegative and n.is_integer:
183             i = Dummy('i', integer=True)
184             return Product(i, (i, 1, n))
185 
186     def _eval_is_integer(self):
187         if self.args[0].is_integer and self.args[0].is_nonnegative:
188             return True
189 
190     def _eval_is_positive(self):
191         if self.args[0].is_integer and self.args[0].is_nonnegative:
192             return True
193 
194     def _eval_is_composite(self):
195         x = self.args[0]
196         if x.is_integer:
197             return (x - 3).is_nonnegative
198 
199     def _eval_is_real(self):
200         x = self.args[0]
201         if x.is_nonnegative or x.is_noninteger:
202             return True
203 
204 
205 class MultiFactorial(CombinatorialFunction):
206     pass
207 
208 
209 class subfactorial(CombinatorialFunction):
210     r"""The subfactorial counts the derangements of n items and is
211     defined for non-negative integers as::
212 
213               ,
214              |  1                             for n = 0
215         !n = {  0                             for n = 1
216              |  (n - 1)*(!(n - 1) + !(n - 2)) for n > 1
217               `
218 
219     It can also be written as int(round(n!/exp(1))) but the recursive
220     definition with caching is implemented for this function.
221 
222     An interesting analytic expression is the following [2]_
223 
224     .. math:: !x = \Gamma(x + 1, -1)/e
225 
226     which is valid for non-negative integers x. The above formula
227     is not very useful incase of non-integers. :math:`\Gamma(x + 1, -1)` is
228     single-valued only for integral arguments x, elsewhere on the positive real
229     axis it has an infinite number of branches none of which are real.
230 
231     References
232     ==========
233 
234     .. [1] http://en.wikipedia.org/wiki/Subfactorial
235     .. [2] http://mathworld.wolfram.com/Subfactorial.html
236 
237     Examples
238     ========
239 
240     >>> from sympy import subfactorial
241     >>> from sympy.abc import n
242     >>> subfactorial(n + 1)
243     subfactorial(n + 1)
244     >>> subfactorial(5)
245     44
246 
247     See Also
248     ========
249 
250     sympy.functions.combinatorial.factorials.factorial,
251     sympy.utilities.iterables.generate_derangements,
252     sympy.functions.special.gamma_functions.uppergamma
253     """
254 
255     @classmethod
256     @cacheit
257     def _eval(self, n):
258         if not n:
259             return S.One
260         elif n == 1:
261             return S.Zero
262         return (n - 1)*(self._eval(n - 1) + self._eval(n - 2))
263 
264     @classmethod
265     def eval(cls, arg):
266         if arg.is_Number:
267             if arg.is_Integer and arg.is_nonnegative:
268                 return cls._eval(arg)
269             elif arg is S.NaN:
270                 return S.NaN
271             elif arg is S.Infinity:
272                 return S.Infinity
273 
274     def _eval_is_even(self):
275         if self.args[0].is_odd and self.args[0].is_nonnegative:
276             return True
277 
278     def _eval_is_integer(self):
279         if self.args[0].is_integer and self.args[0].is_nonnegative:
280             return True
281 
282     def _eval_rewrite_as_uppergamma(self, arg):
283         from sympy import uppergamma
284         return uppergamma(arg + 1, -1)/S.Exp1
285 
286     def _eval_is_nonnegative(self):
287         if self.args[0].is_integer and self.args[0].is_nonnegative:
288             return True
289 
290     def _eval_is_odd(self):
291         if self.args[0].is_even and self.args[0].is_nonnegative:
292             return True
293 
294 
295 class factorial2(CombinatorialFunction):
296     """The double factorial n!!, not to be confused with (n!)!
297 
298     The double factorial is defined for nonnegative integers and for odd
299     negative integers as::
300 
301                ,
302               |  n*(n - 2)*(n - 4)* ... * 1    for n positive odd
303         n!! = {  n*(n - 2)*(n - 4)* ... * 2    for n positive even
304               |  1                             for n = 0
305               |  (n+2)!! / (n+2)               for n negative odd
306                `
307 
308     References
309     ==========
310     .. [1] https://en.wikipedia.org/wiki/Double_factorial
311 
312     Examples
313     ========
314 
315     >>> from sympy import factorial2, var
316     >>> var('n')
317     n
318     >>> factorial2(n + 1)
319     factorial2(n + 1)
320     >>> factorial2(5)
321     15
322     >>> factorial2(-1)
323     1
324     >>> factorial2(-5)
325     1/3
326 
327     See Also
328     ========
329 
330     factorial, RisingFactorial, FallingFactorial
331     """
332 
333     @classmethod
334     def eval(cls, arg):
335         # TODO: extend this to complex numbers?
336 
337         if arg.is_Number:
338             if not arg.is_Integer:
339                 raise ValueError("argument must be nonnegative integer or negative odd integer")
340 
341             # This implementation is faster than the recursive one
342             # It also avoids "maximum recursion depth exceeded" runtime error
343             if arg.is_nonnegative:
344                 if arg.is_even:
345                     k = arg / 2
346                     return 2 ** k * factorial(k)
347                 return factorial(arg) / factorial2(arg - 1)
348 
349 
350             if arg.is_odd:
351                 return arg * (S.NegativeOne) ** ((1 - arg) / 2) / factorial2(-arg)
352             raise ValueError("argument must be nonnegative integer or negative odd integer")
353 
354 
355     def _eval_is_even(self):
356         # Double factorial is even for every positive even input
357         n = self.args[0]
358         if n.is_integer:
359             if n.is_odd:
360                 return False
361             if n.is_even:
362                 if n.is_positive:
363                     return True
364                 if n.is_zero:
365                     return False
366 
367     def _eval_is_integer(self):
368         # Double factorial is an integer for every nonnegative input, and for
369         # -1 and -3
370         n = self.args[0]
371         if n.is_integer:
372             if (n + 1).is_nonnegative:
373                 return True
374             if n.is_odd:
375                 return (n + 3).is_nonnegative
376 
377     def _eval_is_odd(self):
378         # Double factorial is odd for every odd input not smaller than -3, and
379         # for 0
380         n = self.args[0]
381         if n.is_odd:
382             return (n + 3).is_nonnegative
383         if n.is_even:
384             if n.is_positive:
385                 return False
386             if n.is_zero:
387                 return True
388 
389     def _eval_is_positive(self):
390         # Double factorial is positive for every nonnegative input, and for
391         # every odd negative input which is of the form -1-4k for an
392         # nonnegative integer k
393         n = self.args[0]
394         if n.is_integer:
395             if (n + 1).is_nonnegative:
396                 return True
397             if n.is_odd:
398                 return ((n + 1) / 2).is_even
399 
400     def _eval_rewrite_as_gamma(self, n):
401         from sympy import gamma, Piecewise, sqrt
402         return 2**(n/2)*gamma(n/2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)), (sqrt(2/pi), Eq(Mod(n, 2), 1)))
403 
404 
405 ###############################################################################
406 ######################## RISING and FALLING FACTORIALS ########################
407 ###############################################################################
408 
409 
410 class RisingFactorial(CombinatorialFunction):
411     """Rising factorial (also called Pochhammer symbol) is a double valued
412     function arising in concrete mathematics, hypergeometric functions
413     and series expansions. It is defined by:
414 
415                 rf(x, k) = x * (x + 1) * ... * (x + k - 1)
416 
417     where 'x' can be arbitrary expression and 'k' is an integer. For
418     more information check "Concrete mathematics" by Graham, pp. 66
419     or visit http://mathworld.wolfram.com/RisingFactorial.html page.
420 
421     When x is a polynomial f of a single variable y of order >= 1,
422     rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in
423     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
424     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
425 
426     Examples
427     ========
428 
429     >>> from sympy import rf, symbols, factorial, ff, binomial
430     >>> from sympy.abc import x
431     >>> n, k = symbols('n k', integer=True)
432     >>> rf(x, 0)
433     1
434     >>> rf(1, 5)
435     120
436     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)
437     True
438     >>> rf(x**3, 2)
439     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')
440 
441     Rewrite
442 
443     >>> rf(x, k).rewrite(ff)
444     FallingFactorial(k + x - 1, k)
445     >>> rf(x, k).rewrite(binomial)
446     binomial(k + x - 1, k)*factorial(k)
447     >>> rf(n, k).rewrite(factorial)
448     factorial(k + n - 1)/factorial(n - 1)
449 
450     See Also
451     ========
452 
453     factorial, factorial2, FallingFactorial
454 
455     References
456     ==========
457 
458     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol
459     """
460 
461     @classmethod
462     def eval(cls, x, k):
463         x = sympify(x)
464         k = sympify(k)
465 
466         if x is S.NaN or k is S.NaN:
467             return S.NaN
468         elif x is S.One:
469             return factorial(k)
470         elif k.is_Integer:
471             if k is S.Zero:
472                 return S.One
473             else:
474                 if k.is_positive:
475                     if x is S.Infinity:
476                         return S.Infinity
477                     elif x is S.NegativeInfinity:
478                         if k.is_odd:
479                             return S.NegativeInfinity
480                         else:
481                             return S.Infinity
482                     else:
483                         try:
484                             F, opt = poly_from_expr(x)
485                         except PolificationFailed:
486                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
487                         if len(opt.gens) > 1 or F.degree() <= 1:
488                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
489                         else:
490                             v = opt.gens[0]
491                             return reduce(lambda r, i:
492                                           r*(F.subs(v, v + i).expand()),
493                                           range(0, int(k)), 1)
494                 else:
495                     if x is S.Infinity:
496                         return S.Infinity
497                     elif x is S.NegativeInfinity:
498                         return S.Infinity
499                     else:
500                         try:
501                             F, opt = poly_from_expr(x)
502                         except PolificationFailed:
503                             return 1/reduce(lambda r, i:
504                                             r*(x - i),
505                                             range(1, abs(int(k)) + 1), 1)
506                         if len(opt.gens) > 1 or F.degree() <= 1:
507                             return 1/reduce(lambda r, i:
508                                             r*(x - i),
509                                             range(1, abs(int(k)) + 1), 1)
510                         else:
511                             v = opt.gens[0]
512                             return 1/reduce(lambda r, i:
513                                             r*(F.subs(v, v - i).expand()),
514                                             range(1, abs(int(k)) + 1), 1)
515 
516     def _eval_rewrite_as_gamma(self, x, k):
517         from sympy import gamma
518         return gamma(x + k) / gamma(x)
519 
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)
522 
523     def _eval_rewrite_as_factorial(self, x, k):
524         if x.is_integer and k.is_integer:
525             return factorial(k + x - 1) / factorial(x - 1)
526 
527     def _eval_rewrite_as_binomial(self, x, k):
528         if k.is_integer:
529             return factorial(k) * binomial(x + k - 1, k)
530 
531     def _eval_is_integer(self):
532         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
533                           self.args[1].is_nonnegative))
534 
535     def _sage_(self):
536         import sage.all as sage
537         return sage.rising_factorial(self.args[0]._sage_(), self.args[1]._sage_())
538 
539 
540 class FallingFactorial(CombinatorialFunction):
541     """Falling factorial (related to rising factorial) is a double valued
542     function arising in concrete mathematics, hypergeometric functions
543     and series expansions. It is defined by
544 
545                 ff(x, k) = x * (x-1) * ... * (x - k+1)
546 
547     where 'x' can be arbitrary expression and 'k' is an integer. For
548     more information check "Concrete mathematics" by Graham, pp. 66
549     or visit http://mathworld.wolfram.com/FallingFactorial.html page.
550 
551     When x is a polynomial f of a single variable y of order >= 1,
552     ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in
553     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
554     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
555 
556     >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols
557     >>> from sympy.abc import x, k
558     >>> n, m = symbols('n m', integer=True)
559     >>> ff(x, 0)
560     1
561     >>> ff(5, 5)
562     120
563     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)
564     True
565     >>> ff(x**2, 2)
566     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')
567     >>> ff(n, n)
568     factorial(n)
569 
570     Rewrite
571 
572     >>> ff(x, k).rewrite(gamma)
573     (-1)**k*gamma(k - x)/gamma(-x)
574     >>> ff(x, k).rewrite(rf)
575     RisingFactorial(-k + x + 1, k)
576     >>> ff(x, m).rewrite(binomial)
577     binomial(x, m)*factorial(m)
578     >>> ff(n, m).rewrite(factorial)
579     factorial(n)/factorial(-m + n)
580 
581     See Also
582     ========
583 
584     factorial, factorial2, RisingFactorial
585 
586     References
587     ==========
588 
589     .. [1] http://mathworld.wolfram.com/FallingFactorial.html
590     """
591 
592     @classmethod
593     def eval(cls, x, k):
594         x = sympify(x)
595         k = sympify(k)
596 
597         if x is S.NaN or k is S.NaN:
598             return S.NaN
599         elif k.is_integer and x == k:
600             return factorial(x)
601         elif k.is_Integer:
602             if k is S.Zero:
603                 return S.One
604             else:
605                 if k.is_positive:
606                     if x is S.Infinity:
607                         return S.Infinity
608                     elif x is S.NegativeInfinity:
609                         if k.is_odd:
610                             return S.NegativeInfinity
611                         else:
612                             return S.Infinity
613                     else:
614                         try:
615                             F, opt = poly_from_expr(x)
616                         except PolificationFailed:
617                             return reduce(lambda r, i: r*(x - i),
618                                           range(0, int(k)), 1)
619                         if len(opt.gens) > 1 or F.degree() <= 1:
620                             return reduce(lambda r, i: r*(x - i),
621                                           range(0, int(k)), 1)
622                         else:
623                             v = opt.gens[0]
624                             return reduce(lambda r, i:
625                                           r*(F.subs(v, v - i).expand()),
626                                           range(0, int(k)), 1)
627                 else:
628                     if x is S.Infinity:
629                         return S.Infinity
630                     elif x is S.NegativeInfinity:
631                         return S.Infinity
632                     else:
633                         try:
634                             F, opt = poly_from_expr(x)
635                         except PolificationFailed:
636                             return 1/reduce(lambda r, i: r*(x + i),
637                                             range(1, abs(int(k)) + 1), 1)
638                         if len(opt.gens) > 1 or F.degree() <= 1:
639                             return 1/reduce(lambda r, i: r*(x + i),
640                                             range(1, abs(int(k)) + 1), 1)
641                         else:
642                             v = opt.gens[0]
643                             return 1/reduce(lambda r, i:
644                                             r*(F.subs(v, v + i).expand()),
645                                             range(1, abs(int(k)) + 1), 1)
646 
647     def _eval_rewrite_as_gamma(self, x, k):
648         from sympy import gamma
649         return (-1)**k*gamma(k - x) / gamma(-x)
650 
651     def _eval_rewrite_as_RisingFactorial(self, x, k):
652         return rf(x - k + 1, k)
653 
654     def _eval_rewrite_as_binomial(self, x, k):
655         if k.is_integer:
656             return factorial(k) * binomial(x, k)
657 
658     def _eval_rewrite_as_factorial(self, x, k):
659         if x.is_integer and k.is_integer:
660             return factorial(x) / factorial(x - k)
661 
662     def _eval_is_integer(self):
663         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
664                           self.args[1].is_nonnegative))
665 
666     def _sage_(self):
667         import sage.all as sage
668         return sage.falling_factorial(self.args[0]._sage_(),
669                                       self.args[1]._sage_())
670 
671 
672 rf = RisingFactorial
673 ff = FallingFactorial
674 
675 ###############################################################################
676 ########################### BINOMIAL COEFFICIENTS #############################
677 ###############################################################################
678 
679 
680 class binomial(CombinatorialFunction):
681     """Implementation of the binomial coefficient. It can be defined
682     in two ways depending on its desired interpretation:
683 
684         C(n,k) = n!/(k!(n-k)!)   or   C(n, k) = ff(n, k)/k!
685 
686     First, in a strict combinatorial sense it defines the
687     number of ways we can choose 'k' elements from a set of
688     'n' elements. In this case both arguments are nonnegative
689     integers and binomial is computed using an efficient
690     algorithm based on prime factorization.
691 
692     The other definition is generalization for arbitrary 'n',
693     however 'k' must also be nonnegative. This case is very
694     useful when evaluating summations.
695 
696     For the sake of convenience for negative 'k' this function
697     will return zero no matter what valued is the other argument.
698 
699     To expand the binomial when n is a symbol, use either
700     expand_func() or expand(func=True). The former will keep the
701     polynomial in factored form while the latter will expand the
702     polynomial itself. See examples for details.
703 
704     Examples
705     ========
706 
707     >>> from sympy import Symbol, Rational, binomial, expand_func
708     >>> n = Symbol('n', integer=True, positive=True)
709 
710     >>> binomial(15, 8)
711     6435
712 
713     >>> binomial(n, -1)
714     0
715 
716     Rows of Pascal's triangle can be generated with the binomial function:
717 
718     >>> for N in range(8):
719     ...     print([ binomial(N, i) for i in range(N + 1)])
720     ...
721     [1]
722     [1, 1]
723     [1, 2, 1]
724     [1, 3, 3, 1]
725     [1, 4, 6, 4, 1]
726     [1, 5, 10, 10, 5, 1]
727     [1, 6, 15, 20, 15, 6, 1]
728     [1, 7, 21, 35, 35, 21, 7, 1]
729 
730     As can a given diagonal, e.g. the 4th diagonal:
731 
732     >>> N = -4
733     >>> [ binomial(N, i) for i in range(1 - N)]
734     [1, -4, 10, -20, 35]
735 
736     >>> binomial(Rational(5, 4), 3)
737     -5/128
738     >>> binomial(Rational(-5, 4), 3)
739     -195/128
740 
741     >>> binomial(n, 3)
742     binomial(n, 3)
743 
744     >>> binomial(n, 3).expand(func=True)
745     n**3/6 - n**2/2 + n/3
746 
747     >>> expand_func(binomial(n, 3))
748     n*(n - 2)*(n - 1)/6
749 
750     """
751 
752     def fdiff(self, argindex=1):
753         from sympy import polygamma
754         if argindex == 1:
755             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/01/
756             n, k = self.args
757             return binomial(n, k)*(polygamma(0, n + 1) - \
758                 polygamma(0, n - k + 1))
759         elif argindex == 2:
760             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/02/
761             n, k = self.args
762             return binomial(n, k)*(polygamma(0, n - k + 1) - \
763                 polygamma(0, k + 1))
764         else:
765             raise ArgumentIndexError(self, argindex)
766 
767     @classmethod
768     def _eval(self, n, k):
769         # n.is_Number and k.is_Integer and k != 1 and n != k
770         if k.is_Integer:
771             if n.is_Integer and n >= 0:
772                 n, k = int(n), int(k)
773 
774                 if k > n:
775                     return S.Zero
776                 elif k > n // 2:
777                     k = n - k
778 
779                 M, result = int(_sqrt(n)), 1
780 
781                 for prime in sieve.primerange(2, n + 1):
782                     if prime > n - k:
783                         result *= prime
784                     elif prime > n // 2:
785                         continue
786                     elif prime > M:
787                         if n % prime < k % prime:
788                             result *= prime
789                     else:
790                         N, K = n, k
791                         exp = a = 0
792 
793                         while N > 0:
794                             a = int((N % prime) < (K % prime + a))
795                             N, K = N // prime, K // prime
796                             exp = a + exp
797 
798                         if exp > 0:
799                             result *= prime**exp
800                 return Integer(result)
801             else:
802                 d = result = n - k + 1
803                 for i in range(2, k + 1):
804                     d += 1
805                     result *= d
806                     result /= i
807                 return result
808 
809     @classmethod
810     def eval(cls, n, k):
811         n, k = map(sympify, (n, k))
812         d = n - k
813         if d.is_zero or k.is_zero:
814             return S.One
815         elif d.is_zero is False:
816             if (k - 1).is_zero:
817                 return n
818             elif k.is_negative:
819                 return S.Zero
820             elif n.is_integer and n.is_nonnegative and d.is_negative:
821                 return S.Zero
822         if k.is_Integer and k > 0 and n.is_Number:
823             return cls._eval(n, k)
824 
825     def _eval_expand_func(self, **hints):
826         """
827         Function to expand binomial(n,k) when m is positive integer
828         Also,
829         n is self.args[0] and k is self.args[1] while using binomial(n, k)
830         """
831         n = self.args[0]
832         if n.is_Number:
833             return binomial(*self.args)
834 
835         k = self.args[1]
836         if k.is_Add and n in k.args:
837             k = n - k
838 
839         if k.is_Integer:
840             if k == S.Zero:
841                 return S.One
842             elif k < 0:
843                 return S.Zero
844             else:
845                 n = self.args[0]
846                 result = n - k + 1
847                 for i in range(2, k + 1):
848                     result *= n - k + i
849                     result /= i
850                 return result
851         else:
852             return binomial(*self.args)
853 
854     def _eval_rewrite_as_factorial(self, n, k):
855         return factorial(n)/(factorial(k)*factorial(n - k))
856 
857     def _eval_rewrite_as_gamma(self, n, k):
858         from sympy import gamma
859         return gamma(n + 1)/(gamma(k + 1)*gamma(n - k + 1))
860 
861     def _eval_rewrite_as_tractable(self, n, k):
862         return self._eval_rewrite_as_gamma(n, k).rewrite('tractable')
863 
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)
867 
868     def _eval_is_integer(self):
869         n, k = self.args
870         if n.is_integer and k.is_integer:
871             return True
872         elif k.is_integer is False:
873             return False

</code><intended_behavior>This file, which likely includes implementations of rising and potentially falling factorial functions (`rf` and possibly `ff`), should ensure that the definitions and computational logic for these factorials conform to established mathematical standards. If changes were made that diverge from these standards, the intended behavior would involve reverting such changes or ensuring the computations are mathematically accurate, efficient, and reflective of the functions' respective definitions.</intended_behavior>]
2025-10-15 13:08:55.464 | INFO     | Search completed. Bug locations: [<file>sympy/polys/polytools.py</file>
<class>None</class>
<method>gff</method>
<code>
5647 def gff(f, *gens, **args):
5648     """Compute greatest factorial factorization of ``f``. """
5649     raise NotImplementedError('symbolic falling factorial')

</code><intended_behavior>The `gff` function, while currently raising a `NotImplementedError`, suggests a placeholder for future implementation of symbolic falling factorial operations. While not directly a bug, the placeholder indicates an area of future development. The intended functionality here should, eventually, accurately compute the greatest factorial factorization for given inputs in symbolic form, aligning with the mathematical definition of falling factorials.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, Dummy, Mod
4 from sympy.core.function import Function, ArgumentIndexError
5 from sympy.core.logic import fuzzy_and
6 from sympy.core.numbers import Integer, pi
7 from sympy.core.relational import Eq
8 
9 from sympy.ntheory import sieve
10 
11 from math import sqrt as _sqrt
12 
13 from sympy.core.compatibility import reduce, range, HAS_GMPY
14 from sympy.core.cache import cacheit
15 
16 from sympy.polys.polytools import poly_from_expr
17 from sympy.polys.polyerrors import PolificationFailed
18 
19 
20 class CombinatorialFunction(Function):
21     """Base class for combinatorial functions. """
22 
23     def _eval_simplify(self, ratio, measure):
24         from sympy.simplify.simplify import combsimp
25         expr = combsimp(self)
26         if measure(expr) <= ratio*measure(self):
27             return expr
28         return self
29 
30 ###############################################################################
31 ######################## FACTORIAL and MULTI-FACTORIAL ########################
32 ###############################################################################
33 
34 
35 class factorial(CombinatorialFunction):
36     """Implementation of factorial function over nonnegative integers.
37        By convention (consistent with the gamma function and the binomial
38        coefficients), factorial of a negative integer is complex infinity.
39 
40        The factorial is very important in combinatorics where it gives
41        the number of ways in which `n` objects can be permuted. It also
42        arises in calculus, probability, number theory, etc.
43 
44        There is strict relation of factorial with gamma function. In
45        fact n! = gamma(n+1) for nonnegative integers. Rewrite of this
46        kind is very useful in case of combinatorial simplification.
47 
48        Computation of the factorial is done using two algorithms. For
49        small arguments a precomputed look up table is used. However for bigger
50        input algorithm Prime-Swing is used. It is the fastest algorithm
51        known and computes n! via prime factorization of special class
52        of numbers, called here the 'Swing Numbers'.
53 
54        Examples
55        ========
56 
57        >>> from sympy import Symbol, factorial, S
58        >>> n = Symbol('n', integer=True)
59 
60        >>> factorial(0)
61        1
62 
63        >>> factorial(7)
64        5040
65 
66        >>> factorial(-2)
67        zoo
68 
69        >>> factorial(n)
70        factorial(n)
71 
72        >>> factorial(2*n)
73        factorial(2*n)
74 
75        >>> factorial(S(1)/2)
76        factorial(1/2)
77 
78        See Also
79        ========
80 
81        factorial2, RisingFactorial, FallingFactorial
82     """
83 
84     def fdiff(self, argindex=1):
85         from sympy import gamma, polygamma
86         if argindex == 1:
87             return gamma(self.args[0] + 1)*polygamma(0, self.args[0] + 1)
88         else:
89             raise ArgumentIndexError(self, argindex)
90 
91     _small_swing = [
92         1, 1, 1, 3, 3, 15, 5, 35, 35, 315, 63, 693, 231, 3003, 429, 6435, 6435, 109395,
93         12155, 230945, 46189, 969969, 88179, 2028117, 676039, 16900975, 1300075,
94         35102025, 5014575, 145422675, 9694845, 300540195, 300540195
95     ]
96 
97     _small_factorials = []
98 
99     @classmethod
100     def _swing(cls, n):
101         if n < 33:
102             return cls._small_swing[n]
103         else:
104             N, primes = int(_sqrt(n)), []
105 
106             for prime in sieve.primerange(3, N + 1):
107                 p, q = 1, n
108 
109                 while True:
110                     q //= prime
111 
112                     if q > 0:
113                         if q & 1 == 1:
114                             p *= prime
115                     else:
116                         break
117 
118                 if p > 1:
119                     primes.append(p)
120 
121             for prime in sieve.primerange(N + 1, n//3 + 1):
122                 if (n // prime) & 1 == 1:
123                     primes.append(prime)
124 
125             L_product = R_product = 1
126 
127             for prime in sieve.primerange(n//2 + 1, n + 1):
128                 L_product *= prime
129 
130             for prime in primes:
131                 R_product *= prime
132 
133             return L_product*R_product
134 
135     @classmethod
136     def _recursive(cls, n):
137         if n < 2:
138             return 1
139         else:
140             return (cls._recursive(n//2)**2)*cls._swing(n)
141 
142     @classmethod
143     def eval(cls, n):
144         n = sympify(n)
145 
146         if n.is_Number:
147             if n is S.Zero:
148                 return S.One
149             elif n is S.Infinity:
150                 return S.Infinity
151             elif n.is_Integer:
152                 if n.is_negative:
153                     return S.ComplexInfinity
154                 else:
155                     n = n.p
156 
157                     if n < 20:
158                         if not cls._small_factorials:
159                             result = 1
160                             for i in range(1, 20):
161                                 result *= i
162                                 cls._small_factorials.append(result)
163                         result = cls._small_factorials[n-1]
164 
165                     # GMPY factorial is faster, use it when available
166                     elif HAS_GMPY:
167                         from sympy.core.compatibility import gmpy
168                         result = gmpy.fac(n)
169 
170                     else:
171                         bits = bin(n).count('1')
172                         result = cls._recursive(n)*2**(n - bits)
173 
174                     return Integer(result)
175 
176     def _eval_rewrite_as_gamma(self, n):
177         from sympy import gamma
178         return gamma(n + 1)
179 
180     def _eval_rewrite_as_Product(self, n):
181         from sympy import Product
182         if n.is_nonnegative and n.is_integer:
183             i = Dummy('i', integer=True)
184             return Product(i, (i, 1, n))
185 
186     def _eval_is_integer(self):
187         if self.args[0].is_integer and self.args[0].is_nonnegative:
188             return True
189 
190     def _eval_is_positive(self):
191         if self.args[0].is_integer and self.args[0].is_nonnegative:
192             return True
193 
194     def _eval_is_composite(self):
195         x = self.args[0]
196         if x.is_integer:
197             return (x - 3).is_nonnegative
198 
199     def _eval_is_real(self):
200         x = self.args[0]
201         if x.is_nonnegative or x.is_noninteger:
202             return True
203 
204 
205 class MultiFactorial(CombinatorialFunction):
206     pass
207 
208 
209 class subfactorial(CombinatorialFunction):
210     r"""The subfactorial counts the derangements of n items and is
211     defined for non-negative integers as::
212 
213               ,
214              |  1                             for n = 0
215         !n = {  0                             for n = 1
216              |  (n - 1)*(!(n - 1) + !(n - 2)) for n > 1
217               `
218 
219     It can also be written as int(round(n!/exp(1))) but the recursive
220     definition with caching is implemented for this function.
221 
222     An interesting analytic expression is the following [2]_
223 
224     .. math:: !x = \Gamma(x + 1, -1)/e
225 
226     which is valid for non-negative integers x. The above formula
227     is not very useful incase of non-integers. :math:`\Gamma(x + 1, -1)` is
228     single-valued only for integral arguments x, elsewhere on the positive real
229     axis it has an infinite number of branches none of which are real.
230 
231     References
232     ==========
233 
234     .. [1] http://en.wikipedia.org/wiki/Subfactorial
235     .. [2] http://mathworld.wolfram.com/Subfactorial.html
236 
237     Examples
238     ========
239 
240     >>> from sympy import subfactorial
241     >>> from sympy.abc import n
242     >>> subfactorial(n + 1)
243     subfactorial(n + 1)
244     >>> subfactorial(5)
245     44
246 
247     See Also
248     ========
249 
250     sympy.functions.combinatorial.factorials.factorial,
251     sympy.utilities.iterables.generate_derangements,
252     sympy.functions.special.gamma_functions.uppergamma
253     """
254 
255     @classmethod
256     @cacheit
257     def _eval(self, n):
258         if not n:
259             return S.One
260         elif n == 1:
261             return S.Zero
262         return (n - 1)*(self._eval(n - 1) + self._eval(n - 2))
263 
264     @classmethod
265     def eval(cls, arg):
266         if arg.is_Number:
267             if arg.is_Integer and arg.is_nonnegative:
268                 return cls._eval(arg)
269             elif arg is S.NaN:
270                 return S.NaN
271             elif arg is S.Infinity:
272                 return S.Infinity
273 
274     def _eval_is_even(self):
275         if self.args[0].is_odd and self.args[0].is_nonnegative:
276             return True
277 
278     def _eval_is_integer(self):
279         if self.args[0].is_integer and self.args[0].is_nonnegative:
280             return True
281 
282     def _eval_rewrite_as_uppergamma(self, arg):
283         from sympy import uppergamma
284         return uppergamma(arg + 1, -1)/S.Exp1
285 
286     def _eval_is_nonnegative(self):
287         if self.args[0].is_integer and self.args[0].is_nonnegative:
288             return True
289 
290     def _eval_is_odd(self):
291         if self.args[0].is_even and self.args[0].is_nonnegative:
292             return True
293 
294 
295 class factorial2(CombinatorialFunction):
296     """The double factorial n!!, not to be confused with (n!)!
297 
298     The double factorial is defined for nonnegative integers and for odd
299     negative integers as::
300 
301                ,
302               |  n*(n - 2)*(n - 4)* ... * 1    for n positive odd
303         n!! = {  n*(n - 2)*(n - 4)* ... * 2    for n positive even
304               |  1                             for n = 0
305               |  (n+2)!! / (n+2)               for n negative odd
306                `
307 
308     References
309     ==========
310     .. [1] https://en.wikipedia.org/wiki/Double_factorial
311 
312     Examples
313     ========
314 
315     >>> from sympy import factorial2, var
316     >>> var('n')
317     n
318     >>> factorial2(n + 1)
319     factorial2(n + 1)
320     >>> factorial2(5)
321     15
322     >>> factorial2(-1)
323     1
324     >>> factorial2(-5)
325     1/3
326 
327     See Also
328     ========
329 
330     factorial, RisingFactorial, FallingFactorial
331     """
332 
333     @classmethod
334     def eval(cls, arg):
335         # TODO: extend this to complex numbers?
336 
337         if arg.is_Number:
338             if not arg.is_Integer:
339                 raise ValueError("argument must be nonnegative integer or negative odd integer")
340 
341             # This implementation is faster than the recursive one
342             # It also avoids "maximum recursion depth exceeded" runtime error
343             if arg.is_nonnegative:
344                 if arg.is_even:
345                     k = arg / 2
346                     return 2 ** k * factorial(k)
347                 return factorial(arg) / factorial2(arg - 1)
348 
349 
350             if arg.is_odd:
351                 return arg * (S.NegativeOne) ** ((1 - arg) / 2) / factorial2(-arg)
352             raise ValueError("argument must be nonnegative integer or negative odd integer")
353 
354 
355     def _eval_is_even(self):
356         # Double factorial is even for every positive even input
357         n = self.args[0]
358         if n.is_integer:
359             if n.is_odd:
360                 return False
361             if n.is_even:
362                 if n.is_positive:
363                     return True
364                 if n.is_zero:
365                     return False
366 
367     def _eval_is_integer(self):
368         # Double factorial is an integer for every nonnegative input, and for
369         # -1 and -3
370         n = self.args[0]
371         if n.is_integer:
372             if (n + 1).is_nonnegative:
373                 return True
374             if n.is_odd:
375                 return (n + 3).is_nonnegative
376 
377     def _eval_is_odd(self):
378         # Double factorial is odd for every odd input not smaller than -3, and
379         # for 0
380         n = self.args[0]
381         if n.is_odd:
382             return (n + 3).is_nonnegative
383         if n.is_even:
384             if n.is_positive:
385                 return False
386             if n.is_zero:
387                 return True
388 
389     def _eval_is_positive(self):
390         # Double factorial is positive for every nonnegative input, and for
391         # every odd negative input which is of the form -1-4k for an
392         # nonnegative integer k
393         n = self.args[0]
394         if n.is_integer:
395             if (n + 1).is_nonnegative:
396                 return True
397             if n.is_odd:
398                 return ((n + 1) / 2).is_even
399 
400     def _eval_rewrite_as_gamma(self, n):
401         from sympy import gamma, Piecewise, sqrt
402         return 2**(n/2)*gamma(n/2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)), (sqrt(2/pi), Eq(Mod(n, 2), 1)))
403 
404 
405 ###############################################################################
406 ######################## RISING and FALLING FACTORIALS ########################
407 ###############################################################################
408 
409 
410 class RisingFactorial(CombinatorialFunction):
411     """Rising factorial (also called Pochhammer symbol) is a double valued
412     function arising in concrete mathematics, hypergeometric functions
413     and series expansions. It is defined by:
414 
415                 rf(x, k) = x * (x + 1) * ... * (x + k - 1)
416 
417     where 'x' can be arbitrary expression and 'k' is an integer. For
418     more information check "Concrete mathematics" by Graham, pp. 66
419     or visit http://mathworld.wolfram.com/RisingFactorial.html page.
420 
421     When x is a polynomial f of a single variable y of order >= 1,
422     rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in
423     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
424     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
425 
426     Examples
427     ========
428 
429     >>> from sympy import rf, symbols, factorial, ff, binomial
430     >>> from sympy.abc import x
431     >>> n, k = symbols('n k', integer=True)
432     >>> rf(x, 0)
433     1
434     >>> rf(1, 5)
435     120
436     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)
437     True
438     >>> rf(x**3, 2)
439     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')
440 
441     Rewrite
442 
443     >>> rf(x, k).rewrite(ff)
444     FallingFactorial(k + x - 1, k)
445     >>> rf(x, k).rewrite(binomial)
446     binomial(k + x - 1, k)*factorial(k)
447     >>> rf(n, k).rewrite(factorial)
448     factorial(k + n - 1)/factorial(n - 1)
449 
450     See Also
451     ========
452 
453     factorial, factorial2, FallingFactorial
454 
455     References
456     ==========
457 
458     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol
459     """
460 
461     @classmethod
462     def eval(cls, x, k):
463         x = sympify(x)
464         k = sympify(k)
465 
466         if x is S.NaN or k is S.NaN:
467             return S.NaN
468         elif x is S.One:
469             return factorial(k)
470         elif k.is_Integer:
471             if k is S.Zero:
472                 return S.One
473             else:
474                 if k.is_positive:
475                     if x is S.Infinity:
476                         return S.Infinity
477                     elif x is S.NegativeInfinity:
478                         if k.is_odd:
479                             return S.NegativeInfinity
480                         else:
481                             return S.Infinity
482                     else:
483                         try:
484                             F, opt = poly_from_expr(x)
485                         except PolificationFailed:
486                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
487                         if len(opt.gens) > 1 or F.degree() <= 1:
488                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
489                         else:
490                             v = opt.gens[0]
491                             return reduce(lambda r, i:
492                                           r*(F.subs(v, v + i).expand()),
493                                           range(0, int(k)), 1)
494                 else:
495                     if x is S.Infinity:
496                         return S.Infinity
497                     elif x is S.NegativeInfinity:
498                         return S.Infinity
499                     else:
500                         try:
501                             F, opt = poly_from_expr(x)
502                         except PolificationFailed:
503                             return 1/reduce(lambda r, i:
504                                             r*(x - i),
505                                             range(1, abs(int(k)) + 1), 1)
506                         if len(opt.gens) > 1 or F.degree() <= 1:
507                             return 1/reduce(lambda r, i:
508                                             r*(x - i),
509                                             range(1, abs(int(k)) + 1), 1)
510                         else:
511                             v = opt.gens[0]
512                             return 1/reduce(lambda r, i:
513                                             r*(F.subs(v, v - i).expand()),
514                                             range(1, abs(int(k)) + 1), 1)
515 
516     def _eval_rewrite_as_gamma(self, x, k):
517         from sympy import gamma
518         return gamma(x + k) / gamma(x)
519 
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)
522 
523     def _eval_rewrite_as_factorial(self, x, k):
524         if x.is_integer and k.is_integer:
525             return factorial(k + x - 1) / factorial(x - 1)
526 
527     def _eval_rewrite_as_binomial(self, x, k):
528         if k.is_integer:
529             return factorial(k) * binomial(x + k - 1, k)
530 
531     def _eval_is_integer(self):
532         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
533                           self.args[1].is_nonnegative))
534 
535     def _sage_(self):
536         import sage.all as sage
537         return sage.rising_factorial(self.args[0]._sage_(), self.args[1]._sage_())
538 
539 
540 class FallingFactorial(CombinatorialFunction):
541     """Falling factorial (related to rising factorial) is a double valued
542     function arising in concrete mathematics, hypergeometric functions
543     and series expansions. It is defined by
544 
545                 ff(x, k) = x * (x-1) * ... * (x - k+1)
546 
547     where 'x' can be arbitrary expression and 'k' is an integer. For
548     more information check "Concrete mathematics" by Graham, pp. 66
549     or visit http://mathworld.wolfram.com/FallingFactorial.html page.
550 
551     When x is a polynomial f of a single variable y of order >= 1,
552     ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in
553     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
554     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
555 
556     >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols
557     >>> from sympy.abc import x, k
558     >>> n, m = symbols('n m', integer=True)
559     >>> ff(x, 0)
560     1
561     >>> ff(5, 5)
562     120
563     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)
564     True
565     >>> ff(x**2, 2)
566     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')
567     >>> ff(n, n)
568     factorial(n)
569 
570     Rewrite
571 
572     >>> ff(x, k).rewrite(gamma)
573     (-1)**k*gamma(k - x)/gamma(-x)
574     >>> ff(x, k).rewrite(rf)
575     RisingFactorial(-k + x + 1, k)
576     >>> ff(x, m).rewrite(binomial)
577     binomial(x, m)*factorial(m)
578     >>> ff(n, m).rewrite(factorial)
579     factorial(n)/factorial(-m + n)
580 
581     See Also
582     ========
583 
584     factorial, factorial2, RisingFactorial
585 
586     References
587     ==========
588 
589     .. [1] http://mathworld.wolfram.com/FallingFactorial.html
590     """
591 
592     @classmethod
593     def eval(cls, x, k):
594         x = sympify(x)
595         k = sympify(k)
596 
597         if x is S.NaN or k is S.NaN:
598             return S.NaN
599         elif k.is_integer and x == k:
600             return factorial(x)
601         elif k.is_Integer:
602             if k is S.Zero:
603                 return S.One
604             else:
605                 if k.is_positive:
606                     if x is S.Infinity:
607                         return S.Infinity
608                     elif x is S.NegativeInfinity:
609                         if k.is_odd:
610                             return S.NegativeInfinity
611                         else:
612                             return S.Infinity
613                     else:
614                         try:
615                             F, opt = poly_from_expr(x)
616                         except PolificationFailed:
617                             return reduce(lambda r, i: r*(x - i),
618                                           range(0, int(k)), 1)
619                         if len(opt.gens) > 1 or F.degree() <= 1:
620                             return reduce(lambda r, i: r*(x - i),
621                                           range(0, int(k)), 1)
622                         else:
623                             v = opt.gens[0]
624                             return reduce(lambda r, i:
625                                           r*(F.subs(v, v - i).expand()),
626                                           range(0, int(k)), 1)
627                 else:
628                     if x is S.Infinity:
629                         return S.Infinity
630                     elif x is S.NegativeInfinity:
631                         return S.Infinity
632                     else:
633                         try:
634                             F, opt = poly_from_expr(x)
635                         except PolificationFailed:
636                             return 1/reduce(lambda r, i: r*(x + i),
637                                             range(1, abs(int(k)) + 1), 1)
638                         if len(opt.gens) > 1 or F.degree() <= 1:
639                             return 1/reduce(lambda r, i: r*(x + i),
640                                             range(1, abs(int(k)) + 1), 1)
641                         else:
642                             v = opt.gens[0]
643                             return 1/reduce(lambda r, i:
644                                             r*(F.subs(v, v + i).expand()),
645                                             range(1, abs(int(k)) + 1), 1)
646 
647     def _eval_rewrite_as_gamma(self, x, k):
648         from sympy import gamma
649         return (-1)**k*gamma(k - x) / gamma(-x)
650 
651     def _eval_rewrite_as_RisingFactorial(self, x, k):
652         return rf(x - k + 1, k)
653 
654     def _eval_rewrite_as_binomial(self, x, k):
655         if k.is_integer:
656             return factorial(k) * binomial(x, k)
657 
658     def _eval_rewrite_as_factorial(self, x, k):
659         if x.is_integer and k.is_integer:
660             return factorial(x) / factorial(x - k)
661 
662     def _eval_is_integer(self):
663         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
664                           self.args[1].is_nonnegative))
665 
666     def _sage_(self):
667         import sage.all as sage
668         return sage.falling_factorial(self.args[0]._sage_(),
669                                       self.args[1]._sage_())
670 
671 
672 rf = RisingFactorial
673 ff = FallingFactorial
674 
675 ###############################################################################
676 ########################### BINOMIAL COEFFICIENTS #############################
677 ###############################################################################
678 
679 
680 class binomial(CombinatorialFunction):
681     """Implementation of the binomial coefficient. It can be defined
682     in two ways depending on its desired interpretation:
683 
684         C(n,k) = n!/(k!(n-k)!)   or   C(n, k) = ff(n, k)/k!
685 
686     First, in a strict combinatorial sense it defines the
687     number of ways we can choose 'k' elements from a set of
688     'n' elements. In this case both arguments are nonnegative
689     integers and binomial is computed using an efficient
690     algorithm based on prime factorization.
691 
692     The other definition is generalization for arbitrary 'n',
693     however 'k' must also be nonnegative. This case is very
694     useful when evaluating summations.
695 
696     For the sake of convenience for negative 'k' this function
697     will return zero no matter what valued is the other argument.
698 
699     To expand the binomial when n is a symbol, use either
700     expand_func() or expand(func=True). The former will keep the
701     polynomial in factored form while the latter will expand the
702     polynomial itself. See examples for details.
703 
704     Examples
705     ========
706 
707     >>> from sympy import Symbol, Rational, binomial, expand_func
708     >>> n = Symbol('n', integer=True, positive=True)
709 
710     >>> binomial(15, 8)
711     6435
712 
713     >>> binomial(n, -1)
714     0
715 
716     Rows of Pascal's triangle can be generated with the binomial function:
717 
718     >>> for N in range(8):
719     ...     print([ binomial(N, i) for i in range(N + 1)])
720     ...
721     [1]
722     [1, 1]
723     [1, 2, 1]
724     [1, 3, 3, 1]
725     [1, 4, 6, 4, 1]
726     [1, 5, 10, 10, 5, 1]
727     [1, 6, 15, 20, 15, 6, 1]
728     [1, 7, 21, 35, 35, 21, 7, 1]
729 
730     As can a given diagonal, e.g. the 4th diagonal:
731 
732     >>> N = -4
733     >>> [ binomial(N, i) for i in range(1 - N)]
734     [1, -4, 10, -20, 35]
735 
736     >>> binomial(Rational(5, 4), 3)
737     -5/128
738     >>> binomial(Rational(-5, 4), 3)
739     -195/128
740 
741     >>> binomial(n, 3)
742     binomial(n, 3)
743 
744     >>> binomial(n, 3).expand(func=True)
745     n**3/6 - n**2/2 + n/3
746 
747     >>> expand_func(binomial(n, 3))
748     n*(n - 2)*(n - 1)/6
749 
750     """
751 
752     def fdiff(self, argindex=1):
753         from sympy import polygamma
754         if argindex == 1:
755             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/01/
756             n, k = self.args
757             return binomial(n, k)*(polygamma(0, n + 1) - \
758                 polygamma(0, n - k + 1))
759         elif argindex == 2:
760             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/02/
761             n, k = self.args
762             return binomial(n, k)*(polygamma(0, n - k + 1) - \
763                 polygamma(0, k + 1))
764         else:
765             raise ArgumentIndexError(self, argindex)
766 
767     @classmethod
768     def _eval(self, n, k):
769         # n.is_Number and k.is_Integer and k != 1 and n != k
770         if k.is_Integer:
771             if n.is_Integer and n >= 0:
772                 n, k = int(n), int(k)
773 
774                 if k > n:
775                     return S.Zero
776                 elif k > n // 2:
777                     k = n - k
778 
779                 M, result = int(_sqrt(n)), 1
780 
781                 for prime in sieve.primerange(2, n + 1):
782                     if prime > n - k:
783                         result *= prime
784                     elif prime > n // 2:
785                         continue
786                     elif prime > M:
787                         if n % prime < k % prime:
788                             result *= prime
789                     else:
790                         N, K = n, k
791                         exp = a = 0
792 
793                         while N > 0:
794                             a = int((N % prime) < (K % prime + a))
795                             N, K = N // prime, K // prime
796                             exp = a + exp
797 
798                         if exp > 0:
799                             result *= prime**exp
800                 return Integer(result)
801             else:
802                 d = result = n - k + 1
803                 for i in range(2, k + 1):
804                     d += 1
805                     result *= d
806                     result /= i
807                 return result
808 
809     @classmethod
810     def eval(cls, n, k):
811         n, k = map(sympify, (n, k))
812         d = n - k
813         if d.is_zero or k.is_zero:
814             return S.One
815         elif d.is_zero is False:
816             if (k - 1).is_zero:
817                 return n
818             elif k.is_negative:
819                 return S.Zero
820             elif n.is_integer and n.is_nonnegative and d.is_negative:
821                 return S.Zero
822         if k.is_Integer and k > 0 and n.is_Number:
823             return cls._eval(n, k)
824 
825     def _eval_expand_func(self, **hints):
826         """
827         Function to expand binomial(n,k) when m is positive integer
828         Also,
829         n is self.args[0] and k is self.args[1] while using binomial(n, k)
830         """
831         n = self.args[0]
832         if n.is_Number:
833             return binomial(*self.args)
834 
835         k = self.args[1]
836         if k.is_Add and n in k.args:
837             k = n - k
838 
839         if k.is_Integer:
840             if k == S.Zero:
841                 return S.One
842             elif k < 0:
843                 return S.Zero
844             else:
845                 n = self.args[0]
846                 result = n - k + 1
847                 for i in range(2, k + 1):
848                     result *= n - k + i
849                     result /= i
850                 return result
851         else:
852             return binomial(*self.args)
853 
854     def _eval_rewrite_as_factorial(self, n, k):
855         return factorial(n)/(factorial(k)*factorial(n - k))
856 
857     def _eval_rewrite_as_gamma(self, n, k):
858         from sympy import gamma
859         return gamma(n + 1)/(gamma(k + 1)*gamma(n - k + 1))
860 
861     def _eval_rewrite_as_tractable(self, n, k):
862         return self._eval_rewrite_as_gamma(n, k).rewrite('tractable')
863 
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)
867 
868     def _eval_is_integer(self):
869         n, k = self.args
870         if n.is_integer and k.is_integer:
871             return True
872         elif k.is_integer is False:
873             return False

</code><intended_behavior>This file, which likely includes implementations of rising and potentially falling factorial functions (`rf` and possibly `ff`), should ensure that the definitions and computational logic for these factorials conform to established mathematical standards. If changes were made that diverge from these standards, the intended behavior would involve reverting such changes or ensuring the computations are mathematically accurate, efficient, and reflective of the functions' respective definitions.</intended_behavior>]
2025-10-15 13:08:55.464 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 13:08:55.465 | INFO     | Search-only: skipping patch selection
2025-10-15 13:08:55.571 | INFO     | Task sympy__sympy-12798 completed successfully.
2025-10-15 13:08:55.572 | INFO     | No patch generated. You can try running ACR again.
