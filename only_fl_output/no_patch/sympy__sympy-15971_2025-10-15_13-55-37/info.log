2025-10-15 13:55:37.483 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 13:55:47.446 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=321, output_tokens=12, cost=0.003570
2025-10-15 13:55:47.447 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 13:55:47.450 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:55:56.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=460, output_tokens=304, cost=0.013720
2025-10-15 13:55:56.325 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:55:58.789 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=58, cost=0.008320
2025-10-15 13:55:58.790 | DEBUG    | Extracted a valid json.
2025-10-15 13:55:58.790 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"class PrettyPrinter\", \"pretty.py\")",
        "search_method_in_file(\"lerchphi\", \"pretty.py\")",
        "search_code(\"lerchphi\")"
    ],
    "bug_locations": []
}
2025-10-15 13:55:59.039 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 13:55:59.040 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 13:56:15.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1126, output_tokens=748, cost=0.033700
2025-10-15 13:56:15.112 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 13:56:22.532 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2090, output_tokens=223, cost=0.027590
2025-10-15 13:56:22.538 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 13:56:32.114 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=577, output_tokens=209, cost=0.012040
2025-10-15 13:56:32.115 | DEBUG    | Extracted a valid json.
2025-10-15 13:56:32.115 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "sympy/printing/pretty/pretty.py", "class": "PrettyPrinter", "method": "", "intended_behavior": "A new method should be added to the PrettyPrinter class specifically for handling the lerchphi function. This method should check for instances of the lerchphi function within the expressions being pretty-printed and format them into a readable, aesthetically pleasing ASCII art form. The method should capture and accurately represent the mathematical functionality of lerchphi, incorporating appropriate formatting rules to ensure that the pretty-printed output is both interpretable and consistent with SymPy's pretty printing standards for special functions. This task involves identifying the parameters of lerchphi and deciding on their representation in the output. The mechanism for identifying lerchphi functions within expressions and formatting them needs to be integrated seamlessly with the existing pretty printing processes, ensuring that it does not interfere with the rendering of other expressions or symbols that may be part of the input."}]
}
2025-10-15 13:56:32.125 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/pretty/pretty.py</file>
<class>PrettyPrinter</class>
<method>None</method>
<code>
32 class PrettyPrinter(Printer):
33     """Printer, which converts an expression into 2D ASCII-art figure."""
34     printmethod = "_pretty"
35 
36     _default_settings = {
37         "order": None,
38         "full_prec": "auto",
39         "use_unicode": None,
40         "wrap_line": True,
41         "num_columns": None,
42         "use_unicode_sqrt_char": True,
43         "root_notation": True,
44         "imaginary_unit": "i",
45     }
46 
47     def __init__(self, settings=None):
48         Printer.__init__(self, settings)
49 
50         if not isinstance(self._settings['imaginary_unit'], string_types):
51             raise TypeError("'imaginary_unit' must a string, not {}".format(self._settings['imaginary_unit']))
52         elif self._settings['imaginary_unit'] not in ["i", "j"]:
53             raise ValueError("'imaginary_unit' must be either 'i' or 'j', not '{}'".format(self._settings['imaginary_unit']))
54         self.emptyPrinter = lambda x: prettyForm(xstr(x))
55 
56     @property
57     def _use_unicode(self):
58         if self._settings['use_unicode']:
59             return True
60         else:
61             return pretty_use_unicode()
62 
63     def doprint(self, expr):
64         return self._print(expr).render(**self._settings)
65 
66     # empty op so _print(stringPict) returns the same
67     def _print_stringPict(self, e):
68         return e
69 
70     def _print_basestring(self, e):
71         return prettyForm(e)
72 
73     def _print_atan2(self, e):
74         pform = prettyForm(*self._print_seq(e.args).parens())
75         pform = prettyForm(*pform.left('atan2'))
76         return pform
77 
78     def _print_Symbol(self, e):
79         symb = pretty_symbol(e.name)
80         return prettyForm(symb)
81     _print_RandomSymbol = _print_Symbol
82 
83     def _print_Float(self, e):
84         # we will use StrPrinter's Float printer, but we need to handle the
85         # full_prec ourselves, according to the self._print_level
86         full_prec = self._settings["full_prec"]
87         if full_prec == "auto":
88             full_prec = self._print_level == 1
89         return prettyForm(sstr(e, full_prec=full_prec))
90 
91     def _print_Cross(self, e):
92         vec1 = e._expr1
93         vec2 = e._expr2
94         pform = self._print(vec2)
95         pform = prettyForm(*pform.left('('))
96         pform = prettyForm(*pform.right(')'))
97         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
98         pform = prettyForm(*pform.left(')'))
99         pform = prettyForm(*pform.left(self._print(vec1)))
100         pform = prettyForm(*pform.left('('))
101         return pform
102 
103     def _print_Curl(self, e):
104         vec = e._expr
105         pform = self._print(vec)
106         pform = prettyForm(*pform.left('('))
107         pform = prettyForm(*pform.right(')'))
108         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
109         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
110         return pform
111 
112     def _print_Divergence(self, e):
113         vec = e._expr
114         pform = self._print(vec)
115         pform = prettyForm(*pform.left('('))
116         pform = prettyForm(*pform.right(')'))
117         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
118         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
119         return pform
120 
121     def _print_Dot(self, e):
122         vec1 = e._expr1
123         vec2 = e._expr2
124         pform = self._print(vec2)
125         pform = prettyForm(*pform.left('('))
126         pform = prettyForm(*pform.right(')'))
127         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
128         pform = prettyForm(*pform.left(')'))
129         pform = prettyForm(*pform.left(self._print(vec1)))
130         pform = prettyForm(*pform.left('('))
131         return pform
132 
133     def _print_Gradient(self, e):
134         func = e._expr
135         pform = self._print(func)
136         pform = prettyForm(*pform.left('('))
137         pform = prettyForm(*pform.right(')'))
138         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
139         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
140         return pform
141 
142     def _print_Atom(self, e):
143         try:
144             # print atoms like Exp1 or Pi
145             return prettyForm(pretty_atom(e.__class__.__name__, printer=self))
146         except KeyError:
147             return self.emptyPrinter(e)
148 
149     # Infinity inherits from Number, so we have to override _print_XXX order
150     _print_Infinity = _print_Atom
151     _print_NegativeInfinity = _print_Atom
152     _print_EmptySet = _print_Atom
153     _print_Naturals = _print_Atom
154     _print_Naturals0 = _print_Atom
155     _print_Integers = _print_Atom
156     _print_Complexes = _print_Atom
157 
158     def _print_Reals(self, e):
159         if self._use_unicode:
160             return self._print_Atom(e)
161         else:
162             inf_list = ['-oo', 'oo']
163             return self._print_seq(inf_list, '(', ')')
164 
165     def _print_subfactorial(self, e):
166         x = e.args[0]
167         pform = self._print(x)
168         # Add parentheses if needed
169         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
170             pform = prettyForm(*pform.parens())
171         pform = prettyForm(*pform.left('!'))
172         return pform
173 
174     def _print_factorial(self, e):
175         x = e.args[0]
176         pform = self._print(x)
177         # Add parentheses if needed
178         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
179             pform = prettyForm(*pform.parens())
180         pform = prettyForm(*pform.right('!'))
181         return pform
182 
183     def _print_factorial2(self, e):
184         x = e.args[0]
185         pform = self._print(x)
186         # Add parentheses if needed
187         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
188             pform = prettyForm(*pform.parens())
189         pform = prettyForm(*pform.right('!!'))
190         return pform
191 
192     def _print_binomial(self, e):
193         n, k = e.args
194 
195         n_pform = self._print(n)
196         k_pform = self._print(k)
197 
198         bar = ' '*max(n_pform.width(), k_pform.width())
199 
200         pform = prettyForm(*k_pform.above(bar))
201         pform = prettyForm(*pform.above(n_pform))
202         pform = prettyForm(*pform.parens('(', ')'))
203 
204         pform.baseline = (pform.baseline + 1)//2
205 
206         return pform
207 
208     def _print_Relational(self, e):
209         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
210 
211         l = self._print(e.lhs)
212         r = self._print(e.rhs)
213         pform = prettyForm(*stringPict.next(l, op, r))
214         return pform
215 
216     def _print_Not(self, e):
217         from sympy import Equivalent, Implies
218         if self._use_unicode:
219             arg = e.args[0]
220             pform = self._print(arg)
221             if isinstance(arg, Equivalent):
222                 return self._print_Equivalent(arg, altchar=u"\N{LEFT RIGHT DOUBLE ARROW WITH STROKE}")
223             if isinstance(arg, Implies):
224                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
225 
226             if arg.is_Boolean and not arg.is_Not:
227                 pform = prettyForm(*pform.parens())
228 
229             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
230         else:
231             return self._print_Function(e)
232 
233     def __print_Boolean(self, e, char, sort=True):
234         args = e.args
235         if sort:
236             args = sorted(e.args, key=default_sort_key)
237         arg = args[0]
238         pform = self._print(arg)
239 
240         if arg.is_Boolean and not arg.is_Not:
241             pform = prettyForm(*pform.parens())
242 
243         for arg in args[1:]:
244             pform_arg = self._print(arg)
245 
246             if arg.is_Boolean and not arg.is_Not:
247                 pform_arg = prettyForm(*pform_arg.parens())
248 
249             pform = prettyForm(*pform.right(u' %s ' % char))
250             pform = prettyForm(*pform.right(pform_arg))
251 
252         return pform
253 
254     def _print_And(self, e):
255         if self._use_unicode:
256             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
257         else:
258             return self._print_Function(e, sort=True)
259 
260     def _print_Or(self, e):
261         if self._use_unicode:
262             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
263         else:
264             return self._print_Function(e, sort=True)
265 
266     def _print_Xor(self, e):
267         if self._use_unicode:
268             return self.__print_Boolean(e, u"\N{XOR}")
269         else:
270             return self._print_Function(e, sort=True)
271 
272     def _print_Nand(self, e):
273         if self._use_unicode:
274             return self.__print_Boolean(e, u"\N{NAND}")
275         else:
276             return self._print_Function(e, sort=True)
277 
278     def _print_Nor(self, e):
279         if self._use_unicode:
280             return self.__print_Boolean(e, u"\N{NOR}")
281         else:
282             return self._print_Function(e, sort=True)
283 
284     def _print_Implies(self, e, altchar=None):
285         if self._use_unicode:
286             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
287         else:
288             return self._print_Function(e)
289 
290     def _print_Equivalent(self, e, altchar=None):
291         if self._use_unicode:
292             return self.__print_Boolean(e, altchar or u"\N{LEFT RIGHT DOUBLE ARROW}")
293         else:
294             return self._print_Function(e, sort=True)
295 
296     def _print_conjugate(self, e):
297         pform = self._print(e.args[0])
298         return prettyForm( *pform.above( hobj('_', pform.width())) )
299 
300     def _print_Abs(self, e):
301         pform = self._print(e.args[0])
302         pform = prettyForm(*pform.parens('|', '|'))
303         return pform
304     _print_Determinant = _print_Abs
305 
306     def _print_floor(self, e):
307         if self._use_unicode:
308             pform = self._print(e.args[0])
309             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
310             return pform
311         else:
312             return self._print_Function(e)
313 
314     def _print_ceiling(self, e):
315         if self._use_unicode:
316             pform = self._print(e.args[0])
317             pform = prettyForm(*pform.parens('lceil', 'rceil'))
318             return pform
319         else:
320             return self._print_Function(e)
321 
322     def _print_Derivative(self, deriv):
323         if requires_partial(deriv) and self._use_unicode:
324             deriv_symbol = U('PARTIAL DIFFERENTIAL')
325         else:
326             deriv_symbol = r'd'
327         x = None
328         count_total_deriv = 0
329 
330         for sym, num in reversed(deriv.variable_count):
331             s = self._print(sym)
332             ds = prettyForm(*s.left(deriv_symbol))
333             count_total_deriv += num
334 
335             if (not num.is_Integer) or (num > 1):
336                 ds = ds**prettyForm(str(num))
337 
338             if x is None:
339                 x = ds
340             else:
341                 x = prettyForm(*x.right(' '))
342                 x = prettyForm(*x.right(ds))
343 
344         f = prettyForm(
345             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
346 
347         pform = prettyForm(deriv_symbol)
348 
349         if (count_total_deriv > 1) != False:
350             pform = pform**prettyForm(str(count_total_deriv))
351 
352         pform = prettyForm(*pform.below(stringPict.LINE, x))
353         pform.baseline = pform.baseline + 1
354         pform = prettyForm(*stringPict.next(pform, f))
355         pform.binding = prettyForm.MUL
356 
357         return pform
358 
359     def _print_Cycle(self, dc):
360         from sympy.combinatorics.permutations import Permutation, Cycle
361         # for Empty Cycle
362         if dc == Cycle():
363             cyc = stringPict('')
364             return prettyForm(*cyc.parens())
365 
366         dc_list = Permutation(dc.list()).cyclic_form
367         # for Identity Cycle
368         if dc_list == []:
369             cyc = self._print(dc.size - 1)
370             return prettyForm(*cyc.parens())
371 
372         cyc = stringPict('')
373         for i in dc_list:
374             l = self._print(str(tuple(i)).replace(',', ''))
375             cyc = prettyForm(*cyc.right(l))
376         return cyc
377 
378     def _print_PDF(self, pdf):
379         lim = self._print(pdf.pdf.args[0])
380         lim = prettyForm(*lim.right(', '))
381         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
382         lim = prettyForm(*lim.right(', '))
383         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
384         lim = prettyForm(*lim.parens())
385 
386         f = self._print(pdf.pdf.args[1])
387         f = prettyForm(*f.right(', '))
388         f = prettyForm(*f.right(lim))
389         f = prettyForm(*f.parens())
390 
391         pform = prettyForm('PDF')
392         pform = prettyForm(*pform.right(f))
393         return pform
394 
395     def _print_Integral(self, integral):
396         f = integral.function
397 
398         # Add parentheses if arg involves addition of terms and
399         # create a pretty form for the argument
400         prettyF = self._print(f)
401         # XXX generalize parens
402         if f.is_Add:
403             prettyF = prettyForm(*prettyF.parens())
404 
405         # dx dy dz ...
406         arg = prettyF
407         for x in integral.limits:
408             prettyArg = self._print(x[0])
409             # XXX qparens (parens if needs-parens)
410             if prettyArg.width() > 1:
411                 prettyArg = prettyForm(*prettyArg.parens())
412 
413             arg = prettyForm(*arg.right(' d', prettyArg))
414 
415         # \int \int \int ...
416         firstterm = True
417         s = None
418         for lim in integral.limits:
419             x = lim[0]
420             # Create bar based on the height of the argument
421             h = arg.height()
422             H = h + 2
423 
424             # XXX hack!
425             ascii_mode = not self._use_unicode
426             if ascii_mode:
427                 H += 2
428 
429             vint = vobj('int', H)
430 
431             # Construct the pretty form with the integral sign and the argument
432             pform = prettyForm(vint)
433             pform.baseline = arg.baseline + (
434                 H - h)//2    # covering the whole argument
435 
436             if len(lim) > 1:
437                 # Create pretty forms for endpoints, if definite integral.
438                 # Do not print empty endpoints.
439                 if len(lim) == 2:
440                     prettyA = prettyForm("")
441                     prettyB = self._print(lim[1])
442                 if len(lim) == 3:
443                     prettyA = self._print(lim[1])
444                     prettyB = self._print(lim[2])
445 
446                 if ascii_mode:  # XXX hack
447                     # Add spacing so that endpoint can more easily be
448                     # identified with the correct integral sign
449                     spc = max(1, 3 - prettyB.width())
450                     prettyB = prettyForm(*prettyB.left(' ' * spc))
451 
452                     spc = max(1, 4 - prettyA.width())
453                     prettyA = prettyForm(*prettyA.right(' ' * spc))
454 
455                 pform = prettyForm(*pform.above(prettyB))
456                 pform = prettyForm(*pform.below(prettyA))
457 
458             if not ascii_mode:  # XXX hack
459                 pform = prettyForm(*pform.right(' '))
460 
461             if firstterm:
462                 s = pform   # first term
463                 firstterm = False
464             else:
465                 s = prettyForm(*s.left(pform))
466 
467         pform = prettyForm(*arg.left(s))
468         pform.binding = prettyForm.MUL
469         return pform
470 
471     def _print_Product(self, expr):
472         func = expr.term
473         pretty_func = self._print(func)
474 
475         horizontal_chr = xobj('_', 1)
476         corner_chr = xobj('_', 1)
477         vertical_chr = xobj('|', 1)
478 
479         if self._use_unicode:
480             # use unicode corners
481             horizontal_chr = xobj('-', 1)
482             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
483 
484         func_height = pretty_func.height()
485 
486         first = True
487         max_upper = 0
488         sign_height = 0
489 
490         for lim in expr.limits:
491             width = (func_height + 2) * 5 // 3 - 2
492             sign_lines = []
493             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
494             for i in range(func_height + 1):
495                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
496 
497             pretty_sign = stringPict('')
498             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
499 
500             pretty_upper = self._print(lim[2])
501             pretty_lower = self._print(Equality(lim[0], lim[1]))
502 
503             max_upper = max(max_upper, pretty_upper.height())
504 
505             if first:
506                 sign_height = pretty_sign.height()
507 
508             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
509             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
510 
511             if first:
512                 pretty_func.baseline = 0
513                 first = False
514 
515             height = pretty_sign.height()
516             padding = stringPict('')
517             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
518             pretty_sign = prettyForm(*pretty_sign.right(padding))
519 
520             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
521 
522         pretty_func.baseline = max_upper + sign_height//2
523         pretty_func.binding = prettyForm.MUL
524         return pretty_func
525 
526     def _print_Sum(self, expr):
527         ascii_mode = not self._use_unicode
528 
529         def asum(hrequired, lower, upper, use_ascii):
530             def adjust(s, wid=None, how='<^>'):
531                 if not wid or len(s) > wid:
532                     return s
533                 need = wid - len(s)
534                 if how == '<^>' or how == "<" or how not in list('<^>'):
535                     return s + ' '*need
536                 half = need//2
537                 lead = ' '*half
538                 if how == ">":
539                     return " "*need + s
540                 return lead + s + ' '*(need - len(lead))
541 
542             h = max(hrequired, 2)
543             d = h//2
544             w = d + 1
545             more = hrequired % 2
546 
547             lines = []
548             if use_ascii:
549                 lines.append("_"*(w) + ' ')
550                 lines.append(r"\%s`" % (' '*(w - 1)))
551                 for i in range(1, d):
552                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
553                 if more:
554                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
555                 for i in reversed(range(1, d)):
556                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
557                 lines.append("/" + "_"*(w - 1) + ',')
558                 return d, h + more, lines, 0
559             else:
560                 w = w + more
561                 d = d + more
562                 vsum = vobj('sum', 4)
563                 lines.append("_"*(w))
564                 for i in range(0, d):
565                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
566                 for i in reversed(range(0, d)):
567                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
568                 lines.append(vsum[8]*(w))
569                 return d, h + 2*more, lines, more
570 
571         f = expr.function
572 
573         prettyF = self._print(f)
574 
575         if f.is_Add:  # add parens
576             prettyF = prettyForm(*prettyF.parens())
577 
578         H = prettyF.height() + 2
579 
580         # \sum \sum \sum ...
581         first = True
582         max_upper = 0
583         sign_height = 0
584 
585         for lim in expr.limits:
586             if len(lim) == 3:
587                 prettyUpper = self._print(lim[2])
588                 prettyLower = self._print(Equality(lim[0], lim[1]))
589             elif len(lim) == 2:
590                 prettyUpper = self._print("")
591                 prettyLower = self._print(Equality(lim[0], lim[1]))
592             elif len(lim) == 1:
593                 prettyUpper = self._print("")
594                 prettyLower = self._print(lim[0])
595 
596             max_upper = max(max_upper, prettyUpper.height())
597 
598             # Create sum sign based on the height of the argument
599             d, h, slines, adjustment = asum(
600                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
601             prettySign = stringPict('')
602             prettySign = prettyForm(*prettySign.stack(*slines))
603 
604             if first:
605                 sign_height = prettySign.height()
606 
607             prettySign = prettyForm(*prettySign.above(prettyUpper))
608             prettySign = prettyForm(*prettySign.below(prettyLower))
609 
610             if first:
611                 # change F baseline so it centers on the sign
612                 prettyF.baseline -= d - (prettyF.height()//2 -
613                                          prettyF.baseline) - adjustment
614                 first = False
615 
616             # put padding to the right
617             pad = stringPict('')
618             pad = prettyForm(*pad.stack(*[' ']*h))
619             prettySign = prettyForm(*prettySign.right(pad))
620             # put the present prettyF to the right
621             prettyF = prettyForm(*prettySign.right(prettyF))
622 
623         prettyF.baseline = max_upper + sign_height//2
624         prettyF.binding = prettyForm.MUL
625         return prettyF
626 
627     def _print_Limit(self, l):
628         e, z, z0, dir = l.args
629 
630         E = self._print(e)
631         if precedence(e) <= PRECEDENCE["Mul"]:
632             E = prettyForm(*E.parens('(', ')'))
633         Lim = prettyForm('lim')
634 
635         LimArg = self._print(z)
636         if self._use_unicode:
637             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
638         else:
639             LimArg = prettyForm(*LimArg.right('->'))
640         LimArg = prettyForm(*LimArg.right(self._print(z0)))
641 
642         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
643             dir = ""
644         else:
645             if self._use_unicode:
646                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
647 
648         LimArg = prettyForm(*LimArg.right(self._print(dir)))
649 
650         Lim = prettyForm(*Lim.below(LimArg))
651         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
652 
653         return Lim
654 
655     def _print_matrix_contents(self, e):
656         """
657         This method factors out what is essentially grid printing.
658         """
659         M = e   # matrix
660         Ms = {}  # i,j -> pretty(M[i,j])
661         for i in range(M.rows):
662             for j in range(M.cols):
663                 Ms[i, j] = self._print(M[i, j])
664 
665         # h- and v- spacers
666         hsep = 2
667         vsep = 1
668 
669         # max width for columns
670         maxw = [-1] * M.cols
671 
672         for j in range(M.cols):
673             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
674 
675         # drawing result
676         D = None
677 
678         for i in range(M.rows):
679 
680             D_row = None
681             for j in range(M.cols):
682                 s = Ms[i, j]
683 
684                 # reshape s to maxw
685                 # XXX this should be generalized, and go to stringPict.reshape ?
686                 assert s.width() <= maxw[j]
687 
688                 # hcenter it, +0.5 to the right                        2
689                 # ( it's better to align formula starts for say 0 and r )
690                 # XXX this is not good in all cases -- maybe introduce vbaseline?
691                 wdelta = maxw[j] - s.width()
692                 wleft = wdelta // 2
693                 wright = wdelta - wleft
694 
695                 s = prettyForm(*s.right(' '*wright))
696                 s = prettyForm(*s.left(' '*wleft))
697 
698                 # we don't need vcenter cells -- this is automatically done in
699                 # a pretty way because when their baselines are taking into
700                 # account in .right()
701 
702                 if D_row is None:
703                     D_row = s   # first box in a row
704                     continue
705 
706                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
707                 D_row = prettyForm(*D_row.right(s))
708 
709             if D is None:
710                 D = D_row       # first row in a picture
711                 continue
712 
713             # v-spacer
714             for _ in range(vsep):
715                 D = prettyForm(*D.below(' '))
716 
717             D = prettyForm(*D.below(D_row))
718 
719         if D is None:
720             D = prettyForm('')  # Empty Matrix
721 
722         return D
723 
724     def _print_MatrixBase(self, e):
725         D = self._print_matrix_contents(e)
726         D.baseline = D.height()//2
727         D = prettyForm(*D.parens('[', ']'))
728         return D
729     _print_ImmutableMatrix = _print_MatrixBase
730     _print_Matrix = _print_MatrixBase
731 
732     def _print_TensorProduct(self, expr):
733         # This should somehow share the code with _print_WedgeProduct:
734         circled_times = "\u2297"
735         return self._print_seq(expr.args, None, None, circled_times,
736             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
737 
738     def _print_WedgeProduct(self, expr):
739         # This should somehow share the code with _print_TensorProduct:
740         wedge_symbol = u"\u2227"
741         return self._print_seq(expr.args, None, None, wedge_symbol,
742             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
743 
744     def _print_Trace(self, e):
745         D = self._print(e.arg)
746         D = prettyForm(*D.parens('(',')'))
747         D.baseline = D.height()//2
748         D = prettyForm(*D.left('\n'*(0) + 'tr'))
749         return D
750 
751 
752     def _print_MatrixElement(self, expr):
753         from sympy.matrices import MatrixSymbol
754         from sympy import Symbol
755         if (isinstance(expr.parent, MatrixSymbol)
756                 and expr.i.is_number and expr.j.is_number):
757             return self._print(
758                     Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))
759         else:
760             prettyFunc = self._print(expr.parent)
761             prettyFunc = prettyForm(*prettyFunc.parens())
762             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
763                     ).parens(left='[', right=']')[0]
764             pform = prettyForm(binding=prettyForm.FUNC,
765                     *stringPict.next(prettyFunc, prettyIndices))
766 
767             # store pform parts so it can be reassembled e.g. when powered
768             pform.prettyFunc = prettyFunc
769             pform.prettyArgs = prettyIndices
770 
771             return pform
772 
773 
774     def _print_MatrixSlice(self, m):
775         # XXX works only for applied functions
776         prettyFunc = self._print(m.parent)
777         def ppslice(x):
778             x = list(x)
779             if x[2] == 1:
780                 del x[2]
781             if x[1] == x[0] + 1:
782                 del x[1]
783             if x[0] == 0:
784                 x[0] = ''
785             return prettyForm(*self._print_seq(x, delimiter=':'))
786         prettyArgs = self._print_seq((ppslice(m.rowslice),
787             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
788 
789         pform = prettyForm(
790             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
791 
792         # store pform parts so it can be reassembled e.g. when powered
793         pform.prettyFunc = prettyFunc
794         pform.prettyArgs = prettyArgs
795 
796         return pform
797 
798     def _print_Transpose(self, expr):
799         pform = self._print(expr.arg)
800         from sympy.matrices import MatrixSymbol
801         if not isinstance(expr.arg, MatrixSymbol):
802             pform = prettyForm(*pform.parens())
803         pform = pform**(prettyForm('T'))
804         return pform
805 
806     def _print_Adjoint(self, expr):
807         pform = self._print(expr.arg)
808         if self._use_unicode:
809             dag = prettyForm(u'\N{DAGGER}')
810         else:
811             dag = prettyForm('+')
812         from sympy.matrices import MatrixSymbol
813         if not isinstance(expr.arg, MatrixSymbol):
814             pform = prettyForm(*pform.parens())
815         pform = pform**dag
816         return pform
817 
818     def _print_BlockMatrix(self, B):
819         if B.blocks.shape == (1, 1):
820             return self._print(B.blocks[0, 0])
821         return self._print(B.blocks)
822 
823     def _print_MatAdd(self, expr):
824         s = None
825         for item in expr.args:
826             pform = self._print(item)
827             if s is None:
828                 s = pform     # First element
829             else:
830                 coeff = item.as_coeff_mmul()[0]
831                 if _coeff_isneg(S(coeff)):
832                     s = prettyForm(*stringPict.next(s, ' '))
833                     pform = self._print(item)
834                 else:
835                     s = prettyForm(*stringPict.next(s, ' + '))
836                 s = prettyForm(*stringPict.next(s, pform))
837 
838         return s
839 
840     def _print_MatMul(self, expr):
841         args = list(expr.args)
842         from sympy import Add, MatAdd, HadamardProduct, KroneckerProduct
843         for i, a in enumerate(args):
844             if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))
845                     and len(expr.args) > 1):
846                 args[i] = prettyForm(*self._print(a).parens())
847             else:
848                 args[i] = self._print(a)
849 
850         return prettyForm.__mul__(*args)
851 
852     def _print_DotProduct(self, expr):
853         args = list(expr.args)
854 
855         for i, a in enumerate(args):
856             args[i] = self._print(a)
857         return prettyForm.__mul__(*args)
858 
859     def _print_MatPow(self, expr):
860         pform = self._print(expr.base)
861         from sympy.matrices import MatrixSymbol
862         if not isinstance(expr.base, MatrixSymbol):
863             pform = prettyForm(*pform.parens())
864         pform = pform**(self._print(expr.exp))
865         return pform
866 
867     def _print_HadamardProduct(self, expr):
868         from sympy import MatAdd, MatMul
869         if self._use_unicode:
870             delim = pretty_atom('Ring')
871         else:
872             delim = '.*'
873         return self._print_seq(expr.args, None, None, delim,
874                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
875 
876     def _print_KroneckerProduct(self, expr):
877         from sympy import MatAdd, MatMul
878         if self._use_unicode:
879             delim = u' \N{N-ARY CIRCLED TIMES OPERATOR} '
880         else:
881             delim = ' x '
882         return self._print_seq(expr.args, None, None, delim,
883                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
884 
885     _print_MatrixSymbol = _print_Symbol
886 
887     def _print_FunctionMatrix(self, X):
888         D = self._print(X.lamda.expr)
889         D = prettyForm(*D.parens('[', ']'))
890         return D
891 
892     def _print_BasisDependent(self, expr):
893         from sympy.vector import Vector
894 
895         if not self._use_unicode:
896             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
897 
898         if expr == expr.zero:
899             return prettyForm(expr.zero._pretty_form)
900         o1 = []
901         vectstrs = []
902         if isinstance(expr, Vector):
903             items = expr.separate().items()
904         else:
905             items = [(0, expr)]
906         for system, vect in items:
907             inneritems = list(vect.components.items())
908             inneritems.sort(key = lambda x: x[0].__str__())
909             for k, v in inneritems:
910                 #if the coef of the basis vector is 1
911                 #we skip the 1
912                 if v == 1:
913                     o1.append(u"" +
914                               k._pretty_form)
915                 #Same for -1
916                 elif v == -1:
917                     o1.append(u"(-1) " +
918                               k._pretty_form)
919                 #For a general expr
920                 else:
921                     #We always wrap the measure numbers in
922                     #parentheses
923                     arg_str = self._print(
924                         v).parens()[0]
925 
926                     o1.append(arg_str + ' ' + k._pretty_form)
927                 vectstrs.append(k._pretty_form)
928 
929         #outstr = u("").join(o1)
930         if o1[0].startswith(u" + "):
931             o1[0] = o1[0][3:]
932         elif o1[0].startswith(" "):
933             o1[0] = o1[0][1:]
934         #Fixing the newlines
935         lengths = []
936         strs = ['']
937         flag = []
938         for i, partstr in enumerate(o1):
939             flag.append(0)
940             # XXX: What is this hack?
941             if '\n' in partstr:
942                 tempstr = partstr
943                 tempstr = tempstr.replace(vectstrs[i], '')
944                 if u'\N{right parenthesis extension}' in tempstr:   # If scalar is a fraction
945                     for paren in range(len(tempstr)):
946                         flag[i] = 1
947                         if tempstr[paren] == u'\N{right parenthesis extension}':
948                             tempstr = tempstr[:paren] + u'\N{right parenthesis extension}'\
949                                          + ' '  + vectstrs[i] + tempstr[paren + 1:]
950                             break
951                 elif u'\N{RIGHT PARENTHESIS LOWER HOOK}' in tempstr:
952                     flag[i] = 1
953                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS LOWER HOOK}',
954                                         u'\N{RIGHT PARENTHESIS LOWER HOOK}'
955                                         + ' ' + vectstrs[i])
956                 else:
957                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
958                                         u'\N{RIGHT PARENTHESIS UPPER HOOK}'
959                                         + ' ' + vectstrs[i])
960                 o1[i] = tempstr
961 
962         o1 = [x.split('\n') for x in o1]
963         n_newlines = max([len(x) for x in o1])  # Width of part in its pretty form
964 
965         if 1 in flag:                           # If there was a fractional scalar
966             for i, parts in enumerate(o1):
967                 if len(parts) == 1:             # If part has no newline
968                     parts.insert(0, ' ' * (len(parts[0])))
969                     flag[i] = 1
970 
971         for i, parts in enumerate(o1):
972             lengths.append(len(parts[flag[i]]))
973             for j in range(n_newlines):
974                 if j+1 <= len(parts):
975                     if j >= len(strs):
976                         strs.append(' ' * (sum(lengths[:-1]) +
977                                            3*(len(lengths)-1)))
978                     if j == flag[i]:
979                         strs[flag[i]] += parts[flag[i]] + ' + '
980                     else:
981                         strs[j] += parts[j] + ' '*(lengths[-1] -
982                                                    len(parts[j])+
983                                                    3)
984                 else:
985                     if j >= len(strs):
986                         strs.append(' ' * (sum(lengths[:-1]) +
987                                            3*(len(lengths)-1)))
988                     strs[j] += ' '*(lengths[-1]+3)
989 
990         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
991 
992     def _print_NDimArray(self, expr):
993         from sympy import ImmutableMatrix
994 
995         if expr.rank() == 0:
996             return self._print(expr[()])
997 
998         level_str = [[]] + [[] for i in range(expr.rank())]
999         shape_ranges = [list(range(i)) for i in expr.shape]
1000         for outer_i in itertools.product(*shape_ranges):
1001             level_str[-1].append(expr[outer_i])
1002             even = True
1003             for back_outer_i in range(expr.rank()-1, -1, -1):
1004                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1005                     break
1006                 if even:
1007                     level_str[back_outer_i].append(level_str[back_outer_i+1])
1008                 else:
1009                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
1010                     if len(level_str[back_outer_i + 1]) == 1:
1011                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
1012                 even = not even
1013                 level_str[back_outer_i+1] = []
1014 
1015         out_expr = level_str[0][0]
1016         if expr.rank() % 2 == 1:
1017             out_expr = ImmutableMatrix([out_expr])
1018 
1019         return self._print(out_expr)
1020 
1021     _print_ImmutableDenseNDimArray = _print_NDimArray
1022     _print_ImmutableSparseNDimArray = _print_NDimArray
1023     _print_MutableDenseNDimArray = _print_NDimArray
1024     _print_MutableSparseNDimArray = _print_NDimArray
1025 
1026     def _printer_tensor_indices(self, name, indices, index_map={}):
1027         center = stringPict(name)
1028         top = stringPict(" "*center.width())
1029         bot = stringPict(" "*center.width())
1030 
1031         last_valence = None
1032         prev_map = None
1033 
1034         for i, index in enumerate(indices):
1035             indpic = self._print(index.args[0])
1036             if ((index in index_map) or prev_map) and last_valence == index.is_up:
1037                 if index.is_up:
1038                     top = prettyForm(*stringPict.next(top, ","))
1039                 else:
1040                     bot = prettyForm(*stringPict.next(bot, ","))
1041             if index in index_map:
1042                 indpic = prettyForm(*stringPict.next(indpic, "="))
1043                 indpic = prettyForm(*stringPict.next(indpic, self._print(index_map[index])))
1044                 prev_map = True
1045             else:
1046                 prev_map = False
1047             if index.is_up:
1048                 top = stringPict(*top.right(indpic))
1049                 center = stringPict(*center.right(" "*indpic.width()))
1050                 bot = stringPict(*bot.right(" "*indpic.width()))
1051             else:
1052                 bot = stringPict(*bot.right(indpic))
1053                 center = stringPict(*center.right(" "*indpic.width()))
1054                 top = stringPict(*top.right(" "*indpic.width()))
1055             last_valence = index.is_up
1056 
1057         pict = prettyForm(*center.above(top))
1058         pict = prettyForm(*pict.below(bot))
1059         return pict
1060 
1061     def _print_Tensor(self, expr):
1062         name = expr.args[0].name
1063         indices = expr.get_indices()
1064         return self._printer_tensor_indices(name, indices)
1065 
1066     def _print_TensorElement(self, expr):
1067         name = expr.expr.args[0].name
1068         indices = expr.expr.get_indices()
1069         index_map = expr.index_map
1070         return self._printer_tensor_indices(name, indices, index_map)
1071 
1072     def _print_TensMul(self, expr):
1073         sign, args = expr._get_args_for_traditional_printer()
1074         args = [
1075             prettyForm(*self._print(i).parens()) if
1076             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1077             for i in args
1078         ]
1079         pform = prettyForm.__mul__(*args)
1080         if sign:
1081             return prettyForm(*pform.left(sign))
1082         else:
1083             return pform
1084 
1085     def _print_TensAdd(self, expr):
1086         args = [
1087             prettyForm(*self._print(i).parens()) if
1088             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1089             for i in expr.args
1090         ]
1091         return prettyForm.__add__(*args)
1092 
1093     def _print_TensorIndex(self, expr):
1094         sym = expr.args[0]
1095         if not expr.is_up:
1096             sym = -sym
1097         return self._print(sym)
1098 
1099     def _print_PartialDerivative(self, deriv):
1100         if self._use_unicode:
1101             deriv_symbol = U('PARTIAL DIFFERENTIAL')
1102         else:
1103             deriv_symbol = r'd'
1104         x = None
1105 
1106         for variable in reversed(deriv.variables):
1107             s = self._print(variable)
1108             ds = prettyForm(*s.left(deriv_symbol))
1109 
1110             if x is None:
1111                 x = ds
1112             else:
1113                 x = prettyForm(*x.right(' '))
1114                 x = prettyForm(*x.right(ds))
1115 
1116         f = prettyForm(
1117             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
1118 
1119         pform = prettyForm(deriv_symbol)
1120 
1121         pform = prettyForm(*pform.below(stringPict.LINE, x))
1122         pform.baseline = pform.baseline + 1
1123         pform = prettyForm(*stringPict.next(pform, f))
1124         pform.binding = prettyForm.MUL
1125 
1126         return pform
1127 
1128     def _print_Piecewise(self, pexpr):
1129 
1130         P = {}
1131         for n, ec in enumerate(pexpr.args):
1132             P[n, 0] = self._print(ec.expr)
1133             if ec.cond == True:
1134                 P[n, 1] = prettyForm('otherwise')
1135             else:
1136                 P[n, 1] = prettyForm(
1137                     *prettyForm('for ').right(self._print(ec.cond)))
1138         hsep = 2
1139         vsep = 1
1140         len_args = len(pexpr.args)
1141 
1142         # max widths
1143         maxw = [max([P[i, j].width() for i in range(len_args)])
1144                 for j in range(2)]
1145 
1146         # FIXME: Refactor this code and matrix into some tabular environment.
1147         # drawing result
1148         D = None
1149 
1150         for i in range(len_args):
1151             D_row = None
1152             for j in range(2):
1153                 p = P[i, j]
1154                 assert p.width() <= maxw[j]
1155 
1156                 wdelta = maxw[j] - p.width()
1157                 wleft = wdelta // 2
1158                 wright = wdelta - wleft
1159 
1160                 p = prettyForm(*p.right(' '*wright))
1161                 p = prettyForm(*p.left(' '*wleft))
1162 
1163                 if D_row is None:
1164                     D_row = p
1165                     continue
1166 
1167                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
1168                 D_row = prettyForm(*D_row.right(p))
1169             if D is None:
1170                 D = D_row       # first row in a picture
1171                 continue
1172 
1173             # v-spacer
1174             for _ in range(vsep):
1175                 D = prettyForm(*D.below(' '))
1176 
1177             D = prettyForm(*D.below(D_row))
1178 
1179         D = prettyForm(*D.parens('{', ''))
1180         D.baseline = D.height()//2
1181         D.binding = prettyForm.OPEN
1182         return D
1183 
1184     def _print_ITE(self, ite):
1185         from sympy.functions.elementary.piecewise import Piecewise
1186         return self._print(ite.rewrite(Piecewise))
1187 
1188     def _hprint_vec(self, v):
1189         D = None
1190 
1191         for a in v:
1192             p = a
1193             if D is None:
1194                 D = p
1195             else:
1196                 D = prettyForm(*D.right(', '))
1197                 D = prettyForm(*D.right(p))
1198         if D is None:
1199             D = stringPict(' ')
1200 
1201         return D
1202 
1203     def _hprint_vseparator(self, p1, p2):
1204         tmp = prettyForm(*p1.right(p2))
1205         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
1206         return prettyForm(*p1.right(sep, p2))
1207 
1208     def _print_hyper(self, e):
1209         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1210         ap = [self._print(a) for a in e.ap]
1211         bq = [self._print(b) for b in e.bq]
1212 
1213         P = self._print(e.argument)
1214         P.baseline = P.height()//2
1215 
1216         # Drawing result - first create the ap, bq vectors
1217         D = None
1218         for v in [ap, bq]:
1219             D_row = self._hprint_vec(v)
1220             if D is None:
1221                 D = D_row       # first row in a picture
1222             else:
1223                 D = prettyForm(*D.below(' '))
1224                 D = prettyForm(*D.below(D_row))
1225 
1226         # make sure that the argument `z' is centred vertically
1227         D.baseline = D.height()//2
1228 
1229         # insert horizontal separator
1230         P = prettyForm(*P.left(' '))
1231         D = prettyForm(*D.right(' '))
1232 
1233         # insert separating `|`
1234         D = self._hprint_vseparator(D, P)
1235 
1236         # add parens
1237         D = prettyForm(*D.parens('(', ')'))
1238 
1239         # create the F symbol
1240         above = D.height()//2 - 1
1241         below = D.height() - above - 1
1242 
1243         sz, t, b, add, img = annotated('F')
1244         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1245                        baseline=above + sz)
1246         add = (sz + 1)//2
1247 
1248         F = prettyForm(*F.left(self._print(len(e.ap))))
1249         F = prettyForm(*F.right(self._print(len(e.bq))))
1250         F.baseline = above + add
1251 
1252         D = prettyForm(*F.right(' ', D))
1253 
1254         return D
1255 
1256     def _print_meijerg(self, e):
1257         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1258 
1259         v = {}
1260         v[(0, 0)] = [self._print(a) for a in e.an]
1261         v[(0, 1)] = [self._print(a) for a in e.aother]
1262         v[(1, 0)] = [self._print(b) for b in e.bm]
1263         v[(1, 1)] = [self._print(b) for b in e.bother]
1264 
1265         P = self._print(e.argument)
1266         P.baseline = P.height()//2
1267 
1268         vp = {}
1269         for idx in v:
1270             vp[idx] = self._hprint_vec(v[idx])
1271 
1272         for i in range(2):
1273             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1274             for j in range(2):
1275                 s = vp[(j, i)]
1276                 left = (maxw - s.width()) // 2
1277                 right = maxw - left - s.width()
1278                 s = prettyForm(*s.left(' ' * left))
1279                 s = prettyForm(*s.right(' ' * right))
1280                 vp[(j, i)] = s
1281 
1282         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1283         D1 = prettyForm(*D1.below(' '))
1284         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1285         D = prettyForm(*D1.below(D2))
1286 
1287         # make sure that the argument `z' is centred vertically
1288         D.baseline = D.height()//2
1289 
1290         # insert horizontal separator
1291         P = prettyForm(*P.left(' '))
1292         D = prettyForm(*D.right(' '))
1293 
1294         # insert separating `|`
1295         D = self._hprint_vseparator(D, P)
1296 
1297         # add parens
1298         D = prettyForm(*D.parens('(', ')'))
1299 
1300         # create the G symbol
1301         above = D.height()//2 - 1
1302         below = D.height() - above - 1
1303 
1304         sz, t, b, add, img = annotated('G')
1305         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1306                        baseline=above + sz)
1307 
1308         pp = self._print(len(e.ap))
1309         pq = self._print(len(e.bq))
1310         pm = self._print(len(e.bm))
1311         pn = self._print(len(e.an))
1312 
1313         def adjust(p1, p2):
1314             diff = p1.width() - p2.width()
1315             if diff == 0:
1316                 return p1, p2
1317             elif diff > 0:
1318                 return p1, prettyForm(*p2.left(' '*diff))
1319             else:
1320                 return prettyForm(*p1.left(' '*-diff)), p2
1321         pp, pm = adjust(pp, pm)
1322         pq, pn = adjust(pq, pn)
1323         pu = prettyForm(*pm.right(', ', pn))
1324         pl = prettyForm(*pp.right(', ', pq))
1325 
1326         ht = F.baseline - above - 2
1327         if ht > 0:
1328             pu = prettyForm(*pu.below('\n'*ht))
1329         p = prettyForm(*pu.below(pl))
1330 
1331         F.baseline = above
1332         F = prettyForm(*F.right(p))
1333 
1334         F.baseline = above + add
1335 
1336         D = prettyForm(*F.right(' ', D))
1337 
1338         return D
1339 
1340     def _print_ExpBase(self, e):
1341         # TODO should exp_polar be printed differently?
1342         #      what about exp_polar(0), exp_polar(1)?
1343         base = prettyForm(pretty_atom('Exp1', 'e'))
1344         return base ** self._print(e.args[0])
1345 
1346     def _print_Function(self, e, sort=False, func_name=None):
1347         # optional argument func_name for supplying custom names
1348         # XXX works only for applied functions
1349         func = e.func
1350         args = e.args
1351         if sort:
1352             args = sorted(args, key=default_sort_key)
1353 
1354         if not func_name:
1355             func_name = func.__name__
1356 
1357         prettyFunc = self._print(Symbol(func_name))
1358         prettyArgs = prettyForm(*self._print_seq(args).parens())
1359 
1360         pform = prettyForm(
1361             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1362 
1363         # store pform parts so it can be reassembled e.g. when powered
1364         pform.prettyFunc = prettyFunc
1365         pform.prettyArgs = prettyArgs
1366 
1367         return pform
1368 
1369     @property
1370     def _special_function_classes(self):
1371         from sympy.functions.special.tensor_functions import KroneckerDelta
1372         from sympy.functions.special.gamma_functions import gamma, lowergamma
1373         from sympy.functions.special.beta_functions import beta
1374         from sympy.functions.special.delta_functions import DiracDelta
1375         from sympy.functions.special.error_functions import Chi
1376         return {KroneckerDelta: [greek_unicode['delta'], 'delta'],
1377                 gamma: [greek_unicode['Gamma'], 'Gamma'],
1378                 lowergamma: [greek_unicode['gamma'], 'gamma'],
1379                 beta: [greek_unicode['Beta'], 'B'],
1380                 DiracDelta: [greek_unicode['delta'], 'delta'],
1381                 Chi: ['Chi', 'Chi']}
1382 
1383     def _print_FunctionClass(self, expr):
1384         for cls in self._special_function_classes:
1385             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
1386                 if self._use_unicode:
1387                     return prettyForm(self._special_function_classes[cls][0])
1388                 else:
1389                     return prettyForm(self._special_function_classes[cls][1])
1390         func_name = expr.__name__
1391         return prettyForm(pretty_symbol(func_name))
1392 
1393     def _print_GeometryEntity(self, expr):
1394         # GeometryEntity is based on Tuple but should not print like a Tuple
1395         return self.emptyPrinter(expr)
1396 
1397     def _print_Lambda(self, e):
1398         vars, expr = e.args
1399         if self._use_unicode:
1400             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1401         else:
1402             arrow = " -> "
1403         if len(vars) == 1:
1404             var_form = self._print(vars[0])
1405         else:
1406             var_form = self._print(tuple(vars))
1407 
1408         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1409 
1410     def _print_Order(self, expr):
1411         pform = self._print(expr.expr)
1412         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1413            len(expr.variables) > 1:
1414             pform = prettyForm(*pform.right("; "))
1415             if len(expr.variables) > 1:
1416                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1417             elif len(expr.variables):
1418                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1419             if self._use_unicode:
1420                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1421             else:
1422                 pform = prettyForm(*pform.right(" -> "))
1423             if len(expr.point) > 1:
1424                 pform = prettyForm(*pform.right(self._print(expr.point)))
1425             else:
1426                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1427         pform = prettyForm(*pform.parens())
1428         pform = prettyForm(*pform.left("O"))
1429         return pform
1430 
1431     def _print_SingularityFunction(self, e):
1432         if self._use_unicode:
1433             shift = self._print(e.args[0]-e.args[1])
1434             n = self._print(e.args[2])
1435             base = prettyForm("<")
1436             base = prettyForm(*base.right(shift))
1437             base = prettyForm(*base.right(">"))
1438             pform = base**n
1439             return pform
1440         else:
1441             n = self._print(e.args[2])
1442             shift = self._print(e.args[0]-e.args[1])
1443             base = self._print_seq(shift, "<", ">", ' ')
1444             return base**n
1445 
1446     def _print_beta(self, e):
1447         func_name = greek_unicode['Beta'] if self._use_unicode else 'B'
1448         return self._print_Function(e, func_name=func_name)
1449 
1450     def _print_gamma(self, e):
1451         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1452         return self._print_Function(e, func_name=func_name)
1453 
1454     def _print_uppergamma(self, e):
1455         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1456         return self._print_Function(e, func_name=func_name)
1457 
1458     def _print_lowergamma(self, e):
1459         func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'
1460         return self._print_Function(e, func_name=func_name)
1461 
1462     def _print_DiracDelta(self, e):
1463         if self._use_unicode:
1464             if len(e.args) == 2:
1465                 a = prettyForm(greek_unicode['delta'])
1466                 b = self._print(e.args[1])
1467                 b = prettyForm(*b.parens())
1468                 c = self._print(e.args[0])
1469                 c = prettyForm(*c.parens())
1470                 pform = a**b
1471                 pform = prettyForm(*pform.right(' '))
1472                 pform = prettyForm(*pform.right(c))
1473                 return pform
1474             pform = self._print(e.args[0])
1475             pform = prettyForm(*pform.parens())
1476             pform = prettyForm(*pform.left(greek_unicode['delta']))
1477             return pform
1478         else:
1479             return self._print_Function(e)
1480 
1481     def _print_expint(self, e):
1482         from sympy import Function
1483         if e.args[0].is_Integer and self._use_unicode:
1484             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1485         return self._print_Function(e)
1486 
1487     def _print_Chi(self, e):
1488         # This needs a special case since otherwise it comes out as greek
1489         # letter chi...
1490         prettyFunc = prettyForm("Chi")
1491         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1492 
1493         pform = prettyForm(
1494             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1495 
1496         # store pform parts so it can be reassembled e.g. when powered
1497         pform.prettyFunc = prettyFunc
1498         pform.prettyArgs = prettyArgs
1499 
1500         return pform
1501 
1502     def _print_elliptic_e(self, e):
1503         pforma0 = self._print(e.args[0])
1504         if len(e.args) == 1:
1505             pform = pforma0
1506         else:
1507             pforma1 = self._print(e.args[1])
1508             pform = self._hprint_vseparator(pforma0, pforma1)
1509         pform = prettyForm(*pform.parens())
1510         pform = prettyForm(*pform.left('E'))
1511         return pform
1512 
1513     def _print_elliptic_k(self, e):
1514         pform = self._print(e.args[0])
1515         pform = prettyForm(*pform.parens())
1516         pform = prettyForm(*pform.left('K'))
1517         return pform
1518 
1519     def _print_elliptic_f(self, e):
1520         pforma0 = self._print(e.args[0])
1521         pforma1 = self._print(e.args[1])
1522         pform = self._hprint_vseparator(pforma0, pforma1)
1523         pform = prettyForm(*pform.parens())
1524         pform = prettyForm(*pform.left('F'))
1525         return pform
1526 
1527     def _print_elliptic_pi(self, e):
1528         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1529         pforma0 = self._print(e.args[0])
1530         pforma1 = self._print(e.args[1])
1531         if len(e.args) == 2:
1532             pform = self._hprint_vseparator(pforma0, pforma1)
1533         else:
1534             pforma2 = self._print(e.args[2])
1535             pforma = self._hprint_vseparator(pforma1, pforma2)
1536             pforma = prettyForm(*pforma.left('; '))
1537             pform = prettyForm(*pforma.left(pforma0))
1538         pform = prettyForm(*pform.parens())
1539         pform = prettyForm(*pform.left(name))
1540         return pform
1541 
1542     def _print_GoldenRatio(self, expr):
1543         if self._use_unicode:
1544             return prettyForm(pretty_symbol('phi'))
1545         return self._print(Symbol("GoldenRatio"))
1546 
1547     def _print_EulerGamma(self, expr):
1548         if self._use_unicode:
1549             return prettyForm(pretty_symbol('gamma'))
1550         return self._print(Symbol("EulerGamma"))
1551 
1552     def _print_Mod(self, expr):
1553         pform = self._print(expr.args[0])
1554         if pform.binding > prettyForm.MUL:
1555             pform = prettyForm(*pform.parens())
1556         pform = prettyForm(*pform.right(' mod '))
1557         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1558         pform.binding = prettyForm.OPEN
1559         return pform
1560 
1561     def _print_Add(self, expr, order=None):
1562         if self.order == 'none':
1563             terms = list(expr.args)
1564         else:
1565             terms = self._as_ordered_terms(expr, order=order)
1566         pforms, indices = [], []
1567 
1568         def pretty_negative(pform, index):
1569             """Prepend a minus sign to a pretty form. """
1570             #TODO: Move this code to prettyForm
1571             if index == 0:
1572                 if pform.height() > 1:
1573                     pform_neg = '- '
1574                 else:
1575                     pform_neg = '-'
1576             else:
1577                 pform_neg = ' - '
1578 
1579             if (pform.binding > prettyForm.NEG
1580                 or pform.binding == prettyForm.ADD):
1581                 p = stringPict(*pform.parens())
1582             else:
1583                 p = pform
1584             p = stringPict.next(pform_neg, p)
1585             # Lower the binding to NEG, even if it was higher. Otherwise, it
1586             # will print as a + ( - (b)), instead of a - (b).
1587             return prettyForm(binding=prettyForm.NEG, *p)
1588 
1589         for i, term in enumerate(terms):
1590             if term.is_Mul and _coeff_isneg(term):
1591                 coeff, other = term.as_coeff_mul(rational=False)
1592                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1593                 pforms.append(pretty_negative(pform, i))
1594             elif term.is_Rational and term.q > 1:
1595                 pforms.append(None)
1596                 indices.append(i)
1597             elif term.is_Number and term < 0:
1598                 pform = self._print(-term)
1599                 pforms.append(pretty_negative(pform, i))
1600             elif term.is_Relational:
1601                 pforms.append(prettyForm(*self._print(term).parens()))
1602             else:
1603                 pforms.append(self._print(term))
1604 
1605         if indices:
1606             large = True
1607 
1608             for pform in pforms:
1609                 if pform is not None and pform.height() > 1:
1610                     break
1611             else:
1612                 large = False
1613 
1614             for i in indices:
1615                 term, negative = terms[i], False
1616 
1617                 if term < 0:
1618                     term, negative = -term, True
1619 
1620                 if large:
1621                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1622                 else:
1623                     pform = self._print(term)
1624 
1625                 if negative:
1626                     pform = pretty_negative(pform, i)
1627 
1628                 pforms[i] = pform
1629 
1630         return prettyForm.__add__(*pforms)
1631 
1632     def _print_Mul(self, product):
1633         from sympy.physics.units import Quantity
1634         a = []  # items in the numerator
1635         b = []  # items that are in the denominator (if any)
1636 
1637         if self.order not in ('old', 'none'):
1638             args = product.as_ordered_factors()
1639         else:
1640             args = list(product.args)
1641 
1642         # If quantities are present append them at the back
1643         args = sorted(args, key=lambda x: isinstance(x, Quantity) or
1644                      (isinstance(x, Pow) and isinstance(x.base, Quantity)))
1645 
1646         # Gather terms for numerator/denominator
1647         for item in args:
1648             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1649                 if item.exp != -1:
1650                     b.append(Pow(item.base, -item.exp, evaluate=False))
1651                 else:
1652                     b.append(Pow(item.base, -item.exp))
1653             elif item.is_Rational and item is not S.Infinity:
1654                 if item.p != 1:
1655                     a.append( Rational(item.p) )
1656                 if item.q != 1:
1657                     b.append( Rational(item.q) )
1658             else:
1659                 a.append(item)
1660 
1661         from sympy import Integral, Piecewise, Product, Sum
1662 
1663         # Convert to pretty forms. Add parens to Add instances if there
1664         # is more than one term in the numer/denom
1665         for i in range(0, len(a)):
1666             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1667                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1668                 a[i] = prettyForm(*self._print(a[i]).parens())
1669             elif a[i].is_Relational:
1670                 a[i] = prettyForm(*self._print(a[i]).parens())
1671             else:
1672                 a[i] = self._print(a[i])
1673 
1674         for i in range(0, len(b)):
1675             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1676                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1677                 b[i] = prettyForm(*self._print(b[i]).parens())
1678             else:
1679                 b[i] = self._print(b[i])
1680 
1681         # Construct a pretty form
1682         if len(b) == 0:
1683             return prettyForm.__mul__(*a)
1684         else:
1685             if len(a) == 0:
1686                 a.append( self._print(S.One) )
1687             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1688 
1689     # A helper function for _print_Pow to print x**(1/n)
1690     def _print_nth_root(self, base, expt):
1691         bpretty = self._print(base)
1692 
1693         # In very simple cases, use a single-char root sign
1694         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1695             and expt is S.Half and bpretty.height() == 1
1696             and (bpretty.width() == 1
1697                  or (base.is_Integer and base.is_nonnegative))):
1698             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1699 
1700         # Construct root sign, start with the \/ shape
1701         _zZ = xobj('/', 1)
1702         rootsign = xobj('\\', 1) + _zZ
1703         # Make exponent number to put above it
1704         if isinstance(expt, Rational):
1705             exp = str(expt.q)
1706             if exp == '2':
1707                 exp = ''
1708         else:
1709             exp = str(expt.args[0])
1710         exp = exp.ljust(2)
1711         if len(exp) > 2:
1712             rootsign = ' '*(len(exp) - 2) + rootsign
1713         # Stack the exponent
1714         rootsign = stringPict(exp + '\n' + rootsign)
1715         rootsign.baseline = 0
1716         # Diagonal: length is one less than height of base
1717         linelength = bpretty.height() - 1
1718         diagonal = stringPict('\n'.join(
1719             ' '*(linelength - i - 1) + _zZ + ' '*i
1720             for i in range(linelength)
1721         ))
1722         # Put baseline just below lowest line: next to exp
1723         diagonal.baseline = linelength - 1
1724         # Make the root symbol
1725         rootsign = prettyForm(*rootsign.right(diagonal))
1726         # Det the baseline to match contents to fix the height
1727         # but if the height of bpretty is one, the rootsign must be one higher
1728         rootsign.baseline = max(1, bpretty.baseline)
1729         #build result
1730         s = prettyForm(hobj('_', 2 + bpretty.width()))
1731         s = prettyForm(*bpretty.above(s))
1732         s = prettyForm(*s.left(rootsign))
1733         return s
1734 
1735     def _print_Pow(self, power):
1736         from sympy.simplify.simplify import fraction
1737         b, e = power.as_base_exp()
1738         if power.is_commutative:
1739             if e is S.NegativeOne:
1740                 return prettyForm("1")/self._print(b)
1741             n, d = fraction(e)
1742             if n is S.One and d.is_Atom and not e.is_Integer and self._settings['root_notation']:
1743                 return self._print_nth_root(b, e)
1744             if e.is_Rational and e < 0:
1745                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1746 
1747         if b.is_Relational:
1748             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1749 
1750         return self._print(b)**self._print(e)
1751 
1752     def _print_UnevaluatedExpr(self, expr):
1753         return self._print(expr.args[0])
1754 
1755     def __print_numer_denom(self, p, q):
1756         if q == 1:
1757             if p < 0:
1758                 return prettyForm(str(p), binding=prettyForm.NEG)
1759             else:
1760                 return prettyForm(str(p))
1761         elif abs(p) >= 10 and abs(q) >= 10:
1762             # If more than one digit in numer and denom, print larger fraction
1763             if p < 0:
1764                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1765                 # Old printing method:
1766                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1767                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1768             else:
1769                 return prettyForm(str(p))/prettyForm(str(q))
1770         else:
1771             return None
1772 
1773     def _print_Rational(self, expr):
1774         result = self.__print_numer_denom(expr.p, expr.q)
1775 
1776         if result is not None:
1777             return result
1778         else:
1779             return self.emptyPrinter(expr)
1780 
1781     def _print_Fraction(self, expr):
1782         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1783 
1784         if result is not None:
1785             return result
1786         else:
1787             return self.emptyPrinter(expr)
1788 
1789     def _print_ProductSet(self, p):
1790         if len(p.sets) > 1 and not has_variety(p.sets):
1791             from sympy import Pow
1792             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1793         else:
1794             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1795             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1796                                    parenthesize=lambda set: set.is_Union or
1797                                    set.is_Intersection or set.is_ProductSet)
1798 
1799     def _print_FiniteSet(self, s):
1800         items = sorted(s.args, key=default_sort_key)
1801         return self._print_seq(items, '{', '}', ', ' )
1802 
1803     def _print_Range(self, s):
1804 
1805         if self._use_unicode:
1806             dots = u"\N{HORIZONTAL ELLIPSIS}"
1807         else:
1808             dots = '...'
1809 
1810         if s.start.is_infinite:
1811             printset = s.start, dots, s[-1] - s.step, s[-1]
1812         elif s.stop.is_infinite or len(s) > 4:
1813             it = iter(s)
1814             printset = next(it), next(it), dots, s[-1]
1815         else:
1816             printset = tuple(s)
1817 
1818         return self._print_seq(printset, '{', '}', ', ' )
1819 
1820     def _print_Interval(self, i):
1821         if i.start == i.end:
1822             return self._print_seq(i.args[:1], '{', '}')
1823 
1824         else:
1825             if i.left_open:
1826                 left = '('
1827             else:
1828                 left = '['
1829 
1830             if i.right_open:
1831                 right = ')'
1832             else:
1833                 right = ']'
1834 
1835             return self._print_seq(i.args[:2], left, right)
1836 
1837     def _print_AccumulationBounds(self, i):
1838         left = '<'
1839         right = '>'
1840 
1841         return self._print_seq(i.args[:2], left, right)
1842 
1843     def _print_Intersection(self, u):
1844 
1845         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1846 
1847         return self._print_seq(u.args, None, None, delimiter,
1848                                parenthesize=lambda set: set.is_ProductSet or
1849                                set.is_Union or set.is_Complement)
1850 
1851     def _print_Union(self, u):
1852 
1853         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1854 
1855         return self._print_seq(u.args, None, None, union_delimiter,
1856                                parenthesize=lambda set: set.is_ProductSet or
1857                                set.is_Intersection or set.is_Complement)
1858 
1859     def _print_SymmetricDifference(self, u):
1860         if not self._use_unicode:
1861             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1862 
1863         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1864 
1865         return self._print_seq(u.args, None, None, sym_delimeter)
1866 
1867     def _print_Complement(self, u):
1868 
1869         delimiter = r' \ '
1870 
1871         return self._print_seq(u.args, None, None, delimiter,
1872              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1873                                or set.is_Union)
1874 
1875     def _print_ImageSet(self, ts):
1876         if self._use_unicode:
1877             inn = u"\N{SMALL ELEMENT OF}"
1878         else:
1879             inn = 'in'
1880         variables = ts.lamda.variables
1881         expr = self._print(ts.lamda.expr)
1882         bar = self._print("|")
1883         sets = [self._print(i) for i in ts.args[1:]]
1884         if len(sets) == 1:
1885             return self._print_seq((expr, bar, variables[0], inn, sets[0]), "{", "}", ' ')
1886         else:
1887             pargs = tuple(j for var, setv in zip(variables, sets) for j in (var, inn, setv, ","))
1888             return self._print_seq((expr, bar) + pargs[:-1], "{", "}", ' ')
1889 
1890     def _print_ConditionSet(self, ts):
1891         if self._use_unicode:
1892             inn = u"\N{SMALL ELEMENT OF}"
1893             # using _and because and is a keyword and it is bad practice to
1894             # overwrite them
1895             _and = u"\N{LOGICAL AND}"
1896         else:
1897             inn = 'in'
1898             _and = 'and'
1899 
1900         variables = self._print_seq(Tuple(ts.sym))
1901         try:
1902             cond = self._print(ts.condition.as_expr())
1903         except AttributeError:
1904             cond = self._print(ts.condition)
1905             if self._use_unicode:
1906                 cond = self._print_seq(cond, "(", ")")
1907 
1908         bar = self._print("|")
1909 
1910         if ts.base_set is S.UniversalSet:
1911             return self._print_seq((variables, bar, cond), "{", "}", ' ')
1912 
1913         base = self._print(ts.base_set)
1914         return self._print_seq((variables, bar, variables, inn,
1915                                 base, _and, cond), "{", "}", ' ')
1916 
1917     def _print_ComplexRegion(self, ts):
1918         if self._use_unicode:
1919             inn = u"\N{SMALL ELEMENT OF}"
1920         else:
1921             inn = 'in'
1922         variables = self._print_seq(ts.variables)
1923         expr = self._print(ts.expr)
1924         bar = self._print("|")
1925         prodsets = self._print(ts.sets)
1926 
1927         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1928 
1929     def _print_Contains(self, e):
1930         var, set = e.args
1931         if self._use_unicode:
1932             el = u" \N{ELEMENT OF} "
1933             return prettyForm(*stringPict.next(self._print(var),
1934                                                el, self._print(set)), binding=8)
1935         else:
1936             return prettyForm(sstr(e))
1937 
1938     def _print_FourierSeries(self, s):
1939         if self._use_unicode:
1940             dots = u"\N{HORIZONTAL ELLIPSIS}"
1941         else:
1942             dots = '...'
1943         return self._print_Add(s.truncate()) + self._print(dots)
1944 
1945     def _print_FormalPowerSeries(self, s):
1946         return self._print_Add(s.infinite)
1947 
1948     def _print_SetExpr(self, se):
1949         pretty_set = prettyForm(*self._print(se.set).parens())
1950         pretty_name = self._print(Symbol("SetExpr"))
1951         return prettyForm(*pretty_name.right(pretty_set))
1952 
1953     def _print_SeqFormula(self, s):
1954         if self._use_unicode:
1955             dots = u"\N{HORIZONTAL ELLIPSIS}"
1956         else:
1957             dots = '...'
1958 
1959         if s.start is S.NegativeInfinity:
1960             stop = s.stop
1961             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1962                 s.coeff(stop - 1), s.coeff(stop))
1963         elif s.stop is S.Infinity or s.length > 4:
1964             printset = s[:4]
1965             printset.append(dots)
1966             printset = tuple(printset)
1967         else:
1968             printset = tuple(s)
1969         return self._print_list(printset)
1970 
1971     _print_SeqPer = _print_SeqFormula
1972     _print_SeqAdd = _print_SeqFormula
1973     _print_SeqMul = _print_SeqFormula
1974 
1975     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1976             parenthesize=lambda x: False):
1977         s = None
1978         try:
1979             for item in seq:
1980                 pform = self._print(item)
1981 
1982                 if parenthesize(item):
1983                     pform = prettyForm(*pform.parens())
1984                 if s is None:
1985                     # first element
1986                     s = pform
1987                 else:
1988                     s = prettyForm(*stringPict.next(s, delimiter))
1989                     s = prettyForm(*stringPict.next(s, pform))
1990 
1991             if s is None:
1992                 s = stringPict('')
1993 
1994         except AttributeError:
1995             s = None
1996             for item in seq:
1997                 pform = self.doprint(item)
1998                 if parenthesize(item):
1999                     pform = prettyForm(*pform.parens())
2000                 if s is None:
2001                     # first element
2002                     s = pform
2003                 else :
2004                     s = prettyForm(*stringPict.next(s, delimiter))
2005                     s = prettyForm(*stringPict.next(s, pform))
2006 
2007             if s is None:
2008                 s = stringPict('')
2009 
2010         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
2011         return s
2012 
2013     def join(self, delimiter, args):
2014         pform = None
2015 
2016         for arg in args:
2017             if pform is None:
2018                 pform = arg
2019             else:
2020                 pform = prettyForm(*pform.right(delimiter))
2021                 pform = prettyForm(*pform.right(arg))
2022 
2023         if pform is None:
2024             return prettyForm("")
2025         else:
2026             return pform
2027 
2028     def _print_list(self, l):
2029         return self._print_seq(l, '[', ']')
2030 
2031     def _print_tuple(self, t):
2032         if len(t) == 1:
2033             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
2034             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
2035         else:
2036             return self._print_seq(t, '(', ')')
2037 
2038     def _print_Tuple(self, expr):
2039         return self._print_tuple(expr)
2040 
2041     def _print_dict(self, d):
2042         keys = sorted(d.keys(), key=default_sort_key)
2043         items = []
2044 
2045         for k in keys:
2046             K = self._print(k)
2047             V = self._print(d[k])
2048             s = prettyForm(*stringPict.next(K, ': ', V))
2049 
2050             items.append(s)
2051 
2052         return self._print_seq(items, '{', '}')
2053 
2054     def _print_Dict(self, d):
2055         return self._print_dict(d)
2056 
2057     def _print_set(self, s):
2058         if not s:
2059             return prettyForm('set()')
2060         items = sorted(s, key=default_sort_key)
2061         pretty = self._print_seq(items)
2062         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2063         return pretty
2064 
2065     def _print_frozenset(self, s):
2066         if not s:
2067             return prettyForm('frozenset()')
2068         items = sorted(s, key=default_sort_key)
2069         pretty = self._print_seq(items)
2070         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2071         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
2072         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
2073         return pretty
2074 
2075     def _print_PolyRing(self, ring):
2076         return prettyForm(sstr(ring))
2077 
2078     def _print_FracField(self, field):
2079         return prettyForm(sstr(field))
2080 
2081     def _print_FreeGroupElement(self, elm):
2082         return prettyForm(str(elm))
2083 
2084     def _print_PolyElement(self, poly):
2085         return prettyForm(sstr(poly))
2086 
2087     def _print_FracElement(self, frac):
2088         return prettyForm(sstr(frac))
2089 
2090     def _print_AlgebraicNumber(self, expr):
2091         if expr.is_aliased:
2092             return self._print(expr.as_poly().as_expr())
2093         else:
2094             return self._print(expr.as_expr())
2095 
2096     def _print_ComplexRootOf(self, expr):
2097         args = [self._print_Add(expr.expr, order='lex'), expr.index]
2098         pform = prettyForm(*self._print_seq(args).parens())
2099         pform = prettyForm(*pform.left('CRootOf'))
2100         return pform
2101 
2102     def _print_RootSum(self, expr):
2103         args = [self._print_Add(expr.expr, order='lex')]
2104 
2105         if expr.fun is not S.IdentityFunction:
2106             args.append(self._print(expr.fun))
2107 
2108         pform = prettyForm(*self._print_seq(args).parens())
2109         pform = prettyForm(*pform.left('RootSum'))
2110 
2111         return pform
2112 
2113     def _print_FiniteField(self, expr):
2114         if self._use_unicode:
2115             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
2116         else:
2117             form = 'GF(%d)'
2118 
2119         return prettyForm(pretty_symbol(form % expr.mod))
2120 
2121     def _print_IntegerRing(self, expr):
2122         if self._use_unicode:
2123             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
2124         else:
2125             return prettyForm('ZZ')
2126 
2127     def _print_RationalField(self, expr):
2128         if self._use_unicode:
2129             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
2130         else:
2131             return prettyForm('QQ')
2132 
2133     def _print_RealField(self, domain):
2134         if self._use_unicode:
2135             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
2136         else:
2137             prefix = 'RR'
2138 
2139         if domain.has_default_precision:
2140             return prettyForm(prefix)
2141         else:
2142             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2143 
2144     def _print_ComplexField(self, domain):
2145         if self._use_unicode:
2146             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
2147         else:
2148             prefix = 'CC'
2149 
2150         if domain.has_default_precision:
2151             return prettyForm(prefix)
2152         else:
2153             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2154 
2155     def _print_PolynomialRing(self, expr):
2156         args = list(expr.symbols)
2157 
2158         if not expr.order.is_default:
2159             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2160             args.append(order)
2161 
2162         pform = self._print_seq(args, '[', ']')
2163         pform = prettyForm(*pform.left(self._print(expr.domain)))
2164 
2165         return pform
2166 
2167     def _print_FractionField(self, expr):
2168         args = list(expr.symbols)
2169 
2170         if not expr.order.is_default:
2171             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2172             args.append(order)
2173 
2174         pform = self._print_seq(args, '(', ')')
2175         pform = prettyForm(*pform.left(self._print(expr.domain)))
2176 
2177         return pform
2178 
2179     def _print_PolynomialRingBase(self, expr):
2180         g = expr.symbols
2181         if str(expr.order) != str(expr.default_order):
2182             g = g + ("order=" + str(expr.order),)
2183         pform = self._print_seq(g, '[', ']')
2184         pform = prettyForm(*pform.left(self._print(expr.domain)))
2185 
2186         return pform
2187 
2188     def _print_GroebnerBasis(self, basis):
2189         exprs = [ self._print_Add(arg, order=basis.order)
2190                   for arg in basis.exprs ]
2191         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
2192 
2193         gens = [ self._print(gen) for gen in basis.gens ]
2194 
2195         domain = prettyForm(
2196             *prettyForm("domain=").right(self._print(basis.domain)))
2197         order = prettyForm(
2198             *prettyForm("order=").right(self._print(basis.order)))
2199 
2200         pform = self.join(", ", [exprs] + gens + [domain, order])
2201 
2202         pform = prettyForm(*pform.parens())
2203         pform = prettyForm(*pform.left(basis.__class__.__name__))
2204 
2205         return pform
2206 
2207     def _print_Subs(self, e):
2208         pform = self._print(e.expr)
2209         pform = prettyForm(*pform.parens())
2210 
2211         h = pform.height() if pform.height() > 1 else 2
2212         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
2213         pform = prettyForm(*pform.right(rvert))
2214 
2215         b = pform.baseline
2216         pform.baseline = pform.height() - 1
2217         pform = prettyForm(*pform.right(self._print_seq([
2218             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
2219                 delimiter='') for v in zip(e.variables, e.point) ])))
2220 
2221         pform.baseline = b
2222         return pform
2223 
2224     def _print_euler(self, e):
2225         pform = prettyForm("E")
2226         arg = self._print(e.args[0])
2227         pform_arg = prettyForm(" "*arg.width())
2228         pform_arg = prettyForm(*pform_arg.below(arg))
2229         pform = prettyForm(*pform.right(pform_arg))
2230         if len(e.args) == 1:
2231             return pform
2232         m, x = e.args
2233         # TODO: copy-pasted from _print_Function: can we do better?
2234         prettyFunc = pform
2235         prettyArgs = prettyForm(*self._print_seq([x]).parens())
2236         pform = prettyForm(
2237             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
2238         pform.prettyFunc = prettyFunc
2239         pform.prettyArgs = prettyArgs
2240         return pform
2241 
2242     def _print_catalan(self, e):
2243         pform = prettyForm("C")
2244         arg = self._print(e.args[0])
2245         pform_arg = prettyForm(" "*arg.width())
2246         pform_arg = prettyForm(*pform_arg.below(arg))
2247         pform = prettyForm(*pform.right(pform_arg))
2248         return pform
2249 
2250     def _print_KroneckerDelta(self, e):
2251         pform = self._print(e.args[0])
2252         pform = prettyForm(*pform.right((prettyForm(','))))
2253         pform = prettyForm(*pform.right((self._print(e.args[1]))))
2254         if self._use_unicode:
2255             a = stringPict(pretty_symbol('delta'))
2256         else:
2257             a = stringPict('d')
2258         b = pform
2259         top = stringPict(*b.left(' '*a.width()))
2260         bot = stringPict(*a.right(' '*b.width()))
2261         return prettyForm(binding=prettyForm.POW, *bot.below(top))
2262 
2263     def _print_RandomDomain(self, d):
2264         if hasattr(d, 'as_boolean'):
2265             pform = self._print('Domain: ')
2266             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
2267             return pform
2268         elif hasattr(d, 'set'):
2269             pform = self._print('Domain: ')
2270             pform = prettyForm(*pform.right(self._print(d.symbols)))
2271             pform = prettyForm(*pform.right(self._print(' in ')))
2272             pform = prettyForm(*pform.right(self._print(d.set)))
2273             return pform
2274         elif hasattr(d, 'symbols'):
2275             pform = self._print('Domain on ')
2276             pform = prettyForm(*pform.right(self._print(d.symbols)))
2277             return pform
2278         else:
2279             return self._print(None)
2280 
2281     def _print_DMP(self, p):
2282         try:
2283             if p.ring is not None:
2284                 # TODO incorporate order
2285                 return self._print(p.ring.to_sympy(p))
2286         except SympifyError:
2287             pass
2288         return self._print(repr(p))
2289 
2290     def _print_DMF(self, p):
2291         return self._print_DMP(p)
2292 
2293     def _print_Object(self, object):
2294         return self._print(pretty_symbol(object.name))
2295 
2296     def _print_Morphism(self, morphism):
2297         arrow = xsym("-->")
2298 
2299         domain = self._print(morphism.domain)
2300         codomain = self._print(morphism.codomain)
2301         tail = domain.right(arrow, codomain)[0]
2302 
2303         return prettyForm(tail)
2304 
2305     def _print_NamedMorphism(self, morphism):
2306         pretty_name = self._print(pretty_symbol(morphism.name))
2307         pretty_morphism = self._print_Morphism(morphism)
2308         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2309 
2310     def _print_IdentityMorphism(self, morphism):
2311         from sympy.categories import NamedMorphism
2312         return self._print_NamedMorphism(
2313             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2314 
2315     def _print_CompositeMorphism(self, morphism):
2316 
2317         circle = xsym(".")
2318 
2319         # All components of the morphism have names and it is thus
2320         # possible to build the name of the composite.
2321         component_names_list = [pretty_symbol(component.name) for
2322                                 component in morphism.components]
2323         component_names_list.reverse()
2324         component_names = circle.join(component_names_list) + ":"
2325 
2326         pretty_name = self._print(component_names)
2327         pretty_morphism = self._print_Morphism(morphism)
2328         return prettyForm(pretty_name.right(pretty_morphism)[0])
2329 
2330     def _print_Category(self, category):
2331         return self._print(pretty_symbol(category.name))
2332 
2333     def _print_Diagram(self, diagram):
2334         if not diagram.premises:
2335             # This is an empty diagram.
2336             return self._print(S.EmptySet)
2337 
2338         pretty_result = self._print(diagram.premises)
2339         if diagram.conclusions:
2340             results_arrow = " %s " % xsym("==>")
2341 
2342             pretty_conclusions = self._print(diagram.conclusions)[0]
2343             pretty_result = pretty_result.right(
2344                 results_arrow, pretty_conclusions)
2345 
2346         return prettyForm(pretty_result[0])
2347 
2348     def _print_DiagramGrid(self, grid):
2349         from sympy.matrices import Matrix
2350         from sympy import Symbol
2351         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2352                           for j in range(grid.width)]
2353                          for i in range(grid.height)])
2354         return self._print_matrix_contents(matrix)
2355 
2356     def _print_FreeModuleElement(self, m):
2357         # Print as row vector for convenience, for now.
2358         return self._print_seq(m, '[', ']')
2359 
2360     def _print_SubModule(self, M):
2361         return self._print_seq(M.gens, '<', '>')
2362 
2363     def _print_FreeModule(self, M):
2364         return self._print(M.ring)**self._print(M.rank)
2365 
2366     def _print_ModuleImplementedIdeal(self, M):
2367         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2368 
2369     def _print_QuotientRing(self, R):
2370         return self._print(R.ring) / self._print(R.base_ideal)
2371 
2372     def _print_QuotientRingElement(self, R):
2373         return self._print(R.data) + self._print(R.ring.base_ideal)
2374 
2375     def _print_QuotientModuleElement(self, m):
2376         return self._print(m.data) + self._print(m.module.killed_module)
2377 
2378     def _print_QuotientModule(self, M):
2379         return self._print(M.base) / self._print(M.killed_module)
2380 
2381     def _print_MatrixHomomorphism(self, h):
2382         matrix = self._print(h._sympy_matrix())
2383         matrix.baseline = matrix.height() // 2
2384         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2385             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2386         return pform
2387 
2388     def _print_BaseScalarField(self, field):
2389         string = field._coord_sys._names[field._index]
2390         return self._print(pretty_symbol(string))
2391 
2392     def _print_BaseVectorField(self, field):
2393         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2394         return self._print(pretty_symbol(s))
2395 
2396     def _print_Differential(self, diff):
2397         field = diff._form_field
2398         if hasattr(field, '_coord_sys'):
2399             string = field._coord_sys._names[field._index]
2400             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2401         else:
2402             pform = self._print(field)
2403             pform = prettyForm(*pform.parens())
2404             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2405 
2406     def _print_Tr(self, p):
2407         #TODO: Handle indices
2408         pform = self._print(p.args[0])
2409         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2410         pform = prettyForm(*pform.right(')'))
2411         return pform
2412 
2413     def _print_primenu(self, e):
2414         pform = self._print(e.args[0])
2415         pform = prettyForm(*pform.parens())
2416         if self._use_unicode:
2417             pform = prettyForm(*pform.left(greek_unicode['nu']))
2418         else:
2419             pform = prettyForm(*pform.left('nu'))
2420         return pform
2421 
2422     def _print_primeomega(self, e):
2423         pform = self._print(e.args[0])
2424         pform = prettyForm(*pform.parens())
2425         if self._use_unicode:
2426             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2427         else:
2428             pform = prettyForm(*pform.left('Omega'))
2429         return pform
2430 
2431     def _print_Quantity(self, e):
2432         if e.name.name == 'degree':
2433             pform = self._print(u"\N{DEGREE SIGN}")
2434             return pform
2435         else:
2436             return self.emptyPrinter(e)
2437 
2438     def _print_AssignmentBase(self, e):
2439 
2440         op = prettyForm(' ' + xsym(e.op) + ' ')
2441 
2442         l = self._print(e.lhs)
2443         r = self._print(e.rhs)
2444         pform = prettyForm(*stringPict.next(l, op, r))
2445         return pform

</code><intended_behavior>A new method should be added to the PrettyPrinter class specifically for handling the lerchphi function. This method should check for instances of the lerchphi function within the expressions being pretty-printed and format them into a readable, aesthetically pleasing ASCII art form. The method should capture and accurately represent the mathematical functionality of lerchphi, incorporating appropriate formatting rules to ensure that the pretty-printed output is both interpretable and consistent with SymPy's pretty printing standards for special functions. This task involves identifying the parameters of lerchphi and deciding on their representation in the output. The mechanism for identifying lerchphi functions within expressions and formatting them needs to be integrated seamlessly with the existing pretty printing processes, ensuring that it does not interfere with the rendering of other expressions or symbols that may be part of the input.</intended_behavior>]
2025-10-15 13:56:32.125 | INFO     | Search completed. Bug locations: [<file>sympy/printing/pretty/pretty.py</file>
<class>PrettyPrinter</class>
<method>None</method>
<code>
32 class PrettyPrinter(Printer):
33     """Printer, which converts an expression into 2D ASCII-art figure."""
34     printmethod = "_pretty"
35 
36     _default_settings = {
37         "order": None,
38         "full_prec": "auto",
39         "use_unicode": None,
40         "wrap_line": True,
41         "num_columns": None,
42         "use_unicode_sqrt_char": True,
43         "root_notation": True,
44         "imaginary_unit": "i",
45     }
46 
47     def __init__(self, settings=None):
48         Printer.__init__(self, settings)
49 
50         if not isinstance(self._settings['imaginary_unit'], string_types):
51             raise TypeError("'imaginary_unit' must a string, not {}".format(self._settings['imaginary_unit']))
52         elif self._settings['imaginary_unit'] not in ["i", "j"]:
53             raise ValueError("'imaginary_unit' must be either 'i' or 'j', not '{}'".format(self._settings['imaginary_unit']))
54         self.emptyPrinter = lambda x: prettyForm(xstr(x))
55 
56     @property
57     def _use_unicode(self):
58         if self._settings['use_unicode']:
59             return True
60         else:
61             return pretty_use_unicode()
62 
63     def doprint(self, expr):
64         return self._print(expr).render(**self._settings)
65 
66     # empty op so _print(stringPict) returns the same
67     def _print_stringPict(self, e):
68         return e
69 
70     def _print_basestring(self, e):
71         return prettyForm(e)
72 
73     def _print_atan2(self, e):
74         pform = prettyForm(*self._print_seq(e.args).parens())
75         pform = prettyForm(*pform.left('atan2'))
76         return pform
77 
78     def _print_Symbol(self, e):
79         symb = pretty_symbol(e.name)
80         return prettyForm(symb)
81     _print_RandomSymbol = _print_Symbol
82 
83     def _print_Float(self, e):
84         # we will use StrPrinter's Float printer, but we need to handle the
85         # full_prec ourselves, according to the self._print_level
86         full_prec = self._settings["full_prec"]
87         if full_prec == "auto":
88             full_prec = self._print_level == 1
89         return prettyForm(sstr(e, full_prec=full_prec))
90 
91     def _print_Cross(self, e):
92         vec1 = e._expr1
93         vec2 = e._expr2
94         pform = self._print(vec2)
95         pform = prettyForm(*pform.left('('))
96         pform = prettyForm(*pform.right(')'))
97         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
98         pform = prettyForm(*pform.left(')'))
99         pform = prettyForm(*pform.left(self._print(vec1)))
100         pform = prettyForm(*pform.left('('))
101         return pform
102 
103     def _print_Curl(self, e):
104         vec = e._expr
105         pform = self._print(vec)
106         pform = prettyForm(*pform.left('('))
107         pform = prettyForm(*pform.right(')'))
108         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
109         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
110         return pform
111 
112     def _print_Divergence(self, e):
113         vec = e._expr
114         pform = self._print(vec)
115         pform = prettyForm(*pform.left('('))
116         pform = prettyForm(*pform.right(')'))
117         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
118         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
119         return pform
120 
121     def _print_Dot(self, e):
122         vec1 = e._expr1
123         vec2 = e._expr2
124         pform = self._print(vec2)
125         pform = prettyForm(*pform.left('('))
126         pform = prettyForm(*pform.right(')'))
127         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
128         pform = prettyForm(*pform.left(')'))
129         pform = prettyForm(*pform.left(self._print(vec1)))
130         pform = prettyForm(*pform.left('('))
131         return pform
132 
133     def _print_Gradient(self, e):
134         func = e._expr
135         pform = self._print(func)
136         pform = prettyForm(*pform.left('('))
137         pform = prettyForm(*pform.right(')'))
138         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
139         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
140         return pform
141 
142     def _print_Atom(self, e):
143         try:
144             # print atoms like Exp1 or Pi
145             return prettyForm(pretty_atom(e.__class__.__name__, printer=self))
146         except KeyError:
147             return self.emptyPrinter(e)
148 
149     # Infinity inherits from Number, so we have to override _print_XXX order
150     _print_Infinity = _print_Atom
151     _print_NegativeInfinity = _print_Atom
152     _print_EmptySet = _print_Atom
153     _print_Naturals = _print_Atom
154     _print_Naturals0 = _print_Atom
155     _print_Integers = _print_Atom
156     _print_Complexes = _print_Atom
157 
158     def _print_Reals(self, e):
159         if self._use_unicode:
160             return self._print_Atom(e)
161         else:
162             inf_list = ['-oo', 'oo']
163             return self._print_seq(inf_list, '(', ')')
164 
165     def _print_subfactorial(self, e):
166         x = e.args[0]
167         pform = self._print(x)
168         # Add parentheses if needed
169         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
170             pform = prettyForm(*pform.parens())
171         pform = prettyForm(*pform.left('!'))
172         return pform
173 
174     def _print_factorial(self, e):
175         x = e.args[0]
176         pform = self._print(x)
177         # Add parentheses if needed
178         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
179             pform = prettyForm(*pform.parens())
180         pform = prettyForm(*pform.right('!'))
181         return pform
182 
183     def _print_factorial2(self, e):
184         x = e.args[0]
185         pform = self._print(x)
186         # Add parentheses if needed
187         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
188             pform = prettyForm(*pform.parens())
189         pform = prettyForm(*pform.right('!!'))
190         return pform
191 
192     def _print_binomial(self, e):
193         n, k = e.args
194 
195         n_pform = self._print(n)
196         k_pform = self._print(k)
197 
198         bar = ' '*max(n_pform.width(), k_pform.width())
199 
200         pform = prettyForm(*k_pform.above(bar))
201         pform = prettyForm(*pform.above(n_pform))
202         pform = prettyForm(*pform.parens('(', ')'))
203 
204         pform.baseline = (pform.baseline + 1)//2
205 
206         return pform
207 
208     def _print_Relational(self, e):
209         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
210 
211         l = self._print(e.lhs)
212         r = self._print(e.rhs)
213         pform = prettyForm(*stringPict.next(l, op, r))
214         return pform
215 
216     def _print_Not(self, e):
217         from sympy import Equivalent, Implies
218         if self._use_unicode:
219             arg = e.args[0]
220             pform = self._print(arg)
221             if isinstance(arg, Equivalent):
222                 return self._print_Equivalent(arg, altchar=u"\N{LEFT RIGHT DOUBLE ARROW WITH STROKE}")
223             if isinstance(arg, Implies):
224                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
225 
226             if arg.is_Boolean and not arg.is_Not:
227                 pform = prettyForm(*pform.parens())
228 
229             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
230         else:
231             return self._print_Function(e)
232 
233     def __print_Boolean(self, e, char, sort=True):
234         args = e.args
235         if sort:
236             args = sorted(e.args, key=default_sort_key)
237         arg = args[0]
238         pform = self._print(arg)
239 
240         if arg.is_Boolean and not arg.is_Not:
241             pform = prettyForm(*pform.parens())
242 
243         for arg in args[1:]:
244             pform_arg = self._print(arg)
245 
246             if arg.is_Boolean and not arg.is_Not:
247                 pform_arg = prettyForm(*pform_arg.parens())
248 
249             pform = prettyForm(*pform.right(u' %s ' % char))
250             pform = prettyForm(*pform.right(pform_arg))
251 
252         return pform
253 
254     def _print_And(self, e):
255         if self._use_unicode:
256             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
257         else:
258             return self._print_Function(e, sort=True)
259 
260     def _print_Or(self, e):
261         if self._use_unicode:
262             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
263         else:
264             return self._print_Function(e, sort=True)
265 
266     def _print_Xor(self, e):
267         if self._use_unicode:
268             return self.__print_Boolean(e, u"\N{XOR}")
269         else:
270             return self._print_Function(e, sort=True)
271 
272     def _print_Nand(self, e):
273         if self._use_unicode:
274             return self.__print_Boolean(e, u"\N{NAND}")
275         else:
276             return self._print_Function(e, sort=True)
277 
278     def _print_Nor(self, e):
279         if self._use_unicode:
280             return self.__print_Boolean(e, u"\N{NOR}")
281         else:
282             return self._print_Function(e, sort=True)
283 
284     def _print_Implies(self, e, altchar=None):
285         if self._use_unicode:
286             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
287         else:
288             return self._print_Function(e)
289 
290     def _print_Equivalent(self, e, altchar=None):
291         if self._use_unicode:
292             return self.__print_Boolean(e, altchar or u"\N{LEFT RIGHT DOUBLE ARROW}")
293         else:
294             return self._print_Function(e, sort=True)
295 
296     def _print_conjugate(self, e):
297         pform = self._print(e.args[0])
298         return prettyForm( *pform.above( hobj('_', pform.width())) )
299 
300     def _print_Abs(self, e):
301         pform = self._print(e.args[0])
302         pform = prettyForm(*pform.parens('|', '|'))
303         return pform
304     _print_Determinant = _print_Abs
305 
306     def _print_floor(self, e):
307         if self._use_unicode:
308             pform = self._print(e.args[0])
309             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
310             return pform
311         else:
312             return self._print_Function(e)
313 
314     def _print_ceiling(self, e):
315         if self._use_unicode:
316             pform = self._print(e.args[0])
317             pform = prettyForm(*pform.parens('lceil', 'rceil'))
318             return pform
319         else:
320             return self._print_Function(e)
321 
322     def _print_Derivative(self, deriv):
323         if requires_partial(deriv) and self._use_unicode:
324             deriv_symbol = U('PARTIAL DIFFERENTIAL')
325         else:
326             deriv_symbol = r'd'
327         x = None
328         count_total_deriv = 0
329 
330         for sym, num in reversed(deriv.variable_count):
331             s = self._print(sym)
332             ds = prettyForm(*s.left(deriv_symbol))
333             count_total_deriv += num
334 
335             if (not num.is_Integer) or (num > 1):
336                 ds = ds**prettyForm(str(num))
337 
338             if x is None:
339                 x = ds
340             else:
341                 x = prettyForm(*x.right(' '))
342                 x = prettyForm(*x.right(ds))
343 
344         f = prettyForm(
345             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
346 
347         pform = prettyForm(deriv_symbol)
348 
349         if (count_total_deriv > 1) != False:
350             pform = pform**prettyForm(str(count_total_deriv))
351 
352         pform = prettyForm(*pform.below(stringPict.LINE, x))
353         pform.baseline = pform.baseline + 1
354         pform = prettyForm(*stringPict.next(pform, f))
355         pform.binding = prettyForm.MUL
356 
357         return pform
358 
359     def _print_Cycle(self, dc):
360         from sympy.combinatorics.permutations import Permutation, Cycle
361         # for Empty Cycle
362         if dc == Cycle():
363             cyc = stringPict('')
364             return prettyForm(*cyc.parens())
365 
366         dc_list = Permutation(dc.list()).cyclic_form
367         # for Identity Cycle
368         if dc_list == []:
369             cyc = self._print(dc.size - 1)
370             return prettyForm(*cyc.parens())
371 
372         cyc = stringPict('')
373         for i in dc_list:
374             l = self._print(str(tuple(i)).replace(',', ''))
375             cyc = prettyForm(*cyc.right(l))
376         return cyc
377 
378     def _print_PDF(self, pdf):
379         lim = self._print(pdf.pdf.args[0])
380         lim = prettyForm(*lim.right(', '))
381         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
382         lim = prettyForm(*lim.right(', '))
383         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
384         lim = prettyForm(*lim.parens())
385 
386         f = self._print(pdf.pdf.args[1])
387         f = prettyForm(*f.right(', '))
388         f = prettyForm(*f.right(lim))
389         f = prettyForm(*f.parens())
390 
391         pform = prettyForm('PDF')
392         pform = prettyForm(*pform.right(f))
393         return pform
394 
395     def _print_Integral(self, integral):
396         f = integral.function
397 
398         # Add parentheses if arg involves addition of terms and
399         # create a pretty form for the argument
400         prettyF = self._print(f)
401         # XXX generalize parens
402         if f.is_Add:
403             prettyF = prettyForm(*prettyF.parens())
404 
405         # dx dy dz ...
406         arg = prettyF
407         for x in integral.limits:
408             prettyArg = self._print(x[0])
409             # XXX qparens (parens if needs-parens)
410             if prettyArg.width() > 1:
411                 prettyArg = prettyForm(*prettyArg.parens())
412 
413             arg = prettyForm(*arg.right(' d', prettyArg))
414 
415         # \int \int \int ...
416         firstterm = True
417         s = None
418         for lim in integral.limits:
419             x = lim[0]
420             # Create bar based on the height of the argument
421             h = arg.height()
422             H = h + 2
423 
424             # XXX hack!
425             ascii_mode = not self._use_unicode
426             if ascii_mode:
427                 H += 2
428 
429             vint = vobj('int', H)
430 
431             # Construct the pretty form with the integral sign and the argument
432             pform = prettyForm(vint)
433             pform.baseline = arg.baseline + (
434                 H - h)//2    # covering the whole argument
435 
436             if len(lim) > 1:
437                 # Create pretty forms for endpoints, if definite integral.
438                 # Do not print empty endpoints.
439                 if len(lim) == 2:
440                     prettyA = prettyForm("")
441                     prettyB = self._print(lim[1])
442                 if len(lim) == 3:
443                     prettyA = self._print(lim[1])
444                     prettyB = self._print(lim[2])
445 
446                 if ascii_mode:  # XXX hack
447                     # Add spacing so that endpoint can more easily be
448                     # identified with the correct integral sign
449                     spc = max(1, 3 - prettyB.width())
450                     prettyB = prettyForm(*prettyB.left(' ' * spc))
451 
452                     spc = max(1, 4 - prettyA.width())
453                     prettyA = prettyForm(*prettyA.right(' ' * spc))
454 
455                 pform = prettyForm(*pform.above(prettyB))
456                 pform = prettyForm(*pform.below(prettyA))
457 
458             if not ascii_mode:  # XXX hack
459                 pform = prettyForm(*pform.right(' '))
460 
461             if firstterm:
462                 s = pform   # first term
463                 firstterm = False
464             else:
465                 s = prettyForm(*s.left(pform))
466 
467         pform = prettyForm(*arg.left(s))
468         pform.binding = prettyForm.MUL
469         return pform
470 
471     def _print_Product(self, expr):
472         func = expr.term
473         pretty_func = self._print(func)
474 
475         horizontal_chr = xobj('_', 1)
476         corner_chr = xobj('_', 1)
477         vertical_chr = xobj('|', 1)
478 
479         if self._use_unicode:
480             # use unicode corners
481             horizontal_chr = xobj('-', 1)
482             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
483 
484         func_height = pretty_func.height()
485 
486         first = True
487         max_upper = 0
488         sign_height = 0
489 
490         for lim in expr.limits:
491             width = (func_height + 2) * 5 // 3 - 2
492             sign_lines = []
493             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
494             for i in range(func_height + 1):
495                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
496 
497             pretty_sign = stringPict('')
498             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
499 
500             pretty_upper = self._print(lim[2])
501             pretty_lower = self._print(Equality(lim[0], lim[1]))
502 
503             max_upper = max(max_upper, pretty_upper.height())
504 
505             if first:
506                 sign_height = pretty_sign.height()
507 
508             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
509             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
510 
511             if first:
512                 pretty_func.baseline = 0
513                 first = False
514 
515             height = pretty_sign.height()
516             padding = stringPict('')
517             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
518             pretty_sign = prettyForm(*pretty_sign.right(padding))
519 
520             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
521 
522         pretty_func.baseline = max_upper + sign_height//2
523         pretty_func.binding = prettyForm.MUL
524         return pretty_func
525 
526     def _print_Sum(self, expr):
527         ascii_mode = not self._use_unicode
528 
529         def asum(hrequired, lower, upper, use_ascii):
530             def adjust(s, wid=None, how='<^>'):
531                 if not wid or len(s) > wid:
532                     return s
533                 need = wid - len(s)
534                 if how == '<^>' or how == "<" or how not in list('<^>'):
535                     return s + ' '*need
536                 half = need//2
537                 lead = ' '*half
538                 if how == ">":
539                     return " "*need + s
540                 return lead + s + ' '*(need - len(lead))
541 
542             h = max(hrequired, 2)
543             d = h//2
544             w = d + 1
545             more = hrequired % 2
546 
547             lines = []
548             if use_ascii:
549                 lines.append("_"*(w) + ' ')
550                 lines.append(r"\%s`" % (' '*(w - 1)))
551                 for i in range(1, d):
552                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
553                 if more:
554                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
555                 for i in reversed(range(1, d)):
556                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
557                 lines.append("/" + "_"*(w - 1) + ',')
558                 return d, h + more, lines, 0
559             else:
560                 w = w + more
561                 d = d + more
562                 vsum = vobj('sum', 4)
563                 lines.append("_"*(w))
564                 for i in range(0, d):
565                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
566                 for i in reversed(range(0, d)):
567                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
568                 lines.append(vsum[8]*(w))
569                 return d, h + 2*more, lines, more
570 
571         f = expr.function
572 
573         prettyF = self._print(f)
574 
575         if f.is_Add:  # add parens
576             prettyF = prettyForm(*prettyF.parens())
577 
578         H = prettyF.height() + 2
579 
580         # \sum \sum \sum ...
581         first = True
582         max_upper = 0
583         sign_height = 0
584 
585         for lim in expr.limits:
586             if len(lim) == 3:
587                 prettyUpper = self._print(lim[2])
588                 prettyLower = self._print(Equality(lim[0], lim[1]))
589             elif len(lim) == 2:
590                 prettyUpper = self._print("")
591                 prettyLower = self._print(Equality(lim[0], lim[1]))
592             elif len(lim) == 1:
593                 prettyUpper = self._print("")
594                 prettyLower = self._print(lim[0])
595 
596             max_upper = max(max_upper, prettyUpper.height())
597 
598             # Create sum sign based on the height of the argument
599             d, h, slines, adjustment = asum(
600                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
601             prettySign = stringPict('')
602             prettySign = prettyForm(*prettySign.stack(*slines))
603 
604             if first:
605                 sign_height = prettySign.height()
606 
607             prettySign = prettyForm(*prettySign.above(prettyUpper))
608             prettySign = prettyForm(*prettySign.below(prettyLower))
609 
610             if first:
611                 # change F baseline so it centers on the sign
612                 prettyF.baseline -= d - (prettyF.height()//2 -
613                                          prettyF.baseline) - adjustment
614                 first = False
615 
616             # put padding to the right
617             pad = stringPict('')
618             pad = prettyForm(*pad.stack(*[' ']*h))
619             prettySign = prettyForm(*prettySign.right(pad))
620             # put the present prettyF to the right
621             prettyF = prettyForm(*prettySign.right(prettyF))
622 
623         prettyF.baseline = max_upper + sign_height//2
624         prettyF.binding = prettyForm.MUL
625         return prettyF
626 
627     def _print_Limit(self, l):
628         e, z, z0, dir = l.args
629 
630         E = self._print(e)
631         if precedence(e) <= PRECEDENCE["Mul"]:
632             E = prettyForm(*E.parens('(', ')'))
633         Lim = prettyForm('lim')
634 
635         LimArg = self._print(z)
636         if self._use_unicode:
637             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
638         else:
639             LimArg = prettyForm(*LimArg.right('->'))
640         LimArg = prettyForm(*LimArg.right(self._print(z0)))
641 
642         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
643             dir = ""
644         else:
645             if self._use_unicode:
646                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
647 
648         LimArg = prettyForm(*LimArg.right(self._print(dir)))
649 
650         Lim = prettyForm(*Lim.below(LimArg))
651         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
652 
653         return Lim
654 
655     def _print_matrix_contents(self, e):
656         """
657         This method factors out what is essentially grid printing.
658         """
659         M = e   # matrix
660         Ms = {}  # i,j -> pretty(M[i,j])
661         for i in range(M.rows):
662             for j in range(M.cols):
663                 Ms[i, j] = self._print(M[i, j])
664 
665         # h- and v- spacers
666         hsep = 2
667         vsep = 1
668 
669         # max width for columns
670         maxw = [-1] * M.cols
671 
672         for j in range(M.cols):
673             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
674 
675         # drawing result
676         D = None
677 
678         for i in range(M.rows):
679 
680             D_row = None
681             for j in range(M.cols):
682                 s = Ms[i, j]
683 
684                 # reshape s to maxw
685                 # XXX this should be generalized, and go to stringPict.reshape ?
686                 assert s.width() <= maxw[j]
687 
688                 # hcenter it, +0.5 to the right                        2
689                 # ( it's better to align formula starts for say 0 and r )
690                 # XXX this is not good in all cases -- maybe introduce vbaseline?
691                 wdelta = maxw[j] - s.width()
692                 wleft = wdelta // 2
693                 wright = wdelta - wleft
694 
695                 s = prettyForm(*s.right(' '*wright))
696                 s = prettyForm(*s.left(' '*wleft))
697 
698                 # we don't need vcenter cells -- this is automatically done in
699                 # a pretty way because when their baselines are taking into
700                 # account in .right()
701 
702                 if D_row is None:
703                     D_row = s   # first box in a row
704                     continue
705 
706                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
707                 D_row = prettyForm(*D_row.right(s))
708 
709             if D is None:
710                 D = D_row       # first row in a picture
711                 continue
712 
713             # v-spacer
714             for _ in range(vsep):
715                 D = prettyForm(*D.below(' '))
716 
717             D = prettyForm(*D.below(D_row))
718 
719         if D is None:
720             D = prettyForm('')  # Empty Matrix
721 
722         return D
723 
724     def _print_MatrixBase(self, e):
725         D = self._print_matrix_contents(e)
726         D.baseline = D.height()//2
727         D = prettyForm(*D.parens('[', ']'))
728         return D
729     _print_ImmutableMatrix = _print_MatrixBase
730     _print_Matrix = _print_MatrixBase
731 
732     def _print_TensorProduct(self, expr):
733         # This should somehow share the code with _print_WedgeProduct:
734         circled_times = "\u2297"
735         return self._print_seq(expr.args, None, None, circled_times,
736             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
737 
738     def _print_WedgeProduct(self, expr):
739         # This should somehow share the code with _print_TensorProduct:
740         wedge_symbol = u"\u2227"
741         return self._print_seq(expr.args, None, None, wedge_symbol,
742             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
743 
744     def _print_Trace(self, e):
745         D = self._print(e.arg)
746         D = prettyForm(*D.parens('(',')'))
747         D.baseline = D.height()//2
748         D = prettyForm(*D.left('\n'*(0) + 'tr'))
749         return D
750 
751 
752     def _print_MatrixElement(self, expr):
753         from sympy.matrices import MatrixSymbol
754         from sympy import Symbol
755         if (isinstance(expr.parent, MatrixSymbol)
756                 and expr.i.is_number and expr.j.is_number):
757             return self._print(
758                     Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))
759         else:
760             prettyFunc = self._print(expr.parent)
761             prettyFunc = prettyForm(*prettyFunc.parens())
762             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
763                     ).parens(left='[', right=']')[0]
764             pform = prettyForm(binding=prettyForm.FUNC,
765                     *stringPict.next(prettyFunc, prettyIndices))
766 
767             # store pform parts so it can be reassembled e.g. when powered
768             pform.prettyFunc = prettyFunc
769             pform.prettyArgs = prettyIndices
770 
771             return pform
772 
773 
774     def _print_MatrixSlice(self, m):
775         # XXX works only for applied functions
776         prettyFunc = self._print(m.parent)
777         def ppslice(x):
778             x = list(x)
779             if x[2] == 1:
780                 del x[2]
781             if x[1] == x[0] + 1:
782                 del x[1]
783             if x[0] == 0:
784                 x[0] = ''
785             return prettyForm(*self._print_seq(x, delimiter=':'))
786         prettyArgs = self._print_seq((ppslice(m.rowslice),
787             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
788 
789         pform = prettyForm(
790             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
791 
792         # store pform parts so it can be reassembled e.g. when powered
793         pform.prettyFunc = prettyFunc
794         pform.prettyArgs = prettyArgs
795 
796         return pform
797 
798     def _print_Transpose(self, expr):
799         pform = self._print(expr.arg)
800         from sympy.matrices import MatrixSymbol
801         if not isinstance(expr.arg, MatrixSymbol):
802             pform = prettyForm(*pform.parens())
803         pform = pform**(prettyForm('T'))
804         return pform
805 
806     def _print_Adjoint(self, expr):
807         pform = self._print(expr.arg)
808         if self._use_unicode:
809             dag = prettyForm(u'\N{DAGGER}')
810         else:
811             dag = prettyForm('+')
812         from sympy.matrices import MatrixSymbol
813         if not isinstance(expr.arg, MatrixSymbol):
814             pform = prettyForm(*pform.parens())
815         pform = pform**dag
816         return pform
817 
818     def _print_BlockMatrix(self, B):
819         if B.blocks.shape == (1, 1):
820             return self._print(B.blocks[0, 0])
821         return self._print(B.blocks)
822 
823     def _print_MatAdd(self, expr):
824         s = None
825         for item in expr.args:
826             pform = self._print(item)
827             if s is None:
828                 s = pform     # First element
829             else:
830                 coeff = item.as_coeff_mmul()[0]
831                 if _coeff_isneg(S(coeff)):
832                     s = prettyForm(*stringPict.next(s, ' '))
833                     pform = self._print(item)
834                 else:
835                     s = prettyForm(*stringPict.next(s, ' + '))
836                 s = prettyForm(*stringPict.next(s, pform))
837 
838         return s
839 
840     def _print_MatMul(self, expr):
841         args = list(expr.args)
842         from sympy import Add, MatAdd, HadamardProduct, KroneckerProduct
843         for i, a in enumerate(args):
844             if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))
845                     and len(expr.args) > 1):
846                 args[i] = prettyForm(*self._print(a).parens())
847             else:
848                 args[i] = self._print(a)
849 
850         return prettyForm.__mul__(*args)
851 
852     def _print_DotProduct(self, expr):
853         args = list(expr.args)
854 
855         for i, a in enumerate(args):
856             args[i] = self._print(a)
857         return prettyForm.__mul__(*args)
858 
859     def _print_MatPow(self, expr):
860         pform = self._print(expr.base)
861         from sympy.matrices import MatrixSymbol
862         if not isinstance(expr.base, MatrixSymbol):
863             pform = prettyForm(*pform.parens())
864         pform = pform**(self._print(expr.exp))
865         return pform
866 
867     def _print_HadamardProduct(self, expr):
868         from sympy import MatAdd, MatMul
869         if self._use_unicode:
870             delim = pretty_atom('Ring')
871         else:
872             delim = '.*'
873         return self._print_seq(expr.args, None, None, delim,
874                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
875 
876     def _print_KroneckerProduct(self, expr):
877         from sympy import MatAdd, MatMul
878         if self._use_unicode:
879             delim = u' \N{N-ARY CIRCLED TIMES OPERATOR} '
880         else:
881             delim = ' x '
882         return self._print_seq(expr.args, None, None, delim,
883                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
884 
885     _print_MatrixSymbol = _print_Symbol
886 
887     def _print_FunctionMatrix(self, X):
888         D = self._print(X.lamda.expr)
889         D = prettyForm(*D.parens('[', ']'))
890         return D
891 
892     def _print_BasisDependent(self, expr):
893         from sympy.vector import Vector
894 
895         if not self._use_unicode:
896             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
897 
898         if expr == expr.zero:
899             return prettyForm(expr.zero._pretty_form)
900         o1 = []
901         vectstrs = []
902         if isinstance(expr, Vector):
903             items = expr.separate().items()
904         else:
905             items = [(0, expr)]
906         for system, vect in items:
907             inneritems = list(vect.components.items())
908             inneritems.sort(key = lambda x: x[0].__str__())
909             for k, v in inneritems:
910                 #if the coef of the basis vector is 1
911                 #we skip the 1
912                 if v == 1:
913                     o1.append(u"" +
914                               k._pretty_form)
915                 #Same for -1
916                 elif v == -1:
917                     o1.append(u"(-1) " +
918                               k._pretty_form)
919                 #For a general expr
920                 else:
921                     #We always wrap the measure numbers in
922                     #parentheses
923                     arg_str = self._print(
924                         v).parens()[0]
925 
926                     o1.append(arg_str + ' ' + k._pretty_form)
927                 vectstrs.append(k._pretty_form)
928 
929         #outstr = u("").join(o1)
930         if o1[0].startswith(u" + "):
931             o1[0] = o1[0][3:]
932         elif o1[0].startswith(" "):
933             o1[0] = o1[0][1:]
934         #Fixing the newlines
935         lengths = []
936         strs = ['']
937         flag = []
938         for i, partstr in enumerate(o1):
939             flag.append(0)
940             # XXX: What is this hack?
941             if '\n' in partstr:
942                 tempstr = partstr
943                 tempstr = tempstr.replace(vectstrs[i], '')
944                 if u'\N{right parenthesis extension}' in tempstr:   # If scalar is a fraction
945                     for paren in range(len(tempstr)):
946                         flag[i] = 1
947                         if tempstr[paren] == u'\N{right parenthesis extension}':
948                             tempstr = tempstr[:paren] + u'\N{right parenthesis extension}'\
949                                          + ' '  + vectstrs[i] + tempstr[paren + 1:]
950                             break
951                 elif u'\N{RIGHT PARENTHESIS LOWER HOOK}' in tempstr:
952                     flag[i] = 1
953                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS LOWER HOOK}',
954                                         u'\N{RIGHT PARENTHESIS LOWER HOOK}'
955                                         + ' ' + vectstrs[i])
956                 else:
957                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
958                                         u'\N{RIGHT PARENTHESIS UPPER HOOK}'
959                                         + ' ' + vectstrs[i])
960                 o1[i] = tempstr
961 
962         o1 = [x.split('\n') for x in o1]
963         n_newlines = max([len(x) for x in o1])  # Width of part in its pretty form
964 
965         if 1 in flag:                           # If there was a fractional scalar
966             for i, parts in enumerate(o1):
967                 if len(parts) == 1:             # If part has no newline
968                     parts.insert(0, ' ' * (len(parts[0])))
969                     flag[i] = 1
970 
971         for i, parts in enumerate(o1):
972             lengths.append(len(parts[flag[i]]))
973             for j in range(n_newlines):
974                 if j+1 <= len(parts):
975                     if j >= len(strs):
976                         strs.append(' ' * (sum(lengths[:-1]) +
977                                            3*(len(lengths)-1)))
978                     if j == flag[i]:
979                         strs[flag[i]] += parts[flag[i]] + ' + '
980                     else:
981                         strs[j] += parts[j] + ' '*(lengths[-1] -
982                                                    len(parts[j])+
983                                                    3)
984                 else:
985                     if j >= len(strs):
986                         strs.append(' ' * (sum(lengths[:-1]) +
987                                            3*(len(lengths)-1)))
988                     strs[j] += ' '*(lengths[-1]+3)
989 
990         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
991 
992     def _print_NDimArray(self, expr):
993         from sympy import ImmutableMatrix
994 
995         if expr.rank() == 0:
996             return self._print(expr[()])
997 
998         level_str = [[]] + [[] for i in range(expr.rank())]
999         shape_ranges = [list(range(i)) for i in expr.shape]
1000         for outer_i in itertools.product(*shape_ranges):
1001             level_str[-1].append(expr[outer_i])
1002             even = True
1003             for back_outer_i in range(expr.rank()-1, -1, -1):
1004                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1005                     break
1006                 if even:
1007                     level_str[back_outer_i].append(level_str[back_outer_i+1])
1008                 else:
1009                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
1010                     if len(level_str[back_outer_i + 1]) == 1:
1011                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
1012                 even = not even
1013                 level_str[back_outer_i+1] = []
1014 
1015         out_expr = level_str[0][0]
1016         if expr.rank() % 2 == 1:
1017             out_expr = ImmutableMatrix([out_expr])
1018 
1019         return self._print(out_expr)
1020 
1021     _print_ImmutableDenseNDimArray = _print_NDimArray
1022     _print_ImmutableSparseNDimArray = _print_NDimArray
1023     _print_MutableDenseNDimArray = _print_NDimArray
1024     _print_MutableSparseNDimArray = _print_NDimArray
1025 
1026     def _printer_tensor_indices(self, name, indices, index_map={}):
1027         center = stringPict(name)
1028         top = stringPict(" "*center.width())
1029         bot = stringPict(" "*center.width())
1030 
1031         last_valence = None
1032         prev_map = None
1033 
1034         for i, index in enumerate(indices):
1035             indpic = self._print(index.args[0])
1036             if ((index in index_map) or prev_map) and last_valence == index.is_up:
1037                 if index.is_up:
1038                     top = prettyForm(*stringPict.next(top, ","))
1039                 else:
1040                     bot = prettyForm(*stringPict.next(bot, ","))
1041             if index in index_map:
1042                 indpic = prettyForm(*stringPict.next(indpic, "="))
1043                 indpic = prettyForm(*stringPict.next(indpic, self._print(index_map[index])))
1044                 prev_map = True
1045             else:
1046                 prev_map = False
1047             if index.is_up:
1048                 top = stringPict(*top.right(indpic))
1049                 center = stringPict(*center.right(" "*indpic.width()))
1050                 bot = stringPict(*bot.right(" "*indpic.width()))
1051             else:
1052                 bot = stringPict(*bot.right(indpic))
1053                 center = stringPict(*center.right(" "*indpic.width()))
1054                 top = stringPict(*top.right(" "*indpic.width()))
1055             last_valence = index.is_up
1056 
1057         pict = prettyForm(*center.above(top))
1058         pict = prettyForm(*pict.below(bot))
1059         return pict
1060 
1061     def _print_Tensor(self, expr):
1062         name = expr.args[0].name
1063         indices = expr.get_indices()
1064         return self._printer_tensor_indices(name, indices)
1065 
1066     def _print_TensorElement(self, expr):
1067         name = expr.expr.args[0].name
1068         indices = expr.expr.get_indices()
1069         index_map = expr.index_map
1070         return self._printer_tensor_indices(name, indices, index_map)
1071 
1072     def _print_TensMul(self, expr):
1073         sign, args = expr._get_args_for_traditional_printer()
1074         args = [
1075             prettyForm(*self._print(i).parens()) if
1076             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1077             for i in args
1078         ]
1079         pform = prettyForm.__mul__(*args)
1080         if sign:
1081             return prettyForm(*pform.left(sign))
1082         else:
1083             return pform
1084 
1085     def _print_TensAdd(self, expr):
1086         args = [
1087             prettyForm(*self._print(i).parens()) if
1088             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1089             for i in expr.args
1090         ]
1091         return prettyForm.__add__(*args)
1092 
1093     def _print_TensorIndex(self, expr):
1094         sym = expr.args[0]
1095         if not expr.is_up:
1096             sym = -sym
1097         return self._print(sym)
1098 
1099     def _print_PartialDerivative(self, deriv):
1100         if self._use_unicode:
1101             deriv_symbol = U('PARTIAL DIFFERENTIAL')
1102         else:
1103             deriv_symbol = r'd'
1104         x = None
1105 
1106         for variable in reversed(deriv.variables):
1107             s = self._print(variable)
1108             ds = prettyForm(*s.left(deriv_symbol))
1109 
1110             if x is None:
1111                 x = ds
1112             else:
1113                 x = prettyForm(*x.right(' '))
1114                 x = prettyForm(*x.right(ds))
1115 
1116         f = prettyForm(
1117             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
1118 
1119         pform = prettyForm(deriv_symbol)
1120 
1121         pform = prettyForm(*pform.below(stringPict.LINE, x))
1122         pform.baseline = pform.baseline + 1
1123         pform = prettyForm(*stringPict.next(pform, f))
1124         pform.binding = prettyForm.MUL
1125 
1126         return pform
1127 
1128     def _print_Piecewise(self, pexpr):
1129 
1130         P = {}
1131         for n, ec in enumerate(pexpr.args):
1132             P[n, 0] = self._print(ec.expr)
1133             if ec.cond == True:
1134                 P[n, 1] = prettyForm('otherwise')
1135             else:
1136                 P[n, 1] = prettyForm(
1137                     *prettyForm('for ').right(self._print(ec.cond)))
1138         hsep = 2
1139         vsep = 1
1140         len_args = len(pexpr.args)
1141 
1142         # max widths
1143         maxw = [max([P[i, j].width() for i in range(len_args)])
1144                 for j in range(2)]
1145 
1146         # FIXME: Refactor this code and matrix into some tabular environment.
1147         # drawing result
1148         D = None
1149 
1150         for i in range(len_args):
1151             D_row = None
1152             for j in range(2):
1153                 p = P[i, j]
1154                 assert p.width() <= maxw[j]
1155 
1156                 wdelta = maxw[j] - p.width()
1157                 wleft = wdelta // 2
1158                 wright = wdelta - wleft
1159 
1160                 p = prettyForm(*p.right(' '*wright))
1161                 p = prettyForm(*p.left(' '*wleft))
1162 
1163                 if D_row is None:
1164                     D_row = p
1165                     continue
1166 
1167                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
1168                 D_row = prettyForm(*D_row.right(p))
1169             if D is None:
1170                 D = D_row       # first row in a picture
1171                 continue
1172 
1173             # v-spacer
1174             for _ in range(vsep):
1175                 D = prettyForm(*D.below(' '))
1176 
1177             D = prettyForm(*D.below(D_row))
1178 
1179         D = prettyForm(*D.parens('{', ''))
1180         D.baseline = D.height()//2
1181         D.binding = prettyForm.OPEN
1182         return D
1183 
1184     def _print_ITE(self, ite):
1185         from sympy.functions.elementary.piecewise import Piecewise
1186         return self._print(ite.rewrite(Piecewise))
1187 
1188     def _hprint_vec(self, v):
1189         D = None
1190 
1191         for a in v:
1192             p = a
1193             if D is None:
1194                 D = p
1195             else:
1196                 D = prettyForm(*D.right(', '))
1197                 D = prettyForm(*D.right(p))
1198         if D is None:
1199             D = stringPict(' ')
1200 
1201         return D
1202 
1203     def _hprint_vseparator(self, p1, p2):
1204         tmp = prettyForm(*p1.right(p2))
1205         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
1206         return prettyForm(*p1.right(sep, p2))
1207 
1208     def _print_hyper(self, e):
1209         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1210         ap = [self._print(a) for a in e.ap]
1211         bq = [self._print(b) for b in e.bq]
1212 
1213         P = self._print(e.argument)
1214         P.baseline = P.height()//2
1215 
1216         # Drawing result - first create the ap, bq vectors
1217         D = None
1218         for v in [ap, bq]:
1219             D_row = self._hprint_vec(v)
1220             if D is None:
1221                 D = D_row       # first row in a picture
1222             else:
1223                 D = prettyForm(*D.below(' '))
1224                 D = prettyForm(*D.below(D_row))
1225 
1226         # make sure that the argument `z' is centred vertically
1227         D.baseline = D.height()//2
1228 
1229         # insert horizontal separator
1230         P = prettyForm(*P.left(' '))
1231         D = prettyForm(*D.right(' '))
1232 
1233         # insert separating `|`
1234         D = self._hprint_vseparator(D, P)
1235 
1236         # add parens
1237         D = prettyForm(*D.parens('(', ')'))
1238 
1239         # create the F symbol
1240         above = D.height()//2 - 1
1241         below = D.height() - above - 1
1242 
1243         sz, t, b, add, img = annotated('F')
1244         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1245                        baseline=above + sz)
1246         add = (sz + 1)//2
1247 
1248         F = prettyForm(*F.left(self._print(len(e.ap))))
1249         F = prettyForm(*F.right(self._print(len(e.bq))))
1250         F.baseline = above + add
1251 
1252         D = prettyForm(*F.right(' ', D))
1253 
1254         return D
1255 
1256     def _print_meijerg(self, e):
1257         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1258 
1259         v = {}
1260         v[(0, 0)] = [self._print(a) for a in e.an]
1261         v[(0, 1)] = [self._print(a) for a in e.aother]
1262         v[(1, 0)] = [self._print(b) for b in e.bm]
1263         v[(1, 1)] = [self._print(b) for b in e.bother]
1264 
1265         P = self._print(e.argument)
1266         P.baseline = P.height()//2
1267 
1268         vp = {}
1269         for idx in v:
1270             vp[idx] = self._hprint_vec(v[idx])
1271 
1272         for i in range(2):
1273             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1274             for j in range(2):
1275                 s = vp[(j, i)]
1276                 left = (maxw - s.width()) // 2
1277                 right = maxw - left - s.width()
1278                 s = prettyForm(*s.left(' ' * left))
1279                 s = prettyForm(*s.right(' ' * right))
1280                 vp[(j, i)] = s
1281 
1282         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1283         D1 = prettyForm(*D1.below(' '))
1284         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1285         D = prettyForm(*D1.below(D2))
1286 
1287         # make sure that the argument `z' is centred vertically
1288         D.baseline = D.height()//2
1289 
1290         # insert horizontal separator
1291         P = prettyForm(*P.left(' '))
1292         D = prettyForm(*D.right(' '))
1293 
1294         # insert separating `|`
1295         D = self._hprint_vseparator(D, P)
1296 
1297         # add parens
1298         D = prettyForm(*D.parens('(', ')'))
1299 
1300         # create the G symbol
1301         above = D.height()//2 - 1
1302         below = D.height() - above - 1
1303 
1304         sz, t, b, add, img = annotated('G')
1305         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1306                        baseline=above + sz)
1307 
1308         pp = self._print(len(e.ap))
1309         pq = self._print(len(e.bq))
1310         pm = self._print(len(e.bm))
1311         pn = self._print(len(e.an))
1312 
1313         def adjust(p1, p2):
1314             diff = p1.width() - p2.width()
1315             if diff == 0:
1316                 return p1, p2
1317             elif diff > 0:
1318                 return p1, prettyForm(*p2.left(' '*diff))
1319             else:
1320                 return prettyForm(*p1.left(' '*-diff)), p2
1321         pp, pm = adjust(pp, pm)
1322         pq, pn = adjust(pq, pn)
1323         pu = prettyForm(*pm.right(', ', pn))
1324         pl = prettyForm(*pp.right(', ', pq))
1325 
1326         ht = F.baseline - above - 2
1327         if ht > 0:
1328             pu = prettyForm(*pu.below('\n'*ht))
1329         p = prettyForm(*pu.below(pl))
1330 
1331         F.baseline = above
1332         F = prettyForm(*F.right(p))
1333 
1334         F.baseline = above + add
1335 
1336         D = prettyForm(*F.right(' ', D))
1337 
1338         return D
1339 
1340     def _print_ExpBase(self, e):
1341         # TODO should exp_polar be printed differently?
1342         #      what about exp_polar(0), exp_polar(1)?
1343         base = prettyForm(pretty_atom('Exp1', 'e'))
1344         return base ** self._print(e.args[0])
1345 
1346     def _print_Function(self, e, sort=False, func_name=None):
1347         # optional argument func_name for supplying custom names
1348         # XXX works only for applied functions
1349         func = e.func
1350         args = e.args
1351         if sort:
1352             args = sorted(args, key=default_sort_key)
1353 
1354         if not func_name:
1355             func_name = func.__name__
1356 
1357         prettyFunc = self._print(Symbol(func_name))
1358         prettyArgs = prettyForm(*self._print_seq(args).parens())
1359 
1360         pform = prettyForm(
1361             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1362 
1363         # store pform parts so it can be reassembled e.g. when powered
1364         pform.prettyFunc = prettyFunc
1365         pform.prettyArgs = prettyArgs
1366 
1367         return pform
1368 
1369     @property
1370     def _special_function_classes(self):
1371         from sympy.functions.special.tensor_functions import KroneckerDelta
1372         from sympy.functions.special.gamma_functions import gamma, lowergamma
1373         from sympy.functions.special.beta_functions import beta
1374         from sympy.functions.special.delta_functions import DiracDelta
1375         from sympy.functions.special.error_functions import Chi
1376         return {KroneckerDelta: [greek_unicode['delta'], 'delta'],
1377                 gamma: [greek_unicode['Gamma'], 'Gamma'],
1378                 lowergamma: [greek_unicode['gamma'], 'gamma'],
1379                 beta: [greek_unicode['Beta'], 'B'],
1380                 DiracDelta: [greek_unicode['delta'], 'delta'],
1381                 Chi: ['Chi', 'Chi']}
1382 
1383     def _print_FunctionClass(self, expr):
1384         for cls in self._special_function_classes:
1385             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
1386                 if self._use_unicode:
1387                     return prettyForm(self._special_function_classes[cls][0])
1388                 else:
1389                     return prettyForm(self._special_function_classes[cls][1])
1390         func_name = expr.__name__
1391         return prettyForm(pretty_symbol(func_name))
1392 
1393     def _print_GeometryEntity(self, expr):
1394         # GeometryEntity is based on Tuple but should not print like a Tuple
1395         return self.emptyPrinter(expr)
1396 
1397     def _print_Lambda(self, e):
1398         vars, expr = e.args
1399         if self._use_unicode:
1400             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1401         else:
1402             arrow = " -> "
1403         if len(vars) == 1:
1404             var_form = self._print(vars[0])
1405         else:
1406             var_form = self._print(tuple(vars))
1407 
1408         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1409 
1410     def _print_Order(self, expr):
1411         pform = self._print(expr.expr)
1412         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1413            len(expr.variables) > 1:
1414             pform = prettyForm(*pform.right("; "))
1415             if len(expr.variables) > 1:
1416                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1417             elif len(expr.variables):
1418                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1419             if self._use_unicode:
1420                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1421             else:
1422                 pform = prettyForm(*pform.right(" -> "))
1423             if len(expr.point) > 1:
1424                 pform = prettyForm(*pform.right(self._print(expr.point)))
1425             else:
1426                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1427         pform = prettyForm(*pform.parens())
1428         pform = prettyForm(*pform.left("O"))
1429         return pform
1430 
1431     def _print_SingularityFunction(self, e):
1432         if self._use_unicode:
1433             shift = self._print(e.args[0]-e.args[1])
1434             n = self._print(e.args[2])
1435             base = prettyForm("<")
1436             base = prettyForm(*base.right(shift))
1437             base = prettyForm(*base.right(">"))
1438             pform = base**n
1439             return pform
1440         else:
1441             n = self._print(e.args[2])
1442             shift = self._print(e.args[0]-e.args[1])
1443             base = self._print_seq(shift, "<", ">", ' ')
1444             return base**n
1445 
1446     def _print_beta(self, e):
1447         func_name = greek_unicode['Beta'] if self._use_unicode else 'B'
1448         return self._print_Function(e, func_name=func_name)
1449 
1450     def _print_gamma(self, e):
1451         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1452         return self._print_Function(e, func_name=func_name)
1453 
1454     def _print_uppergamma(self, e):
1455         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1456         return self._print_Function(e, func_name=func_name)
1457 
1458     def _print_lowergamma(self, e):
1459         func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'
1460         return self._print_Function(e, func_name=func_name)
1461 
1462     def _print_DiracDelta(self, e):
1463         if self._use_unicode:
1464             if len(e.args) == 2:
1465                 a = prettyForm(greek_unicode['delta'])
1466                 b = self._print(e.args[1])
1467                 b = prettyForm(*b.parens())
1468                 c = self._print(e.args[0])
1469                 c = prettyForm(*c.parens())
1470                 pform = a**b
1471                 pform = prettyForm(*pform.right(' '))
1472                 pform = prettyForm(*pform.right(c))
1473                 return pform
1474             pform = self._print(e.args[0])
1475             pform = prettyForm(*pform.parens())
1476             pform = prettyForm(*pform.left(greek_unicode['delta']))
1477             return pform
1478         else:
1479             return self._print_Function(e)
1480 
1481     def _print_expint(self, e):
1482         from sympy import Function
1483         if e.args[0].is_Integer and self._use_unicode:
1484             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1485         return self._print_Function(e)
1486 
1487     def _print_Chi(self, e):
1488         # This needs a special case since otherwise it comes out as greek
1489         # letter chi...
1490         prettyFunc = prettyForm("Chi")
1491         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1492 
1493         pform = prettyForm(
1494             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1495 
1496         # store pform parts so it can be reassembled e.g. when powered
1497         pform.prettyFunc = prettyFunc
1498         pform.prettyArgs = prettyArgs
1499 
1500         return pform
1501 
1502     def _print_elliptic_e(self, e):
1503         pforma0 = self._print(e.args[0])
1504         if len(e.args) == 1:
1505             pform = pforma0
1506         else:
1507             pforma1 = self._print(e.args[1])
1508             pform = self._hprint_vseparator(pforma0, pforma1)
1509         pform = prettyForm(*pform.parens())
1510         pform = prettyForm(*pform.left('E'))
1511         return pform
1512 
1513     def _print_elliptic_k(self, e):
1514         pform = self._print(e.args[0])
1515         pform = prettyForm(*pform.parens())
1516         pform = prettyForm(*pform.left('K'))
1517         return pform
1518 
1519     def _print_elliptic_f(self, e):
1520         pforma0 = self._print(e.args[0])
1521         pforma1 = self._print(e.args[1])
1522         pform = self._hprint_vseparator(pforma0, pforma1)
1523         pform = prettyForm(*pform.parens())
1524         pform = prettyForm(*pform.left('F'))
1525         return pform
1526 
1527     def _print_elliptic_pi(self, e):
1528         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1529         pforma0 = self._print(e.args[0])
1530         pforma1 = self._print(e.args[1])
1531         if len(e.args) == 2:
1532             pform = self._hprint_vseparator(pforma0, pforma1)
1533         else:
1534             pforma2 = self._print(e.args[2])
1535             pforma = self._hprint_vseparator(pforma1, pforma2)
1536             pforma = prettyForm(*pforma.left('; '))
1537             pform = prettyForm(*pforma.left(pforma0))
1538         pform = prettyForm(*pform.parens())
1539         pform = prettyForm(*pform.left(name))
1540         return pform
1541 
1542     def _print_GoldenRatio(self, expr):
1543         if self._use_unicode:
1544             return prettyForm(pretty_symbol('phi'))
1545         return self._print(Symbol("GoldenRatio"))
1546 
1547     def _print_EulerGamma(self, expr):
1548         if self._use_unicode:
1549             return prettyForm(pretty_symbol('gamma'))
1550         return self._print(Symbol("EulerGamma"))
1551 
1552     def _print_Mod(self, expr):
1553         pform = self._print(expr.args[0])
1554         if pform.binding > prettyForm.MUL:
1555             pform = prettyForm(*pform.parens())
1556         pform = prettyForm(*pform.right(' mod '))
1557         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1558         pform.binding = prettyForm.OPEN
1559         return pform
1560 
1561     def _print_Add(self, expr, order=None):
1562         if self.order == 'none':
1563             terms = list(expr.args)
1564         else:
1565             terms = self._as_ordered_terms(expr, order=order)
1566         pforms, indices = [], []
1567 
1568         def pretty_negative(pform, index):
1569             """Prepend a minus sign to a pretty form. """
1570             #TODO: Move this code to prettyForm
1571             if index == 0:
1572                 if pform.height() > 1:
1573                     pform_neg = '- '
1574                 else:
1575                     pform_neg = '-'
1576             else:
1577                 pform_neg = ' - '
1578 
1579             if (pform.binding > prettyForm.NEG
1580                 or pform.binding == prettyForm.ADD):
1581                 p = stringPict(*pform.parens())
1582             else:
1583                 p = pform
1584             p = stringPict.next(pform_neg, p)
1585             # Lower the binding to NEG, even if it was higher. Otherwise, it
1586             # will print as a + ( - (b)), instead of a - (b).
1587             return prettyForm(binding=prettyForm.NEG, *p)
1588 
1589         for i, term in enumerate(terms):
1590             if term.is_Mul and _coeff_isneg(term):
1591                 coeff, other = term.as_coeff_mul(rational=False)
1592                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1593                 pforms.append(pretty_negative(pform, i))
1594             elif term.is_Rational and term.q > 1:
1595                 pforms.append(None)
1596                 indices.append(i)
1597             elif term.is_Number and term < 0:
1598                 pform = self._print(-term)
1599                 pforms.append(pretty_negative(pform, i))
1600             elif term.is_Relational:
1601                 pforms.append(prettyForm(*self._print(term).parens()))
1602             else:
1603                 pforms.append(self._print(term))
1604 
1605         if indices:
1606             large = True
1607 
1608             for pform in pforms:
1609                 if pform is not None and pform.height() > 1:
1610                     break
1611             else:
1612                 large = False
1613 
1614             for i in indices:
1615                 term, negative = terms[i], False
1616 
1617                 if term < 0:
1618                     term, negative = -term, True
1619 
1620                 if large:
1621                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1622                 else:
1623                     pform = self._print(term)
1624 
1625                 if negative:
1626                     pform = pretty_negative(pform, i)
1627 
1628                 pforms[i] = pform
1629 
1630         return prettyForm.__add__(*pforms)
1631 
1632     def _print_Mul(self, product):
1633         from sympy.physics.units import Quantity
1634         a = []  # items in the numerator
1635         b = []  # items that are in the denominator (if any)
1636 
1637         if self.order not in ('old', 'none'):
1638             args = product.as_ordered_factors()
1639         else:
1640             args = list(product.args)
1641 
1642         # If quantities are present append them at the back
1643         args = sorted(args, key=lambda x: isinstance(x, Quantity) or
1644                      (isinstance(x, Pow) and isinstance(x.base, Quantity)))
1645 
1646         # Gather terms for numerator/denominator
1647         for item in args:
1648             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1649                 if item.exp != -1:
1650                     b.append(Pow(item.base, -item.exp, evaluate=False))
1651                 else:
1652                     b.append(Pow(item.base, -item.exp))
1653             elif item.is_Rational and item is not S.Infinity:
1654                 if item.p != 1:
1655                     a.append( Rational(item.p) )
1656                 if item.q != 1:
1657                     b.append( Rational(item.q) )
1658             else:
1659                 a.append(item)
1660 
1661         from sympy import Integral, Piecewise, Product, Sum
1662 
1663         # Convert to pretty forms. Add parens to Add instances if there
1664         # is more than one term in the numer/denom
1665         for i in range(0, len(a)):
1666             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1667                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1668                 a[i] = prettyForm(*self._print(a[i]).parens())
1669             elif a[i].is_Relational:
1670                 a[i] = prettyForm(*self._print(a[i]).parens())
1671             else:
1672                 a[i] = self._print(a[i])
1673 
1674         for i in range(0, len(b)):
1675             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1676                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1677                 b[i] = prettyForm(*self._print(b[i]).parens())
1678             else:
1679                 b[i] = self._print(b[i])
1680 
1681         # Construct a pretty form
1682         if len(b) == 0:
1683             return prettyForm.__mul__(*a)
1684         else:
1685             if len(a) == 0:
1686                 a.append( self._print(S.One) )
1687             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1688 
1689     # A helper function for _print_Pow to print x**(1/n)
1690     def _print_nth_root(self, base, expt):
1691         bpretty = self._print(base)
1692 
1693         # In very simple cases, use a single-char root sign
1694         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1695             and expt is S.Half and bpretty.height() == 1
1696             and (bpretty.width() == 1
1697                  or (base.is_Integer and base.is_nonnegative))):
1698             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1699 
1700         # Construct root sign, start with the \/ shape
1701         _zZ = xobj('/', 1)
1702         rootsign = xobj('\\', 1) + _zZ
1703         # Make exponent number to put above it
1704         if isinstance(expt, Rational):
1705             exp = str(expt.q)
1706             if exp == '2':
1707                 exp = ''
1708         else:
1709             exp = str(expt.args[0])
1710         exp = exp.ljust(2)
1711         if len(exp) > 2:
1712             rootsign = ' '*(len(exp) - 2) + rootsign
1713         # Stack the exponent
1714         rootsign = stringPict(exp + '\n' + rootsign)
1715         rootsign.baseline = 0
1716         # Diagonal: length is one less than height of base
1717         linelength = bpretty.height() - 1
1718         diagonal = stringPict('\n'.join(
1719             ' '*(linelength - i - 1) + _zZ + ' '*i
1720             for i in range(linelength)
1721         ))
1722         # Put baseline just below lowest line: next to exp
1723         diagonal.baseline = linelength - 1
1724         # Make the root symbol
1725         rootsign = prettyForm(*rootsign.right(diagonal))
1726         # Det the baseline to match contents to fix the height
1727         # but if the height of bpretty is one, the rootsign must be one higher
1728         rootsign.baseline = max(1, bpretty.baseline)
1729         #build result
1730         s = prettyForm(hobj('_', 2 + bpretty.width()))
1731         s = prettyForm(*bpretty.above(s))
1732         s = prettyForm(*s.left(rootsign))
1733         return s
1734 
1735     def _print_Pow(self, power):
1736         from sympy.simplify.simplify import fraction
1737         b, e = power.as_base_exp()
1738         if power.is_commutative:
1739             if e is S.NegativeOne:
1740                 return prettyForm("1")/self._print(b)
1741             n, d = fraction(e)
1742             if n is S.One and d.is_Atom and not e.is_Integer and self._settings['root_notation']:
1743                 return self._print_nth_root(b, e)
1744             if e.is_Rational and e < 0:
1745                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1746 
1747         if b.is_Relational:
1748             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1749 
1750         return self._print(b)**self._print(e)
1751 
1752     def _print_UnevaluatedExpr(self, expr):
1753         return self._print(expr.args[0])
1754 
1755     def __print_numer_denom(self, p, q):
1756         if q == 1:
1757             if p < 0:
1758                 return prettyForm(str(p), binding=prettyForm.NEG)
1759             else:
1760                 return prettyForm(str(p))
1761         elif abs(p) >= 10 and abs(q) >= 10:
1762             # If more than one digit in numer and denom, print larger fraction
1763             if p < 0:
1764                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1765                 # Old printing method:
1766                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1767                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1768             else:
1769                 return prettyForm(str(p))/prettyForm(str(q))
1770         else:
1771             return None
1772 
1773     def _print_Rational(self, expr):
1774         result = self.__print_numer_denom(expr.p, expr.q)
1775 
1776         if result is not None:
1777             return result
1778         else:
1779             return self.emptyPrinter(expr)
1780 
1781     def _print_Fraction(self, expr):
1782         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1783 
1784         if result is not None:
1785             return result
1786         else:
1787             return self.emptyPrinter(expr)
1788 
1789     def _print_ProductSet(self, p):
1790         if len(p.sets) > 1 and not has_variety(p.sets):
1791             from sympy import Pow
1792             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1793         else:
1794             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1795             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1796                                    parenthesize=lambda set: set.is_Union or
1797                                    set.is_Intersection or set.is_ProductSet)
1798 
1799     def _print_FiniteSet(self, s):
1800         items = sorted(s.args, key=default_sort_key)
1801         return self._print_seq(items, '{', '}', ', ' )
1802 
1803     def _print_Range(self, s):
1804 
1805         if self._use_unicode:
1806             dots = u"\N{HORIZONTAL ELLIPSIS}"
1807         else:
1808             dots = '...'
1809 
1810         if s.start.is_infinite:
1811             printset = s.start, dots, s[-1] - s.step, s[-1]
1812         elif s.stop.is_infinite or len(s) > 4:
1813             it = iter(s)
1814             printset = next(it), next(it), dots, s[-1]
1815         else:
1816             printset = tuple(s)
1817 
1818         return self._print_seq(printset, '{', '}', ', ' )
1819 
1820     def _print_Interval(self, i):
1821         if i.start == i.end:
1822             return self._print_seq(i.args[:1], '{', '}')
1823 
1824         else:
1825             if i.left_open:
1826                 left = '('
1827             else:
1828                 left = '['
1829 
1830             if i.right_open:
1831                 right = ')'
1832             else:
1833                 right = ']'
1834 
1835             return self._print_seq(i.args[:2], left, right)
1836 
1837     def _print_AccumulationBounds(self, i):
1838         left = '<'
1839         right = '>'
1840 
1841         return self._print_seq(i.args[:2], left, right)
1842 
1843     def _print_Intersection(self, u):
1844 
1845         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1846 
1847         return self._print_seq(u.args, None, None, delimiter,
1848                                parenthesize=lambda set: set.is_ProductSet or
1849                                set.is_Union or set.is_Complement)
1850 
1851     def _print_Union(self, u):
1852 
1853         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1854 
1855         return self._print_seq(u.args, None, None, union_delimiter,
1856                                parenthesize=lambda set: set.is_ProductSet or
1857                                set.is_Intersection or set.is_Complement)
1858 
1859     def _print_SymmetricDifference(self, u):
1860         if not self._use_unicode:
1861             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1862 
1863         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1864 
1865         return self._print_seq(u.args, None, None, sym_delimeter)
1866 
1867     def _print_Complement(self, u):
1868 
1869         delimiter = r' \ '
1870 
1871         return self._print_seq(u.args, None, None, delimiter,
1872              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1873                                or set.is_Union)
1874 
1875     def _print_ImageSet(self, ts):
1876         if self._use_unicode:
1877             inn = u"\N{SMALL ELEMENT OF}"
1878         else:
1879             inn = 'in'
1880         variables = ts.lamda.variables
1881         expr = self._print(ts.lamda.expr)
1882         bar = self._print("|")
1883         sets = [self._print(i) for i in ts.args[1:]]
1884         if len(sets) == 1:
1885             return self._print_seq((expr, bar, variables[0], inn, sets[0]), "{", "}", ' ')
1886         else:
1887             pargs = tuple(j for var, setv in zip(variables, sets) for j in (var, inn, setv, ","))
1888             return self._print_seq((expr, bar) + pargs[:-1], "{", "}", ' ')
1889 
1890     def _print_ConditionSet(self, ts):
1891         if self._use_unicode:
1892             inn = u"\N{SMALL ELEMENT OF}"
1893             # using _and because and is a keyword and it is bad practice to
1894             # overwrite them
1895             _and = u"\N{LOGICAL AND}"
1896         else:
1897             inn = 'in'
1898             _and = 'and'
1899 
1900         variables = self._print_seq(Tuple(ts.sym))
1901         try:
1902             cond = self._print(ts.condition.as_expr())
1903         except AttributeError:
1904             cond = self._print(ts.condition)
1905             if self._use_unicode:
1906                 cond = self._print_seq(cond, "(", ")")
1907 
1908         bar = self._print("|")
1909 
1910         if ts.base_set is S.UniversalSet:
1911             return self._print_seq((variables, bar, cond), "{", "}", ' ')
1912 
1913         base = self._print(ts.base_set)
1914         return self._print_seq((variables, bar, variables, inn,
1915                                 base, _and, cond), "{", "}", ' ')
1916 
1917     def _print_ComplexRegion(self, ts):
1918         if self._use_unicode:
1919             inn = u"\N{SMALL ELEMENT OF}"
1920         else:
1921             inn = 'in'
1922         variables = self._print_seq(ts.variables)
1923         expr = self._print(ts.expr)
1924         bar = self._print("|")
1925         prodsets = self._print(ts.sets)
1926 
1927         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1928 
1929     def _print_Contains(self, e):
1930         var, set = e.args
1931         if self._use_unicode:
1932             el = u" \N{ELEMENT OF} "
1933             return prettyForm(*stringPict.next(self._print(var),
1934                                                el, self._print(set)), binding=8)
1935         else:
1936             return prettyForm(sstr(e))
1937 
1938     def _print_FourierSeries(self, s):
1939         if self._use_unicode:
1940             dots = u"\N{HORIZONTAL ELLIPSIS}"
1941         else:
1942             dots = '...'
1943         return self._print_Add(s.truncate()) + self._print(dots)
1944 
1945     def _print_FormalPowerSeries(self, s):
1946         return self._print_Add(s.infinite)
1947 
1948     def _print_SetExpr(self, se):
1949         pretty_set = prettyForm(*self._print(se.set).parens())
1950         pretty_name = self._print(Symbol("SetExpr"))
1951         return prettyForm(*pretty_name.right(pretty_set))
1952 
1953     def _print_SeqFormula(self, s):
1954         if self._use_unicode:
1955             dots = u"\N{HORIZONTAL ELLIPSIS}"
1956         else:
1957             dots = '...'
1958 
1959         if s.start is S.NegativeInfinity:
1960             stop = s.stop
1961             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1962                 s.coeff(stop - 1), s.coeff(stop))
1963         elif s.stop is S.Infinity or s.length > 4:
1964             printset = s[:4]
1965             printset.append(dots)
1966             printset = tuple(printset)
1967         else:
1968             printset = tuple(s)
1969         return self._print_list(printset)
1970 
1971     _print_SeqPer = _print_SeqFormula
1972     _print_SeqAdd = _print_SeqFormula
1973     _print_SeqMul = _print_SeqFormula
1974 
1975     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1976             parenthesize=lambda x: False):
1977         s = None
1978         try:
1979             for item in seq:
1980                 pform = self._print(item)
1981 
1982                 if parenthesize(item):
1983                     pform = prettyForm(*pform.parens())
1984                 if s is None:
1985                     # first element
1986                     s = pform
1987                 else:
1988                     s = prettyForm(*stringPict.next(s, delimiter))
1989                     s = prettyForm(*stringPict.next(s, pform))
1990 
1991             if s is None:
1992                 s = stringPict('')
1993 
1994         except AttributeError:
1995             s = None
1996             for item in seq:
1997                 pform = self.doprint(item)
1998                 if parenthesize(item):
1999                     pform = prettyForm(*pform.parens())
2000                 if s is None:
2001                     # first element
2002                     s = pform
2003                 else :
2004                     s = prettyForm(*stringPict.next(s, delimiter))
2005                     s = prettyForm(*stringPict.next(s, pform))
2006 
2007             if s is None:
2008                 s = stringPict('')
2009 
2010         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
2011         return s
2012 
2013     def join(self, delimiter, args):
2014         pform = None
2015 
2016         for arg in args:
2017             if pform is None:
2018                 pform = arg
2019             else:
2020                 pform = prettyForm(*pform.right(delimiter))
2021                 pform = prettyForm(*pform.right(arg))
2022 
2023         if pform is None:
2024             return prettyForm("")
2025         else:
2026             return pform
2027 
2028     def _print_list(self, l):
2029         return self._print_seq(l, '[', ']')
2030 
2031     def _print_tuple(self, t):
2032         if len(t) == 1:
2033             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
2034             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
2035         else:
2036             return self._print_seq(t, '(', ')')
2037 
2038     def _print_Tuple(self, expr):
2039         return self._print_tuple(expr)
2040 
2041     def _print_dict(self, d):
2042         keys = sorted(d.keys(), key=default_sort_key)
2043         items = []
2044 
2045         for k in keys:
2046             K = self._print(k)
2047             V = self._print(d[k])
2048             s = prettyForm(*stringPict.next(K, ': ', V))
2049 
2050             items.append(s)
2051 
2052         return self._print_seq(items, '{', '}')
2053 
2054     def _print_Dict(self, d):
2055         return self._print_dict(d)
2056 
2057     def _print_set(self, s):
2058         if not s:
2059             return prettyForm('set()')
2060         items = sorted(s, key=default_sort_key)
2061         pretty = self._print_seq(items)
2062         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2063         return pretty
2064 
2065     def _print_frozenset(self, s):
2066         if not s:
2067             return prettyForm('frozenset()')
2068         items = sorted(s, key=default_sort_key)
2069         pretty = self._print_seq(items)
2070         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2071         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
2072         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
2073         return pretty
2074 
2075     def _print_PolyRing(self, ring):
2076         return prettyForm(sstr(ring))
2077 
2078     def _print_FracField(self, field):
2079         return prettyForm(sstr(field))
2080 
2081     def _print_FreeGroupElement(self, elm):
2082         return prettyForm(str(elm))
2083 
2084     def _print_PolyElement(self, poly):
2085         return prettyForm(sstr(poly))
2086 
2087     def _print_FracElement(self, frac):
2088         return prettyForm(sstr(frac))
2089 
2090     def _print_AlgebraicNumber(self, expr):
2091         if expr.is_aliased:
2092             return self._print(expr.as_poly().as_expr())
2093         else:
2094             return self._print(expr.as_expr())
2095 
2096     def _print_ComplexRootOf(self, expr):
2097         args = [self._print_Add(expr.expr, order='lex'), expr.index]
2098         pform = prettyForm(*self._print_seq(args).parens())
2099         pform = prettyForm(*pform.left('CRootOf'))
2100         return pform
2101 
2102     def _print_RootSum(self, expr):
2103         args = [self._print_Add(expr.expr, order='lex')]
2104 
2105         if expr.fun is not S.IdentityFunction:
2106             args.append(self._print(expr.fun))
2107 
2108         pform = prettyForm(*self._print_seq(args).parens())
2109         pform = prettyForm(*pform.left('RootSum'))
2110 
2111         return pform
2112 
2113     def _print_FiniteField(self, expr):
2114         if self._use_unicode:
2115             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
2116         else:
2117             form = 'GF(%d)'
2118 
2119         return prettyForm(pretty_symbol(form % expr.mod))
2120 
2121     def _print_IntegerRing(self, expr):
2122         if self._use_unicode:
2123             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
2124         else:
2125             return prettyForm('ZZ')
2126 
2127     def _print_RationalField(self, expr):
2128         if self._use_unicode:
2129             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
2130         else:
2131             return prettyForm('QQ')
2132 
2133     def _print_RealField(self, domain):
2134         if self._use_unicode:
2135             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
2136         else:
2137             prefix = 'RR'
2138 
2139         if domain.has_default_precision:
2140             return prettyForm(prefix)
2141         else:
2142             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2143 
2144     def _print_ComplexField(self, domain):
2145         if self._use_unicode:
2146             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
2147         else:
2148             prefix = 'CC'
2149 
2150         if domain.has_default_precision:
2151             return prettyForm(prefix)
2152         else:
2153             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2154 
2155     def _print_PolynomialRing(self, expr):
2156         args = list(expr.symbols)
2157 
2158         if not expr.order.is_default:
2159             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2160             args.append(order)
2161 
2162         pform = self._print_seq(args, '[', ']')
2163         pform = prettyForm(*pform.left(self._print(expr.domain)))
2164 
2165         return pform
2166 
2167     def _print_FractionField(self, expr):
2168         args = list(expr.symbols)
2169 
2170         if not expr.order.is_default:
2171             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2172             args.append(order)
2173 
2174         pform = self._print_seq(args, '(', ')')
2175         pform = prettyForm(*pform.left(self._print(expr.domain)))
2176 
2177         return pform
2178 
2179     def _print_PolynomialRingBase(self, expr):
2180         g = expr.symbols
2181         if str(expr.order) != str(expr.default_order):
2182             g = g + ("order=" + str(expr.order),)
2183         pform = self._print_seq(g, '[', ']')
2184         pform = prettyForm(*pform.left(self._print(expr.domain)))
2185 
2186         return pform
2187 
2188     def _print_GroebnerBasis(self, basis):
2189         exprs = [ self._print_Add(arg, order=basis.order)
2190                   for arg in basis.exprs ]
2191         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
2192 
2193         gens = [ self._print(gen) for gen in basis.gens ]
2194 
2195         domain = prettyForm(
2196             *prettyForm("domain=").right(self._print(basis.domain)))
2197         order = prettyForm(
2198             *prettyForm("order=").right(self._print(basis.order)))
2199 
2200         pform = self.join(", ", [exprs] + gens + [domain, order])
2201 
2202         pform = prettyForm(*pform.parens())
2203         pform = prettyForm(*pform.left(basis.__class__.__name__))
2204 
2205         return pform
2206 
2207     def _print_Subs(self, e):
2208         pform = self._print(e.expr)
2209         pform = prettyForm(*pform.parens())
2210 
2211         h = pform.height() if pform.height() > 1 else 2
2212         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
2213         pform = prettyForm(*pform.right(rvert))
2214 
2215         b = pform.baseline
2216         pform.baseline = pform.height() - 1
2217         pform = prettyForm(*pform.right(self._print_seq([
2218             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
2219                 delimiter='') for v in zip(e.variables, e.point) ])))
2220 
2221         pform.baseline = b
2222         return pform
2223 
2224     def _print_euler(self, e):
2225         pform = prettyForm("E")
2226         arg = self._print(e.args[0])
2227         pform_arg = prettyForm(" "*arg.width())
2228         pform_arg = prettyForm(*pform_arg.below(arg))
2229         pform = prettyForm(*pform.right(pform_arg))
2230         if len(e.args) == 1:
2231             return pform
2232         m, x = e.args
2233         # TODO: copy-pasted from _print_Function: can we do better?
2234         prettyFunc = pform
2235         prettyArgs = prettyForm(*self._print_seq([x]).parens())
2236         pform = prettyForm(
2237             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
2238         pform.prettyFunc = prettyFunc
2239         pform.prettyArgs = prettyArgs
2240         return pform
2241 
2242     def _print_catalan(self, e):
2243         pform = prettyForm("C")
2244         arg = self._print(e.args[0])
2245         pform_arg = prettyForm(" "*arg.width())
2246         pform_arg = prettyForm(*pform_arg.below(arg))
2247         pform = prettyForm(*pform.right(pform_arg))
2248         return pform
2249 
2250     def _print_KroneckerDelta(self, e):
2251         pform = self._print(e.args[0])
2252         pform = prettyForm(*pform.right((prettyForm(','))))
2253         pform = prettyForm(*pform.right((self._print(e.args[1]))))
2254         if self._use_unicode:
2255             a = stringPict(pretty_symbol('delta'))
2256         else:
2257             a = stringPict('d')
2258         b = pform
2259         top = stringPict(*b.left(' '*a.width()))
2260         bot = stringPict(*a.right(' '*b.width()))
2261         return prettyForm(binding=prettyForm.POW, *bot.below(top))
2262 
2263     def _print_RandomDomain(self, d):
2264         if hasattr(d, 'as_boolean'):
2265             pform = self._print('Domain: ')
2266             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
2267             return pform
2268         elif hasattr(d, 'set'):
2269             pform = self._print('Domain: ')
2270             pform = prettyForm(*pform.right(self._print(d.symbols)))
2271             pform = prettyForm(*pform.right(self._print(' in ')))
2272             pform = prettyForm(*pform.right(self._print(d.set)))
2273             return pform
2274         elif hasattr(d, 'symbols'):
2275             pform = self._print('Domain on ')
2276             pform = prettyForm(*pform.right(self._print(d.symbols)))
2277             return pform
2278         else:
2279             return self._print(None)
2280 
2281     def _print_DMP(self, p):
2282         try:
2283             if p.ring is not None:
2284                 # TODO incorporate order
2285                 return self._print(p.ring.to_sympy(p))
2286         except SympifyError:
2287             pass
2288         return self._print(repr(p))
2289 
2290     def _print_DMF(self, p):
2291         return self._print_DMP(p)
2292 
2293     def _print_Object(self, object):
2294         return self._print(pretty_symbol(object.name))
2295 
2296     def _print_Morphism(self, morphism):
2297         arrow = xsym("-->")
2298 
2299         domain = self._print(morphism.domain)
2300         codomain = self._print(morphism.codomain)
2301         tail = domain.right(arrow, codomain)[0]
2302 
2303         return prettyForm(tail)
2304 
2305     def _print_NamedMorphism(self, morphism):
2306         pretty_name = self._print(pretty_symbol(morphism.name))
2307         pretty_morphism = self._print_Morphism(morphism)
2308         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2309 
2310     def _print_IdentityMorphism(self, morphism):
2311         from sympy.categories import NamedMorphism
2312         return self._print_NamedMorphism(
2313             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2314 
2315     def _print_CompositeMorphism(self, morphism):
2316 
2317         circle = xsym(".")
2318 
2319         # All components of the morphism have names and it is thus
2320         # possible to build the name of the composite.
2321         component_names_list = [pretty_symbol(component.name) for
2322                                 component in morphism.components]
2323         component_names_list.reverse()
2324         component_names = circle.join(component_names_list) + ":"
2325 
2326         pretty_name = self._print(component_names)
2327         pretty_morphism = self._print_Morphism(morphism)
2328         return prettyForm(pretty_name.right(pretty_morphism)[0])
2329 
2330     def _print_Category(self, category):
2331         return self._print(pretty_symbol(category.name))
2332 
2333     def _print_Diagram(self, diagram):
2334         if not diagram.premises:
2335             # This is an empty diagram.
2336             return self._print(S.EmptySet)
2337 
2338         pretty_result = self._print(diagram.premises)
2339         if diagram.conclusions:
2340             results_arrow = " %s " % xsym("==>")
2341 
2342             pretty_conclusions = self._print(diagram.conclusions)[0]
2343             pretty_result = pretty_result.right(
2344                 results_arrow, pretty_conclusions)
2345 
2346         return prettyForm(pretty_result[0])
2347 
2348     def _print_DiagramGrid(self, grid):
2349         from sympy.matrices import Matrix
2350         from sympy import Symbol
2351         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2352                           for j in range(grid.width)]
2353                          for i in range(grid.height)])
2354         return self._print_matrix_contents(matrix)
2355 
2356     def _print_FreeModuleElement(self, m):
2357         # Print as row vector for convenience, for now.
2358         return self._print_seq(m, '[', ']')
2359 
2360     def _print_SubModule(self, M):
2361         return self._print_seq(M.gens, '<', '>')
2362 
2363     def _print_FreeModule(self, M):
2364         return self._print(M.ring)**self._print(M.rank)
2365 
2366     def _print_ModuleImplementedIdeal(self, M):
2367         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2368 
2369     def _print_QuotientRing(self, R):
2370         return self._print(R.ring) / self._print(R.base_ideal)
2371 
2372     def _print_QuotientRingElement(self, R):
2373         return self._print(R.data) + self._print(R.ring.base_ideal)
2374 
2375     def _print_QuotientModuleElement(self, m):
2376         return self._print(m.data) + self._print(m.module.killed_module)
2377 
2378     def _print_QuotientModule(self, M):
2379         return self._print(M.base) / self._print(M.killed_module)
2380 
2381     def _print_MatrixHomomorphism(self, h):
2382         matrix = self._print(h._sympy_matrix())
2383         matrix.baseline = matrix.height() // 2
2384         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2385             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2386         return pform
2387 
2388     def _print_BaseScalarField(self, field):
2389         string = field._coord_sys._names[field._index]
2390         return self._print(pretty_symbol(string))
2391 
2392     def _print_BaseVectorField(self, field):
2393         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2394         return self._print(pretty_symbol(s))
2395 
2396     def _print_Differential(self, diff):
2397         field = diff._form_field
2398         if hasattr(field, '_coord_sys'):
2399             string = field._coord_sys._names[field._index]
2400             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2401         else:
2402             pform = self._print(field)
2403             pform = prettyForm(*pform.parens())
2404             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2405 
2406     def _print_Tr(self, p):
2407         #TODO: Handle indices
2408         pform = self._print(p.args[0])
2409         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2410         pform = prettyForm(*pform.right(')'))
2411         return pform
2412 
2413     def _print_primenu(self, e):
2414         pform = self._print(e.args[0])
2415         pform = prettyForm(*pform.parens())
2416         if self._use_unicode:
2417             pform = prettyForm(*pform.left(greek_unicode['nu']))
2418         else:
2419             pform = prettyForm(*pform.left('nu'))
2420         return pform
2421 
2422     def _print_primeomega(self, e):
2423         pform = self._print(e.args[0])
2424         pform = prettyForm(*pform.parens())
2425         if self._use_unicode:
2426             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2427         else:
2428             pform = prettyForm(*pform.left('Omega'))
2429         return pform
2430 
2431     def _print_Quantity(self, e):
2432         if e.name.name == 'degree':
2433             pform = self._print(u"\N{DEGREE SIGN}")
2434             return pform
2435         else:
2436             return self.emptyPrinter(e)
2437 
2438     def _print_AssignmentBase(self, e):
2439 
2440         op = prettyForm(' ' + xsym(e.op) + ' ')
2441 
2442         l = self._print(e.lhs)
2443         r = self._print(e.rhs)
2444         pform = prettyForm(*stringPict.next(l, op, r))
2445         return pform

</code><intended_behavior>A new method should be added to the PrettyPrinter class specifically for handling the lerchphi function. This method should check for instances of the lerchphi function within the expressions being pretty-printed and format them into a readable, aesthetically pleasing ASCII art form. The method should capture and accurately represent the mathematical functionality of lerchphi, incorporating appropriate formatting rules to ensure that the pretty-printed output is both interpretable and consistent with SymPy's pretty printing standards for special functions. This task involves identifying the parameters of lerchphi and deciding on their representation in the output. The mechanism for identifying lerchphi functions within expressions and formatting them needs to be integrated seamlessly with the existing pretty printing processes, ensuring that it does not interfere with the rendering of other expressions or symbols that may be part of the input.</intended_behavior>]
2025-10-15 13:56:32.126 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 13:56:32.126 | INFO     | Search-only: skipping patch selection
2025-10-15 13:56:32.252 | INFO     | Task sympy__sympy-15971 completed successfully.
2025-10-15 13:56:32.253 | INFO     | No patch generated. You can try running ACR again.
