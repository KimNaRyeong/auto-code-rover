2025-10-15 07:01:20.086 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:01:23.364 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=262, output_tokens=12, cost=0.002980
2025-10-15 07:01:23.365 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 07:01:23.369 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:01:31.764 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=570, output_tokens=317, cost=0.015210
2025-10-15 07:01:31.768 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:01:34.938 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=43, cost=0.008000
2025-10-15 07:01:34.939 | DEBUG    | Extracted a valid json.
2025-10-15 07:01:34.939 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ModelAdmin\")",
        "search_class(\"ManyToManyField\")",
        "search_method(\"check\")"
    ],
    "bug_locations": []
}
2025-10-15 07:01:34.990 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:01:34.990 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:01:57.056 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2995, output_tokens=834, cost=0.054970
2025-10-15 07:01:57.064 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:02:07.075 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4045, output_tokens=384, cost=0.051970
2025-10-15 07:02:07.079 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:02:16.520 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=738, output_tokens=305, cost=0.016530
2025-10-15 07:02:16.521 | DEBUG    | Extracted a valid json.
2025-10-15 07:02:16.521 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "N/A",
            "intended_behavior": "Add a new method or enhance an existing system check within ModelAdmin to validate the use of filter_horizontal or filter_vertical. This new check should iterate over the model fields to identify any ManyToManyField using a custom through model if filter_horizontal or filter_vertical are configured. If such a case is detected, raise a system check error warning the developer that filter_horizontal and filter_vertical cannot be used with ManyToManyField instances that have a custom through model. This maintains existing functionality by introducing a validation step that improves developer awareness and debugging efficiency."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "check",
            "intended_behavior": "Extend the check method of ManyToManyField to include a specific validation for its usage within admin class configurations that utilize filter_horizontal or filter_vertical. While it's not directly accessing the admin configurations in this layer, it can include a warning or documentation hint suggesting that developers ensure compatibility with filter_horizontal and filter_vertical when using a custom through model. This change would indirectly address the issue by guiding developers during model field configuration, although the primary solution would be more direct checks within the admin framework as specified in Bug Location 1."
        }
    ]
}
2025-10-15 07:02:16.535 | DEBUG    | Found override of check in RelatedField
2025-10-15 07:02:16.536 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x74155fd22c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x74146d85f0e0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x74146fb623e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x74146d85f0e0>, <app.raw_tasks.RawSweTask object at 0x74146d85f110>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x74146fb62480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x74146d797860>
    └ <function run_task_in_subprocess at 0x74146fb62660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x74146d797860>
    │        │      └ <function run_raw_task at 0x74146fb62700>
    │        └ <function ProcessPoolExecutor.submit at 0x74155f94a020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x74155f949da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x74155f949ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x74155f949f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x74155fb14ea0>
    └ <ForkProcess name='ForkProcess-205' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-205' parent=45407 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x74155fb860c0>)>
    │    │        └ <ForkProcess name='ForkProcess-205' parent=45407 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-205' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-205' parent=45407 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-205' parent=45407 started>
    │    └ <function Popen._launch at 0x74146db7f7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x74146ee6e600>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x74155fb158a0>
           └ <ForkProcess name='ForkProcess-205' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x74155fb14e00>
    └ <ForkProcess name='ForkProcess-205' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-205' parent=45407 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x74146fd5e960>, <multiprocessing.queues.SimpleQueue object at 0x74146fb80f...
    │    │        └ <ForkProcess name='ForkProcess-205' parent=45407 started>
    │    └ <function _process_worker at 0x74155f9491c0>
    └ <ForkProcess name='ForkProcess-205' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x74155fdad640>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x74147096ec30>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x74155fdad640>
        │         └ <function run_raw_task at 0x74146fb62700>
        └ <concurrent.futures.process._CallItem object at 0x74155fdad640>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output/django__django-16983_2025-10-15_07-01-19'
             │            │    └ <function RawSweTask.to_task at 0x74146fb616c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x74147096ec30>
             └ <function do_inference at 0x74146fb628e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x74146fdf0400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7414702104a0>
       │                 │         │            └ SweTask(task_id='django__django-16983', problem_statement='Add system check for filter_horizontal/filter_vertical on ManyToMa...
       │                 │         └ <app.manage.ProjectApiManager object at 0x741470438170>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output/django__django-16983_2025-10-15_07-01-19/output_0')
       └ <function _run_one_task at 0x74146fdf18a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x74146fe9dbc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x74146e0843e0>
                                  └ <app.manage.ProjectApiManager object at 0x741470438170>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'django/db/models/fields/related.py', 'class': 'ManyToManyField', 'method': 'check', 'intended_behavior': "Extend th...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x74146fe9d8a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x741470afb9e0>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x74146e0843e0>
    │                 └ <method 'extend' of 'list' objects>
    └ [<file>django/contrib/admin/options.py</file>
      <class>ModelAdmin</class>
      <method>None</method>
      <code>
      630 class ModelAdmin(Bas...

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ 'check'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/mo...
    │    │                      │   └ 'ManyToManyField'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/mo...
    │    └ <function SearchBackend._get_inherited_methods at 0x74146fe9d800>
    └ <app.search.search_backend.SearchBackend object at 0x741470afb9e0>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'RelatedField', 'method_name': 'check'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x74146fe9cf40>
                                  └ <app.search.search_backend.SearchBackend object at 0x741470afb9e0>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x741470afb9e0>, {'class_name': 'RelatedField', 'method_name': 'check'})
           └ <function SearchBackend.search_method_in_class at 0x74146fe9cea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-15 07:02:16.544 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
630 class ModelAdmin(BaseModelAdmin):
631     """Encapsulate all admin options and functionality for a given model."""
632 
633     list_display = ("__str__",)
634     list_display_links = ()
635     list_filter = ()
636     list_select_related = False
637     list_per_page = 100
638     list_max_show_all = 200
639     list_editable = ()
640     search_fields = ()
641     search_help_text = None
642     date_hierarchy = None
643     save_as = False
644     save_as_continue = True
645     save_on_top = False
646     paginator = Paginator
647     preserve_filters = True
648     show_facets = ShowFacets.ALLOW
649     inlines = ()
650 
651     # Custom templates (designed to be over-ridden in subclasses)
652     add_form_template = None
653     change_form_template = None
654     change_list_template = None
655     delete_confirmation_template = None
656     delete_selected_confirmation_template = None
657     object_history_template = None
658     popup_response_template = None
659 
660     # Actions
661     actions = ()
662     action_form = helpers.ActionForm
663     actions_on_top = True
664     actions_on_bottom = False
665     actions_selection_counter = True
666     checks_class = ModelAdminChecks
667 
668     def __init__(self, model, admin_site):
669         self.model = model
670         self.opts = model._meta
671         self.admin_site = admin_site
672         super().__init__()
673 
674     def __str__(self):
675         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
676 
677     def __repr__(self):
678         return (
679             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
680             f"site={self.admin_site!r}>"
681         )
682 
683     def get_inline_instances(self, request, obj=None):
684         inline_instances = []
685         for inline_class in self.get_inlines(request, obj):
686             inline = inline_class(self.model, self.admin_site)
687             if request:
688                 if not (
689                     inline.has_view_or_change_permission(request, obj)
690                     or inline.has_add_permission(request, obj)
691                     or inline.has_delete_permission(request, obj)
692                 ):
693                     continue
694                 if not inline.has_add_permission(request, obj):
695                     inline.max_num = 0
696             inline_instances.append(inline)
697 
698         return inline_instances
699 
700     def get_urls(self):
701         from django.urls import path
702 
703         def wrap(view):
704             def wrapper(*args, **kwargs):
705                 return self.admin_site.admin_view(view)(*args, **kwargs)
706 
707             wrapper.model_admin = self
708             return update_wrapper(wrapper, view)
709 
710         info = self.opts.app_label, self.opts.model_name
711 
712         return [
713             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
714             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
715             path(
716                 "<path:object_id>/history/",
717                 wrap(self.history_view),
718                 name="%s_%s_history" % info,
719             ),
720             path(
721                 "<path:object_id>/delete/",
722                 wrap(self.delete_view),
723                 name="%s_%s_delete" % info,
724             ),
725             path(
726                 "<path:object_id>/change/",
727                 wrap(self.change_view),
728                 name="%s_%s_change" % info,
729             ),
730             # For backwards compatibility (was the change url before 1.9)
731             path(
732                 "<path:object_id>/",
733                 wrap(
734                     RedirectView.as_view(
735                         pattern_name="%s:%s_%s_change"
736                         % ((self.admin_site.name,) + info)
737                     )
738                 ),
739             ),
740         ]
741 
742     @property
743     def urls(self):
744         return self.get_urls()
745 
746     @property
747     def media(self):
748         extra = "" if settings.DEBUG else ".min"
749         js = [
750             "vendor/jquery/jquery%s.js" % extra,
751             "jquery.init.js",
752             "core.js",
753             "admin/RelatedObjectLookups.js",
754             "actions.js",
755             "urlify.js",
756             "prepopulate.js",
757             "vendor/xregexp/xregexp%s.js" % extra,
758         ]
759         return forms.Media(js=["admin/js/%s" % url for url in js])
760 
761     def get_model_perms(self, request):
762         """
763         Return a dict of all perms for this model. This dict has the keys
764         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
765         for each of those actions.
766         """
767         return {
768             "add": self.has_add_permission(request),
769             "change": self.has_change_permission(request),
770             "delete": self.has_delete_permission(request),
771             "view": self.has_view_permission(request),
772         }
773 
774     def _get_form_for_get_fields(self, request, obj):
775         return self.get_form(request, obj, fields=None)
776 
777     def get_form(self, request, obj=None, change=False, **kwargs):
778         """
779         Return a Form class for use in the admin add view. This is used by
780         add_view and change_view.
781         """
782         if "fields" in kwargs:
783             fields = kwargs.pop("fields")
784         else:
785             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
786         excluded = self.get_exclude(request, obj)
787         exclude = [] if excluded is None else list(excluded)
788         readonly_fields = self.get_readonly_fields(request, obj)
789         exclude.extend(readonly_fields)
790         # Exclude all fields if it's a change form and the user doesn't have
791         # the change permission.
792         if (
793             change
794             and hasattr(request, "user")
795             and not self.has_change_permission(request, obj)
796         ):
797             exclude.extend(fields)
798         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
799             # Take the custom ModelForm's Meta.exclude into account only if the
800             # ModelAdmin doesn't define its own.
801             exclude.extend(self.form._meta.exclude)
802         # if exclude is an empty list we pass None to be consistent with the
803         # default on modelform_factory
804         exclude = exclude or None
805 
806         # Remove declared form fields which are in readonly_fields.
807         new_attrs = dict.fromkeys(
808             f for f in readonly_fields if f in self.form.declared_fields
809         )
810         form = type(self.form.__name__, (self.form,), new_attrs)
811 
812         defaults = {
813             "form": form,
814             "fields": fields,
815             "exclude": exclude,
816             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
817             **kwargs,
818         }
819 
820         if defaults["fields"] is None and not modelform_defines_fields(
821             defaults["form"]
822         ):
823             defaults["fields"] = forms.ALL_FIELDS
824 
825         try:
826             return modelform_factory(self.model, **defaults)
827         except FieldError as e:
828             raise FieldError(
829                 "%s. Check fields/fieldsets/exclude attributes of class %s."
830                 % (e, self.__class__.__name__)
831             )
832 
833     def get_changelist(self, request, **kwargs):
834         """
835         Return the ChangeList class for use on the changelist page.
836         """
837         from django.contrib.admin.views.main import ChangeList
838 
839         return ChangeList
840 
841     def get_changelist_instance(self, request):
842         """
843         Return a `ChangeList` instance based on `request`. May raise
844         `IncorrectLookupParameters`.
845         """
846         list_display = self.get_list_display(request)
847         list_display_links = self.get_list_display_links(request, list_display)
848         # Add the action checkboxes if any actions are available.
849         if self.get_actions(request):
850             list_display = ["action_checkbox", *list_display]
851         sortable_by = self.get_sortable_by(request)
852         ChangeList = self.get_changelist(request)
853         return ChangeList(
854             request,
855             self.model,
856             list_display,
857             list_display_links,
858             self.get_list_filter(request),
859             self.date_hierarchy,
860             self.get_search_fields(request),
861             self.get_list_select_related(request),
862             self.list_per_page,
863             self.list_max_show_all,
864             self.list_editable,
865             self,
866             sortable_by,
867             self.search_help_text,
868         )
869 
870     def get_object(self, request, object_id, from_field=None):
871         """
872         Return an instance matching the field and value provided, the primary
873         key is used if no field is provided. Return ``None`` if no match is
874         found or the object_id fails validation.
875         """
876         queryset = self.get_queryset(request)
877         model = queryset.model
878         field = (
879             model._meta.pk if from_field is None else model._meta.get_field(from_field)
880         )
881         try:
882             object_id = field.to_python(object_id)
883             return queryset.get(**{field.name: object_id})
884         except (model.DoesNotExist, ValidationError, ValueError):
885             return None
886 
887     def get_changelist_form(self, request, **kwargs):
888         """
889         Return a Form class for use in the Formset on the changelist page.
890         """
891         defaults = {
892             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
893             **kwargs,
894         }
895         if defaults.get("fields") is None and not modelform_defines_fields(
896             defaults.get("form")
897         ):
898             defaults["fields"] = forms.ALL_FIELDS
899 
900         return modelform_factory(self.model, **defaults)
901 
902     def get_changelist_formset(self, request, **kwargs):
903         """
904         Return a FormSet class for use on the changelist page if list_editable
905         is used.
906         """
907         defaults = {
908             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
909             **kwargs,
910         }
911         return modelformset_factory(
912             self.model,
913             self.get_changelist_form(request),
914             extra=0,
915             fields=self.list_editable,
916             **defaults,
917         )
918 
919     def get_formsets_with_inlines(self, request, obj=None):
920         """
921         Yield formsets and the corresponding inlines.
922         """
923         for inline in self.get_inline_instances(request, obj):
924             yield inline.get_formset(request, obj), inline
925 
926     def get_paginator(
927         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
928     ):
929         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
930 
931     def log_addition(self, request, obj, message):
932         """
933         Log that an object has been successfully added.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import ADDITION, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=ADDITION,
945             change_message=message,
946         )
947 
948     def log_change(self, request, obj, message):
949         """
950         Log that an object has been successfully changed.
951 
952         The default implementation creates an admin LogEntry object.
953         """
954         from django.contrib.admin.models import CHANGE, LogEntry
955 
956         return LogEntry.objects.log_action(
957             user_id=request.user.pk,
958             content_type_id=get_content_type_for_model(obj).pk,
959             object_id=obj.pk,
960             object_repr=str(obj),
961             action_flag=CHANGE,
962             change_message=message,
963         )
964 
965     def log_deletion(self, request, obj, object_repr):
966         """
967         Log that an object will be deleted. Note that this method must be
968         called before the deletion.
969 
970         The default implementation creates an admin LogEntry object.
971         """
972         from django.contrib.admin.models import DELETION, LogEntry
973 
974         return LogEntry.objects.log_action(
975             user_id=request.user.pk,
976             content_type_id=get_content_type_for_model(obj).pk,
977             object_id=obj.pk,
978             object_repr=object_repr,
979             action_flag=DELETION,
980         )
981 
982     def action_checkbox(self, obj):
983         """
984         A list_display column containing a checkbox widget.
985         """
986         attrs = {
987             "class": "action-select",
988             "aria-label": format_html(_("Select this object for an action - {}"), obj),
989         }
990         checkbox = forms.CheckboxInput(attrs, lambda value: False)
991         return checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
992 
993     @staticmethod
994     def _get_action_description(func, name):
995         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
996 
997     def _get_base_actions(self):
998         """Return the list of actions, prior to any request-based filtering."""
999         actions = []
1000         base_actions = (self.get_action(action) for action in self.actions or [])
1001         # get_action might have returned None, so filter any of those out.
1002         base_actions = [action for action in base_actions if action]
1003         base_action_names = {name for _, name, _ in base_actions}
1004 
1005         # Gather actions from the admin site first
1006         for name, func in self.admin_site.actions:
1007             if name in base_action_names:
1008                 continue
1009             description = self._get_action_description(func, name)
1010             actions.append((func, name, description))
1011         # Add actions from this ModelAdmin.
1012         actions.extend(base_actions)
1013         return actions
1014 
1015     def _filter_actions_by_permissions(self, request, actions):
1016         """Filter out any actions that the user doesn't have access to."""
1017         filtered_actions = []
1018         for action in actions:
1019             callable = action[0]
1020             if not hasattr(callable, "allowed_permissions"):
1021                 filtered_actions.append(action)
1022                 continue
1023             permission_checks = (
1024                 getattr(self, "has_%s_permission" % permission)
1025                 for permission in callable.allowed_permissions
1026             )
1027             if any(has_permission(request) for has_permission in permission_checks):
1028                 filtered_actions.append(action)
1029         return filtered_actions
1030 
1031     def get_actions(self, request):
1032         """
1033         Return a dictionary mapping the names of all actions for this
1034         ModelAdmin to a tuple of (callable, name, description) for each action.
1035         """
1036         # If self.actions is set to None that means actions are disabled on
1037         # this page.
1038         if self.actions is None or IS_POPUP_VAR in request.GET:
1039             return {}
1040         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1041         return {name: (func, name, desc) for func, name, desc in actions}
1042 
1043     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1044         """
1045         Return a list of choices for use in a form object.  Each choice is a
1046         tuple (name, description).
1047         """
1048         choices = [] + default_choices
1049         for func, name, description in self.get_actions(request).values():
1050             choice = (name, description % model_format_dict(self.opts))
1051             choices.append(choice)
1052         return choices
1053 
1054     def get_action(self, action):
1055         """
1056         Return a given action from a parameter, which can either be a callable,
1057         or the name of a method on the ModelAdmin.  Return is a tuple of
1058         (callable, name, description).
1059         """
1060         # If the action is a callable, just use it.
1061         if callable(action):
1062             func = action
1063             action = action.__name__
1064 
1065         # Next, look for a method. Grab it off self.__class__ to get an unbound
1066         # method instead of a bound one; this ensures that the calling
1067         # conventions are the same for functions and methods.
1068         elif hasattr(self.__class__, action):
1069             func = getattr(self.__class__, action)
1070 
1071         # Finally, look for a named method on the admin site
1072         else:
1073             try:
1074                 func = self.admin_site.get_action(action)
1075             except KeyError:
1076                 return None
1077 
1078         description = self._get_action_description(func, action)
1079         return func, action, description
1080 
1081     def get_list_display(self, request):
1082         """
1083         Return a sequence containing the fields to be displayed on the
1084         changelist.
1085         """
1086         return self.list_display
1087 
1088     def get_list_display_links(self, request, list_display):
1089         """
1090         Return a sequence containing the fields to be displayed as links
1091         on the changelist. The list_display parameter is the list of fields
1092         returned by get_list_display().
1093         """
1094         if (
1095             self.list_display_links
1096             or self.list_display_links is None
1097             or not list_display
1098         ):
1099             return self.list_display_links
1100         else:
1101             # Use only the first item in list_display as link
1102             return list(list_display)[:1]
1103 
1104     def get_list_filter(self, request):
1105         """
1106         Return a sequence containing the fields to be displayed as filters in
1107         the right sidebar of the changelist page.
1108         """
1109         return self.list_filter
1110 
1111     def get_list_select_related(self, request):
1112         """
1113         Return a list of fields to add to the select_related() part of the
1114         changelist items query.
1115         """
1116         return self.list_select_related
1117 
1118     def get_search_fields(self, request):
1119         """
1120         Return a sequence containing the fields to be searched whenever
1121         somebody submits a search query.
1122         """
1123         return self.search_fields
1124 
1125     def get_search_results(self, request, queryset, search_term):
1126         """
1127         Return a tuple containing a queryset to implement the search
1128         and a boolean indicating if the results may contain duplicates.
1129         """
1130 
1131         # Apply keyword searches.
1132         def construct_search(field_name):
1133             if field_name.startswith("^"):
1134                 return "%s__istartswith" % field_name.removeprefix("^")
1135             elif field_name.startswith("="):
1136                 return "%s__iexact" % field_name.removeprefix("=")
1137             elif field_name.startswith("@"):
1138                 return "%s__search" % field_name.removeprefix("@")
1139             # Use field_name if it includes a lookup.
1140             opts = queryset.model._meta
1141             lookup_fields = field_name.split(LOOKUP_SEP)
1142             # Go through the fields, following all relations.
1143             prev_field = None
1144             for path_part in lookup_fields:
1145                 if path_part == "pk":
1146                     path_part = opts.pk.name
1147                 try:
1148                     field = opts.get_field(path_part)
1149                 except FieldDoesNotExist:
1150                     # Use valid query lookups.
1151                     if prev_field and prev_field.get_lookup(path_part):
1152                         return field_name
1153                 else:
1154                     prev_field = field
1155                     if hasattr(field, "path_infos"):
1156                         # Update opts to follow the relation.
1157                         opts = field.path_infos[-1].to_opts
1158             # Otherwise, use the field with icontains.
1159             return "%s__icontains" % field_name
1160 
1161         may_have_duplicates = False
1162         search_fields = self.get_search_fields(request)
1163         if search_fields and search_term:
1164             orm_lookups = [
1165                 construct_search(str(search_field)) for search_field in search_fields
1166             ]
1167             term_queries = []
1168             for bit in smart_split(search_term):
1169                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1170                     bit = unescape_string_literal(bit)
1171                 or_queries = models.Q.create(
1172                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1173                     connector=models.Q.OR,
1174                 )
1175                 term_queries.append(or_queries)
1176             queryset = queryset.filter(models.Q.create(term_queries))
1177             may_have_duplicates |= any(
1178                 lookup_spawns_duplicates(self.opts, search_spec)
1179                 for search_spec in orm_lookups
1180             )
1181         return queryset, may_have_duplicates
1182 
1183     def get_preserved_filters(self, request):
1184         """
1185         Return the preserved filters querystring.
1186         """
1187         match = request.resolver_match
1188         if self.preserve_filters and match:
1189             current_url = "%s:%s" % (match.app_name, match.url_name)
1190             changelist_url = "admin:%s_%s_changelist" % (
1191                 self.opts.app_label,
1192                 self.opts.model_name,
1193             )
1194             if current_url == changelist_url:
1195                 preserved_filters = request.GET.urlencode()
1196             else:
1197                 preserved_filters = request.GET.get("_changelist_filters")
1198 
1199             if preserved_filters:
1200                 return urlencode({"_changelist_filters": preserved_filters})
1201         return ""
1202 
1203     def construct_change_message(self, request, form, formsets, add=False):
1204         """
1205         Construct a JSON structure describing changes from a changed object.
1206         """
1207         return construct_change_message(form, formsets, add)
1208 
1209     def message_user(
1210         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1211     ):
1212         """
1213         Send a message to the user. The default implementation
1214         posts a message using the django.contrib.messages backend.
1215 
1216         Exposes almost the same API as messages.add_message(), but accepts the
1217         positional arguments in a different order to maintain backwards
1218         compatibility. For convenience, it accepts the `level` argument as
1219         a string rather than the usual level number.
1220         """
1221         if not isinstance(level, int):
1222             # attempt to get the level if passed a string
1223             try:
1224                 level = getattr(messages.constants, level.upper())
1225             except AttributeError:
1226                 levels = messages.constants.DEFAULT_TAGS.values()
1227                 levels_repr = ", ".join("`%s`" % level for level in levels)
1228                 raise ValueError(
1229                     "Bad message level string: `%s`. Possible values are: %s"
1230                     % (level, levels_repr)
1231                 )
1232 
1233         messages.add_message(
1234             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1235         )
1236 
1237     def save_form(self, request, form, change):
1238         """
1239         Given a ModelForm return an unsaved instance. ``change`` is True if
1240         the object is being changed, and False if it's being added.
1241         """
1242         return form.save(commit=False)
1243 
1244     def save_model(self, request, obj, form, change):
1245         """
1246         Given a model instance save it to the database.
1247         """
1248         obj.save()
1249 
1250     def delete_model(self, request, obj):
1251         """
1252         Given a model instance delete it from the database.
1253         """
1254         obj.delete()
1255 
1256     def delete_queryset(self, request, queryset):
1257         """Given a queryset, delete it from the database."""
1258         queryset.delete()
1259 
1260     def save_formset(self, request, form, formset, change):
1261         """
1262         Given an inline formset save it to the database.
1263         """
1264         formset.save()
1265 
1266     def save_related(self, request, form, formsets, change):
1267         """
1268         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1269         list of inline formsets and a boolean value based on whether the
1270         parent is being added or changed, save the related objects to the
1271         database. Note that at this point save_form() and save_model() have
1272         already been called.
1273         """
1274         form.save_m2m()
1275         for formset in formsets:
1276             self.save_formset(request, form, formset, change=change)
1277 
1278     def render_change_form(
1279         self, request, context, add=False, change=False, form_url="", obj=None
1280     ):
1281         app_label = self.opts.app_label
1282         preserved_filters = self.get_preserved_filters(request)
1283         form_url = add_preserved_filters(
1284             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1285         )
1286         view_on_site_url = self.get_view_on_site_url(obj)
1287         has_editable_inline_admin_formsets = False
1288         for inline in context["inline_admin_formsets"]:
1289             if (
1290                 inline.has_add_permission
1291                 or inline.has_change_permission
1292                 or inline.has_delete_permission
1293             ):
1294                 has_editable_inline_admin_formsets = True
1295                 break
1296         context.update(
1297             {
1298                 "add": add,
1299                 "change": change,
1300                 "has_view_permission": self.has_view_permission(request, obj),
1301                 "has_add_permission": self.has_add_permission(request),
1302                 "has_change_permission": self.has_change_permission(request, obj),
1303                 "has_delete_permission": self.has_delete_permission(request, obj),
1304                 "has_editable_inline_admin_formsets": (
1305                     has_editable_inline_admin_formsets
1306                 ),
1307                 "has_file_field": context["adminform"].form.is_multipart()
1308                 or any(
1309                     admin_formset.formset.is_multipart()
1310                     for admin_formset in context["inline_admin_formsets"]
1311                 ),
1312                 "has_absolute_url": view_on_site_url is not None,
1313                 "absolute_url": view_on_site_url,
1314                 "form_url": form_url,
1315                 "opts": self.opts,
1316                 "content_type_id": get_content_type_for_model(self.model).pk,
1317                 "save_as": self.save_as,
1318                 "save_on_top": self.save_on_top,
1319                 "to_field_var": TO_FIELD_VAR,
1320                 "is_popup_var": IS_POPUP_VAR,
1321                 "app_label": app_label,
1322             }
1323         )
1324         if add and self.add_form_template is not None:
1325             form_template = self.add_form_template
1326         else:
1327             form_template = self.change_form_template
1328 
1329         request.current_app = self.admin_site.name
1330 
1331         return TemplateResponse(
1332             request,
1333             form_template
1334             or [
1335                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1336                 "admin/%s/change_form.html" % app_label,
1337                 "admin/change_form.html",
1338             ],
1339             context,
1340         )
1341 
1342     def response_add(self, request, obj, post_url_continue=None):
1343         """
1344         Determine the HttpResponse for the add_view stage.
1345         """
1346         opts = obj._meta
1347         preserved_filters = self.get_preserved_filters(request)
1348         obj_url = reverse(
1349             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1350             args=(quote(obj.pk),),
1351             current_app=self.admin_site.name,
1352         )
1353         # Add a link to the object's change form if the user can edit the obj.
1354         if self.has_change_permission(request, obj):
1355             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1356         else:
1357             obj_repr = str(obj)
1358         msg_dict = {
1359             "name": opts.verbose_name,
1360             "obj": obj_repr,
1361         }
1362         # Here, we distinguish between different save types by checking for
1363         # the presence of keys in request.POST.
1364 
1365         if IS_POPUP_VAR in request.POST:
1366             to_field = request.POST.get(TO_FIELD_VAR)
1367             if to_field:
1368                 attr = str(to_field)
1369             else:
1370                 attr = obj._meta.pk.attname
1371             value = obj.serializable_value(attr)
1372             popup_response_data = json.dumps(
1373                 {
1374                     "value": str(value),
1375                     "obj": str(obj),
1376                 }
1377             )
1378             return TemplateResponse(
1379                 request,
1380                 self.popup_response_template
1381                 or [
1382                     "admin/%s/%s/popup_response.html"
1383                     % (opts.app_label, opts.model_name),
1384                     "admin/%s/popup_response.html" % opts.app_label,
1385                     "admin/popup_response.html",
1386                 ],
1387                 {
1388                     "popup_response_data": popup_response_data,
1389                 },
1390             )
1391 
1392         elif "_continue" in request.POST or (
1393             # Redirecting after "Save as new".
1394             "_saveasnew" in request.POST
1395             and self.save_as_continue
1396             and self.has_change_permission(request, obj)
1397         ):
1398             msg = _("The {name} “{obj}” was added successfully.")
1399             if self.has_change_permission(request, obj):
1400                 msg += " " + _("You may edit it again below.")
1401             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1402             if post_url_continue is None:
1403                 post_url_continue = obj_url
1404             post_url_continue = add_preserved_filters(
1405                 {"preserved_filters": preserved_filters, "opts": opts},
1406                 post_url_continue,
1407             )
1408             return HttpResponseRedirect(post_url_continue)
1409 
1410         elif "_addanother" in request.POST:
1411             msg = format_html(
1412                 _(
1413                     "The {name} “{obj}” was added successfully. You may add another "
1414                     "{name} below."
1415                 ),
1416                 **msg_dict,
1417             )
1418             self.message_user(request, msg, messages.SUCCESS)
1419             redirect_url = request.path
1420             redirect_url = add_preserved_filters(
1421                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1422             )
1423             return HttpResponseRedirect(redirect_url)
1424 
1425         else:
1426             msg = format_html(
1427                 _("The {name} “{obj}” was added successfully."), **msg_dict
1428             )
1429             self.message_user(request, msg, messages.SUCCESS)
1430             return self.response_post_save_add(request, obj)
1431 
1432     def response_change(self, request, obj):
1433         """
1434         Determine the HttpResponse for the change_view stage.
1435         """
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             opts = obj._meta
1439             to_field = request.POST.get(TO_FIELD_VAR)
1440             attr = str(to_field) if to_field else opts.pk.attname
1441             value = request.resolver_match.kwargs["object_id"]
1442             new_value = obj.serializable_value(attr)
1443             popup_response_data = json.dumps(
1444                 {
1445                     "action": "change",
1446                     "value": str(value),
1447                     "obj": str(obj),
1448                     "new_value": str(new_value),
1449                 }
1450             )
1451             return TemplateResponse(
1452                 request,
1453                 self.popup_response_template
1454                 or [
1455                     "admin/%s/%s/popup_response.html"
1456                     % (opts.app_label, opts.model_name),
1457                     "admin/%s/popup_response.html" % opts.app_label,
1458                     "admin/popup_response.html",
1459                 ],
1460                 {
1461                     "popup_response_data": popup_response_data,
1462                 },
1463             )
1464 
1465         opts = self.opts
1466         preserved_filters = self.get_preserved_filters(request)
1467 
1468         msg_dict = {
1469             "name": opts.verbose_name,
1470             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1471         }
1472         if "_continue" in request.POST:
1473             msg = format_html(
1474                 _(
1475                     "The {name} “{obj}” was changed successfully. You may edit it "
1476                     "again below."
1477                 ),
1478                 **msg_dict,
1479             )
1480             self.message_user(request, msg, messages.SUCCESS)
1481             redirect_url = request.path
1482             redirect_url = add_preserved_filters(
1483                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1484             )
1485             return HttpResponseRedirect(redirect_url)
1486 
1487         elif "_saveasnew" in request.POST:
1488             msg = format_html(
1489                 _(
1490                     "The {name} “{obj}” was added successfully. You may edit it again "
1491                     "below."
1492                 ),
1493                 **msg_dict,
1494             )
1495             self.message_user(request, msg, messages.SUCCESS)
1496             redirect_url = reverse(
1497                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1498                 args=(obj.pk,),
1499                 current_app=self.admin_site.name,
1500             )
1501             redirect_url = add_preserved_filters(
1502                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1503             )
1504             return HttpResponseRedirect(redirect_url)
1505 
1506         elif "_addanother" in request.POST:
1507             msg = format_html(
1508                 _(
1509                     "The {name} “{obj}” was changed successfully. You may add another "
1510                     "{name} below."
1511                 ),
1512                 **msg_dict,
1513             )
1514             self.message_user(request, msg, messages.SUCCESS)
1515             redirect_url = reverse(
1516                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1517                 current_app=self.admin_site.name,
1518             )
1519             redirect_url = add_preserved_filters(
1520                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1521             )
1522             return HttpResponseRedirect(redirect_url)
1523 
1524         else:
1525             msg = format_html(
1526                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1527             )
1528             self.message_user(request, msg, messages.SUCCESS)
1529             return self.response_post_save_change(request, obj)
1530 
1531     def _response_post_save(self, request, obj):
1532         if self.has_view_or_change_permission(request):
1533             post_url = reverse(
1534                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1535                 current_app=self.admin_site.name,
1536             )
1537             preserved_filters = self.get_preserved_filters(request)
1538             post_url = add_preserved_filters(
1539                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1540             )
1541         else:
1542             post_url = reverse("admin:index", current_app=self.admin_site.name)
1543         return HttpResponseRedirect(post_url)
1544 
1545     def response_post_save_add(self, request, obj):
1546         """
1547         Figure out where to redirect after the 'Save' button has been pressed
1548         when adding a new object.
1549         """
1550         return self._response_post_save(request, obj)
1551 
1552     def response_post_save_change(self, request, obj):
1553         """
1554         Figure out where to redirect after the 'Save' button has been pressed
1555         when editing an existing object.
1556         """
1557         return self._response_post_save(request, obj)
1558 
1559     def response_action(self, request, queryset):
1560         """
1561         Handle an admin action. This is called if a request is POSTed to the
1562         changelist; it returns an HttpResponse if the action was handled, and
1563         None otherwise.
1564         """
1565 
1566         # There can be multiple action forms on the page (at the top
1567         # and bottom of the change list, for example). Get the action
1568         # whose button was pushed.
1569         try:
1570             action_index = int(request.POST.get("index", 0))
1571         except ValueError:
1572             action_index = 0
1573 
1574         # Construct the action form.
1575         data = request.POST.copy()
1576         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1577         data.pop("index", None)
1578 
1579         # Use the action whose button was pushed
1580         try:
1581             data.update({"action": data.getlist("action")[action_index]})
1582         except IndexError:
1583             # If we didn't get an action from the chosen form that's invalid
1584             # POST data, so by deleting action it'll fail the validation check
1585             # below. So no need to do anything here
1586             pass
1587 
1588         action_form = self.action_form(data, auto_id=None)
1589         action_form.fields["action"].choices = self.get_action_choices(request)
1590 
1591         # If the form's valid we can handle the action.
1592         if action_form.is_valid():
1593             action = action_form.cleaned_data["action"]
1594             select_across = action_form.cleaned_data["select_across"]
1595             func = self.get_actions(request)[action][0]
1596 
1597             # Get the list of selected PKs. If nothing's selected, we can't
1598             # perform an action on it, so bail. Except we want to perform
1599             # the action explicitly on all objects.
1600             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1601             if not selected and not select_across:
1602                 # Reminder that something needs to be selected or nothing will happen
1603                 msg = _(
1604                     "Items must be selected in order to perform "
1605                     "actions on them. No items have been changed."
1606                 )
1607                 self.message_user(request, msg, messages.WARNING)
1608                 return None
1609 
1610             if not select_across:
1611                 # Perform the action only on the selected objects
1612                 queryset = queryset.filter(pk__in=selected)
1613 
1614             response = func(self, request, queryset)
1615 
1616             # Actions may return an HttpResponse-like object, which will be
1617             # used as the response from the POST. If not, we'll be a good
1618             # little HTTP citizen and redirect back to the changelist page.
1619             if isinstance(response, HttpResponseBase):
1620                 return response
1621             else:
1622                 return HttpResponseRedirect(request.get_full_path())
1623         else:
1624             msg = _("No action selected.")
1625             self.message_user(request, msg, messages.WARNING)
1626             return None
1627 
1628     def response_delete(self, request, obj_display, obj_id):
1629         """
1630         Determine the HttpResponse for the delete_view stage.
1631         """
1632         if IS_POPUP_VAR in request.POST:
1633             popup_response_data = json.dumps(
1634                 {
1635                     "action": "delete",
1636                     "value": str(obj_id),
1637                 }
1638             )
1639             return TemplateResponse(
1640                 request,
1641                 self.popup_response_template
1642                 or [
1643                     "admin/%s/%s/popup_response.html"
1644                     % (self.opts.app_label, self.opts.model_name),
1645                     "admin/%s/popup_response.html" % self.opts.app_label,
1646                     "admin/popup_response.html",
1647                 ],
1648                 {
1649                     "popup_response_data": popup_response_data,
1650                 },
1651             )
1652 
1653         self.message_user(
1654             request,
1655             _("The %(name)s “%(obj)s” was deleted successfully.")
1656             % {
1657                 "name": self.opts.verbose_name,
1658                 "obj": obj_display,
1659             },
1660             messages.SUCCESS,
1661         )
1662 
1663         if self.has_change_permission(request, None):
1664             post_url = reverse(
1665                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1666                 current_app=self.admin_site.name,
1667             )
1668             preserved_filters = self.get_preserved_filters(request)
1669             post_url = add_preserved_filters(
1670                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1671             )
1672         else:
1673             post_url = reverse("admin:index", current_app=self.admin_site.name)
1674         return HttpResponseRedirect(post_url)
1675 
1676     def render_delete_form(self, request, context):
1677         app_label = self.opts.app_label
1678 
1679         request.current_app = self.admin_site.name
1680         context.update(
1681             to_field_var=TO_FIELD_VAR,
1682             is_popup_var=IS_POPUP_VAR,
1683             media=self.media,
1684         )
1685 
1686         return TemplateResponse(
1687             request,
1688             self.delete_confirmation_template
1689             or [
1690                 "admin/{}/{}/delete_confirmation.html".format(
1691                     app_label, self.opts.model_name
1692                 ),
1693                 "admin/{}/delete_confirmation.html".format(app_label),
1694                 "admin/delete_confirmation.html",
1695             ],
1696             context,
1697         )
1698 
1699     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1700         # Edit permissions on parent model are required for editable inlines.
1701         can_edit_parent = (
1702             self.has_change_permission(request, obj)
1703             if obj
1704             else self.has_add_permission(request)
1705         )
1706         inline_admin_formsets = []
1707         for inline, formset in zip(inline_instances, formsets):
1708             fieldsets = list(inline.get_fieldsets(request, obj))
1709             readonly = list(inline.get_readonly_fields(request, obj))
1710             if can_edit_parent:
1711                 has_add_permission = inline.has_add_permission(request, obj)
1712                 has_change_permission = inline.has_change_permission(request, obj)
1713                 has_delete_permission = inline.has_delete_permission(request, obj)
1714             else:
1715                 # Disable all edit-permissions, and override formset settings.
1716                 has_add_permission = (
1717                     has_change_permission
1718                 ) = has_delete_permission = False
1719                 formset.extra = formset.max_num = 0
1720             has_view_permission = inline.has_view_permission(request, obj)
1721             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1722             inline_admin_formset = helpers.InlineAdminFormSet(
1723                 inline,
1724                 formset,
1725                 fieldsets,
1726                 prepopulated,
1727                 readonly,
1728                 model_admin=self,
1729                 has_add_permission=has_add_permission,
1730                 has_change_permission=has_change_permission,
1731                 has_delete_permission=has_delete_permission,
1732                 has_view_permission=has_view_permission,
1733             )
1734             inline_admin_formsets.append(inline_admin_formset)
1735         return inline_admin_formsets
1736 
1737     def get_changeform_initial_data(self, request):
1738         """
1739         Get the initial form data from the request's GET params.
1740         """
1741         initial = dict(request.GET.items())
1742         for k in initial:
1743             try:
1744                 f = self.opts.get_field(k)
1745             except FieldDoesNotExist:
1746                 continue
1747             # We have to special-case M2Ms as a list of comma-separated PKs.
1748             if isinstance(f, models.ManyToManyField):
1749                 initial[k] = initial[k].split(",")
1750         return initial
1751 
1752     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1753         """
1754         Create a message informing the user that the object doesn't exist
1755         and return a redirect to the admin index page.
1756         """
1757         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1758             "name": opts.verbose_name,
1759             "key": unquote(object_id),
1760         }
1761         self.message_user(request, msg, messages.WARNING)
1762         url = reverse("admin:index", current_app=self.admin_site.name)
1763         return HttpResponseRedirect(url)
1764 
1765     @csrf_protect_m
1766     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1767         with transaction.atomic(using=router.db_for_write(self.model)):
1768             return self._changeform_view(request, object_id, form_url, extra_context)
1769 
1770     def _changeform_view(self, request, object_id, form_url, extra_context):
1771         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1772         if to_field and not self.to_field_allowed(request, to_field):
1773             raise DisallowedModelAdminToField(
1774                 "The field %s cannot be referenced." % to_field
1775             )
1776 
1777         if request.method == "POST" and "_saveasnew" in request.POST:
1778             object_id = None
1779 
1780         add = object_id is None
1781 
1782         if add:
1783             if not self.has_add_permission(request):
1784                 raise PermissionDenied
1785             obj = None
1786 
1787         else:
1788             obj = self.get_object(request, unquote(object_id), to_field)
1789 
1790             if request.method == "POST":
1791                 if not self.has_change_permission(request, obj):
1792                     raise PermissionDenied
1793             else:
1794                 if not self.has_view_or_change_permission(request, obj):
1795                     raise PermissionDenied
1796 
1797             if obj is None:
1798                 return self._get_obj_does_not_exist_redirect(
1799                     request, self.opts, object_id
1800                 )
1801 
1802         fieldsets = self.get_fieldsets(request, obj)
1803         ModelForm = self.get_form(
1804             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1805         )
1806         if request.method == "POST":
1807             form = ModelForm(request.POST, request.FILES, instance=obj)
1808             formsets, inline_instances = self._create_formsets(
1809                 request,
1810                 form.instance,
1811                 change=not add,
1812             )
1813             form_validated = form.is_valid()
1814             if form_validated:
1815                 new_object = self.save_form(request, form, change=not add)
1816             else:
1817                 new_object = form.instance
1818             if all_valid(formsets) and form_validated:
1819                 self.save_model(request, new_object, form, not add)
1820                 self.save_related(request, form, formsets, not add)
1821                 change_message = self.construct_change_message(
1822                     request, form, formsets, add
1823                 )
1824                 if add:
1825                     self.log_addition(request, new_object, change_message)
1826                     return self.response_add(request, new_object)
1827                 else:
1828                     self.log_change(request, new_object, change_message)
1829                     return self.response_change(request, new_object)
1830             else:
1831                 form_validated = False
1832         else:
1833             if add:
1834                 initial = self.get_changeform_initial_data(request)
1835                 form = ModelForm(initial=initial)
1836                 formsets, inline_instances = self._create_formsets(
1837                     request, form.instance, change=False
1838                 )
1839             else:
1840                 form = ModelForm(instance=obj)
1841                 formsets, inline_instances = self._create_formsets(
1842                     request, obj, change=True
1843                 )
1844 
1845         if not add and not self.has_change_permission(request, obj):
1846             readonly_fields = flatten_fieldsets(fieldsets)
1847         else:
1848             readonly_fields = self.get_readonly_fields(request, obj)
1849         admin_form = helpers.AdminForm(
1850             form,
1851             list(fieldsets),
1852             # Clear prepopulated fields on a view-only form to avoid a crash.
1853             self.get_prepopulated_fields(request, obj)
1854             if add or self.has_change_permission(request, obj)
1855             else {},
1856             readonly_fields,
1857             model_admin=self,
1858         )
1859         media = self.media + admin_form.media
1860 
1861         inline_formsets = self.get_inline_formsets(
1862             request, formsets, inline_instances, obj
1863         )
1864         for inline_formset in inline_formsets:
1865             media += inline_formset.media
1866 
1867         if add:
1868             title = _("Add %s")
1869         elif self.has_change_permission(request, obj):
1870             title = _("Change %s")
1871         else:
1872             title = _("View %s")
1873         context = {
1874             **self.admin_site.each_context(request),
1875             "title": title % self.opts.verbose_name,
1876             "subtitle": str(obj) if obj else None,
1877             "adminform": admin_form,
1878             "object_id": object_id,
1879             "original": obj,
1880             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1881             "to_field": to_field,
1882             "media": media,
1883             "inline_admin_formsets": inline_formsets,
1884             "errors": helpers.AdminErrorList(form, formsets),
1885             "preserved_filters": self.get_preserved_filters(request),
1886         }
1887 
1888         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1889         # previously chosen to prevent the interface from getting confusing.
1890         if (
1891             request.method == "POST"
1892             and not form_validated
1893             and "_saveasnew" in request.POST
1894         ):
1895             context["show_save"] = False
1896             context["show_save_and_continue"] = False
1897             # Use the change template instead of the add template.
1898             add = False
1899 
1900         context.update(extra_context or {})
1901 
1902         return self.render_change_form(
1903             request, context, add=add, change=not add, obj=obj, form_url=form_url
1904         )
1905 
1906     def add_view(self, request, form_url="", extra_context=None):
1907         return self.changeform_view(request, None, form_url, extra_context)
1908 
1909     def change_view(self, request, object_id, form_url="", extra_context=None):
1910         return self.changeform_view(request, object_id, form_url, extra_context)
1911 
1912     def _get_edited_object_pks(self, request, prefix):
1913         """Return POST data values of list_editable primary keys."""
1914         pk_pattern = re.compile(
1915             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1916         )
1917         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1918 
1919     def _get_list_editable_queryset(self, request, prefix):
1920         """
1921         Based on POST data, return a queryset of the objects that were edited
1922         via list_editable.
1923         """
1924         object_pks = self._get_edited_object_pks(request, prefix)
1925         queryset = self.get_queryset(request)
1926         validate = queryset.model._meta.pk.to_python
1927         try:
1928             for pk in object_pks:
1929                 validate(pk)
1930         except ValidationError:
1931             # Disable the optimization if the POST data was tampered with.
1932             return queryset
1933         return queryset.filter(pk__in=object_pks)
1934 
1935     @csrf_protect_m
1936     def changelist_view(self, request, extra_context=None):
1937         """
1938         The 'change list' admin view for this model.
1939         """
1940         from django.contrib.admin.views.main import ERROR_FLAG
1941 
1942         app_label = self.opts.app_label
1943         if not self.has_view_or_change_permission(request):
1944             raise PermissionDenied
1945 
1946         try:
1947             cl = self.get_changelist_instance(request)
1948         except IncorrectLookupParameters:
1949             # Wacky lookup parameters were given, so redirect to the main
1950             # changelist page, without parameters, and pass an 'invalid=1'
1951             # parameter via the query string. If wacky parameters were given
1952             # and the 'invalid=1' parameter was already in the query string,
1953             # something is screwed up with the database, so display an error
1954             # page.
1955             if ERROR_FLAG in request.GET:
1956                 return SimpleTemplateResponse(
1957                     "admin/invalid_setup.html",
1958                     {
1959                         "title": _("Database error"),
1960                     },
1961                 )
1962             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1963 
1964         # If the request was POSTed, this might be a bulk action or a bulk
1965         # edit. Try to look up an action or confirmation first, but if this
1966         # isn't an action the POST will fall through to the bulk edit check,
1967         # below.
1968         action_failed = False
1969         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1970 
1971         actions = self.get_actions(request)
1972         # Actions with no confirmation
1973         if (
1974             actions
1975             and request.method == "POST"
1976             and "index" in request.POST
1977             and "_save" not in request.POST
1978         ):
1979             if selected:
1980                 response = self.response_action(
1981                     request, queryset=cl.get_queryset(request)
1982                 )
1983                 if response:
1984                     return response
1985                 else:
1986                     action_failed = True
1987             else:
1988                 msg = _(
1989                     "Items must be selected in order to perform "
1990                     "actions on them. No items have been changed."
1991                 )
1992                 self.message_user(request, msg, messages.WARNING)
1993                 action_failed = True
1994 
1995         # Actions with confirmation
1996         if (
1997             actions
1998             and request.method == "POST"
1999             and helpers.ACTION_CHECKBOX_NAME in request.POST
2000             and "index" not in request.POST
2001             and "_save" not in request.POST
2002         ):
2003             if selected:
2004                 response = self.response_action(
2005                     request, queryset=cl.get_queryset(request)
2006                 )
2007                 if response:
2008                     return response
2009                 else:
2010                     action_failed = True
2011 
2012         if action_failed:
2013             # Redirect back to the changelist page to avoid resubmitting the
2014             # form if the user refreshes the browser or uses the "No, take
2015             # me back" button on the action confirmation page.
2016             return HttpResponseRedirect(request.get_full_path())
2017 
2018         # If we're allowing changelist editing, we need to construct a formset
2019         # for the changelist given all the fields to be edited. Then we'll
2020         # use the formset to validate/process POSTed data.
2021         formset = cl.formset = None
2022 
2023         # Handle POSTed bulk-edit data.
2024         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2025             if not self.has_change_permission(request):
2026                 raise PermissionDenied
2027             FormSet = self.get_changelist_formset(request)
2028             modified_objects = self._get_list_editable_queryset(
2029                 request, FormSet.get_default_prefix()
2030             )
2031             formset = cl.formset = FormSet(
2032                 request.POST, request.FILES, queryset=modified_objects
2033             )
2034             if formset.is_valid():
2035                 changecount = 0
2036                 with transaction.atomic(using=router.db_for_write(self.model)):
2037                     for form in formset.forms:
2038                         if form.has_changed():
2039                             obj = self.save_form(request, form, change=True)
2040                             self.save_model(request, obj, form, change=True)
2041                             self.save_related(request, form, formsets=[], change=True)
2042                             change_msg = self.construct_change_message(
2043                                 request, form, None
2044                             )
2045                             self.log_change(request, obj, change_msg)
2046                             changecount += 1
2047                 if changecount:
2048                     msg = ngettext(
2049                         "%(count)s %(name)s was changed successfully.",
2050                         "%(count)s %(name)s were changed successfully.",
2051                         changecount,
2052                     ) % {
2053                         "count": changecount,
2054                         "name": model_ngettext(self.opts, changecount),
2055                     }
2056                     self.message_user(request, msg, messages.SUCCESS)
2057 
2058                 return HttpResponseRedirect(request.get_full_path())
2059 
2060         # Handle GET -- construct a formset for display.
2061         elif cl.list_editable and self.has_change_permission(request):
2062             FormSet = self.get_changelist_formset(request)
2063             formset = cl.formset = FormSet(queryset=cl.result_list)
2064 
2065         # Build the list of media to be used by the formset.
2066         if formset:
2067             media = self.media + formset.media
2068         else:
2069             media = self.media
2070 
2071         # Build the action form and populate it with available actions.
2072         if actions:
2073             action_form = self.action_form(auto_id=None)
2074             action_form.fields["action"].choices = self.get_action_choices(request)
2075             media += action_form.media
2076         else:
2077             action_form = None
2078 
2079         selection_note_all = ngettext(
2080             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2081         )
2082 
2083         context = {
2084             **self.admin_site.each_context(request),
2085             "module_name": str(self.opts.verbose_name_plural),
2086             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2087             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2088             "title": cl.title,
2089             "subtitle": None,
2090             "is_popup": cl.is_popup,
2091             "to_field": cl.to_field,
2092             "cl": cl,
2093             "media": media,
2094             "has_add_permission": self.has_add_permission(request),
2095             "opts": cl.opts,
2096             "action_form": action_form,
2097             "actions_on_top": self.actions_on_top,
2098             "actions_on_bottom": self.actions_on_bottom,
2099             "actions_selection_counter": self.actions_selection_counter,
2100             "preserved_filters": self.get_preserved_filters(request),
2101             **(extra_context or {}),
2102         }
2103 
2104         request.current_app = self.admin_site.name
2105 
2106         return TemplateResponse(
2107             request,
2108             self.change_list_template
2109             or [
2110                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2111                 "admin/%s/change_list.html" % app_label,
2112                 "admin/change_list.html",
2113             ],
2114             context,
2115         )
2116 
2117     def get_deleted_objects(self, objs, request):
2118         """
2119         Hook for customizing the delete process for the delete view and the
2120         "delete selected" action.
2121         """
2122         return get_deleted_objects(objs, request, self.admin_site)
2123 
2124     @csrf_protect_m
2125     def delete_view(self, request, object_id, extra_context=None):
2126         with transaction.atomic(using=router.db_for_write(self.model)):
2127             return self._delete_view(request, object_id, extra_context)
2128 
2129     def _delete_view(self, request, object_id, extra_context):
2130         "The 'delete' admin view for this model."
2131         app_label = self.opts.app_label
2132 
2133         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2134         if to_field and not self.to_field_allowed(request, to_field):
2135             raise DisallowedModelAdminToField(
2136                 "The field %s cannot be referenced." % to_field
2137             )
2138 
2139         obj = self.get_object(request, unquote(object_id), to_field)
2140 
2141         if not self.has_delete_permission(request, obj):
2142             raise PermissionDenied
2143 
2144         if obj is None:
2145             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2146 
2147         # Populate deleted_objects, a data structure of all related objects that
2148         # will also be deleted.
2149         (
2150             deleted_objects,
2151             model_count,
2152             perms_needed,
2153             protected,
2154         ) = self.get_deleted_objects([obj], request)
2155 
2156         if request.POST and not protected:  # The user has confirmed the deletion.
2157             if perms_needed:
2158                 raise PermissionDenied
2159             obj_display = str(obj)
2160             attr = str(to_field) if to_field else self.opts.pk.attname
2161             obj_id = obj.serializable_value(attr)
2162             self.log_deletion(request, obj, obj_display)
2163             self.delete_model(request, obj)
2164 
2165             return self.response_delete(request, obj_display, obj_id)
2166 
2167         object_name = str(self.opts.verbose_name)
2168 
2169         if perms_needed or protected:
2170             title = _("Cannot delete %(name)s") % {"name": object_name}
2171         else:
2172             title = _("Are you sure?")
2173 
2174         context = {
2175             **self.admin_site.each_context(request),
2176             "title": title,
2177             "subtitle": None,
2178             "object_name": object_name,
2179             "object": obj,
2180             "deleted_objects": deleted_objects,
2181             "model_count": dict(model_count).items(),
2182             "perms_lacking": perms_needed,
2183             "protected": protected,
2184             "opts": self.opts,
2185             "app_label": app_label,
2186             "preserved_filters": self.get_preserved_filters(request),
2187             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2188             "to_field": to_field,
2189             **(extra_context or {}),
2190         }
2191 
2192         return self.render_delete_form(request, context)
2193 
2194     def history_view(self, request, object_id, extra_context=None):
2195         "The 'history' admin view for this model."
2196         from django.contrib.admin.models import LogEntry
2197         from django.contrib.admin.views.main import PAGE_VAR
2198 
2199         # First check if the user can see this history.
2200         model = self.model
2201         obj = self.get_object(request, unquote(object_id))
2202         if obj is None:
2203             return self._get_obj_does_not_exist_redirect(
2204                 request, model._meta, object_id
2205             )
2206 
2207         if not self.has_view_or_change_permission(request, obj):
2208             raise PermissionDenied
2209 
2210         # Then get the history for this object.
2211         app_label = self.opts.app_label
2212         action_list = (
2213             LogEntry.objects.filter(
2214                 object_id=unquote(object_id),
2215                 content_type=get_content_type_for_model(model),
2216             )
2217             .select_related()
2218             .order_by("action_time")
2219         )
2220 
2221         paginator = self.get_paginator(request, action_list, 100)
2222         page_number = request.GET.get(PAGE_VAR, 1)
2223         page_obj = paginator.get_page(page_number)
2224         page_range = paginator.get_elided_page_range(page_obj.number)
2225 
2226         context = {
2227             **self.admin_site.each_context(request),
2228             "title": _("Change history: %s") % obj,
2229             "subtitle": None,
2230             "action_list": page_obj,
2231             "page_range": page_range,
2232             "page_var": PAGE_VAR,
2233             "pagination_required": paginator.count > 100,
2234             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2235             "object": obj,
2236             "opts": self.opts,
2237             "preserved_filters": self.get_preserved_filters(request),
2238             **(extra_context or {}),
2239         }
2240 
2241         request.current_app = self.admin_site.name
2242 
2243         return TemplateResponse(
2244             request,
2245             self.object_history_template
2246             or [
2247                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2248                 "admin/%s/object_history.html" % app_label,
2249                 "admin/object_history.html",
2250             ],
2251             context,
2252         )
2253 
2254     def get_formset_kwargs(self, request, obj, inline, prefix):
2255         formset_params = {
2256             "instance": obj,
2257             "prefix": prefix,
2258             "queryset": inline.get_queryset(request),
2259         }
2260         if request.method == "POST":
2261             formset_params.update(
2262                 {
2263                     "data": request.POST.copy(),
2264                     "files": request.FILES,
2265                     "save_as_new": "_saveasnew" in request.POST,
2266                 }
2267             )
2268         return formset_params
2269 
2270     def _create_formsets(self, request, obj, change):
2271         "Helper function to generate formsets for add/change_view."
2272         formsets = []
2273         inline_instances = []
2274         prefixes = {}
2275         get_formsets_args = [request]
2276         if change:
2277             get_formsets_args.append(obj)
2278         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2279             prefix = FormSet.get_default_prefix()
2280             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2281             if prefixes[prefix] != 1 or not prefix:
2282                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2283             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2284             formset = FormSet(**formset_params)
2285 
2286             def user_deleted_form(request, obj, formset, index, inline):
2287                 """Return whether or not the user deleted the form."""
2288                 return (
2289                     inline.has_delete_permission(request, obj)
2290                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2291                 )
2292 
2293             # Bypass validation of each view-only inline form (since the form's
2294             # data won't be in request.POST), unless the form was deleted.
2295             if not inline.has_change_permission(request, obj if change else None):
2296                 for index, form in enumerate(formset.initial_forms):
2297                     if user_deleted_form(request, obj, formset, index, inline):
2298                         continue
2299                     form._errors = {}
2300                     form.cleaned_data = form.initial
2301             formsets.append(formset)
2302             inline_instances.append(inline)
2303         return formsets, inline_instances

</code><intended_behavior>Add a new method or enhance an existing system check within ModelAdmin to validate the use of filter_horizontal or filter_vertical. This new check should iterate over the model fields to identify any ManyToManyField using a custom through model if filter_horizontal or filter_vertical are configured. If such a case is detected, raise a system check error warning the developer that filter_horizontal and filter_vertical cannot be used with ManyToManyField instances that have a custom through model. This maintains existing functionality by introducing a validation step that improves developer awareness and debugging efficiency.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>check</method>
<code>
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]

</code><intended_behavior>Extend the check method of ManyToManyField to include a specific validation for its usage within admin class configurations that utilize filter_horizontal or filter_vertical. While it's not directly accessing the admin configurations in this layer, it can include a warning or documentation hint suggesting that developers ensure compatibility with filter_horizontal and filter_vertical when using a custom through model. This change would indirectly address the issue by guiding developers during model field configuration, although the primary solution would be more direct checks within the admin framework as specified in Bug Location 1.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:02:16.544 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
630 class ModelAdmin(BaseModelAdmin):
631     """Encapsulate all admin options and functionality for a given model."""
632 
633     list_display = ("__str__",)
634     list_display_links = ()
635     list_filter = ()
636     list_select_related = False
637     list_per_page = 100
638     list_max_show_all = 200
639     list_editable = ()
640     search_fields = ()
641     search_help_text = None
642     date_hierarchy = None
643     save_as = False
644     save_as_continue = True
645     save_on_top = False
646     paginator = Paginator
647     preserve_filters = True
648     show_facets = ShowFacets.ALLOW
649     inlines = ()
650 
651     # Custom templates (designed to be over-ridden in subclasses)
652     add_form_template = None
653     change_form_template = None
654     change_list_template = None
655     delete_confirmation_template = None
656     delete_selected_confirmation_template = None
657     object_history_template = None
658     popup_response_template = None
659 
660     # Actions
661     actions = ()
662     action_form = helpers.ActionForm
663     actions_on_top = True
664     actions_on_bottom = False
665     actions_selection_counter = True
666     checks_class = ModelAdminChecks
667 
668     def __init__(self, model, admin_site):
669         self.model = model
670         self.opts = model._meta
671         self.admin_site = admin_site
672         super().__init__()
673 
674     def __str__(self):
675         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
676 
677     def __repr__(self):
678         return (
679             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
680             f"site={self.admin_site!r}>"
681         )
682 
683     def get_inline_instances(self, request, obj=None):
684         inline_instances = []
685         for inline_class in self.get_inlines(request, obj):
686             inline = inline_class(self.model, self.admin_site)
687             if request:
688                 if not (
689                     inline.has_view_or_change_permission(request, obj)
690                     or inline.has_add_permission(request, obj)
691                     or inline.has_delete_permission(request, obj)
692                 ):
693                     continue
694                 if not inline.has_add_permission(request, obj):
695                     inline.max_num = 0
696             inline_instances.append(inline)
697 
698         return inline_instances
699 
700     def get_urls(self):
701         from django.urls import path
702 
703         def wrap(view):
704             def wrapper(*args, **kwargs):
705                 return self.admin_site.admin_view(view)(*args, **kwargs)
706 
707             wrapper.model_admin = self
708             return update_wrapper(wrapper, view)
709 
710         info = self.opts.app_label, self.opts.model_name
711 
712         return [
713             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
714             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
715             path(
716                 "<path:object_id>/history/",
717                 wrap(self.history_view),
718                 name="%s_%s_history" % info,
719             ),
720             path(
721                 "<path:object_id>/delete/",
722                 wrap(self.delete_view),
723                 name="%s_%s_delete" % info,
724             ),
725             path(
726                 "<path:object_id>/change/",
727                 wrap(self.change_view),
728                 name="%s_%s_change" % info,
729             ),
730             # For backwards compatibility (was the change url before 1.9)
731             path(
732                 "<path:object_id>/",
733                 wrap(
734                     RedirectView.as_view(
735                         pattern_name="%s:%s_%s_change"
736                         % ((self.admin_site.name,) + info)
737                     )
738                 ),
739             ),
740         ]
741 
742     @property
743     def urls(self):
744         return self.get_urls()
745 
746     @property
747     def media(self):
748         extra = "" if settings.DEBUG else ".min"
749         js = [
750             "vendor/jquery/jquery%s.js" % extra,
751             "jquery.init.js",
752             "core.js",
753             "admin/RelatedObjectLookups.js",
754             "actions.js",
755             "urlify.js",
756             "prepopulate.js",
757             "vendor/xregexp/xregexp%s.js" % extra,
758         ]
759         return forms.Media(js=["admin/js/%s" % url for url in js])
760 
761     def get_model_perms(self, request):
762         """
763         Return a dict of all perms for this model. This dict has the keys
764         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
765         for each of those actions.
766         """
767         return {
768             "add": self.has_add_permission(request),
769             "change": self.has_change_permission(request),
770             "delete": self.has_delete_permission(request),
771             "view": self.has_view_permission(request),
772         }
773 
774     def _get_form_for_get_fields(self, request, obj):
775         return self.get_form(request, obj, fields=None)
776 
777     def get_form(self, request, obj=None, change=False, **kwargs):
778         """
779         Return a Form class for use in the admin add view. This is used by
780         add_view and change_view.
781         """
782         if "fields" in kwargs:
783             fields = kwargs.pop("fields")
784         else:
785             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
786         excluded = self.get_exclude(request, obj)
787         exclude = [] if excluded is None else list(excluded)
788         readonly_fields = self.get_readonly_fields(request, obj)
789         exclude.extend(readonly_fields)
790         # Exclude all fields if it's a change form and the user doesn't have
791         # the change permission.
792         if (
793             change
794             and hasattr(request, "user")
795             and not self.has_change_permission(request, obj)
796         ):
797             exclude.extend(fields)
798         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
799             # Take the custom ModelForm's Meta.exclude into account only if the
800             # ModelAdmin doesn't define its own.
801             exclude.extend(self.form._meta.exclude)
802         # if exclude is an empty list we pass None to be consistent with the
803         # default on modelform_factory
804         exclude = exclude or None
805 
806         # Remove declared form fields which are in readonly_fields.
807         new_attrs = dict.fromkeys(
808             f for f in readonly_fields if f in self.form.declared_fields
809         )
810         form = type(self.form.__name__, (self.form,), new_attrs)
811 
812         defaults = {
813             "form": form,
814             "fields": fields,
815             "exclude": exclude,
816             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
817             **kwargs,
818         }
819 
820         if defaults["fields"] is None and not modelform_defines_fields(
821             defaults["form"]
822         ):
823             defaults["fields"] = forms.ALL_FIELDS
824 
825         try:
826             return modelform_factory(self.model, **defaults)
827         except FieldError as e:
828             raise FieldError(
829                 "%s. Check fields/fieldsets/exclude attributes of class %s."
830                 % (e, self.__class__.__name__)
831             )
832 
833     def get_changelist(self, request, **kwargs):
834         """
835         Return the ChangeList class for use on the changelist page.
836         """
837         from django.contrib.admin.views.main import ChangeList
838 
839         return ChangeList
840 
841     def get_changelist_instance(self, request):
842         """
843         Return a `ChangeList` instance based on `request`. May raise
844         `IncorrectLookupParameters`.
845         """
846         list_display = self.get_list_display(request)
847         list_display_links = self.get_list_display_links(request, list_display)
848         # Add the action checkboxes if any actions are available.
849         if self.get_actions(request):
850             list_display = ["action_checkbox", *list_display]
851         sortable_by = self.get_sortable_by(request)
852         ChangeList = self.get_changelist(request)
853         return ChangeList(
854             request,
855             self.model,
856             list_display,
857             list_display_links,
858             self.get_list_filter(request),
859             self.date_hierarchy,
860             self.get_search_fields(request),
861             self.get_list_select_related(request),
862             self.list_per_page,
863             self.list_max_show_all,
864             self.list_editable,
865             self,
866             sortable_by,
867             self.search_help_text,
868         )
869 
870     def get_object(self, request, object_id, from_field=None):
871         """
872         Return an instance matching the field and value provided, the primary
873         key is used if no field is provided. Return ``None`` if no match is
874         found or the object_id fails validation.
875         """
876         queryset = self.get_queryset(request)
877         model = queryset.model
878         field = (
879             model._meta.pk if from_field is None else model._meta.get_field(from_field)
880         )
881         try:
882             object_id = field.to_python(object_id)
883             return queryset.get(**{field.name: object_id})
884         except (model.DoesNotExist, ValidationError, ValueError):
885             return None
886 
887     def get_changelist_form(self, request, **kwargs):
888         """
889         Return a Form class for use in the Formset on the changelist page.
890         """
891         defaults = {
892             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
893             **kwargs,
894         }
895         if defaults.get("fields") is None and not modelform_defines_fields(
896             defaults.get("form")
897         ):
898             defaults["fields"] = forms.ALL_FIELDS
899 
900         return modelform_factory(self.model, **defaults)
901 
902     def get_changelist_formset(self, request, **kwargs):
903         """
904         Return a FormSet class for use on the changelist page if list_editable
905         is used.
906         """
907         defaults = {
908             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
909             **kwargs,
910         }
911         return modelformset_factory(
912             self.model,
913             self.get_changelist_form(request),
914             extra=0,
915             fields=self.list_editable,
916             **defaults,
917         )
918 
919     def get_formsets_with_inlines(self, request, obj=None):
920         """
921         Yield formsets and the corresponding inlines.
922         """
923         for inline in self.get_inline_instances(request, obj):
924             yield inline.get_formset(request, obj), inline
925 
926     def get_paginator(
927         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
928     ):
929         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
930 
931     def log_addition(self, request, obj, message):
932         """
933         Log that an object has been successfully added.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import ADDITION, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=ADDITION,
945             change_message=message,
946         )
947 
948     def log_change(self, request, obj, message):
949         """
950         Log that an object has been successfully changed.
951 
952         The default implementation creates an admin LogEntry object.
953         """
954         from django.contrib.admin.models import CHANGE, LogEntry
955 
956         return LogEntry.objects.log_action(
957             user_id=request.user.pk,
958             content_type_id=get_content_type_for_model(obj).pk,
959             object_id=obj.pk,
960             object_repr=str(obj),
961             action_flag=CHANGE,
962             change_message=message,
963         )
964 
965     def log_deletion(self, request, obj, object_repr):
966         """
967         Log that an object will be deleted. Note that this method must be
968         called before the deletion.
969 
970         The default implementation creates an admin LogEntry object.
971         """
972         from django.contrib.admin.models import DELETION, LogEntry
973 
974         return LogEntry.objects.log_action(
975             user_id=request.user.pk,
976             content_type_id=get_content_type_for_model(obj).pk,
977             object_id=obj.pk,
978             object_repr=object_repr,
979             action_flag=DELETION,
980         )
981 
982     def action_checkbox(self, obj):
983         """
984         A list_display column containing a checkbox widget.
985         """
986         attrs = {
987             "class": "action-select",
988             "aria-label": format_html(_("Select this object for an action - {}"), obj),
989         }
990         checkbox = forms.CheckboxInput(attrs, lambda value: False)
991         return checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
992 
993     @staticmethod
994     def _get_action_description(func, name):
995         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
996 
997     def _get_base_actions(self):
998         """Return the list of actions, prior to any request-based filtering."""
999         actions = []
1000         base_actions = (self.get_action(action) for action in self.actions or [])
1001         # get_action might have returned None, so filter any of those out.
1002         base_actions = [action for action in base_actions if action]
1003         base_action_names = {name for _, name, _ in base_actions}
1004 
1005         # Gather actions from the admin site first
1006         for name, func in self.admin_site.actions:
1007             if name in base_action_names:
1008                 continue
1009             description = self._get_action_description(func, name)
1010             actions.append((func, name, description))
1011         # Add actions from this ModelAdmin.
1012         actions.extend(base_actions)
1013         return actions
1014 
1015     def _filter_actions_by_permissions(self, request, actions):
1016         """Filter out any actions that the user doesn't have access to."""
1017         filtered_actions = []
1018         for action in actions:
1019             callable = action[0]
1020             if not hasattr(callable, "allowed_permissions"):
1021                 filtered_actions.append(action)
1022                 continue
1023             permission_checks = (
1024                 getattr(self, "has_%s_permission" % permission)
1025                 for permission in callable.allowed_permissions
1026             )
1027             if any(has_permission(request) for has_permission in permission_checks):
1028                 filtered_actions.append(action)
1029         return filtered_actions
1030 
1031     def get_actions(self, request):
1032         """
1033         Return a dictionary mapping the names of all actions for this
1034         ModelAdmin to a tuple of (callable, name, description) for each action.
1035         """
1036         # If self.actions is set to None that means actions are disabled on
1037         # this page.
1038         if self.actions is None or IS_POPUP_VAR in request.GET:
1039             return {}
1040         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1041         return {name: (func, name, desc) for func, name, desc in actions}
1042 
1043     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1044         """
1045         Return a list of choices for use in a form object.  Each choice is a
1046         tuple (name, description).
1047         """
1048         choices = [] + default_choices
1049         for func, name, description in self.get_actions(request).values():
1050             choice = (name, description % model_format_dict(self.opts))
1051             choices.append(choice)
1052         return choices
1053 
1054     def get_action(self, action):
1055         """
1056         Return a given action from a parameter, which can either be a callable,
1057         or the name of a method on the ModelAdmin.  Return is a tuple of
1058         (callable, name, description).
1059         """
1060         # If the action is a callable, just use it.
1061         if callable(action):
1062             func = action
1063             action = action.__name__
1064 
1065         # Next, look for a method. Grab it off self.__class__ to get an unbound
1066         # method instead of a bound one; this ensures that the calling
1067         # conventions are the same for functions and methods.
1068         elif hasattr(self.__class__, action):
1069             func = getattr(self.__class__, action)
1070 
1071         # Finally, look for a named method on the admin site
1072         else:
1073             try:
1074                 func = self.admin_site.get_action(action)
1075             except KeyError:
1076                 return None
1077 
1078         description = self._get_action_description(func, action)
1079         return func, action, description
1080 
1081     def get_list_display(self, request):
1082         """
1083         Return a sequence containing the fields to be displayed on the
1084         changelist.
1085         """
1086         return self.list_display
1087 
1088     def get_list_display_links(self, request, list_display):
1089         """
1090         Return a sequence containing the fields to be displayed as links
1091         on the changelist. The list_display parameter is the list of fields
1092         returned by get_list_display().
1093         """
1094         if (
1095             self.list_display_links
1096             or self.list_display_links is None
1097             or not list_display
1098         ):
1099             return self.list_display_links
1100         else:
1101             # Use only the first item in list_display as link
1102             return list(list_display)[:1]
1103 
1104     def get_list_filter(self, request):
1105         """
1106         Return a sequence containing the fields to be displayed as filters in
1107         the right sidebar of the changelist page.
1108         """
1109         return self.list_filter
1110 
1111     def get_list_select_related(self, request):
1112         """
1113         Return a list of fields to add to the select_related() part of the
1114         changelist items query.
1115         """
1116         return self.list_select_related
1117 
1118     def get_search_fields(self, request):
1119         """
1120         Return a sequence containing the fields to be searched whenever
1121         somebody submits a search query.
1122         """
1123         return self.search_fields
1124 
1125     def get_search_results(self, request, queryset, search_term):
1126         """
1127         Return a tuple containing a queryset to implement the search
1128         and a boolean indicating if the results may contain duplicates.
1129         """
1130 
1131         # Apply keyword searches.
1132         def construct_search(field_name):
1133             if field_name.startswith("^"):
1134                 return "%s__istartswith" % field_name.removeprefix("^")
1135             elif field_name.startswith("="):
1136                 return "%s__iexact" % field_name.removeprefix("=")
1137             elif field_name.startswith("@"):
1138                 return "%s__search" % field_name.removeprefix("@")
1139             # Use field_name if it includes a lookup.
1140             opts = queryset.model._meta
1141             lookup_fields = field_name.split(LOOKUP_SEP)
1142             # Go through the fields, following all relations.
1143             prev_field = None
1144             for path_part in lookup_fields:
1145                 if path_part == "pk":
1146                     path_part = opts.pk.name
1147                 try:
1148                     field = opts.get_field(path_part)
1149                 except FieldDoesNotExist:
1150                     # Use valid query lookups.
1151                     if prev_field and prev_field.get_lookup(path_part):
1152                         return field_name
1153                 else:
1154                     prev_field = field
1155                     if hasattr(field, "path_infos"):
1156                         # Update opts to follow the relation.
1157                         opts = field.path_infos[-1].to_opts
1158             # Otherwise, use the field with icontains.
1159             return "%s__icontains" % field_name
1160 
1161         may_have_duplicates = False
1162         search_fields = self.get_search_fields(request)
1163         if search_fields and search_term:
1164             orm_lookups = [
1165                 construct_search(str(search_field)) for search_field in search_fields
1166             ]
1167             term_queries = []
1168             for bit in smart_split(search_term):
1169                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1170                     bit = unescape_string_literal(bit)
1171                 or_queries = models.Q.create(
1172                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1173                     connector=models.Q.OR,
1174                 )
1175                 term_queries.append(or_queries)
1176             queryset = queryset.filter(models.Q.create(term_queries))
1177             may_have_duplicates |= any(
1178                 lookup_spawns_duplicates(self.opts, search_spec)
1179                 for search_spec in orm_lookups
1180             )
1181         return queryset, may_have_duplicates
1182 
1183     def get_preserved_filters(self, request):
1184         """
1185         Return the preserved filters querystring.
1186         """
1187         match = request.resolver_match
1188         if self.preserve_filters and match:
1189             current_url = "%s:%s" % (match.app_name, match.url_name)
1190             changelist_url = "admin:%s_%s_changelist" % (
1191                 self.opts.app_label,
1192                 self.opts.model_name,
1193             )
1194             if current_url == changelist_url:
1195                 preserved_filters = request.GET.urlencode()
1196             else:
1197                 preserved_filters = request.GET.get("_changelist_filters")
1198 
1199             if preserved_filters:
1200                 return urlencode({"_changelist_filters": preserved_filters})
1201         return ""
1202 
1203     def construct_change_message(self, request, form, formsets, add=False):
1204         """
1205         Construct a JSON structure describing changes from a changed object.
1206         """
1207         return construct_change_message(form, formsets, add)
1208 
1209     def message_user(
1210         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1211     ):
1212         """
1213         Send a message to the user. The default implementation
1214         posts a message using the django.contrib.messages backend.
1215 
1216         Exposes almost the same API as messages.add_message(), but accepts the
1217         positional arguments in a different order to maintain backwards
1218         compatibility. For convenience, it accepts the `level` argument as
1219         a string rather than the usual level number.
1220         """
1221         if not isinstance(level, int):
1222             # attempt to get the level if passed a string
1223             try:
1224                 level = getattr(messages.constants, level.upper())
1225             except AttributeError:
1226                 levels = messages.constants.DEFAULT_TAGS.values()
1227                 levels_repr = ", ".join("`%s`" % level for level in levels)
1228                 raise ValueError(
1229                     "Bad message level string: `%s`. Possible values are: %s"
1230                     % (level, levels_repr)
1231                 )
1232 
1233         messages.add_message(
1234             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1235         )
1236 
1237     def save_form(self, request, form, change):
1238         """
1239         Given a ModelForm return an unsaved instance. ``change`` is True if
1240         the object is being changed, and False if it's being added.
1241         """
1242         return form.save(commit=False)
1243 
1244     def save_model(self, request, obj, form, change):
1245         """
1246         Given a model instance save it to the database.
1247         """
1248         obj.save()
1249 
1250     def delete_model(self, request, obj):
1251         """
1252         Given a model instance delete it from the database.
1253         """
1254         obj.delete()
1255 
1256     def delete_queryset(self, request, queryset):
1257         """Given a queryset, delete it from the database."""
1258         queryset.delete()
1259 
1260     def save_formset(self, request, form, formset, change):
1261         """
1262         Given an inline formset save it to the database.
1263         """
1264         formset.save()
1265 
1266     def save_related(self, request, form, formsets, change):
1267         """
1268         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1269         list of inline formsets and a boolean value based on whether the
1270         parent is being added or changed, save the related objects to the
1271         database. Note that at this point save_form() and save_model() have
1272         already been called.
1273         """
1274         form.save_m2m()
1275         for formset in formsets:
1276             self.save_formset(request, form, formset, change=change)
1277 
1278     def render_change_form(
1279         self, request, context, add=False, change=False, form_url="", obj=None
1280     ):
1281         app_label = self.opts.app_label
1282         preserved_filters = self.get_preserved_filters(request)
1283         form_url = add_preserved_filters(
1284             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1285         )
1286         view_on_site_url = self.get_view_on_site_url(obj)
1287         has_editable_inline_admin_formsets = False
1288         for inline in context["inline_admin_formsets"]:
1289             if (
1290                 inline.has_add_permission
1291                 or inline.has_change_permission
1292                 or inline.has_delete_permission
1293             ):
1294                 has_editable_inline_admin_formsets = True
1295                 break
1296         context.update(
1297             {
1298                 "add": add,
1299                 "change": change,
1300                 "has_view_permission": self.has_view_permission(request, obj),
1301                 "has_add_permission": self.has_add_permission(request),
1302                 "has_change_permission": self.has_change_permission(request, obj),
1303                 "has_delete_permission": self.has_delete_permission(request, obj),
1304                 "has_editable_inline_admin_formsets": (
1305                     has_editable_inline_admin_formsets
1306                 ),
1307                 "has_file_field": context["adminform"].form.is_multipart()
1308                 or any(
1309                     admin_formset.formset.is_multipart()
1310                     for admin_formset in context["inline_admin_formsets"]
1311                 ),
1312                 "has_absolute_url": view_on_site_url is not None,
1313                 "absolute_url": view_on_site_url,
1314                 "form_url": form_url,
1315                 "opts": self.opts,
1316                 "content_type_id": get_content_type_for_model(self.model).pk,
1317                 "save_as": self.save_as,
1318                 "save_on_top": self.save_on_top,
1319                 "to_field_var": TO_FIELD_VAR,
1320                 "is_popup_var": IS_POPUP_VAR,
1321                 "app_label": app_label,
1322             }
1323         )
1324         if add and self.add_form_template is not None:
1325             form_template = self.add_form_template
1326         else:
1327             form_template = self.change_form_template
1328 
1329         request.current_app = self.admin_site.name
1330 
1331         return TemplateResponse(
1332             request,
1333             form_template
1334             or [
1335                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1336                 "admin/%s/change_form.html" % app_label,
1337                 "admin/change_form.html",
1338             ],
1339             context,
1340         )
1341 
1342     def response_add(self, request, obj, post_url_continue=None):
1343         """
1344         Determine the HttpResponse for the add_view stage.
1345         """
1346         opts = obj._meta
1347         preserved_filters = self.get_preserved_filters(request)
1348         obj_url = reverse(
1349             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1350             args=(quote(obj.pk),),
1351             current_app=self.admin_site.name,
1352         )
1353         # Add a link to the object's change form if the user can edit the obj.
1354         if self.has_change_permission(request, obj):
1355             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1356         else:
1357             obj_repr = str(obj)
1358         msg_dict = {
1359             "name": opts.verbose_name,
1360             "obj": obj_repr,
1361         }
1362         # Here, we distinguish between different save types by checking for
1363         # the presence of keys in request.POST.
1364 
1365         if IS_POPUP_VAR in request.POST:
1366             to_field = request.POST.get(TO_FIELD_VAR)
1367             if to_field:
1368                 attr = str(to_field)
1369             else:
1370                 attr = obj._meta.pk.attname
1371             value = obj.serializable_value(attr)
1372             popup_response_data = json.dumps(
1373                 {
1374                     "value": str(value),
1375                     "obj": str(obj),
1376                 }
1377             )
1378             return TemplateResponse(
1379                 request,
1380                 self.popup_response_template
1381                 or [
1382                     "admin/%s/%s/popup_response.html"
1383                     % (opts.app_label, opts.model_name),
1384                     "admin/%s/popup_response.html" % opts.app_label,
1385                     "admin/popup_response.html",
1386                 ],
1387                 {
1388                     "popup_response_data": popup_response_data,
1389                 },
1390             )
1391 
1392         elif "_continue" in request.POST or (
1393             # Redirecting after "Save as new".
1394             "_saveasnew" in request.POST
1395             and self.save_as_continue
1396             and self.has_change_permission(request, obj)
1397         ):
1398             msg = _("The {name} “{obj}” was added successfully.")
1399             if self.has_change_permission(request, obj):
1400                 msg += " " + _("You may edit it again below.")
1401             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1402             if post_url_continue is None:
1403                 post_url_continue = obj_url
1404             post_url_continue = add_preserved_filters(
1405                 {"preserved_filters": preserved_filters, "opts": opts},
1406                 post_url_continue,
1407             )
1408             return HttpResponseRedirect(post_url_continue)
1409 
1410         elif "_addanother" in request.POST:
1411             msg = format_html(
1412                 _(
1413                     "The {name} “{obj}” was added successfully. You may add another "
1414                     "{name} below."
1415                 ),
1416                 **msg_dict,
1417             )
1418             self.message_user(request, msg, messages.SUCCESS)
1419             redirect_url = request.path
1420             redirect_url = add_preserved_filters(
1421                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1422             )
1423             return HttpResponseRedirect(redirect_url)
1424 
1425         else:
1426             msg = format_html(
1427                 _("The {name} “{obj}” was added successfully."), **msg_dict
1428             )
1429             self.message_user(request, msg, messages.SUCCESS)
1430             return self.response_post_save_add(request, obj)
1431 
1432     def response_change(self, request, obj):
1433         """
1434         Determine the HttpResponse for the change_view stage.
1435         """
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             opts = obj._meta
1439             to_field = request.POST.get(TO_FIELD_VAR)
1440             attr = str(to_field) if to_field else opts.pk.attname
1441             value = request.resolver_match.kwargs["object_id"]
1442             new_value = obj.serializable_value(attr)
1443             popup_response_data = json.dumps(
1444                 {
1445                     "action": "change",
1446                     "value": str(value),
1447                     "obj": str(obj),
1448                     "new_value": str(new_value),
1449                 }
1450             )
1451             return TemplateResponse(
1452                 request,
1453                 self.popup_response_template
1454                 or [
1455                     "admin/%s/%s/popup_response.html"
1456                     % (opts.app_label, opts.model_name),
1457                     "admin/%s/popup_response.html" % opts.app_label,
1458                     "admin/popup_response.html",
1459                 ],
1460                 {
1461                     "popup_response_data": popup_response_data,
1462                 },
1463             )
1464 
1465         opts = self.opts
1466         preserved_filters = self.get_preserved_filters(request)
1467 
1468         msg_dict = {
1469             "name": opts.verbose_name,
1470             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1471         }
1472         if "_continue" in request.POST:
1473             msg = format_html(
1474                 _(
1475                     "The {name} “{obj}” was changed successfully. You may edit it "
1476                     "again below."
1477                 ),
1478                 **msg_dict,
1479             )
1480             self.message_user(request, msg, messages.SUCCESS)
1481             redirect_url = request.path
1482             redirect_url = add_preserved_filters(
1483                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1484             )
1485             return HttpResponseRedirect(redirect_url)
1486 
1487         elif "_saveasnew" in request.POST:
1488             msg = format_html(
1489                 _(
1490                     "The {name} “{obj}” was added successfully. You may edit it again "
1491                     "below."
1492                 ),
1493                 **msg_dict,
1494             )
1495             self.message_user(request, msg, messages.SUCCESS)
1496             redirect_url = reverse(
1497                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1498                 args=(obj.pk,),
1499                 current_app=self.admin_site.name,
1500             )
1501             redirect_url = add_preserved_filters(
1502                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1503             )
1504             return HttpResponseRedirect(redirect_url)
1505 
1506         elif "_addanother" in request.POST:
1507             msg = format_html(
1508                 _(
1509                     "The {name} “{obj}” was changed successfully. You may add another "
1510                     "{name} below."
1511                 ),
1512                 **msg_dict,
1513             )
1514             self.message_user(request, msg, messages.SUCCESS)
1515             redirect_url = reverse(
1516                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1517                 current_app=self.admin_site.name,
1518             )
1519             redirect_url = add_preserved_filters(
1520                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1521             )
1522             return HttpResponseRedirect(redirect_url)
1523 
1524         else:
1525             msg = format_html(
1526                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1527             )
1528             self.message_user(request, msg, messages.SUCCESS)
1529             return self.response_post_save_change(request, obj)
1530 
1531     def _response_post_save(self, request, obj):
1532         if self.has_view_or_change_permission(request):
1533             post_url = reverse(
1534                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1535                 current_app=self.admin_site.name,
1536             )
1537             preserved_filters = self.get_preserved_filters(request)
1538             post_url = add_preserved_filters(
1539                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1540             )
1541         else:
1542             post_url = reverse("admin:index", current_app=self.admin_site.name)
1543         return HttpResponseRedirect(post_url)
1544 
1545     def response_post_save_add(self, request, obj):
1546         """
1547         Figure out where to redirect after the 'Save' button has been pressed
1548         when adding a new object.
1549         """
1550         return self._response_post_save(request, obj)
1551 
1552     def response_post_save_change(self, request, obj):
1553         """
1554         Figure out where to redirect after the 'Save' button has been pressed
1555         when editing an existing object.
1556         """
1557         return self._response_post_save(request, obj)
1558 
1559     def response_action(self, request, queryset):
1560         """
1561         Handle an admin action. This is called if a request is POSTed to the
1562         changelist; it returns an HttpResponse if the action was handled, and
1563         None otherwise.
1564         """
1565 
1566         # There can be multiple action forms on the page (at the top
1567         # and bottom of the change list, for example). Get the action
1568         # whose button was pushed.
1569         try:
1570             action_index = int(request.POST.get("index", 0))
1571         except ValueError:
1572             action_index = 0
1573 
1574         # Construct the action form.
1575         data = request.POST.copy()
1576         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1577         data.pop("index", None)
1578 
1579         # Use the action whose button was pushed
1580         try:
1581             data.update({"action": data.getlist("action")[action_index]})
1582         except IndexError:
1583             # If we didn't get an action from the chosen form that's invalid
1584             # POST data, so by deleting action it'll fail the validation check
1585             # below. So no need to do anything here
1586             pass
1587 
1588         action_form = self.action_form(data, auto_id=None)
1589         action_form.fields["action"].choices = self.get_action_choices(request)
1590 
1591         # If the form's valid we can handle the action.
1592         if action_form.is_valid():
1593             action = action_form.cleaned_data["action"]
1594             select_across = action_form.cleaned_data["select_across"]
1595             func = self.get_actions(request)[action][0]
1596 
1597             # Get the list of selected PKs. If nothing's selected, we can't
1598             # perform an action on it, so bail. Except we want to perform
1599             # the action explicitly on all objects.
1600             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1601             if not selected and not select_across:
1602                 # Reminder that something needs to be selected or nothing will happen
1603                 msg = _(
1604                     "Items must be selected in order to perform "
1605                     "actions on them. No items have been changed."
1606                 )
1607                 self.message_user(request, msg, messages.WARNING)
1608                 return None
1609 
1610             if not select_across:
1611                 # Perform the action only on the selected objects
1612                 queryset = queryset.filter(pk__in=selected)
1613 
1614             response = func(self, request, queryset)
1615 
1616             # Actions may return an HttpResponse-like object, which will be
1617             # used as the response from the POST. If not, we'll be a good
1618             # little HTTP citizen and redirect back to the changelist page.
1619             if isinstance(response, HttpResponseBase):
1620                 return response
1621             else:
1622                 return HttpResponseRedirect(request.get_full_path())
1623         else:
1624             msg = _("No action selected.")
1625             self.message_user(request, msg, messages.WARNING)
1626             return None
1627 
1628     def response_delete(self, request, obj_display, obj_id):
1629         """
1630         Determine the HttpResponse for the delete_view stage.
1631         """
1632         if IS_POPUP_VAR in request.POST:
1633             popup_response_data = json.dumps(
1634                 {
1635                     "action": "delete",
1636                     "value": str(obj_id),
1637                 }
1638             )
1639             return TemplateResponse(
1640                 request,
1641                 self.popup_response_template
1642                 or [
1643                     "admin/%s/%s/popup_response.html"
1644                     % (self.opts.app_label, self.opts.model_name),
1645                     "admin/%s/popup_response.html" % self.opts.app_label,
1646                     "admin/popup_response.html",
1647                 ],
1648                 {
1649                     "popup_response_data": popup_response_data,
1650                 },
1651             )
1652 
1653         self.message_user(
1654             request,
1655             _("The %(name)s “%(obj)s” was deleted successfully.")
1656             % {
1657                 "name": self.opts.verbose_name,
1658                 "obj": obj_display,
1659             },
1660             messages.SUCCESS,
1661         )
1662 
1663         if self.has_change_permission(request, None):
1664             post_url = reverse(
1665                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1666                 current_app=self.admin_site.name,
1667             )
1668             preserved_filters = self.get_preserved_filters(request)
1669             post_url = add_preserved_filters(
1670                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1671             )
1672         else:
1673             post_url = reverse("admin:index", current_app=self.admin_site.name)
1674         return HttpResponseRedirect(post_url)
1675 
1676     def render_delete_form(self, request, context):
1677         app_label = self.opts.app_label
1678 
1679         request.current_app = self.admin_site.name
1680         context.update(
1681             to_field_var=TO_FIELD_VAR,
1682             is_popup_var=IS_POPUP_VAR,
1683             media=self.media,
1684         )
1685 
1686         return TemplateResponse(
1687             request,
1688             self.delete_confirmation_template
1689             or [
1690                 "admin/{}/{}/delete_confirmation.html".format(
1691                     app_label, self.opts.model_name
1692                 ),
1693                 "admin/{}/delete_confirmation.html".format(app_label),
1694                 "admin/delete_confirmation.html",
1695             ],
1696             context,
1697         )
1698 
1699     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1700         # Edit permissions on parent model are required for editable inlines.
1701         can_edit_parent = (
1702             self.has_change_permission(request, obj)
1703             if obj
1704             else self.has_add_permission(request)
1705         )
1706         inline_admin_formsets = []
1707         for inline, formset in zip(inline_instances, formsets):
1708             fieldsets = list(inline.get_fieldsets(request, obj))
1709             readonly = list(inline.get_readonly_fields(request, obj))
1710             if can_edit_parent:
1711                 has_add_permission = inline.has_add_permission(request, obj)
1712                 has_change_permission = inline.has_change_permission(request, obj)
1713                 has_delete_permission = inline.has_delete_permission(request, obj)
1714             else:
1715                 # Disable all edit-permissions, and override formset settings.
1716                 has_add_permission = (
1717                     has_change_permission
1718                 ) = has_delete_permission = False
1719                 formset.extra = formset.max_num = 0
1720             has_view_permission = inline.has_view_permission(request, obj)
1721             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1722             inline_admin_formset = helpers.InlineAdminFormSet(
1723                 inline,
1724                 formset,
1725                 fieldsets,
1726                 prepopulated,
1727                 readonly,
1728                 model_admin=self,
1729                 has_add_permission=has_add_permission,
1730                 has_change_permission=has_change_permission,
1731                 has_delete_permission=has_delete_permission,
1732                 has_view_permission=has_view_permission,
1733             )
1734             inline_admin_formsets.append(inline_admin_formset)
1735         return inline_admin_formsets
1736 
1737     def get_changeform_initial_data(self, request):
1738         """
1739         Get the initial form data from the request's GET params.
1740         """
1741         initial = dict(request.GET.items())
1742         for k in initial:
1743             try:
1744                 f = self.opts.get_field(k)
1745             except FieldDoesNotExist:
1746                 continue
1747             # We have to special-case M2Ms as a list of comma-separated PKs.
1748             if isinstance(f, models.ManyToManyField):
1749                 initial[k] = initial[k].split(",")
1750         return initial
1751 
1752     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1753         """
1754         Create a message informing the user that the object doesn't exist
1755         and return a redirect to the admin index page.
1756         """
1757         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1758             "name": opts.verbose_name,
1759             "key": unquote(object_id),
1760         }
1761         self.message_user(request, msg, messages.WARNING)
1762         url = reverse("admin:index", current_app=self.admin_site.name)
1763         return HttpResponseRedirect(url)
1764 
1765     @csrf_protect_m
1766     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1767         with transaction.atomic(using=router.db_for_write(self.model)):
1768             return self._changeform_view(request, object_id, form_url, extra_context)
1769 
1770     def _changeform_view(self, request, object_id, form_url, extra_context):
1771         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1772         if to_field and not self.to_field_allowed(request, to_field):
1773             raise DisallowedModelAdminToField(
1774                 "The field %s cannot be referenced." % to_field
1775             )
1776 
1777         if request.method == "POST" and "_saveasnew" in request.POST:
1778             object_id = None
1779 
1780         add = object_id is None
1781 
1782         if add:
1783             if not self.has_add_permission(request):
1784                 raise PermissionDenied
1785             obj = None
1786 
1787         else:
1788             obj = self.get_object(request, unquote(object_id), to_field)
1789 
1790             if request.method == "POST":
1791                 if not self.has_change_permission(request, obj):
1792                     raise PermissionDenied
1793             else:
1794                 if not self.has_view_or_change_permission(request, obj):
1795                     raise PermissionDenied
1796 
1797             if obj is None:
1798                 return self._get_obj_does_not_exist_redirect(
1799                     request, self.opts, object_id
1800                 )
1801 
1802         fieldsets = self.get_fieldsets(request, obj)
1803         ModelForm = self.get_form(
1804             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1805         )
1806         if request.method == "POST":
1807             form = ModelForm(request.POST, request.FILES, instance=obj)
1808             formsets, inline_instances = self._create_formsets(
1809                 request,
1810                 form.instance,
1811                 change=not add,
1812             )
1813             form_validated = form.is_valid()
1814             if form_validated:
1815                 new_object = self.save_form(request, form, change=not add)
1816             else:
1817                 new_object = form.instance
1818             if all_valid(formsets) and form_validated:
1819                 self.save_model(request, new_object, form, not add)
1820                 self.save_related(request, form, formsets, not add)
1821                 change_message = self.construct_change_message(
1822                     request, form, formsets, add
1823                 )
1824                 if add:
1825                     self.log_addition(request, new_object, change_message)
1826                     return self.response_add(request, new_object)
1827                 else:
1828                     self.log_change(request, new_object, change_message)
1829                     return self.response_change(request, new_object)
1830             else:
1831                 form_validated = False
1832         else:
1833             if add:
1834                 initial = self.get_changeform_initial_data(request)
1835                 form = ModelForm(initial=initial)
1836                 formsets, inline_instances = self._create_formsets(
1837                     request, form.instance, change=False
1838                 )
1839             else:
1840                 form = ModelForm(instance=obj)
1841                 formsets, inline_instances = self._create_formsets(
1842                     request, obj, change=True
1843                 )
1844 
1845         if not add and not self.has_change_permission(request, obj):
1846             readonly_fields = flatten_fieldsets(fieldsets)
1847         else:
1848             readonly_fields = self.get_readonly_fields(request, obj)
1849         admin_form = helpers.AdminForm(
1850             form,
1851             list(fieldsets),
1852             # Clear prepopulated fields on a view-only form to avoid a crash.
1853             self.get_prepopulated_fields(request, obj)
1854             if add or self.has_change_permission(request, obj)
1855             else {},
1856             readonly_fields,
1857             model_admin=self,
1858         )
1859         media = self.media + admin_form.media
1860 
1861         inline_formsets = self.get_inline_formsets(
1862             request, formsets, inline_instances, obj
1863         )
1864         for inline_formset in inline_formsets:
1865             media += inline_formset.media
1866 
1867         if add:
1868             title = _("Add %s")
1869         elif self.has_change_permission(request, obj):
1870             title = _("Change %s")
1871         else:
1872             title = _("View %s")
1873         context = {
1874             **self.admin_site.each_context(request),
1875             "title": title % self.opts.verbose_name,
1876             "subtitle": str(obj) if obj else None,
1877             "adminform": admin_form,
1878             "object_id": object_id,
1879             "original": obj,
1880             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1881             "to_field": to_field,
1882             "media": media,
1883             "inline_admin_formsets": inline_formsets,
1884             "errors": helpers.AdminErrorList(form, formsets),
1885             "preserved_filters": self.get_preserved_filters(request),
1886         }
1887 
1888         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1889         # previously chosen to prevent the interface from getting confusing.
1890         if (
1891             request.method == "POST"
1892             and not form_validated
1893             and "_saveasnew" in request.POST
1894         ):
1895             context["show_save"] = False
1896             context["show_save_and_continue"] = False
1897             # Use the change template instead of the add template.
1898             add = False
1899 
1900         context.update(extra_context or {})
1901 
1902         return self.render_change_form(
1903             request, context, add=add, change=not add, obj=obj, form_url=form_url
1904         )
1905 
1906     def add_view(self, request, form_url="", extra_context=None):
1907         return self.changeform_view(request, None, form_url, extra_context)
1908 
1909     def change_view(self, request, object_id, form_url="", extra_context=None):
1910         return self.changeform_view(request, object_id, form_url, extra_context)
1911 
1912     def _get_edited_object_pks(self, request, prefix):
1913         """Return POST data values of list_editable primary keys."""
1914         pk_pattern = re.compile(
1915             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1916         )
1917         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1918 
1919     def _get_list_editable_queryset(self, request, prefix):
1920         """
1921         Based on POST data, return a queryset of the objects that were edited
1922         via list_editable.
1923         """
1924         object_pks = self._get_edited_object_pks(request, prefix)
1925         queryset = self.get_queryset(request)
1926         validate = queryset.model._meta.pk.to_python
1927         try:
1928             for pk in object_pks:
1929                 validate(pk)
1930         except ValidationError:
1931             # Disable the optimization if the POST data was tampered with.
1932             return queryset
1933         return queryset.filter(pk__in=object_pks)
1934 
1935     @csrf_protect_m
1936     def changelist_view(self, request, extra_context=None):
1937         """
1938         The 'change list' admin view for this model.
1939         """
1940         from django.contrib.admin.views.main import ERROR_FLAG
1941 
1942         app_label = self.opts.app_label
1943         if not self.has_view_or_change_permission(request):
1944             raise PermissionDenied
1945 
1946         try:
1947             cl = self.get_changelist_instance(request)
1948         except IncorrectLookupParameters:
1949             # Wacky lookup parameters were given, so redirect to the main
1950             # changelist page, without parameters, and pass an 'invalid=1'
1951             # parameter via the query string. If wacky parameters were given
1952             # and the 'invalid=1' parameter was already in the query string,
1953             # something is screwed up with the database, so display an error
1954             # page.
1955             if ERROR_FLAG in request.GET:
1956                 return SimpleTemplateResponse(
1957                     "admin/invalid_setup.html",
1958                     {
1959                         "title": _("Database error"),
1960                     },
1961                 )
1962             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1963 
1964         # If the request was POSTed, this might be a bulk action or a bulk
1965         # edit. Try to look up an action or confirmation first, but if this
1966         # isn't an action the POST will fall through to the bulk edit check,
1967         # below.
1968         action_failed = False
1969         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1970 
1971         actions = self.get_actions(request)
1972         # Actions with no confirmation
1973         if (
1974             actions
1975             and request.method == "POST"
1976             and "index" in request.POST
1977             and "_save" not in request.POST
1978         ):
1979             if selected:
1980                 response = self.response_action(
1981                     request, queryset=cl.get_queryset(request)
1982                 )
1983                 if response:
1984                     return response
1985                 else:
1986                     action_failed = True
1987             else:
1988                 msg = _(
1989                     "Items must be selected in order to perform "
1990                     "actions on them. No items have been changed."
1991                 )
1992                 self.message_user(request, msg, messages.WARNING)
1993                 action_failed = True
1994 
1995         # Actions with confirmation
1996         if (
1997             actions
1998             and request.method == "POST"
1999             and helpers.ACTION_CHECKBOX_NAME in request.POST
2000             and "index" not in request.POST
2001             and "_save" not in request.POST
2002         ):
2003             if selected:
2004                 response = self.response_action(
2005                     request, queryset=cl.get_queryset(request)
2006                 )
2007                 if response:
2008                     return response
2009                 else:
2010                     action_failed = True
2011 
2012         if action_failed:
2013             # Redirect back to the changelist page to avoid resubmitting the
2014             # form if the user refreshes the browser or uses the "No, take
2015             # me back" button on the action confirmation page.
2016             return HttpResponseRedirect(request.get_full_path())
2017 
2018         # If we're allowing changelist editing, we need to construct a formset
2019         # for the changelist given all the fields to be edited. Then we'll
2020         # use the formset to validate/process POSTed data.
2021         formset = cl.formset = None
2022 
2023         # Handle POSTed bulk-edit data.
2024         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2025             if not self.has_change_permission(request):
2026                 raise PermissionDenied
2027             FormSet = self.get_changelist_formset(request)
2028             modified_objects = self._get_list_editable_queryset(
2029                 request, FormSet.get_default_prefix()
2030             )
2031             formset = cl.formset = FormSet(
2032                 request.POST, request.FILES, queryset=modified_objects
2033             )
2034             if formset.is_valid():
2035                 changecount = 0
2036                 with transaction.atomic(using=router.db_for_write(self.model)):
2037                     for form in formset.forms:
2038                         if form.has_changed():
2039                             obj = self.save_form(request, form, change=True)
2040                             self.save_model(request, obj, form, change=True)
2041                             self.save_related(request, form, formsets=[], change=True)
2042                             change_msg = self.construct_change_message(
2043                                 request, form, None
2044                             )
2045                             self.log_change(request, obj, change_msg)
2046                             changecount += 1
2047                 if changecount:
2048                     msg = ngettext(
2049                         "%(count)s %(name)s was changed successfully.",
2050                         "%(count)s %(name)s were changed successfully.",
2051                         changecount,
2052                     ) % {
2053                         "count": changecount,
2054                         "name": model_ngettext(self.opts, changecount),
2055                     }
2056                     self.message_user(request, msg, messages.SUCCESS)
2057 
2058                 return HttpResponseRedirect(request.get_full_path())
2059 
2060         # Handle GET -- construct a formset for display.
2061         elif cl.list_editable and self.has_change_permission(request):
2062             FormSet = self.get_changelist_formset(request)
2063             formset = cl.formset = FormSet(queryset=cl.result_list)
2064 
2065         # Build the list of media to be used by the formset.
2066         if formset:
2067             media = self.media + formset.media
2068         else:
2069             media = self.media
2070 
2071         # Build the action form and populate it with available actions.
2072         if actions:
2073             action_form = self.action_form(auto_id=None)
2074             action_form.fields["action"].choices = self.get_action_choices(request)
2075             media += action_form.media
2076         else:
2077             action_form = None
2078 
2079         selection_note_all = ngettext(
2080             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2081         )
2082 
2083         context = {
2084             **self.admin_site.each_context(request),
2085             "module_name": str(self.opts.verbose_name_plural),
2086             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2087             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2088             "title": cl.title,
2089             "subtitle": None,
2090             "is_popup": cl.is_popup,
2091             "to_field": cl.to_field,
2092             "cl": cl,
2093             "media": media,
2094             "has_add_permission": self.has_add_permission(request),
2095             "opts": cl.opts,
2096             "action_form": action_form,
2097             "actions_on_top": self.actions_on_top,
2098             "actions_on_bottom": self.actions_on_bottom,
2099             "actions_selection_counter": self.actions_selection_counter,
2100             "preserved_filters": self.get_preserved_filters(request),
2101             **(extra_context or {}),
2102         }
2103 
2104         request.current_app = self.admin_site.name
2105 
2106         return TemplateResponse(
2107             request,
2108             self.change_list_template
2109             or [
2110                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2111                 "admin/%s/change_list.html" % app_label,
2112                 "admin/change_list.html",
2113             ],
2114             context,
2115         )
2116 
2117     def get_deleted_objects(self, objs, request):
2118         """
2119         Hook for customizing the delete process for the delete view and the
2120         "delete selected" action.
2121         """
2122         return get_deleted_objects(objs, request, self.admin_site)
2123 
2124     @csrf_protect_m
2125     def delete_view(self, request, object_id, extra_context=None):
2126         with transaction.atomic(using=router.db_for_write(self.model)):
2127             return self._delete_view(request, object_id, extra_context)
2128 
2129     def _delete_view(self, request, object_id, extra_context):
2130         "The 'delete' admin view for this model."
2131         app_label = self.opts.app_label
2132 
2133         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2134         if to_field and not self.to_field_allowed(request, to_field):
2135             raise DisallowedModelAdminToField(
2136                 "The field %s cannot be referenced." % to_field
2137             )
2138 
2139         obj = self.get_object(request, unquote(object_id), to_field)
2140 
2141         if not self.has_delete_permission(request, obj):
2142             raise PermissionDenied
2143 
2144         if obj is None:
2145             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2146 
2147         # Populate deleted_objects, a data structure of all related objects that
2148         # will also be deleted.
2149         (
2150             deleted_objects,
2151             model_count,
2152             perms_needed,
2153             protected,
2154         ) = self.get_deleted_objects([obj], request)
2155 
2156         if request.POST and not protected:  # The user has confirmed the deletion.
2157             if perms_needed:
2158                 raise PermissionDenied
2159             obj_display = str(obj)
2160             attr = str(to_field) if to_field else self.opts.pk.attname
2161             obj_id = obj.serializable_value(attr)
2162             self.log_deletion(request, obj, obj_display)
2163             self.delete_model(request, obj)
2164 
2165             return self.response_delete(request, obj_display, obj_id)
2166 
2167         object_name = str(self.opts.verbose_name)
2168 
2169         if perms_needed or protected:
2170             title = _("Cannot delete %(name)s") % {"name": object_name}
2171         else:
2172             title = _("Are you sure?")
2173 
2174         context = {
2175             **self.admin_site.each_context(request),
2176             "title": title,
2177             "subtitle": None,
2178             "object_name": object_name,
2179             "object": obj,
2180             "deleted_objects": deleted_objects,
2181             "model_count": dict(model_count).items(),
2182             "perms_lacking": perms_needed,
2183             "protected": protected,
2184             "opts": self.opts,
2185             "app_label": app_label,
2186             "preserved_filters": self.get_preserved_filters(request),
2187             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2188             "to_field": to_field,
2189             **(extra_context or {}),
2190         }
2191 
2192         return self.render_delete_form(request, context)
2193 
2194     def history_view(self, request, object_id, extra_context=None):
2195         "The 'history' admin view for this model."
2196         from django.contrib.admin.models import LogEntry
2197         from django.contrib.admin.views.main import PAGE_VAR
2198 
2199         # First check if the user can see this history.
2200         model = self.model
2201         obj = self.get_object(request, unquote(object_id))
2202         if obj is None:
2203             return self._get_obj_does_not_exist_redirect(
2204                 request, model._meta, object_id
2205             )
2206 
2207         if not self.has_view_or_change_permission(request, obj):
2208             raise PermissionDenied
2209 
2210         # Then get the history for this object.
2211         app_label = self.opts.app_label
2212         action_list = (
2213             LogEntry.objects.filter(
2214                 object_id=unquote(object_id),
2215                 content_type=get_content_type_for_model(model),
2216             )
2217             .select_related()
2218             .order_by("action_time")
2219         )
2220 
2221         paginator = self.get_paginator(request, action_list, 100)
2222         page_number = request.GET.get(PAGE_VAR, 1)
2223         page_obj = paginator.get_page(page_number)
2224         page_range = paginator.get_elided_page_range(page_obj.number)
2225 
2226         context = {
2227             **self.admin_site.each_context(request),
2228             "title": _("Change history: %s") % obj,
2229             "subtitle": None,
2230             "action_list": page_obj,
2231             "page_range": page_range,
2232             "page_var": PAGE_VAR,
2233             "pagination_required": paginator.count > 100,
2234             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2235             "object": obj,
2236             "opts": self.opts,
2237             "preserved_filters": self.get_preserved_filters(request),
2238             **(extra_context or {}),
2239         }
2240 
2241         request.current_app = self.admin_site.name
2242 
2243         return TemplateResponse(
2244             request,
2245             self.object_history_template
2246             or [
2247                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2248                 "admin/%s/object_history.html" % app_label,
2249                 "admin/object_history.html",
2250             ],
2251             context,
2252         )
2253 
2254     def get_formset_kwargs(self, request, obj, inline, prefix):
2255         formset_params = {
2256             "instance": obj,
2257             "prefix": prefix,
2258             "queryset": inline.get_queryset(request),
2259         }
2260         if request.method == "POST":
2261             formset_params.update(
2262                 {
2263                     "data": request.POST.copy(),
2264                     "files": request.FILES,
2265                     "save_as_new": "_saveasnew" in request.POST,
2266                 }
2267             )
2268         return formset_params
2269 
2270     def _create_formsets(self, request, obj, change):
2271         "Helper function to generate formsets for add/change_view."
2272         formsets = []
2273         inline_instances = []
2274         prefixes = {}
2275         get_formsets_args = [request]
2276         if change:
2277             get_formsets_args.append(obj)
2278         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2279             prefix = FormSet.get_default_prefix()
2280             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2281             if prefixes[prefix] != 1 or not prefix:
2282                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2283             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2284             formset = FormSet(**formset_params)
2285 
2286             def user_deleted_form(request, obj, formset, index, inline):
2287                 """Return whether or not the user deleted the form."""
2288                 return (
2289                     inline.has_delete_permission(request, obj)
2290                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2291                 )
2292 
2293             # Bypass validation of each view-only inline form (since the form's
2294             # data won't be in request.POST), unless the form was deleted.
2295             if not inline.has_change_permission(request, obj if change else None):
2296                 for index, form in enumerate(formset.initial_forms):
2297                     if user_deleted_form(request, obj, formset, index, inline):
2298                         continue
2299                     form._errors = {}
2300                     form.cleaned_data = form.initial
2301             formsets.append(formset)
2302             inline_instances.append(inline)
2303         return formsets, inline_instances

</code><intended_behavior>Add a new method or enhance an existing system check within ModelAdmin to validate the use of filter_horizontal or filter_vertical. This new check should iterate over the model fields to identify any ManyToManyField using a custom through model if filter_horizontal or filter_vertical are configured. If such a case is detected, raise a system check error warning the developer that filter_horizontal and filter_vertical cannot be used with ManyToManyField instances that have a custom through model. This maintains existing functionality by introducing a validation step that improves developer awareness and debugging efficiency.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>check</method>
<code>
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]

</code><intended_behavior>Extend the check method of ManyToManyField to include a specific validation for its usage within admin class configurations that utilize filter_horizontal or filter_vertical. While it's not directly accessing the admin configurations in this layer, it can include a warning or documentation hint suggesting that developers ensure compatibility with filter_horizontal and filter_vertical when using a custom through model. This change would indirectly address the issue by guiding developers during model field configuration, although the primary solution would be more direct checks within the admin framework as specified in Bug Location 1.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:02:16.545 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:02:16.545 | INFO     | Search-only: skipping patch selection
2025-10-15 07:02:16.685 | INFO     | Task django__django-16983 completed successfully.
2025-10-15 07:02:16.685 | INFO     | No patch generated. You can try running ACR again.
