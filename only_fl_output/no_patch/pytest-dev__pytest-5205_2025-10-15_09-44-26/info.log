2025-10-15 09:44:26.339 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 09:44:28.212 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=822, output_tokens=12, cost=0.008580
2025-10-15 09:44:49.982 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1002, output_tokens=738, cost=0.032160
2025-10-15 09:44:51.130 | INFO     | registered non reproducing test 0
2025-10-15 09:45:10.471 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2451, output_tokens=738, cost=0.046650
2025-10-15 09:45:11.592 | INFO     | registered non reproducing test 1
2025-10-15 09:45:33.863 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2306, output_tokens=819, cost=0.047630
2025-10-15 09:45:34.985 | INFO     | registered non reproducing test 2
2025-10-15 09:45:34.985 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 09:45:34.992 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:45:47.082 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1117, output_tokens=462, cost=0.025030
2025-10-15 09:45:47.093 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:45:52.262 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=816, output_tokens=123, cost=0.011850
2025-10-15 09:45:52.264 | DEBUG    | Extracted a valid json.
2025-10-15 09:45:52.264 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"junitxml\")",
        "search_class_in_file(\"TestSuite\", \"junitxml.py\")",
        "search_class_in_file(\"TestCase\", \"junitxml.py\")",
        "search_method(\"record_property\")",
        "search_method_in_file(\"record_property\", \"junitxml.py\")",
        "search_code(\"<properties>\")",
        "search_code_in_file(\"<testcase>\", \"junitxml.py\")",
        "search_code(\"record-property\")"
    ],
    "bug_locations": []
}
2025-10-15 09:45:52.306 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:45:52.307 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:46:10.533 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2344, output_tokens=677, cost=0.043750
2025-10-15 09:46:10.546 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:46:19.075 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3237, output_tokens=270, cost=0.040470
2025-10-15 09:46:19.082 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:46:24.428 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=624, output_tokens=107, cost=0.009450
2025-10-15 09:46:24.429 | DEBUG    | Extracted a valid json.
2025-10-15 09:46:24.429 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"add_property\", \"junitxml.py\")",
        "search_code_in_file(\"ElementTree.Element\", \"junitxml.py\")",
        "search_code_in_file(\"<testsuite>\", \"junitxml.py\")",
        "search_code_in_file(\"<testcase>\", \"junitxml.py\")",
        "search_method_in_file(\"_generate_xml\", \"junitxml.py\")"
    ],
    "bug_locations": []
}
2025-10-15 09:46:24.441 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:46:24.442 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:46:41.667 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3905, output_tokens=614, cost=0.057470
2025-10-15 09:46:41.679 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:46:57.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4735, output_tokens=564, cost=0.064270
2025-10-15 09:46:57.149 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:47:11.332 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=918, output_tokens=338, cost=0.019320
2025-10-15 09:47:11.333 | DEBUG    | Extracted a valid json.
2025-10-15 09:47:11.333 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/junitxml.py",
            "class": "_NodeReporter",
            "method": "add_property",
            "intended_behavior": "This method correctly collects properties to be included in the report, but the bug isn't in the collection of properties—it's in how and where these properties are added to the XML structure. However, because add_property is part of the process that eventually leads to the misplacement, the intended behavior adjustment is not directly in this method but in ensuring that properties collected here are placed within <testsuite> elements when the XML document is being constructed. Thus, this location itself might not need a change in code but offers context to where adjustments in XML generation are needed."
        },
        {
            "file": "src/_pytest/junitxml.py",
            "class": "",
            "method": "",
            "intended_behavior": "There needs to be a review and possibly a restructuring of how the JUnit XML document is assembled, especially in relation to accommodating record_property data according to the JUnit schema. Specifically, the code responsible for generating or assembling the XML document should: Ensure that <properties> elements gathered via add_property are included within the <testsuite> element, not inside individual <testcase> elements. This could involve adjusting the logic that appends properties to the XML structure, maybe by introducing a new method or modifying existing ones to accurately place properties as per schema requirements. Preserve existing functionality for test case reporting, ensuring that all other aspects of the JUnit XML report remain valid and unchanged."
        }
    ]
}
2025-10-15 09:47:11.340 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/junitxml.py</file>
<class>_NodeReporter</class>
<method>add_property</method>
<code>
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))

</code><intended_behavior>This method correctly collects properties to be included in the report, but the bug isn't in the collection of properties—it's in how and where these properties are added to the XML structure. However, because add_property is part of the process that eventually leads to the misplacement, the intended behavior adjustment is not directly in this method but in ensuring that properties collected here are placed within <testsuite> elements when the XML document is being constructed. Thus, this location itself might not need a change in code but offers context to where adjustments in XML generation are needed.</intended_behavior>, <file>src/_pytest/junitxml.py</file>
<class>_NodeReporter</class>
<method>None</method>
<code>
91 class _NodeReporter(object):
92     def __init__(self, nodeid, xml):
93         self.id = nodeid
94         self.xml = xml
95         self.add_stats = self.xml.add_stats
96         self.family = self.xml.family
97         self.duration = 0
98         self.properties = []
99         self.nodes = []
100         self.testcase = None
101         self.attrs = {}
102 
103     def append(self, node):
104         self.xml.add_stats(type(node).__name__)
105         self.nodes.append(node)
106 
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))
109 
110     def add_attribute(self, name, value):
111         self.attrs[str(name)] = bin_xml_escape(value)
112 
113     def make_properties_node(self):
114         """Return a Junit node containing custom properties, if any.
115         """
116         if self.properties:
117             return Junit.properties(
118                 [
119                     Junit.property(name=name, value=value)
120                     for name, value in self.properties
121                 ]
122             )
123         return ""
124 
125     def record_testreport(self, testreport):
126         assert not self.testcase
127         names = mangle_test_address(testreport.nodeid)
128         existing_attrs = self.attrs
129         classnames = names[:-1]
130         if self.xml.prefix:
131             classnames.insert(0, self.xml.prefix)
132         attrs = {
133             "classname": ".".join(classnames),
134             "name": bin_xml_escape(names[-1]),
135             "file": testreport.location[0],
136         }
137         if testreport.location[1] is not None:
138             attrs["line"] = testreport.location[1]
139         if hasattr(testreport, "url"):
140             attrs["url"] = testreport.url
141         self.attrs = attrs
142         self.attrs.update(existing_attrs)  # restore any user-defined attributes
143 
144         # Preserve legacy testcase behavior
145         if self.family == "xunit1":
146             return
147 
148         # Filter out attributes not permitted by this test family.
149         # Including custom attributes because they are not valid here.
150         temp_attrs = {}
151         for key in self.attrs.keys():
152             if key in families[self.family]["testcase"]:
153                 temp_attrs[key] = self.attrs[key]
154         self.attrs = temp_attrs
155 
156     def to_xml(self):
157         testcase = Junit.testcase(time="%.3f" % self.duration, **self.attrs)
158         testcase.append(self.make_properties_node())
159         for node in self.nodes:
160             testcase.append(node)
161         return testcase
162 
163     def _add_simple(self, kind, message, data=None):
164         data = bin_xml_escape(data)
165         node = kind(data, message=message)
166         self.append(node)
167 
168     def write_captured_output(self, report):
169         content_out = report.capstdout
170         content_log = report.caplog
171         content_err = report.capstderr
172 
173         if content_log or content_out:
174             if content_log and self.xml.logging == "system-out":
175                 if content_out:
176                     # syncing stdout and the log-output is not done yet. It's
177                     # probably not worth the effort. Therefore, first the captured
178                     # stdout is shown and then the captured logs.
179                     content = "\n".join(
180                         [
181                             " Captured Stdout ".center(80, "-"),
182                             content_out,
183                             "",
184                             " Captured Log ".center(80, "-"),
185                             content_log,
186                         ]
187                     )
188                 else:
189                     content = content_log
190             else:
191                 content = content_out
192 
193             if content:
194                 tag = getattr(Junit, "system-out")
195                 self.append(tag(bin_xml_escape(content)))
196 
197         if content_log or content_err:
198             if content_log and self.xml.logging == "system-err":
199                 if content_err:
200                     content = "\n".join(
201                         [
202                             " Captured Stderr ".center(80, "-"),
203                             content_err,
204                             "",
205                             " Captured Log ".center(80, "-"),
206                             content_log,
207                         ]
208                     )
209                 else:
210                     content = content_log
211             else:
212                 content = content_err
213 
214             if content:
215                 tag = getattr(Junit, "system-err")
216                 self.append(tag(bin_xml_escape(content)))
217 
218     def append_pass(self, report):
219         self.add_stats("passed")
220 
221     def append_failure(self, report):
222         # msg = str(report.longrepr.reprtraceback.extraline)
223         if hasattr(report, "wasxfail"):
224             self._add_simple(Junit.skipped, "xfail-marked test passes unexpectedly")
225         else:
226             if hasattr(report.longrepr, "reprcrash"):
227                 message = report.longrepr.reprcrash.message
228             elif isinstance(report.longrepr, six.string_types):
229                 message = report.longrepr
230             else:
231                 message = str(report.longrepr)
232             message = bin_xml_escape(message)
233             fail = Junit.failure(message=message)
234             fail.append(bin_xml_escape(report.longrepr))
235             self.append(fail)
236 
237     def append_collect_error(self, report):
238         # msg = str(report.longrepr.reprtraceback.extraline)
239         self.append(
240             Junit.error(bin_xml_escape(report.longrepr), message="collection failure")
241         )
242 
243     def append_collect_skipped(self, report):
244         self._add_simple(Junit.skipped, "collection skipped", report.longrepr)
245 
246     def append_error(self, report):
247         if report.when == "teardown":
248             msg = "test teardown failure"
249         else:
250             msg = "test setup failure"
251         self._add_simple(Junit.error, msg, report.longrepr)
252 
253     def append_skipped(self, report):
254         if hasattr(report, "wasxfail"):
255             xfailreason = report.wasxfail
256             if xfailreason.startswith("reason: "):
257                 xfailreason = xfailreason[8:]
258             self.append(
259                 Junit.skipped(
260                     "", type="pytest.xfail", message=bin_xml_escape(xfailreason)
261                 )
262             )
263         else:
264             filename, lineno, skipreason = report.longrepr
265             if skipreason.startswith("Skipped: "):
266                 skipreason = skipreason[9:]
267             details = "%s:%s: %s" % (filename, lineno, skipreason)
268 
269             self.append(
270                 Junit.skipped(
271                     bin_xml_escape(details),
272                     type="pytest.skip",
273                     message=bin_xml_escape(skipreason),
274                 )
275             )
276             self.write_captured_output(report)
277 
278     def finalize(self):
279         data = self.to_xml().unicode(indent=0)
280         self.__dict__.clear()
281         self.to_xml = lambda: py.xml.raw(data)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>src/_pytest/junitxml.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     report test results in JUnit-XML format,
3     for use with Jenkins and build integration servers.
4 
5 
6 Based on initial code from Ross Lawley.
7 
8 Output conforms to https://github.com/jenkinsci/xunit-plugin/blob/master/
9 src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd
10 """
11 from __future__ import absolute_import
12 from __future__ import division
13 from __future__ import print_function
14 
15 import functools
16 import os
17 import re
18 import sys
19 import time
20 
21 import py
22 import six
23 
24 import pytest
25 from _pytest import nodes
26 from _pytest.config import filename_arg
27 
28 # Python 2.X and 3.X compatibility
29 if sys.version_info[0] < 3:
30     from codecs import open
31 
32 
33 class Junit(py.xml.Namespace):
34     pass
35 
36 
37 # We need to get the subset of the invalid unicode ranges according to
38 # XML 1.0 which are valid in this python build.  Hence we calculate
39 # this dynamically instead of hardcoding it.  The spec range of valid
40 # chars is: Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
41 #                    | [#x10000-#x10FFFF]
42 _legal_chars = (0x09, 0x0A, 0x0D)
43 _legal_ranges = ((0x20, 0x7E), (0x80, 0xD7FF), (0xE000, 0xFFFD), (0x10000, 0x10FFFF))
44 _legal_xml_re = [
45     u"%s-%s" % (six.unichr(low), six.unichr(high))
46     for (low, high) in _legal_ranges
47     if low < sys.maxunicode
48 ]
49 _legal_xml_re = [six.unichr(x) for x in _legal_chars] + _legal_xml_re
50 illegal_xml_re = re.compile(u"[^%s]" % u"".join(_legal_xml_re))
51 del _legal_chars
52 del _legal_ranges
53 del _legal_xml_re
54 
55 _py_ext_re = re.compile(r"\.py$")
56 
57 
58 def bin_xml_escape(arg):
59     def repl(matchobj):
60         i = ord(matchobj.group())
61         if i <= 0xFF:
62             return u"#x%02X" % i
63         else:
64             return u"#x%04X" % i
65 
66     return py.xml.raw(illegal_xml_re.sub(repl, py.xml.escape(arg)))
67 
68 
69 def merge_family(left, right):
70     result = {}
71     for kl, vl in left.items():
72         for kr, vr in right.items():
73             if not isinstance(vl, list):
74                 raise TypeError(type(vl))
75             result[kl] = vl + vr
76     left.update(result)
77 
78 
79 families = {}
80 families["_base"] = {"testcase": ["classname", "name"]}
81 families["_base_legacy"] = {"testcase": ["file", "line", "url"]}
82 
83 # xUnit 1.x inherits legacy attributes
84 families["xunit1"] = families["_base"].copy()
85 merge_family(families["xunit1"], families["_base_legacy"])
86 
87 # xUnit 2.x uses strict base attributes
88 families["xunit2"] = families["_base"]
89 
90 
91 class _NodeReporter(object):
92     def __init__(self, nodeid, xml):
93         self.id = nodeid
94         self.xml = xml
95         self.add_stats = self.xml.add_stats
96         self.family = self.xml.family
97         self.duration = 0
98         self.properties = []
99         self.nodes = []
100         self.testcase = None
101         self.attrs = {}
102 
103     def append(self, node):
104         self.xml.add_stats(type(node).__name__)
105         self.nodes.append(node)
106 
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))
109 
110     def add_attribute(self, name, value):
111         self.attrs[str(name)] = bin_xml_escape(value)
112 
113     def make_properties_node(self):
114         """Return a Junit node containing custom properties, if any.
115         """
116         if self.properties:
117             return Junit.properties(
118                 [
119                     Junit.property(name=name, value=value)
120                     for name, value in self.properties
121                 ]
122             )
123         return ""
124 
125     def record_testreport(self, testreport):
126         assert not self.testcase
127         names = mangle_test_address(testreport.nodeid)
128         existing_attrs = self.attrs
129         classnames = names[:-1]
130         if self.xml.prefix:
131             classnames.insert(0, self.xml.prefix)
132         attrs = {
133             "classname": ".".join(classnames),
134             "name": bin_xml_escape(names[-1]),
135             "file": testreport.location[0],
136         }
137         if testreport.location[1] is not None:
138             attrs["line"] = testreport.location[1]
139         if hasattr(testreport, "url"):
140             attrs["url"] = testreport.url
141         self.attrs = attrs
142         self.attrs.update(existing_attrs)  # restore any user-defined attributes
143 
144         # Preserve legacy testcase behavior
145         if self.family == "xunit1":
146             return
147 
148         # Filter out attributes not permitted by this test family.
149         # Including custom attributes because they are not valid here.
150         temp_attrs = {}
151         for key in self.attrs.keys():
152             if key in families[self.family]["testcase"]:
153                 temp_attrs[key] = self.attrs[key]
154         self.attrs = temp_attrs
155 
156     def to_xml(self):
157         testcase = Junit.testcase(time="%.3f" % self.duration, **self.attrs)
158         testcase.append(self.make_properties_node())
159         for node in self.nodes:
160             testcase.append(node)
161         return testcase
162 
163     def _add_simple(self, kind, message, data=None):
164         data = bin_xml_escape(data)
165         node = kind(data, message=message)
166         self.append(node)
167 
168     def write_captured_output(self, report):
169         content_out = report.capstdout
170         content_log = report.caplog
171         content_err = report.capstderr
172 
173         if content_log or content_out:
174             if content_log and self.xml.logging == "system-out":
175                 if content_out:
176                     # syncing stdout and the log-output is not done yet. It's
177                     # probably not worth the effort. Therefore, first the captured
178                     # stdout is shown and then the captured logs.
179                     content = "\n".join(
180                         [
181                             " Captured Stdout ".center(80, "-"),
182                             content_out,
183                             "",
184                             " Captured Log ".center(80, "-"),
185                             content_log,
186                         ]
187                     )
188                 else:
189                     content = content_log
190             else:
191                 content = content_out
192 
193             if content:
194                 tag = getattr(Junit, "system-out")
195                 self.append(tag(bin_xml_escape(content)))
196 
197         if content_log or content_err:
198             if content_log and self.xml.logging == "system-err":
199                 if content_err:
200                     content = "\n".join(
201                         [
202                             " Captured Stderr ".center(80, "-"),
203                             content_err,
204                             "",
205                             " Captured Log ".center(80, "-"),
206                             content_log,
207                         ]
208                     )
209                 else:
210                     content = content_log
211             else:
212                 content = content_err
213 
214             if content:
215                 tag = getattr(Junit, "system-err")
216                 self.append(tag(bin_xml_escape(content)))
217 
218     def append_pass(self, report):
219         self.add_stats("passed")
220 
221     def append_failure(self, report):
222         # msg = str(report.longrepr.reprtraceback.extraline)
223         if hasattr(report, "wasxfail"):
224             self._add_simple(Junit.skipped, "xfail-marked test passes unexpectedly")
225         else:
226             if hasattr(report.longrepr, "reprcrash"):
227                 message = report.longrepr.reprcrash.message
228             elif isinstance(report.longrepr, six.string_types):
229                 message = report.longrepr
230             else:
231                 message = str(report.longrepr)
232             message = bin_xml_escape(message)
233             fail = Junit.failure(message=message)
234             fail.append(bin_xml_escape(report.longrepr))
235             self.append(fail)
236 
237     def append_collect_error(self, report):
238         # msg = str(report.longrepr.reprtraceback.extraline)
239         self.append(
240             Junit.error(bin_xml_escape(report.longrepr), message="collection failure")
241         )
242 
243     def append_collect_skipped(self, report):
244         self._add_simple(Junit.skipped, "collection skipped", report.longrepr)
245 
246     def append_error(self, report):
247         if report.when == "teardown":
248             msg = "test teardown failure"
249         else:
250             msg = "test setup failure"
251         self._add_simple(Junit.error, msg, report.longrepr)
252 
253     def append_skipped(self, report):
254         if hasattr(report, "wasxfail"):
255             xfailreason = report.wasxfail
256             if xfailreason.startswith("reason: "):
257                 xfailreason = xfailreason[8:]
258             self.append(
259                 Junit.skipped(
260                     "", type="pytest.xfail", message=bin_xml_escape(xfailreason)
261                 )
262             )
263         else:
264             filename, lineno, skipreason = report.longrepr
265             if skipreason.startswith("Skipped: "):
266                 skipreason = skipreason[9:]
267             details = "%s:%s: %s" % (filename, lineno, skipreason)
268 
269             self.append(
270                 Junit.skipped(
271                     bin_xml_escape(details),
272                     type="pytest.skip",
273                     message=bin_xml_escape(skipreason),
274                 )
275             )
276             self.write_captured_output(report)
277 
278     def finalize(self):
279         data = self.to_xml().unicode(indent=0)
280         self.__dict__.clear()
281         self.to_xml = lambda: py.xml.raw(data)
282 
283 
284 def _warn_incompatibility_with_xunit2(request, fixture_name):
285     """Emits a PytestWarning about the given fixture being incompatible with newer xunit revisions"""
286     from _pytest.warning_types import PytestWarning
287 
288     xml = getattr(request.config, "_xml", None)
289     if xml is not None and xml.family not in ("xunit1", "legacy"):
290         request.node.warn(
291             PytestWarning(
292                 "{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')".format(
293                     fixture_name=fixture_name, family=xml.family
294                 )
295             )
296         )
297 
298 
299 @pytest.fixture
300 def record_property(request):
301     """Add an extra properties the calling test.
302     User properties become part of the test report and are available to the
303     configured reporters, like JUnit XML.
304     The fixture is callable with ``(name, value)``, with value being automatically
305     xml-encoded.
306 
307     Example::
308 
309         def test_function(record_property):
310             record_property("example_key", 1)
311     """
312     _warn_incompatibility_with_xunit2(request, "record_property")
313 
314     def append_property(name, value):
315         request.node.user_properties.append((name, value))
316 
317     return append_property
318 
319 
320 @pytest.fixture
321 def record_xml_attribute(request):
322     """Add extra xml attributes to the tag for the calling test.
323     The fixture is callable with ``(name, value)``, with value being
324     automatically xml-encoded
325     """
326     from _pytest.warning_types import PytestExperimentalApiWarning
327 
328     request.node.warn(
329         PytestExperimentalApiWarning("record_xml_attribute is an experimental feature")
330     )
331 
332     _warn_incompatibility_with_xunit2(request, "record_xml_attribute")
333 
334     # Declare noop
335     def add_attr_noop(name, value):
336         pass
337 
338     attr_func = add_attr_noop
339 
340     xml = getattr(request.config, "_xml", None)
341     if xml is not None:
342         node_reporter = xml.node_reporter(request.node.nodeid)
343         attr_func = node_reporter.add_attribute
344 
345     return attr_func
346 
347 
348 def pytest_addoption(parser):
349     group = parser.getgroup("terminal reporting")
350     group.addoption(
351         "--junitxml",
352         "--junit-xml",
353         action="store",
354         dest="xmlpath",
355         metavar="path",
356         type=functools.partial(filename_arg, optname="--junitxml"),
357         default=None,
358         help="create junit-xml style report file at given path.",
359     )
360     group.addoption(
361         "--junitprefix",
362         "--junit-prefix",
363         action="store",
364         metavar="str",
365         default=None,
366         help="prepend prefix to classnames in junit-xml output",
367     )
368     parser.addini(
369         "junit_suite_name", "Test suite name for JUnit report", default="pytest"
370     )
371     parser.addini(
372         "junit_logging",
373         "Write captured log messages to JUnit report: "
374         "one of no|system-out|system-err",
375         default="no",
376     )  # choices=['no', 'stdout', 'stderr'])
377     parser.addini(
378         "junit_duration_report",
379         "Duration time to report: one of total|call",
380         default="total",
381     )  # choices=['total', 'call'])
382     parser.addini(
383         "junit_family",
384         "Emit XML for schema: one of legacy|xunit1|xunit2",
385         default="xunit1",
386     )
387 
388 
389 def pytest_configure(config):
390     xmlpath = config.option.xmlpath
391     # prevent opening xmllog on slave nodes (xdist)
392     if xmlpath and not hasattr(config, "slaveinput"):
393         config._xml = LogXML(
394             xmlpath,
395             config.option.junitprefix,
396             config.getini("junit_suite_name"),
397             config.getini("junit_logging"),
398             config.getini("junit_duration_report"),
399             config.getini("junit_family"),
400         )
401         config.pluginmanager.register(config._xml)
402 
403 
404 def pytest_unconfigure(config):
405     xml = getattr(config, "_xml", None)
406     if xml:
407         del config._xml
408         config.pluginmanager.unregister(xml)
409 
410 
411 def mangle_test_address(address):
412     path, possible_open_bracket, params = address.partition("[")
413     names = path.split("::")
414     try:
415         names.remove("()")
416     except ValueError:
417         pass
418     # convert file path to dotted path
419     names[0] = names[0].replace(nodes.SEP, ".")
420     names[0] = _py_ext_re.sub("", names[0])
421     # put any params back
422     names[-1] += possible_open_bracket + params
423     return names
424 
425 
426 class LogXML(object):
427     def __init__(
428         self,
429         logfile,
430         prefix,
431         suite_name="pytest",
432         logging="no",
433         report_duration="total",
434         family="xunit1",
435     ):
436         logfile = os.path.expanduser(os.path.expandvars(logfile))
437         self.logfile = os.path.normpath(os.path.abspath(logfile))
438         self.prefix = prefix
439         self.suite_name = suite_name
440         self.logging = logging
441         self.report_duration = report_duration
442         self.family = family
443         self.stats = dict.fromkeys(["error", "passed", "failure", "skipped"], 0)
444         self.node_reporters = {}  # nodeid -> _NodeReporter
445         self.node_reporters_ordered = []
446         self.global_properties = []
447         # List of reports that failed on call but teardown is pending.
448         self.open_reports = []
449         self.cnt_double_fail_tests = 0
450 
451         # Replaces convenience family with real family
452         if self.family == "legacy":
453             self.family = "xunit1"
454 
455     def finalize(self, report):
456         nodeid = getattr(report, "nodeid", report)
457         # local hack to handle xdist report order
458         slavenode = getattr(report, "node", None)
459         reporter = self.node_reporters.pop((nodeid, slavenode))
460         if reporter is not None:
461             reporter.finalize()
462 
463     def node_reporter(self, report):
464         nodeid = getattr(report, "nodeid", report)
465         # local hack to handle xdist report order
466         slavenode = getattr(report, "node", None)
467 
468         key = nodeid, slavenode
469 
470         if key in self.node_reporters:
471             # TODO: breasks for --dist=each
472             return self.node_reporters[key]
473 
474         reporter = _NodeReporter(nodeid, self)
475 
476         self.node_reporters[key] = reporter
477         self.node_reporters_ordered.append(reporter)
478 
479         return reporter
480 
481     def add_stats(self, key):
482         if key in self.stats:
483             self.stats[key] += 1
484 
485     def _opentestcase(self, report):
486         reporter = self.node_reporter(report)
487         reporter.record_testreport(report)
488         return reporter
489 
490     def pytest_runtest_logreport(self, report):
491         """handle a setup/call/teardown report, generating the appropriate
492         xml tags as necessary.
493 
494         note: due to plugins like xdist, this hook may be called in interlaced
495         order with reports from other nodes. for example:
496 
497         usual call order:
498             -> setup node1
499             -> call node1
500             -> teardown node1
501             -> setup node2
502             -> call node2
503             -> teardown node2
504 
505         possible call order in xdist:
506             -> setup node1
507             -> call node1
508             -> setup node2
509             -> call node2
510             -> teardown node2
511             -> teardown node1
512         """
513         close_report = None
514         if report.passed:
515             if report.when == "call":  # ignore setup/teardown
516                 reporter = self._opentestcase(report)
517                 reporter.append_pass(report)
518         elif report.failed:
519             if report.when == "teardown":
520                 # The following vars are needed when xdist plugin is used
521                 report_wid = getattr(report, "worker_id", None)
522                 report_ii = getattr(report, "item_index", None)
523                 close_report = next(
524                     (
525                         rep
526                         for rep in self.open_reports
527                         if (
528                             rep.nodeid == report.nodeid
529                             and getattr(rep, "item_index", None) == report_ii
530                             and getattr(rep, "worker_id", None) == report_wid
531                         )
532                     ),
533                     None,
534                 )
535                 if close_report:
536                     # We need to open new testcase in case we have failure in
537                     # call and error in teardown in order to follow junit
538                     # schema
539                     self.finalize(close_report)
540                     self.cnt_double_fail_tests += 1
541             reporter = self._opentestcase(report)
542             if report.when == "call":
543                 reporter.append_failure(report)
544                 self.open_reports.append(report)
545             else:
546                 reporter.append_error(report)
547         elif report.skipped:
548             reporter = self._opentestcase(report)
549             reporter.append_skipped(report)
550         self.update_testcase_duration(report)
551         if report.when == "teardown":
552             reporter = self._opentestcase(report)
553             reporter.write_captured_output(report)
554 
555             for propname, propvalue in report.user_properties:
556                 reporter.add_property(propname, propvalue)
557 
558             self.finalize(report)
559             report_wid = getattr(report, "worker_id", None)
560             report_ii = getattr(report, "item_index", None)
561             close_report = next(
562                 (
563                     rep
564                     for rep in self.open_reports
565                     if (
566                         rep.nodeid == report.nodeid
567                         and getattr(rep, "item_index", None) == report_ii
568                         and getattr(rep, "worker_id", None) == report_wid
569                     )
570                 ),
571                 None,
572             )
573             if close_report:
574                 self.open_reports.remove(close_report)
575 
576     def update_testcase_duration(self, report):
577         """accumulates total duration for nodeid from given report and updates
578         the Junit.testcase with the new total if already created.
579         """
580         if self.report_duration == "total" or report.when == self.report_duration:
581             reporter = self.node_reporter(report)
582             reporter.duration += getattr(report, "duration", 0.0)
583 
584     def pytest_collectreport(self, report):
585         if not report.passed:
586             reporter = self._opentestcase(report)
587             if report.failed:
588                 reporter.append_collect_error(report)
589             else:
590                 reporter.append_collect_skipped(report)
591 
592     def pytest_internalerror(self, excrepr):
593         reporter = self.node_reporter("internal")
594         reporter.attrs.update(classname="pytest", name="internal")
595         reporter._add_simple(Junit.error, "internal error", excrepr)
596 
597     def pytest_sessionstart(self):
598         self.suite_start_time = time.time()
599 
600     def pytest_sessionfinish(self):
601         dirname = os.path.dirname(os.path.abspath(self.logfile))
602         if not os.path.isdir(dirname):
603             os.makedirs(dirname)
604         logfile = open(self.logfile, "w", encoding="utf-8")
605         suite_stop_time = time.time()
606         suite_time_delta = suite_stop_time - self.suite_start_time
607 
608         numtests = (
609             self.stats["passed"]
610             + self.stats["failure"]
611             + self.stats["skipped"]
612             + self.stats["error"]
613             - self.cnt_double_fail_tests
614         )
615         logfile.write('<?xml version="1.0" encoding="utf-8"?>')
616 
617         logfile.write(
618             Junit.testsuite(
619                 self._get_global_properties_node(),
620                 [x.to_xml() for x in self.node_reporters_ordered],
621                 name=self.suite_name,
622                 errors=self.stats["error"],
623                 failures=self.stats["failure"],
624                 skipped=self.stats["skipped"],
625                 tests=numtests,
626                 time="%.3f" % suite_time_delta,
627             ).unicode(indent=0)
628         )
629         logfile.close()
630 
631     def pytest_terminal_summary(self, terminalreporter):
632         terminalreporter.write_sep("-", "generated xml file: %s" % (self.logfile))
633 
634     def add_global_property(self, name, value):
635         self.global_properties.append((str(name), bin_xml_escape(value)))
636 
637     def _get_global_properties_node(self):
638         """Return a Junit node containing custom properties, if any.
639         """
640         if self.global_properties:
641             return Junit.properties(
642                 [
643                     Junit.property(name=name, value=value)
644                     for name, value in self.global_properties
645                 ]
646             )
647         return ""

</code><intended_behavior>There needs to be a review and possibly a restructuring of how the JUnit XML document is assembled, especially in relation to accommodating record_property data according to the JUnit schema. Specifically, the code responsible for generating or assembling the XML document should: Ensure that <properties> elements gathered via add_property are included within the <testsuite> element, not inside individual <testcase> elements. This could involve adjusting the logic that appends properties to the XML structure, maybe by introducing a new method or modifying existing ones to accurately place properties as per schema requirements. Preserve existing functionality for test case reporting, ensuring that all other aspects of the JUnit XML report remain valid and unchanged.</intended_behavior>]
2025-10-15 09:47:11.340 | INFO     | Search completed. Bug locations: [<file>src/_pytest/junitxml.py</file>
<class>_NodeReporter</class>
<method>add_property</method>
<code>
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))

</code><intended_behavior>This method correctly collects properties to be included in the report, but the bug isn't in the collection of properties—it's in how and where these properties are added to the XML structure. However, because add_property is part of the process that eventually leads to the misplacement, the intended behavior adjustment is not directly in this method but in ensuring that properties collected here are placed within <testsuite> elements when the XML document is being constructed. Thus, this location itself might not need a change in code but offers context to where adjustments in XML generation are needed.</intended_behavior>, <file>src/_pytest/junitxml.py</file>
<class>_NodeReporter</class>
<method>None</method>
<code>
91 class _NodeReporter(object):
92     def __init__(self, nodeid, xml):
93         self.id = nodeid
94         self.xml = xml
95         self.add_stats = self.xml.add_stats
96         self.family = self.xml.family
97         self.duration = 0
98         self.properties = []
99         self.nodes = []
100         self.testcase = None
101         self.attrs = {}
102 
103     def append(self, node):
104         self.xml.add_stats(type(node).__name__)
105         self.nodes.append(node)
106 
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))
109 
110     def add_attribute(self, name, value):
111         self.attrs[str(name)] = bin_xml_escape(value)
112 
113     def make_properties_node(self):
114         """Return a Junit node containing custom properties, if any.
115         """
116         if self.properties:
117             return Junit.properties(
118                 [
119                     Junit.property(name=name, value=value)
120                     for name, value in self.properties
121                 ]
122             )
123         return ""
124 
125     def record_testreport(self, testreport):
126         assert not self.testcase
127         names = mangle_test_address(testreport.nodeid)
128         existing_attrs = self.attrs
129         classnames = names[:-1]
130         if self.xml.prefix:
131             classnames.insert(0, self.xml.prefix)
132         attrs = {
133             "classname": ".".join(classnames),
134             "name": bin_xml_escape(names[-1]),
135             "file": testreport.location[0],
136         }
137         if testreport.location[1] is not None:
138             attrs["line"] = testreport.location[1]
139         if hasattr(testreport, "url"):
140             attrs["url"] = testreport.url
141         self.attrs = attrs
142         self.attrs.update(existing_attrs)  # restore any user-defined attributes
143 
144         # Preserve legacy testcase behavior
145         if self.family == "xunit1":
146             return
147 
148         # Filter out attributes not permitted by this test family.
149         # Including custom attributes because they are not valid here.
150         temp_attrs = {}
151         for key in self.attrs.keys():
152             if key in families[self.family]["testcase"]:
153                 temp_attrs[key] = self.attrs[key]
154         self.attrs = temp_attrs
155 
156     def to_xml(self):
157         testcase = Junit.testcase(time="%.3f" % self.duration, **self.attrs)
158         testcase.append(self.make_properties_node())
159         for node in self.nodes:
160             testcase.append(node)
161         return testcase
162 
163     def _add_simple(self, kind, message, data=None):
164         data = bin_xml_escape(data)
165         node = kind(data, message=message)
166         self.append(node)
167 
168     def write_captured_output(self, report):
169         content_out = report.capstdout
170         content_log = report.caplog
171         content_err = report.capstderr
172 
173         if content_log or content_out:
174             if content_log and self.xml.logging == "system-out":
175                 if content_out:
176                     # syncing stdout and the log-output is not done yet. It's
177                     # probably not worth the effort. Therefore, first the captured
178                     # stdout is shown and then the captured logs.
179                     content = "\n".join(
180                         [
181                             " Captured Stdout ".center(80, "-"),
182                             content_out,
183                             "",
184                             " Captured Log ".center(80, "-"),
185                             content_log,
186                         ]
187                     )
188                 else:
189                     content = content_log
190             else:
191                 content = content_out
192 
193             if content:
194                 tag = getattr(Junit, "system-out")
195                 self.append(tag(bin_xml_escape(content)))
196 
197         if content_log or content_err:
198             if content_log and self.xml.logging == "system-err":
199                 if content_err:
200                     content = "\n".join(
201                         [
202                             " Captured Stderr ".center(80, "-"),
203                             content_err,
204                             "",
205                             " Captured Log ".center(80, "-"),
206                             content_log,
207                         ]
208                     )
209                 else:
210                     content = content_log
211             else:
212                 content = content_err
213 
214             if content:
215                 tag = getattr(Junit, "system-err")
216                 self.append(tag(bin_xml_escape(content)))
217 
218     def append_pass(self, report):
219         self.add_stats("passed")
220 
221     def append_failure(self, report):
222         # msg = str(report.longrepr.reprtraceback.extraline)
223         if hasattr(report, "wasxfail"):
224             self._add_simple(Junit.skipped, "xfail-marked test passes unexpectedly")
225         else:
226             if hasattr(report.longrepr, "reprcrash"):
227                 message = report.longrepr.reprcrash.message
228             elif isinstance(report.longrepr, six.string_types):
229                 message = report.longrepr
230             else:
231                 message = str(report.longrepr)
232             message = bin_xml_escape(message)
233             fail = Junit.failure(message=message)
234             fail.append(bin_xml_escape(report.longrepr))
235             self.append(fail)
236 
237     def append_collect_error(self, report):
238         # msg = str(report.longrepr.reprtraceback.extraline)
239         self.append(
240             Junit.error(bin_xml_escape(report.longrepr), message="collection failure")
241         )
242 
243     def append_collect_skipped(self, report):
244         self._add_simple(Junit.skipped, "collection skipped", report.longrepr)
245 
246     def append_error(self, report):
247         if report.when == "teardown":
248             msg = "test teardown failure"
249         else:
250             msg = "test setup failure"
251         self._add_simple(Junit.error, msg, report.longrepr)
252 
253     def append_skipped(self, report):
254         if hasattr(report, "wasxfail"):
255             xfailreason = report.wasxfail
256             if xfailreason.startswith("reason: "):
257                 xfailreason = xfailreason[8:]
258             self.append(
259                 Junit.skipped(
260                     "", type="pytest.xfail", message=bin_xml_escape(xfailreason)
261                 )
262             )
263         else:
264             filename, lineno, skipreason = report.longrepr
265             if skipreason.startswith("Skipped: "):
266                 skipreason = skipreason[9:]
267             details = "%s:%s: %s" % (filename, lineno, skipreason)
268 
269             self.append(
270                 Junit.skipped(
271                     bin_xml_escape(details),
272                     type="pytest.skip",
273                     message=bin_xml_escape(skipreason),
274                 )
275             )
276             self.write_captured_output(report)
277 
278     def finalize(self):
279         data = self.to_xml().unicode(indent=0)
280         self.__dict__.clear()
281         self.to_xml = lambda: py.xml.raw(data)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>src/_pytest/junitxml.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     report test results in JUnit-XML format,
3     for use with Jenkins and build integration servers.
4 
5 
6 Based on initial code from Ross Lawley.
7 
8 Output conforms to https://github.com/jenkinsci/xunit-plugin/blob/master/
9 src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd
10 """
11 from __future__ import absolute_import
12 from __future__ import division
13 from __future__ import print_function
14 
15 import functools
16 import os
17 import re
18 import sys
19 import time
20 
21 import py
22 import six
23 
24 import pytest
25 from _pytest import nodes
26 from _pytest.config import filename_arg
27 
28 # Python 2.X and 3.X compatibility
29 if sys.version_info[0] < 3:
30     from codecs import open
31 
32 
33 class Junit(py.xml.Namespace):
34     pass
35 
36 
37 # We need to get the subset of the invalid unicode ranges according to
38 # XML 1.0 which are valid in this python build.  Hence we calculate
39 # this dynamically instead of hardcoding it.  The spec range of valid
40 # chars is: Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
41 #                    | [#x10000-#x10FFFF]
42 _legal_chars = (0x09, 0x0A, 0x0D)
43 _legal_ranges = ((0x20, 0x7E), (0x80, 0xD7FF), (0xE000, 0xFFFD), (0x10000, 0x10FFFF))
44 _legal_xml_re = [
45     u"%s-%s" % (six.unichr(low), six.unichr(high))
46     for (low, high) in _legal_ranges
47     if low < sys.maxunicode
48 ]
49 _legal_xml_re = [six.unichr(x) for x in _legal_chars] + _legal_xml_re
50 illegal_xml_re = re.compile(u"[^%s]" % u"".join(_legal_xml_re))
51 del _legal_chars
52 del _legal_ranges
53 del _legal_xml_re
54 
55 _py_ext_re = re.compile(r"\.py$")
56 
57 
58 def bin_xml_escape(arg):
59     def repl(matchobj):
60         i = ord(matchobj.group())
61         if i <= 0xFF:
62             return u"#x%02X" % i
63         else:
64             return u"#x%04X" % i
65 
66     return py.xml.raw(illegal_xml_re.sub(repl, py.xml.escape(arg)))
67 
68 
69 def merge_family(left, right):
70     result = {}
71     for kl, vl in left.items():
72         for kr, vr in right.items():
73             if not isinstance(vl, list):
74                 raise TypeError(type(vl))
75             result[kl] = vl + vr
76     left.update(result)
77 
78 
79 families = {}
80 families["_base"] = {"testcase": ["classname", "name"]}
81 families["_base_legacy"] = {"testcase": ["file", "line", "url"]}
82 
83 # xUnit 1.x inherits legacy attributes
84 families["xunit1"] = families["_base"].copy()
85 merge_family(families["xunit1"], families["_base_legacy"])
86 
87 # xUnit 2.x uses strict base attributes
88 families["xunit2"] = families["_base"]
89 
90 
91 class _NodeReporter(object):
92     def __init__(self, nodeid, xml):
93         self.id = nodeid
94         self.xml = xml
95         self.add_stats = self.xml.add_stats
96         self.family = self.xml.family
97         self.duration = 0
98         self.properties = []
99         self.nodes = []
100         self.testcase = None
101         self.attrs = {}
102 
103     def append(self, node):
104         self.xml.add_stats(type(node).__name__)
105         self.nodes.append(node)
106 
107     def add_property(self, name, value):
108         self.properties.append((str(name), bin_xml_escape(value)))
109 
110     def add_attribute(self, name, value):
111         self.attrs[str(name)] = bin_xml_escape(value)
112 
113     def make_properties_node(self):
114         """Return a Junit node containing custom properties, if any.
115         """
116         if self.properties:
117             return Junit.properties(
118                 [
119                     Junit.property(name=name, value=value)
120                     for name, value in self.properties
121                 ]
122             )
123         return ""
124 
125     def record_testreport(self, testreport):
126         assert not self.testcase
127         names = mangle_test_address(testreport.nodeid)
128         existing_attrs = self.attrs
129         classnames = names[:-1]
130         if self.xml.prefix:
131             classnames.insert(0, self.xml.prefix)
132         attrs = {
133             "classname": ".".join(classnames),
134             "name": bin_xml_escape(names[-1]),
135             "file": testreport.location[0],
136         }
137         if testreport.location[1] is not None:
138             attrs["line"] = testreport.location[1]
139         if hasattr(testreport, "url"):
140             attrs["url"] = testreport.url
141         self.attrs = attrs
142         self.attrs.update(existing_attrs)  # restore any user-defined attributes
143 
144         # Preserve legacy testcase behavior
145         if self.family == "xunit1":
146             return
147 
148         # Filter out attributes not permitted by this test family.
149         # Including custom attributes because they are not valid here.
150         temp_attrs = {}
151         for key in self.attrs.keys():
152             if key in families[self.family]["testcase"]:
153                 temp_attrs[key] = self.attrs[key]
154         self.attrs = temp_attrs
155 
156     def to_xml(self):
157         testcase = Junit.testcase(time="%.3f" % self.duration, **self.attrs)
158         testcase.append(self.make_properties_node())
159         for node in self.nodes:
160             testcase.append(node)
161         return testcase
162 
163     def _add_simple(self, kind, message, data=None):
164         data = bin_xml_escape(data)
165         node = kind(data, message=message)
166         self.append(node)
167 
168     def write_captured_output(self, report):
169         content_out = report.capstdout
170         content_log = report.caplog
171         content_err = report.capstderr
172 
173         if content_log or content_out:
174             if content_log and self.xml.logging == "system-out":
175                 if content_out:
176                     # syncing stdout and the log-output is not done yet. It's
177                     # probably not worth the effort. Therefore, first the captured
178                     # stdout is shown and then the captured logs.
179                     content = "\n".join(
180                         [
181                             " Captured Stdout ".center(80, "-"),
182                             content_out,
183                             "",
184                             " Captured Log ".center(80, "-"),
185                             content_log,
186                         ]
187                     )
188                 else:
189                     content = content_log
190             else:
191                 content = content_out
192 
193             if content:
194                 tag = getattr(Junit, "system-out")
195                 self.append(tag(bin_xml_escape(content)))
196 
197         if content_log or content_err:
198             if content_log and self.xml.logging == "system-err":
199                 if content_err:
200                     content = "\n".join(
201                         [
202                             " Captured Stderr ".center(80, "-"),
203                             content_err,
204                             "",
205                             " Captured Log ".center(80, "-"),
206                             content_log,
207                         ]
208                     )
209                 else:
210                     content = content_log
211             else:
212                 content = content_err
213 
214             if content:
215                 tag = getattr(Junit, "system-err")
216                 self.append(tag(bin_xml_escape(content)))
217 
218     def append_pass(self, report):
219         self.add_stats("passed")
220 
221     def append_failure(self, report):
222         # msg = str(report.longrepr.reprtraceback.extraline)
223         if hasattr(report, "wasxfail"):
224             self._add_simple(Junit.skipped, "xfail-marked test passes unexpectedly")
225         else:
226             if hasattr(report.longrepr, "reprcrash"):
227                 message = report.longrepr.reprcrash.message
228             elif isinstance(report.longrepr, six.string_types):
229                 message = report.longrepr
230             else:
231                 message = str(report.longrepr)
232             message = bin_xml_escape(message)
233             fail = Junit.failure(message=message)
234             fail.append(bin_xml_escape(report.longrepr))
235             self.append(fail)
236 
237     def append_collect_error(self, report):
238         # msg = str(report.longrepr.reprtraceback.extraline)
239         self.append(
240             Junit.error(bin_xml_escape(report.longrepr), message="collection failure")
241         )
242 
243     def append_collect_skipped(self, report):
244         self._add_simple(Junit.skipped, "collection skipped", report.longrepr)
245 
246     def append_error(self, report):
247         if report.when == "teardown":
248             msg = "test teardown failure"
249         else:
250             msg = "test setup failure"
251         self._add_simple(Junit.error, msg, report.longrepr)
252 
253     def append_skipped(self, report):
254         if hasattr(report, "wasxfail"):
255             xfailreason = report.wasxfail
256             if xfailreason.startswith("reason: "):
257                 xfailreason = xfailreason[8:]
258             self.append(
259                 Junit.skipped(
260                     "", type="pytest.xfail", message=bin_xml_escape(xfailreason)
261                 )
262             )
263         else:
264             filename, lineno, skipreason = report.longrepr
265             if skipreason.startswith("Skipped: "):
266                 skipreason = skipreason[9:]
267             details = "%s:%s: %s" % (filename, lineno, skipreason)
268 
269             self.append(
270                 Junit.skipped(
271                     bin_xml_escape(details),
272                     type="pytest.skip",
273                     message=bin_xml_escape(skipreason),
274                 )
275             )
276             self.write_captured_output(report)
277 
278     def finalize(self):
279         data = self.to_xml().unicode(indent=0)
280         self.__dict__.clear()
281         self.to_xml = lambda: py.xml.raw(data)
282 
283 
284 def _warn_incompatibility_with_xunit2(request, fixture_name):
285     """Emits a PytestWarning about the given fixture being incompatible with newer xunit revisions"""
286     from _pytest.warning_types import PytestWarning
287 
288     xml = getattr(request.config, "_xml", None)
289     if xml is not None and xml.family not in ("xunit1", "legacy"):
290         request.node.warn(
291             PytestWarning(
292                 "{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')".format(
293                     fixture_name=fixture_name, family=xml.family
294                 )
295             )
296         )
297 
298 
299 @pytest.fixture
300 def record_property(request):
301     """Add an extra properties the calling test.
302     User properties become part of the test report and are available to the
303     configured reporters, like JUnit XML.
304     The fixture is callable with ``(name, value)``, with value being automatically
305     xml-encoded.
306 
307     Example::
308 
309         def test_function(record_property):
310             record_property("example_key", 1)
311     """
312     _warn_incompatibility_with_xunit2(request, "record_property")
313 
314     def append_property(name, value):
315         request.node.user_properties.append((name, value))
316 
317     return append_property
318 
319 
320 @pytest.fixture
321 def record_xml_attribute(request):
322     """Add extra xml attributes to the tag for the calling test.
323     The fixture is callable with ``(name, value)``, with value being
324     automatically xml-encoded
325     """
326     from _pytest.warning_types import PytestExperimentalApiWarning
327 
328     request.node.warn(
329         PytestExperimentalApiWarning("record_xml_attribute is an experimental feature")
330     )
331 
332     _warn_incompatibility_with_xunit2(request, "record_xml_attribute")
333 
334     # Declare noop
335     def add_attr_noop(name, value):
336         pass
337 
338     attr_func = add_attr_noop
339 
340     xml = getattr(request.config, "_xml", None)
341     if xml is not None:
342         node_reporter = xml.node_reporter(request.node.nodeid)
343         attr_func = node_reporter.add_attribute
344 
345     return attr_func
346 
347 
348 def pytest_addoption(parser):
349     group = parser.getgroup("terminal reporting")
350     group.addoption(
351         "--junitxml",
352         "--junit-xml",
353         action="store",
354         dest="xmlpath",
355         metavar="path",
356         type=functools.partial(filename_arg, optname="--junitxml"),
357         default=None,
358         help="create junit-xml style report file at given path.",
359     )
360     group.addoption(
361         "--junitprefix",
362         "--junit-prefix",
363         action="store",
364         metavar="str",
365         default=None,
366         help="prepend prefix to classnames in junit-xml output",
367     )
368     parser.addini(
369         "junit_suite_name", "Test suite name for JUnit report", default="pytest"
370     )
371     parser.addini(
372         "junit_logging",
373         "Write captured log messages to JUnit report: "
374         "one of no|system-out|system-err",
375         default="no",
376     )  # choices=['no', 'stdout', 'stderr'])
377     parser.addini(
378         "junit_duration_report",
379         "Duration time to report: one of total|call",
380         default="total",
381     )  # choices=['total', 'call'])
382     parser.addini(
383         "junit_family",
384         "Emit XML for schema: one of legacy|xunit1|xunit2",
385         default="xunit1",
386     )
387 
388 
389 def pytest_configure(config):
390     xmlpath = config.option.xmlpath
391     # prevent opening xmllog on slave nodes (xdist)
392     if xmlpath and not hasattr(config, "slaveinput"):
393         config._xml = LogXML(
394             xmlpath,
395             config.option.junitprefix,
396             config.getini("junit_suite_name"),
397             config.getini("junit_logging"),
398             config.getini("junit_duration_report"),
399             config.getini("junit_family"),
400         )
401         config.pluginmanager.register(config._xml)
402 
403 
404 def pytest_unconfigure(config):
405     xml = getattr(config, "_xml", None)
406     if xml:
407         del config._xml
408         config.pluginmanager.unregister(xml)
409 
410 
411 def mangle_test_address(address):
412     path, possible_open_bracket, params = address.partition("[")
413     names = path.split("::")
414     try:
415         names.remove("()")
416     except ValueError:
417         pass
418     # convert file path to dotted path
419     names[0] = names[0].replace(nodes.SEP, ".")
420     names[0] = _py_ext_re.sub("", names[0])
421     # put any params back
422     names[-1] += possible_open_bracket + params
423     return names
424 
425 
426 class LogXML(object):
427     def __init__(
428         self,
429         logfile,
430         prefix,
431         suite_name="pytest",
432         logging="no",
433         report_duration="total",
434         family="xunit1",
435     ):
436         logfile = os.path.expanduser(os.path.expandvars(logfile))
437         self.logfile = os.path.normpath(os.path.abspath(logfile))
438         self.prefix = prefix
439         self.suite_name = suite_name
440         self.logging = logging
441         self.report_duration = report_duration
442         self.family = family
443         self.stats = dict.fromkeys(["error", "passed", "failure", "skipped"], 0)
444         self.node_reporters = {}  # nodeid -> _NodeReporter
445         self.node_reporters_ordered = []
446         self.global_properties = []
447         # List of reports that failed on call but teardown is pending.
448         self.open_reports = []
449         self.cnt_double_fail_tests = 0
450 
451         # Replaces convenience family with real family
452         if self.family == "legacy":
453             self.family = "xunit1"
454 
455     def finalize(self, report):
456         nodeid = getattr(report, "nodeid", report)
457         # local hack to handle xdist report order
458         slavenode = getattr(report, "node", None)
459         reporter = self.node_reporters.pop((nodeid, slavenode))
460         if reporter is not None:
461             reporter.finalize()
462 
463     def node_reporter(self, report):
464         nodeid = getattr(report, "nodeid", report)
465         # local hack to handle xdist report order
466         slavenode = getattr(report, "node", None)
467 
468         key = nodeid, slavenode
469 
470         if key in self.node_reporters:
471             # TODO: breasks for --dist=each
472             return self.node_reporters[key]
473 
474         reporter = _NodeReporter(nodeid, self)
475 
476         self.node_reporters[key] = reporter
477         self.node_reporters_ordered.append(reporter)
478 
479         return reporter
480 
481     def add_stats(self, key):
482         if key in self.stats:
483             self.stats[key] += 1
484 
485     def _opentestcase(self, report):
486         reporter = self.node_reporter(report)
487         reporter.record_testreport(report)
488         return reporter
489 
490     def pytest_runtest_logreport(self, report):
491         """handle a setup/call/teardown report, generating the appropriate
492         xml tags as necessary.
493 
494         note: due to plugins like xdist, this hook may be called in interlaced
495         order with reports from other nodes. for example:
496 
497         usual call order:
498             -> setup node1
499             -> call node1
500             -> teardown node1
501             -> setup node2
502             -> call node2
503             -> teardown node2
504 
505         possible call order in xdist:
506             -> setup node1
507             -> call node1
508             -> setup node2
509             -> call node2
510             -> teardown node2
511             -> teardown node1
512         """
513         close_report = None
514         if report.passed:
515             if report.when == "call":  # ignore setup/teardown
516                 reporter = self._opentestcase(report)
517                 reporter.append_pass(report)
518         elif report.failed:
519             if report.when == "teardown":
520                 # The following vars are needed when xdist plugin is used
521                 report_wid = getattr(report, "worker_id", None)
522                 report_ii = getattr(report, "item_index", None)
523                 close_report = next(
524                     (
525                         rep
526                         for rep in self.open_reports
527                         if (
528                             rep.nodeid == report.nodeid
529                             and getattr(rep, "item_index", None) == report_ii
530                             and getattr(rep, "worker_id", None) == report_wid
531                         )
532                     ),
533                     None,
534                 )
535                 if close_report:
536                     # We need to open new testcase in case we have failure in
537                     # call and error in teardown in order to follow junit
538                     # schema
539                     self.finalize(close_report)
540                     self.cnt_double_fail_tests += 1
541             reporter = self._opentestcase(report)
542             if report.when == "call":
543                 reporter.append_failure(report)
544                 self.open_reports.append(report)
545             else:
546                 reporter.append_error(report)
547         elif report.skipped:
548             reporter = self._opentestcase(report)
549             reporter.append_skipped(report)
550         self.update_testcase_duration(report)
551         if report.when == "teardown":
552             reporter = self._opentestcase(report)
553             reporter.write_captured_output(report)
554 
555             for propname, propvalue in report.user_properties:
556                 reporter.add_property(propname, propvalue)
557 
558             self.finalize(report)
559             report_wid = getattr(report, "worker_id", None)
560             report_ii = getattr(report, "item_index", None)
561             close_report = next(
562                 (
563                     rep
564                     for rep in self.open_reports
565                     if (
566                         rep.nodeid == report.nodeid
567                         and getattr(rep, "item_index", None) == report_ii
568                         and getattr(rep, "worker_id", None) == report_wid
569                     )
570                 ),
571                 None,
572             )
573             if close_report:
574                 self.open_reports.remove(close_report)
575 
576     def update_testcase_duration(self, report):
577         """accumulates total duration for nodeid from given report and updates
578         the Junit.testcase with the new total if already created.
579         """
580         if self.report_duration == "total" or report.when == self.report_duration:
581             reporter = self.node_reporter(report)
582             reporter.duration += getattr(report, "duration", 0.0)
583 
584     def pytest_collectreport(self, report):
585         if not report.passed:
586             reporter = self._opentestcase(report)
587             if report.failed:
588                 reporter.append_collect_error(report)
589             else:
590                 reporter.append_collect_skipped(report)
591 
592     def pytest_internalerror(self, excrepr):
593         reporter = self.node_reporter("internal")
594         reporter.attrs.update(classname="pytest", name="internal")
595         reporter._add_simple(Junit.error, "internal error", excrepr)
596 
597     def pytest_sessionstart(self):
598         self.suite_start_time = time.time()
599 
600     def pytest_sessionfinish(self):
601         dirname = os.path.dirname(os.path.abspath(self.logfile))
602         if not os.path.isdir(dirname):
603             os.makedirs(dirname)
604         logfile = open(self.logfile, "w", encoding="utf-8")
605         suite_stop_time = time.time()
606         suite_time_delta = suite_stop_time - self.suite_start_time
607 
608         numtests = (
609             self.stats["passed"]
610             + self.stats["failure"]
611             + self.stats["skipped"]
612             + self.stats["error"]
613             - self.cnt_double_fail_tests
614         )
615         logfile.write('<?xml version="1.0" encoding="utf-8"?>')
616 
617         logfile.write(
618             Junit.testsuite(
619                 self._get_global_properties_node(),
620                 [x.to_xml() for x in self.node_reporters_ordered],
621                 name=self.suite_name,
622                 errors=self.stats["error"],
623                 failures=self.stats["failure"],
624                 skipped=self.stats["skipped"],
625                 tests=numtests,
626                 time="%.3f" % suite_time_delta,
627             ).unicode(indent=0)
628         )
629         logfile.close()
630 
631     def pytest_terminal_summary(self, terminalreporter):
632         terminalreporter.write_sep("-", "generated xml file: %s" % (self.logfile))
633 
634     def add_global_property(self, name, value):
635         self.global_properties.append((str(name), bin_xml_escape(value)))
636 
637     def _get_global_properties_node(self):
638         """Return a Junit node containing custom properties, if any.
639         """
640         if self.global_properties:
641             return Junit.properties(
642                 [
643                     Junit.property(name=name, value=value)
644                     for name, value in self.global_properties
645                 ]
646             )
647         return ""

</code><intended_behavior>There needs to be a review and possibly a restructuring of how the JUnit XML document is assembled, especially in relation to accommodating record_property data according to the JUnit schema. Specifically, the code responsible for generating or assembling the XML document should: Ensure that <properties> elements gathered via add_property are included within the <testsuite> element, not inside individual <testcase> elements. This could involve adjusting the logic that appends properties to the XML structure, maybe by introducing a new method or modifying existing ones to accurately place properties as per schema requirements. Preserve existing functionality for test case reporting, ensuring that all other aspects of the JUnit XML report remain valid and unchanged.</intended_behavior>]
2025-10-15 09:47:11.341 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 09:47:11.341 | INFO     | Search-only: skipping patch selection
2025-10-15 09:47:11.423 | INFO     | Task pytest-dev__pytest-5205 completed successfully.
2025-10-15 09:47:11.424 | INFO     | No patch generated. You can try running ACR again.
