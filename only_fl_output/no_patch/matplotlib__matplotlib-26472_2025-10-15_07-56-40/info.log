2025-10-15 07:56:40.239 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:56:43.661 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=888, output_tokens=12, cost=0.009240
2025-10-15 07:56:57.635 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1068, output_tokens=542, cost=0.026940
2025-10-15 07:56:58.981 | INFO     | registered non reproducing test 0
2025-10-15 07:57:14.339 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2024, output_tokens=659, cost=0.040010
2025-10-15 07:57:15.654 | INFO     | registered non reproducing test 1
2025-10-15 07:57:32.522 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2252, output_tokens=748, cost=0.044960
2025-10-15 07:57:33.833 | INFO     | registered non reproducing test 2
2025-10-15 07:57:33.833 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 07:57:33.836 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:57:41.585 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1084, output_tokens=356, cost=0.021520
2025-10-15 07:57:41.592 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:57:43.634 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=710, output_tokens=52, cost=0.008660
2025-10-15 07:57:43.635 | DEBUG    | Extracted a valid json.
2025-10-15 07:57:43.635 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"%matplotlib\")",
        "search_method(\"show\")",
        "search_code(\"ion()\")",
        "search_code(\"ioff()\")"
    ],
    "bug_locations": []
}
2025-10-15 07:57:43.881 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:57:43.881 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:58:04.625 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3321, output_tokens=760, cost=0.056010
2025-10-15 07:58:04.633 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:58:13.325 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4297, output_tokens=353, cost=0.053560
2025-10-15 07:58:13.330 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:58:22.115 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=313, cost=0.016460
2025-10-15 07:58:22.117 | DEBUG    | Extracted a valid json.
2025-10-15 07:58:22.117 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/pyplot.py",
            "class": "",
            "method": "",
            "intended_behavior": "In `pyplot.py`, adjustments should be made to ensure that backend switching via `%matplotlib` magic does not interfere with the visibility of GUI windows created under different backends. Specifically, this involves preserving the state of GUI windows upon backend switches. Methods related to backend switching and interactive mode toggling (`ion()`, `ioff()`) may need to be modified to check the current backend and manage GUI windows accordingly, without closing them unintentionally. The exact implementation would depend on identifying a method to tag certain figures to remain unaffected by backend changes or maintaining a global state of figures that should not be closed upon backend switches."
        },
        {
            "file": "lib/matplotlib/backend_bases.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file, which is likely involved in the fundamental implementation of display mechanisms across backends, may require modifications to the `show()` method implementations specific to different backends. The adjustments should ensure that figures designated to remain open (perhaps through a mechanism introduced in `pyplot.py`) are not closed when the backend switches to `inline`. This could involve enhancing the `show()` method or related utility functions to acknowledge the new state management logic introduced in `pyplot.py` for backend switching, maintaining the figure's visibility as needed."
        }
    ]
}
2025-10-15 07:58:22.134 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 # fmt: off
39 
40 from __future__ import annotations
41 
42 from contextlib import AbstractContextManager, ExitStack
43 from enum import Enum
44 import functools
45 import importlib
46 import inspect
47 import logging
48 import re
49 import sys
50 import threading
51 import time
52 from typing import cast, overload
53 
54 from cycler import cycler
55 import matplotlib
56 import matplotlib.colorbar
57 import matplotlib.image
58 from matplotlib import _api
59 from matplotlib import (  # Re-exported for typing.
60     cm as cm, get_backend as get_backend, rcParams as rcParams, style as style)
61 from matplotlib import _pylab_helpers, interactive
62 from matplotlib import cbook
63 from matplotlib import _docstring
64 from matplotlib.backend_bases import (
65     FigureCanvasBase, FigureManagerBase, MouseButton)
66 from matplotlib.figure import Figure, FigureBase, figaspect
67 from matplotlib.gridspec import GridSpec, SubplotSpec
68 from matplotlib import rcsetup, rcParamsDefault, rcParamsOrig
69 from matplotlib.artist import Artist
70 from matplotlib.axes import Axes, Subplot  # type: ignore
71 from matplotlib.projections import PolarAxes  # type: ignore
72 from matplotlib import mlab  # for detrend_none, window_hanning
73 from matplotlib.scale import get_scale_names
74 
75 from matplotlib.cm import _colormaps
76 from matplotlib.cm import register_cmap  # type: ignore
77 from matplotlib.colors import _color_sequences
78 
79 import numpy as np
80 
81 from typing import TYPE_CHECKING, cast
82 
83 if TYPE_CHECKING:
84     from collections.abc import Callable, Hashable, Iterable, Sequence
85     import datetime
86     import pathlib
87     import os
88     from typing import Any, BinaryIO, Literal, TypeVar
89     from typing_extensions import ParamSpec
90 
91     import PIL
92     from numpy.typing import ArrayLike
93 
94     from matplotlib.axis import Tick
95     from matplotlib.axes._base import _AxesBase
96     from matplotlib.backend_bases import RendererBase, Event
97     from matplotlib.cm import ScalarMappable
98     from matplotlib.contour import ContourSet, QuadContourSet
99     from matplotlib.collections import (
100         Collection,
101         LineCollection,
102         BrokenBarHCollection,
103         PolyCollection,
104         PathCollection,
105         EventCollection,
106         QuadMesh,
107     )
108     from matplotlib.colorbar import Colorbar
109     from matplotlib.colors import Colormap
110     from matplotlib.container import (
111         BarContainer,
112         ErrorbarContainer,
113         StemContainer,
114     )
115     from matplotlib.figure import SubFigure
116     from matplotlib.legend import Legend
117     from matplotlib.mlab import GaussianKDE
118     from matplotlib.image import AxesImage, FigureImage
119     from matplotlib.patches import FancyArrow, StepPatch, Wedge
120     from matplotlib.quiver import Barbs, Quiver, QuiverKey
121     from matplotlib.scale import ScaleBase
122     from matplotlib.transforms import Transform, Bbox
123     from matplotlib.typing import ColorType, LineStyleType, MarkerType, HashableList
124     from matplotlib.widgets import SubplotTool
125 
126     _P = ParamSpec('_P')
127     _R = TypeVar('_R')
128 
129 
130 # We may not need the following imports here:
131 from matplotlib.colors import Normalize
132 from matplotlib.lines import Line2D
133 from matplotlib.text import Text, Annotation
134 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
135 from matplotlib.widgets import Button, Slider, Widget
136 
137 from .ticker import (
138     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
139     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
140     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
141     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
142 
143 _log = logging.getLogger(__name__)
144 
145 
146 # Explicit rename instead of import-as for typing's sake.
147 colormaps = _colormaps
148 color_sequences = _color_sequences
149 
150 
151 @overload
152 def _copy_docstring_and_deprecators(
153     method: Any,
154     func: Literal[None] = None
155 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...
156 
157 
158 @overload
159 def _copy_docstring_and_deprecators(
160     method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...
161 
162 
163 def _copy_docstring_and_deprecators(
164     method: Any,
165     func: Callable[_P, _R] | None = None
166 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:
167     if func is None:
168         return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',
169                     functools.partial(_copy_docstring_and_deprecators, method))
170     decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [
171         _docstring.copy(method)
172     ]
173     # Check whether the definition of *method* includes @_api.rename_parameter
174     # or @_api.make_keyword_only decorators; if so, propagate them to the
175     # pyplot wrapper as well.
176     while hasattr(method, "__wrapped__"):
177         potential_decorator = _api.deprecation.DECORATORS.get(method)
178         if potential_decorator:
179             decorators.append(potential_decorator)
180         method = method.__wrapped__
181     for decorator in decorators[::-1]:
182         func = decorator(func)
183     return func
184 
185 
186 ## Global ##
187 
188 
189 # The state controlled by {,un}install_repl_displayhook().
190 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
191 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
192 
193 
194 def _draw_all_if_interactive() -> None:
195     if matplotlib.is_interactive():
196         draw_all()
197 
198 
199 def install_repl_displayhook() -> None:
200     """
201     Connect to the display hook of the current shell.
202 
203     The display hook gets called when the read-evaluate-print-loop (REPL) of
204     the shell has finished the execution of a command. We use this callback
205     to be able to automatically update a figure in interactive mode.
206 
207     This works both with IPython and with vanilla python shells.
208     """
209     global _REPL_DISPLAYHOOK
210 
211     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
212         return
213 
214     # See if we have IPython hooks around, if so use them.
215     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
216     # entries can also have been explicitly set to None.
217     mod_ipython = sys.modules.get("IPython")
218     if not mod_ipython:
219         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
220         return
221     ip = mod_ipython.get_ipython()
222     if not ip:
223         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
224         return
225 
226     ip.events.register("post_execute", _draw_all_if_interactive)
227     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
228 
229     from IPython.core.pylabtools import backend2gui  # type: ignore
230     # trigger IPython's eventloop integration, if available
231     ipython_gui_name = backend2gui.get(get_backend())
232     if ipython_gui_name:
233         ip.enable_gui(ipython_gui_name)
234 
235 
236 def uninstall_repl_displayhook() -> None:
237     """Disconnect from the display hook of the current shell."""
238     global _REPL_DISPLAYHOOK
239     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
240         from IPython import get_ipython  # type: ignore
241         ip = get_ipython()
242         ip.events.unregister("post_execute", _draw_all_if_interactive)
243     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
244 
245 
246 draw_all = _pylab_helpers.Gcf.draw_all
247 
248 
249 # Ensure this appears in the pyplot docs.
250 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
251 def set_loglevel(*args, **kwargs) -> None:
252     return matplotlib.set_loglevel(*args, **kwargs)
253 
254 
255 @_copy_docstring_and_deprecators(Artist.findobj)
256 def findobj(
257     o: Artist | None = None,
258     match: Callable[[Artist], bool] | type[Artist] | None = None,
259     include_self: bool = True
260 ) -> list[Artist]:
261     if o is None:
262         o = gcf()
263     return o.findobj(match, include_self=include_self)
264 
265 
266 _backend_mod: type[matplotlib.backend_bases._Backend] | None = None
267 
268 
269 def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:
270     """
271     Ensure that a backend is selected and return it.
272 
273     This is currently private, but may be made public in the future.
274     """
275     if _backend_mod is None:
276         # Use rcParams._get("backend") to avoid going through the fallback
277         # logic (which will (re)import pyplot and then call switch_backend if
278         # we need to resolve the auto sentinel)
279         switch_backend(rcParams._get("backend"))  # type: ignore[attr-defined]
280     return cast(type[matplotlib.backend_bases._Backend], _backend_mod)
281 
282 
283 def switch_backend(newbackend: str) -> None:
284     """
285     Set the pyplot backend.
286 
287     Switching to an interactive backend is possible only if no event loop for
288     another interactive backend has started.  Switching to and from
289     non-interactive backends is always possible.
290 
291     If the new backend is different than the current backend then all open
292     Figures will be closed via ``plt.close('all')``.
293 
294     Parameters
295     ----------
296     newbackend : str
297         The case-insensitive name of the backend to use.
298 
299     """
300     global _backend_mod
301     # make sure the init is pulled up so we can assign to it later
302     import matplotlib.backends
303 
304     if newbackend is rcsetup._auto_backend_sentinel:
305         current_framework = cbook._get_running_interactive_framework()
306         mapping = {'qt': 'qtagg',
307                    'gtk3': 'gtk3agg',
308                    'gtk4': 'gtk4agg',
309                    'wx': 'wxagg',
310                    'tk': 'tkagg',
311                    'macosx': 'macosx',
312                    'headless': 'agg'}
313 
314         if current_framework in mapping:
315             candidates = [mapping[current_framework]]
316         else:
317             candidates = []
318         candidates += [
319             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
320 
321         # Don't try to fallback on the cairo-based backends as they each have
322         # an additional dependency (pycairo) over the agg-based backend, and
323         # are of worse quality.
324         for candidate in candidates:
325             try:
326                 switch_backend(candidate)
327             except ImportError:
328                 continue
329             else:
330                 rcParamsOrig['backend'] = candidate
331                 return
332         else:
333             # Switching to Agg should always succeed; if it doesn't, let the
334             # exception propagate out.
335             switch_backend("agg")
336             rcParamsOrig["backend"] = "agg"
337             return
338     # have to escape the switch on access logic
339     old_backend = dict.__getitem__(rcParams, 'backend')
340 
341     module = importlib.import_module(cbook._backend_module_name(newbackend))
342 
343     required_framework = module.FigureCanvas.required_interactive_framework
344     if required_framework is not None:
345         current_framework = cbook._get_running_interactive_framework()
346         if (current_framework and required_framework
347                 and current_framework != required_framework):
348             raise ImportError(
349                 "Cannot load backend {!r} which requires the {!r} interactive "
350                 "framework, as {!r} is currently running".format(
351                     newbackend, required_framework, current_framework))
352 
353     # Load the new_figure_manager() and show() functions from the backend.
354 
355     # Classically, backends can directly export these functions.  This should
356     # keep working for backcompat.
357     new_figure_manager = getattr(module, "new_figure_manager", None)
358     show = getattr(module, "show", None)
359 
360     # In that classical approach, backends are implemented as modules, but
361     # "inherit" default method implementations from backend_bases._Backend.
362     # This is achieved by creating a "class" that inherits from
363     # backend_bases._Backend and whose body is filled with the module globals.
364     class backend_mod(matplotlib.backend_bases._Backend):
365         locals().update(vars(module))
366 
367     # However, the newer approach for defining new_figure_manager and
368     # show is to derive them from canvas methods.  In that case, also
369     # update backend_mod accordingly; also, per-backend customization of
370     # draw_if_interactive is disabled.
371     if new_figure_manager is None:
372         # Only try to get the canvas class if have opted into the new scheme.
373         canvas_class = backend_mod.FigureCanvas
374 
375         def new_figure_manager_given_figure(num, figure):
376             return canvas_class.new_manager(figure, num)
377 
378         def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):
379             fig = FigureClass(*args, **kwargs)
380             return new_figure_manager_given_figure(num, fig)
381 
382         def draw_if_interactive() -> None:
383             if matplotlib.is_interactive():
384                 manager = _pylab_helpers.Gcf.get_active()
385                 if manager:
386                     manager.canvas.draw_idle()
387 
388         backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]
389             new_figure_manager_given_figure)
390         backend_mod.new_figure_manager = (  # type: ignore[method-assign]
391             new_figure_manager)
392         backend_mod.draw_if_interactive = (  # type: ignore[method-assign]
393             draw_if_interactive)
394 
395     # If the manager explicitly overrides pyplot_show, use it even if a global
396     # show is already present, as the latter may be here for backcompat.
397     manager_class = getattr(getattr(backend_mod, "FigureCanvas", None),
398                             "manager_class", None)
399     # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because
400     # pyplot_show is a classmethod so the above constructs are bound classmethods, and
401     # thus always different (being bound to different classes).  We also have to use
402     # getattr_static instead of vars as manager_class could have no __dict__.
403     manager_pyplot_show = inspect.getattr_static(manager_class, "pyplot_show", None)
404     base_pyplot_show = inspect.getattr_static(FigureManagerBase, "pyplot_show", None)
405     if (show is None
406             or (manager_pyplot_show is not None
407                 and manager_pyplot_show != base_pyplot_show)):
408         _pyplot_show = cast('Any', manager_class).pyplot_show
409         backend_mod.show = _pyplot_show  # type: ignore[method-assign]
410 
411     _log.debug("Loaded backend %s version %s.",
412                newbackend, backend_mod.backend_version)
413 
414     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
415     _backend_mod = backend_mod
416     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
417         globals()[func_name].__signature__ = inspect.signature(
418             getattr(backend_mod, func_name))
419 
420     # Need to keep a global reference to the backend for compatibility reasons.
421     # See https://github.com/matplotlib/matplotlib/issues/6092
422     matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]
423     if not cbook._str_equal(old_backend, newbackend):
424         close("all")
425 
426     # make sure the repl display hook is installed in case we become
427     # interactive
428     install_repl_displayhook()
429 
430 
431 def _warn_if_gui_out_of_main_thread() -> None:
432     warn = False
433     canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)
434     if canvas_class.required_interactive_framework:
435         if hasattr(threading, 'get_native_id'):
436             # This compares native thread ids because even if Python-level
437             # Thread objects match, the underlying OS thread (which is what
438             # really matters) may be different on Python implementations with
439             # green threads.
440             if threading.get_native_id() != threading.main_thread().native_id:
441                 warn = True
442         else:
443             # Fall back to Python-level Thread if native IDs are unavailable,
444             # mainly for PyPy.
445             if threading.current_thread() is not threading.main_thread():
446                 warn = True
447     if warn:
448         _api.warn_external(
449             "Starting a Matplotlib GUI outside of the main thread will likely "
450             "fail.")
451 
452 
453 # This function's signature is rewritten upon backend-load by switch_backend.
454 def new_figure_manager(*args, **kwargs):
455     """Create a new figure manager instance."""
456     _warn_if_gui_out_of_main_thread()
457     return _get_backend_mod().new_figure_manager(*args, **kwargs)
458 
459 
460 # This function's signature is rewritten upon backend-load by switch_backend.
461 def draw_if_interactive(*args, **kwargs):
462     """
463     Redraw the current figure if in interactive mode.
464 
465     .. warning::
466 
467         End users will typically not have to call this function because the
468         the interactive mode takes care of this.
469     """
470     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
471 
472 
473 # This function's signature is rewritten upon backend-load by switch_backend.
474 def show(*args, **kwargs):
475     """
476     Display all open figures.
477 
478     Parameters
479     ----------
480     block : bool, optional
481         Whether to wait for all figures to be closed before returning.
482 
483         If `True` block and run the GUI main loop until all figure windows
484         are closed.
485 
486         If `False` ensure that all figure windows are displayed and return
487         immediately.  In this case, you are responsible for ensuring
488         that the event loop is running to have responsive figures.
489 
490         Defaults to True in non-interactive mode and to False in interactive
491         mode (see `.pyplot.isinteractive`).
492 
493     See Also
494     --------
495     ion : Enable interactive mode, which shows / updates the figure after
496           every plotting command, so that calling ``show()`` is not necessary.
497     ioff : Disable interactive mode.
498     savefig : Save the figure to an image file instead of showing it on screen.
499 
500     Notes
501     -----
502     **Saving figures to file and showing a window at the same time**
503 
504     If you want an image file as well as a user interface window, use
505     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
506     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
507     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
508     limitation of command order does not apply if the show is non-blocking or
509     if you keep a reference to the figure and use `.Figure.savefig`.
510 
511     **Auto-show in jupyter notebooks**
512 
513     The jupyter backends (activated via ``%matplotlib inline``,
514     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
515     the end of every cell by default. Thus, you usually don't have to call it
516     explicitly there.
517     """
518     _warn_if_gui_out_of_main_thread()
519     return _get_backend_mod().show(*args, **kwargs)
520 
521 
522 def isinteractive() -> bool:
523     """
524     Return whether plots are updated after every plotting command.
525 
526     The interactive mode is mainly useful if you build plots from the command
527     line and want to see the effect of each command while you are building the
528     figure.
529 
530     In interactive mode:
531 
532     - newly created figures will be shown immediately;
533     - figures will automatically redraw on change;
534     - `.pyplot.show` will not block by default.
535 
536     In non-interactive mode:
537 
538     - newly created figures and changes to figures will not be reflected until
539       explicitly asked to be;
540     - `.pyplot.show` will block by default.
541 
542     See Also
543     --------
544     ion : Enable interactive mode.
545     ioff : Disable interactive mode.
546     show : Show all figures (and maybe block).
547     pause : Show all figures, and block for a time.
548     """
549     return matplotlib.is_interactive()
550 
551 
552 def ioff() -> ExitStack:
553     """
554     Disable interactive mode.
555 
556     See `.pyplot.isinteractive` for more details.
557 
558     See Also
559     --------
560     ion : Enable interactive mode.
561     isinteractive : Whether interactive mode is enabled.
562     show : Show all figures (and maybe block).
563     pause : Show all figures, and block for a time.
564 
565     Notes
566     -----
567     For a temporary change, this can be used as a context manager::
568 
569         # if interactive mode is on
570         # then figures will be shown on creation
571         plt.ion()
572         # This figure will be shown immediately
573         fig = plt.figure()
574 
575         with plt.ioff():
576             # interactive mode will be off
577             # figures will not automatically be shown
578             fig2 = plt.figure()
579             # ...
580 
581     To enable optional usage as a context manager, this function returns a
582     `~contextlib.ExitStack` object, which is not intended to be stored or
583     accessed by the user.
584     """
585     stack = ExitStack()
586     stack.callback(ion if isinteractive() else ioff)
587     matplotlib.interactive(False)
588     uninstall_repl_displayhook()
589     return stack
590 
591 
592 def ion() -> ExitStack:
593     """
594     Enable interactive mode.
595 
596     See `.pyplot.isinteractive` for more details.
597 
598     See Also
599     --------
600     ioff : Disable interactive mode.
601     isinteractive : Whether interactive mode is enabled.
602     show : Show all figures (and maybe block).
603     pause : Show all figures, and block for a time.
604 
605     Notes
606     -----
607     For a temporary change, this can be used as a context manager::
608 
609         # if interactive mode is off
610         # then figures will not be shown on creation
611         plt.ioff()
612         # This figure will not be shown immediately
613         fig = plt.figure()
614 
615         with plt.ion():
616             # interactive mode will be on
617             # figures will automatically be shown
618             fig2 = plt.figure()
619             # ...
620 
621     To enable optional usage as a context manager, this function returns a
622     `~contextlib.ExitStack` object, which is not intended to be stored or
623     accessed by the user.
624     """
625     stack = ExitStack()
626     stack.callback(ion if isinteractive() else ioff)
627     matplotlib.interactive(True)
628     install_repl_displayhook()
629     return stack
630 
631 
632 def pause(interval: float) -> None:
633     """
634     Run the GUI event loop for *interval* seconds.
635 
636     If there is an active figure, it will be updated and displayed before the
637     pause, and the GUI event loop (if any) will run during the pause.
638 
639     This can be used for crude animation.  For more complex animation use
640     :mod:`matplotlib.animation`.
641 
642     If there is no active figure, sleep for *interval* seconds instead.
643 
644     See Also
645     --------
646     matplotlib.animation : Proper animations
647     show : Show all figures and optional block until all figures are closed.
648     """
649     manager = _pylab_helpers.Gcf.get_active()
650     if manager is not None:
651         canvas = manager.canvas
652         if canvas.figure.stale:
653             canvas.draw_idle()
654         show(block=False)
655         canvas.start_event_loop(interval)
656     else:
657         time.sleep(interval)
658 
659 
660 @_copy_docstring_and_deprecators(matplotlib.rc)
661 def rc(group: str, **kwargs) -> None:
662     matplotlib.rc(group, **kwargs)
663 
664 
665 @_copy_docstring_and_deprecators(matplotlib.rc_context)
666 def rc_context(
667     rc: dict[str, Any] | None = None,
668     fname: str | pathlib.Path | os.PathLike | None = None,
669 ) -> AbstractContextManager[None]:
670     return matplotlib.rc_context(rc, fname)
671 
672 
673 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
674 def rcdefaults() -> None:
675     matplotlib.rcdefaults()
676     if matplotlib.is_interactive():
677         draw_all()
678 
679 
680 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
681 
682 
683 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
684 def getp(obj, *args, **kwargs):
685     return matplotlib.artist.getp(obj, *args, **kwargs)
686 
687 
688 @_copy_docstring_and_deprecators(matplotlib.artist.get)
689 def get(obj, *args, **kwargs):
690     return matplotlib.artist.get(obj, *args, **kwargs)
691 
692 
693 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
694 def setp(obj, *args, **kwargs):
695     return matplotlib.artist.setp(obj, *args, **kwargs)
696 
697 
698 def xkcd(
699     scale: float = 1, length: float = 100, randomness: float = 2
700 ) -> ExitStack:
701     """
702     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
703     only have effect on things drawn after this function is called.
704 
705     For best results, the "Humor Sans" font should be installed: it is
706     not included with Matplotlib.
707 
708     Parameters
709     ----------
710     scale : float, optional
711         The amplitude of the wiggle perpendicular to the source line.
712     length : float, optional
713         The length of the wiggle along the line.
714     randomness : float, optional
715         The scale factor by which the length is shrunken or expanded.
716 
717     Notes
718     -----
719     This function works by a number of rcParams, so it will probably
720     override others you have set before.
721 
722     If you want the effects of this function to be temporary, it can
723     be used as a context manager, for example::
724 
725         with plt.xkcd():
726             # This figure will be in XKCD-style
727             fig1 = plt.figure()
728             # ...
729 
730         # This figure will be in regular style
731         fig2 = plt.figure()
732     """
733     # This cannot be implemented in terms of contextmanager() or rc_context()
734     # because this needs to work as a non-contextmanager too.
735 
736     if rcParams['text.usetex']:
737         raise RuntimeError(
738             "xkcd mode is not compatible with text.usetex = True")
739 
740     stack = ExitStack()
741     stack.callback(dict.update, rcParams, rcParams.copy())  # type: ignore
742 
743     from matplotlib import patheffects
744     rcParams.update({
745         'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
746                         'Comic Sans MS'],
747         'font.size': 14.0,
748         'path.sketch': (scale, length, randomness),
749         'path.effects': [
750             patheffects.withStroke(linewidth=4, foreground="w")],
751         'axes.linewidth': 1.5,
752         'lines.linewidth': 2.0,
753         'figure.facecolor': 'white',
754         'grid.linewidth': 0.0,
755         'axes.grid': False,
756         'axes.unicode_minus': False,
757         'axes.edgecolor': 'black',
758         'xtick.major.size': 8,
759         'xtick.major.width': 3,
760         'ytick.major.size': 8,
761         'ytick.major.width': 3,
762     })
763 
764     return stack
765 
766 
767 ## Figures ##
768 
769 def figure(
770     # autoincrement if None, else integer from 1-N
771     num: int | str | Figure | SubFigure | None = None,
772     # defaults to rc figure.figsize
773     figsize: tuple[float, float] | None = None,
774     # defaults to rc figure.dpi
775     dpi: float | None = None,
776     *,
777     # defaults to rc figure.facecolor
778     facecolor: ColorType | None = None,
779     # defaults to rc figure.edgecolor
780     edgecolor: ColorType | None = None,
781     frameon: bool = True,
782     FigureClass: type[Figure] = Figure,
783     clear: bool = False,
784     **kwargs
785 ) -> Figure:
786     """
787     Create a new figure, or activate an existing figure.
788 
789     Parameters
790     ----------
791     num : int or str or `.Figure` or `.SubFigure`, optional
792         A unique identifier for the figure.
793 
794         If a figure with that identifier already exists, this figure is made
795         active and returned. An integer refers to the ``Figure.number``
796         attribute, a string refers to the figure label.
797 
798         If there is no figure with the identifier or *num* is not given, a new
799         figure is created, made active and returned.  If *num* is an int, it
800         will be used for the ``Figure.number`` attribute, otherwise, an
801         auto-generated integer value is used (starting at 1 and incremented
802         for each new figure). If *num* is a string, the figure label and the
803         window title is set to this value.  If num is a ``SubFigure``, its
804         parent ``Figure`` is activated.
805 
806     figsize : (float, float), default: :rc:`figure.figsize`
807         Width, height in inches.
808 
809     dpi : float, default: :rc:`figure.dpi`
810         The resolution of the figure in dots-per-inch.
811 
812     facecolor : color, default: :rc:`figure.facecolor`
813         The background color.
814 
815     edgecolor : color, default: :rc:`figure.edgecolor`
816         The border color.
817 
818     frameon : bool, default: True
819         If False, suppress drawing the figure frame.
820 
821     FigureClass : subclass of `~matplotlib.figure.Figure`
822         If set, an instance of this subclass will be created, rather than a
823         plain `.Figure`.
824 
825     clear : bool, default: False
826         If True and the figure already exists, then it is cleared.
827 
828     layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \
829 default: None
830         The layout mechanism for positioning of plot elements to avoid
831         overlapping Axes decorations (labels, ticks, etc). Note that layout
832         managers can measurably slow down figure display.
833 
834         - 'constrained': The constrained layout solver adjusts axes sizes
835           to avoid overlapping axes decorations.  Can handle complex plot
836           layouts and colorbars, and is thus recommended.
837 
838           See :ref:`constrainedlayout_guide`
839           for examples.
840 
841         - 'compressed': uses the same algorithm as 'constrained', but
842           removes extra space between fixed-aspect-ratio Axes.  Best for
843           simple grids of axes.
844 
845         - 'tight': Use the tight layout mechanism. This is a relatively
846           simple algorithm that adjusts the subplot parameters so that
847           decorations do not overlap. See `.Figure.set_tight_layout` for
848           further details.
849 
850         - 'none': Do not use a layout engine.
851 
852         - A `.LayoutEngine` instance. Builtin layout classes are
853           `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
854           accessible by 'constrained' and 'tight'.  Passing an instance
855           allows third parties to provide their own layout engine.
856 
857         If not given, fall back to using the parameters *tight_layout* and
858         *constrained_layout*, including their config defaults
859         :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
860 
861     **kwargs
862         Additional keyword arguments are passed to the `.Figure` constructor.
863 
864     Returns
865     -------
866     `~matplotlib.figure.Figure`
867 
868     Notes
869     -----
870     A newly created figure is passed to the `~.FigureCanvasBase.new_manager`
871     method or the `new_figure_manager` function provided by the current
872     backend, which install a canvas and a manager on the figure.
873 
874     Once this is done, :rc:`figure.hooks` are called, one at a time, on the
875     figure; these hooks allow arbitrary customization of the figure (e.g.,
876     attaching callbacks) or of associated elements (e.g., modifying the
877     toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of
878     toolbar customization.
879 
880     If you are creating many figures, make sure you explicitly call
881     `.pyplot.close` on the figures you are not using, because this will
882     enable pyplot to properly clean up the memory.
883 
884     `~matplotlib.rcParams` defines the default values, which can be modified
885     in the matplotlibrc file.
886     """
887     if isinstance(num, FigureBase):
888         # type narrowed to `Figure | SubFigure` by combination of input and isinstance
889         if num.canvas.manager is None:
890             raise ValueError("The passed figure is not managed by pyplot")
891         _pylab_helpers.Gcf.set_active(num.canvas.manager)
892         return num.figure
893 
894     allnums = get_fignums()
895     next_num = max(allnums) + 1 if allnums else 1
896     fig_label = ''
897     if num is None:
898         num = next_num
899     elif isinstance(num, str):
900         fig_label = num
901         all_labels = get_figlabels()
902         if fig_label not in all_labels:
903             if fig_label == 'all':
904                 _api.warn_external("close('all') closes all existing figures.")
905             num = next_num
906         else:
907             inum = all_labels.index(fig_label)
908             num = allnums[inum]
909     else:
910         num = int(num)  # crude validation of num argument
911 
912     # Type of "num" has narrowed to int, but mypy can't quite see it
913     manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]
914     if manager is None:
915         max_open_warning = rcParams['figure.max_open_warning']
916         if len(allnums) == max_open_warning >= 1:
917             _api.warn_external(
918                 f"More than {max_open_warning} figures have been opened. "
919                 f"Figures created through the pyplot interface "
920                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
921                 f"closed and may consume too much memory. (To control this "
922                 f"warning, see the rcParam `figure.max_open_warning`). "
923                 f"Consider using `matplotlib.pyplot.close()`.",
924                 RuntimeWarning)
925 
926         manager = new_figure_manager(
927             num, figsize=figsize, dpi=dpi,
928             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
929             FigureClass=FigureClass, **kwargs)
930         fig = manager.canvas.figure
931         if fig_label:
932             fig.set_label(fig_label)
933 
934         for hookspecs in rcParams["figure.hooks"]:
935             module_name, dotted_name = hookspecs.split(":")
936             obj = importlib.import_module(module_name)
937             for part in dotted_name.split("."):
938                 obj = getattr(obj, part)
939             obj(fig)
940 
941         _pylab_helpers.Gcf._set_new_active_manager(manager)
942 
943         # make sure backends (inline) that we don't ship that expect this
944         # to be called in plotting commands to make the figure call show
945         # still work.  There is probably a better way to do this in the
946         # FigureManager base class.
947         draw_if_interactive()
948 
949         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
950             fig.stale_callback = _auto_draw_if_interactive
951 
952     if clear:
953         manager.canvas.figure.clear()
954 
955     return manager.canvas.figure
956 
957 
958 def _auto_draw_if_interactive(fig, val):
959     """
960     An internal helper function for making sure that auto-redrawing
961     works as intended in the plain python repl.
962 
963     Parameters
964     ----------
965     fig : Figure
966         A figure object which is assumed to be associated with a canvas
967     """
968     if (val and matplotlib.is_interactive()
969             and not fig.canvas.is_saving()
970             and not fig.canvas._is_idle_drawing):
971         # Some artists can mark themselves as stale in the middle of drawing
972         # (e.g. axes position & tick labels being computed at draw time), but
973         # this shouldn't trigger a redraw because the current redraw will
974         # already take them into account.
975         with fig.canvas._idle_draw_cntx():
976             fig.canvas.draw_idle()
977 
978 
979 def gcf() -> Figure:
980     """
981     Get the current figure.
982 
983     If there is currently no figure on the pyplot figure stack, a new one is
984     created using `~.pyplot.figure()`.  (To test whether there is currently a
985     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
986     is empty.)
987     """
988     manager = _pylab_helpers.Gcf.get_active()
989     if manager is not None:
990         return manager.canvas.figure
991     else:
992         return figure()
993 
994 
995 def fignum_exists(num: int) -> bool:
996     """Return whether the figure with the given id exists."""
997     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
998 
999 
1000 def get_fignums() -> list[int]:
1001     """Return a list of existing figure numbers."""
1002     return sorted(_pylab_helpers.Gcf.figs)
1003 
1004 
1005 def get_figlabels() -> list[Any]:
1006     """Return a list of existing figure labels."""
1007     managers = _pylab_helpers.Gcf.get_all_fig_managers()
1008     managers.sort(key=lambda m: m.num)
1009     return [m.canvas.figure.get_label() for m in managers]
1010 
1011 
1012 def get_current_fig_manager() -> FigureManagerBase | None:
1013     """
1014     Return the figure manager of the current figure.
1015 
1016     The figure manager is a container for the actual backend-depended window
1017     that displays the figure on screen.
1018 
1019     If no current figure exists, a new one is created, and its figure
1020     manager is returned.
1021 
1022     Returns
1023     -------
1024     `.FigureManagerBase` or backend-dependent subclass thereof
1025     """
1026     return gcf().canvas.manager
1027 
1028 
1029 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
1030 def connect(s: str, func: Callable[[Event], Any]) -> int:
1031     return gcf().canvas.mpl_connect(s, func)
1032 
1033 
1034 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
1035 def disconnect(cid: int) -> None:
1036     gcf().canvas.mpl_disconnect(cid)
1037 
1038 
1039 def close(fig: None | int | str | Figure | Literal["all"] = None) -> None:
1040     """
1041     Close a figure window.
1042 
1043     Parameters
1044     ----------
1045     fig : None or int or str or `.Figure`
1046         The figure to close. There are a number of ways to specify this:
1047 
1048         - *None*: the current figure
1049         - `.Figure`: the given `.Figure` instance
1050         - ``int``: a figure number
1051         - ``str``: a figure name
1052         - 'all': all figures
1053 
1054     """
1055     if fig is None:
1056         manager = _pylab_helpers.Gcf.get_active()
1057         if manager is None:
1058             return
1059         else:
1060             _pylab_helpers.Gcf.destroy(manager)
1061     elif fig == 'all':
1062         _pylab_helpers.Gcf.destroy_all()
1063     elif isinstance(fig, int):
1064         _pylab_helpers.Gcf.destroy(fig)
1065     elif hasattr(fig, 'int'):
1066         # if we are dealing with a type UUID, we
1067         # can use its integer representation
1068         _pylab_helpers.Gcf.destroy(fig.int)
1069     elif isinstance(fig, str):
1070         all_labels = get_figlabels()
1071         if fig in all_labels:
1072             num = get_fignums()[all_labels.index(fig)]
1073             _pylab_helpers.Gcf.destroy(num)
1074     elif isinstance(fig, Figure):
1075         _pylab_helpers.Gcf.destroy_fig(fig)
1076     else:
1077         raise TypeError("close() argument must be a Figure, an int, a string, "
1078                         "or None, not %s" % type(fig))
1079 
1080 
1081 def clf() -> None:
1082     """Clear the current figure."""
1083     gcf().clear()
1084 
1085 
1086 def draw() -> None:
1087     """
1088     Redraw the current figure.
1089 
1090     This is used to update a figure that has been altered, but not
1091     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
1092     should be only rarely needed, but there may be ways to modify the state of
1093     a figure without marking it as "stale".  Please report these cases as bugs.
1094 
1095     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
1096     the current figure.
1097 
1098     See Also
1099     --------
1100     .FigureCanvasBase.draw_idle
1101     .FigureCanvasBase.draw
1102     """
1103     gcf().canvas.draw_idle()
1104 
1105 
1106 @_copy_docstring_and_deprecators(Figure.savefig)
1107 def savefig(*args, **kwargs) -> None:
1108     fig = gcf()
1109     # savefig default implementation has no return, so mypy is unhappy
1110     # presumably this is here because subclasses can return?
1111     res = fig.savefig(*args, **kwargs)  # type: ignore[func-returns-value]
1112     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
1113     return res
1114 
1115 
1116 ## Putting things in figures ##
1117 
1118 
1119 def figlegend(*args, **kwargs) -> Legend:
1120     return gcf().legend(*args, **kwargs)
1121 if Figure.legend.__doc__:
1122     figlegend.__doc__ = Figure.legend.__doc__ \
1123         .replace(" legend(", " figlegend(") \
1124         .replace("fig.legend(", "plt.figlegend(") \
1125         .replace("ax.plot(", "plt.plot(")
1126 
1127 
1128 ## Axes ##
1129 
1130 @_docstring.dedent_interpd
1131 def axes(
1132     arg: None | tuple[float, float, float, float] = None,
1133     **kwargs
1134 ) -> matplotlib.axes.Axes:
1135     """
1136     Add an Axes to the current figure and make it the current Axes.
1137 
1138     Call signatures::
1139 
1140         plt.axes()
1141         plt.axes(rect, projection=None, polar=False, **kwargs)
1142         plt.axes(ax)
1143 
1144     Parameters
1145     ----------
1146     arg : None or 4-tuple
1147         The exact behavior of this function depends on the type:
1148 
1149         - *None*: A new full window Axes is added using
1150           ``subplot(**kwargs)``.
1151         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
1152           A new Axes is added with dimensions *rect* in normalized
1153           (0, 1) units using `~.Figure.add_axes` on the current figure.
1154 
1155     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1156 'polar', 'rectilinear', str}, optional
1157         The projection type of the `~.axes.Axes`. *str* is the name of
1158         a custom projection, see `~matplotlib.projections`. The default
1159         None results in a 'rectilinear' projection.
1160 
1161     polar : bool, default: False
1162         If True, equivalent to projection='polar'.
1163 
1164     sharex, sharey : `~matplotlib.axes.Axes`, optional
1165         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1166         The axis will have the same limits, ticks, and scale as the axis
1167         of the shared Axes.
1168 
1169     label : str
1170         A label for the returned Axes.
1171 
1172     Returns
1173     -------
1174     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1175         The returned axes class depends on the projection used. It is
1176         `~.axes.Axes` if rectilinear projection is used and
1177         `.projections.polar.PolarAxes` if polar projection is used.
1178 
1179     Other Parameters
1180     ----------------
1181     **kwargs
1182         This method also takes the keyword arguments for
1183         the returned Axes class. The keyword arguments for the
1184         rectilinear Axes class `~.axes.Axes` can be found in
1185         the following table but there might also be other keyword
1186         arguments if another projection is used, see the actual Axes
1187         class.
1188 
1189         %(Axes:kwdoc)s
1190 
1191     See Also
1192     --------
1193     .Figure.add_axes
1194     .pyplot.subplot
1195     .Figure.add_subplot
1196     .Figure.subplots
1197     .pyplot.subplots
1198 
1199     Examples
1200     --------
1201     ::
1202 
1203         # Creating a new full window Axes
1204         plt.axes()
1205 
1206         # Creating a new Axes with specified dimensions and a grey background
1207         plt.axes((left, bottom, width, height), facecolor='grey')
1208     """
1209     fig = gcf()
1210     pos = kwargs.pop('position', None)
1211     if arg is None:
1212         if pos is None:
1213             return fig.add_subplot(**kwargs)
1214         else:
1215             return fig.add_axes(pos, **kwargs)
1216     else:
1217         return fig.add_axes(arg, **kwargs)
1218 
1219 
1220 def delaxes(ax: matplotlib.axes.Axes | None = None) -> None:
1221     """
1222     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1223     """
1224     if ax is None:
1225         ax = gca()
1226     ax.remove()
1227 
1228 
1229 def sca(ax: Axes) -> None:
1230     """
1231     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1232     """
1233     # Mypy sees ax.figure as potentially None,
1234     # but if you are calling this, it won't be None
1235     # Additionally the slight difference between `Figure` and `FigureBase` mypy catches
1236     figure(ax.figure)  # type: ignore[arg-type]
1237     ax.figure.sca(ax)  # type: ignore[union-attr]
1238 
1239 
1240 def cla() -> None:
1241     """Clear the current axes."""
1242     # Not generated via boilerplate.py to allow a different docstring.
1243     return gca().cla()
1244 
1245 
1246 ## More ways of creating axes ##
1247 
1248 @_docstring.dedent_interpd
1249 def subplot(*args, **kwargs) -> Axes:
1250     """
1251     Add an Axes to the current figure or retrieve an existing Axes.
1252 
1253     This is a wrapper of `.Figure.add_subplot` which provides additional
1254     behavior when working with the implicit API (see the notes section).
1255 
1256     Call signatures::
1257 
1258        subplot(nrows, ncols, index, **kwargs)
1259        subplot(pos, **kwargs)
1260        subplot(**kwargs)
1261        subplot(ax)
1262 
1263     Parameters
1264     ----------
1265     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1266         The position of the subplot described by one of
1267 
1268         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1269           *index* position on a grid with *nrows* rows and *ncols* columns.
1270           *index* starts at 1 in the upper left corner and increases to the
1271           right. *index* can also be a two-tuple specifying the (*first*,
1272           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1273           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1274           upper 2/3 of the figure.
1275         - A 3-digit integer. The digits are interpreted as if given separately
1276           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1277           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1278           if there are no more than 9 subplots.
1279         - A `.SubplotSpec`.
1280 
1281     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1282 'polar', 'rectilinear', str}, optional
1283         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1284         of a custom projection, see `~matplotlib.projections`. The default
1285         None results in a 'rectilinear' projection.
1286 
1287     polar : bool, default: False
1288         If True, equivalent to projection='polar'.
1289 
1290     sharex, sharey : `~matplotlib.axes.Axes`, optional
1291         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1292         axis will have the same limits, ticks, and scale as the axis of the
1293         shared axes.
1294 
1295     label : str
1296         A label for the returned axes.
1297 
1298     Returns
1299     -------
1300     `~.axes.Axes`
1301 
1302         The Axes of the subplot. The returned Axes can actually be an instance
1303         of a subclass, such as `.projections.polar.PolarAxes` for polar
1304         projections.
1305 
1306     Other Parameters
1307     ----------------
1308     **kwargs
1309         This method also takes the keyword arguments for the returned axes
1310         base class; except for the *figure* argument. The keyword arguments
1311         for the rectilinear base class `~.axes.Axes` can be found in
1312         the following table but there might also be other keyword
1313         arguments if another projection is used.
1314 
1315         %(Axes:kwdoc)s
1316 
1317     Notes
1318     -----
1319     Creating a new Axes will delete any preexisting Axes that
1320     overlaps with it beyond sharing a boundary::
1321 
1322         import matplotlib.pyplot as plt
1323         # plot a line, implicitly creating a subplot(111)
1324         plt.plot([1, 2, 3])
1325         # now create a subplot which represents the top plot of a grid
1326         # with 2 rows and 1 column. Since this subplot will overlap the
1327         # first, the plot (and its axes) previously created, will be removed
1328         plt.subplot(211)
1329 
1330     If you do not want this behavior, use the `.Figure.add_subplot` method
1331     or the `.pyplot.axes` function instead.
1332 
1333     If no *kwargs* are passed and there exists an Axes in the location
1334     specified by *args* then that Axes will be returned rather than a new
1335     Axes being created.
1336 
1337     If *kwargs* are passed and there exists an Axes in the location
1338     specified by *args*, the projection type is the same, and the
1339     *kwargs* match with the existing Axes, then the existing Axes is
1340     returned.  Otherwise a new Axes is created with the specified
1341     parameters.  We save a reference to the *kwargs* which we use
1342     for this comparison.  If any of the values in *kwargs* are
1343     mutable we will not detect the case where they are mutated.
1344     In these cases we suggest using `.Figure.add_subplot` and the
1345     explicit Axes API rather than the implicit pyplot API.
1346 
1347     See Also
1348     --------
1349     .Figure.add_subplot
1350     .pyplot.subplots
1351     .pyplot.axes
1352     .Figure.subplots
1353 
1354     Examples
1355     --------
1356     ::
1357 
1358         plt.subplot(221)
1359 
1360         # equivalent but more general
1361         ax1 = plt.subplot(2, 2, 1)
1362 
1363         # add a subplot with no frame
1364         ax2 = plt.subplot(222, frameon=False)
1365 
1366         # add a polar subplot
1367         plt.subplot(223, projection='polar')
1368 
1369         # add a red subplot that shares the x-axis with ax1
1370         plt.subplot(224, sharex=ax1, facecolor='red')
1371 
1372         # delete ax2 from the figure
1373         plt.delaxes(ax2)
1374 
1375         # add ax2 to the figure again
1376         plt.subplot(ax2)
1377 
1378         # make the first axes "current" again
1379         plt.subplot(221)
1380 
1381     """
1382     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1383     # downstream code deal with the rest.
1384     unset = object()
1385     projection = kwargs.get('projection', unset)
1386     polar = kwargs.pop('polar', unset)
1387     if polar is not unset and polar:
1388         # if we got mixed messages from the user, raise
1389         if projection is not unset and projection != 'polar':
1390             raise ValueError(
1391                 f"polar={polar}, yet projection={projection!r}. "
1392                 "Only one of these arguments should be supplied."
1393             )
1394         kwargs['projection'] = projection = 'polar'
1395 
1396     # if subplot called without arguments, create subplot(1, 1, 1)
1397     if len(args) == 0:
1398         args = (1, 1, 1)
1399 
1400     # This check was added because it is very easy to type subplot(1, 2, False)
1401     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1402     # cases, no error will ever occur, but mysterious behavior can result
1403     # because what was intended to be the sharex argument is instead treated as
1404     # a subplot index for subplot()
1405     if len(args) >= 3 and isinstance(args[2], bool):
1406         _api.warn_external("The subplot index argument to subplot() appears "
1407                            "to be a boolean. Did you intend to use "
1408                            "subplots()?")
1409     # Check for nrows and ncols, which are not valid subplot args:
1410     if 'nrows' in kwargs or 'ncols' in kwargs:
1411         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1412                         "and/or 'nrows'.  Did you intend to call subplots()?")
1413 
1414     fig = gcf()
1415 
1416     # First, search for an existing subplot with a matching spec.
1417     key = SubplotSpec._from_subplot_args(fig, args)
1418 
1419     for ax in fig.axes:
1420         # If we found an Axes at the position, we can re-use it if the user passed no
1421         # kwargs or if the axes class and kwargs are identical.
1422         if (ax.get_subplotspec() == key
1423             and (kwargs == {}
1424                  or (ax._projection_init
1425                      == fig._process_projection_requirements(**kwargs)))):
1426             break
1427     else:
1428         # we have exhausted the known Axes and none match, make a new one!
1429         ax = fig.add_subplot(*args, **kwargs)
1430 
1431     fig.sca(ax)
1432 
1433     return ax
1434 
1435 
1436 def subplots(
1437     nrows: int = 1, ncols: int = 1, *,
1438     sharex: bool | Literal["none", "all", "row", "col"] = False,
1439     sharey: bool | Literal["none", "all", "row", "col"] = False,
1440     squeeze: bool = True,
1441     width_ratios: Sequence[float] | None = None,
1442     height_ratios: Sequence[float] | None = None,
1443     subplot_kw: dict[str, Any] | None = None,
1444     gridspec_kw: dict[str, Any] | None = None,
1445     **fig_kw
1446 ) -> tuple[Figure, Any]:
1447     """
1448     Create a figure and a set of subplots.
1449 
1450     This utility wrapper makes it convenient to create common layouts of
1451     subplots, including the enclosing figure object, in a single call.
1452 
1453     Parameters
1454     ----------
1455     nrows, ncols : int, default: 1
1456         Number of rows/columns of the subplot grid.
1457 
1458     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1459         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1460         axes:
1461 
1462         - True or 'all': x- or y-axis will be shared among all subplots.
1463         - False or 'none': each subplot x- or y-axis will be independent.
1464         - 'row': each subplot row will share an x- or y-axis.
1465         - 'col': each subplot column will share an x- or y-axis.
1466 
1467         When subplots have a shared x-axis along a column, only the x tick
1468         labels of the bottom subplot are created. Similarly, when subplots
1469         have a shared y-axis along a row, only the y tick labels of the first
1470         column subplot are created. To later turn other subplots' ticklabels
1471         on, use `~matplotlib.axes.Axes.tick_params`.
1472 
1473         When subplots have a shared axis that has units, calling
1474         `~matplotlib.axis.Axis.set_units` will update each axis with the
1475         new units.
1476 
1477     squeeze : bool, default: True
1478         - If True, extra dimensions are squeezed out from the returned
1479           array of `~matplotlib.axes.Axes`:
1480 
1481           - if only one subplot is constructed (nrows=ncols=1), the
1482             resulting single Axes object is returned as a scalar.
1483           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1484             object array of Axes objects.
1485           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1486 
1487         - If False, no squeezing at all is done: the returned Axes object is
1488           always a 2D array containing Axes instances, even if it ends up
1489           being 1x1.
1490 
1491     width_ratios : array-like of length *ncols*, optional
1492         Defines the relative widths of the columns. Each column gets a
1493         relative width of ``width_ratios[i] / sum(width_ratios)``.
1494         If not given, all columns will have the same width.  Equivalent
1495         to ``gridspec_kw={'width_ratios': [...]}``.
1496 
1497     height_ratios : array-like of length *nrows*, optional
1498         Defines the relative heights of the rows. Each row gets a
1499         relative height of ``height_ratios[i] / sum(height_ratios)``.
1500         If not given, all rows will have the same height. Convenience
1501         for ``gridspec_kw={'height_ratios': [...]}``.
1502 
1503     subplot_kw : dict, optional
1504         Dict with keywords passed to the
1505         `~matplotlib.figure.Figure.add_subplot` call used to create each
1506         subplot.
1507 
1508     gridspec_kw : dict, optional
1509         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1510         constructor used to create the grid the subplots are placed on.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519 
1520     ax : `~matplotlib.axes.Axes` or array of Axes
1521         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1522         objects if more than one subplot was created.  The dimensions of the
1523         resulting array can be controlled with the squeeze keyword, see above.
1524 
1525         Typical idioms for handling the return value are::
1526 
1527             # using the variable ax for single a Axes
1528             fig, ax = plt.subplots()
1529 
1530             # using the variable axs for multiple Axes
1531             fig, axs = plt.subplots(2, 2)
1532 
1533             # using tuple unpacking for multiple Axes
1534             fig, (ax1, ax2) = plt.subplots(1, 2)
1535             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1536 
1537         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1538         because for the latter it's not clear if it refers to a single
1539         `~.axes.Axes` instance or a collection of these.
1540 
1541     See Also
1542     --------
1543     .pyplot.figure
1544     .pyplot.subplot
1545     .pyplot.axes
1546     .Figure.subplots
1547     .Figure.add_subplot
1548 
1549     Examples
1550     --------
1551     ::
1552 
1553         # First create some toy data:
1554         x = np.linspace(0, 2*np.pi, 400)
1555         y = np.sin(x**2)
1556 
1557         # Create just a figure and only one subplot
1558         fig, ax = plt.subplots()
1559         ax.plot(x, y)
1560         ax.set_title('Simple plot')
1561 
1562         # Create two subplots and unpack the output array immediately
1563         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1564         ax1.plot(x, y)
1565         ax1.set_title('Sharing Y axis')
1566         ax2.scatter(x, y)
1567 
1568         # Create four polar axes and access them through the returned array
1569         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1570         axs[0, 0].plot(x, y)
1571         axs[1, 1].scatter(x, y)
1572 
1573         # Share a X axis with each column of subplots
1574         plt.subplots(2, 2, sharex='col')
1575 
1576         # Share a Y axis with each row of subplots
1577         plt.subplots(2, 2, sharey='row')
1578 
1579         # Share both X and Y axes with all subplots
1580         plt.subplots(2, 2, sharex='all', sharey='all')
1581 
1582         # Note that this is the same as
1583         plt.subplots(2, 2, sharex=True, sharey=True)
1584 
1585         # Create figure number 10 with a single subplot
1586         # and clears it if it already exists.
1587         fig, ax = plt.subplots(num=10, clear=True)
1588 
1589     """
1590     fig = figure(**fig_kw)
1591     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1592                        squeeze=squeeze, subplot_kw=subplot_kw,
1593                        gridspec_kw=gridspec_kw, height_ratios=height_ratios,
1594                        width_ratios=width_ratios)
1595     return fig, axs
1596 
1597 
1598 def subplot_mosaic(
1599     mosaic: str | HashableList,
1600     *,
1601     sharex: bool = False,
1602     sharey: bool = False,
1603     width_ratios: ArrayLike | None = None,
1604     height_ratios: ArrayLike | None = None,
1605     empty_sentinel: Any = '.',
1606     subplot_kw: dict[str, Any] | None = None,
1607     gridspec_kw: dict[str, Any] | None = None,
1608     per_subplot_kw: dict[Hashable, dict[str, Any]] | None = None,
1609     **fig_kw
1610 ) -> tuple[Figure, dict[Hashable, matplotlib.axes.Axes]]:
1611     """
1612     Build a layout of Axes based on ASCII art or nested lists.
1613 
1614     This is a helper function to build complex GridSpec layouts visually.
1615 
1616     See :ref:`mosaic`
1617     for an example and full API documentation
1618 
1619     Parameters
1620     ----------
1621     mosaic : list of list of {hashable or nested} or str
1622 
1623         A visual layout of how you want your Axes to be arranged
1624         labeled as strings.  For example ::
1625 
1626            x = [['A panel', 'A panel', 'edge'],
1627                 ['C panel', '.',       'edge']]
1628 
1629         produces 4 axes:
1630 
1631         - 'A panel' which is 1 row high and spans the first two columns
1632         - 'edge' which is 2 rows high and is on the right edge
1633         - 'C panel' which in 1 row and 1 column wide in the bottom left
1634         - a blank space 1 row and 1 column wide in the bottom center
1635 
1636         Any of the entries in the layout can be a list of lists
1637         of the same form to create nested layouts.
1638 
1639         If input is a str, then it must be of the form ::
1640 
1641           '''
1642           AAE
1643           C.E
1644           '''
1645 
1646         where each character is a column and each line is a row.
1647         This only allows only single character Axes labels and does
1648         not allow nesting but is very terse.
1649 
1650     sharex, sharey : bool, default: False
1651         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1652         among all subplots.  In that case, tick label visibility and axis units
1653         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1654         be independent.
1655 
1656     width_ratios : array-like of length *ncols*, optional
1657         Defines the relative widths of the columns. Each column gets a
1658         relative width of ``width_ratios[i] / sum(width_ratios)``.
1659         If not given, all columns will have the same width.  Convenience
1660         for ``gridspec_kw={'width_ratios': [...]}``.
1661 
1662     height_ratios : array-like of length *nrows*, optional
1663         Defines the relative heights of the rows. Each row gets a
1664         relative height of ``height_ratios[i] / sum(height_ratios)``.
1665         If not given, all rows will have the same height. Convenience
1666         for ``gridspec_kw={'height_ratios': [...]}``.
1667 
1668     empty_sentinel : object, optional
1669         Entry in the layout to mean "leave this space empty".  Defaults
1670         to ``'.'``. Note, if *layout* is a string, it is processed via
1671         `inspect.cleandoc` to remove leading white space, which may
1672         interfere with using white-space as the empty sentinel.
1673 
1674     subplot_kw : dict, optional
1675         Dictionary with keywords passed to the `.Figure.add_subplot` call
1676         used to create each subplot.  These values may be overridden by
1677         values in *per_subplot_kw*.
1678 
1679     per_subplot_kw : dict, optional
1680         A dictionary mapping the Axes identifiers or tuples of identifiers
1681         to a dictionary of keyword arguments to be passed to the
1682         `.Figure.add_subplot` call used to create each subplot.  The values
1683         in these dictionaries have precedence over the values in
1684         *subplot_kw*.
1685 
1686         If *mosaic* is a string, and thus all keys are single characters,
1687         it is possible to use a single string instead of a tuple as keys;
1688         i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1689 
1690         .. versionadded:: 3.7
1691 
1692     gridspec_kw : dict, optional
1693         Dictionary with keywords passed to the `.GridSpec` constructor used
1694         to create the grid the subplots are placed on.
1695 
1696     **fig_kw
1697         All additional keyword arguments are passed to the
1698         `.pyplot.figure` call.
1699 
1700     Returns
1701     -------
1702     fig : `.Figure`
1703        The new figure
1704 
1705     dict[label, Axes]
1706        A dictionary mapping the labels to the Axes objects.  The order of
1707        the axes is left-to-right and top-to-bottom of their position in the
1708        total layout.
1709 
1710     """
1711     fig = figure(**fig_kw)
1712     ax_dict = fig.subplot_mosaic(
1713         mosaic, sharex=sharex, sharey=sharey,
1714         height_ratios=height_ratios, width_ratios=width_ratios,
1715         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1716         empty_sentinel=empty_sentinel,
1717         per_subplot_kw=per_subplot_kw,
1718     )
1719     return fig, ax_dict
1720 
1721 
1722 def subplot2grid(
1723     shape: tuple[int, int], loc: tuple[int, int],
1724     rowspan: int = 1, colspan: int = 1,
1725     fig: Figure | None = None,
1726     **kwargs
1727 ) -> matplotlib.axes.Axes:
1728     """
1729     Create a subplot at a specific location inside a regular grid.
1730 
1731     Parameters
1732     ----------
1733     shape : (int, int)
1734         Number of rows and of columns of the grid in which to place axis.
1735     loc : (int, int)
1736         Row number and column number of the axis location within the grid.
1737     rowspan : int, default: 1
1738         Number of rows for the axis to span downwards.
1739     colspan : int, default: 1
1740         Number of columns for the axis to span to the right.
1741     fig : `.Figure`, optional
1742         Figure to place the subplot in. Defaults to the current figure.
1743     **kwargs
1744         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1745 
1746     Returns
1747     -------
1748     `~.axes.Axes`
1749 
1750         The Axes of the subplot. The returned Axes can actually be an instance
1751         of a subclass, such as `.projections.polar.PolarAxes` for polar
1752         projections.
1753 
1754     Notes
1755     -----
1756     The following call ::
1757 
1758         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1759 
1760     is identical to ::
1761 
1762         fig = gcf()
1763         gs = fig.add_gridspec(nrows, ncols)
1764         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1765     """
1766     if fig is None:
1767         fig = gcf()
1768     rows, cols = shape
1769     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1770     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1771     return fig.add_subplot(subplotspec, **kwargs)
1772 
1773 
1774 def twinx(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1775     """
1776     Make and return a second axes that shares the *x*-axis.  The new axes will
1777     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1778     on the right.
1779 
1780     Examples
1781     --------
1782     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1783     """
1784     if ax is None:
1785         ax = gca()
1786     ax1 = ax.twinx()
1787     return ax1
1788 
1789 
1790 def twiny(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1791     """
1792     Make and return a second axes that shares the *y*-axis.  The new axes will
1793     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1794     on the top.
1795 
1796     Examples
1797     --------
1798     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1799     """
1800     if ax is None:
1801         ax = gca()
1802     ax1 = ax.twiny()
1803     return ax1
1804 
1805 
1806 def subplot_tool(targetfig: Figure | None = None) -> SubplotTool | None:
1807     """
1808     Launch a subplot tool window for a figure.
1809 
1810     Returns
1811     -------
1812     `matplotlib.widgets.SubplotTool`
1813     """
1814     if targetfig is None:
1815         targetfig = gcf()
1816     tb = targetfig.canvas.manager.toolbar  # type: ignore[union-attr]
1817     if hasattr(tb, "configure_subplots"):  # toolbar2
1818         from matplotlib.backend_bases import NavigationToolbar2
1819         return cast(NavigationToolbar2, tb).configure_subplots()
1820     elif hasattr(tb, "trigger_tool"):  # toolmanager
1821         from matplotlib.backend_bases import ToolContainerBase
1822         cast(ToolContainerBase, tb).trigger_tool("subplots")
1823         return None
1824     else:
1825         raise ValueError("subplot_tool can only be launched for figures with "
1826                          "an associated toolbar")
1827 
1828 
1829 def box(on: bool | None = None) -> None:
1830     """
1831     Turn the axes box on or off on the current axes.
1832 
1833     Parameters
1834     ----------
1835     on : bool or None
1836         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1837         the state.
1838 
1839     See Also
1840     --------
1841     :meth:`matplotlib.axes.Axes.set_frame_on`
1842     :meth:`matplotlib.axes.Axes.get_frame_on`
1843     """
1844     ax = gca()
1845     if on is None:
1846         on = not ax.get_frame_on()
1847     ax.set_frame_on(on)
1848 
1849 ## Axis ##
1850 
1851 
1852 def xlim(*args, **kwargs) -> tuple[float, float]:
1853     """
1854     Get or set the x limits of the current axes.
1855 
1856     Call signatures::
1857 
1858         left, right = xlim()  # return the current xlim
1859         xlim((left, right))   # set the xlim to left, right
1860         xlim(left, right)     # set the xlim to left, right
1861 
1862     If you do not specify args, you can pass *left* or *right* as kwargs,
1863     i.e.::
1864 
1865         xlim(right=3)  # adjust the right leaving left unchanged
1866         xlim(left=1)  # adjust the left leaving right unchanged
1867 
1868     Setting limits turns autoscaling off for the x-axis.
1869 
1870     Returns
1871     -------
1872     left, right
1873         A tuple of the new x-axis limits.
1874 
1875     Notes
1876     -----
1877     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1878     equivalent of calling `~.Axes.get_xlim` on the current axes.
1879     Calling this function with arguments is the pyplot equivalent of calling
1880     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1881     """
1882     ax = gca()
1883     if not args and not kwargs:
1884         return ax.get_xlim()
1885     ret = ax.set_xlim(*args, **kwargs)
1886     return ret
1887 
1888 
1889 def ylim(*args, **kwargs) -> tuple[float, float]:
1890     """
1891     Get or set the y-limits of the current axes.
1892 
1893     Call signatures::
1894 
1895         bottom, top = ylim()  # return the current ylim
1896         ylim((bottom, top))   # set the ylim to bottom, top
1897         ylim(bottom, top)     # set the ylim to bottom, top
1898 
1899     If you do not specify args, you can alternatively pass *bottom* or
1900     *top* as kwargs, i.e.::
1901 
1902         ylim(top=3)  # adjust the top leaving bottom unchanged
1903         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1904 
1905     Setting limits turns autoscaling off for the y-axis.
1906 
1907     Returns
1908     -------
1909     bottom, top
1910         A tuple of the new y-axis limits.
1911 
1912     Notes
1913     -----
1914     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1915     equivalent of calling `~.Axes.get_ylim` on the current axes.
1916     Calling this function with arguments is the pyplot equivalent of calling
1917     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1918     """
1919     ax = gca()
1920     if not args and not kwargs:
1921         return ax.get_ylim()
1922     ret = ax.set_ylim(*args, **kwargs)
1923     return ret
1924 
1925 
1926 def xticks(
1927     ticks: ArrayLike | None = None,
1928     labels: Sequence[str] | None = None,
1929     *,
1930     minor: bool = False,
1931     **kwargs
1932 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
1933     """
1934     Get or set the current tick locations and labels of the x-axis.
1935 
1936     Pass no arguments to return the current values without modifying them.
1937 
1938     Parameters
1939     ----------
1940     ticks : array-like, optional
1941         The list of xtick locations.  Passing an empty list removes all xticks.
1942     labels : array-like, optional
1943         The labels to place at the given *ticks* locations.  This argument can
1944         only be passed if *ticks* is passed as well.
1945     minor : bool, default: False
1946         If ``False``, get/set the major ticks/labels; if ``True``, the minor
1947         ticks/labels.
1948     **kwargs
1949         `.Text` properties can be used to control the appearance of the labels.
1950 
1951     Returns
1952     -------
1953     locs
1954         The list of xtick locations.
1955     labels
1956         The list of xlabel `.Text` objects.
1957 
1958     Notes
1959     -----
1960     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1961     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1962     the current axes.
1963     Calling this function with arguments is the pyplot equivalent of calling
1964     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1965 
1966     Examples
1967     --------
1968     >>> locs, labels = xticks()  # Get the current locations and labels.
1969     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1970     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1971     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1972     ...        rotation=20)  # Set text labels and properties.
1973     >>> xticks([])  # Disable xticks.
1974     """
1975     ax = gca()
1976 
1977     locs: list[Tick] | np.ndarray
1978     if ticks is None:
1979         locs = ax.get_xticks(minor=minor)
1980         if labels is not None:
1981             raise TypeError("xticks(): Parameter 'labels' can't be set "
1982                             "without setting 'ticks'")
1983     else:
1984         locs = ax.set_xticks(ticks, minor=minor)
1985 
1986     labels_out: list[Text] = []
1987     if labels is None:
1988         labels_out = ax.get_xticklabels(minor=minor)
1989         for l in labels_out:
1990             l._internal_update(kwargs)
1991     else:
1992         labels_out = ax.set_xticklabels(labels, minor=minor, **kwargs)
1993 
1994     return locs, labels_out
1995 
1996 
1997 def yticks(
1998     ticks: ArrayLike | None = None,
1999     labels: Sequence[str] | None = None,
2000     *,
2001     minor: bool = False,
2002     **kwargs
2003 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
2004     """
2005     Get or set the current tick locations and labels of the y-axis.
2006 
2007     Pass no arguments to return the current values without modifying them.
2008 
2009     Parameters
2010     ----------
2011     ticks : array-like, optional
2012         The list of ytick locations.  Passing an empty list removes all yticks.
2013     labels : array-like, optional
2014         The labels to place at the given *ticks* locations.  This argument can
2015         only be passed if *ticks* is passed as well.
2016     minor : bool, default: False
2017         If ``False``, get/set the major ticks/labels; if ``True``, the minor
2018         ticks/labels.
2019     **kwargs
2020         `.Text` properties can be used to control the appearance of the labels.
2021 
2022     Returns
2023     -------
2024     locs
2025         The list of ytick locations.
2026     labels
2027         The list of ylabel `.Text` objects.
2028 
2029     Notes
2030     -----
2031     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
2032     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
2033     the current axes.
2034     Calling this function with arguments is the pyplot equivalent of calling
2035     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
2036 
2037     Examples
2038     --------
2039     >>> locs, labels = yticks()  # Get the current locations and labels.
2040     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
2041     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
2042     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
2043     ...        rotation=45)  # Set text labels and properties.
2044     >>> yticks([])  # Disable yticks.
2045     """
2046     ax = gca()
2047 
2048     locs: list[Tick] | np.ndarray
2049     if ticks is None:
2050         locs = ax.get_yticks(minor=minor)
2051         if labels is not None:
2052             raise TypeError("yticks(): Parameter 'labels' can't be set "
2053                             "without setting 'ticks'")
2054     else:
2055         locs = ax.set_yticks(ticks, minor=minor)
2056 
2057     labels_out: list[Text] = []
2058     if labels is None:
2059         labels_out = ax.get_yticklabels(minor=minor)
2060         for l in labels_out:
2061             l._internal_update(kwargs)
2062     else:
2063         labels_out = ax.set_yticklabels(labels, minor=minor, **kwargs)
2064 
2065     return locs, labels_out
2066 
2067 
2068 def rgrids(
2069     radii: ArrayLike | None = None,
2070     labels: Sequence[str | Text] | None = None,
2071     angle: float | None = None,
2072     fmt: str | None = None,
2073     **kwargs
2074 ) -> tuple[list[Line2D], list[Text]]:
2075     """
2076     Get or set the radial gridlines on the current polar plot.
2077 
2078     Call signatures::
2079 
2080      lines, labels = rgrids()
2081      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
2082 
2083     When called with no arguments, `.rgrids` simply returns the tuple
2084     (*lines*, *labels*). When called with arguments, the labels will
2085     appear at the specified radial distances and angle.
2086 
2087     Parameters
2088     ----------
2089     radii : tuple with floats
2090         The radii for the radial gridlines
2091 
2092     labels : tuple with strings or None
2093         The labels to use at each radial gridline. The
2094         `matplotlib.ticker.ScalarFormatter` will be used if None.
2095 
2096     angle : float
2097         The angular position of the radius labels in degrees.
2098 
2099     fmt : str or None
2100         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2101         For example '%f'.
2102 
2103     Returns
2104     -------
2105     lines : list of `.lines.Line2D`
2106         The radial gridlines.
2107 
2108     labels : list of `.text.Text`
2109         The tick labels.
2110 
2111     Other Parameters
2112     ----------------
2113     **kwargs
2114         *kwargs* are optional `.Text` properties for the labels.
2115 
2116     See Also
2117     --------
2118     .pyplot.thetagrids
2119     .projections.polar.PolarAxes.set_rgrids
2120     .Axis.get_gridlines
2121     .Axis.get_ticklabels
2122 
2123     Examples
2124     --------
2125     ::
2126 
2127       # set the locations of the radial gridlines
2128       lines, labels = rgrids( (0.25, 0.5, 1.0) )
2129 
2130       # set the locations and labels of the radial gridlines
2131       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
2132     """
2133     ax = gca()
2134     if not isinstance(ax, PolarAxes):
2135         raise RuntimeError('rgrids only defined for polar axes')
2136     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
2137         lines_out: list[Line2D] = ax.yaxis.get_gridlines()
2138         labels_out: list[Text] = ax.yaxis.get_ticklabels()
2139     elif radii is None:
2140         raise TypeError("'radii' cannot be None when other parameters are passed")
2141     else:
2142         lines_out, labels_out = ax.set_rgrids(
2143             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
2144     return lines_out, labels_out
2145 
2146 
2147 def thetagrids(
2148     angles: ArrayLike | None = None,
2149     labels: Sequence[str | Text] | None = None,
2150     fmt: str | None = None,
2151     **kwargs
2152 ) -> tuple[list[Line2D], list[Text]]:
2153     """
2154     Get or set the theta gridlines on the current polar plot.
2155 
2156     Call signatures::
2157 
2158      lines, labels = thetagrids()
2159      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
2160 
2161     When called with no arguments, `.thetagrids` simply returns the tuple
2162     (*lines*, *labels*). When called with arguments, the labels will
2163     appear at the specified angles.
2164 
2165     Parameters
2166     ----------
2167     angles : tuple with floats, degrees
2168         The angles of the theta gridlines.
2169 
2170     labels : tuple with strings or None
2171         The labels to use at each radial gridline. The
2172         `.projections.polar.ThetaFormatter` will be used if None.
2173 
2174     fmt : str or None
2175         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2176         For example '%f'. Note that the angle in radians will be used.
2177 
2178     Returns
2179     -------
2180     lines : list of `.lines.Line2D`
2181         The theta gridlines.
2182 
2183     labels : list of `.text.Text`
2184         The tick labels.
2185 
2186     Other Parameters
2187     ----------------
2188     **kwargs
2189         *kwargs* are optional `.Text` properties for the labels.
2190 
2191     See Also
2192     --------
2193     .pyplot.rgrids
2194     .projections.polar.PolarAxes.set_thetagrids
2195     .Axis.get_gridlines
2196     .Axis.get_ticklabels
2197 
2198     Examples
2199     --------
2200     ::
2201 
2202       # set the locations of the angular gridlines
2203       lines, labels = thetagrids(range(45, 360, 90))
2204 
2205       # set the locations and labels of the angular gridlines
2206       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
2207     """
2208     ax = gca()
2209     if not isinstance(ax, PolarAxes):
2210         raise RuntimeError('thetagrids only defined for polar axes')
2211     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
2212         lines_out: list[Line2D] = ax.xaxis.get_ticklines()
2213         labels_out: list[Text] = ax.xaxis.get_ticklabels()
2214     elif angles is None:
2215         raise TypeError("'angles' cannot be None when other parameters are passed")
2216     else:
2217         lines_out, labels_out = ax.set_thetagrids(angles,
2218                                                   labels=labels, fmt=fmt,
2219                                                   **kwargs)
2220     return lines_out, labels_out
2221 
2222 
2223 @_api.deprecated("3.7", pending=True)
2224 def get_plot_commands() -> list[str]:
2225     """
2226     Get a sorted list of all of the plotting commands.
2227     """
2228     NON_PLOT_COMMANDS = {
2229         'connect', 'disconnect', 'get_current_fig_manager', 'ginput',
2230         'new_figure_manager', 'waitforbuttonpress'}
2231     return [name for name in _get_pyplot_commands()
2232             if name not in NON_PLOT_COMMANDS]
2233 
2234 
2235 def _get_pyplot_commands() -> list[str]:
2236     # This works by searching for all functions in this module and removing
2237     # a few hard-coded exclusions, as well as all of the colormap-setting
2238     # functions, and anything marked as private with a preceding underscore.
2239     exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}
2240     this_module = inspect.getmodule(get_plot_commands)
2241     return sorted(
2242         name for name, obj in globals().items()
2243         if not name.startswith('_') and name not in exclude
2244            and inspect.isfunction(obj)
2245            and inspect.getmodule(obj) is this_module)
2246 
2247 
2248 ## Plotting part 1: manually generated functions and wrappers ##
2249 
2250 
2251 @_copy_docstring_and_deprecators(Figure.colorbar)
2252 def colorbar(
2253     mappable: ScalarMappable | None = None,
2254     cax: matplotlib.axes.Axes | None = None,
2255     ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,
2256     **kwargs
2257 ) -> Colorbar:
2258     if mappable is None:
2259         mappable = gci()
2260         if mappable is None:
2261             raise RuntimeError('No mappable was found to use for colorbar '
2262                                'creation. First define a mappable such as '
2263                                'an image (with imshow) or a contour set ('
2264                                'with contourf).')
2265     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2266     return ret
2267 
2268 
2269 def clim(vmin: float | None = None, vmax: float | None = None) -> None:
2270     """
2271     Set the color limits of the current image.
2272 
2273     If either *vmin* or *vmax* is None, the image min/max respectively
2274     will be used for color scaling.
2275 
2276     If you want to set the clim of multiple images, use
2277     `~.ScalarMappable.set_clim` on every image, for example::
2278 
2279       for im in gca().get_images():
2280           im.set_clim(0, 0.5)
2281 
2282     """
2283     im = gci()
2284     if im is None:
2285         raise RuntimeError('You must first define an image, e.g., with imshow')
2286 
2287     im.set_clim(vmin, vmax)
2288 
2289 
2290 # eventually this implementation should move here, use indirection for now to
2291 # avoid having two copies of the code floating around.
2292 def get_cmap(
2293     name: Colormap | str | None = None,
2294     lut: int | None = None
2295 ) -> Colormap:
2296     return cm._get_cmap(name=name, lut=lut)  # type: ignore
2297 get_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore
2298 
2299 
2300 def set_cmap(cmap: Colormap | str) -> None:
2301     """
2302     Set the default colormap, and applies it to the current image if any.
2303 
2304     Parameters
2305     ----------
2306     cmap : `~matplotlib.colors.Colormap` or str
2307         A colormap instance or the name of a registered colormap.
2308 
2309     See Also
2310     --------
2311     colormaps
2312     matplotlib.cm.register_cmap
2313     matplotlib.cm.get_cmap
2314     """
2315     cmap = get_cmap(cmap)
2316 
2317     rc('image', cmap=cmap.name)
2318     im = gci()
2319 
2320     if im is not None:
2321         im.set_cmap(cmap)
2322 
2323 
2324 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2325 def imread(
2326         fname: str | pathlib.Path | BinaryIO, format: str | None = None
2327 ) -> np.ndarray:
2328     return matplotlib.image.imread(fname, format)
2329 
2330 
2331 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2332 def imsave(
2333     fname: str | os.PathLike | BinaryIO, arr: ArrayLike, **kwargs
2334 ) -> None:
2335     matplotlib.image.imsave(fname, arr, **kwargs)
2336 
2337 
2338 def matshow(A: ArrayLike, fignum: None | int = None, **kwargs) -> AxesImage:
2339     """
2340     Display an array as a matrix in a new figure window.
2341 
2342     The origin is set at the upper left hand corner and rows (first
2343     dimension of the array) are displayed horizontally.  The aspect
2344     ratio of the figure window is that of the array, unless this would
2345     make an excessively short or narrow figure.
2346 
2347     Tick labels for the xaxis are placed on top.
2348 
2349     Parameters
2350     ----------
2351     A : 2D array-like
2352         The matrix to be displayed.
2353 
2354     fignum : None or int
2355         If *None*, create a new figure window with automatic numbering.
2356 
2357         If a nonzero integer, draw into the figure with the given number
2358         (create it if it does not exist).
2359 
2360         If 0, use the current axes (or create one if it does not exist).
2361 
2362         .. note::
2363 
2364            Because of how `.Axes.matshow` tries to set the figure aspect
2365            ratio to be the one of the array, strange things may happen if you
2366            reuse an existing figure.
2367 
2368     Returns
2369     -------
2370     `~matplotlib.image.AxesImage`
2371 
2372     Other Parameters
2373     ----------------
2374     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2375 
2376     """
2377     A = np.asanyarray(A)
2378     if fignum == 0:
2379         ax = gca()
2380     else:
2381         # Extract actual aspect ratio of array and make appropriately sized
2382         # figure.
2383         fig = figure(fignum, figsize=figaspect(A))
2384         ax = fig.add_axes((0.15, 0.09, 0.775, 0.775))
2385     im = ax.matshow(A, **kwargs)
2386     sci(im)
2387     return im
2388 
2389 
2390 def polar(*args, **kwargs) -> list[Line2D]:
2391     """
2392     Make a polar plot.
2393 
2394     call signature::
2395 
2396       polar(theta, r, **kwargs)
2397 
2398     Multiple *theta*, *r* arguments are supported, with format strings, as in
2399     `plot`.
2400     """
2401     # If an axis already exists, check if it has a polar projection
2402     if gcf().get_axes():
2403         ax = gca()
2404         if not isinstance(ax, PolarAxes):
2405             _api.warn_external('Trying to create polar plot on an Axes '
2406                                'that does not have a polar projection.')
2407     else:
2408         ax = axes(projection="polar")
2409     return ax.plot(*args, **kwargs)
2410 
2411 
2412 # If rcParams['backend_fallback'] is true, and an interactive backend is
2413 # requested, ignore rcParams['backend'] and force selection of a backend that
2414 # is compatible with the current running interactive framework.
2415 if (rcParams["backend_fallback"]
2416         and rcParams._get_backend_or_none() in (  # type: ignore
2417             set(rcsetup.interactive_bk) - {'WebAgg', 'nbAgg'})
2418         and cbook._get_running_interactive_framework()):  # type: ignore
2419     rcParams._set("backend", rcsetup._auto_backend_sentinel)  # type: ignore
2420 
2421 # fmt: on
2422 
2423 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2424 
2425 
2426 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2427 @_copy_docstring_and_deprecators(Figure.figimage)
2428 def figimage(
2429     X: ArrayLike,
2430     xo: int = 0,
2431     yo: int = 0,
2432     alpha: float | None = None,
2433     norm: str | Normalize | None = None,
2434     cmap: str | Colormap | None = None,
2435     vmin: float | None = None,
2436     vmax: float | None = None,
2437     origin: Literal["upper", "lower"] | None = None,
2438     resize: bool = False,
2439     **kwargs,
2440 ) -> FigureImage:
2441     return gcf().figimage(
2442         X,
2443         xo=xo,
2444         yo=yo,
2445         alpha=alpha,
2446         norm=norm,
2447         cmap=cmap,
2448         vmin=vmin,
2449         vmax=vmax,
2450         origin=origin,
2451         resize=resize,
2452         **kwargs,
2453     )
2454 
2455 
2456 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2457 @_copy_docstring_and_deprecators(Figure.text)
2458 def figtext(
2459     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
2460 ) -> Text:
2461     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2462 
2463 
2464 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2465 @_copy_docstring_and_deprecators(Figure.gca)
2466 def gca() -> Axes:
2467     return gcf().gca()
2468 
2469 
2470 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2471 @_copy_docstring_and_deprecators(Figure._gci)
2472 def gci() -> ScalarMappable | None:
2473     return gcf()._gci()
2474 
2475 
2476 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2477 @_copy_docstring_and_deprecators(Figure.ginput)
2478 def ginput(
2479     n: int = 1,
2480     timeout: float = 30,
2481     show_clicks: bool = True,
2482     mouse_add: MouseButton = MouseButton.LEFT,
2483     mouse_pop: MouseButton = MouseButton.RIGHT,
2484     mouse_stop: MouseButton = MouseButton.MIDDLE,
2485 ) -> list[tuple[int, int]]:
2486     return gcf().ginput(
2487         n=n,
2488         timeout=timeout,
2489         show_clicks=show_clicks,
2490         mouse_add=mouse_add,
2491         mouse_pop=mouse_pop,
2492         mouse_stop=mouse_stop,
2493     )
2494 
2495 
2496 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2497 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2498 def subplots_adjust(
2499     left: float | None = None,
2500     bottom: float | None = None,
2501     right: float | None = None,
2502     top: float | None = None,
2503     wspace: float | None = None,
2504     hspace: float | None = None,
2505 ) -> None:
2506     gcf().subplots_adjust(
2507         left=left, bottom=bottom, right=right, top=top, wspace=wspace, hspace=hspace
2508     )
2509 
2510 
2511 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2512 @_copy_docstring_and_deprecators(Figure.suptitle)
2513 def suptitle(t: str, **kwargs) -> Text:
2514     return gcf().suptitle(t, **kwargs)
2515 
2516 
2517 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2518 @_copy_docstring_and_deprecators(Figure.tight_layout)
2519 def tight_layout(
2520     *,
2521     pad: float = 1.08,
2522     h_pad: float | None = None,
2523     w_pad: float | None = None,
2524     rect: tuple[float, float, float, float] | None = None,
2525 ) -> None:
2526     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2527 
2528 
2529 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2530 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2531 def waitforbuttonpress(timeout: float = -1) -> None | bool:
2532     return gcf().waitforbuttonpress(timeout=timeout)
2533 
2534 
2535 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2536 @_copy_docstring_and_deprecators(Axes.acorr)
2537 def acorr(
2538     x: ArrayLike, *, data=None, **kwargs
2539 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
2540     return gca().acorr(x, **({"data": data} if data is not None else {}), **kwargs)
2541 
2542 
2543 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2544 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2545 def angle_spectrum(
2546     x: ArrayLike,
2547     Fs: float | None = None,
2548     Fc: int | None = None,
2549     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2550     pad_to: int | None = None,
2551     sides: Literal["default", "onesided", "twosided"] | None = None,
2552     *,
2553     data=None,
2554     **kwargs,
2555 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
2556     return gca().angle_spectrum(
2557         x,
2558         Fs=Fs,
2559         Fc=Fc,
2560         window=window,
2561         pad_to=pad_to,
2562         sides=sides,
2563         **({"data": data} if data is not None else {}),
2564         **kwargs,
2565     )
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.annotate)
2570 def annotate(
2571     text: str,
2572     xy: tuple[float, float],
2573     xytext: tuple[float, float] | None = None,
2574     xycoords: str
2575     | Artist
2576     | Transform
2577     | Callable[[RendererBase], Bbox | Transform]
2578     | tuple[float, float] = "data",
2579     textcoords: str
2580     | Artist
2581     | Transform
2582     | Callable[[RendererBase], Bbox | Transform]
2583     | tuple[float, float]
2584     | None = None,
2585     arrowprops: dict[str, Any] | None = None,
2586     annotation_clip: bool | None = None,
2587     **kwargs,
2588 ) -> Annotation:
2589     return gca().annotate(
2590         text,
2591         xy,
2592         xytext=xytext,
2593         xycoords=xycoords,
2594         textcoords=textcoords,
2595         arrowprops=arrowprops,
2596         annotation_clip=annotation_clip,
2597         **kwargs,
2598     )
2599 
2600 
2601 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2602 @_copy_docstring_and_deprecators(Axes.arrow)
2603 def arrow(x: float, y: float, dx: float, dy: float, **kwargs) -> FancyArrow:
2604     return gca().arrow(x, y, dx, dy, **kwargs)
2605 
2606 
2607 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2608 @_copy_docstring_and_deprecators(Axes.autoscale)
2609 def autoscale(
2610     enable: bool = True,
2611     axis: Literal["both", "x", "y"] = "both",
2612     tight: bool | None = None,
2613 ) -> None:
2614     gca().autoscale(enable=enable, axis=axis, tight=tight)
2615 
2616 
2617 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2618 @_copy_docstring_and_deprecators(Axes.axhline)
2619 def axhline(y: float = 0, xmin: float = 0, xmax: float = 1, **kwargs) -> Line2D:
2620     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2621 
2622 
2623 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2624 @_copy_docstring_and_deprecators(Axes.axhspan)
2625 def axhspan(
2626     ymin: float, ymax: float, xmin: float = 0, xmax: float = 1, **kwargs
2627 ) -> Polygon:
2628     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2629 
2630 
2631 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2632 @_copy_docstring_and_deprecators(Axes.axis)
2633 def axis(
2634     arg: tuple[float, float, float, float] | bool | str | None = None,
2635     /,
2636     *,
2637     emit: bool = True,
2638     **kwargs,
2639 ) -> tuple[float, float, float, float]:
2640     return gca().axis(arg, emit=emit, **kwargs)
2641 
2642 
2643 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2644 @_copy_docstring_and_deprecators(Axes.axline)
2645 def axline(
2646     xy1: tuple[float, float],
2647     xy2: tuple[float, float] | None = None,
2648     *,
2649     slope: float | None = None,
2650     **kwargs,
2651 ) -> Line2D:
2652     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2653 
2654 
2655 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2656 @_copy_docstring_and_deprecators(Axes.axvline)
2657 def axvline(x: float = 0, ymin: float = 0, ymax: float = 1, **kwargs) -> Line2D:
2658     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2659 
2660 
2661 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2662 @_copy_docstring_and_deprecators(Axes.axvspan)
2663 def axvspan(
2664     xmin: float, xmax: float, ymin: float = 0, ymax: float = 1, **kwargs
2665 ) -> Polygon:
2666     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2667 
2668 
2669 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2670 @_copy_docstring_and_deprecators(Axes.bar)
2671 def bar(
2672     x: float | ArrayLike,
2673     height: float | ArrayLike,
2674     width: float | ArrayLike = 0.8,
2675     bottom: float | ArrayLike | None = None,
2676     *,
2677     align: Literal["center", "edge"] = "center",
2678     data=None,
2679     **kwargs,
2680 ) -> BarContainer:
2681     return gca().bar(
2682         x,
2683         height,
2684         width=width,
2685         bottom=bottom,
2686         align=align,
2687         **({"data": data} if data is not None else {}),
2688         **kwargs,
2689     )
2690 
2691 
2692 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2693 @_copy_docstring_and_deprecators(Axes.barbs)
2694 def barbs(*args, data=None, **kwargs) -> Barbs:
2695     return gca().barbs(*args, **({"data": data} if data is not None else {}), **kwargs)
2696 
2697 
2698 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2699 @_copy_docstring_and_deprecators(Axes.barh)
2700 def barh(
2701     y: float | ArrayLike,
2702     width: float | ArrayLike,
2703     height: float | ArrayLike = 0.8,
2704     left: float | ArrayLike | None = None,
2705     *,
2706     align: Literal["center", "edge"] = "center",
2707     data=None,
2708     **kwargs,
2709 ) -> BarContainer:
2710     return gca().barh(
2711         y,
2712         width,
2713         height=height,
2714         left=left,
2715         align=align,
2716         **({"data": data} if data is not None else {}),
2717         **kwargs,
2718     )
2719 
2720 
2721 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2722 @_copy_docstring_and_deprecators(Axes.bar_label)
2723 def bar_label(
2724     container: BarContainer,
2725     labels: ArrayLike | None = None,
2726     *,
2727     fmt: str | Callable[[float], str] = "%g",
2728     label_type: Literal["center", "edge"] = "edge",
2729     padding: float = 0,
2730     **kwargs,
2731 ) -> list[Annotation]:
2732     return gca().bar_label(
2733         container,
2734         labels=labels,
2735         fmt=fmt,
2736         label_type=label_type,
2737         padding=padding,
2738         **kwargs,
2739     )
2740 
2741 
2742 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2743 @_copy_docstring_and_deprecators(Axes.boxplot)
2744 def boxplot(
2745     x: ArrayLike | Sequence[ArrayLike],
2746     notch: bool | None = None,
2747     sym: str | None = None,
2748     vert: bool | None = None,
2749     whis: float | tuple[float, float] | None = None,
2750     positions: ArrayLike | None = None,
2751     widths: float | ArrayLike | None = None,
2752     patch_artist: bool | None = None,
2753     bootstrap: int | None = None,
2754     usermedians: ArrayLike | None = None,
2755     conf_intervals: ArrayLike | None = None,
2756     meanline: bool | None = None,
2757     showmeans: bool | None = None,
2758     showcaps: bool | None = None,
2759     showbox: bool | None = None,
2760     showfliers: bool | None = None,
2761     boxprops: dict[str, Any] | None = None,
2762     labels: Sequence[str] | None = None,
2763     flierprops: dict[str, Any] | None = None,
2764     medianprops: dict[str, Any] | None = None,
2765     meanprops: dict[str, Any] | None = None,
2766     capprops: dict[str, Any] | None = None,
2767     whiskerprops: dict[str, Any] | None = None,
2768     manage_ticks: bool = True,
2769     autorange: bool = False,
2770     zorder: float | None = None,
2771     capwidths: float | ArrayLike | None = None,
2772     *,
2773     data=None,
2774 ) -> dict[str, Any]:
2775     return gca().boxplot(
2776         x,
2777         notch=notch,
2778         sym=sym,
2779         vert=vert,
2780         whis=whis,
2781         positions=positions,
2782         widths=widths,
2783         patch_artist=patch_artist,
2784         bootstrap=bootstrap,
2785         usermedians=usermedians,
2786         conf_intervals=conf_intervals,
2787         meanline=meanline,
2788         showmeans=showmeans,
2789         showcaps=showcaps,
2790         showbox=showbox,
2791         showfliers=showfliers,
2792         boxprops=boxprops,
2793         labels=labels,
2794         flierprops=flierprops,
2795         medianprops=medianprops,
2796         meanprops=meanprops,
2797         capprops=capprops,
2798         whiskerprops=whiskerprops,
2799         manage_ticks=manage_ticks,
2800         autorange=autorange,
2801         zorder=zorder,
2802         capwidths=capwidths,
2803         **({"data": data} if data is not None else {}),
2804     )
2805 
2806 
2807 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2808 @_copy_docstring_and_deprecators(Axes.broken_barh)
2809 def broken_barh(
2810     xranges: Sequence[tuple[float, float]],
2811     yrange: tuple[float, float],
2812     *,
2813     data=None,
2814     **kwargs,
2815 ) -> BrokenBarHCollection:
2816     return gca().broken_barh(
2817         xranges, yrange, **({"data": data} if data is not None else {}), **kwargs
2818     )
2819 
2820 
2821 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2822 @_copy_docstring_and_deprecators(Axes.clabel)
2823 def clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:
2824     return gca().clabel(CS, levels=levels, **kwargs)
2825 
2826 
2827 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2828 @_copy_docstring_and_deprecators(Axes.cohere)
2829 def cohere(
2830     x: ArrayLike,
2831     y: ArrayLike,
2832     NFFT: int = 256,
2833     Fs: float = 2,
2834     Fc: int = 0,
2835     detrend: Literal["none", "mean", "linear"]
2836     | Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
2837     window: Callable[[ArrayLike], ArrayLike] | ArrayLike = mlab.window_hanning,
2838     noverlap: int = 0,
2839     pad_to: int | None = None,
2840     sides: Literal["default", "onesided", "twosided"] = "default",
2841     scale_by_freq: bool | None = None,
2842     *,
2843     data=None,
2844     **kwargs,
2845 ) -> tuple[np.ndarray, np.ndarray]:
2846     return gca().cohere(
2847         x,
2848         y,
2849         NFFT=NFFT,
2850         Fs=Fs,
2851         Fc=Fc,
2852         detrend=detrend,
2853         window=window,
2854         noverlap=noverlap,
2855         pad_to=pad_to,
2856         sides=sides,
2857         scale_by_freq=scale_by_freq,
2858         **({"data": data} if data is not None else {}),
2859         **kwargs,
2860     )
2861 
2862 
2863 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2864 @_copy_docstring_and_deprecators(Axes.contour)
2865 def contour(*args, data=None, **kwargs) -> QuadContourSet:
2866     __ret = gca().contour(
2867         *args, **({"data": data} if data is not None else {}), **kwargs
2868     )
2869     if __ret._A is not None:  # type: ignore[attr-defined]
2870         sci(__ret)
2871     return __ret
2872 
2873 
2874 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2875 @_copy_docstring_and_deprecators(Axes.contourf)
2876 def contourf(*args, data=None, **kwargs) -> QuadContourSet:
2877     __ret = gca().contourf(
2878         *args, **({"data": data} if data is not None else {}), **kwargs
2879     )
2880     if __ret._A is not None:  # type: ignore[attr-defined]
2881         sci(__ret)
2882     return __ret
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.csd)
2887 def csd(
2888     x: ArrayLike,
2889     y: ArrayLike,
2890     NFFT: int | None = None,
2891     Fs: float | None = None,
2892     Fc: int | None = None,
2893     detrend: Literal["none", "mean", "linear"]
2894     | Callable[[ArrayLike], ArrayLike]
2895     | None = None,
2896     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2897     noverlap: int | None = None,
2898     pad_to: int | None = None,
2899     sides: Literal["default", "onesided", "twosided"] | None = None,
2900     scale_by_freq: bool | None = None,
2901     return_line: bool | None = None,
2902     *,
2903     data=None,
2904     **kwargs,
2905 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
2906     return gca().csd(
2907         x,
2908         y,
2909         NFFT=NFFT,
2910         Fs=Fs,
2911         Fc=Fc,
2912         detrend=detrend,
2913         window=window,
2914         noverlap=noverlap,
2915         pad_to=pad_to,
2916         sides=sides,
2917         scale_by_freq=scale_by_freq,
2918         return_line=return_line,
2919         **({"data": data} if data is not None else {}),
2920         **kwargs,
2921     )
2922 
2923 
2924 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2925 @_copy_docstring_and_deprecators(Axes.ecdf)
2926 def ecdf(
2927     x: ArrayLike,
2928     weights: ArrayLike | None = None,
2929     *,
2930     complementary: bool = False,
2931     orientation: Literal["vertical", "horizonatal"] = "vertical",
2932     compress: bool = False,
2933     data=None,
2934     **kwargs,
2935 ) -> Line2D:
2936     return gca().ecdf(
2937         x,
2938         weights=weights,
2939         complementary=complementary,
2940         orientation=orientation,
2941         compress=compress,
2942         **({"data": data} if data is not None else {}),
2943         **kwargs,
2944     )
2945 
2946 
2947 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2948 @_copy_docstring_and_deprecators(Axes.errorbar)
2949 def errorbar(
2950     x: float | ArrayLike,
2951     y: float | ArrayLike,
2952     yerr: float | ArrayLike | None = None,
2953     xerr: float | ArrayLike | None = None,
2954     fmt: str = "",
2955     ecolor: ColorType | None = None,
2956     elinewidth: float | None = None,
2957     capsize: float | None = None,
2958     barsabove: bool = False,
2959     lolims: bool = False,
2960     uplims: bool = False,
2961     xlolims: bool = False,
2962     xuplims: bool = False,
2963     errorevery: int | tuple[int, int] = 1,
2964     capthick: float | None = None,
2965     *,
2966     data=None,
2967     **kwargs,
2968 ) -> ErrorbarContainer:
2969     return gca().errorbar(
2970         x,
2971         y,
2972         yerr=yerr,
2973         xerr=xerr,
2974         fmt=fmt,
2975         ecolor=ecolor,
2976         elinewidth=elinewidth,
2977         capsize=capsize,
2978         barsabove=barsabove,
2979         lolims=lolims,
2980         uplims=uplims,
2981         xlolims=xlolims,
2982         xuplims=xuplims,
2983         errorevery=errorevery,
2984         capthick=capthick,
2985         **({"data": data} if data is not None else {}),
2986         **kwargs,
2987     )
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @_copy_docstring_and_deprecators(Axes.eventplot)
2992 def eventplot(
2993     positions: ArrayLike | Sequence[ArrayLike],
2994     orientation: Literal["horizontal", "vertical"] = "horizontal",
2995     lineoffsets: float | Sequence[float] = 1,
2996     linelengths: float | Sequence[float] = 1,
2997     linewidths: float | Sequence[float] | None = None,
2998     colors: ColorType | Sequence[ColorType] | None = None,
2999     alpha: float | Sequence[float] | None = None,
3000     linestyles: LineStyleType | Sequence[LineStyleType] = "solid",
3001     *,
3002     data=None,
3003     **kwargs,
3004 ) -> EventCollection:
3005     return gca().eventplot(
3006         positions,
3007         orientation=orientation,
3008         lineoffsets=lineoffsets,
3009         linelengths=linelengths,
3010         linewidths=linewidths,
3011         colors=colors,
3012         alpha=alpha,
3013         linestyles=linestyles,
3014         **({"data": data} if data is not None else {}),
3015         **kwargs,
3016     )
3017 
3018 
3019 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3020 @_copy_docstring_and_deprecators(Axes.fill)
3021 def fill(*args, data=None, **kwargs) -> list[Polygon]:
3022     return gca().fill(*args, **({"data": data} if data is not None else {}), **kwargs)
3023 
3024 
3025 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3026 @_copy_docstring_and_deprecators(Axes.fill_between)
3027 def fill_between(
3028     x: ArrayLike,
3029     y1: ArrayLike | float,
3030     y2: ArrayLike | float = 0,
3031     where: Sequence[bool] | None = None,
3032     interpolate: bool = False,
3033     step: Literal["pre", "post", "mid"] | None = None,
3034     *,
3035     data=None,
3036     **kwargs,
3037 ) -> PolyCollection:
3038     return gca().fill_between(
3039         x,
3040         y1,
3041         y2=y2,
3042         where=where,
3043         interpolate=interpolate,
3044         step=step,
3045         **({"data": data} if data is not None else {}),
3046         **kwargs,
3047     )
3048 
3049 
3050 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3051 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
3052 def fill_betweenx(
3053     y: ArrayLike,
3054     x1: ArrayLike | float,
3055     x2: ArrayLike | float = 0,
3056     where: Sequence[bool] | None = None,
3057     step: Literal["pre", "post", "mid"] | None = None,
3058     interpolate: bool = False,
3059     *,
3060     data=None,
3061     **kwargs,
3062 ) -> PolyCollection:
3063     return gca().fill_betweenx(
3064         y,
3065         x1,
3066         x2=x2,
3067         where=where,
3068         step=step,
3069         interpolate=interpolate,
3070         **({"data": data} if data is not None else {}),
3071         **kwargs,
3072     )
3073 
3074 
3075 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3076 @_copy_docstring_and_deprecators(Axes.grid)
3077 def grid(
3078     visible: bool | None = None,
3079     which: Literal["major", "minor", "both"] = "major",
3080     axis: Literal["both", "x", "y"] = "both",
3081     **kwargs,
3082 ) -> None:
3083     gca().grid(visible=visible, which=which, axis=axis, **kwargs)
3084 
3085 
3086 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3087 @_copy_docstring_and_deprecators(Axes.hexbin)
3088 def hexbin(
3089     x: ArrayLike,
3090     y: ArrayLike,
3091     C: ArrayLike | None = None,
3092     gridsize: int | tuple[int, int] = 100,
3093     bins: Literal["log"] | int | Sequence[float] | None = None,
3094     xscale: Literal["linear", "log"] = "linear",
3095     yscale: Literal["linear", "log"] = "linear",
3096     extent: tuple[float, float, float, float] | None = None,
3097     cmap: str | Colormap | None = None,
3098     norm: str | Normalize | None = None,
3099     vmin: float | None = None,
3100     vmax: float | None = None,
3101     alpha: float | None = None,
3102     linewidths: float | None = None,
3103     edgecolors: Literal["face", "none"] | ColorType = "face",
3104     reduce_C_function: Callable[[np.ndarray | list[float]], float] = np.mean,
3105     mincnt: int | None = None,
3106     marginals: bool = False,
3107     *,
3108     data=None,
3109     **kwargs,
3110 ) -> PolyCollection:
3111     __ret = gca().hexbin(
3112         x,
3113         y,
3114         C=C,
3115         gridsize=gridsize,
3116         bins=bins,
3117         xscale=xscale,
3118         yscale=yscale,
3119         extent=extent,
3120         cmap=cmap,
3121         norm=norm,
3122         vmin=vmin,
3123         vmax=vmax,
3124         alpha=alpha,
3125         linewidths=linewidths,
3126         edgecolors=edgecolors,
3127         reduce_C_function=reduce_C_function,
3128         mincnt=mincnt,
3129         marginals=marginals,
3130         **({"data": data} if data is not None else {}),
3131         **kwargs,
3132     )
3133     sci(__ret)
3134     return __ret
3135 
3136 
3137 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3138 @_copy_docstring_and_deprecators(Axes.hist)
3139 def hist(
3140     x: ArrayLike | Sequence[ArrayLike],
3141     bins: int | Sequence[float] | str | None = None,
3142     range: tuple[float, float] | None = None,
3143     density: bool = False,
3144     weights: ArrayLike | None = None,
3145     cumulative: bool | float = False,
3146     bottom: ArrayLike | float | None = None,
3147     histtype: Literal["bar", "barstacked", "step", "stepfilled"] = "bar",
3148     align: Literal["left", "mid", "right"] = "mid",
3149     orientation: Literal["vertical", "horizontal"] = "vertical",
3150     rwidth: float | None = None,
3151     log: bool = False,
3152     color: ColorType | Sequence[ColorType] | None = None,
3153     label: str | Sequence[str] | None = None,
3154     stacked: bool = False,
3155     *,
3156     data=None,
3157     **kwargs,
3158 ) -> tuple[
3159     np.ndarray | list[np.ndarray],
3160     np.ndarray,
3161     BarContainer | Polygon | list[BarContainer | Polygon],
3162 ]:
3163     return gca().hist(
3164         x,
3165         bins=bins,
3166         range=range,
3167         density=density,
3168         weights=weights,
3169         cumulative=cumulative,
3170         bottom=bottom,
3171         histtype=histtype,
3172         align=align,
3173         orientation=orientation,
3174         rwidth=rwidth,
3175         log=log,
3176         color=color,
3177         label=label,
3178         stacked=stacked,
3179         **({"data": data} if data is not None else {}),
3180         **kwargs,
3181     )
3182 
3183 
3184 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3185 @_copy_docstring_and_deprecators(Axes.stairs)
3186 def stairs(
3187     values: ArrayLike,
3188     edges: ArrayLike | None = None,
3189     *,
3190     orientation: Literal["vertical", "horizontal"] = "vertical",
3191     baseline: float | ArrayLike | None = 0,
3192     fill: bool = False,
3193     data=None,
3194     **kwargs,
3195 ) -> StepPatch:
3196     return gca().stairs(
3197         values,
3198         edges=edges,
3199         orientation=orientation,
3200         baseline=baseline,
3201         fill=fill,
3202         **({"data": data} if data is not None else {}),
3203         **kwargs,
3204     )
3205 
3206 
3207 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3208 @_copy_docstring_and_deprecators(Axes.hist2d)
3209 def hist2d(
3210     x: ArrayLike,
3211     y: ArrayLike,
3212     bins: None | int | tuple[int, int] | ArrayLike | tuple[ArrayLike, ArrayLike] = 10,
3213     range: ArrayLike | None = None,
3214     density: bool = False,
3215     weights: ArrayLike | None = None,
3216     cmin: float | None = None,
3217     cmax: float | None = None,
3218     *,
3219     data=None,
3220     **kwargs,
3221 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, QuadMesh]:
3222     __ret = gca().hist2d(
3223         x,
3224         y,
3225         bins=bins,
3226         range=range,
3227         density=density,
3228         weights=weights,
3229         cmin=cmin,
3230         cmax=cmax,
3231         **({"data": data} if data is not None else {}),
3232         **kwargs,
3233     )
3234     sci(__ret[-1])
3235     return __ret
3236 
3237 
3238 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3239 @_copy_docstring_and_deprecators(Axes.hlines)
3240 def hlines(
3241     y: float | ArrayLike,
3242     xmin: float | ArrayLike,
3243     xmax: float | ArrayLike,
3244     colors: ColorType | Sequence[ColorType] | None = None,
3245     linestyles: LineStyleType = "solid",
3246     label: str = "",
3247     *,
3248     data=None,
3249     **kwargs,
3250 ) -> LineCollection:
3251     return gca().hlines(
3252         y,
3253         xmin,
3254         xmax,
3255         colors=colors,
3256         linestyles=linestyles,
3257         label=label,
3258         **({"data": data} if data is not None else {}),
3259         **kwargs,
3260     )
3261 
3262 
3263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3264 @_copy_docstring_and_deprecators(Axes.imshow)
3265 def imshow(
3266     X: ArrayLike | PIL.Image.Image,
3267     cmap: str | Colormap | None = None,
3268     norm: str | Normalize | None = None,
3269     *,
3270     aspect: Literal["equal", "auto"] | float | None = None,
3271     interpolation: str | None = None,
3272     alpha: float | ArrayLike | None = None,
3273     vmin: float | None = None,
3274     vmax: float | None = None,
3275     origin: Literal["upper", "lower"] | None = None,
3276     extent: tuple[float, float, float, float] | None = None,
3277     interpolation_stage: Literal["data", "rgba"] | None = None,
3278     filternorm: bool = True,
3279     filterrad: float = 4.0,
3280     resample: bool | None = None,
3281     url: str | None = None,
3282     data=None,
3283     **kwargs,
3284 ) -> AxesImage:
3285     __ret = gca().imshow(
3286         X,
3287         cmap=cmap,
3288         norm=norm,
3289         aspect=aspect,
3290         interpolation=interpolation,
3291         alpha=alpha,
3292         vmin=vmin,
3293         vmax=vmax,
3294         origin=origin,
3295         extent=extent,
3296         interpolation_stage=interpolation_stage,
3297         filternorm=filternorm,
3298         filterrad=filterrad,
3299         resample=resample,
3300         url=url,
3301         **({"data": data} if data is not None else {}),
3302         **kwargs,
3303     )
3304     sci(__ret)
3305     return __ret
3306 
3307 
3308 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3309 @_copy_docstring_and_deprecators(Axes.legend)
3310 def legend(*args, **kwargs) -> Legend:
3311     return gca().legend(*args, **kwargs)
3312 
3313 
3314 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3315 @_copy_docstring_and_deprecators(Axes.locator_params)
3316 def locator_params(
3317     axis: Literal["both", "x", "y"] = "both", tight: bool | None = None, **kwargs
3318 ) -> None:
3319     gca().locator_params(axis=axis, tight=tight, **kwargs)
3320 
3321 
3322 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3323 @_copy_docstring_and_deprecators(Axes.loglog)
3324 def loglog(*args, **kwargs) -> list[Line2D]:
3325     return gca().loglog(*args, **kwargs)
3326 
3327 
3328 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3329 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
3330 def magnitude_spectrum(
3331     x: ArrayLike,
3332     Fs: float | None = None,
3333     Fc: int | None = None,
3334     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3335     pad_to: int | None = None,
3336     sides: Literal["default", "onesided", "twosided"] | None = None,
3337     scale: Literal["default", "linear", "dB"] | None = None,
3338     *,
3339     data=None,
3340     **kwargs,
3341 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3342     return gca().magnitude_spectrum(
3343         x,
3344         Fs=Fs,
3345         Fc=Fc,
3346         window=window,
3347         pad_to=pad_to,
3348         sides=sides,
3349         scale=scale,
3350         **({"data": data} if data is not None else {}),
3351         **kwargs,
3352     )
3353 
3354 
3355 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3356 @_copy_docstring_and_deprecators(Axes.margins)
3357 def margins(
3358     *margins: float,
3359     x: float | None = None,
3360     y: float | None = None,
3361     tight: bool | None = True,
3362 ) -> tuple[float, float] | None:
3363     return gca().margins(*margins, x=x, y=y, tight=tight)
3364 
3365 
3366 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3367 @_copy_docstring_and_deprecators(Axes.minorticks_off)
3368 def minorticks_off() -> None:
3369     gca().minorticks_off()
3370 
3371 
3372 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3373 @_copy_docstring_and_deprecators(Axes.minorticks_on)
3374 def minorticks_on() -> None:
3375     gca().minorticks_on()
3376 
3377 
3378 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3379 @_copy_docstring_and_deprecators(Axes.pcolor)
3380 def pcolor(
3381     *args: ArrayLike,
3382     shading: Literal["flat", "nearest", "auto"] | None = None,
3383     alpha: float | None = None,
3384     norm: str | Normalize | None = None,
3385     cmap: str | Colormap | None = None,
3386     vmin: float | None = None,
3387     vmax: float | None = None,
3388     data=None,
3389     **kwargs,
3390 ) -> Collection:
3391     __ret = gca().pcolor(
3392         *args,
3393         shading=shading,
3394         alpha=alpha,
3395         norm=norm,
3396         cmap=cmap,
3397         vmin=vmin,
3398         vmax=vmax,
3399         **({"data": data} if data is not None else {}),
3400         **kwargs,
3401     )
3402     sci(__ret)
3403     return __ret
3404 
3405 
3406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3407 @_copy_docstring_and_deprecators(Axes.pcolormesh)
3408 def pcolormesh(
3409     *args: ArrayLike,
3410     alpha: float | None = None,
3411     norm: str | Normalize | None = None,
3412     cmap: str | Colormap | None = None,
3413     vmin: float | None = None,
3414     vmax: float | None = None,
3415     shading: Literal["flat", "nearest", "gouraud", "auto"] | None = None,
3416     antialiased: bool = False,
3417     data=None,
3418     **kwargs,
3419 ) -> QuadMesh:
3420     __ret = gca().pcolormesh(
3421         *args,
3422         alpha=alpha,
3423         norm=norm,
3424         cmap=cmap,
3425         vmin=vmin,
3426         vmax=vmax,
3427         shading=shading,
3428         antialiased=antialiased,
3429         **({"data": data} if data is not None else {}),
3430         **kwargs,
3431     )
3432     sci(__ret)
3433     return __ret
3434 
3435 
3436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3437 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
3438 def phase_spectrum(
3439     x: ArrayLike,
3440     Fs: float | None = None,
3441     Fc: int | None = None,
3442     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3443     pad_to: int | None = None,
3444     sides: Literal["default", "onesided", "twosided"] | None = None,
3445     *,
3446     data=None,
3447     **kwargs,
3448 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3449     return gca().phase_spectrum(
3450         x,
3451         Fs=Fs,
3452         Fc=Fc,
3453         window=window,
3454         pad_to=pad_to,
3455         sides=sides,
3456         **({"data": data} if data is not None else {}),
3457         **kwargs,
3458     )
3459 
3460 
3461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3462 @_copy_docstring_and_deprecators(Axes.pie)
3463 def pie(
3464     x: ArrayLike,
3465     explode: ArrayLike | None = None,
3466     labels: Sequence[str] | None = None,
3467     colors: ColorType | Sequence[ColorType] | None = None,
3468     autopct: str | Callable[[float], str] | None = None,
3469     pctdistance: float = 0.6,
3470     shadow: bool = False,
3471     labeldistance: float | None = 1.1,
3472     startangle: float = 0,
3473     radius: float = 1,
3474     counterclock: bool = True,
3475     wedgeprops: dict[str, Any] | None = None,
3476     textprops: dict[str, Any] | None = None,
3477     center: tuple[float, float] = (0, 0),
3478     frame: bool = False,
3479     rotatelabels: bool = False,
3480     *,
3481     normalize: bool = True,
3482     hatch: str | Sequence[str] | None = None,
3483     data=None,
3484 ) -> tuple[list[Wedge], list[Text]] | tuple[list[Wedge], list[Text], list[Text]]:
3485     return gca().pie(
3486         x,
3487         explode=explode,
3488         labels=labels,
3489         colors=colors,
3490         autopct=autopct,
3491         pctdistance=pctdistance,
3492         shadow=shadow,
3493         labeldistance=labeldistance,
3494         startangle=startangle,
3495         radius=radius,
3496         counterclock=counterclock,
3497         wedgeprops=wedgeprops,
3498         textprops=textprops,
3499         center=center,
3500         frame=frame,
3501         rotatelabels=rotatelabels,
3502         normalize=normalize,
3503         hatch=hatch,
3504         **({"data": data} if data is not None else {}),
3505     )
3506 
3507 
3508 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3509 @_copy_docstring_and_deprecators(Axes.plot)
3510 def plot(
3511     *args: float | ArrayLike | str,
3512     scalex: bool = True,
3513     scaley: bool = True,
3514     data=None,
3515     **kwargs,
3516 ) -> list[Line2D]:
3517     return gca().plot(
3518         *args,
3519         scalex=scalex,
3520         scaley=scaley,
3521         **({"data": data} if data is not None else {}),
3522         **kwargs,
3523     )
3524 
3525 
3526 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3527 @_copy_docstring_and_deprecators(Axes.plot_date)
3528 def plot_date(
3529     x: ArrayLike,
3530     y: ArrayLike,
3531     fmt: str = "o",
3532     tz: str | datetime.tzinfo | None = None,
3533     xdate: bool = True,
3534     ydate: bool = False,
3535     *,
3536     data=None,
3537     **kwargs,
3538 ) -> list[Line2D]:
3539     return gca().plot_date(
3540         x,
3541         y,
3542         fmt=fmt,
3543         tz=tz,
3544         xdate=xdate,
3545         ydate=ydate,
3546         **({"data": data} if data is not None else {}),
3547         **kwargs,
3548     )
3549 
3550 
3551 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3552 @_copy_docstring_and_deprecators(Axes.psd)
3553 def psd(
3554     x: ArrayLike,
3555     NFFT: int | None = None,
3556     Fs: float | None = None,
3557     Fc: int | None = None,
3558     detrend: Literal["none", "mean", "linear"]
3559     | Callable[[ArrayLike], ArrayLike]
3560     | None = None,
3561     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3562     noverlap: int | None = None,
3563     pad_to: int | None = None,
3564     sides: Literal["default", "onesided", "twosided"] | None = None,
3565     scale_by_freq: bool | None = None,
3566     return_line: bool | None = None,
3567     *,
3568     data=None,
3569     **kwargs,
3570 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
3571     return gca().psd(
3572         x,
3573         NFFT=NFFT,
3574         Fs=Fs,
3575         Fc=Fc,
3576         detrend=detrend,
3577         window=window,
3578         noverlap=noverlap,
3579         pad_to=pad_to,
3580         sides=sides,
3581         scale_by_freq=scale_by_freq,
3582         return_line=return_line,
3583         **({"data": data} if data is not None else {}),
3584         **kwargs,
3585     )
3586 
3587 
3588 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3589 @_copy_docstring_and_deprecators(Axes.quiver)
3590 def quiver(*args, data=None, **kwargs) -> Quiver:
3591     __ret = gca().quiver(
3592         *args, **({"data": data} if data is not None else {}), **kwargs
3593     )
3594     sci(__ret)
3595     return __ret
3596 
3597 
3598 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3599 @_copy_docstring_and_deprecators(Axes.quiverkey)
3600 def quiverkey(
3601     Q: Quiver, X: float, Y: float, U: float, label: str, **kwargs
3602 ) -> QuiverKey:
3603     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
3604 
3605 
3606 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3607 @_copy_docstring_and_deprecators(Axes.scatter)
3608 def scatter(
3609     x: float | ArrayLike,
3610     y: float | ArrayLike,
3611     s: float | ArrayLike | None = None,
3612     c: Sequence[ColorType] | ColorType | None = None,
3613     marker: MarkerType | None = None,
3614     cmap: str | Colormap | None = None,
3615     norm: str | Normalize | None = None,
3616     vmin: float | None = None,
3617     vmax: float | None = None,
3618     alpha: float | None = None,
3619     linewidths: float | Sequence[float] | None = None,
3620     *,
3621     edgecolors: Literal["face", "none"] | ColorType | Sequence[ColorType] | None = None,
3622     plotnonfinite: bool = False,
3623     data=None,
3624     **kwargs,
3625 ) -> PathCollection:
3626     __ret = gca().scatter(
3627         x,
3628         y,
3629         s=s,
3630         c=c,
3631         marker=marker,
3632         cmap=cmap,
3633         norm=norm,
3634         vmin=vmin,
3635         vmax=vmax,
3636         alpha=alpha,
3637         linewidths=linewidths,
3638         edgecolors=edgecolors,
3639         plotnonfinite=plotnonfinite,
3640         **({"data": data} if data is not None else {}),
3641         **kwargs,
3642     )
3643     sci(__ret)
3644     return __ret
3645 
3646 
3647 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3648 @_copy_docstring_and_deprecators(Axes.semilogx)
3649 def semilogx(*args, **kwargs) -> list[Line2D]:
3650     return gca().semilogx(*args, **kwargs)
3651 
3652 
3653 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3654 @_copy_docstring_and_deprecators(Axes.semilogy)
3655 def semilogy(*args, **kwargs) -> list[Line2D]:
3656     return gca().semilogy(*args, **kwargs)
3657 
3658 
3659 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3660 @_copy_docstring_and_deprecators(Axes.specgram)
3661 def specgram(
3662     x: ArrayLike,
3663     NFFT: int | None = None,
3664     Fs: float | None = None,
3665     Fc: int | None = None,
3666     detrend: Literal["none", "mean", "linear"]
3667     | Callable[[ArrayLike], ArrayLike]
3668     | None = None,
3669     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3670     noverlap: int | None = None,
3671     cmap: str | Colormap | None = None,
3672     xextent: tuple[float, float] | None = None,
3673     pad_to: int | None = None,
3674     sides: Literal["default", "onesided", "twosided"] | None = None,
3675     scale_by_freq: bool | None = None,
3676     mode: Literal["default", "psd", "magnitude", "angle", "phase"] | None = None,
3677     scale: Literal["default", "linear", "dB"] | None = None,
3678     vmin: float | None = None,
3679     vmax: float | None = None,
3680     *,
3681     data=None,
3682     **kwargs,
3683 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, AxesImage]:
3684     __ret = gca().specgram(
3685         x,
3686         NFFT=NFFT,
3687         Fs=Fs,
3688         Fc=Fc,
3689         detrend=detrend,
3690         window=window,
3691         noverlap=noverlap,
3692         cmap=cmap,
3693         xextent=xextent,
3694         pad_to=pad_to,
3695         sides=sides,
3696         scale_by_freq=scale_by_freq,
3697         mode=mode,
3698         scale=scale,
3699         vmin=vmin,
3700         vmax=vmax,
3701         **({"data": data} if data is not None else {}),
3702         **kwargs,
3703     )
3704     sci(__ret[-1])
3705     return __ret
3706 
3707 
3708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3709 @_copy_docstring_and_deprecators(Axes.spy)
3710 def spy(
3711     Z: ArrayLike,
3712     precision: float | Literal["present"] = 0,
3713     marker: str | None = None,
3714     markersize: float | None = None,
3715     aspect: Literal["equal", "auto"] | float | None = "equal",
3716     origin: Literal["upper", "lower"] = "upper",
3717     **kwargs,
3718 ) -> AxesImage:
3719     __ret = gca().spy(
3720         Z,
3721         precision=precision,
3722         marker=marker,
3723         markersize=markersize,
3724         aspect=aspect,
3725         origin=origin,
3726         **kwargs,
3727     )
3728     if isinstance(__ret, cm.ScalarMappable):
3729         sci(__ret)  # noqa
3730     return __ret
3731 
3732 
3733 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3734 @_copy_docstring_and_deprecators(Axes.stackplot)
3735 def stackplot(x, *args, labels=(), colors=None, baseline="zero", data=None, **kwargs):
3736     return gca().stackplot(
3737         x,
3738         *args,
3739         labels=labels,
3740         colors=colors,
3741         baseline=baseline,
3742         **({"data": data} if data is not None else {}),
3743         **kwargs,
3744     )
3745 
3746 
3747 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3748 @_copy_docstring_and_deprecators(Axes.stem)
3749 def stem(
3750     *args: ArrayLike | str,
3751     linefmt: str | None = None,
3752     markerfmt: str | None = None,
3753     basefmt: str | None = None,
3754     bottom: float = 0,
3755     label: str | None = None,
3756     orientation: Literal["vertical", "horizontal"] = "vertical",
3757     data=None,
3758 ) -> StemContainer:
3759     return gca().stem(
3760         *args,
3761         linefmt=linefmt,
3762         markerfmt=markerfmt,
3763         basefmt=basefmt,
3764         bottom=bottom,
3765         label=label,
3766         orientation=orientation,
3767         **({"data": data} if data is not None else {}),
3768     )
3769 
3770 
3771 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3772 @_copy_docstring_and_deprecators(Axes.step)
3773 def step(
3774     x: ArrayLike,
3775     y: ArrayLike,
3776     *args,
3777     where: Literal["pre", "post", "mid"] = "pre",
3778     data=None,
3779     **kwargs,
3780 ) -> list[Line2D]:
3781     return gca().step(
3782         x,
3783         y,
3784         *args,
3785         where=where,
3786         **({"data": data} if data is not None else {}),
3787         **kwargs,
3788     )
3789 
3790 
3791 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3792 @_copy_docstring_and_deprecators(Axes.streamplot)
3793 def streamplot(
3794     x,
3795     y,
3796     u,
3797     v,
3798     density=1,
3799     linewidth=None,
3800     color=None,
3801     cmap=None,
3802     norm=None,
3803     arrowsize=1,
3804     arrowstyle="-|>",
3805     minlength=0.1,
3806     transform=None,
3807     zorder=None,
3808     start_points=None,
3809     maxlength=4.0,
3810     integration_direction="both",
3811     broken_streamlines=True,
3812     *,
3813     data=None,
3814 ):
3815     __ret = gca().streamplot(
3816         x,
3817         y,
3818         u,
3819         v,
3820         density=density,
3821         linewidth=linewidth,
3822         color=color,
3823         cmap=cmap,
3824         norm=norm,
3825         arrowsize=arrowsize,
3826         arrowstyle=arrowstyle,
3827         minlength=minlength,
3828         transform=transform,
3829         zorder=zorder,
3830         start_points=start_points,
3831         maxlength=maxlength,
3832         integration_direction=integration_direction,
3833         broken_streamlines=broken_streamlines,
3834         **({"data": data} if data is not None else {}),
3835     )
3836     sci(__ret.lines)
3837     return __ret
3838 
3839 
3840 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3841 @_copy_docstring_and_deprecators(Axes.table)
3842 def table(
3843     cellText=None,
3844     cellColours=None,
3845     cellLoc="right",
3846     colWidths=None,
3847     rowLabels=None,
3848     rowColours=None,
3849     rowLoc="left",
3850     colLabels=None,
3851     colColours=None,
3852     colLoc="center",
3853     loc="bottom",
3854     bbox=None,
3855     edges="closed",
3856     **kwargs,
3857 ):
3858     return gca().table(
3859         cellText=cellText,
3860         cellColours=cellColours,
3861         cellLoc=cellLoc,
3862         colWidths=colWidths,
3863         rowLabels=rowLabels,
3864         rowColours=rowColours,
3865         rowLoc=rowLoc,
3866         colLabels=colLabels,
3867         colColours=colColours,
3868         colLoc=colLoc,
3869         loc=loc,
3870         bbox=bbox,
3871         edges=edges,
3872         **kwargs,
3873     )
3874 
3875 
3876 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3877 @_copy_docstring_and_deprecators(Axes.text)
3878 def text(
3879     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
3880 ) -> Text:
3881     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
3882 
3883 
3884 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3885 @_copy_docstring_and_deprecators(Axes.tick_params)
3886 def tick_params(axis: Literal["both", "x", "y"] = "both", **kwargs) -> None:
3887     gca().tick_params(axis=axis, **kwargs)
3888 
3889 
3890 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3891 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
3892 def ticklabel_format(
3893     *,
3894     axis: Literal["both", "x", "y"] = "both",
3895     style: Literal["", "sci", "scientific", "plain"] = "",
3896     scilimits: tuple[int, int] | None = None,
3897     useOffset: bool | float | None = None,
3898     useLocale: bool | None = None,
3899     useMathText: bool | None = None,
3900 ) -> None:
3901     gca().ticklabel_format(
3902         axis=axis,
3903         style=style,
3904         scilimits=scilimits,
3905         useOffset=useOffset,
3906         useLocale=useLocale,
3907         useMathText=useMathText,
3908     )
3909 
3910 
3911 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3912 @_copy_docstring_and_deprecators(Axes.tricontour)
3913 def tricontour(*args, **kwargs):
3914     __ret = gca().tricontour(*args, **kwargs)
3915     if __ret._A is not None:  # type: ignore[attr-defined]
3916         sci(__ret)
3917     return __ret
3918 
3919 
3920 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3921 @_copy_docstring_and_deprecators(Axes.tricontourf)
3922 def tricontourf(*args, **kwargs):
3923     __ret = gca().tricontourf(*args, **kwargs)
3924     if __ret._A is not None:  # type: ignore[attr-defined]
3925         sci(__ret)
3926     return __ret
3927 
3928 
3929 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3930 @_copy_docstring_and_deprecators(Axes.tripcolor)
3931 def tripcolor(
3932     *args,
3933     alpha=1.0,
3934     norm=None,
3935     cmap=None,
3936     vmin=None,
3937     vmax=None,
3938     shading="flat",
3939     facecolors=None,
3940     **kwargs,
3941 ):
3942     __ret = gca().tripcolor(
3943         *args,
3944         alpha=alpha,
3945         norm=norm,
3946         cmap=cmap,
3947         vmin=vmin,
3948         vmax=vmax,
3949         shading=shading,
3950         facecolors=facecolors,
3951         **kwargs,
3952     )
3953     sci(__ret)
3954     return __ret
3955 
3956 
3957 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3958 @_copy_docstring_and_deprecators(Axes.triplot)
3959 def triplot(*args, **kwargs):
3960     return gca().triplot(*args, **kwargs)
3961 
3962 
3963 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3964 @_copy_docstring_and_deprecators(Axes.violinplot)
3965 def violinplot(
3966     dataset: ArrayLike | Sequence[ArrayLike],
3967     positions: ArrayLike | None = None,
3968     vert: bool = True,
3969     widths: float | ArrayLike = 0.5,
3970     showmeans: bool = False,
3971     showextrema: bool = True,
3972     showmedians: bool = False,
3973     quantiles: Sequence[float | Sequence[float]] | None = None,
3974     points: int = 100,
3975     bw_method: Literal["scott", "silverman"]
3976     | float
3977     | Callable[[GaussianKDE], float]
3978     | None = None,
3979     *,
3980     data=None,
3981 ) -> dict[str, Collection]:
3982     return gca().violinplot(
3983         dataset,
3984         positions=positions,
3985         vert=vert,
3986         widths=widths,
3987         showmeans=showmeans,
3988         showextrema=showextrema,
3989         showmedians=showmedians,
3990         quantiles=quantiles,
3991         points=points,
3992         bw_method=bw_method,
3993         **({"data": data} if data is not None else {}),
3994     )
3995 
3996 
3997 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3998 @_copy_docstring_and_deprecators(Axes.vlines)
3999 def vlines(
4000     x: float | ArrayLike,
4001     ymin: float | ArrayLike,
4002     ymax: float | ArrayLike,
4003     colors: ColorType | Sequence[ColorType] | None = None,
4004     linestyles: LineStyleType = "solid",
4005     label: str = "",
4006     *,
4007     data=None,
4008     **kwargs,
4009 ) -> LineCollection:
4010     return gca().vlines(
4011         x,
4012         ymin,
4013         ymax,
4014         colors=colors,
4015         linestyles=linestyles,
4016         label=label,
4017         **({"data": data} if data is not None else {}),
4018         **kwargs,
4019     )
4020 
4021 
4022 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4023 @_copy_docstring_and_deprecators(Axes.xcorr)
4024 def xcorr(
4025     x: ArrayLike,
4026     y: ArrayLike,
4027     normed: bool = True,
4028     detrend: Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
4029     usevlines: bool = True,
4030     maxlags: int = 10,
4031     *,
4032     data=None,
4033     **kwargs,
4034 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
4035     return gca().xcorr(
4036         x,
4037         y,
4038         normed=normed,
4039         detrend=detrend,
4040         usevlines=usevlines,
4041         maxlags=maxlags,
4042         **({"data": data} if data is not None else {}),
4043         **kwargs,
4044     )
4045 
4046 
4047 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4048 @_copy_docstring_and_deprecators(Axes._sci)
4049 def sci(im: ScalarMappable) -> None:
4050     gca()._sci(im)
4051 
4052 
4053 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4054 @_copy_docstring_and_deprecators(Axes.set_title)
4055 def title(
4056     label: str,
4057     fontdict: dict[str, Any] | None = None,
4058     loc: Literal["left", "center", "right"] | None = None,
4059     pad: float | None = None,
4060     *,
4061     y: float | None = None,
4062     **kwargs,
4063 ) -> Text:
4064     return gca().set_title(label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
4065 
4066 
4067 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4068 @_copy_docstring_and_deprecators(Axes.set_xlabel)
4069 def xlabel(
4070     xlabel: str,
4071     fontdict: dict[str, Any] | None = None,
4072     labelpad: float | None = None,
4073     *,
4074     loc: Literal["left", "center", "right"] | None = None,
4075     **kwargs,
4076 ) -> Text:
4077     return gca().set_xlabel(
4078         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4079     )
4080 
4081 
4082 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4083 @_copy_docstring_and_deprecators(Axes.set_ylabel)
4084 def ylabel(
4085     ylabel: str,
4086     fontdict: dict[str, Any] | None = None,
4087     labelpad: float | None = None,
4088     *,
4089     loc: Literal["bottom", "center", "top"] | None = None,
4090     **kwargs,
4091 ) -> Text:
4092     return gca().set_ylabel(
4093         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4094     )
4095 
4096 
4097 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4098 @_copy_docstring_and_deprecators(Axes.set_xscale)
4099 def xscale(value: str | ScaleBase, **kwargs) -> None:
4100     gca().set_xscale(value, **kwargs)
4101 
4102 
4103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4104 @_copy_docstring_and_deprecators(Axes.set_yscale)
4105 def yscale(value: str | ScaleBase, **kwargs) -> None:
4106     gca().set_yscale(value, **kwargs)
4107 
4108 
4109 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4110 def autumn() -> None:
4111     """
4112     Set the colormap to 'autumn'.
4113 
4114     This changes the default colormap as well as the colormap of the current
4115     image if there is one. See ``help(colormaps)`` for more information.
4116     """
4117     set_cmap("autumn")
4118 
4119 
4120 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4121 def bone() -> None:
4122     """
4123     Set the colormap to 'bone'.
4124 
4125     This changes the default colormap as well as the colormap of the current
4126     image if there is one. See ``help(colormaps)`` for more information.
4127     """
4128     set_cmap("bone")
4129 
4130 
4131 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4132 def cool() -> None:
4133     """
4134     Set the colormap to 'cool'.
4135 
4136     This changes the default colormap as well as the colormap of the current
4137     image if there is one. See ``help(colormaps)`` for more information.
4138     """
4139     set_cmap("cool")
4140 
4141 
4142 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4143 def copper() -> None:
4144     """
4145     Set the colormap to 'copper'.
4146 
4147     This changes the default colormap as well as the colormap of the current
4148     image if there is one. See ``help(colormaps)`` for more information.
4149     """
4150     set_cmap("copper")
4151 
4152 
4153 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4154 def flag() -> None:
4155     """
4156     Set the colormap to 'flag'.
4157 
4158     This changes the default colormap as well as the colormap of the current
4159     image if there is one. See ``help(colormaps)`` for more information.
4160     """
4161     set_cmap("flag")
4162 
4163 
4164 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4165 def gray() -> None:
4166     """
4167     Set the colormap to 'gray'.
4168 
4169     This changes the default colormap as well as the colormap of the current
4170     image if there is one. See ``help(colormaps)`` for more information.
4171     """
4172     set_cmap("gray")
4173 
4174 
4175 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4176 def hot() -> None:
4177     """
4178     Set the colormap to 'hot'.
4179 
4180     This changes the default colormap as well as the colormap of the current
4181     image if there is one. See ``help(colormaps)`` for more information.
4182     """
4183     set_cmap("hot")
4184 
4185 
4186 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4187 def hsv() -> None:
4188     """
4189     Set the colormap to 'hsv'.
4190 
4191     This changes the default colormap as well as the colormap of the current
4192     image if there is one. See ``help(colormaps)`` for more information.
4193     """
4194     set_cmap("hsv")
4195 
4196 
4197 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4198 def jet() -> None:
4199     """
4200     Set the colormap to 'jet'.
4201 
4202     This changes the default colormap as well as the colormap of the current
4203     image if there is one. See ``help(colormaps)`` for more information.
4204     """
4205     set_cmap("jet")
4206 
4207 
4208 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4209 def pink() -> None:
4210     """
4211     Set the colormap to 'pink'.
4212 
4213     This changes the default colormap as well as the colormap of the current
4214     image if there is one. See ``help(colormaps)`` for more information.
4215     """
4216     set_cmap("pink")
4217 
4218 
4219 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4220 def prism() -> None:
4221     """
4222     Set the colormap to 'prism'.
4223 
4224     This changes the default colormap as well as the colormap of the current
4225     image if there is one. See ``help(colormaps)`` for more information.
4226     """
4227     set_cmap("prism")
4228 
4229 
4230 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4231 def spring() -> None:
4232     """
4233     Set the colormap to 'spring'.
4234 
4235     This changes the default colormap as well as the colormap of the current
4236     image if there is one. See ``help(colormaps)`` for more information.
4237     """
4238     set_cmap("spring")
4239 
4240 
4241 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4242 def summer() -> None:
4243     """
4244     Set the colormap to 'summer'.
4245 
4246     This changes the default colormap as well as the colormap of the current
4247     image if there is one. See ``help(colormaps)`` for more information.
4248     """
4249     set_cmap("summer")
4250 
4251 
4252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4253 def winter() -> None:
4254     """
4255     Set the colormap to 'winter'.
4256 
4257     This changes the default colormap as well as the colormap of the current
4258     image if there is one. See ``help(colormaps)`` for more information.
4259     """
4260     set_cmap("winter")
4261 
4262 
4263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4264 def magma() -> None:
4265     """
4266     Set the colormap to 'magma'.
4267 
4268     This changes the default colormap as well as the colormap of the current
4269     image if there is one. See ``help(colormaps)`` for more information.
4270     """
4271     set_cmap("magma")
4272 
4273 
4274 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4275 def inferno() -> None:
4276     """
4277     Set the colormap to 'inferno'.
4278 
4279     This changes the default colormap as well as the colormap of the current
4280     image if there is one. See ``help(colormaps)`` for more information.
4281     """
4282     set_cmap("inferno")
4283 
4284 
4285 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4286 def plasma() -> None:
4287     """
4288     Set the colormap to 'plasma'.
4289 
4290     This changes the default colormap as well as the colormap of the current
4291     image if there is one. See ``help(colormaps)`` for more information.
4292     """
4293     set_cmap("plasma")
4294 
4295 
4296 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4297 def viridis() -> None:
4298     """
4299     Set the colormap to 'viridis'.
4300 
4301     This changes the default colormap as well as the colormap of the current
4302     image if there is one. See ``help(colormaps)`` for more information.
4303     """
4304     set_cmap("viridis")
4305 
4306 
4307 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4308 def nipy_spectral() -> None:
4309     """
4310     Set the colormap to 'nipy_spectral'.
4311 
4312     This changes the default colormap as well as the colormap of the current
4313     image if there is one. See ``help(colormaps)`` for more information.
4314     """
4315     set_cmap("nipy_spectral")

</code><intended_behavior>In `pyplot.py`, adjustments should be made to ensure that backend switching via `%matplotlib` magic does not interfere with the visibility of GUI windows created under different backends. Specifically, this involves preserving the state of GUI windows upon backend switches. Methods related to backend switching and interactive mode toggling (`ion()`, `ioff()`) may need to be modified to check the current backend and manage GUI windows accordingly, without closing them unintentionally. The exact implementation would depend on identifying a method to tag certain figures to remain unaffected by backend changes or maintaining a global state of figures that should not be closed upon backend switches.</intended_behavior>, <file>lib/matplotlib/backend_bases.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Abstract base classes define the primitives that renderers and
3 graphics contexts must implement to serve as a Matplotlib backend.
4 
5 `RendererBase`
6     An abstract base class to handle drawing/rendering operations.
7 
8 `FigureCanvasBase`
9     The abstraction layer that separates the `.Figure` from the backend
10     specific details like a user interface drawing area.
11 
12 `GraphicsContextBase`
13     An abstract base class that provides color, line styles, etc.
14 
15 `Event`
16     The base class for all of the Matplotlib event handling.  Derived classes
17     such as `KeyEvent` and `MouseEvent` store the meta data like keys and
18     buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.
19 
20 `ShowBase`
21     The base class for the ``Show`` class of each interactive backend; the
22     'show' callable is then set to ``Show.__call__``.
23 
24 `ToolContainerBase`
25     The base class for the Toolbar class of each interactive backend.
26 """
27 
28 from collections import namedtuple
29 from contextlib import ExitStack, contextmanager, nullcontext
30 from enum import Enum, IntEnum
31 import functools
32 import importlib
33 import inspect
34 import io
35 import itertools
36 import logging
37 import os
38 import sys
39 import time
40 import weakref
41 from weakref import WeakKeyDictionary
42 
43 import numpy as np
44 
45 import matplotlib as mpl
46 from matplotlib import (
47     _api, backend_tools as tools, cbook, colors, _docstring, text,
48     _tight_bbox, transforms, widgets, get_backend, is_interactive, rcParams)
49 from matplotlib._pylab_helpers import Gcf
50 from matplotlib.backend_managers import ToolManager
51 from matplotlib.cbook import _setattr_cm
52 from matplotlib.layout_engine import ConstrainedLayoutEngine
53 from matplotlib.path import Path
54 from matplotlib.texmanager import TexManager
55 from matplotlib.transforms import Affine2D
56 from matplotlib._enums import JoinStyle, CapStyle
57 
58 
59 _log = logging.getLogger(__name__)
60 _default_filetypes = {
61     'eps': 'Encapsulated Postscript',
62     'jpg': 'Joint Photographic Experts Group',
63     'jpeg': 'Joint Photographic Experts Group',
64     'pdf': 'Portable Document Format',
65     'pgf': 'PGF code for LaTeX',
66     'png': 'Portable Network Graphics',
67     'ps': 'Postscript',
68     'raw': 'Raw RGBA bitmap',
69     'rgba': 'Raw RGBA bitmap',
70     'svg': 'Scalable Vector Graphics',
71     'svgz': 'Scalable Vector Graphics',
72     'tif': 'Tagged Image File Format',
73     'tiff': 'Tagged Image File Format',
74     'webp': 'WebP Image Format',
75 }
76 _default_backends = {
77     'eps': 'matplotlib.backends.backend_ps',
78     'jpg': 'matplotlib.backends.backend_agg',
79     'jpeg': 'matplotlib.backends.backend_agg',
80     'pdf': 'matplotlib.backends.backend_pdf',
81     'pgf': 'matplotlib.backends.backend_pgf',
82     'png': 'matplotlib.backends.backend_agg',
83     'ps': 'matplotlib.backends.backend_ps',
84     'raw': 'matplotlib.backends.backend_agg',
85     'rgba': 'matplotlib.backends.backend_agg',
86     'svg': 'matplotlib.backends.backend_svg',
87     'svgz': 'matplotlib.backends.backend_svg',
88     'tif': 'matplotlib.backends.backend_agg',
89     'tiff': 'matplotlib.backends.backend_agg',
90     'webp': 'matplotlib.backends.backend_agg',
91 }
92 
93 
94 def _safe_pyplot_import():
95     """
96     Import and return ``pyplot``, correctly setting the backend if one is
97     already forced.
98     """
99     try:
100         import matplotlib.pyplot as plt
101     except ImportError:  # Likely due to a framework mismatch.
102         current_framework = cbook._get_running_interactive_framework()
103         if current_framework is None:
104             raise  # No, something else went wrong, likely with the install...
105         backend_mapping = {
106             'qt': 'qtagg',
107             'gtk3': 'gtk3agg',
108             'gtk4': 'gtk4agg',
109             'wx': 'wxagg',
110             'tk': 'tkagg',
111             'macosx': 'macosx',
112             'headless': 'agg',
113         }
114         backend = backend_mapping[current_framework]
115         rcParams["backend"] = mpl.rcParamsOrig["backend"] = backend
116         import matplotlib.pyplot as plt  # Now this should succeed.
117     return plt
118 
119 
120 def register_backend(format, backend, description=None):
121     """
122     Register a backend for saving to a given file format.
123 
124     Parameters
125     ----------
126     format : str
127         File extension
128     backend : module string or canvas class
129         Backend for handling file output
130     description : str, default: ""
131         Description of the file type.
132     """
133     if description is None:
134         description = ''
135     _default_backends[format] = backend
136     _default_filetypes[format] = description
137 
138 
139 def get_registered_canvas_class(format):
140     """
141     Return the registered default canvas for given file format.
142     Handles deferred import of required backend.
143     """
144     if format not in _default_backends:
145         return None
146     backend_class = _default_backends[format]
147     if isinstance(backend_class, str):
148         backend_class = importlib.import_module(backend_class).FigureCanvas
149         _default_backends[format] = backend_class
150     return backend_class
151 
152 
153 class RendererBase:
154     """
155     An abstract base class to handle drawing/rendering operations.
156 
157     The following methods must be implemented in the backend for full
158     functionality (though just implementing `draw_path` alone would give a
159     highly capable backend):
160 
161     * `draw_path`
162     * `draw_image`
163     * `draw_gouraud_triangles`
164 
165     The following methods *should* be implemented in the backend for
166     optimization reasons:
167 
168     * `draw_text`
169     * `draw_markers`
170     * `draw_path_collection`
171     * `draw_quad_mesh`
172     """
173     def __init__(self):
174         super().__init__()
175         self._texmanager = None
176         self._text2path = text.TextToPath()
177         self._raster_depth = 0
178         self._rasterizing = False
179 
180     def open_group(self, s, gid=None):
181         """
182         Open a grouping element with label *s* and *gid* (if set) as id.
183 
184         Only used by the SVG renderer.
185         """
186 
187     def close_group(self, s):
188         """
189         Close a grouping element with label *s*.
190 
191         Only used by the SVG renderer.
192         """
193 
194     def draw_path(self, gc, path, transform, rgbFace=None):
195         """Draw a `~.path.Path` instance using the given affine transform."""
196         raise NotImplementedError
197 
198     def draw_markers(self, gc, marker_path, marker_trans, path,
199                      trans, rgbFace=None):
200         """
201         Draw a marker at each of *path*'s vertices (excluding control points).
202 
203         The base (fallback) implementation makes multiple calls to `draw_path`.
204         Backends may want to override this method in order to draw the marker
205         only once and reuse it multiple times.
206 
207         Parameters
208         ----------
209         gc : `.GraphicsContextBase`
210             The graphics context.
211         marker_trans : `~matplotlib.transforms.Transform`
212             An affine transform applied to the marker.
213         trans : `~matplotlib.transforms.Transform`
214             An affine transform applied to the path.
215         """
216         for vertices, codes in path.iter_segments(trans, simplify=False):
217             if len(vertices):
218                 x, y = vertices[-2:]
219                 self.draw_path(gc, marker_path,
220                                marker_trans +
221                                transforms.Affine2D().translate(x, y),
222                                rgbFace)
223 
224     def draw_path_collection(self, gc, master_transform, paths, all_transforms,
225                              offsets, offset_trans, facecolors, edgecolors,
226                              linewidths, linestyles, antialiaseds, urls,
227                              offset_position):
228         """
229         Draw a collection of *paths*.
230 
231         Each path is first transformed by the corresponding entry
232         in *all_transforms* (a list of (3, 3) matrices) and then by
233         *master_transform*.  They are then translated by the corresponding
234         entry in *offsets*, which has been first transformed by *offset_trans*.
235 
236         *facecolors*, *edgecolors*, *linewidths*, *linestyles*, and
237         *antialiased* are lists that set the corresponding properties.
238 
239         *offset_position* is unused now, but the argument is kept for
240         backwards compatibility.
241 
242         The base (fallback) implementation makes multiple calls to `draw_path`.
243         Backends may want to override this in order to render each set of
244         path data only once, and then reference that path multiple times with
245         the different offsets, colors, styles etc.  The generator methods
246         `_iter_collection_raw_paths` and `_iter_collection` are provided to
247         help with (and standardize) the implementation across backends.  It
248         is highly recommended to use those generators, so that changes to the
249         behavior of `draw_path_collection` can be made globally.
250         """
251         path_ids = self._iter_collection_raw_paths(master_transform,
252                                                    paths, all_transforms)
253 
254         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
255                 gc, list(path_ids), offsets, offset_trans,
256                 facecolors, edgecolors, linewidths, linestyles,
257                 antialiaseds, urls, offset_position):
258             path, transform = path_id
259             # Only apply another translation if we have an offset, else we
260             # reuse the initial transform.
261             if xo != 0 or yo != 0:
262                 # The transformation can be used by multiple paths. Since
263                 # translate is a inplace operation, we need to copy the
264                 # transformation by .frozen() before applying the translation.
265                 transform = transform.frozen()
266                 transform.translate(xo, yo)
267             self.draw_path(gc0, path, transform, rgbFace)
268 
269     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,
270                        coordinates, offsets, offsetTrans, facecolors,
271                        antialiased, edgecolors):
272         """
273         Draw a quadmesh.
274 
275         The base (fallback) implementation converts the quadmesh to paths and
276         then calls `draw_path_collection`.
277         """
278 
279         from matplotlib.collections import QuadMesh
280         paths = QuadMesh._convert_mesh_to_paths(coordinates)
281 
282         if edgecolors is None:
283             edgecolors = facecolors
284         linewidths = np.array([gc.get_linewidth()], float)
285 
286         return self.draw_path_collection(
287             gc, master_transform, paths, [], offsets, offsetTrans, facecolors,
288             edgecolors, linewidths, [], [antialiased], [None], 'screen')
289 
290     @_api.deprecated("3.7", alternative="draw_gouraud_triangles")
291     def draw_gouraud_triangle(self, gc, points, colors, transform):
292         """
293         Draw a Gouraud-shaded triangle.
294 
295         Parameters
296         ----------
297         gc : `.GraphicsContextBase`
298             The graphics context.
299         points : (3, 2) array-like
300             Array of (x, y) points for the triangle.
301         colors : (3, 4) array-like
302             RGBA colors for each point of the triangle.
303         transform : `~matplotlib.transforms.Transform`
304             An affine transform to apply to the points.
305         """
306         raise NotImplementedError
307 
308     def draw_gouraud_triangles(self, gc, triangles_array, colors_array,
309                                transform):
310         """
311         Draw a series of Gouraud triangles.
312 
313         Parameters
314         ----------
315         gc : `.GraphicsContextBase`
316             The graphics context.
317         triangles_array : (N, 3, 2) array-like
318             Array of *N* (x, y) points for the triangles.
319         colors_array : (N, 3, 4) array-like
320             Array of *N* RGBA colors for each point of the triangles.
321         transform : `~matplotlib.transforms.Transform`
322             An affine transform to apply to the points.
323         """
324         raise NotImplementedError
325 
326     def _iter_collection_raw_paths(self, master_transform, paths,
327                                    all_transforms):
328         """
329         Helper method (along with `_iter_collection`) to implement
330         `draw_path_collection` in a memory-efficient manner.
331 
332         This method yields all of the base path/transform combinations, given a
333         master transform, a list of paths and list of transforms.
334 
335         The arguments should be exactly what is passed in to
336         `draw_path_collection`.
337 
338         The backend should take each yielded path and transform and create an
339         object that can be referenced (reused) later.
340         """
341         Npaths = len(paths)
342         Ntransforms = len(all_transforms)
343         N = max(Npaths, Ntransforms)
344 
345         if Npaths == 0:
346             return
347 
348         transform = transforms.IdentityTransform()
349         for i in range(N):
350             path = paths[i % Npaths]
351             if Ntransforms:
352                 transform = Affine2D(all_transforms[i % Ntransforms])
353             yield path, transform + master_transform
354 
355     def _iter_collection_uses_per_path(self, paths, all_transforms,
356                                        offsets, facecolors, edgecolors):
357         """
358         Compute how many times each raw path object returned by
359         `_iter_collection_raw_paths` would be used when calling
360         `_iter_collection`. This is intended for the backend to decide
361         on the tradeoff between using the paths in-line and storing
362         them once and reusing. Rounds up in case the number of uses
363         is not the same for every path.
364         """
365         Npaths = len(paths)
366         if Npaths == 0 or len(facecolors) == len(edgecolors) == 0:
367             return 0
368         Npath_ids = max(Npaths, len(all_transforms))
369         N = max(Npath_ids, len(offsets))
370         return (N + Npath_ids - 1) // Npath_ids
371 
372     def _iter_collection(self, gc, path_ids, offsets, offset_trans, facecolors,
373                          edgecolors, linewidths, linestyles,
374                          antialiaseds, urls, offset_position):
375         """
376         Helper method (along with `_iter_collection_raw_paths`) to implement
377         `draw_path_collection` in a memory-efficient manner.
378 
379         This method yields all of the path, offset and graphics context
380         combinations to draw the path collection.  The caller should already
381         have looped over the results of `_iter_collection_raw_paths` to draw
382         this collection.
383 
384         The arguments should be the same as that passed into
385         `draw_path_collection`, with the exception of *path_ids*, which is a
386         list of arbitrary objects that the backend will use to reference one of
387         the paths created in the `_iter_collection_raw_paths` stage.
388 
389         Each yielded result is of the form::
390 
391            xo, yo, path_id, gc, rgbFace
392 
393         where *xo*, *yo* is an offset; *path_id* is one of the elements of
394         *path_ids*; *gc* is a graphics context and *rgbFace* is a color to
395         use for filling the path.
396         """
397         Npaths = len(path_ids)
398         Noffsets = len(offsets)
399         N = max(Npaths, Noffsets)
400         Nfacecolors = len(facecolors)
401         Nedgecolors = len(edgecolors)
402         Nlinewidths = len(linewidths)
403         Nlinestyles = len(linestyles)
404         Nurls = len(urls)
405 
406         if (Nfacecolors == 0 and Nedgecolors == 0) or Npaths == 0:
407             return
408 
409         gc0 = self.new_gc()
410         gc0.copy_properties(gc)
411 
412         def cycle_or_default(seq, default=None):
413             # Cycle over *seq* if it is not empty; else always yield *default*.
414             return (itertools.cycle(seq) if len(seq)
415                     else itertools.repeat(default))
416 
417         pathids = cycle_or_default(path_ids)
418         toffsets = cycle_or_default(offset_trans.transform(offsets), (0, 0))
419         fcs = cycle_or_default(facecolors)
420         ecs = cycle_or_default(edgecolors)
421         lws = cycle_or_default(linewidths)
422         lss = cycle_or_default(linestyles)
423         aas = cycle_or_default(antialiaseds)
424         urls = cycle_or_default(urls)
425 
426         if Nedgecolors == 0:
427             gc0.set_linewidth(0.0)
428 
429         for pathid, (xo, yo), fc, ec, lw, ls, aa, url in itertools.islice(
430                 zip(pathids, toffsets, fcs, ecs, lws, lss, aas, urls), N):
431             if not (np.isfinite(xo) and np.isfinite(yo)):
432                 continue
433             if Nedgecolors:
434                 if Nlinewidths:
435                     gc0.set_linewidth(lw)
436                 if Nlinestyles:
437                     gc0.set_dashes(*ls)
438                 if len(ec) == 4 and ec[3] == 0.0:
439                     gc0.set_linewidth(0)
440                 else:
441                     gc0.set_foreground(ec)
442             if fc is not None and len(fc) == 4 and fc[3] == 0:
443                 fc = None
444             gc0.set_antialiased(aa)
445             if Nurls:
446                 gc0.set_url(url)
447             yield xo, yo, pathid, gc0, fc
448         gc0.restore()
449 
450     def get_image_magnification(self):
451         """
452         Get the factor by which to magnify images passed to `draw_image`.
453         Allows a backend to have images at a different resolution to other
454         artists.
455         """
456         return 1.0
457 
458     def draw_image(self, gc, x, y, im, transform=None):
459         """
460         Draw an RGBA image.
461 
462         Parameters
463         ----------
464         gc : `.GraphicsContextBase`
465             A graphics context with clipping information.
466 
467         x : scalar
468             The distance in physical units (i.e., dots or pixels) from the left
469             hand side of the canvas.
470 
471         y : scalar
472             The distance in physical units (i.e., dots or pixels) from the
473             bottom side of the canvas.
474 
475         im : (N, M, 4) array of `numpy.uint8`
476             An array of RGBA pixels.
477 
478         transform : `~matplotlib.transforms.Affine2DBase`
479             If and only if the concrete backend is written such that
480             `option_scale_image` returns ``True``, an affine transformation
481             (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The
482             translation vector of the transformation is given in physical units
483             (i.e., dots or pixels). Note that the transformation does not
484             override *x* and *y*, and has to be applied *before* translating
485             the result by *x* and *y* (this can be accomplished by adding *x*
486             and *y* to the translation vector defined by *transform*).
487         """
488         raise NotImplementedError
489 
490     def option_image_nocomposite(self):
491         """
492         Return whether image composition by Matplotlib should be skipped.
493 
494         Raster backends should usually return False (letting the C-level
495         rasterizer take care of image composition); vector backends should
496         usually return ``not rcParams["image.composite_image"]``.
497         """
498         return False
499 
500     def option_scale_image(self):
501         """
502         Return whether arbitrary affine transformations in `draw_image` are
503         supported (True for most vector backends).
504         """
505         return False
506 
507     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):
508         """
509         Draw a TeX instance.
510 
511         Parameters
512         ----------
513         gc : `.GraphicsContextBase`
514             The graphics context.
515         x : float
516             The x location of the text in display coords.
517         y : float
518             The y location of the text baseline in display coords.
519         s : str
520             The TeX text string.
521         prop : `~matplotlib.font_manager.FontProperties`
522             The font properties.
523         angle : float
524             The rotation angle in degrees anti-clockwise.
525         mtext : `~matplotlib.text.Text`
526             The original text object to be rendered.
527         """
528         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath="TeX")
529 
530     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
531         """
532         Draw a text instance.
533 
534         Parameters
535         ----------
536         gc : `.GraphicsContextBase`
537             The graphics context.
538         x : float
539             The x location of the text in display coords.
540         y : float
541             The y location of the text baseline in display coords.
542         s : str
543             The text string.
544         prop : `~matplotlib.font_manager.FontProperties`
545             The font properties.
546         angle : float
547             The rotation angle in degrees anti-clockwise.
548         ismath : bool or "TeX"
549             If True, use mathtext parser. If "TeX", use tex for rendering.
550         mtext : `~matplotlib.text.Text`
551             The original text object to be rendered.
552 
553         Notes
554         -----
555         **Note for backend implementers:**
556 
557         When you are trying to determine if you have gotten your bounding box
558         right (which is what enables the text layout/alignment to work
559         properly), it helps to change the line in text.py::
560 
561             if 0: bbox_artist(self, renderer)
562 
563         to if 1, and then the actual bounding box will be plotted along with
564         your text.
565         """
566 
567         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath)
568 
569     def _get_text_path_transform(self, x, y, s, prop, angle, ismath):
570         """
571         Return the text path and transform.
572 
573         Parameters
574         ----------
575         x : float
576             The x location of the text in display coords.
577         y : float
578             The y location of the text baseline in display coords.
579         s : str
580             The text to be converted.
581         prop : `~matplotlib.font_manager.FontProperties`
582             The font property.
583         angle : float
584             Angle in degrees to render the text at.
585         ismath : bool or "TeX"
586             If True, use mathtext parser. If "TeX", use tex for rendering.
587         """
588 
589         text2path = self._text2path
590         fontsize = self.points_to_pixels(prop.get_size_in_points())
591         verts, codes = text2path.get_text_path(prop, s, ismath=ismath)
592 
593         path = Path(verts, codes)
594         angle = np.deg2rad(angle)
595         if self.flipy():
596             width, height = self.get_canvas_width_height()
597             transform = (Affine2D()
598                          .scale(fontsize / text2path.FONT_SCALE)
599                          .rotate(angle)
600                          .translate(x, height - y))
601         else:
602             transform = (Affine2D()
603                          .scale(fontsize / text2path.FONT_SCALE)
604                          .rotate(angle)
605                          .translate(x, y))
606 
607         return path, transform
608 
609     def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):
610         """
611         Draw the text by converting them to paths using `.TextToPath`.
612 
613         Parameters
614         ----------
615         gc : `.GraphicsContextBase`
616             The graphics context.
617         x : float
618             The x location of the text in display coords.
619         y : float
620             The y location of the text baseline in display coords.
621         s : str
622             The text to be converted.
623         prop : `~matplotlib.font_manager.FontProperties`
624             The font property.
625         angle : float
626             Angle in degrees to render the text at.
627         ismath : bool or "TeX"
628             If True, use mathtext parser. If "TeX", use tex for rendering.
629         """
630         path, transform = self._get_text_path_transform(
631             x, y, s, prop, angle, ismath)
632         color = gc.get_rgb()
633         gc.set_linewidth(0.0)
634         self.draw_path(gc, path, transform, rgbFace=color)
635 
636     def get_text_width_height_descent(self, s, prop, ismath):
637         """
638         Get the width, height, and descent (offset from the bottom to the baseline), in
639         display coords, of the string *s* with `.FontProperties` *prop*.
640 
641         Whitespace at the start and the end of *s* is included in the reported width.
642         """
643         fontsize = prop.get_size_in_points()
644 
645         if ismath == 'TeX':
646             # todo: handle properties
647             return self.get_texmanager().get_text_width_height_descent(
648                 s, fontsize, renderer=self)
649 
650         dpi = self.points_to_pixels(72)
651         if ismath:
652             dims = self._text2path.mathtext_parser.parse(s, dpi, prop)
653             return dims[0:3]  # return width, height, descent
654 
655         flags = self._text2path._get_hinting_flag()
656         font = self._text2path._get_font(prop)
657         font.set_size(fontsize, dpi)
658         # the width and height of unrotated string
659         font.set_text(s, 0.0, flags=flags)
660         w, h = font.get_width_height()
661         d = font.get_descent()
662         w /= 64.0  # convert from subpixels
663         h /= 64.0
664         d /= 64.0
665         return w, h, d
666 
667     def flipy(self):
668         """
669         Return whether y values increase from top to bottom.
670 
671         Note that this only affects drawing of texts.
672         """
673         return True
674 
675     def get_canvas_width_height(self):
676         """Return the canvas width and height in display coords."""
677         return 1, 1
678 
679     def get_texmanager(self):
680         """Return the `.TexManager` instance."""
681         if self._texmanager is None:
682             self._texmanager = TexManager()
683         return self._texmanager
684 
685     def new_gc(self):
686         """Return an instance of a `.GraphicsContextBase`."""
687         return GraphicsContextBase()
688 
689     def points_to_pixels(self, points):
690         """
691         Convert points to display units.
692 
693         You need to override this function (unless your backend
694         doesn't have a dpi, e.g., postscript or svg).  Some imaging
695         systems assume some value for pixels per inch::
696 
697             points to pixels = points * pixels_per_inch/72 * dpi/72
698 
699         Parameters
700         ----------
701         points : float or array-like
702 
703         Returns
704         -------
705         Points converted to pixels
706         """
707         return points
708 
709     def start_rasterizing(self):
710         """
711         Switch to the raster renderer.
712 
713         Used by `.MixedModeRenderer`.
714         """
715 
716     def stop_rasterizing(self):
717         """
718         Switch back to the vector renderer and draw the contents of the raster
719         renderer as an image on the vector renderer.
720 
721         Used by `.MixedModeRenderer`.
722         """
723 
724     def start_filter(self):
725         """
726         Switch to a temporary renderer for image filtering effects.
727 
728         Currently only supported by the agg renderer.
729         """
730 
731     def stop_filter(self, filter_func):
732         """
733         Switch back to the original renderer.  The contents of the temporary
734         renderer is processed with the *filter_func* and is drawn on the
735         original renderer as an image.
736 
737         Currently only supported by the agg renderer.
738         """
739 
740     def _draw_disabled(self):
741         """
742         Context manager to temporary disable drawing.
743 
744         This is used for getting the drawn size of Artists.  This lets us
745         run the draw process to update any Python state but does not pay the
746         cost of the draw_XYZ calls on the canvas.
747         """
748         no_ops = {
749             meth_name: lambda *args, **kwargs: None
750             for meth_name in dir(RendererBase)
751             if (meth_name.startswith("draw_")
752                 or meth_name in ["open_group", "close_group"])
753         }
754 
755         return _setattr_cm(self, **no_ops)
756 
757 
758 class GraphicsContextBase:
759     """An abstract base class that provides color, line styles, etc."""
760 
761     def __init__(self):
762         self._alpha = 1.0
763         self._forced_alpha = False  # if True, _alpha overrides A from RGBA
764         self._antialiased = 1  # use 0, 1 not True, False for extension code
765         self._capstyle = CapStyle('butt')
766         self._cliprect = None
767         self._clippath = None
768         self._dashes = 0, None
769         self._joinstyle = JoinStyle('round')
770         self._linestyle = 'solid'
771         self._linewidth = 1
772         self._rgb = (0.0, 0.0, 0.0, 1.0)
773         self._hatch = None
774         self._hatch_color = colors.to_rgba(rcParams['hatch.color'])
775         self._hatch_linewidth = rcParams['hatch.linewidth']
776         self._url = None
777         self._gid = None
778         self._snap = None
779         self._sketch = None
780 
781     def copy_properties(self, gc):
782         """Copy properties from *gc* to self."""
783         self._alpha = gc._alpha
784         self._forced_alpha = gc._forced_alpha
785         self._antialiased = gc._antialiased
786         self._capstyle = gc._capstyle
787         self._cliprect = gc._cliprect
788         self._clippath = gc._clippath
789         self._dashes = gc._dashes
790         self._joinstyle = gc._joinstyle
791         self._linestyle = gc._linestyle
792         self._linewidth = gc._linewidth
793         self._rgb = gc._rgb
794         self._hatch = gc._hatch
795         self._hatch_color = gc._hatch_color
796         self._hatch_linewidth = gc._hatch_linewidth
797         self._url = gc._url
798         self._gid = gc._gid
799         self._snap = gc._snap
800         self._sketch = gc._sketch
801 
802     def restore(self):
803         """
804         Restore the graphics context from the stack - needed only
805         for backends that save graphics contexts on a stack.
806         """
807 
808     def get_alpha(self):
809         """
810         Return the alpha value used for blending - not supported on all
811         backends.
812         """
813         return self._alpha
814 
815     def get_antialiased(self):
816         """Return whether the object should try to do antialiased rendering."""
817         return self._antialiased
818 
819     def get_capstyle(self):
820         """Return the `.CapStyle`."""
821         return self._capstyle.name
822 
823     def get_clip_rectangle(self):
824         """
825         Return the clip rectangle as a `~matplotlib.transforms.Bbox` instance.
826         """
827         return self._cliprect
828 
829     def get_clip_path(self):
830         """
831         Return the clip path in the form (path, transform), where path
832         is a `~.path.Path` instance, and transform is
833         an affine transform to apply to the path before clipping.
834         """
835         if self._clippath is not None:
836             tpath, tr = self._clippath.get_transformed_path_and_affine()
837             if np.all(np.isfinite(tpath.vertices)):
838                 return tpath, tr
839             else:
840                 _log.warning("Ill-defined clip_path detected. Returning None.")
841                 return None, None
842         return None, None
843 
844     def get_dashes(self):
845         """
846         Return the dash style as an (offset, dash-list) pair.
847 
848         See `.set_dashes` for details.
849 
850         Default value is (None, None).
851         """
852         return self._dashes
853 
854     def get_forced_alpha(self):
855         """
856         Return whether the value given by get_alpha() should be used to
857         override any other alpha-channel values.
858         """
859         return self._forced_alpha
860 
861     def get_joinstyle(self):
862         """Return the `.JoinStyle`."""
863         return self._joinstyle.name
864 
865     def get_linewidth(self):
866         """Return the line width in points."""
867         return self._linewidth
868 
869     def get_rgb(self):
870         """Return a tuple of three or four floats from 0-1."""
871         return self._rgb
872 
873     def get_url(self):
874         """Return a url if one is set, None otherwise."""
875         return self._url
876 
877     def get_gid(self):
878         """Return the object identifier if one is set, None otherwise."""
879         return self._gid
880 
881     def get_snap(self):
882         """
883         Return the snap setting, which can be:
884 
885         * True: snap vertices to the nearest pixel center
886         * False: leave vertices as-is
887         * None: (auto) If the path contains only rectilinear line segments,
888           round to the nearest pixel center
889         """
890         return self._snap
891 
892     def set_alpha(self, alpha):
893         """
894         Set the alpha value used for blending - not supported on all backends.
895 
896         If ``alpha=None`` (the default), the alpha components of the
897         foreground and fill colors will be used to set their respective
898         transparencies (where applicable); otherwise, ``alpha`` will override
899         them.
900         """
901         if alpha is not None:
902             self._alpha = alpha
903             self._forced_alpha = True
904         else:
905             self._alpha = 1.0
906             self._forced_alpha = False
907         self.set_foreground(self._rgb, isRGBA=True)
908 
909     def set_antialiased(self, b):
910         """Set whether object should be drawn with antialiased rendering."""
911         # Use ints to make life easier on extension code trying to read the gc.
912         self._antialiased = int(bool(b))
913 
914     @_docstring.interpd
915     def set_capstyle(self, cs):
916         """
917         Set how to draw endpoints of lines.
918 
919         Parameters
920         ----------
921         cs : `.CapStyle` or %(CapStyle)s
922         """
923         self._capstyle = CapStyle(cs)
924 
925     def set_clip_rectangle(self, rectangle):
926         """Set the clip rectangle to a `.Bbox` or None."""
927         self._cliprect = rectangle
928 
929     def set_clip_path(self, path):
930         """Set the clip path to a `.TransformedPath` or None."""
931         _api.check_isinstance((transforms.TransformedPath, None), path=path)
932         self._clippath = path
933 
934     def set_dashes(self, dash_offset, dash_list):
935         """
936         Set the dash style for the gc.
937 
938         Parameters
939         ----------
940         dash_offset : float
941             Distance, in points, into the dash pattern at which to
942             start the pattern. It is usually set to 0.
943         dash_list : array-like or None
944             The on-off sequence as points.  None specifies a solid line. All
945             values must otherwise be non-negative (:math:`\\ge 0`).
946 
947         Notes
948         -----
949         See p. 666 of the PostScript
950         `Language Reference
951         <https://www.adobe.com/jp/print/postscript/pdfs/PLRM.pdf>`_
952         for more info.
953         """
954         if dash_list is not None:
955             dl = np.asarray(dash_list)
956             if np.any(dl < 0.0):
957                 raise ValueError(
958                     "All values in the dash list must be non-negative")
959             if dl.size and not np.any(dl > 0.0):
960                 raise ValueError(
961                     'At least one value in the dash list must be positive')
962         self._dashes = dash_offset, dash_list
963 
964     def set_foreground(self, fg, isRGBA=False):
965         """
966         Set the foreground color.
967 
968         Parameters
969         ----------
970         fg : color
971         isRGBA : bool
972             If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be
973             set to True to improve performance.
974         """
975         if self._forced_alpha and isRGBA:
976             self._rgb = fg[:3] + (self._alpha,)
977         elif self._forced_alpha:
978             self._rgb = colors.to_rgba(fg, self._alpha)
979         elif isRGBA:
980             self._rgb = fg
981         else:
982             self._rgb = colors.to_rgba(fg)
983 
984     @_docstring.interpd
985     def set_joinstyle(self, js):
986         """
987         Set how to draw connections between line segments.
988 
989         Parameters
990         ----------
991         js : `.JoinStyle` or %(JoinStyle)s
992         """
993         self._joinstyle = JoinStyle(js)
994 
995     def set_linewidth(self, w):
996         """Set the linewidth in points."""
997         self._linewidth = float(w)
998 
999     def set_url(self, url):
1000         """Set the url for links in compatible backends."""
1001         self._url = url
1002 
1003     def set_gid(self, id):
1004         """Set the id."""
1005         self._gid = id
1006 
1007     def set_snap(self, snap):
1008         """
1009         Set the snap setting which may be:
1010 
1011         * True: snap vertices to the nearest pixel center
1012         * False: leave vertices as-is
1013         * None: (auto) If the path contains only rectilinear line segments,
1014           round to the nearest pixel center
1015         """
1016         self._snap = snap
1017 
1018     def set_hatch(self, hatch):
1019         """Set the hatch style (for fills)."""
1020         self._hatch = hatch
1021 
1022     def get_hatch(self):
1023         """Get the current hatch style."""
1024         return self._hatch
1025 
1026     def get_hatch_path(self, density=6.0):
1027         """Return a `.Path` for the current hatch."""
1028         hatch = self.get_hatch()
1029         if hatch is None:
1030             return None
1031         return Path.hatch(hatch, density)
1032 
1033     def get_hatch_color(self):
1034         """Get the hatch color."""
1035         return self._hatch_color
1036 
1037     def set_hatch_color(self, hatch_color):
1038         """Set the hatch color."""
1039         self._hatch_color = hatch_color
1040 
1041     def get_hatch_linewidth(self):
1042         """Get the hatch linewidth."""
1043         return self._hatch_linewidth
1044 
1045     def get_sketch_params(self):
1046         """
1047         Return the sketch parameters for the artist.
1048 
1049         Returns
1050         -------
1051         tuple or `None`
1052 
1053             A 3-tuple with the following elements:
1054 
1055             * ``scale``: The amplitude of the wiggle perpendicular to the
1056               source line.
1057             * ``length``: The length of the wiggle along the line.
1058             * ``randomness``: The scale factor by which the length is
1059               shrunken or expanded.
1060 
1061             May return `None` if no sketch parameters were set.
1062         """
1063         return self._sketch
1064 
1065     def set_sketch_params(self, scale=None, length=None, randomness=None):
1066         """
1067         Set the sketch parameters.
1068 
1069         Parameters
1070         ----------
1071         scale : float, optional
1072             The amplitude of the wiggle perpendicular to the source line, in
1073             pixels.  If scale is `None`, or not provided, no sketch filter will
1074             be provided.
1075         length : float, default: 128
1076             The length of the wiggle along the line, in pixels.
1077         randomness : float, default: 16
1078             The scale factor by which the length is shrunken or expanded.
1079         """
1080         self._sketch = (
1081             None if scale is None
1082             else (scale, length or 128., randomness or 16.))
1083 
1084 
1085 class TimerBase:
1086     """
1087     A base class for providing timer events, useful for things animations.
1088     Backends need to implement a few specific methods in order to use their
1089     own timing mechanisms so that the timer events are integrated into their
1090     event loops.
1091 
1092     Subclasses must override the following methods:
1093 
1094     - ``_timer_start``: Backend-specific code for starting the timer.
1095     - ``_timer_stop``: Backend-specific code for stopping the timer.
1096 
1097     Subclasses may additionally override the following methods:
1098 
1099     - ``_timer_set_single_shot``: Code for setting the timer to single shot
1100       operating mode, if supported by the timer object.  If not, the `Timer`
1101       class itself will store the flag and the ``_on_timer`` method should be
1102       overridden to support such behavior.
1103 
1104     - ``_timer_set_interval``: Code for setting the interval on the timer, if
1105       there is a method for doing so on the timer object.
1106 
1107     - ``_on_timer``: The internal function that any timer object should call,
1108       which will handle the task of running all callbacks that have been set.
1109     """
1110 
1111     def __init__(self, interval=None, callbacks=None):
1112         """
1113         Parameters
1114         ----------
1115         interval : int, default: 1000ms
1116             The time between timer events in milliseconds.  Will be stored as
1117             ``timer.interval``.
1118         callbacks : list[tuple[callable, tuple, dict]]
1119             List of (func, args, kwargs) tuples that will be called upon
1120             timer events.  This list is accessible as ``timer.callbacks`` and
1121             can be manipulated directly, or the functions `add_callback` and
1122             `remove_callback` can be used.
1123         """
1124         self.callbacks = [] if callbacks is None else callbacks.copy()
1125         # Set .interval and not ._interval to go through the property setter.
1126         self.interval = 1000 if interval is None else interval
1127         self.single_shot = False
1128 
1129     def __del__(self):
1130         """Need to stop timer and possibly disconnect timer."""
1131         self._timer_stop()
1132 
1133     def start(self, interval=None):
1134         """
1135         Start the timer object.
1136 
1137         Parameters
1138         ----------
1139         interval : int, optional
1140             Timer interval in milliseconds; overrides a previously set interval
1141             if provided.
1142         """
1143         if interval is not None:
1144             self.interval = interval
1145         self._timer_start()
1146 
1147     def stop(self):
1148         """Stop the timer."""
1149         self._timer_stop()
1150 
1151     def _timer_start(self):
1152         pass
1153 
1154     def _timer_stop(self):
1155         pass
1156 
1157     @property
1158     def interval(self):
1159         """The time between timer events, in milliseconds."""
1160         return self._interval
1161 
1162     @interval.setter
1163     def interval(self, interval):
1164         # Force to int since none of the backends actually support fractional
1165         # milliseconds, and some error or give warnings.
1166         # Some backends also fail when interval == 0, so ensure >= 1 msec
1167         interval = max(int(interval), 1)
1168         self._interval = interval
1169         self._timer_set_interval()
1170 
1171     @property
1172     def single_shot(self):
1173         """Whether this timer should stop after a single run."""
1174         return self._single
1175 
1176     @single_shot.setter
1177     def single_shot(self, ss):
1178         self._single = ss
1179         self._timer_set_single_shot()
1180 
1181     def add_callback(self, func, *args, **kwargs):
1182         """
1183         Register *func* to be called by timer when the event fires. Any
1184         additional arguments provided will be passed to *func*.
1185 
1186         This function returns *func*, which makes it possible to use it as a
1187         decorator.
1188         """
1189         self.callbacks.append((func, args, kwargs))
1190         return func
1191 
1192     def remove_callback(self, func, *args, **kwargs):
1193         """
1194         Remove *func* from list of callbacks.
1195 
1196         *args* and *kwargs* are optional and used to distinguish between copies
1197         of the same function registered to be called with different arguments.
1198         This behavior is deprecated.  In the future, ``*args, **kwargs`` won't
1199         be considered anymore; to keep a specific callback removable by itself,
1200         pass it to `add_callback` as a `functools.partial` object.
1201         """
1202         if args or kwargs:
1203             _api.warn_deprecated(
1204                 "3.1", message="In a future version, Timer.remove_callback "
1205                 "will not take *args, **kwargs anymore, but remove all "
1206                 "callbacks where the callable matches; to keep a specific "
1207                 "callback removable by itself, pass it to add_callback as a "
1208                 "functools.partial object.")
1209             self.callbacks.remove((func, args, kwargs))
1210         else:
1211             funcs = [c[0] for c in self.callbacks]
1212             if func in funcs:
1213                 self.callbacks.pop(funcs.index(func))
1214 
1215     def _timer_set_interval(self):
1216         """Used to set interval on underlying timer object."""
1217 
1218     def _timer_set_single_shot(self):
1219         """Used to set single shot on underlying timer object."""
1220 
1221     def _on_timer(self):
1222         """
1223         Runs all function that have been registered as callbacks. Functions
1224         can return False (or 0) if they should not be called any more. If there
1225         are no callbacks, the timer is automatically stopped.
1226         """
1227         for func, args, kwargs in self.callbacks:
1228             ret = func(*args, **kwargs)
1229             # docstring above explains why we use `if ret == 0` here,
1230             # instead of `if not ret`.
1231             # This will also catch `ret == False` as `False == 0`
1232             # but does not annoy the linters
1233             # https://docs.python.org/3/library/stdtypes.html#boolean-values
1234             if ret == 0:
1235                 self.callbacks.remove((func, args, kwargs))
1236 
1237         if len(self.callbacks) == 0:
1238             self.stop()
1239 
1240 
1241 class Event:
1242     """
1243     A Matplotlib event.
1244 
1245     The following attributes are defined and shown with their default values.
1246     Subclasses may define additional attributes.
1247 
1248     Attributes
1249     ----------
1250     name : str
1251         The event name.
1252     canvas : `FigureCanvasBase`
1253         The backend-specific canvas instance generating the event.
1254     guiEvent
1255         The GUI event that triggered the Matplotlib event.
1256     """
1257 
1258     def __init__(self, name, canvas, guiEvent=None):
1259         self.name = name
1260         self.canvas = canvas
1261         self._guiEvent = guiEvent
1262         self._guiEvent_deleted = False
1263 
1264     def _process(self):
1265         """Process this event on ``self.canvas``, then unset ``guiEvent``."""
1266         self.canvas.callbacks.process(self.name, self)
1267         self._guiEvent_deleted = True
1268 
1269     @property
1270     def guiEvent(self):
1271         # After deprecation elapses: remove _guiEvent_deleted; make guiEvent a plain
1272         # attribute set to None by _process.
1273         if self._guiEvent_deleted:
1274             _api.warn_deprecated(
1275                 "3.8", message="Accessing guiEvent outside of the original GUI event "
1276                 "handler is unsafe and deprecated since %(since)s; in the future, the "
1277                 "attribute will be set to None after quitting the event handler.  You "
1278                 "may separately record the value of the guiEvent attribute at your own "
1279                 "risk.")
1280         return self._guiEvent
1281 
1282 
1283 class DrawEvent(Event):
1284     """
1285     An event triggered by a draw operation on the canvas.
1286 
1287     In most backends, callbacks subscribed to this event will be fired after
1288     the rendering is complete but before the screen is updated. Any extra
1289     artists drawn to the canvas's renderer will be reflected without an
1290     explicit call to ``blit``.
1291 
1292     .. warning::
1293 
1294        Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may
1295        not be safe with all backends and may cause infinite recursion.
1296 
1297     A DrawEvent has a number of special attributes in addition to those defined
1298     by the parent `Event` class.
1299 
1300     Attributes
1301     ----------
1302     renderer : `RendererBase`
1303         The renderer for the draw event.
1304     """
1305     def __init__(self, name, canvas, renderer):
1306         super().__init__(name, canvas)
1307         self.renderer = renderer
1308 
1309 
1310 class ResizeEvent(Event):
1311     """
1312     An event triggered by a canvas resize.
1313 
1314     A ResizeEvent has a number of special attributes in addition to those
1315     defined by the parent `Event` class.
1316 
1317     Attributes
1318     ----------
1319     width : int
1320         Width of the canvas in pixels.
1321     height : int
1322         Height of the canvas in pixels.
1323     """
1324 
1325     def __init__(self, name, canvas):
1326         super().__init__(name, canvas)
1327         self.width, self.height = canvas.get_width_height()
1328 
1329 
1330 class CloseEvent(Event):
1331     """An event triggered by a figure being closed."""
1332 
1333 
1334 class LocationEvent(Event):
1335     """
1336     An event that has a screen location.
1337 
1338     A LocationEvent has a number of special attributes in addition to those
1339     defined by the parent `Event` class.
1340 
1341     Attributes
1342     ----------
1343     x, y : int or None
1344         Event location in pixels from bottom left of canvas.
1345     inaxes : `~matplotlib.axes.Axes` or None
1346         The `~.axes.Axes` instance over which the mouse is, if any.
1347     xdata, ydata : float or None
1348         Data coordinates of the mouse within *inaxes*, or *None* if the mouse
1349         is not over an Axes.
1350     modifiers : frozenset
1351         The keyboard modifiers currently being pressed (except for KeyEvent).
1352     """
1353 
1354     # Fully delete all occurrences of lastevent after deprecation elapses.
1355     _lastevent = None
1356     lastevent = _api.deprecated("3.8")(
1357         _api.classproperty(lambda cls: cls._lastevent))
1358     _last_axes_ref = None
1359 
1360     def __init__(self, name, canvas, x, y, guiEvent=None, *, modifiers=None):
1361         super().__init__(name, canvas, guiEvent=guiEvent)
1362         # x position - pixels from left of canvas
1363         self.x = int(x) if x is not None else x
1364         # y position - pixels from right of canvas
1365         self.y = int(y) if y is not None else y
1366         self.inaxes = None  # the Axes instance the mouse is over
1367         self.xdata = None   # x coord of mouse in data coords
1368         self.ydata = None   # y coord of mouse in data coords
1369         self.modifiers = frozenset(modifiers if modifiers is not None else [])
1370 
1371         if x is None or y is None:
1372             # cannot check if event was in Axes if no (x, y) info
1373             return
1374 
1375         self._set_inaxes(self.canvas.inaxes((x, y))
1376                          if self.canvas.mouse_grabber is None else
1377                          self.canvas.mouse_grabber,
1378                          (x, y))
1379 
1380     # Splitting _set_inaxes out is useful for the axes_leave_event handler: it
1381     # needs to generate synthetic LocationEvents with manually-set inaxes.  In
1382     # that latter case, xy has already been cast to int so it can directly be
1383     # read from self.x, self.y; in the normal case, however, it is more
1384     # accurate to pass the untruncated float x, y values passed to the ctor.
1385 
1386     def _set_inaxes(self, inaxes, xy=None):
1387         self.inaxes = inaxes
1388         if inaxes is not None:
1389             try:
1390                 self.xdata, self.ydata = inaxes.transData.inverted().transform(
1391                     xy if xy is not None else (self.x, self.y))
1392             except ValueError:
1393                 pass
1394 
1395 
1396 class MouseButton(IntEnum):
1397     LEFT = 1
1398     MIDDLE = 2
1399     RIGHT = 3
1400     BACK = 8
1401     FORWARD = 9
1402 
1403 
1404 class MouseEvent(LocationEvent):
1405     """
1406     A mouse event ('button_press_event', 'button_release_event', \
1407 'scroll_event', 'motion_notify_event').
1408 
1409     A MouseEvent has a number of special attributes in addition to those
1410     defined by the parent `Event` and `LocationEvent` classes.
1411 
1412     Attributes
1413     ----------
1414     button : None or `MouseButton` or {'up', 'down'}
1415         The button pressed. 'up' and 'down' are used for scroll events.
1416 
1417         Note that LEFT and RIGHT actually refer to the "primary" and
1418         "secondary" buttons, i.e. if the user inverts their left and right
1419         buttons ("left-handed setting") then the LEFT button will be the one
1420         physically on the right.
1421 
1422         If this is unset, *name* is "scroll_event", and *step* is nonzero, then
1423         this will be set to "up" or "down" depending on the sign of *step*.
1424 
1425     key : None or str
1426         The key pressed when the mouse event triggered, e.g. 'shift'.
1427         See `KeyEvent`.
1428 
1429         .. warning::
1430            This key is currently obtained from the last 'key_press_event' or
1431            'key_release_event' that occurred within the canvas.  Thus, if the
1432            last change of keyboard state occurred while the canvas did not have
1433            focus, this attribute will be wrong.  On the other hand, the
1434            ``modifiers`` attribute should always be correct, but it can only
1435            report on modifier keys.
1436 
1437     step : float
1438         The number of scroll steps (positive for 'up', negative for 'down').
1439         This applies only to 'scroll_event' and defaults to 0 otherwise.
1440 
1441     dblclick : bool
1442         Whether the event is a double-click. This applies only to
1443         'button_press_event' and is False otherwise. In particular, it's
1444         not used in 'button_release_event'.
1445 
1446     Examples
1447     --------
1448     ::
1449 
1450         def on_press(event):
1451             print('you pressed', event.button, event.xdata, event.ydata)
1452 
1453         cid = fig.canvas.mpl_connect('button_press_event', on_press)
1454     """
1455 
1456     def __init__(self, name, canvas, x, y, button=None, key=None,
1457                  step=0, dblclick=False, guiEvent=None, *, modifiers=None):
1458         super().__init__(
1459             name, canvas, x, y, guiEvent=guiEvent, modifiers=modifiers)
1460         if button in MouseButton.__members__.values():
1461             button = MouseButton(button)
1462         if name == "scroll_event" and button is None:
1463             if step > 0:
1464                 button = "up"
1465             elif step < 0:
1466                 button = "down"
1467         self.button = button
1468         self.key = key
1469         self.step = step
1470         self.dblclick = dblclick
1471 
1472     def __str__(self):
1473         return (f"{self.name}: "
1474                 f"xy=({self.x}, {self.y}) xydata=({self.xdata}, {self.ydata}) "
1475                 f"button={self.button} dblclick={self.dblclick} "
1476                 f"inaxes={self.inaxes}")
1477 
1478 
1479 class PickEvent(Event):
1480     """
1481     A pick event.
1482 
1483     This event is fired when the user picks a location on the canvas
1484     sufficiently close to an artist that has been made pickable with
1485     `.Artist.set_picker`.
1486 
1487     A PickEvent has a number of special attributes in addition to those defined
1488     by the parent `Event` class.
1489 
1490     Attributes
1491     ----------
1492     mouseevent : `MouseEvent`
1493         The mouse event that generated the pick.
1494     artist : `~matplotlib.artist.Artist`
1495         The picked artist.  Note that artists are not pickable by default
1496         (see `.Artist.set_picker`).
1497     other
1498         Additional attributes may be present depending on the type of the
1499         picked object; e.g., a `.Line2D` pick may define different extra
1500         attributes than a `.PatchCollection` pick.
1501 
1502     Examples
1503     --------
1504     Bind a function ``on_pick()`` to pick events, that prints the coordinates
1505     of the picked data point::
1506 
1507         ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance
1508 
1509         def on_pick(event):
1510             line = event.artist
1511             xdata, ydata = line.get_data()
1512             ind = event.ind
1513             print(f'on pick line: {xdata[ind]:.3f}, {ydata[ind]:.3f}')
1514 
1515         cid = fig.canvas.mpl_connect('pick_event', on_pick)
1516     """
1517 
1518     def __init__(self, name, canvas, mouseevent, artist,
1519                  guiEvent=None, **kwargs):
1520         if guiEvent is None:
1521             guiEvent = mouseevent.guiEvent
1522         super().__init__(name, canvas, guiEvent)
1523         self.mouseevent = mouseevent
1524         self.artist = artist
1525         self.__dict__.update(kwargs)
1526 
1527 
1528 class KeyEvent(LocationEvent):
1529     """
1530     A key event (key press, key release).
1531 
1532     A KeyEvent has a number of special attributes in addition to those defined
1533     by the parent `Event` and `LocationEvent` classes.
1534 
1535     Attributes
1536     ----------
1537     key : None or str
1538         The key(s) pressed. Could be *None*, a single case sensitive Unicode
1539         character ("g", "G", "#", etc.), a special key ("control", "shift",
1540         "f1", "up", etc.) or a combination of the above (e.g., "ctrl+alt+g",
1541         "ctrl+alt+G").
1542 
1543     Notes
1544     -----
1545     Modifier keys will be prefixed to the pressed key and will be in the order
1546     "ctrl", "alt", "super". The exception to this rule is when the pressed key
1547     is itself a modifier key, therefore "ctrl+alt" and "alt+control" can both
1548     be valid key values.
1549 
1550     Examples
1551     --------
1552     ::
1553 
1554         def on_key(event):
1555             print('you pressed', event.key, event.xdata, event.ydata)
1556 
1557         cid = fig.canvas.mpl_connect('key_press_event', on_key)
1558     """
1559 
1560     def __init__(self, name, canvas, key, x=0, y=0, guiEvent=None):
1561         super().__init__(name, canvas, x, y, guiEvent=guiEvent)
1562         self.key = key
1563 
1564 
1565 # Default callback for key events.
1566 def _key_handler(event):
1567     # Dead reckoning of key.
1568     if event.name == "key_press_event":
1569         event.canvas._key = event.key
1570     elif event.name == "key_release_event":
1571         event.canvas._key = None
1572 
1573 
1574 # Default callback for mouse events.
1575 def _mouse_handler(event):
1576     # Dead-reckoning of button and key.
1577     if event.name == "button_press_event":
1578         event.canvas._button = event.button
1579     elif event.name == "button_release_event":
1580         event.canvas._button = None
1581     elif event.name == "motion_notify_event" and event.button is None:
1582         event.button = event.canvas._button
1583     if event.key is None:
1584         event.key = event.canvas._key
1585     # Emit axes_enter/axes_leave.
1586     if event.name == "motion_notify_event":
1587         last_ref = LocationEvent._last_axes_ref
1588         last_axes = last_ref() if last_ref else None
1589         if last_axes != event.inaxes:
1590             if last_axes is not None:
1591                 # Create a synthetic LocationEvent for the axes_leave_event.
1592                 # Its inaxes attribute needs to be manually set (because the
1593                 # cursor is actually *out* of that axes at that point); this is
1594                 # done with the internal _set_inaxes method which ensures that
1595                 # the xdata and ydata attributes are also correct.
1596                 try:
1597                     leave_event = LocationEvent(
1598                         "axes_leave_event", last_axes.figure.canvas,
1599                         event.x, event.y, event.guiEvent,
1600                         modifiers=event.modifiers)
1601                     leave_event._set_inaxes(last_axes)
1602                     last_axes.figure.canvas.callbacks.process(
1603                         "axes_leave_event", leave_event)
1604                 except Exception:
1605                     pass  # The last canvas may already have been torn down.
1606             if event.inaxes is not None:
1607                 event.canvas.callbacks.process("axes_enter_event", event)
1608         LocationEvent._last_axes_ref = (
1609             weakref.ref(event.inaxes) if event.inaxes else None)
1610         LocationEvent._lastevent = (
1611             None if event.name == "figure_leave_event" else event)
1612 
1613 
1614 def _get_renderer(figure, print_method=None):
1615     """
1616     Get the renderer that would be used to save a `.Figure`.
1617 
1618     If you need a renderer without any active draw methods use
1619     renderer._draw_disabled to temporary patch them out at your call site.
1620     """
1621     # This is implemented by triggering a draw, then immediately jumping out of
1622     # Figure.draw() by raising an exception.
1623 
1624     class Done(Exception):
1625         pass
1626 
1627     def _draw(renderer): raise Done(renderer)
1628 
1629     with cbook._setattr_cm(figure, draw=_draw), ExitStack() as stack:
1630         if print_method is None:
1631             fmt = figure.canvas.get_default_filetype()
1632             # Even for a canvas' default output type, a canvas switch may be
1633             # needed, e.g. for FigureCanvasBase.
1634             print_method = stack.enter_context(
1635                 figure.canvas._switch_canvas_and_return_print_method(fmt))
1636         try:
1637             print_method(io.BytesIO())
1638         except Done as exc:
1639             renderer, = exc.args
1640             return renderer
1641         else:
1642             raise RuntimeError(f"{print_method} did not call Figure.draw, so "
1643                                f"no renderer is available")
1644 
1645 
1646 def _no_output_draw(figure):
1647     # _no_output_draw was promoted to the figure level, but
1648     # keep this here in case someone was calling it...
1649     figure.draw_without_rendering()
1650 
1651 
1652 def _is_non_interactive_terminal_ipython(ip):
1653     """
1654     Return whether we are in a terminal IPython, but non interactive.
1655 
1656     When in _terminal_ IPython, ip.parent will have and `interact` attribute,
1657     if this attribute is False we do not setup eventloop integration as the
1658     user will _not_ interact with IPython. In all other case (ZMQKernel, or is
1659     interactive), we do.
1660     """
1661     return (hasattr(ip, 'parent')
1662             and (ip.parent is not None)
1663             and getattr(ip.parent, 'interact', None) is False)
1664 
1665 
1666 class FigureCanvasBase:
1667     """
1668     The canvas the figure renders into.
1669 
1670     Attributes
1671     ----------
1672     figure : `~matplotlib.figure.Figure`
1673         A high-level figure instance.
1674     """
1675 
1676     # Set to one of {"qt", "gtk3", "gtk4", "wx", "tk", "macosx"} if an
1677     # interactive framework is required, or None otherwise.
1678     required_interactive_framework = None
1679 
1680     # The manager class instantiated by new_manager.
1681     # (This is defined as a classproperty because the manager class is
1682     # currently defined *after* the canvas class, but one could also assign
1683     # ``FigureCanvasBase.manager_class = FigureManagerBase``
1684     # after defining both classes.)
1685     manager_class = _api.classproperty(lambda cls: FigureManagerBase)
1686 
1687     events = [
1688         'resize_event',
1689         'draw_event',
1690         'key_press_event',
1691         'key_release_event',
1692         'button_press_event',
1693         'button_release_event',
1694         'scroll_event',
1695         'motion_notify_event',
1696         'pick_event',
1697         'figure_enter_event',
1698         'figure_leave_event',
1699         'axes_enter_event',
1700         'axes_leave_event',
1701         'close_event'
1702     ]
1703 
1704     fixed_dpi = None
1705 
1706     filetypes = _default_filetypes
1707 
1708     @_api.classproperty
1709     def supports_blit(cls):
1710         """If this Canvas sub-class supports blitting."""
1711         return (hasattr(cls, "copy_from_bbox")
1712                 and hasattr(cls, "restore_region"))
1713 
1714     def __init__(self, figure=None):
1715         from matplotlib.figure import Figure
1716         self._fix_ipython_backend2gui()
1717         self._is_idle_drawing = True
1718         self._is_saving = False
1719         if figure is None:
1720             figure = Figure()
1721         figure.set_canvas(self)
1722         self.figure = figure
1723         self.manager = None
1724         self.widgetlock = widgets.LockDraw()
1725         self._button = None  # the button pressed
1726         self._key = None  # the key pressed
1727         self.mouse_grabber = None  # the Axes currently grabbing mouse
1728         self.toolbar = None  # NavigationToolbar2 will set me
1729         self._is_idle_drawing = False
1730         # We don't want to scale up the figure DPI more than once.
1731         figure._original_dpi = figure.dpi
1732         self._device_pixel_ratio = 1
1733         super().__init__()  # Typically the GUI widget init (if any).
1734 
1735     callbacks = property(lambda self: self.figure._canvas_callbacks)
1736     button_pick_id = property(lambda self: self.figure._button_pick_id)
1737     scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)
1738 
1739     @classmethod
1740     @functools.cache
1741     def _fix_ipython_backend2gui(cls):
1742         # Fix hard-coded module -> toolkit mapping in IPython (used for
1743         # `ipython --auto`).  This cannot be done at import time due to
1744         # ordering issues, so we do it when creating a canvas, and should only
1745         # be done once per class (hence the `cache`).
1746         if sys.modules.get("IPython") is None:
1747             return
1748         import IPython
1749         ip = IPython.get_ipython()
1750         if not ip:
1751             return
1752         from IPython.core import pylabtools as pt
1753         if (not hasattr(pt, "backend2gui")
1754                 or not hasattr(ip, "enable_matplotlib")):
1755             # In case we ever move the patch to IPython and remove these APIs,
1756             # don't break on our side.
1757             return
1758         backend2gui_rif = {
1759             "qt": "qt",
1760             "gtk3": "gtk3",
1761             "gtk4": "gtk4",
1762             "wx": "wx",
1763             "macosx": "osx",
1764         }.get(cls.required_interactive_framework)
1765         if backend2gui_rif:
1766             if _is_non_interactive_terminal_ipython(ip):
1767                 ip.enable_gui(backend2gui_rif)
1768 
1769     @classmethod
1770     def new_manager(cls, figure, num):
1771         """
1772         Create a new figure manager for *figure*, using this canvas class.
1773 
1774         Notes
1775         -----
1776         This method should not be reimplemented in subclasses.  If
1777         custom manager creation logic is needed, please reimplement
1778         ``FigureManager.create_with_canvas``.
1779         """
1780         return cls.manager_class.create_with_canvas(cls, figure, num)
1781 
1782     @contextmanager
1783     def _idle_draw_cntx(self):
1784         self._is_idle_drawing = True
1785         try:
1786             yield
1787         finally:
1788             self._is_idle_drawing = False
1789 
1790     def is_saving(self):
1791         """
1792         Return whether the renderer is in the process of saving
1793         to a file, rather than rendering for an on-screen buffer.
1794         """
1795         return self._is_saving
1796 
1797     def blit(self, bbox=None):
1798         """Blit the canvas in bbox (default entire canvas)."""
1799 
1800     def inaxes(self, xy):
1801         """
1802         Return the topmost visible `~.axes.Axes` containing the point *xy*.
1803 
1804         Parameters
1805         ----------
1806         xy : (float, float)
1807             (x, y) pixel positions from left/bottom of the canvas.
1808 
1809         Returns
1810         -------
1811         `~matplotlib.axes.Axes` or None
1812             The topmost visible Axes containing the point, or None if there
1813             is no Axes at the point.
1814         """
1815         axes_list = [a for a in self.figure.get_axes()
1816                      if a.patch.contains_point(xy) and a.get_visible()]
1817         if axes_list:
1818             axes = cbook._topmost_artist(axes_list)
1819         else:
1820             axes = None
1821 
1822         return axes
1823 
1824     def grab_mouse(self, ax):
1825         """
1826         Set the child `~.axes.Axes` which is grabbing the mouse events.
1827 
1828         Usually called by the widgets themselves. It is an error to call this
1829         if the mouse is already grabbed by another Axes.
1830         """
1831         if self.mouse_grabber not in (None, ax):
1832             raise RuntimeError("Another Axes already grabs mouse input")
1833         self.mouse_grabber = ax
1834 
1835     def release_mouse(self, ax):
1836         """
1837         Release the mouse grab held by the `~.axes.Axes` *ax*.
1838 
1839         Usually called by the widgets. It is ok to call this even if *ax*
1840         doesn't have the mouse grab currently.
1841         """
1842         if self.mouse_grabber is ax:
1843             self.mouse_grabber = None
1844 
1845     def set_cursor(self, cursor):
1846         """
1847         Set the current cursor.
1848 
1849         This may have no effect if the backend does not display anything.
1850 
1851         If required by the backend, this method should trigger an update in
1852         the backend event loop after the cursor is set, as this method may be
1853         called e.g. before a long-running task during which the GUI is not
1854         updated.
1855 
1856         Parameters
1857         ----------
1858         cursor : `.Cursors`
1859             The cursor to display over the canvas. Note: some backends may
1860             change the cursor for the entire window.
1861         """
1862 
1863     def draw(self, *args, **kwargs):
1864         """
1865         Render the `.Figure`.
1866 
1867         This method must walk the artist tree, even if no output is produced,
1868         because it triggers deferred work that users may want to access
1869         before saving output to disk. For example computing limits,
1870         auto-limits, and tick values.
1871         """
1872 
1873     def draw_idle(self, *args, **kwargs):
1874         """
1875         Request a widget redraw once control returns to the GUI event loop.
1876 
1877         Even if multiple calls to `draw_idle` occur before control returns
1878         to the GUI event loop, the figure will only be rendered once.
1879 
1880         Notes
1881         -----
1882         Backends may choose to override the method and implement their own
1883         strategy to prevent multiple renderings.
1884 
1885         """
1886         if not self._is_idle_drawing:
1887             with self._idle_draw_cntx():
1888                 self.draw(*args, **kwargs)
1889 
1890     @property
1891     def device_pixel_ratio(self):
1892         """
1893         The ratio of physical to logical pixels used for the canvas on screen.
1894 
1895         By default, this is 1, meaning physical and logical pixels are the same
1896         size. Subclasses that support High DPI screens may set this property to
1897         indicate that said ratio is different. All Matplotlib interaction,
1898         unless working directly with the canvas, remains in logical pixels.
1899 
1900         """
1901         return self._device_pixel_ratio
1902 
1903     def _set_device_pixel_ratio(self, ratio):
1904         """
1905         Set the ratio of physical to logical pixels used for the canvas.
1906 
1907         Subclasses that support High DPI screens can set this property to
1908         indicate that said ratio is different. The canvas itself will be
1909         created at the physical size, while the client side will use the
1910         logical size. Thus the DPI of the Figure will change to be scaled by
1911         this ratio. Implementations that support High DPI screens should use
1912         physical pixels for events so that transforms back to Axes space are
1913         correct.
1914 
1915         By default, this is 1, meaning physical and logical pixels are the same
1916         size.
1917 
1918         Parameters
1919         ----------
1920         ratio : float
1921             The ratio of logical to physical pixels used for the canvas.
1922 
1923         Returns
1924         -------
1925         bool
1926             Whether the ratio has changed. Backends may interpret this as a
1927             signal to resize the window, repaint the canvas, or change any
1928             other relevant properties.
1929         """
1930         if self._device_pixel_ratio == ratio:
1931             return False
1932         # In cases with mixed resolution displays, we need to be careful if the
1933         # device pixel ratio changes - in this case we need to resize the
1934         # canvas accordingly. Some backends provide events that indicate a
1935         # change in DPI, but those that don't will update this before drawing.
1936         dpi = ratio * self.figure._original_dpi
1937         self.figure._set_dpi(dpi, forward=False)
1938         self._device_pixel_ratio = ratio
1939         return True
1940 
1941     def get_width_height(self, *, physical=False):
1942         """
1943         Return the figure width and height in integral points or pixels.
1944 
1945         When the figure is used on High DPI screens (and the backend supports
1946         it), the truncation to integers occurs after scaling by the device
1947         pixel ratio.
1948 
1949         Parameters
1950         ----------
1951         physical : bool, default: False
1952             Whether to return true physical pixels or logical pixels. Physical
1953             pixels may be used by backends that support HiDPI, but still
1954             configure the canvas using its actual size.
1955 
1956         Returns
1957         -------
1958         width, height : int
1959             The size of the figure, in points or pixels, depending on the
1960             backend.
1961         """
1962         return tuple(int(size / (1 if physical else self.device_pixel_ratio))
1963                      for size in self.figure.bbox.max)
1964 
1965     @classmethod
1966     def get_supported_filetypes(cls):
1967         """Return dict of savefig file formats supported by this backend."""
1968         return cls.filetypes
1969 
1970     @classmethod
1971     def get_supported_filetypes_grouped(cls):
1972         """
1973         Return a dict of savefig file formats supported by this backend,
1974         where the keys are a file type name, such as 'Joint Photographic
1975         Experts Group', and the values are a list of filename extensions used
1976         for that filetype, such as ['jpg', 'jpeg'].
1977         """
1978         groupings = {}
1979         for ext, name in cls.filetypes.items():
1980             groupings.setdefault(name, []).append(ext)
1981             groupings[name].sort()
1982         return groupings
1983 
1984     @contextmanager
1985     def _switch_canvas_and_return_print_method(self, fmt, backend=None):
1986         """
1987         Context manager temporarily setting the canvas for saving the figure::
1988 
1989             with canvas._switch_canvas_and_return_print_method(fmt, backend) \\
1990                     as print_method:
1991                 # ``print_method`` is a suitable ``print_{fmt}`` method, and
1992                 # the figure's canvas is temporarily switched to the method's
1993                 # canvas within the with... block.  ``print_method`` is also
1994                 # wrapped to suppress extra kwargs passed by ``print_figure``.
1995 
1996         Parameters
1997         ----------
1998         fmt : str
1999             If *backend* is None, then determine a suitable canvas class for
2000             saving to format *fmt* -- either the current canvas class, if it
2001             supports *fmt*, or whatever `get_registered_canvas_class` returns;
2002             switch the figure canvas to that canvas class.
2003         backend : str or None, default: None
2004             If not None, switch the figure canvas to the ``FigureCanvas`` class
2005             of the given backend.
2006         """
2007         canvas = None
2008         if backend is not None:
2009             # Return a specific canvas class, if requested.
2010             canvas_class = (
2011                 importlib.import_module(cbook._backend_module_name(backend))
2012                 .FigureCanvas)
2013             if not hasattr(canvas_class, f"print_{fmt}"):
2014                 raise ValueError(
2015                     f"The {backend!r} backend does not support {fmt} output")
2016             canvas = canvas_class(self.figure)
2017         elif hasattr(self, f"print_{fmt}"):
2018             # Return the current canvas if it supports the requested format.
2019             canvas = self
2020         else:
2021             # Return a default canvas for the requested format, if it exists.
2022             canvas_class = get_registered_canvas_class(fmt)
2023             if canvas_class is None:
2024                 raise ValueError(
2025                     "Format {!r} is not supported (supported formats: {})".format(
2026                         fmt, ", ".join(sorted(self.get_supported_filetypes()))))
2027             canvas = canvas_class(self.figure)
2028         canvas._is_saving = self._is_saving
2029         meth = getattr(canvas, f"print_{fmt}")
2030         mod = (meth.func.__module__
2031                if hasattr(meth, "func")  # partialmethod, e.g. backend_wx.
2032                else meth.__module__)
2033         if mod.startswith(("matplotlib.", "mpl_toolkits.")):
2034             optional_kws = {  # Passed by print_figure for other renderers.
2035                 "dpi", "facecolor", "edgecolor", "orientation",
2036                 "bbox_inches_restore"}
2037             skip = optional_kws - {*inspect.signature(meth).parameters}
2038             print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(
2039                 *args, **{k: v for k, v in kwargs.items() if k not in skip}))
2040         else:  # Let third-parties do as they see fit.
2041             print_method = meth
2042         try:
2043             yield print_method
2044         finally:
2045             self.figure.canvas = self
2046 
2047     def print_figure(
2048             self, filename, dpi=None, facecolor=None, edgecolor=None,
2049             orientation='portrait', format=None, *,
2050             bbox_inches=None, pad_inches=None, bbox_extra_artists=None,
2051             backend=None, **kwargs):
2052         """
2053         Render the figure to hardcopy. Set the figure patch face and edge
2054         colors.  This is useful because some of the GUIs have a gray figure
2055         face color background and you'll probably want to override this on
2056         hardcopy.
2057 
2058         Parameters
2059         ----------
2060         filename : str or path-like or file-like
2061             The file where the figure is saved.
2062 
2063         dpi : float, default: :rc:`savefig.dpi`
2064             The dots per inch to save the figure in.
2065 
2066         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
2067             The facecolor of the figure.  If 'auto', use the current figure
2068             facecolor.
2069 
2070         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
2071             The edgecolor of the figure.  If 'auto', use the current figure
2072             edgecolor.
2073 
2074         orientation : {'landscape', 'portrait'}, default: 'portrait'
2075             Only currently applies to PostScript printing.
2076 
2077         format : str, optional
2078             Force a specific file format. If not given, the format is inferred
2079             from the *filename* extension, and if that fails from
2080             :rc:`savefig.format`.
2081 
2082         bbox_inches : 'tight' or `.Bbox`, default: :rc:`savefig.bbox`
2083             Bounding box in inches: only the given portion of the figure is
2084             saved.  If 'tight', try to figure out the tight bbox of the figure.
2085 
2086         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
2087             Amount of padding in inches around the figure when bbox_inches is
2088             'tight'. If 'layout' use the padding from the constrained or
2089             compressed layout engine; ignored if one of those engines is not in
2090             use.
2091 
2092         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2093             A list of extra artists that will be considered when the
2094             tight bbox is calculated.
2095 
2096         backend : str, optional
2097             Use a non-default backend to render the file, e.g. to render a
2098             png file with the "cairo" backend rather than the default "agg",
2099             or a pdf file with the "pgf" backend rather than the default
2100             "pdf".  Note that the default backend is normally sufficient.  See
2101             :ref:`the-builtin-backends` for a list of valid backends for each
2102             file format.  Custom backends can be referenced as "module://...".
2103         """
2104         if format is None:
2105             # get format from filename, or from backend's default filetype
2106             if isinstance(filename, os.PathLike):
2107                 filename = os.fspath(filename)
2108             if isinstance(filename, str):
2109                 format = os.path.splitext(filename)[1][1:]
2110             if format is None or format == '':
2111                 format = self.get_default_filetype()
2112                 if isinstance(filename, str):
2113                     filename = filename.rstrip('.') + '.' + format
2114         format = format.lower()
2115 
2116         if dpi is None:
2117             dpi = rcParams['savefig.dpi']
2118         if dpi == 'figure':
2119             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)
2120 
2121         # Remove the figure manager, if any, to avoid resizing the GUI widget.
2122         with cbook._setattr_cm(self, manager=None), \
2123              self._switch_canvas_and_return_print_method(format, backend) \
2124                  as print_method, \
2125              cbook._setattr_cm(self.figure, dpi=dpi), \
2126              cbook._setattr_cm(self.figure.canvas, _device_pixel_ratio=1), \
2127              cbook._setattr_cm(self.figure.canvas, _is_saving=True), \
2128              ExitStack() as stack:
2129 
2130             for prop in ["facecolor", "edgecolor"]:
2131                 color = locals()[prop]
2132                 if color is None:
2133                     color = rcParams[f"savefig.{prop}"]
2134                 if not cbook._str_equal(color, "auto"):
2135                     stack.enter_context(self.figure._cm_set(**{prop: color}))
2136 
2137             if bbox_inches is None:
2138                 bbox_inches = rcParams['savefig.bbox']
2139 
2140             layout_engine = self.figure.get_layout_engine()
2141             if layout_engine is not None or bbox_inches == "tight":
2142                 # we need to trigger a draw before printing to make sure
2143                 # CL works.  "tight" also needs a draw to get the right
2144                 # locations:
2145                 renderer = _get_renderer(
2146                     self.figure,
2147                     functools.partial(
2148                         print_method, orientation=orientation)
2149                 )
2150                 # we do this instead of `self.figure.draw_without_rendering`
2151                 # so that we can inject the orientation
2152                 with getattr(renderer, "_draw_disabled", nullcontext)():
2153                     self.figure.draw(renderer)
2154             if bbox_inches:
2155                 if bbox_inches == "tight":
2156                     bbox_inches = self.figure.get_tightbbox(
2157                         renderer, bbox_extra_artists=bbox_extra_artists)
2158                     if (isinstance(layout_engine, ConstrainedLayoutEngine) and
2159                             pad_inches == "layout"):
2160                         h_pad = layout_engine.get()["h_pad"]
2161                         w_pad = layout_engine.get()["w_pad"]
2162                     else:
2163                         if pad_inches in [None, "layout"]:
2164                             pad_inches = rcParams['savefig.pad_inches']
2165                         h_pad = w_pad = pad_inches
2166                     bbox_inches = bbox_inches.padded(w_pad, h_pad)
2167 
2168                 # call adjust_bbox to save only the given area
2169                 restore_bbox = _tight_bbox.adjust_bbox(
2170                     self.figure, bbox_inches, self.figure.canvas.fixed_dpi)
2171 
2172                 _bbox_inches_restore = (bbox_inches, restore_bbox)
2173             else:
2174                 _bbox_inches_restore = None
2175 
2176             # we have already done layout above, so turn it off:
2177             stack.enter_context(self.figure._cm_set(layout_engine='none'))
2178             try:
2179                 # _get_renderer may change the figure dpi (as vector formats
2180                 # force the figure dpi to 72), so we need to set it again here.
2181                 with cbook._setattr_cm(self.figure, dpi=dpi):
2182                     result = print_method(
2183                         filename,
2184                         facecolor=facecolor,
2185                         edgecolor=edgecolor,
2186                         orientation=orientation,
2187                         bbox_inches_restore=_bbox_inches_restore,
2188                         **kwargs)
2189             finally:
2190                 if bbox_inches and restore_bbox:
2191                     restore_bbox()
2192 
2193             return result
2194 
2195     @classmethod
2196     def get_default_filetype(cls):
2197         """
2198         Return the default savefig file format as specified in
2199         :rc:`savefig.format`.
2200 
2201         The returned string does not include a period. This method is
2202         overridden in backends that only support a single file type.
2203         """
2204         return rcParams['savefig.format']
2205 
2206     def get_default_filename(self):
2207         """
2208         Return a string, which includes extension, suitable for use as
2209         a default filename.
2210         """
2211         basename = (self.manager.get_window_title() if self.manager is not None
2212                     else '')
2213         basename = (basename or 'image').replace(' ', '_')
2214         filetype = self.get_default_filetype()
2215         filename = basename + '.' + filetype
2216         return filename
2217 
2218     @_api.deprecated("3.8")
2219     def switch_backends(self, FigureCanvasClass):
2220         """
2221         Instantiate an instance of FigureCanvasClass
2222 
2223         This is used for backend switching, e.g., to instantiate a
2224         FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is
2225         not done, so any changes to one of the instances (e.g., setting
2226         figure size or line props), will be reflected in the other
2227         """
2228         newCanvas = FigureCanvasClass(self.figure)
2229         newCanvas._is_saving = self._is_saving
2230         return newCanvas
2231 
2232     def mpl_connect(self, s, func):
2233         """
2234         Bind function *func* to event *s*.
2235 
2236         Parameters
2237         ----------
2238         s : str
2239             One of the following events ids:
2240 
2241             - 'button_press_event'
2242             - 'button_release_event'
2243             - 'draw_event'
2244             - 'key_press_event'
2245             - 'key_release_event'
2246             - 'motion_notify_event'
2247             - 'pick_event'
2248             - 'resize_event'
2249             - 'scroll_event'
2250             - 'figure_enter_event',
2251             - 'figure_leave_event',
2252             - 'axes_enter_event',
2253             - 'axes_leave_event'
2254             - 'close_event'.
2255 
2256         func : callable
2257             The callback function to be executed, which must have the
2258             signature::
2259 
2260                 def func(event: Event) -> Any
2261 
2262             For the location events (button and key press/release), if the
2263             mouse is over the Axes, the ``inaxes`` attribute of the event will
2264             be set to the `~matplotlib.axes.Axes` the event occurs is over, and
2265             additionally, the variables ``xdata`` and ``ydata`` attributes will
2266             be set to the mouse location in data coordinates.  See `.KeyEvent`
2267             and `.MouseEvent` for more info.
2268 
2269             .. note::
2270 
2271                 If func is a method, this only stores a weak reference to the
2272                 method. Thus, the figure does not influence the lifetime of
2273                 the associated object. Usually, you want to make sure that the
2274                 object is kept alive throughout the lifetime of the figure by
2275                 holding a reference to it.
2276 
2277         Returns
2278         -------
2279         cid
2280             A connection id that can be used with
2281             `.FigureCanvasBase.mpl_disconnect`.
2282 
2283         Examples
2284         --------
2285         ::
2286 
2287             def on_press(event):
2288                 print('you pressed', event.button, event.xdata, event.ydata)
2289 
2290             cid = canvas.mpl_connect('button_press_event', on_press)
2291         """
2292 
2293         return self.callbacks.connect(s, func)
2294 
2295     def mpl_disconnect(self, cid):
2296         """
2297         Disconnect the callback with id *cid*.
2298 
2299         Examples
2300         --------
2301         ::
2302 
2303             cid = canvas.mpl_connect('button_press_event', on_press)
2304             # ... later
2305             canvas.mpl_disconnect(cid)
2306         """
2307         self.callbacks.disconnect(cid)
2308 
2309     # Internal subclasses can override _timer_cls instead of new_timer, though
2310     # this is not a public API for third-party subclasses.
2311     _timer_cls = TimerBase
2312 
2313     def new_timer(self, interval=None, callbacks=None):
2314         """
2315         Create a new backend-specific subclass of `.Timer`.
2316 
2317         This is useful for getting periodic events through the backend's native
2318         event loop.  Implemented only for backends with GUIs.
2319 
2320         Parameters
2321         ----------
2322         interval : int
2323             Timer interval in milliseconds.
2324 
2325         callbacks : list[tuple[callable, tuple, dict]]
2326             Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``
2327             will be executed by the timer every *interval*.
2328 
2329             Callbacks which return ``False`` or ``0`` will be removed from the
2330             timer.
2331 
2332         Examples
2333         --------
2334         >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1,), {'a': 3})])
2335         """
2336         return self._timer_cls(interval=interval, callbacks=callbacks)
2337 
2338     def flush_events(self):
2339         """
2340         Flush the GUI events for the figure.
2341 
2342         Interactive backends need to reimplement this method.
2343         """
2344 
2345     def start_event_loop(self, timeout=0):
2346         """
2347         Start a blocking event loop.
2348 
2349         Such an event loop is used by interactive functions, such as
2350         `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for
2351         events.
2352 
2353         The event loop blocks until a callback function triggers
2354         `stop_event_loop`, or *timeout* is reached.
2355 
2356         If *timeout* is 0 or negative, never timeout.
2357 
2358         Only interactive backends need to reimplement this method and it relies
2359         on `flush_events` being properly implemented.
2360 
2361         Interactive backends should implement this in a more native way.
2362         """
2363         if timeout <= 0:
2364             timeout = np.inf
2365         timestep = 0.01
2366         counter = 0
2367         self._looping = True
2368         while self._looping and counter * timestep < timeout:
2369             self.flush_events()
2370             time.sleep(timestep)
2371             counter += 1
2372 
2373     def stop_event_loop(self):
2374         """
2375         Stop the current blocking event loop.
2376 
2377         Interactive backends need to reimplement this to match
2378         `start_event_loop`
2379         """
2380         self._looping = False
2381 
2382 
2383 def key_press_handler(event, canvas=None, toolbar=None):
2384     """
2385     Implement the default Matplotlib key bindings for the canvas and toolbar
2386     described at :ref:`key-event-handling`.
2387 
2388     Parameters
2389     ----------
2390     event : `KeyEvent`
2391         A key press/release event.
2392     canvas : `FigureCanvasBase`, default: ``event.canvas``
2393         The backend-specific canvas instance.  This parameter is kept for
2394         back-compatibility, but, if set, should always be equal to
2395         ``event.canvas``.
2396     toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``
2397         The navigation cursor toolbar.  This parameter is kept for
2398         back-compatibility, but, if set, should always be equal to
2399         ``event.canvas.toolbar``.
2400     """
2401     # these bindings happen whether you are over an Axes or not
2402 
2403     if event.key is None:
2404         return
2405     if canvas is None:
2406         canvas = event.canvas
2407     if toolbar is None:
2408         toolbar = canvas.toolbar
2409 
2410     # Load key-mappings from rcParams.
2411     fullscreen_keys = rcParams['keymap.fullscreen']
2412     home_keys = rcParams['keymap.home']
2413     back_keys = rcParams['keymap.back']
2414     forward_keys = rcParams['keymap.forward']
2415     pan_keys = rcParams['keymap.pan']
2416     zoom_keys = rcParams['keymap.zoom']
2417     save_keys = rcParams['keymap.save']
2418     quit_keys = rcParams['keymap.quit']
2419     quit_all_keys = rcParams['keymap.quit_all']
2420     grid_keys = rcParams['keymap.grid']
2421     grid_minor_keys = rcParams['keymap.grid_minor']
2422     toggle_yscale_keys = rcParams['keymap.yscale']
2423     toggle_xscale_keys = rcParams['keymap.xscale']
2424 
2425     # toggle fullscreen mode ('f', 'ctrl + f')
2426     if event.key in fullscreen_keys:
2427         try:
2428             canvas.manager.full_screen_toggle()
2429         except AttributeError:
2430             pass
2431 
2432     # quit the figure (default key 'ctrl+w')
2433     if event.key in quit_keys:
2434         Gcf.destroy_fig(canvas.figure)
2435     if event.key in quit_all_keys:
2436         Gcf.destroy_all()
2437 
2438     if toolbar is not None:
2439         # home or reset mnemonic  (default key 'h', 'home' and 'r')
2440         if event.key in home_keys:
2441             toolbar.home()
2442         # forward / backward keys to enable left handed quick navigation
2443         # (default key for backward: 'left', 'backspace' and 'c')
2444         elif event.key in back_keys:
2445             toolbar.back()
2446         # (default key for forward: 'right' and 'v')
2447         elif event.key in forward_keys:
2448             toolbar.forward()
2449         # pan mnemonic (default key 'p')
2450         elif event.key in pan_keys:
2451             toolbar.pan()
2452             toolbar._update_cursor(event)
2453         # zoom mnemonic (default key 'o')
2454         elif event.key in zoom_keys:
2455             toolbar.zoom()
2456             toolbar._update_cursor(event)
2457         # saving current figure (default key 's')
2458         elif event.key in save_keys:
2459             toolbar.save_figure()
2460 
2461     if event.inaxes is None:
2462         return
2463 
2464     # these bindings require the mouse to be over an Axes to trigger
2465     def _get_uniform_gridstate(ticks):
2466         # Return True/False if all grid lines are on or off, None if they are
2467         # not all in the same state.
2468         if all(tick.gridline.get_visible() for tick in ticks):
2469             return True
2470         elif not any(tick.gridline.get_visible() for tick in ticks):
2471             return False
2472         else:
2473             return None
2474 
2475     ax = event.inaxes
2476     # toggle major grids in current Axes (default key 'g')
2477     # Both here and below (for 'G'), we do nothing if *any* grid (major or
2478     # minor, x or y) is not in a uniform state, to avoid messing up user
2479     # customization.
2480     if (event.key in grid_keys
2481             # Exclude minor grids not in a uniform state.
2482             and None not in [_get_uniform_gridstate(ax.xaxis.minorTicks),
2483                              _get_uniform_gridstate(ax.yaxis.minorTicks)]):
2484         x_state = _get_uniform_gridstate(ax.xaxis.majorTicks)
2485         y_state = _get_uniform_gridstate(ax.yaxis.majorTicks)
2486         cycle = [(False, False), (True, False), (True, True), (False, True)]
2487         try:
2488             x_state, y_state = (
2489                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])
2490         except ValueError:
2491             # Exclude major grids not in a uniform state.
2492             pass
2493         else:
2494             # If turning major grids off, also turn minor grids off.
2495             ax.grid(x_state, which="major" if x_state else "both", axis="x")
2496             ax.grid(y_state, which="major" if y_state else "both", axis="y")
2497             canvas.draw_idle()
2498     # toggle major and minor grids in current Axes (default key 'G')
2499     if (event.key in grid_minor_keys
2500             # Exclude major grids not in a uniform state.
2501             and None not in [_get_uniform_gridstate(ax.xaxis.majorTicks),
2502                              _get_uniform_gridstate(ax.yaxis.majorTicks)]):
2503         x_state = _get_uniform_gridstate(ax.xaxis.minorTicks)
2504         y_state = _get_uniform_gridstate(ax.yaxis.minorTicks)
2505         cycle = [(False, False), (True, False), (True, True), (False, True)]
2506         try:
2507             x_state, y_state = (
2508                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])
2509         except ValueError:
2510             # Exclude minor grids not in a uniform state.
2511             pass
2512         else:
2513             ax.grid(x_state, which="both", axis="x")
2514             ax.grid(y_state, which="both", axis="y")
2515             canvas.draw_idle()
2516     # toggle scaling of y-axes between 'log and 'linear' (default key 'l')
2517     elif event.key in toggle_yscale_keys:
2518         scale = ax.get_yscale()
2519         if scale == 'log':
2520             ax.set_yscale('linear')
2521             ax.figure.canvas.draw_idle()
2522         elif scale == 'linear':
2523             try:
2524                 ax.set_yscale('log')
2525             except ValueError as exc:
2526                 _log.warning(str(exc))
2527                 ax.set_yscale('linear')
2528             ax.figure.canvas.draw_idle()
2529     # toggle scaling of x-axes between 'log and 'linear' (default key 'k')
2530     elif event.key in toggle_xscale_keys:
2531         scalex = ax.get_xscale()
2532         if scalex == 'log':
2533             ax.set_xscale('linear')
2534             ax.figure.canvas.draw_idle()
2535         elif scalex == 'linear':
2536             try:
2537                 ax.set_xscale('log')
2538             except ValueError as exc:
2539                 _log.warning(str(exc))
2540                 ax.set_xscale('linear')
2541             ax.figure.canvas.draw_idle()
2542 
2543 
2544 def button_press_handler(event, canvas=None, toolbar=None):
2545     """
2546     The default Matplotlib button actions for extra mouse buttons.
2547 
2548     Parameters are as for `key_press_handler`, except that *event* is a
2549     `MouseEvent`.
2550     """
2551     if canvas is None:
2552         canvas = event.canvas
2553     if toolbar is None:
2554         toolbar = canvas.toolbar
2555     if toolbar is not None:
2556         button_name = str(MouseButton(event.button))
2557         if button_name in rcParams['keymap.back']:
2558             toolbar.back()
2559         elif button_name in rcParams['keymap.forward']:
2560             toolbar.forward()
2561 
2562 
2563 class NonGuiException(Exception):
2564     """Raised when trying show a figure in a non-GUI backend."""
2565     pass
2566 
2567 
2568 class FigureManagerBase:
2569     """
2570     A backend-independent abstraction of a figure container and controller.
2571 
2572     The figure manager is used by pyplot to interact with the window in a
2573     backend-independent way. It's an adapter for the real (GUI) framework that
2574     represents the visual figure on screen.
2575 
2576     GUI backends define from this class to translate common operations such
2577     as *show* or *resize* to the GUI-specific code. Non-GUI backends do not
2578     support these operations an can just use the base class.
2579 
2580     This following basic operations are accessible:
2581 
2582     **Window operations**
2583 
2584     - `~.FigureManagerBase.show`
2585     - `~.FigureManagerBase.destroy`
2586     - `~.FigureManagerBase.full_screen_toggle`
2587     - `~.FigureManagerBase.resize`
2588     - `~.FigureManagerBase.get_window_title`
2589     - `~.FigureManagerBase.set_window_title`
2590 
2591     **Key and mouse button press handling**
2592 
2593     The figure manager sets up default key and mouse button press handling by
2594     hooking up the `.key_press_handler` to the matplotlib event system. This
2595     ensures the same shortcuts and mouse actions across backends.
2596 
2597     **Other operations**
2598 
2599     Subclasses will have additional attributes and functions to access
2600     additional functionality. This is of course backend-specific. For example,
2601     most GUI backends have ``window`` and ``toolbar`` attributes that give
2602     access to the native GUI widgets of the respective framework.
2603 
2604     Attributes
2605     ----------
2606     canvas : `FigureCanvasBase`
2607         The backend-specific canvas instance.
2608 
2609     num : int or str
2610         The figure number.
2611 
2612     key_press_handler_id : int
2613         The default key handler cid, when using the toolmanager.
2614         To disable the default key press handling use::
2615 
2616             figure.canvas.mpl_disconnect(
2617                 figure.canvas.manager.key_press_handler_id)
2618 
2619     button_press_handler_id : int
2620         The default mouse button handler cid, when using the toolmanager.
2621         To disable the default button press handling use::
2622 
2623             figure.canvas.mpl_disconnect(
2624                 figure.canvas.manager.button_press_handler_id)
2625     """
2626 
2627     _toolbar2_class = None
2628     _toolmanager_toolbar_class = None
2629 
2630     def __init__(self, canvas, num):
2631         self.canvas = canvas
2632         canvas.manager = self  # store a pointer to parent
2633         self.num = num
2634         self.set_window_title(f"Figure {num:d}")
2635 
2636         self.key_press_handler_id = None
2637         self.button_press_handler_id = None
2638         if rcParams['toolbar'] != 'toolmanager':
2639             self.key_press_handler_id = self.canvas.mpl_connect(
2640                 'key_press_event', key_press_handler)
2641             self.button_press_handler_id = self.canvas.mpl_connect(
2642                 'button_press_event', button_press_handler)
2643 
2644         self.toolmanager = (ToolManager(canvas.figure)
2645                             if mpl.rcParams['toolbar'] == 'toolmanager'
2646                             else None)
2647         if (mpl.rcParams["toolbar"] == "toolbar2"
2648                 and self._toolbar2_class):
2649             self.toolbar = self._toolbar2_class(self.canvas)
2650         elif (mpl.rcParams["toolbar"] == "toolmanager"
2651                 and self._toolmanager_toolbar_class):
2652             self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)
2653         else:
2654             self.toolbar = None
2655 
2656         if self.toolmanager:
2657             tools.add_tools_to_manager(self.toolmanager)
2658             if self.toolbar:
2659                 tools.add_tools_to_container(self.toolbar)
2660 
2661         @self.canvas.figure.add_axobserver
2662         def notify_axes_change(fig):
2663             # Called whenever the current Axes is changed.
2664             if self.toolmanager is None and self.toolbar is not None:
2665                 self.toolbar.update()
2666 
2667     @classmethod
2668     def create_with_canvas(cls, canvas_class, figure, num):
2669         """
2670         Create a manager for a given *figure* using a specific *canvas_class*.
2671 
2672         Backends should override this method if they have specific needs for
2673         setting up the canvas or the manager.
2674         """
2675         return cls(canvas_class(figure), num)
2676 
2677     @classmethod
2678     def start_main_loop(cls):
2679         """
2680         Start the main event loop.
2681 
2682         This method is called by `.FigureManagerBase.pyplot_show`, which is the
2683         implementation of `.pyplot.show`.  To customize the behavior of
2684         `.pyplot.show`, interactive backends should usually override
2685         `~.FigureManagerBase.start_main_loop`; if more customized logic is
2686         necessary, `~.FigureManagerBase.pyplot_show` can also be overridden.
2687         """
2688 
2689     @classmethod
2690     def pyplot_show(cls, *, block=None):
2691         """
2692         Show all figures.  This method is the implementation of `.pyplot.show`.
2693 
2694         To customize the behavior of `.pyplot.show`, interactive backends
2695         should usually override `~.FigureManagerBase.start_main_loop`; if more
2696         customized logic is necessary, `~.FigureManagerBase.pyplot_show` can
2697         also be overridden.
2698 
2699         Parameters
2700         ----------
2701         block : bool, optional
2702             Whether to block by calling ``start_main_loop``.  The default,
2703             None, means to block if we are neither in IPython's ``%pylab`` mode
2704             nor in ``interactive`` mode.
2705         """
2706         managers = Gcf.get_all_fig_managers()
2707         if not managers:
2708             return
2709         for manager in managers:
2710             try:
2711                 manager.show()  # Emits a warning for non-interactive backend.
2712             except NonGuiException as exc:
2713                 _api.warn_external(str(exc))
2714         if block is None:
2715             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython
2716             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always
2717             # set to False).
2718             pyplot_show = getattr(sys.modules.get("matplotlib.pyplot"), "show", None)
2719             ipython_pylab = hasattr(pyplot_show, "_needmain")
2720             block = not ipython_pylab and not is_interactive()
2721         if block:
2722             cls.start_main_loop()
2723 
2724     def show(self):
2725         """
2726         For GUI backends, show the figure window and redraw.
2727         For non-GUI backends, raise an exception, unless running headless (i.e.
2728         on Linux with an unset DISPLAY); this exception is converted to a
2729         warning in `.Figure.show`.
2730         """
2731         # This should be overridden in GUI backends.
2732         if sys.platform == "linux" and not os.environ.get("DISPLAY"):
2733             # We cannot check _get_running_interactive_framework() ==
2734             # "headless" because that would also suppress the warning when
2735             # $DISPLAY exists but is invalid, which is more likely an error and
2736             # thus warrants a warning.
2737             return
2738         raise NonGuiException(
2739             f"Matplotlib is currently using {get_backend()}, which is a "
2740             f"non-GUI backend, so cannot show the figure.")
2741 
2742     def destroy(self):
2743         pass
2744 
2745     def full_screen_toggle(self):
2746         pass
2747 
2748     def resize(self, w, h):
2749         """For GUI backends, resize the window (in physical pixels)."""
2750 
2751     def get_window_title(self):
2752         """
2753         Return the title text of the window containing the figure, or None
2754         if there is no window (e.g., a PS backend).
2755         """
2756         return 'image'
2757 
2758     def set_window_title(self, title):
2759         """
2760         Set the title text of the window containing the figure.
2761 
2762         This has no effect for non-GUI (e.g., PS) backends.
2763         """
2764 
2765 
2766 cursors = tools.cursors
2767 
2768 
2769 class _Mode(str, Enum):
2770     NONE = ""
2771     PAN = "pan/zoom"
2772     ZOOM = "zoom rect"
2773 
2774     def __str__(self):
2775         return self.value
2776 
2777     @property
2778     def _navigate_mode(self):
2779         return self.name if self is not _Mode.NONE else None
2780 
2781 
2782 class NavigationToolbar2:
2783     """
2784     Base class for the navigation cursor, version 2.
2785 
2786     Backends must implement a canvas that handles connections for
2787     'button_press_event' and 'button_release_event'.  See
2788     :meth:`FigureCanvasBase.mpl_connect` for more information.
2789 
2790     They must also define
2791 
2792     :meth:`save_figure`
2793         Save the current figure.
2794 
2795     :meth:`draw_rubberband` (optional)
2796         Draw the zoom to rect "rubberband" rectangle.
2797 
2798     :meth:`set_message` (optional)
2799         Display message.
2800 
2801     :meth:`set_history_buttons` (optional)
2802         You can change the history back / forward buttons to indicate disabled / enabled
2803         state.
2804 
2805     and override ``__init__`` to set up the toolbar -- without forgetting to
2806     call the base-class init.  Typically, ``__init__`` needs to set up toolbar
2807     buttons connected to the `home`, `back`, `forward`, `pan`, `zoom`, and
2808     `save_figure` methods and using standard icons in the "images" subdirectory
2809     of the data path.
2810 
2811     That's it, we'll do the rest!
2812     """
2813 
2814     # list of toolitems to add to the toolbar, format is:
2815     # (
2816     #   text, # the text of the button (often not visible to users)
2817     #   tooltip_text, # the tooltip shown on hover (where possible)
2818     #   image_file, # name of the image for the button (without the extension)
2819     #   name_of_method, # name of the method in NavigationToolbar2 to call
2820     # )
2821     toolitems = (
2822         ('Home', 'Reset original view', 'home', 'home'),
2823         ('Back', 'Back to previous view', 'back', 'back'),
2824         ('Forward', 'Forward to next view', 'forward', 'forward'),
2825         (None, None, None, None),
2826         ('Pan',
2827          'Left button pans, Right button zooms\n'
2828          'x/y fixes axis, CTRL fixes aspect',
2829          'move', 'pan'),
2830         ('Zoom', 'Zoom to rectangle\nx/y fixes axis', 'zoom_to_rect', 'zoom'),
2831         ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'),
2832         (None, None, None, None),
2833         ('Save', 'Save the figure', 'filesave', 'save_figure'),
2834       )
2835 
2836     def __init__(self, canvas):
2837         self.canvas = canvas
2838         canvas.toolbar = self
2839         self._nav_stack = cbook._Stack()
2840         # This cursor will be set after the initial draw.
2841         self._last_cursor = tools.Cursors.POINTER
2842 
2843         self._id_press = self.canvas.mpl_connect(
2844             'button_press_event', self._zoom_pan_handler)
2845         self._id_release = self.canvas.mpl_connect(
2846             'button_release_event', self._zoom_pan_handler)
2847         self._id_drag = self.canvas.mpl_connect(
2848             'motion_notify_event', self.mouse_move)
2849         self._pan_info = None
2850         self._zoom_info = None
2851 
2852         self.mode = _Mode.NONE  # a mode string for the status bar
2853         self.set_history_buttons()
2854 
2855     def set_message(self, s):
2856         """Display a message on toolbar or in status bar."""
2857 
2858     def draw_rubberband(self, event, x0, y0, x1, y1):
2859         """
2860         Draw a rectangle rubberband to indicate zoom limits.
2861 
2862         Note that it is not guaranteed that ``x0 <= x1`` and ``y0 <= y1``.
2863         """
2864 
2865     def remove_rubberband(self):
2866         """Remove the rubberband."""
2867 
2868     def home(self, *args):
2869         """
2870         Restore the original view.
2871 
2872         For convenience of being directly connected as a GUI callback, which
2873         often get passed additional parameters, this method accepts arbitrary
2874         parameters, but does not use them.
2875         """
2876         self._nav_stack.home()
2877         self.set_history_buttons()
2878         self._update_view()
2879 
2880     def back(self, *args):
2881         """
2882         Move back up the view lim stack.
2883 
2884         For convenience of being directly connected as a GUI callback, which
2885         often get passed additional parameters, this method accepts arbitrary
2886         parameters, but does not use them.
2887         """
2888         self._nav_stack.back()
2889         self.set_history_buttons()
2890         self._update_view()
2891 
2892     def forward(self, *args):
2893         """
2894         Move forward in the view lim stack.
2895 
2896         For convenience of being directly connected as a GUI callback, which
2897         often get passed additional parameters, this method accepts arbitrary
2898         parameters, but does not use them.
2899         """
2900         self._nav_stack.forward()
2901         self.set_history_buttons()
2902         self._update_view()
2903 
2904     def _update_cursor(self, event):
2905         """
2906         Update the cursor after a mouse move event or a tool (de)activation.
2907         """
2908         if self.mode and event.inaxes and event.inaxes.get_navigate():
2909             if (self.mode == _Mode.ZOOM
2910                     and self._last_cursor != tools.Cursors.SELECT_REGION):
2911                 self.canvas.set_cursor(tools.Cursors.SELECT_REGION)
2912                 self._last_cursor = tools.Cursors.SELECT_REGION
2913             elif (self.mode == _Mode.PAN
2914                   and self._last_cursor != tools.Cursors.MOVE):
2915                 self.canvas.set_cursor(tools.Cursors.MOVE)
2916                 self._last_cursor = tools.Cursors.MOVE
2917         elif self._last_cursor != tools.Cursors.POINTER:
2918             self.canvas.set_cursor(tools.Cursors.POINTER)
2919             self._last_cursor = tools.Cursors.POINTER
2920 
2921     @contextmanager
2922     def _wait_cursor_for_draw_cm(self):
2923         """
2924         Set the cursor to a wait cursor when drawing the canvas.
2925 
2926         In order to avoid constantly changing the cursor when the canvas
2927         changes frequently, do nothing if this context was triggered during the
2928         last second.  (Optimally we'd prefer only setting the wait cursor if
2929         the *current* draw takes too long, but the current draw blocks the GUI
2930         thread).
2931         """
2932         self._draw_time, last_draw_time = (
2933             time.time(), getattr(self, "_draw_time", -np.inf))
2934         if self._draw_time - last_draw_time > 1:
2935             try:
2936                 self.canvas.set_cursor(tools.Cursors.WAIT)
2937                 yield
2938             finally:
2939                 self.canvas.set_cursor(self._last_cursor)
2940         else:
2941             yield
2942 
2943     @staticmethod
2944     def _mouse_event_to_message(event):
2945         if event.inaxes and event.inaxes.get_navigate():
2946             try:
2947                 s = event.inaxes.format_coord(event.xdata, event.ydata)
2948             except (ValueError, OverflowError):
2949                 pass
2950             else:
2951                 s = s.rstrip()
2952                 artists = [a for a in event.inaxes._mouseover_set
2953                            if a.contains(event)[0] and a.get_visible()]
2954                 if artists:
2955                     a = cbook._topmost_artist(artists)
2956                     if a is not event.inaxes.patch:
2957                         data = a.get_cursor_data(event)
2958                         if data is not None:
2959                             data_str = a.format_cursor_data(data).rstrip()
2960                             if data_str:
2961                                 s = s + '\n' + data_str
2962                 return s
2963         return ""
2964 
2965     def mouse_move(self, event):
2966         self._update_cursor(event)
2967         self.set_message(self._mouse_event_to_message(event))
2968 
2969     def _zoom_pan_handler(self, event):
2970         if self.mode == _Mode.PAN:
2971             if event.name == "button_press_event":
2972                 self.press_pan(event)
2973             elif event.name == "button_release_event":
2974                 self.release_pan(event)
2975         if self.mode == _Mode.ZOOM:
2976             if event.name == "button_press_event":
2977                 self.press_zoom(event)
2978             elif event.name == "button_release_event":
2979                 self.release_zoom(event)
2980 
2981     def pan(self, *args):
2982         """
2983         Toggle the pan/zoom tool.
2984 
2985         Pan with left button, zoom with right.
2986         """
2987         if not self.canvas.widgetlock.available(self):
2988             self.set_message("pan unavailable")
2989             return
2990         if self.mode == _Mode.PAN:
2991             self.mode = _Mode.NONE
2992             self.canvas.widgetlock.release(self)
2993         else:
2994             self.mode = _Mode.PAN
2995             self.canvas.widgetlock(self)
2996         for a in self.canvas.figure.get_axes():
2997             a.set_navigate_mode(self.mode._navigate_mode)
2998 
2999     _PanInfo = namedtuple("_PanInfo", "button axes cid")
3000 
3001     def press_pan(self, event):
3002         """Callback for mouse button press in pan/zoom mode."""
3003         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]
3004                 or event.x is None or event.y is None):
3005             return
3006         axes = [a for a in self.canvas.figure.get_axes()
3007                 if a.in_axes(event) and a.get_navigate() and a.can_pan()]
3008         if not axes:
3009             return
3010         if self._nav_stack() is None:
3011             self.push_current()  # set the home button to this view
3012         for ax in axes:
3013             ax.start_pan(event.x, event.y, event.button)
3014         self.canvas.mpl_disconnect(self._id_drag)
3015         id_drag = self.canvas.mpl_connect("motion_notify_event", self.drag_pan)
3016         self._pan_info = self._PanInfo(
3017             button=event.button, axes=axes, cid=id_drag)
3018 
3019     def drag_pan(self, event):
3020         """Callback for dragging in pan/zoom mode."""
3021         for ax in self._pan_info.axes:
3022             # Using the recorded button at the press is safer than the current
3023             # button, as multiple buttons can get pressed during motion.
3024             ax.drag_pan(self._pan_info.button, event.key, event.x, event.y)
3025         self.canvas.draw_idle()
3026 
3027     def release_pan(self, event):
3028         """Callback for mouse button release in pan/zoom mode."""
3029         if self._pan_info is None:
3030             return
3031         self.canvas.mpl_disconnect(self._pan_info.cid)
3032         self._id_drag = self.canvas.mpl_connect(
3033             'motion_notify_event', self.mouse_move)
3034         for ax in self._pan_info.axes:
3035             ax.end_pan()
3036         self.canvas.draw_idle()
3037         self._pan_info = None
3038         self.push_current()
3039 
3040     def zoom(self, *args):
3041         if not self.canvas.widgetlock.available(self):
3042             self.set_message("zoom unavailable")
3043             return
3044         """Toggle zoom to rect mode."""
3045         if self.mode == _Mode.ZOOM:
3046             self.mode = _Mode.NONE
3047             self.canvas.widgetlock.release(self)
3048         else:
3049             self.mode = _Mode.ZOOM
3050             self.canvas.widgetlock(self)
3051         for a in self.canvas.figure.get_axes():
3052             a.set_navigate_mode(self.mode._navigate_mode)
3053 
3054     _ZoomInfo = namedtuple("_ZoomInfo", "direction start_xy axes cid cbar")
3055 
3056     def press_zoom(self, event):
3057         """Callback for mouse button press in zoom to rect mode."""
3058         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]
3059                 or event.x is None or event.y is None):
3060             return
3061         axes = [a for a in self.canvas.figure.get_axes()
3062                 if a.in_axes(event) and a.get_navigate() and a.can_zoom()]
3063         if not axes:
3064             return
3065         if self._nav_stack() is None:
3066             self.push_current()  # set the home button to this view
3067         id_zoom = self.canvas.mpl_connect(
3068             "motion_notify_event", self.drag_zoom)
3069         # A colorbar is one-dimensional, so we extend the zoom rectangle out
3070         # to the edge of the Axes bbox in the other dimension. To do that we
3071         # store the orientation of the colorbar for later.
3072         if hasattr(axes[0], "_colorbar"):
3073             cbar = axes[0]._colorbar.orientation
3074         else:
3075             cbar = None
3076         self._zoom_info = self._ZoomInfo(
3077             direction="in" if event.button == 1 else "out",
3078             start_xy=(event.x, event.y), axes=axes, cid=id_zoom, cbar=cbar)
3079 
3080     def drag_zoom(self, event):
3081         """Callback for dragging in zoom mode."""
3082         start_xy = self._zoom_info.start_xy
3083         ax = self._zoom_info.axes[0]
3084         (x1, y1), (x2, y2) = np.clip(
3085             [start_xy, [event.x, event.y]], ax.bbox.min, ax.bbox.max)
3086         key = event.key
3087         # Force the key on colorbars to extend the short-axis bbox
3088         if self._zoom_info.cbar == "horizontal":
3089             key = "x"
3090         elif self._zoom_info.cbar == "vertical":
3091             key = "y"
3092         if key == "x":
3093             y1, y2 = ax.bbox.intervaly
3094         elif key == "y":
3095             x1, x2 = ax.bbox.intervalx
3096 
3097         self.draw_rubberband(event, x1, y1, x2, y2)
3098 
3099     def release_zoom(self, event):
3100         """Callback for mouse button release in zoom to rect mode."""
3101         if self._zoom_info is None:
3102             return
3103 
3104         # We don't check the event button here, so that zooms can be cancelled
3105         # by (pressing and) releasing another mouse button.
3106         self.canvas.mpl_disconnect(self._zoom_info.cid)
3107         self.remove_rubberband()
3108 
3109         start_x, start_y = self._zoom_info.start_xy
3110         key = event.key
3111         # Force the key on colorbars to ignore the zoom-cancel on the
3112         # short-axis side
3113         if self._zoom_info.cbar == "horizontal":
3114             key = "x"
3115         elif self._zoom_info.cbar == "vertical":
3116             key = "y"
3117         # Ignore single clicks: 5 pixels is a threshold that allows the user to
3118         # "cancel" a zoom action by zooming by less than 5 pixels.
3119         if ((abs(event.x - start_x) < 5 and key != "y") or
3120                 (abs(event.y - start_y) < 5 and key != "x")):
3121             self.canvas.draw_idle()
3122             self._zoom_info = None
3123             return
3124 
3125         for i, ax in enumerate(self._zoom_info.axes):
3126             # Detect whether this Axes is twinned with an earlier Axes in the
3127             # list of zoomed Axes, to avoid double zooming.
3128             twinx = any(ax.get_shared_x_axes().joined(ax, prev)
3129                         for prev in self._zoom_info.axes[:i])
3130             twiny = any(ax.get_shared_y_axes().joined(ax, prev)
3131                         for prev in self._zoom_info.axes[:i])
3132             ax._set_view_from_bbox(
3133                 (start_x, start_y, event.x, event.y),
3134                 self._zoom_info.direction, key, twinx, twiny)
3135 
3136         self.canvas.draw_idle()
3137         self._zoom_info = None
3138         self.push_current()
3139 
3140     def push_current(self):
3141         """Push the current view limits and position onto the stack."""
3142         self._nav_stack.push(
3143             WeakKeyDictionary(
3144                 {ax: (ax._get_view(),
3145                       # Store both the original and modified positions.
3146                       (ax.get_position(True).frozen(),
3147                        ax.get_position().frozen()))
3148                  for ax in self.canvas.figure.axes}))
3149         self.set_history_buttons()
3150 
3151     def _update_view(self):
3152         """
3153         Update the viewlim and position from the view and position stack for
3154         each Axes.
3155         """
3156         nav_info = self._nav_stack()
3157         if nav_info is None:
3158             return
3159         # Retrieve all items at once to avoid any risk of GC deleting an Axes
3160         # while in the middle of the loop below.
3161         items = list(nav_info.items())
3162         for ax, (view, (pos_orig, pos_active)) in items:
3163             ax._set_view(view)
3164             # Restore both the original and modified positions
3165             ax._set_position(pos_orig, 'original')
3166             ax._set_position(pos_active, 'active')
3167         self.canvas.draw_idle()
3168 
3169     def configure_subplots(self, *args):
3170         if hasattr(self, "subplot_tool"):
3171             self.subplot_tool.figure.canvas.manager.show()
3172             return
3173         # This import needs to happen here due to circular imports.
3174         from matplotlib.figure import Figure
3175         with mpl.rc_context({"toolbar": "none"}):  # No navbar for the toolfig.
3176             manager = type(self.canvas).new_manager(Figure(figsize=(6, 3)), -1)
3177         manager.set_window_title("Subplot configuration tool")
3178         tool_fig = manager.canvas.figure
3179         tool_fig.subplots_adjust(top=0.9)
3180         self.subplot_tool = widgets.SubplotTool(self.canvas.figure, tool_fig)
3181         cid = self.canvas.mpl_connect(
3182             "close_event", lambda e: manager.destroy())
3183 
3184         def on_tool_fig_close(e):
3185             self.canvas.mpl_disconnect(cid)
3186             del self.subplot_tool
3187 
3188         tool_fig.canvas.mpl_connect("close_event", on_tool_fig_close)
3189         manager.show()
3190         return self.subplot_tool
3191 
3192     def save_figure(self, *args):
3193         """Save the current figure."""
3194         raise NotImplementedError
3195 
3196     def update(self):
3197         """Reset the Axes stack."""
3198         self._nav_stack.clear()
3199         self.set_history_buttons()
3200 
3201     def set_history_buttons(self):
3202         """Enable or disable the back/forward button."""
3203 
3204 
3205 class ToolContainerBase:
3206     """
3207     Base class for all tool containers, e.g. toolbars.
3208 
3209     Attributes
3210     ----------
3211     toolmanager : `.ToolManager`
3212         The tools with which this `ToolContainer` wants to communicate.
3213     """
3214 
3215     _icon_extension = '.png'
3216     """
3217     Toolcontainer button icon image format extension
3218 
3219     **String**: Image extension
3220     """
3221 
3222     def __init__(self, toolmanager):
3223         self.toolmanager = toolmanager
3224         toolmanager.toolmanager_connect(
3225             'tool_message_event',
3226             lambda event: self.set_message(event.message))
3227         toolmanager.toolmanager_connect(
3228             'tool_removed_event',
3229             lambda event: self.remove_toolitem(event.tool.name))
3230 
3231     def _tool_toggled_cbk(self, event):
3232         """
3233         Capture the 'tool_trigger_[name]'
3234 
3235         This only gets used for toggled tools.
3236         """
3237         self.toggle_toolitem(event.tool.name, event.tool.toggled)
3238 
3239     def add_tool(self, tool, group, position=-1):
3240         """
3241         Add a tool to this container.
3242 
3243         Parameters
3244         ----------
3245         tool : tool_like
3246             The tool to add, see `.ToolManager.get_tool`.
3247         group : str
3248             The name of the group to add this tool to.
3249         position : int, default: -1
3250             The position within the group to place this tool.
3251         """
3252         tool = self.toolmanager.get_tool(tool)
3253         image = self._get_image_filename(tool.image)
3254         toggle = getattr(tool, 'toggled', None) is not None
3255         self.add_toolitem(tool.name, group, position,
3256                           image, tool.description, toggle)
3257         if toggle:
3258             self.toolmanager.toolmanager_connect('tool_trigger_%s' % tool.name,
3259                                                  self._tool_toggled_cbk)
3260             # If initially toggled
3261             if tool.toggled:
3262                 self.toggle_toolitem(tool.name, True)
3263 
3264     def _get_image_filename(self, image):
3265         """Find the image based on its name."""
3266         if not image:
3267             return None
3268 
3269         basedir = cbook._get_data_path("images")
3270         for fname in [
3271             image,
3272             image + self._icon_extension,
3273             str(basedir / image),
3274             str(basedir / (image + self._icon_extension)),
3275         ]:
3276             if os.path.isfile(fname):
3277                 return fname
3278 
3279     def trigger_tool(self, name):
3280         """
3281         Trigger the tool.
3282 
3283         Parameters
3284         ----------
3285         name : str
3286             Name (id) of the tool triggered from within the container.
3287         """
3288         self.toolmanager.trigger_tool(name, sender=self)
3289 
3290     def add_toolitem(self, name, group, position, image, description, toggle):
3291         """
3292         Add a toolitem to the container.
3293 
3294         This method must be implemented per backend.
3295 
3296         The callback associated with the button click event,
3297         must be *exactly* ``self.trigger_tool(name)``.
3298 
3299         Parameters
3300         ----------
3301         name : str
3302             Name of the tool to add, this gets used as the tool's ID and as the
3303             default label of the buttons.
3304         group : str
3305             Name of the group that this tool belongs to.
3306         position : int
3307             Position of the tool within its group, if -1 it goes at the end.
3308         image : str
3309             Filename of the image for the button or `None`.
3310         description : str
3311             Description of the tool, used for the tooltips.
3312         toggle : bool
3313             * `True` : The button is a toggle (change the pressed/unpressed
3314               state between consecutive clicks).
3315             * `False` : The button is a normal button (returns to unpressed
3316               state after release).
3317         """
3318         raise NotImplementedError
3319 
3320     def toggle_toolitem(self, name, toggled):
3321         """
3322         Toggle the toolitem without firing event.
3323 
3324         Parameters
3325         ----------
3326         name : str
3327             Id of the tool to toggle.
3328         toggled : bool
3329             Whether to set this tool as toggled or not.
3330         """
3331         raise NotImplementedError
3332 
3333     def remove_toolitem(self, name):
3334         """
3335         Remove a toolitem from the `ToolContainer`.
3336 
3337         This method must get implemented per backend.
3338 
3339         Called when `.ToolManager` emits a `tool_removed_event`.
3340 
3341         Parameters
3342         ----------
3343         name : str
3344             Name of the tool to remove.
3345         """
3346         raise NotImplementedError
3347 
3348     def set_message(self, s):
3349         """
3350         Display a message on the toolbar.
3351 
3352         Parameters
3353         ----------
3354         s : str
3355             Message text.
3356         """
3357         raise NotImplementedError
3358 
3359 
3360 class _Backend:
3361     # A backend can be defined by using the following pattern:
3362     #
3363     # @_Backend.export
3364     # class FooBackend(_Backend):
3365     #     # override the attributes and methods documented below.
3366 
3367     # `backend_version` may be overridden by the subclass.
3368     backend_version = "unknown"
3369 
3370     # The `FigureCanvas` class must be defined.
3371     FigureCanvas = None
3372 
3373     # For interactive backends, the `FigureManager` class must be overridden.
3374     FigureManager = FigureManagerBase
3375 
3376     # For interactive backends, `mainloop` should be a function taking no
3377     # argument and starting the backend main loop.  It should be left as None
3378     # for non-interactive backends.
3379     mainloop = None
3380 
3381     # The following methods will be automatically defined and exported, but
3382     # can be overridden.
3383 
3384     @classmethod
3385     def new_figure_manager(cls, num, *args, **kwargs):
3386         """Create a new figure manager instance."""
3387         # This import needs to happen here due to circular imports.
3388         from matplotlib.figure import Figure
3389         fig_cls = kwargs.pop('FigureClass', Figure)
3390         fig = fig_cls(*args, **kwargs)
3391         return cls.new_figure_manager_given_figure(num, fig)
3392 
3393     @classmethod
3394     def new_figure_manager_given_figure(cls, num, figure):
3395         """Create a new figure manager instance for the given figure."""
3396         return cls.FigureCanvas.new_manager(figure, num)
3397 
3398     @classmethod
3399     def draw_if_interactive(cls):
3400         manager_class = cls.FigureCanvas.manager_class
3401         # Interactive backends reimplement start_main_loop or pyplot_show.
3402         backend_is_interactive = (
3403             manager_class.start_main_loop != FigureManagerBase.start_main_loop
3404             or manager_class.pyplot_show != FigureManagerBase.pyplot_show)
3405         if backend_is_interactive and is_interactive():
3406             manager = Gcf.get_active()
3407             if manager:
3408                 manager.canvas.draw_idle()
3409 
3410     @classmethod
3411     def show(cls, *, block=None):
3412         """
3413         Show all figures.
3414 
3415         `show` blocks by calling `mainloop` if *block* is ``True``, or if it
3416         is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in
3417         `interactive` mode.
3418         """
3419         managers = Gcf.get_all_fig_managers()
3420         if not managers:
3421             return
3422         for manager in managers:
3423             try:
3424                 manager.show()  # Emits a warning for non-interactive backend.
3425             except NonGuiException as exc:
3426                 _api.warn_external(str(exc))
3427         if cls.mainloop is None:
3428             return
3429         if block is None:
3430             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython
3431             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always
3432             # set to False).
3433             pyplot_show = getattr(sys.modules.get("matplotlib.pyplot"), "show", None)
3434             ipython_pylab = hasattr(pyplot_show, "_needmain")
3435             block = not ipython_pylab and not is_interactive()
3436         if block:
3437             cls.mainloop()
3438 
3439     # This method is the one actually exporting the required methods.
3440 
3441     @staticmethod
3442     def export(cls):
3443         for name in [
3444                 "backend_version",
3445                 "FigureCanvas",
3446                 "FigureManager",
3447                 "new_figure_manager",
3448                 "new_figure_manager_given_figure",
3449                 "draw_if_interactive",
3450                 "show",
3451         ]:
3452             setattr(sys.modules[cls.__module__], name, getattr(cls, name))
3453 
3454         # For back-compatibility, generate a shim `Show` class.
3455 
3456         class Show(ShowBase):
3457             def mainloop(self):
3458                 return cls.mainloop()
3459 
3460         setattr(sys.modules[cls.__module__], "Show", Show)
3461         return cls
3462 
3463 
3464 class ShowBase(_Backend):
3465     """
3466     Simple base class to generate a ``show()`` function in backends.
3467 
3468     Subclass must override ``mainloop()`` method.
3469     """
3470 
3471     def __call__(self, block=None):
3472         return self.show(block=block)

</code><intended_behavior>This file, which is likely involved in the fundamental implementation of display mechanisms across backends, may require modifications to the `show()` method implementations specific to different backends. The adjustments should ensure that figures designated to remain open (perhaps through a mechanism introduced in `pyplot.py`) are not closed when the backend switches to `inline`. This could involve enhancing the `show()` method or related utility functions to acknowledge the new state management logic introduced in `pyplot.py` for backend switching, maintaining the figure's visibility as needed.</intended_behavior>]
2025-10-15 07:58:22.134 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 # fmt: off
39 
40 from __future__ import annotations
41 
42 from contextlib import AbstractContextManager, ExitStack
43 from enum import Enum
44 import functools
45 import importlib
46 import inspect
47 import logging
48 import re
49 import sys
50 import threading
51 import time
52 from typing import cast, overload
53 
54 from cycler import cycler
55 import matplotlib
56 import matplotlib.colorbar
57 import matplotlib.image
58 from matplotlib import _api
59 from matplotlib import (  # Re-exported for typing.
60     cm as cm, get_backend as get_backend, rcParams as rcParams, style as style)
61 from matplotlib import _pylab_helpers, interactive
62 from matplotlib import cbook
63 from matplotlib import _docstring
64 from matplotlib.backend_bases import (
65     FigureCanvasBase, FigureManagerBase, MouseButton)
66 from matplotlib.figure import Figure, FigureBase, figaspect
67 from matplotlib.gridspec import GridSpec, SubplotSpec
68 from matplotlib import rcsetup, rcParamsDefault, rcParamsOrig
69 from matplotlib.artist import Artist
70 from matplotlib.axes import Axes, Subplot  # type: ignore
71 from matplotlib.projections import PolarAxes  # type: ignore
72 from matplotlib import mlab  # for detrend_none, window_hanning
73 from matplotlib.scale import get_scale_names
74 
75 from matplotlib.cm import _colormaps
76 from matplotlib.cm import register_cmap  # type: ignore
77 from matplotlib.colors import _color_sequences
78 
79 import numpy as np
80 
81 from typing import TYPE_CHECKING, cast
82 
83 if TYPE_CHECKING:
84     from collections.abc import Callable, Hashable, Iterable, Sequence
85     import datetime
86     import pathlib
87     import os
88     from typing import Any, BinaryIO, Literal, TypeVar
89     from typing_extensions import ParamSpec
90 
91     import PIL
92     from numpy.typing import ArrayLike
93 
94     from matplotlib.axis import Tick
95     from matplotlib.axes._base import _AxesBase
96     from matplotlib.backend_bases import RendererBase, Event
97     from matplotlib.cm import ScalarMappable
98     from matplotlib.contour import ContourSet, QuadContourSet
99     from matplotlib.collections import (
100         Collection,
101         LineCollection,
102         BrokenBarHCollection,
103         PolyCollection,
104         PathCollection,
105         EventCollection,
106         QuadMesh,
107     )
108     from matplotlib.colorbar import Colorbar
109     from matplotlib.colors import Colormap
110     from matplotlib.container import (
111         BarContainer,
112         ErrorbarContainer,
113         StemContainer,
114     )
115     from matplotlib.figure import SubFigure
116     from matplotlib.legend import Legend
117     from matplotlib.mlab import GaussianKDE
118     from matplotlib.image import AxesImage, FigureImage
119     from matplotlib.patches import FancyArrow, StepPatch, Wedge
120     from matplotlib.quiver import Barbs, Quiver, QuiverKey
121     from matplotlib.scale import ScaleBase
122     from matplotlib.transforms import Transform, Bbox
123     from matplotlib.typing import ColorType, LineStyleType, MarkerType, HashableList
124     from matplotlib.widgets import SubplotTool
125 
126     _P = ParamSpec('_P')
127     _R = TypeVar('_R')
128 
129 
130 # We may not need the following imports here:
131 from matplotlib.colors import Normalize
132 from matplotlib.lines import Line2D
133 from matplotlib.text import Text, Annotation
134 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
135 from matplotlib.widgets import Button, Slider, Widget
136 
137 from .ticker import (
138     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
139     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
140     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
141     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
142 
143 _log = logging.getLogger(__name__)
144 
145 
146 # Explicit rename instead of import-as for typing's sake.
147 colormaps = _colormaps
148 color_sequences = _color_sequences
149 
150 
151 @overload
152 def _copy_docstring_and_deprecators(
153     method: Any,
154     func: Literal[None] = None
155 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...
156 
157 
158 @overload
159 def _copy_docstring_and_deprecators(
160     method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...
161 
162 
163 def _copy_docstring_and_deprecators(
164     method: Any,
165     func: Callable[_P, _R] | None = None
166 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:
167     if func is None:
168         return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',
169                     functools.partial(_copy_docstring_and_deprecators, method))
170     decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [
171         _docstring.copy(method)
172     ]
173     # Check whether the definition of *method* includes @_api.rename_parameter
174     # or @_api.make_keyword_only decorators; if so, propagate them to the
175     # pyplot wrapper as well.
176     while hasattr(method, "__wrapped__"):
177         potential_decorator = _api.deprecation.DECORATORS.get(method)
178         if potential_decorator:
179             decorators.append(potential_decorator)
180         method = method.__wrapped__
181     for decorator in decorators[::-1]:
182         func = decorator(func)
183     return func
184 
185 
186 ## Global ##
187 
188 
189 # The state controlled by {,un}install_repl_displayhook().
190 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
191 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
192 
193 
194 def _draw_all_if_interactive() -> None:
195     if matplotlib.is_interactive():
196         draw_all()
197 
198 
199 def install_repl_displayhook() -> None:
200     """
201     Connect to the display hook of the current shell.
202 
203     The display hook gets called when the read-evaluate-print-loop (REPL) of
204     the shell has finished the execution of a command. We use this callback
205     to be able to automatically update a figure in interactive mode.
206 
207     This works both with IPython and with vanilla python shells.
208     """
209     global _REPL_DISPLAYHOOK
210 
211     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
212         return
213 
214     # See if we have IPython hooks around, if so use them.
215     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
216     # entries can also have been explicitly set to None.
217     mod_ipython = sys.modules.get("IPython")
218     if not mod_ipython:
219         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
220         return
221     ip = mod_ipython.get_ipython()
222     if not ip:
223         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
224         return
225 
226     ip.events.register("post_execute", _draw_all_if_interactive)
227     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
228 
229     from IPython.core.pylabtools import backend2gui  # type: ignore
230     # trigger IPython's eventloop integration, if available
231     ipython_gui_name = backend2gui.get(get_backend())
232     if ipython_gui_name:
233         ip.enable_gui(ipython_gui_name)
234 
235 
236 def uninstall_repl_displayhook() -> None:
237     """Disconnect from the display hook of the current shell."""
238     global _REPL_DISPLAYHOOK
239     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
240         from IPython import get_ipython  # type: ignore
241         ip = get_ipython()
242         ip.events.unregister("post_execute", _draw_all_if_interactive)
243     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
244 
245 
246 draw_all = _pylab_helpers.Gcf.draw_all
247 
248 
249 # Ensure this appears in the pyplot docs.
250 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
251 def set_loglevel(*args, **kwargs) -> None:
252     return matplotlib.set_loglevel(*args, **kwargs)
253 
254 
255 @_copy_docstring_and_deprecators(Artist.findobj)
256 def findobj(
257     o: Artist | None = None,
258     match: Callable[[Artist], bool] | type[Artist] | None = None,
259     include_self: bool = True
260 ) -> list[Artist]:
261     if o is None:
262         o = gcf()
263     return o.findobj(match, include_self=include_self)
264 
265 
266 _backend_mod: type[matplotlib.backend_bases._Backend] | None = None
267 
268 
269 def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:
270     """
271     Ensure that a backend is selected and return it.
272 
273     This is currently private, but may be made public in the future.
274     """
275     if _backend_mod is None:
276         # Use rcParams._get("backend") to avoid going through the fallback
277         # logic (which will (re)import pyplot and then call switch_backend if
278         # we need to resolve the auto sentinel)
279         switch_backend(rcParams._get("backend"))  # type: ignore[attr-defined]
280     return cast(type[matplotlib.backend_bases._Backend], _backend_mod)
281 
282 
283 def switch_backend(newbackend: str) -> None:
284     """
285     Set the pyplot backend.
286 
287     Switching to an interactive backend is possible only if no event loop for
288     another interactive backend has started.  Switching to and from
289     non-interactive backends is always possible.
290 
291     If the new backend is different than the current backend then all open
292     Figures will be closed via ``plt.close('all')``.
293 
294     Parameters
295     ----------
296     newbackend : str
297         The case-insensitive name of the backend to use.
298 
299     """
300     global _backend_mod
301     # make sure the init is pulled up so we can assign to it later
302     import matplotlib.backends
303 
304     if newbackend is rcsetup._auto_backend_sentinel:
305         current_framework = cbook._get_running_interactive_framework()
306         mapping = {'qt': 'qtagg',
307                    'gtk3': 'gtk3agg',
308                    'gtk4': 'gtk4agg',
309                    'wx': 'wxagg',
310                    'tk': 'tkagg',
311                    'macosx': 'macosx',
312                    'headless': 'agg'}
313 
314         if current_framework in mapping:
315             candidates = [mapping[current_framework]]
316         else:
317             candidates = []
318         candidates += [
319             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
320 
321         # Don't try to fallback on the cairo-based backends as they each have
322         # an additional dependency (pycairo) over the agg-based backend, and
323         # are of worse quality.
324         for candidate in candidates:
325             try:
326                 switch_backend(candidate)
327             except ImportError:
328                 continue
329             else:
330                 rcParamsOrig['backend'] = candidate
331                 return
332         else:
333             # Switching to Agg should always succeed; if it doesn't, let the
334             # exception propagate out.
335             switch_backend("agg")
336             rcParamsOrig["backend"] = "agg"
337             return
338     # have to escape the switch on access logic
339     old_backend = dict.__getitem__(rcParams, 'backend')
340 
341     module = importlib.import_module(cbook._backend_module_name(newbackend))
342 
343     required_framework = module.FigureCanvas.required_interactive_framework
344     if required_framework is not None:
345         current_framework = cbook._get_running_interactive_framework()
346         if (current_framework and required_framework
347                 and current_framework != required_framework):
348             raise ImportError(
349                 "Cannot load backend {!r} which requires the {!r} interactive "
350                 "framework, as {!r} is currently running".format(
351                     newbackend, required_framework, current_framework))
352 
353     # Load the new_figure_manager() and show() functions from the backend.
354 
355     # Classically, backends can directly export these functions.  This should
356     # keep working for backcompat.
357     new_figure_manager = getattr(module, "new_figure_manager", None)
358     show = getattr(module, "show", None)
359 
360     # In that classical approach, backends are implemented as modules, but
361     # "inherit" default method implementations from backend_bases._Backend.
362     # This is achieved by creating a "class" that inherits from
363     # backend_bases._Backend and whose body is filled with the module globals.
364     class backend_mod(matplotlib.backend_bases._Backend):
365         locals().update(vars(module))
366 
367     # However, the newer approach for defining new_figure_manager and
368     # show is to derive them from canvas methods.  In that case, also
369     # update backend_mod accordingly; also, per-backend customization of
370     # draw_if_interactive is disabled.
371     if new_figure_manager is None:
372         # Only try to get the canvas class if have opted into the new scheme.
373         canvas_class = backend_mod.FigureCanvas
374 
375         def new_figure_manager_given_figure(num, figure):
376             return canvas_class.new_manager(figure, num)
377 
378         def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):
379             fig = FigureClass(*args, **kwargs)
380             return new_figure_manager_given_figure(num, fig)
381 
382         def draw_if_interactive() -> None:
383             if matplotlib.is_interactive():
384                 manager = _pylab_helpers.Gcf.get_active()
385                 if manager:
386                     manager.canvas.draw_idle()
387 
388         backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]
389             new_figure_manager_given_figure)
390         backend_mod.new_figure_manager = (  # type: ignore[method-assign]
391             new_figure_manager)
392         backend_mod.draw_if_interactive = (  # type: ignore[method-assign]
393             draw_if_interactive)
394 
395     # If the manager explicitly overrides pyplot_show, use it even if a global
396     # show is already present, as the latter may be here for backcompat.
397     manager_class = getattr(getattr(backend_mod, "FigureCanvas", None),
398                             "manager_class", None)
399     # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because
400     # pyplot_show is a classmethod so the above constructs are bound classmethods, and
401     # thus always different (being bound to different classes).  We also have to use
402     # getattr_static instead of vars as manager_class could have no __dict__.
403     manager_pyplot_show = inspect.getattr_static(manager_class, "pyplot_show", None)
404     base_pyplot_show = inspect.getattr_static(FigureManagerBase, "pyplot_show", None)
405     if (show is None
406             or (manager_pyplot_show is not None
407                 and manager_pyplot_show != base_pyplot_show)):
408         _pyplot_show = cast('Any', manager_class).pyplot_show
409         backend_mod.show = _pyplot_show  # type: ignore[method-assign]
410 
411     _log.debug("Loaded backend %s version %s.",
412                newbackend, backend_mod.backend_version)
413 
414     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
415     _backend_mod = backend_mod
416     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
417         globals()[func_name].__signature__ = inspect.signature(
418             getattr(backend_mod, func_name))
419 
420     # Need to keep a global reference to the backend for compatibility reasons.
421     # See https://github.com/matplotlib/matplotlib/issues/6092
422     matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]
423     if not cbook._str_equal(old_backend, newbackend):
424         close("all")
425 
426     # make sure the repl display hook is installed in case we become
427     # interactive
428     install_repl_displayhook()
429 
430 
431 def _warn_if_gui_out_of_main_thread() -> None:
432     warn = False
433     canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)
434     if canvas_class.required_interactive_framework:
435         if hasattr(threading, 'get_native_id'):
436             # This compares native thread ids because even if Python-level
437             # Thread objects match, the underlying OS thread (which is what
438             # really matters) may be different on Python implementations with
439             # green threads.
440             if threading.get_native_id() != threading.main_thread().native_id:
441                 warn = True
442         else:
443             # Fall back to Python-level Thread if native IDs are unavailable,
444             # mainly for PyPy.
445             if threading.current_thread() is not threading.main_thread():
446                 warn = True
447     if warn:
448         _api.warn_external(
449             "Starting a Matplotlib GUI outside of the main thread will likely "
450             "fail.")
451 
452 
453 # This function's signature is rewritten upon backend-load by switch_backend.
454 def new_figure_manager(*args, **kwargs):
455     """Create a new figure manager instance."""
456     _warn_if_gui_out_of_main_thread()
457     return _get_backend_mod().new_figure_manager(*args, **kwargs)
458 
459 
460 # This function's signature is rewritten upon backend-load by switch_backend.
461 def draw_if_interactive(*args, **kwargs):
462     """
463     Redraw the current figure if in interactive mode.
464 
465     .. warning::
466 
467         End users will typically not have to call this function because the
468         the interactive mode takes care of this.
469     """
470     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
471 
472 
473 # This function's signature is rewritten upon backend-load by switch_backend.
474 def show(*args, **kwargs):
475     """
476     Display all open figures.
477 
478     Parameters
479     ----------
480     block : bool, optional
481         Whether to wait for all figures to be closed before returning.
482 
483         If `True` block and run the GUI main loop until all figure windows
484         are closed.
485 
486         If `False` ensure that all figure windows are displayed and return
487         immediately.  In this case, you are responsible for ensuring
488         that the event loop is running to have responsive figures.
489 
490         Defaults to True in non-interactive mode and to False in interactive
491         mode (see `.pyplot.isinteractive`).
492 
493     See Also
494     --------
495     ion : Enable interactive mode, which shows / updates the figure after
496           every plotting command, so that calling ``show()`` is not necessary.
497     ioff : Disable interactive mode.
498     savefig : Save the figure to an image file instead of showing it on screen.
499 
500     Notes
501     -----
502     **Saving figures to file and showing a window at the same time**
503 
504     If you want an image file as well as a user interface window, use
505     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
506     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
507     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
508     limitation of command order does not apply if the show is non-blocking or
509     if you keep a reference to the figure and use `.Figure.savefig`.
510 
511     **Auto-show in jupyter notebooks**
512 
513     The jupyter backends (activated via ``%matplotlib inline``,
514     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
515     the end of every cell by default. Thus, you usually don't have to call it
516     explicitly there.
517     """
518     _warn_if_gui_out_of_main_thread()
519     return _get_backend_mod().show(*args, **kwargs)
520 
521 
522 def isinteractive() -> bool:
523     """
524     Return whether plots are updated after every plotting command.
525 
526     The interactive mode is mainly useful if you build plots from the command
527     line and want to see the effect of each command while you are building the
528     figure.
529 
530     In interactive mode:
531 
532     - newly created figures will be shown immediately;
533     - figures will automatically redraw on change;
534     - `.pyplot.show` will not block by default.
535 
536     In non-interactive mode:
537 
538     - newly created figures and changes to figures will not be reflected until
539       explicitly asked to be;
540     - `.pyplot.show` will block by default.
541 
542     See Also
543     --------
544     ion : Enable interactive mode.
545     ioff : Disable interactive mode.
546     show : Show all figures (and maybe block).
547     pause : Show all figures, and block for a time.
548     """
549     return matplotlib.is_interactive()
550 
551 
552 def ioff() -> ExitStack:
553     """
554     Disable interactive mode.
555 
556     See `.pyplot.isinteractive` for more details.
557 
558     See Also
559     --------
560     ion : Enable interactive mode.
561     isinteractive : Whether interactive mode is enabled.
562     show : Show all figures (and maybe block).
563     pause : Show all figures, and block for a time.
564 
565     Notes
566     -----
567     For a temporary change, this can be used as a context manager::
568 
569         # if interactive mode is on
570         # then figures will be shown on creation
571         plt.ion()
572         # This figure will be shown immediately
573         fig = plt.figure()
574 
575         with plt.ioff():
576             # interactive mode will be off
577             # figures will not automatically be shown
578             fig2 = plt.figure()
579             # ...
580 
581     To enable optional usage as a context manager, this function returns a
582     `~contextlib.ExitStack` object, which is not intended to be stored or
583     accessed by the user.
584     """
585     stack = ExitStack()
586     stack.callback(ion if isinteractive() else ioff)
587     matplotlib.interactive(False)
588     uninstall_repl_displayhook()
589     return stack
590 
591 
592 def ion() -> ExitStack:
593     """
594     Enable interactive mode.
595 
596     See `.pyplot.isinteractive` for more details.
597 
598     See Also
599     --------
600     ioff : Disable interactive mode.
601     isinteractive : Whether interactive mode is enabled.
602     show : Show all figures (and maybe block).
603     pause : Show all figures, and block for a time.
604 
605     Notes
606     -----
607     For a temporary change, this can be used as a context manager::
608 
609         # if interactive mode is off
610         # then figures will not be shown on creation
611         plt.ioff()
612         # This figure will not be shown immediately
613         fig = plt.figure()
614 
615         with plt.ion():
616             # interactive mode will be on
617             # figures will automatically be shown
618             fig2 = plt.figure()
619             # ...
620 
621     To enable optional usage as a context manager, this function returns a
622     `~contextlib.ExitStack` object, which is not intended to be stored or
623     accessed by the user.
624     """
625     stack = ExitStack()
626     stack.callback(ion if isinteractive() else ioff)
627     matplotlib.interactive(True)
628     install_repl_displayhook()
629     return stack
630 
631 
632 def pause(interval: float) -> None:
633     """
634     Run the GUI event loop for *interval* seconds.
635 
636     If there is an active figure, it will be updated and displayed before the
637     pause, and the GUI event loop (if any) will run during the pause.
638 
639     This can be used for crude animation.  For more complex animation use
640     :mod:`matplotlib.animation`.
641 
642     If there is no active figure, sleep for *interval* seconds instead.
643 
644     See Also
645     --------
646     matplotlib.animation : Proper animations
647     show : Show all figures and optional block until all figures are closed.
648     """
649     manager = _pylab_helpers.Gcf.get_active()
650     if manager is not None:
651         canvas = manager.canvas
652         if canvas.figure.stale:
653             canvas.draw_idle()
654         show(block=False)
655         canvas.start_event_loop(interval)
656     else:
657         time.sleep(interval)
658 
659 
660 @_copy_docstring_and_deprecators(matplotlib.rc)
661 def rc(group: str, **kwargs) -> None:
662     matplotlib.rc(group, **kwargs)
663 
664 
665 @_copy_docstring_and_deprecators(matplotlib.rc_context)
666 def rc_context(
667     rc: dict[str, Any] | None = None,
668     fname: str | pathlib.Path | os.PathLike | None = None,
669 ) -> AbstractContextManager[None]:
670     return matplotlib.rc_context(rc, fname)
671 
672 
673 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
674 def rcdefaults() -> None:
675     matplotlib.rcdefaults()
676     if matplotlib.is_interactive():
677         draw_all()
678 
679 
680 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
681 
682 
683 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
684 def getp(obj, *args, **kwargs):
685     return matplotlib.artist.getp(obj, *args, **kwargs)
686 
687 
688 @_copy_docstring_and_deprecators(matplotlib.artist.get)
689 def get(obj, *args, **kwargs):
690     return matplotlib.artist.get(obj, *args, **kwargs)
691 
692 
693 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
694 def setp(obj, *args, **kwargs):
695     return matplotlib.artist.setp(obj, *args, **kwargs)
696 
697 
698 def xkcd(
699     scale: float = 1, length: float = 100, randomness: float = 2
700 ) -> ExitStack:
701     """
702     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
703     only have effect on things drawn after this function is called.
704 
705     For best results, the "Humor Sans" font should be installed: it is
706     not included with Matplotlib.
707 
708     Parameters
709     ----------
710     scale : float, optional
711         The amplitude of the wiggle perpendicular to the source line.
712     length : float, optional
713         The length of the wiggle along the line.
714     randomness : float, optional
715         The scale factor by which the length is shrunken or expanded.
716 
717     Notes
718     -----
719     This function works by a number of rcParams, so it will probably
720     override others you have set before.
721 
722     If you want the effects of this function to be temporary, it can
723     be used as a context manager, for example::
724 
725         with plt.xkcd():
726             # This figure will be in XKCD-style
727             fig1 = plt.figure()
728             # ...
729 
730         # This figure will be in regular style
731         fig2 = plt.figure()
732     """
733     # This cannot be implemented in terms of contextmanager() or rc_context()
734     # because this needs to work as a non-contextmanager too.
735 
736     if rcParams['text.usetex']:
737         raise RuntimeError(
738             "xkcd mode is not compatible with text.usetex = True")
739 
740     stack = ExitStack()
741     stack.callback(dict.update, rcParams, rcParams.copy())  # type: ignore
742 
743     from matplotlib import patheffects
744     rcParams.update({
745         'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
746                         'Comic Sans MS'],
747         'font.size': 14.0,
748         'path.sketch': (scale, length, randomness),
749         'path.effects': [
750             patheffects.withStroke(linewidth=4, foreground="w")],
751         'axes.linewidth': 1.5,
752         'lines.linewidth': 2.0,
753         'figure.facecolor': 'white',
754         'grid.linewidth': 0.0,
755         'axes.grid': False,
756         'axes.unicode_minus': False,
757         'axes.edgecolor': 'black',
758         'xtick.major.size': 8,
759         'xtick.major.width': 3,
760         'ytick.major.size': 8,
761         'ytick.major.width': 3,
762     })
763 
764     return stack
765 
766 
767 ## Figures ##
768 
769 def figure(
770     # autoincrement if None, else integer from 1-N
771     num: int | str | Figure | SubFigure | None = None,
772     # defaults to rc figure.figsize
773     figsize: tuple[float, float] | None = None,
774     # defaults to rc figure.dpi
775     dpi: float | None = None,
776     *,
777     # defaults to rc figure.facecolor
778     facecolor: ColorType | None = None,
779     # defaults to rc figure.edgecolor
780     edgecolor: ColorType | None = None,
781     frameon: bool = True,
782     FigureClass: type[Figure] = Figure,
783     clear: bool = False,
784     **kwargs
785 ) -> Figure:
786     """
787     Create a new figure, or activate an existing figure.
788 
789     Parameters
790     ----------
791     num : int or str or `.Figure` or `.SubFigure`, optional
792         A unique identifier for the figure.
793 
794         If a figure with that identifier already exists, this figure is made
795         active and returned. An integer refers to the ``Figure.number``
796         attribute, a string refers to the figure label.
797 
798         If there is no figure with the identifier or *num* is not given, a new
799         figure is created, made active and returned.  If *num* is an int, it
800         will be used for the ``Figure.number`` attribute, otherwise, an
801         auto-generated integer value is used (starting at 1 and incremented
802         for each new figure). If *num* is a string, the figure label and the
803         window title is set to this value.  If num is a ``SubFigure``, its
804         parent ``Figure`` is activated.
805 
806     figsize : (float, float), default: :rc:`figure.figsize`
807         Width, height in inches.
808 
809     dpi : float, default: :rc:`figure.dpi`
810         The resolution of the figure in dots-per-inch.
811 
812     facecolor : color, default: :rc:`figure.facecolor`
813         The background color.
814 
815     edgecolor : color, default: :rc:`figure.edgecolor`
816         The border color.
817 
818     frameon : bool, default: True
819         If False, suppress drawing the figure frame.
820 
821     FigureClass : subclass of `~matplotlib.figure.Figure`
822         If set, an instance of this subclass will be created, rather than a
823         plain `.Figure`.
824 
825     clear : bool, default: False
826         If True and the figure already exists, then it is cleared.
827 
828     layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \
829 default: None
830         The layout mechanism for positioning of plot elements to avoid
831         overlapping Axes decorations (labels, ticks, etc). Note that layout
832         managers can measurably slow down figure display.
833 
834         - 'constrained': The constrained layout solver adjusts axes sizes
835           to avoid overlapping axes decorations.  Can handle complex plot
836           layouts and colorbars, and is thus recommended.
837 
838           See :ref:`constrainedlayout_guide`
839           for examples.
840 
841         - 'compressed': uses the same algorithm as 'constrained', but
842           removes extra space between fixed-aspect-ratio Axes.  Best for
843           simple grids of axes.
844 
845         - 'tight': Use the tight layout mechanism. This is a relatively
846           simple algorithm that adjusts the subplot parameters so that
847           decorations do not overlap. See `.Figure.set_tight_layout` for
848           further details.
849 
850         - 'none': Do not use a layout engine.
851 
852         - A `.LayoutEngine` instance. Builtin layout classes are
853           `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
854           accessible by 'constrained' and 'tight'.  Passing an instance
855           allows third parties to provide their own layout engine.
856 
857         If not given, fall back to using the parameters *tight_layout* and
858         *constrained_layout*, including their config defaults
859         :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
860 
861     **kwargs
862         Additional keyword arguments are passed to the `.Figure` constructor.
863 
864     Returns
865     -------
866     `~matplotlib.figure.Figure`
867 
868     Notes
869     -----
870     A newly created figure is passed to the `~.FigureCanvasBase.new_manager`
871     method or the `new_figure_manager` function provided by the current
872     backend, which install a canvas and a manager on the figure.
873 
874     Once this is done, :rc:`figure.hooks` are called, one at a time, on the
875     figure; these hooks allow arbitrary customization of the figure (e.g.,
876     attaching callbacks) or of associated elements (e.g., modifying the
877     toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of
878     toolbar customization.
879 
880     If you are creating many figures, make sure you explicitly call
881     `.pyplot.close` on the figures you are not using, because this will
882     enable pyplot to properly clean up the memory.
883 
884     `~matplotlib.rcParams` defines the default values, which can be modified
885     in the matplotlibrc file.
886     """
887     if isinstance(num, FigureBase):
888         # type narrowed to `Figure | SubFigure` by combination of input and isinstance
889         if num.canvas.manager is None:
890             raise ValueError("The passed figure is not managed by pyplot")
891         _pylab_helpers.Gcf.set_active(num.canvas.manager)
892         return num.figure
893 
894     allnums = get_fignums()
895     next_num = max(allnums) + 1 if allnums else 1
896     fig_label = ''
897     if num is None:
898         num = next_num
899     elif isinstance(num, str):
900         fig_label = num
901         all_labels = get_figlabels()
902         if fig_label not in all_labels:
903             if fig_label == 'all':
904                 _api.warn_external("close('all') closes all existing figures.")
905             num = next_num
906         else:
907             inum = all_labels.index(fig_label)
908             num = allnums[inum]
909     else:
910         num = int(num)  # crude validation of num argument
911 
912     # Type of "num" has narrowed to int, but mypy can't quite see it
913     manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]
914     if manager is None:
915         max_open_warning = rcParams['figure.max_open_warning']
916         if len(allnums) == max_open_warning >= 1:
917             _api.warn_external(
918                 f"More than {max_open_warning} figures have been opened. "
919                 f"Figures created through the pyplot interface "
920                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
921                 f"closed and may consume too much memory. (To control this "
922                 f"warning, see the rcParam `figure.max_open_warning`). "
923                 f"Consider using `matplotlib.pyplot.close()`.",
924                 RuntimeWarning)
925 
926         manager = new_figure_manager(
927             num, figsize=figsize, dpi=dpi,
928             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
929             FigureClass=FigureClass, **kwargs)
930         fig = manager.canvas.figure
931         if fig_label:
932             fig.set_label(fig_label)
933 
934         for hookspecs in rcParams["figure.hooks"]:
935             module_name, dotted_name = hookspecs.split(":")
936             obj = importlib.import_module(module_name)
937             for part in dotted_name.split("."):
938                 obj = getattr(obj, part)
939             obj(fig)
940 
941         _pylab_helpers.Gcf._set_new_active_manager(manager)
942 
943         # make sure backends (inline) that we don't ship that expect this
944         # to be called in plotting commands to make the figure call show
945         # still work.  There is probably a better way to do this in the
946         # FigureManager base class.
947         draw_if_interactive()
948 
949         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
950             fig.stale_callback = _auto_draw_if_interactive
951 
952     if clear:
953         manager.canvas.figure.clear()
954 
955     return manager.canvas.figure
956 
957 
958 def _auto_draw_if_interactive(fig, val):
959     """
960     An internal helper function for making sure that auto-redrawing
961     works as intended in the plain python repl.
962 
963     Parameters
964     ----------
965     fig : Figure
966         A figure object which is assumed to be associated with a canvas
967     """
968     if (val and matplotlib.is_interactive()
969             and not fig.canvas.is_saving()
970             and not fig.canvas._is_idle_drawing):
971         # Some artists can mark themselves as stale in the middle of drawing
972         # (e.g. axes position & tick labels being computed at draw time), but
973         # this shouldn't trigger a redraw because the current redraw will
974         # already take them into account.
975         with fig.canvas._idle_draw_cntx():
976             fig.canvas.draw_idle()
977 
978 
979 def gcf() -> Figure:
980     """
981     Get the current figure.
982 
983     If there is currently no figure on the pyplot figure stack, a new one is
984     created using `~.pyplot.figure()`.  (To test whether there is currently a
985     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
986     is empty.)
987     """
988     manager = _pylab_helpers.Gcf.get_active()
989     if manager is not None:
990         return manager.canvas.figure
991     else:
992         return figure()
993 
994 
995 def fignum_exists(num: int) -> bool:
996     """Return whether the figure with the given id exists."""
997     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
998 
999 
1000 def get_fignums() -> list[int]:
1001     """Return a list of existing figure numbers."""
1002     return sorted(_pylab_helpers.Gcf.figs)
1003 
1004 
1005 def get_figlabels() -> list[Any]:
1006     """Return a list of existing figure labels."""
1007     managers = _pylab_helpers.Gcf.get_all_fig_managers()
1008     managers.sort(key=lambda m: m.num)
1009     return [m.canvas.figure.get_label() for m in managers]
1010 
1011 
1012 def get_current_fig_manager() -> FigureManagerBase | None:
1013     """
1014     Return the figure manager of the current figure.
1015 
1016     The figure manager is a container for the actual backend-depended window
1017     that displays the figure on screen.
1018 
1019     If no current figure exists, a new one is created, and its figure
1020     manager is returned.
1021 
1022     Returns
1023     -------
1024     `.FigureManagerBase` or backend-dependent subclass thereof
1025     """
1026     return gcf().canvas.manager
1027 
1028 
1029 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
1030 def connect(s: str, func: Callable[[Event], Any]) -> int:
1031     return gcf().canvas.mpl_connect(s, func)
1032 
1033 
1034 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
1035 def disconnect(cid: int) -> None:
1036     gcf().canvas.mpl_disconnect(cid)
1037 
1038 
1039 def close(fig: None | int | str | Figure | Literal["all"] = None) -> None:
1040     """
1041     Close a figure window.
1042 
1043     Parameters
1044     ----------
1045     fig : None or int or str or `.Figure`
1046         The figure to close. There are a number of ways to specify this:
1047 
1048         - *None*: the current figure
1049         - `.Figure`: the given `.Figure` instance
1050         - ``int``: a figure number
1051         - ``str``: a figure name
1052         - 'all': all figures
1053 
1054     """
1055     if fig is None:
1056         manager = _pylab_helpers.Gcf.get_active()
1057         if manager is None:
1058             return
1059         else:
1060             _pylab_helpers.Gcf.destroy(manager)
1061     elif fig == 'all':
1062         _pylab_helpers.Gcf.destroy_all()
1063     elif isinstance(fig, int):
1064         _pylab_helpers.Gcf.destroy(fig)
1065     elif hasattr(fig, 'int'):
1066         # if we are dealing with a type UUID, we
1067         # can use its integer representation
1068         _pylab_helpers.Gcf.destroy(fig.int)
1069     elif isinstance(fig, str):
1070         all_labels = get_figlabels()
1071         if fig in all_labels:
1072             num = get_fignums()[all_labels.index(fig)]
1073             _pylab_helpers.Gcf.destroy(num)
1074     elif isinstance(fig, Figure):
1075         _pylab_helpers.Gcf.destroy_fig(fig)
1076     else:
1077         raise TypeError("close() argument must be a Figure, an int, a string, "
1078                         "or None, not %s" % type(fig))
1079 
1080 
1081 def clf() -> None:
1082     """Clear the current figure."""
1083     gcf().clear()
1084 
1085 
1086 def draw() -> None:
1087     """
1088     Redraw the current figure.
1089 
1090     This is used to update a figure that has been altered, but not
1091     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
1092     should be only rarely needed, but there may be ways to modify the state of
1093     a figure without marking it as "stale".  Please report these cases as bugs.
1094 
1095     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
1096     the current figure.
1097 
1098     See Also
1099     --------
1100     .FigureCanvasBase.draw_idle
1101     .FigureCanvasBase.draw
1102     """
1103     gcf().canvas.draw_idle()
1104 
1105 
1106 @_copy_docstring_and_deprecators(Figure.savefig)
1107 def savefig(*args, **kwargs) -> None:
1108     fig = gcf()
1109     # savefig default implementation has no return, so mypy is unhappy
1110     # presumably this is here because subclasses can return?
1111     res = fig.savefig(*args, **kwargs)  # type: ignore[func-returns-value]
1112     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
1113     return res
1114 
1115 
1116 ## Putting things in figures ##
1117 
1118 
1119 def figlegend(*args, **kwargs) -> Legend:
1120     return gcf().legend(*args, **kwargs)
1121 if Figure.legend.__doc__:
1122     figlegend.__doc__ = Figure.legend.__doc__ \
1123         .replace(" legend(", " figlegend(") \
1124         .replace("fig.legend(", "plt.figlegend(") \
1125         .replace("ax.plot(", "plt.plot(")
1126 
1127 
1128 ## Axes ##
1129 
1130 @_docstring.dedent_interpd
1131 def axes(
1132     arg: None | tuple[float, float, float, float] = None,
1133     **kwargs
1134 ) -> matplotlib.axes.Axes:
1135     """
1136     Add an Axes to the current figure and make it the current Axes.
1137 
1138     Call signatures::
1139 
1140         plt.axes()
1141         plt.axes(rect, projection=None, polar=False, **kwargs)
1142         plt.axes(ax)
1143 
1144     Parameters
1145     ----------
1146     arg : None or 4-tuple
1147         The exact behavior of this function depends on the type:
1148 
1149         - *None*: A new full window Axes is added using
1150           ``subplot(**kwargs)``.
1151         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
1152           A new Axes is added with dimensions *rect* in normalized
1153           (0, 1) units using `~.Figure.add_axes` on the current figure.
1154 
1155     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1156 'polar', 'rectilinear', str}, optional
1157         The projection type of the `~.axes.Axes`. *str* is the name of
1158         a custom projection, see `~matplotlib.projections`. The default
1159         None results in a 'rectilinear' projection.
1160 
1161     polar : bool, default: False
1162         If True, equivalent to projection='polar'.
1163 
1164     sharex, sharey : `~matplotlib.axes.Axes`, optional
1165         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1166         The axis will have the same limits, ticks, and scale as the axis
1167         of the shared Axes.
1168 
1169     label : str
1170         A label for the returned Axes.
1171 
1172     Returns
1173     -------
1174     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1175         The returned axes class depends on the projection used. It is
1176         `~.axes.Axes` if rectilinear projection is used and
1177         `.projections.polar.PolarAxes` if polar projection is used.
1178 
1179     Other Parameters
1180     ----------------
1181     **kwargs
1182         This method also takes the keyword arguments for
1183         the returned Axes class. The keyword arguments for the
1184         rectilinear Axes class `~.axes.Axes` can be found in
1185         the following table but there might also be other keyword
1186         arguments if another projection is used, see the actual Axes
1187         class.
1188 
1189         %(Axes:kwdoc)s
1190 
1191     See Also
1192     --------
1193     .Figure.add_axes
1194     .pyplot.subplot
1195     .Figure.add_subplot
1196     .Figure.subplots
1197     .pyplot.subplots
1198 
1199     Examples
1200     --------
1201     ::
1202 
1203         # Creating a new full window Axes
1204         plt.axes()
1205 
1206         # Creating a new Axes with specified dimensions and a grey background
1207         plt.axes((left, bottom, width, height), facecolor='grey')
1208     """
1209     fig = gcf()
1210     pos = kwargs.pop('position', None)
1211     if arg is None:
1212         if pos is None:
1213             return fig.add_subplot(**kwargs)
1214         else:
1215             return fig.add_axes(pos, **kwargs)
1216     else:
1217         return fig.add_axes(arg, **kwargs)
1218 
1219 
1220 def delaxes(ax: matplotlib.axes.Axes | None = None) -> None:
1221     """
1222     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1223     """
1224     if ax is None:
1225         ax = gca()
1226     ax.remove()
1227 
1228 
1229 def sca(ax: Axes) -> None:
1230     """
1231     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1232     """
1233     # Mypy sees ax.figure as potentially None,
1234     # but if you are calling this, it won't be None
1235     # Additionally the slight difference between `Figure` and `FigureBase` mypy catches
1236     figure(ax.figure)  # type: ignore[arg-type]
1237     ax.figure.sca(ax)  # type: ignore[union-attr]
1238 
1239 
1240 def cla() -> None:
1241     """Clear the current axes."""
1242     # Not generated via boilerplate.py to allow a different docstring.
1243     return gca().cla()
1244 
1245 
1246 ## More ways of creating axes ##
1247 
1248 @_docstring.dedent_interpd
1249 def subplot(*args, **kwargs) -> Axes:
1250     """
1251     Add an Axes to the current figure or retrieve an existing Axes.
1252 
1253     This is a wrapper of `.Figure.add_subplot` which provides additional
1254     behavior when working with the implicit API (see the notes section).
1255 
1256     Call signatures::
1257 
1258        subplot(nrows, ncols, index, **kwargs)
1259        subplot(pos, **kwargs)
1260        subplot(**kwargs)
1261        subplot(ax)
1262 
1263     Parameters
1264     ----------
1265     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1266         The position of the subplot described by one of
1267 
1268         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1269           *index* position on a grid with *nrows* rows and *ncols* columns.
1270           *index* starts at 1 in the upper left corner and increases to the
1271           right. *index* can also be a two-tuple specifying the (*first*,
1272           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1273           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1274           upper 2/3 of the figure.
1275         - A 3-digit integer. The digits are interpreted as if given separately
1276           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1277           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1278           if there are no more than 9 subplots.
1279         - A `.SubplotSpec`.
1280 
1281     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1282 'polar', 'rectilinear', str}, optional
1283         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1284         of a custom projection, see `~matplotlib.projections`. The default
1285         None results in a 'rectilinear' projection.
1286 
1287     polar : bool, default: False
1288         If True, equivalent to projection='polar'.
1289 
1290     sharex, sharey : `~matplotlib.axes.Axes`, optional
1291         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1292         axis will have the same limits, ticks, and scale as the axis of the
1293         shared axes.
1294 
1295     label : str
1296         A label for the returned axes.
1297 
1298     Returns
1299     -------
1300     `~.axes.Axes`
1301 
1302         The Axes of the subplot. The returned Axes can actually be an instance
1303         of a subclass, such as `.projections.polar.PolarAxes` for polar
1304         projections.
1305 
1306     Other Parameters
1307     ----------------
1308     **kwargs
1309         This method also takes the keyword arguments for the returned axes
1310         base class; except for the *figure* argument. The keyword arguments
1311         for the rectilinear base class `~.axes.Axes` can be found in
1312         the following table but there might also be other keyword
1313         arguments if another projection is used.
1314 
1315         %(Axes:kwdoc)s
1316 
1317     Notes
1318     -----
1319     Creating a new Axes will delete any preexisting Axes that
1320     overlaps with it beyond sharing a boundary::
1321 
1322         import matplotlib.pyplot as plt
1323         # plot a line, implicitly creating a subplot(111)
1324         plt.plot([1, 2, 3])
1325         # now create a subplot which represents the top plot of a grid
1326         # with 2 rows and 1 column. Since this subplot will overlap the
1327         # first, the plot (and its axes) previously created, will be removed
1328         plt.subplot(211)
1329 
1330     If you do not want this behavior, use the `.Figure.add_subplot` method
1331     or the `.pyplot.axes` function instead.
1332 
1333     If no *kwargs* are passed and there exists an Axes in the location
1334     specified by *args* then that Axes will be returned rather than a new
1335     Axes being created.
1336 
1337     If *kwargs* are passed and there exists an Axes in the location
1338     specified by *args*, the projection type is the same, and the
1339     *kwargs* match with the existing Axes, then the existing Axes is
1340     returned.  Otherwise a new Axes is created with the specified
1341     parameters.  We save a reference to the *kwargs* which we use
1342     for this comparison.  If any of the values in *kwargs* are
1343     mutable we will not detect the case where they are mutated.
1344     In these cases we suggest using `.Figure.add_subplot` and the
1345     explicit Axes API rather than the implicit pyplot API.
1346 
1347     See Also
1348     --------
1349     .Figure.add_subplot
1350     .pyplot.subplots
1351     .pyplot.axes
1352     .Figure.subplots
1353 
1354     Examples
1355     --------
1356     ::
1357 
1358         plt.subplot(221)
1359 
1360         # equivalent but more general
1361         ax1 = plt.subplot(2, 2, 1)
1362 
1363         # add a subplot with no frame
1364         ax2 = plt.subplot(222, frameon=False)
1365 
1366         # add a polar subplot
1367         plt.subplot(223, projection='polar')
1368 
1369         # add a red subplot that shares the x-axis with ax1
1370         plt.subplot(224, sharex=ax1, facecolor='red')
1371 
1372         # delete ax2 from the figure
1373         plt.delaxes(ax2)
1374 
1375         # add ax2 to the figure again
1376         plt.subplot(ax2)
1377 
1378         # make the first axes "current" again
1379         plt.subplot(221)
1380 
1381     """
1382     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1383     # downstream code deal with the rest.
1384     unset = object()
1385     projection = kwargs.get('projection', unset)
1386     polar = kwargs.pop('polar', unset)
1387     if polar is not unset and polar:
1388         # if we got mixed messages from the user, raise
1389         if projection is not unset and projection != 'polar':
1390             raise ValueError(
1391                 f"polar={polar}, yet projection={projection!r}. "
1392                 "Only one of these arguments should be supplied."
1393             )
1394         kwargs['projection'] = projection = 'polar'
1395 
1396     # if subplot called without arguments, create subplot(1, 1, 1)
1397     if len(args) == 0:
1398         args = (1, 1, 1)
1399 
1400     # This check was added because it is very easy to type subplot(1, 2, False)
1401     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1402     # cases, no error will ever occur, but mysterious behavior can result
1403     # because what was intended to be the sharex argument is instead treated as
1404     # a subplot index for subplot()
1405     if len(args) >= 3 and isinstance(args[2], bool):
1406         _api.warn_external("The subplot index argument to subplot() appears "
1407                            "to be a boolean. Did you intend to use "
1408                            "subplots()?")
1409     # Check for nrows and ncols, which are not valid subplot args:
1410     if 'nrows' in kwargs or 'ncols' in kwargs:
1411         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1412                         "and/or 'nrows'.  Did you intend to call subplots()?")
1413 
1414     fig = gcf()
1415 
1416     # First, search for an existing subplot with a matching spec.
1417     key = SubplotSpec._from_subplot_args(fig, args)
1418 
1419     for ax in fig.axes:
1420         # If we found an Axes at the position, we can re-use it if the user passed no
1421         # kwargs or if the axes class and kwargs are identical.
1422         if (ax.get_subplotspec() == key
1423             and (kwargs == {}
1424                  or (ax._projection_init
1425                      == fig._process_projection_requirements(**kwargs)))):
1426             break
1427     else:
1428         # we have exhausted the known Axes and none match, make a new one!
1429         ax = fig.add_subplot(*args, **kwargs)
1430 
1431     fig.sca(ax)
1432 
1433     return ax
1434 
1435 
1436 def subplots(
1437     nrows: int = 1, ncols: int = 1, *,
1438     sharex: bool | Literal["none", "all", "row", "col"] = False,
1439     sharey: bool | Literal["none", "all", "row", "col"] = False,
1440     squeeze: bool = True,
1441     width_ratios: Sequence[float] | None = None,
1442     height_ratios: Sequence[float] | None = None,
1443     subplot_kw: dict[str, Any] | None = None,
1444     gridspec_kw: dict[str, Any] | None = None,
1445     **fig_kw
1446 ) -> tuple[Figure, Any]:
1447     """
1448     Create a figure and a set of subplots.
1449 
1450     This utility wrapper makes it convenient to create common layouts of
1451     subplots, including the enclosing figure object, in a single call.
1452 
1453     Parameters
1454     ----------
1455     nrows, ncols : int, default: 1
1456         Number of rows/columns of the subplot grid.
1457 
1458     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1459         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1460         axes:
1461 
1462         - True or 'all': x- or y-axis will be shared among all subplots.
1463         - False or 'none': each subplot x- or y-axis will be independent.
1464         - 'row': each subplot row will share an x- or y-axis.
1465         - 'col': each subplot column will share an x- or y-axis.
1466 
1467         When subplots have a shared x-axis along a column, only the x tick
1468         labels of the bottom subplot are created. Similarly, when subplots
1469         have a shared y-axis along a row, only the y tick labels of the first
1470         column subplot are created. To later turn other subplots' ticklabels
1471         on, use `~matplotlib.axes.Axes.tick_params`.
1472 
1473         When subplots have a shared axis that has units, calling
1474         `~matplotlib.axis.Axis.set_units` will update each axis with the
1475         new units.
1476 
1477     squeeze : bool, default: True
1478         - If True, extra dimensions are squeezed out from the returned
1479           array of `~matplotlib.axes.Axes`:
1480 
1481           - if only one subplot is constructed (nrows=ncols=1), the
1482             resulting single Axes object is returned as a scalar.
1483           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1484             object array of Axes objects.
1485           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1486 
1487         - If False, no squeezing at all is done: the returned Axes object is
1488           always a 2D array containing Axes instances, even if it ends up
1489           being 1x1.
1490 
1491     width_ratios : array-like of length *ncols*, optional
1492         Defines the relative widths of the columns. Each column gets a
1493         relative width of ``width_ratios[i] / sum(width_ratios)``.
1494         If not given, all columns will have the same width.  Equivalent
1495         to ``gridspec_kw={'width_ratios': [...]}``.
1496 
1497     height_ratios : array-like of length *nrows*, optional
1498         Defines the relative heights of the rows. Each row gets a
1499         relative height of ``height_ratios[i] / sum(height_ratios)``.
1500         If not given, all rows will have the same height. Convenience
1501         for ``gridspec_kw={'height_ratios': [...]}``.
1502 
1503     subplot_kw : dict, optional
1504         Dict with keywords passed to the
1505         `~matplotlib.figure.Figure.add_subplot` call used to create each
1506         subplot.
1507 
1508     gridspec_kw : dict, optional
1509         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1510         constructor used to create the grid the subplots are placed on.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519 
1520     ax : `~matplotlib.axes.Axes` or array of Axes
1521         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1522         objects if more than one subplot was created.  The dimensions of the
1523         resulting array can be controlled with the squeeze keyword, see above.
1524 
1525         Typical idioms for handling the return value are::
1526 
1527             # using the variable ax for single a Axes
1528             fig, ax = plt.subplots()
1529 
1530             # using the variable axs for multiple Axes
1531             fig, axs = plt.subplots(2, 2)
1532 
1533             # using tuple unpacking for multiple Axes
1534             fig, (ax1, ax2) = plt.subplots(1, 2)
1535             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1536 
1537         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1538         because for the latter it's not clear if it refers to a single
1539         `~.axes.Axes` instance or a collection of these.
1540 
1541     See Also
1542     --------
1543     .pyplot.figure
1544     .pyplot.subplot
1545     .pyplot.axes
1546     .Figure.subplots
1547     .Figure.add_subplot
1548 
1549     Examples
1550     --------
1551     ::
1552 
1553         # First create some toy data:
1554         x = np.linspace(0, 2*np.pi, 400)
1555         y = np.sin(x**2)
1556 
1557         # Create just a figure and only one subplot
1558         fig, ax = plt.subplots()
1559         ax.plot(x, y)
1560         ax.set_title('Simple plot')
1561 
1562         # Create two subplots and unpack the output array immediately
1563         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1564         ax1.plot(x, y)
1565         ax1.set_title('Sharing Y axis')
1566         ax2.scatter(x, y)
1567 
1568         # Create four polar axes and access them through the returned array
1569         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1570         axs[0, 0].plot(x, y)
1571         axs[1, 1].scatter(x, y)
1572 
1573         # Share a X axis with each column of subplots
1574         plt.subplots(2, 2, sharex='col')
1575 
1576         # Share a Y axis with each row of subplots
1577         plt.subplots(2, 2, sharey='row')
1578 
1579         # Share both X and Y axes with all subplots
1580         plt.subplots(2, 2, sharex='all', sharey='all')
1581 
1582         # Note that this is the same as
1583         plt.subplots(2, 2, sharex=True, sharey=True)
1584 
1585         # Create figure number 10 with a single subplot
1586         # and clears it if it already exists.
1587         fig, ax = plt.subplots(num=10, clear=True)
1588 
1589     """
1590     fig = figure(**fig_kw)
1591     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1592                        squeeze=squeeze, subplot_kw=subplot_kw,
1593                        gridspec_kw=gridspec_kw, height_ratios=height_ratios,
1594                        width_ratios=width_ratios)
1595     return fig, axs
1596 
1597 
1598 def subplot_mosaic(
1599     mosaic: str | HashableList,
1600     *,
1601     sharex: bool = False,
1602     sharey: bool = False,
1603     width_ratios: ArrayLike | None = None,
1604     height_ratios: ArrayLike | None = None,
1605     empty_sentinel: Any = '.',
1606     subplot_kw: dict[str, Any] | None = None,
1607     gridspec_kw: dict[str, Any] | None = None,
1608     per_subplot_kw: dict[Hashable, dict[str, Any]] | None = None,
1609     **fig_kw
1610 ) -> tuple[Figure, dict[Hashable, matplotlib.axes.Axes]]:
1611     """
1612     Build a layout of Axes based on ASCII art or nested lists.
1613 
1614     This is a helper function to build complex GridSpec layouts visually.
1615 
1616     See :ref:`mosaic`
1617     for an example and full API documentation
1618 
1619     Parameters
1620     ----------
1621     mosaic : list of list of {hashable or nested} or str
1622 
1623         A visual layout of how you want your Axes to be arranged
1624         labeled as strings.  For example ::
1625 
1626            x = [['A panel', 'A panel', 'edge'],
1627                 ['C panel', '.',       'edge']]
1628 
1629         produces 4 axes:
1630 
1631         - 'A panel' which is 1 row high and spans the first two columns
1632         - 'edge' which is 2 rows high and is on the right edge
1633         - 'C panel' which in 1 row and 1 column wide in the bottom left
1634         - a blank space 1 row and 1 column wide in the bottom center
1635 
1636         Any of the entries in the layout can be a list of lists
1637         of the same form to create nested layouts.
1638 
1639         If input is a str, then it must be of the form ::
1640 
1641           '''
1642           AAE
1643           C.E
1644           '''
1645 
1646         where each character is a column and each line is a row.
1647         This only allows only single character Axes labels and does
1648         not allow nesting but is very terse.
1649 
1650     sharex, sharey : bool, default: False
1651         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1652         among all subplots.  In that case, tick label visibility and axis units
1653         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1654         be independent.
1655 
1656     width_ratios : array-like of length *ncols*, optional
1657         Defines the relative widths of the columns. Each column gets a
1658         relative width of ``width_ratios[i] / sum(width_ratios)``.
1659         If not given, all columns will have the same width.  Convenience
1660         for ``gridspec_kw={'width_ratios': [...]}``.
1661 
1662     height_ratios : array-like of length *nrows*, optional
1663         Defines the relative heights of the rows. Each row gets a
1664         relative height of ``height_ratios[i] / sum(height_ratios)``.
1665         If not given, all rows will have the same height. Convenience
1666         for ``gridspec_kw={'height_ratios': [...]}``.
1667 
1668     empty_sentinel : object, optional
1669         Entry in the layout to mean "leave this space empty".  Defaults
1670         to ``'.'``. Note, if *layout* is a string, it is processed via
1671         `inspect.cleandoc` to remove leading white space, which may
1672         interfere with using white-space as the empty sentinel.
1673 
1674     subplot_kw : dict, optional
1675         Dictionary with keywords passed to the `.Figure.add_subplot` call
1676         used to create each subplot.  These values may be overridden by
1677         values in *per_subplot_kw*.
1678 
1679     per_subplot_kw : dict, optional
1680         A dictionary mapping the Axes identifiers or tuples of identifiers
1681         to a dictionary of keyword arguments to be passed to the
1682         `.Figure.add_subplot` call used to create each subplot.  The values
1683         in these dictionaries have precedence over the values in
1684         *subplot_kw*.
1685 
1686         If *mosaic* is a string, and thus all keys are single characters,
1687         it is possible to use a single string instead of a tuple as keys;
1688         i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1689 
1690         .. versionadded:: 3.7
1691 
1692     gridspec_kw : dict, optional
1693         Dictionary with keywords passed to the `.GridSpec` constructor used
1694         to create the grid the subplots are placed on.
1695 
1696     **fig_kw
1697         All additional keyword arguments are passed to the
1698         `.pyplot.figure` call.
1699 
1700     Returns
1701     -------
1702     fig : `.Figure`
1703        The new figure
1704 
1705     dict[label, Axes]
1706        A dictionary mapping the labels to the Axes objects.  The order of
1707        the axes is left-to-right and top-to-bottom of their position in the
1708        total layout.
1709 
1710     """
1711     fig = figure(**fig_kw)
1712     ax_dict = fig.subplot_mosaic(
1713         mosaic, sharex=sharex, sharey=sharey,
1714         height_ratios=height_ratios, width_ratios=width_ratios,
1715         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1716         empty_sentinel=empty_sentinel,
1717         per_subplot_kw=per_subplot_kw,
1718     )
1719     return fig, ax_dict
1720 
1721 
1722 def subplot2grid(
1723     shape: tuple[int, int], loc: tuple[int, int],
1724     rowspan: int = 1, colspan: int = 1,
1725     fig: Figure | None = None,
1726     **kwargs
1727 ) -> matplotlib.axes.Axes:
1728     """
1729     Create a subplot at a specific location inside a regular grid.
1730 
1731     Parameters
1732     ----------
1733     shape : (int, int)
1734         Number of rows and of columns of the grid in which to place axis.
1735     loc : (int, int)
1736         Row number and column number of the axis location within the grid.
1737     rowspan : int, default: 1
1738         Number of rows for the axis to span downwards.
1739     colspan : int, default: 1
1740         Number of columns for the axis to span to the right.
1741     fig : `.Figure`, optional
1742         Figure to place the subplot in. Defaults to the current figure.
1743     **kwargs
1744         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1745 
1746     Returns
1747     -------
1748     `~.axes.Axes`
1749 
1750         The Axes of the subplot. The returned Axes can actually be an instance
1751         of a subclass, such as `.projections.polar.PolarAxes` for polar
1752         projections.
1753 
1754     Notes
1755     -----
1756     The following call ::
1757 
1758         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1759 
1760     is identical to ::
1761 
1762         fig = gcf()
1763         gs = fig.add_gridspec(nrows, ncols)
1764         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1765     """
1766     if fig is None:
1767         fig = gcf()
1768     rows, cols = shape
1769     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1770     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1771     return fig.add_subplot(subplotspec, **kwargs)
1772 
1773 
1774 def twinx(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1775     """
1776     Make and return a second axes that shares the *x*-axis.  The new axes will
1777     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1778     on the right.
1779 
1780     Examples
1781     --------
1782     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1783     """
1784     if ax is None:
1785         ax = gca()
1786     ax1 = ax.twinx()
1787     return ax1
1788 
1789 
1790 def twiny(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1791     """
1792     Make and return a second axes that shares the *y*-axis.  The new axes will
1793     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1794     on the top.
1795 
1796     Examples
1797     --------
1798     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1799     """
1800     if ax is None:
1801         ax = gca()
1802     ax1 = ax.twiny()
1803     return ax1
1804 
1805 
1806 def subplot_tool(targetfig: Figure | None = None) -> SubplotTool | None:
1807     """
1808     Launch a subplot tool window for a figure.
1809 
1810     Returns
1811     -------
1812     `matplotlib.widgets.SubplotTool`
1813     """
1814     if targetfig is None:
1815         targetfig = gcf()
1816     tb = targetfig.canvas.manager.toolbar  # type: ignore[union-attr]
1817     if hasattr(tb, "configure_subplots"):  # toolbar2
1818         from matplotlib.backend_bases import NavigationToolbar2
1819         return cast(NavigationToolbar2, tb).configure_subplots()
1820     elif hasattr(tb, "trigger_tool"):  # toolmanager
1821         from matplotlib.backend_bases import ToolContainerBase
1822         cast(ToolContainerBase, tb).trigger_tool("subplots")
1823         return None
1824     else:
1825         raise ValueError("subplot_tool can only be launched for figures with "
1826                          "an associated toolbar")
1827 
1828 
1829 def box(on: bool | None = None) -> None:
1830     """
1831     Turn the axes box on or off on the current axes.
1832 
1833     Parameters
1834     ----------
1835     on : bool or None
1836         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1837         the state.
1838 
1839     See Also
1840     --------
1841     :meth:`matplotlib.axes.Axes.set_frame_on`
1842     :meth:`matplotlib.axes.Axes.get_frame_on`
1843     """
1844     ax = gca()
1845     if on is None:
1846         on = not ax.get_frame_on()
1847     ax.set_frame_on(on)
1848 
1849 ## Axis ##
1850 
1851 
1852 def xlim(*args, **kwargs) -> tuple[float, float]:
1853     """
1854     Get or set the x limits of the current axes.
1855 
1856     Call signatures::
1857 
1858         left, right = xlim()  # return the current xlim
1859         xlim((left, right))   # set the xlim to left, right
1860         xlim(left, right)     # set the xlim to left, right
1861 
1862     If you do not specify args, you can pass *left* or *right* as kwargs,
1863     i.e.::
1864 
1865         xlim(right=3)  # adjust the right leaving left unchanged
1866         xlim(left=1)  # adjust the left leaving right unchanged
1867 
1868     Setting limits turns autoscaling off for the x-axis.
1869 
1870     Returns
1871     -------
1872     left, right
1873         A tuple of the new x-axis limits.
1874 
1875     Notes
1876     -----
1877     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1878     equivalent of calling `~.Axes.get_xlim` on the current axes.
1879     Calling this function with arguments is the pyplot equivalent of calling
1880     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1881     """
1882     ax = gca()
1883     if not args and not kwargs:
1884         return ax.get_xlim()
1885     ret = ax.set_xlim(*args, **kwargs)
1886     return ret
1887 
1888 
1889 def ylim(*args, **kwargs) -> tuple[float, float]:
1890     """
1891     Get or set the y-limits of the current axes.
1892 
1893     Call signatures::
1894 
1895         bottom, top = ylim()  # return the current ylim
1896         ylim((bottom, top))   # set the ylim to bottom, top
1897         ylim(bottom, top)     # set the ylim to bottom, top
1898 
1899     If you do not specify args, you can alternatively pass *bottom* or
1900     *top* as kwargs, i.e.::
1901 
1902         ylim(top=3)  # adjust the top leaving bottom unchanged
1903         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1904 
1905     Setting limits turns autoscaling off for the y-axis.
1906 
1907     Returns
1908     -------
1909     bottom, top
1910         A tuple of the new y-axis limits.
1911 
1912     Notes
1913     -----
1914     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1915     equivalent of calling `~.Axes.get_ylim` on the current axes.
1916     Calling this function with arguments is the pyplot equivalent of calling
1917     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1918     """
1919     ax = gca()
1920     if not args and not kwargs:
1921         return ax.get_ylim()
1922     ret = ax.set_ylim(*args, **kwargs)
1923     return ret
1924 
1925 
1926 def xticks(
1927     ticks: ArrayLike | None = None,
1928     labels: Sequence[str] | None = None,
1929     *,
1930     minor: bool = False,
1931     **kwargs
1932 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
1933     """
1934     Get or set the current tick locations and labels of the x-axis.
1935 
1936     Pass no arguments to return the current values without modifying them.
1937 
1938     Parameters
1939     ----------
1940     ticks : array-like, optional
1941         The list of xtick locations.  Passing an empty list removes all xticks.
1942     labels : array-like, optional
1943         The labels to place at the given *ticks* locations.  This argument can
1944         only be passed if *ticks* is passed as well.
1945     minor : bool, default: False
1946         If ``False``, get/set the major ticks/labels; if ``True``, the minor
1947         ticks/labels.
1948     **kwargs
1949         `.Text` properties can be used to control the appearance of the labels.
1950 
1951     Returns
1952     -------
1953     locs
1954         The list of xtick locations.
1955     labels
1956         The list of xlabel `.Text` objects.
1957 
1958     Notes
1959     -----
1960     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1961     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1962     the current axes.
1963     Calling this function with arguments is the pyplot equivalent of calling
1964     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1965 
1966     Examples
1967     --------
1968     >>> locs, labels = xticks()  # Get the current locations and labels.
1969     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1970     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1971     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1972     ...        rotation=20)  # Set text labels and properties.
1973     >>> xticks([])  # Disable xticks.
1974     """
1975     ax = gca()
1976 
1977     locs: list[Tick] | np.ndarray
1978     if ticks is None:
1979         locs = ax.get_xticks(minor=minor)
1980         if labels is not None:
1981             raise TypeError("xticks(): Parameter 'labels' can't be set "
1982                             "without setting 'ticks'")
1983     else:
1984         locs = ax.set_xticks(ticks, minor=minor)
1985 
1986     labels_out: list[Text] = []
1987     if labels is None:
1988         labels_out = ax.get_xticklabels(minor=minor)
1989         for l in labels_out:
1990             l._internal_update(kwargs)
1991     else:
1992         labels_out = ax.set_xticklabels(labels, minor=minor, **kwargs)
1993 
1994     return locs, labels_out
1995 
1996 
1997 def yticks(
1998     ticks: ArrayLike | None = None,
1999     labels: Sequence[str] | None = None,
2000     *,
2001     minor: bool = False,
2002     **kwargs
2003 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
2004     """
2005     Get or set the current tick locations and labels of the y-axis.
2006 
2007     Pass no arguments to return the current values without modifying them.
2008 
2009     Parameters
2010     ----------
2011     ticks : array-like, optional
2012         The list of ytick locations.  Passing an empty list removes all yticks.
2013     labels : array-like, optional
2014         The labels to place at the given *ticks* locations.  This argument can
2015         only be passed if *ticks* is passed as well.
2016     minor : bool, default: False
2017         If ``False``, get/set the major ticks/labels; if ``True``, the minor
2018         ticks/labels.
2019     **kwargs
2020         `.Text` properties can be used to control the appearance of the labels.
2021 
2022     Returns
2023     -------
2024     locs
2025         The list of ytick locations.
2026     labels
2027         The list of ylabel `.Text` objects.
2028 
2029     Notes
2030     -----
2031     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
2032     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
2033     the current axes.
2034     Calling this function with arguments is the pyplot equivalent of calling
2035     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
2036 
2037     Examples
2038     --------
2039     >>> locs, labels = yticks()  # Get the current locations and labels.
2040     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
2041     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
2042     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
2043     ...        rotation=45)  # Set text labels and properties.
2044     >>> yticks([])  # Disable yticks.
2045     """
2046     ax = gca()
2047 
2048     locs: list[Tick] | np.ndarray
2049     if ticks is None:
2050         locs = ax.get_yticks(minor=minor)
2051         if labels is not None:
2052             raise TypeError("yticks(): Parameter 'labels' can't be set "
2053                             "without setting 'ticks'")
2054     else:
2055         locs = ax.set_yticks(ticks, minor=minor)
2056 
2057     labels_out: list[Text] = []
2058     if labels is None:
2059         labels_out = ax.get_yticklabels(minor=minor)
2060         for l in labels_out:
2061             l._internal_update(kwargs)
2062     else:
2063         labels_out = ax.set_yticklabels(labels, minor=minor, **kwargs)
2064 
2065     return locs, labels_out
2066 
2067 
2068 def rgrids(
2069     radii: ArrayLike | None = None,
2070     labels: Sequence[str | Text] | None = None,
2071     angle: float | None = None,
2072     fmt: str | None = None,
2073     **kwargs
2074 ) -> tuple[list[Line2D], list[Text]]:
2075     """
2076     Get or set the radial gridlines on the current polar plot.
2077 
2078     Call signatures::
2079 
2080      lines, labels = rgrids()
2081      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
2082 
2083     When called with no arguments, `.rgrids` simply returns the tuple
2084     (*lines*, *labels*). When called with arguments, the labels will
2085     appear at the specified radial distances and angle.
2086 
2087     Parameters
2088     ----------
2089     radii : tuple with floats
2090         The radii for the radial gridlines
2091 
2092     labels : tuple with strings or None
2093         The labels to use at each radial gridline. The
2094         `matplotlib.ticker.ScalarFormatter` will be used if None.
2095 
2096     angle : float
2097         The angular position of the radius labels in degrees.
2098 
2099     fmt : str or None
2100         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2101         For example '%f'.
2102 
2103     Returns
2104     -------
2105     lines : list of `.lines.Line2D`
2106         The radial gridlines.
2107 
2108     labels : list of `.text.Text`
2109         The tick labels.
2110 
2111     Other Parameters
2112     ----------------
2113     **kwargs
2114         *kwargs* are optional `.Text` properties for the labels.
2115 
2116     See Also
2117     --------
2118     .pyplot.thetagrids
2119     .projections.polar.PolarAxes.set_rgrids
2120     .Axis.get_gridlines
2121     .Axis.get_ticklabels
2122 
2123     Examples
2124     --------
2125     ::
2126 
2127       # set the locations of the radial gridlines
2128       lines, labels = rgrids( (0.25, 0.5, 1.0) )
2129 
2130       # set the locations and labels of the radial gridlines
2131       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
2132     """
2133     ax = gca()
2134     if not isinstance(ax, PolarAxes):
2135         raise RuntimeError('rgrids only defined for polar axes')
2136     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
2137         lines_out: list[Line2D] = ax.yaxis.get_gridlines()
2138         labels_out: list[Text] = ax.yaxis.get_ticklabels()
2139     elif radii is None:
2140         raise TypeError("'radii' cannot be None when other parameters are passed")
2141     else:
2142         lines_out, labels_out = ax.set_rgrids(
2143             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
2144     return lines_out, labels_out
2145 
2146 
2147 def thetagrids(
2148     angles: ArrayLike | None = None,
2149     labels: Sequence[str | Text] | None = None,
2150     fmt: str | None = None,
2151     **kwargs
2152 ) -> tuple[list[Line2D], list[Text]]:
2153     """
2154     Get or set the theta gridlines on the current polar plot.
2155 
2156     Call signatures::
2157 
2158      lines, labels = thetagrids()
2159      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
2160 
2161     When called with no arguments, `.thetagrids` simply returns the tuple
2162     (*lines*, *labels*). When called with arguments, the labels will
2163     appear at the specified angles.
2164 
2165     Parameters
2166     ----------
2167     angles : tuple with floats, degrees
2168         The angles of the theta gridlines.
2169 
2170     labels : tuple with strings or None
2171         The labels to use at each radial gridline. The
2172         `.projections.polar.ThetaFormatter` will be used if None.
2173 
2174     fmt : str or None
2175         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2176         For example '%f'. Note that the angle in radians will be used.
2177 
2178     Returns
2179     -------
2180     lines : list of `.lines.Line2D`
2181         The theta gridlines.
2182 
2183     labels : list of `.text.Text`
2184         The tick labels.
2185 
2186     Other Parameters
2187     ----------------
2188     **kwargs
2189         *kwargs* are optional `.Text` properties for the labels.
2190 
2191     See Also
2192     --------
2193     .pyplot.rgrids
2194     .projections.polar.PolarAxes.set_thetagrids
2195     .Axis.get_gridlines
2196     .Axis.get_ticklabels
2197 
2198     Examples
2199     --------
2200     ::
2201 
2202       # set the locations of the angular gridlines
2203       lines, labels = thetagrids(range(45, 360, 90))
2204 
2205       # set the locations and labels of the angular gridlines
2206       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
2207     """
2208     ax = gca()
2209     if not isinstance(ax, PolarAxes):
2210         raise RuntimeError('thetagrids only defined for polar axes')
2211     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
2212         lines_out: list[Line2D] = ax.xaxis.get_ticklines()
2213         labels_out: list[Text] = ax.xaxis.get_ticklabels()
2214     elif angles is None:
2215         raise TypeError("'angles' cannot be None when other parameters are passed")
2216     else:
2217         lines_out, labels_out = ax.set_thetagrids(angles,
2218                                                   labels=labels, fmt=fmt,
2219                                                   **kwargs)
2220     return lines_out, labels_out
2221 
2222 
2223 @_api.deprecated("3.7", pending=True)
2224 def get_plot_commands() -> list[str]:
2225     """
2226     Get a sorted list of all of the plotting commands.
2227     """
2228     NON_PLOT_COMMANDS = {
2229         'connect', 'disconnect', 'get_current_fig_manager', 'ginput',
2230         'new_figure_manager', 'waitforbuttonpress'}
2231     return [name for name in _get_pyplot_commands()
2232             if name not in NON_PLOT_COMMANDS]
2233 
2234 
2235 def _get_pyplot_commands() -> list[str]:
2236     # This works by searching for all functions in this module and removing
2237     # a few hard-coded exclusions, as well as all of the colormap-setting
2238     # functions, and anything marked as private with a preceding underscore.
2239     exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}
2240     this_module = inspect.getmodule(get_plot_commands)
2241     return sorted(
2242         name for name, obj in globals().items()
2243         if not name.startswith('_') and name not in exclude
2244            and inspect.isfunction(obj)
2245            and inspect.getmodule(obj) is this_module)
2246 
2247 
2248 ## Plotting part 1: manually generated functions and wrappers ##
2249 
2250 
2251 @_copy_docstring_and_deprecators(Figure.colorbar)
2252 def colorbar(
2253     mappable: ScalarMappable | None = None,
2254     cax: matplotlib.axes.Axes | None = None,
2255     ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,
2256     **kwargs
2257 ) -> Colorbar:
2258     if mappable is None:
2259         mappable = gci()
2260         if mappable is None:
2261             raise RuntimeError('No mappable was found to use for colorbar '
2262                                'creation. First define a mappable such as '
2263                                'an image (with imshow) or a contour set ('
2264                                'with contourf).')
2265     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2266     return ret
2267 
2268 
2269 def clim(vmin: float | None = None, vmax: float | None = None) -> None:
2270     """
2271     Set the color limits of the current image.
2272 
2273     If either *vmin* or *vmax* is None, the image min/max respectively
2274     will be used for color scaling.
2275 
2276     If you want to set the clim of multiple images, use
2277     `~.ScalarMappable.set_clim` on every image, for example::
2278 
2279       for im in gca().get_images():
2280           im.set_clim(0, 0.5)
2281 
2282     """
2283     im = gci()
2284     if im is None:
2285         raise RuntimeError('You must first define an image, e.g., with imshow')
2286 
2287     im.set_clim(vmin, vmax)
2288 
2289 
2290 # eventually this implementation should move here, use indirection for now to
2291 # avoid having two copies of the code floating around.
2292 def get_cmap(
2293     name: Colormap | str | None = None,
2294     lut: int | None = None
2295 ) -> Colormap:
2296     return cm._get_cmap(name=name, lut=lut)  # type: ignore
2297 get_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore
2298 
2299 
2300 def set_cmap(cmap: Colormap | str) -> None:
2301     """
2302     Set the default colormap, and applies it to the current image if any.
2303 
2304     Parameters
2305     ----------
2306     cmap : `~matplotlib.colors.Colormap` or str
2307         A colormap instance or the name of a registered colormap.
2308 
2309     See Also
2310     --------
2311     colormaps
2312     matplotlib.cm.register_cmap
2313     matplotlib.cm.get_cmap
2314     """
2315     cmap = get_cmap(cmap)
2316 
2317     rc('image', cmap=cmap.name)
2318     im = gci()
2319 
2320     if im is not None:
2321         im.set_cmap(cmap)
2322 
2323 
2324 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2325 def imread(
2326         fname: str | pathlib.Path | BinaryIO, format: str | None = None
2327 ) -> np.ndarray:
2328     return matplotlib.image.imread(fname, format)
2329 
2330 
2331 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2332 def imsave(
2333     fname: str | os.PathLike | BinaryIO, arr: ArrayLike, **kwargs
2334 ) -> None:
2335     matplotlib.image.imsave(fname, arr, **kwargs)
2336 
2337 
2338 def matshow(A: ArrayLike, fignum: None | int = None, **kwargs) -> AxesImage:
2339     """
2340     Display an array as a matrix in a new figure window.
2341 
2342     The origin is set at the upper left hand corner and rows (first
2343     dimension of the array) are displayed horizontally.  The aspect
2344     ratio of the figure window is that of the array, unless this would
2345     make an excessively short or narrow figure.
2346 
2347     Tick labels for the xaxis are placed on top.
2348 
2349     Parameters
2350     ----------
2351     A : 2D array-like
2352         The matrix to be displayed.
2353 
2354     fignum : None or int
2355         If *None*, create a new figure window with automatic numbering.
2356 
2357         If a nonzero integer, draw into the figure with the given number
2358         (create it if it does not exist).
2359 
2360         If 0, use the current axes (or create one if it does not exist).
2361 
2362         .. note::
2363 
2364            Because of how `.Axes.matshow` tries to set the figure aspect
2365            ratio to be the one of the array, strange things may happen if you
2366            reuse an existing figure.
2367 
2368     Returns
2369     -------
2370     `~matplotlib.image.AxesImage`
2371 
2372     Other Parameters
2373     ----------------
2374     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2375 
2376     """
2377     A = np.asanyarray(A)
2378     if fignum == 0:
2379         ax = gca()
2380     else:
2381         # Extract actual aspect ratio of array and make appropriately sized
2382         # figure.
2383         fig = figure(fignum, figsize=figaspect(A))
2384         ax = fig.add_axes((0.15, 0.09, 0.775, 0.775))
2385     im = ax.matshow(A, **kwargs)
2386     sci(im)
2387     return im
2388 
2389 
2390 def polar(*args, **kwargs) -> list[Line2D]:
2391     """
2392     Make a polar plot.
2393 
2394     call signature::
2395 
2396       polar(theta, r, **kwargs)
2397 
2398     Multiple *theta*, *r* arguments are supported, with format strings, as in
2399     `plot`.
2400     """
2401     # If an axis already exists, check if it has a polar projection
2402     if gcf().get_axes():
2403         ax = gca()
2404         if not isinstance(ax, PolarAxes):
2405             _api.warn_external('Trying to create polar plot on an Axes '
2406                                'that does not have a polar projection.')
2407     else:
2408         ax = axes(projection="polar")
2409     return ax.plot(*args, **kwargs)
2410 
2411 
2412 # If rcParams['backend_fallback'] is true, and an interactive backend is
2413 # requested, ignore rcParams['backend'] and force selection of a backend that
2414 # is compatible with the current running interactive framework.
2415 if (rcParams["backend_fallback"]
2416         and rcParams._get_backend_or_none() in (  # type: ignore
2417             set(rcsetup.interactive_bk) - {'WebAgg', 'nbAgg'})
2418         and cbook._get_running_interactive_framework()):  # type: ignore
2419     rcParams._set("backend", rcsetup._auto_backend_sentinel)  # type: ignore
2420 
2421 # fmt: on
2422 
2423 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2424 
2425 
2426 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2427 @_copy_docstring_and_deprecators(Figure.figimage)
2428 def figimage(
2429     X: ArrayLike,
2430     xo: int = 0,
2431     yo: int = 0,
2432     alpha: float | None = None,
2433     norm: str | Normalize | None = None,
2434     cmap: str | Colormap | None = None,
2435     vmin: float | None = None,
2436     vmax: float | None = None,
2437     origin: Literal["upper", "lower"] | None = None,
2438     resize: bool = False,
2439     **kwargs,
2440 ) -> FigureImage:
2441     return gcf().figimage(
2442         X,
2443         xo=xo,
2444         yo=yo,
2445         alpha=alpha,
2446         norm=norm,
2447         cmap=cmap,
2448         vmin=vmin,
2449         vmax=vmax,
2450         origin=origin,
2451         resize=resize,
2452         **kwargs,
2453     )
2454 
2455 
2456 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2457 @_copy_docstring_and_deprecators(Figure.text)
2458 def figtext(
2459     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
2460 ) -> Text:
2461     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2462 
2463 
2464 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2465 @_copy_docstring_and_deprecators(Figure.gca)
2466 def gca() -> Axes:
2467     return gcf().gca()
2468 
2469 
2470 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2471 @_copy_docstring_and_deprecators(Figure._gci)
2472 def gci() -> ScalarMappable | None:
2473     return gcf()._gci()
2474 
2475 
2476 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2477 @_copy_docstring_and_deprecators(Figure.ginput)
2478 def ginput(
2479     n: int = 1,
2480     timeout: float = 30,
2481     show_clicks: bool = True,
2482     mouse_add: MouseButton = MouseButton.LEFT,
2483     mouse_pop: MouseButton = MouseButton.RIGHT,
2484     mouse_stop: MouseButton = MouseButton.MIDDLE,
2485 ) -> list[tuple[int, int]]:
2486     return gcf().ginput(
2487         n=n,
2488         timeout=timeout,
2489         show_clicks=show_clicks,
2490         mouse_add=mouse_add,
2491         mouse_pop=mouse_pop,
2492         mouse_stop=mouse_stop,
2493     )
2494 
2495 
2496 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2497 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2498 def subplots_adjust(
2499     left: float | None = None,
2500     bottom: float | None = None,
2501     right: float | None = None,
2502     top: float | None = None,
2503     wspace: float | None = None,
2504     hspace: float | None = None,
2505 ) -> None:
2506     gcf().subplots_adjust(
2507         left=left, bottom=bottom, right=right, top=top, wspace=wspace, hspace=hspace
2508     )
2509 
2510 
2511 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2512 @_copy_docstring_and_deprecators(Figure.suptitle)
2513 def suptitle(t: str, **kwargs) -> Text:
2514     return gcf().suptitle(t, **kwargs)
2515 
2516 
2517 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2518 @_copy_docstring_and_deprecators(Figure.tight_layout)
2519 def tight_layout(
2520     *,
2521     pad: float = 1.08,
2522     h_pad: float | None = None,
2523     w_pad: float | None = None,
2524     rect: tuple[float, float, float, float] | None = None,
2525 ) -> None:
2526     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2527 
2528 
2529 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2530 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2531 def waitforbuttonpress(timeout: float = -1) -> None | bool:
2532     return gcf().waitforbuttonpress(timeout=timeout)
2533 
2534 
2535 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2536 @_copy_docstring_and_deprecators(Axes.acorr)
2537 def acorr(
2538     x: ArrayLike, *, data=None, **kwargs
2539 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
2540     return gca().acorr(x, **({"data": data} if data is not None else {}), **kwargs)
2541 
2542 
2543 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2544 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2545 def angle_spectrum(
2546     x: ArrayLike,
2547     Fs: float | None = None,
2548     Fc: int | None = None,
2549     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2550     pad_to: int | None = None,
2551     sides: Literal["default", "onesided", "twosided"] | None = None,
2552     *,
2553     data=None,
2554     **kwargs,
2555 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
2556     return gca().angle_spectrum(
2557         x,
2558         Fs=Fs,
2559         Fc=Fc,
2560         window=window,
2561         pad_to=pad_to,
2562         sides=sides,
2563         **({"data": data} if data is not None else {}),
2564         **kwargs,
2565     )
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.annotate)
2570 def annotate(
2571     text: str,
2572     xy: tuple[float, float],
2573     xytext: tuple[float, float] | None = None,
2574     xycoords: str
2575     | Artist
2576     | Transform
2577     | Callable[[RendererBase], Bbox | Transform]
2578     | tuple[float, float] = "data",
2579     textcoords: str
2580     | Artist
2581     | Transform
2582     | Callable[[RendererBase], Bbox | Transform]
2583     | tuple[float, float]
2584     | None = None,
2585     arrowprops: dict[str, Any] | None = None,
2586     annotation_clip: bool | None = None,
2587     **kwargs,
2588 ) -> Annotation:
2589     return gca().annotate(
2590         text,
2591         xy,
2592         xytext=xytext,
2593         xycoords=xycoords,
2594         textcoords=textcoords,
2595         arrowprops=arrowprops,
2596         annotation_clip=annotation_clip,
2597         **kwargs,
2598     )
2599 
2600 
2601 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2602 @_copy_docstring_and_deprecators(Axes.arrow)
2603 def arrow(x: float, y: float, dx: float, dy: float, **kwargs) -> FancyArrow:
2604     return gca().arrow(x, y, dx, dy, **kwargs)
2605 
2606 
2607 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2608 @_copy_docstring_and_deprecators(Axes.autoscale)
2609 def autoscale(
2610     enable: bool = True,
2611     axis: Literal["both", "x", "y"] = "both",
2612     tight: bool | None = None,
2613 ) -> None:
2614     gca().autoscale(enable=enable, axis=axis, tight=tight)
2615 
2616 
2617 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2618 @_copy_docstring_and_deprecators(Axes.axhline)
2619 def axhline(y: float = 0, xmin: float = 0, xmax: float = 1, **kwargs) -> Line2D:
2620     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2621 
2622 
2623 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2624 @_copy_docstring_and_deprecators(Axes.axhspan)
2625 def axhspan(
2626     ymin: float, ymax: float, xmin: float = 0, xmax: float = 1, **kwargs
2627 ) -> Polygon:
2628     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2629 
2630 
2631 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2632 @_copy_docstring_and_deprecators(Axes.axis)
2633 def axis(
2634     arg: tuple[float, float, float, float] | bool | str | None = None,
2635     /,
2636     *,
2637     emit: bool = True,
2638     **kwargs,
2639 ) -> tuple[float, float, float, float]:
2640     return gca().axis(arg, emit=emit, **kwargs)
2641 
2642 
2643 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2644 @_copy_docstring_and_deprecators(Axes.axline)
2645 def axline(
2646     xy1: tuple[float, float],
2647     xy2: tuple[float, float] | None = None,
2648     *,
2649     slope: float | None = None,
2650     **kwargs,
2651 ) -> Line2D:
2652     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2653 
2654 
2655 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2656 @_copy_docstring_and_deprecators(Axes.axvline)
2657 def axvline(x: float = 0, ymin: float = 0, ymax: float = 1, **kwargs) -> Line2D:
2658     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2659 
2660 
2661 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2662 @_copy_docstring_and_deprecators(Axes.axvspan)
2663 def axvspan(
2664     xmin: float, xmax: float, ymin: float = 0, ymax: float = 1, **kwargs
2665 ) -> Polygon:
2666     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2667 
2668 
2669 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2670 @_copy_docstring_and_deprecators(Axes.bar)
2671 def bar(
2672     x: float | ArrayLike,
2673     height: float | ArrayLike,
2674     width: float | ArrayLike = 0.8,
2675     bottom: float | ArrayLike | None = None,
2676     *,
2677     align: Literal["center", "edge"] = "center",
2678     data=None,
2679     **kwargs,
2680 ) -> BarContainer:
2681     return gca().bar(
2682         x,
2683         height,
2684         width=width,
2685         bottom=bottom,
2686         align=align,
2687         **({"data": data} if data is not None else {}),
2688         **kwargs,
2689     )
2690 
2691 
2692 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2693 @_copy_docstring_and_deprecators(Axes.barbs)
2694 def barbs(*args, data=None, **kwargs) -> Barbs:
2695     return gca().barbs(*args, **({"data": data} if data is not None else {}), **kwargs)
2696 
2697 
2698 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2699 @_copy_docstring_and_deprecators(Axes.barh)
2700 def barh(
2701     y: float | ArrayLike,
2702     width: float | ArrayLike,
2703     height: float | ArrayLike = 0.8,
2704     left: float | ArrayLike | None = None,
2705     *,
2706     align: Literal["center", "edge"] = "center",
2707     data=None,
2708     **kwargs,
2709 ) -> BarContainer:
2710     return gca().barh(
2711         y,
2712         width,
2713         height=height,
2714         left=left,
2715         align=align,
2716         **({"data": data} if data is not None else {}),
2717         **kwargs,
2718     )
2719 
2720 
2721 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2722 @_copy_docstring_and_deprecators(Axes.bar_label)
2723 def bar_label(
2724     container: BarContainer,
2725     labels: ArrayLike | None = None,
2726     *,
2727     fmt: str | Callable[[float], str] = "%g",
2728     label_type: Literal["center", "edge"] = "edge",
2729     padding: float = 0,
2730     **kwargs,
2731 ) -> list[Annotation]:
2732     return gca().bar_label(
2733         container,
2734         labels=labels,
2735         fmt=fmt,
2736         label_type=label_type,
2737         padding=padding,
2738         **kwargs,
2739     )
2740 
2741 
2742 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2743 @_copy_docstring_and_deprecators(Axes.boxplot)
2744 def boxplot(
2745     x: ArrayLike | Sequence[ArrayLike],
2746     notch: bool | None = None,
2747     sym: str | None = None,
2748     vert: bool | None = None,
2749     whis: float | tuple[float, float] | None = None,
2750     positions: ArrayLike | None = None,
2751     widths: float | ArrayLike | None = None,
2752     patch_artist: bool | None = None,
2753     bootstrap: int | None = None,
2754     usermedians: ArrayLike | None = None,
2755     conf_intervals: ArrayLike | None = None,
2756     meanline: bool | None = None,
2757     showmeans: bool | None = None,
2758     showcaps: bool | None = None,
2759     showbox: bool | None = None,
2760     showfliers: bool | None = None,
2761     boxprops: dict[str, Any] | None = None,
2762     labels: Sequence[str] | None = None,
2763     flierprops: dict[str, Any] | None = None,
2764     medianprops: dict[str, Any] | None = None,
2765     meanprops: dict[str, Any] | None = None,
2766     capprops: dict[str, Any] | None = None,
2767     whiskerprops: dict[str, Any] | None = None,
2768     manage_ticks: bool = True,
2769     autorange: bool = False,
2770     zorder: float | None = None,
2771     capwidths: float | ArrayLike | None = None,
2772     *,
2773     data=None,
2774 ) -> dict[str, Any]:
2775     return gca().boxplot(
2776         x,
2777         notch=notch,
2778         sym=sym,
2779         vert=vert,
2780         whis=whis,
2781         positions=positions,
2782         widths=widths,
2783         patch_artist=patch_artist,
2784         bootstrap=bootstrap,
2785         usermedians=usermedians,
2786         conf_intervals=conf_intervals,
2787         meanline=meanline,
2788         showmeans=showmeans,
2789         showcaps=showcaps,
2790         showbox=showbox,
2791         showfliers=showfliers,
2792         boxprops=boxprops,
2793         labels=labels,
2794         flierprops=flierprops,
2795         medianprops=medianprops,
2796         meanprops=meanprops,
2797         capprops=capprops,
2798         whiskerprops=whiskerprops,
2799         manage_ticks=manage_ticks,
2800         autorange=autorange,
2801         zorder=zorder,
2802         capwidths=capwidths,
2803         **({"data": data} if data is not None else {}),
2804     )
2805 
2806 
2807 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2808 @_copy_docstring_and_deprecators(Axes.broken_barh)
2809 def broken_barh(
2810     xranges: Sequence[tuple[float, float]],
2811     yrange: tuple[float, float],
2812     *,
2813     data=None,
2814     **kwargs,
2815 ) -> BrokenBarHCollection:
2816     return gca().broken_barh(
2817         xranges, yrange, **({"data": data} if data is not None else {}), **kwargs
2818     )
2819 
2820 
2821 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2822 @_copy_docstring_and_deprecators(Axes.clabel)
2823 def clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:
2824     return gca().clabel(CS, levels=levels, **kwargs)
2825 
2826 
2827 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2828 @_copy_docstring_and_deprecators(Axes.cohere)
2829 def cohere(
2830     x: ArrayLike,
2831     y: ArrayLike,
2832     NFFT: int = 256,
2833     Fs: float = 2,
2834     Fc: int = 0,
2835     detrend: Literal["none", "mean", "linear"]
2836     | Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
2837     window: Callable[[ArrayLike], ArrayLike] | ArrayLike = mlab.window_hanning,
2838     noverlap: int = 0,
2839     pad_to: int | None = None,
2840     sides: Literal["default", "onesided", "twosided"] = "default",
2841     scale_by_freq: bool | None = None,
2842     *,
2843     data=None,
2844     **kwargs,
2845 ) -> tuple[np.ndarray, np.ndarray]:
2846     return gca().cohere(
2847         x,
2848         y,
2849         NFFT=NFFT,
2850         Fs=Fs,
2851         Fc=Fc,
2852         detrend=detrend,
2853         window=window,
2854         noverlap=noverlap,
2855         pad_to=pad_to,
2856         sides=sides,
2857         scale_by_freq=scale_by_freq,
2858         **({"data": data} if data is not None else {}),
2859         **kwargs,
2860     )
2861 
2862 
2863 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2864 @_copy_docstring_and_deprecators(Axes.contour)
2865 def contour(*args, data=None, **kwargs) -> QuadContourSet:
2866     __ret = gca().contour(
2867         *args, **({"data": data} if data is not None else {}), **kwargs
2868     )
2869     if __ret._A is not None:  # type: ignore[attr-defined]
2870         sci(__ret)
2871     return __ret
2872 
2873 
2874 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2875 @_copy_docstring_and_deprecators(Axes.contourf)
2876 def contourf(*args, data=None, **kwargs) -> QuadContourSet:
2877     __ret = gca().contourf(
2878         *args, **({"data": data} if data is not None else {}), **kwargs
2879     )
2880     if __ret._A is not None:  # type: ignore[attr-defined]
2881         sci(__ret)
2882     return __ret
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.csd)
2887 def csd(
2888     x: ArrayLike,
2889     y: ArrayLike,
2890     NFFT: int | None = None,
2891     Fs: float | None = None,
2892     Fc: int | None = None,
2893     detrend: Literal["none", "mean", "linear"]
2894     | Callable[[ArrayLike], ArrayLike]
2895     | None = None,
2896     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2897     noverlap: int | None = None,
2898     pad_to: int | None = None,
2899     sides: Literal["default", "onesided", "twosided"] | None = None,
2900     scale_by_freq: bool | None = None,
2901     return_line: bool | None = None,
2902     *,
2903     data=None,
2904     **kwargs,
2905 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
2906     return gca().csd(
2907         x,
2908         y,
2909         NFFT=NFFT,
2910         Fs=Fs,
2911         Fc=Fc,
2912         detrend=detrend,
2913         window=window,
2914         noverlap=noverlap,
2915         pad_to=pad_to,
2916         sides=sides,
2917         scale_by_freq=scale_by_freq,
2918         return_line=return_line,
2919         **({"data": data} if data is not None else {}),
2920         **kwargs,
2921     )
2922 
2923 
2924 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2925 @_copy_docstring_and_deprecators(Axes.ecdf)
2926 def ecdf(
2927     x: ArrayLike,
2928     weights: ArrayLike | None = None,
2929     *,
2930     complementary: bool = False,
2931     orientation: Literal["vertical", "horizonatal"] = "vertical",
2932     compress: bool = False,
2933     data=None,
2934     **kwargs,
2935 ) -> Line2D:
2936     return gca().ecdf(
2937         x,
2938         weights=weights,
2939         complementary=complementary,
2940         orientation=orientation,
2941         compress=compress,
2942         **({"data": data} if data is not None else {}),
2943         **kwargs,
2944     )
2945 
2946 
2947 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2948 @_copy_docstring_and_deprecators(Axes.errorbar)
2949 def errorbar(
2950     x: float | ArrayLike,
2951     y: float | ArrayLike,
2952     yerr: float | ArrayLike | None = None,
2953     xerr: float | ArrayLike | None = None,
2954     fmt: str = "",
2955     ecolor: ColorType | None = None,
2956     elinewidth: float | None = None,
2957     capsize: float | None = None,
2958     barsabove: bool = False,
2959     lolims: bool = False,
2960     uplims: bool = False,
2961     xlolims: bool = False,
2962     xuplims: bool = False,
2963     errorevery: int | tuple[int, int] = 1,
2964     capthick: float | None = None,
2965     *,
2966     data=None,
2967     **kwargs,
2968 ) -> ErrorbarContainer:
2969     return gca().errorbar(
2970         x,
2971         y,
2972         yerr=yerr,
2973         xerr=xerr,
2974         fmt=fmt,
2975         ecolor=ecolor,
2976         elinewidth=elinewidth,
2977         capsize=capsize,
2978         barsabove=barsabove,
2979         lolims=lolims,
2980         uplims=uplims,
2981         xlolims=xlolims,
2982         xuplims=xuplims,
2983         errorevery=errorevery,
2984         capthick=capthick,
2985         **({"data": data} if data is not None else {}),
2986         **kwargs,
2987     )
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @_copy_docstring_and_deprecators(Axes.eventplot)
2992 def eventplot(
2993     positions: ArrayLike | Sequence[ArrayLike],
2994     orientation: Literal["horizontal", "vertical"] = "horizontal",
2995     lineoffsets: float | Sequence[float] = 1,
2996     linelengths: float | Sequence[float] = 1,
2997     linewidths: float | Sequence[float] | None = None,
2998     colors: ColorType | Sequence[ColorType] | None = None,
2999     alpha: float | Sequence[float] | None = None,
3000     linestyles: LineStyleType | Sequence[LineStyleType] = "solid",
3001     *,
3002     data=None,
3003     **kwargs,
3004 ) -> EventCollection:
3005     return gca().eventplot(
3006         positions,
3007         orientation=orientation,
3008         lineoffsets=lineoffsets,
3009         linelengths=linelengths,
3010         linewidths=linewidths,
3011         colors=colors,
3012         alpha=alpha,
3013         linestyles=linestyles,
3014         **({"data": data} if data is not None else {}),
3015         **kwargs,
3016     )
3017 
3018 
3019 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3020 @_copy_docstring_and_deprecators(Axes.fill)
3021 def fill(*args, data=None, **kwargs) -> list[Polygon]:
3022     return gca().fill(*args, **({"data": data} if data is not None else {}), **kwargs)
3023 
3024 
3025 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3026 @_copy_docstring_and_deprecators(Axes.fill_between)
3027 def fill_between(
3028     x: ArrayLike,
3029     y1: ArrayLike | float,
3030     y2: ArrayLike | float = 0,
3031     where: Sequence[bool] | None = None,
3032     interpolate: bool = False,
3033     step: Literal["pre", "post", "mid"] | None = None,
3034     *,
3035     data=None,
3036     **kwargs,
3037 ) -> PolyCollection:
3038     return gca().fill_between(
3039         x,
3040         y1,
3041         y2=y2,
3042         where=where,
3043         interpolate=interpolate,
3044         step=step,
3045         **({"data": data} if data is not None else {}),
3046         **kwargs,
3047     )
3048 
3049 
3050 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3051 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
3052 def fill_betweenx(
3053     y: ArrayLike,
3054     x1: ArrayLike | float,
3055     x2: ArrayLike | float = 0,
3056     where: Sequence[bool] | None = None,
3057     step: Literal["pre", "post", "mid"] | None = None,
3058     interpolate: bool = False,
3059     *,
3060     data=None,
3061     **kwargs,
3062 ) -> PolyCollection:
3063     return gca().fill_betweenx(
3064         y,
3065         x1,
3066         x2=x2,
3067         where=where,
3068         step=step,
3069         interpolate=interpolate,
3070         **({"data": data} if data is not None else {}),
3071         **kwargs,
3072     )
3073 
3074 
3075 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3076 @_copy_docstring_and_deprecators(Axes.grid)
3077 def grid(
3078     visible: bool | None = None,
3079     which: Literal["major", "minor", "both"] = "major",
3080     axis: Literal["both", "x", "y"] = "both",
3081     **kwargs,
3082 ) -> None:
3083     gca().grid(visible=visible, which=which, axis=axis, **kwargs)
3084 
3085 
3086 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3087 @_copy_docstring_and_deprecators(Axes.hexbin)
3088 def hexbin(
3089     x: ArrayLike,
3090     y: ArrayLike,
3091     C: ArrayLike | None = None,
3092     gridsize: int | tuple[int, int] = 100,
3093     bins: Literal["log"] | int | Sequence[float] | None = None,
3094     xscale: Literal["linear", "log"] = "linear",
3095     yscale: Literal["linear", "log"] = "linear",
3096     extent: tuple[float, float, float, float] | None = None,
3097     cmap: str | Colormap | None = None,
3098     norm: str | Normalize | None = None,
3099     vmin: float | None = None,
3100     vmax: float | None = None,
3101     alpha: float | None = None,
3102     linewidths: float | None = None,
3103     edgecolors: Literal["face", "none"] | ColorType = "face",
3104     reduce_C_function: Callable[[np.ndarray | list[float]], float] = np.mean,
3105     mincnt: int | None = None,
3106     marginals: bool = False,
3107     *,
3108     data=None,
3109     **kwargs,
3110 ) -> PolyCollection:
3111     __ret = gca().hexbin(
3112         x,
3113         y,
3114         C=C,
3115         gridsize=gridsize,
3116         bins=bins,
3117         xscale=xscale,
3118         yscale=yscale,
3119         extent=extent,
3120         cmap=cmap,
3121         norm=norm,
3122         vmin=vmin,
3123         vmax=vmax,
3124         alpha=alpha,
3125         linewidths=linewidths,
3126         edgecolors=edgecolors,
3127         reduce_C_function=reduce_C_function,
3128         mincnt=mincnt,
3129         marginals=marginals,
3130         **({"data": data} if data is not None else {}),
3131         **kwargs,
3132     )
3133     sci(__ret)
3134     return __ret
3135 
3136 
3137 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3138 @_copy_docstring_and_deprecators(Axes.hist)
3139 def hist(
3140     x: ArrayLike | Sequence[ArrayLike],
3141     bins: int | Sequence[float] | str | None = None,
3142     range: tuple[float, float] | None = None,
3143     density: bool = False,
3144     weights: ArrayLike | None = None,
3145     cumulative: bool | float = False,
3146     bottom: ArrayLike | float | None = None,
3147     histtype: Literal["bar", "barstacked", "step", "stepfilled"] = "bar",
3148     align: Literal["left", "mid", "right"] = "mid",
3149     orientation: Literal["vertical", "horizontal"] = "vertical",
3150     rwidth: float | None = None,
3151     log: bool = False,
3152     color: ColorType | Sequence[ColorType] | None = None,
3153     label: str | Sequence[str] | None = None,
3154     stacked: bool = False,
3155     *,
3156     data=None,
3157     **kwargs,
3158 ) -> tuple[
3159     np.ndarray | list[np.ndarray],
3160     np.ndarray,
3161     BarContainer | Polygon | list[BarContainer | Polygon],
3162 ]:
3163     return gca().hist(
3164         x,
3165         bins=bins,
3166         range=range,
3167         density=density,
3168         weights=weights,
3169         cumulative=cumulative,
3170         bottom=bottom,
3171         histtype=histtype,
3172         align=align,
3173         orientation=orientation,
3174         rwidth=rwidth,
3175         log=log,
3176         color=color,
3177         label=label,
3178         stacked=stacked,
3179         **({"data": data} if data is not None else {}),
3180         **kwargs,
3181     )
3182 
3183 
3184 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3185 @_copy_docstring_and_deprecators(Axes.stairs)
3186 def stairs(
3187     values: ArrayLike,
3188     edges: ArrayLike | None = None,
3189     *,
3190     orientation: Literal["vertical", "horizontal"] = "vertical",
3191     baseline: float | ArrayLike | None = 0,
3192     fill: bool = False,
3193     data=None,
3194     **kwargs,
3195 ) -> StepPatch:
3196     return gca().stairs(
3197         values,
3198         edges=edges,
3199         orientation=orientation,
3200         baseline=baseline,
3201         fill=fill,
3202         **({"data": data} if data is not None else {}),
3203         **kwargs,
3204     )
3205 
3206 
3207 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3208 @_copy_docstring_and_deprecators(Axes.hist2d)
3209 def hist2d(
3210     x: ArrayLike,
3211     y: ArrayLike,
3212     bins: None | int | tuple[int, int] | ArrayLike | tuple[ArrayLike, ArrayLike] = 10,
3213     range: ArrayLike | None = None,
3214     density: bool = False,
3215     weights: ArrayLike | None = None,
3216     cmin: float | None = None,
3217     cmax: float | None = None,
3218     *,
3219     data=None,
3220     **kwargs,
3221 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, QuadMesh]:
3222     __ret = gca().hist2d(
3223         x,
3224         y,
3225         bins=bins,
3226         range=range,
3227         density=density,
3228         weights=weights,
3229         cmin=cmin,
3230         cmax=cmax,
3231         **({"data": data} if data is not None else {}),
3232         **kwargs,
3233     )
3234     sci(__ret[-1])
3235     return __ret
3236 
3237 
3238 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3239 @_copy_docstring_and_deprecators(Axes.hlines)
3240 def hlines(
3241     y: float | ArrayLike,
3242     xmin: float | ArrayLike,
3243     xmax: float | ArrayLike,
3244     colors: ColorType | Sequence[ColorType] | None = None,
3245     linestyles: LineStyleType = "solid",
3246     label: str = "",
3247     *,
3248     data=None,
3249     **kwargs,
3250 ) -> LineCollection:
3251     return gca().hlines(
3252         y,
3253         xmin,
3254         xmax,
3255         colors=colors,
3256         linestyles=linestyles,
3257         label=label,
3258         **({"data": data} if data is not None else {}),
3259         **kwargs,
3260     )
3261 
3262 
3263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3264 @_copy_docstring_and_deprecators(Axes.imshow)
3265 def imshow(
3266     X: ArrayLike | PIL.Image.Image,
3267     cmap: str | Colormap | None = None,
3268     norm: str | Normalize | None = None,
3269     *,
3270     aspect: Literal["equal", "auto"] | float | None = None,
3271     interpolation: str | None = None,
3272     alpha: float | ArrayLike | None = None,
3273     vmin: float | None = None,
3274     vmax: float | None = None,
3275     origin: Literal["upper", "lower"] | None = None,
3276     extent: tuple[float, float, float, float] | None = None,
3277     interpolation_stage: Literal["data", "rgba"] | None = None,
3278     filternorm: bool = True,
3279     filterrad: float = 4.0,
3280     resample: bool | None = None,
3281     url: str | None = None,
3282     data=None,
3283     **kwargs,
3284 ) -> AxesImage:
3285     __ret = gca().imshow(
3286         X,
3287         cmap=cmap,
3288         norm=norm,
3289         aspect=aspect,
3290         interpolation=interpolation,
3291         alpha=alpha,
3292         vmin=vmin,
3293         vmax=vmax,
3294         origin=origin,
3295         extent=extent,
3296         interpolation_stage=interpolation_stage,
3297         filternorm=filternorm,
3298         filterrad=filterrad,
3299         resample=resample,
3300         url=url,
3301         **({"data": data} if data is not None else {}),
3302         **kwargs,
3303     )
3304     sci(__ret)
3305     return __ret
3306 
3307 
3308 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3309 @_copy_docstring_and_deprecators(Axes.legend)
3310 def legend(*args, **kwargs) -> Legend:
3311     return gca().legend(*args, **kwargs)
3312 
3313 
3314 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3315 @_copy_docstring_and_deprecators(Axes.locator_params)
3316 def locator_params(
3317     axis: Literal["both", "x", "y"] = "both", tight: bool | None = None, **kwargs
3318 ) -> None:
3319     gca().locator_params(axis=axis, tight=tight, **kwargs)
3320 
3321 
3322 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3323 @_copy_docstring_and_deprecators(Axes.loglog)
3324 def loglog(*args, **kwargs) -> list[Line2D]:
3325     return gca().loglog(*args, **kwargs)
3326 
3327 
3328 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3329 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
3330 def magnitude_spectrum(
3331     x: ArrayLike,
3332     Fs: float | None = None,
3333     Fc: int | None = None,
3334     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3335     pad_to: int | None = None,
3336     sides: Literal["default", "onesided", "twosided"] | None = None,
3337     scale: Literal["default", "linear", "dB"] | None = None,
3338     *,
3339     data=None,
3340     **kwargs,
3341 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3342     return gca().magnitude_spectrum(
3343         x,
3344         Fs=Fs,
3345         Fc=Fc,
3346         window=window,
3347         pad_to=pad_to,
3348         sides=sides,
3349         scale=scale,
3350         **({"data": data} if data is not None else {}),
3351         **kwargs,
3352     )
3353 
3354 
3355 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3356 @_copy_docstring_and_deprecators(Axes.margins)
3357 def margins(
3358     *margins: float,
3359     x: float | None = None,
3360     y: float | None = None,
3361     tight: bool | None = True,
3362 ) -> tuple[float, float] | None:
3363     return gca().margins(*margins, x=x, y=y, tight=tight)
3364 
3365 
3366 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3367 @_copy_docstring_and_deprecators(Axes.minorticks_off)
3368 def minorticks_off() -> None:
3369     gca().minorticks_off()
3370 
3371 
3372 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3373 @_copy_docstring_and_deprecators(Axes.minorticks_on)
3374 def minorticks_on() -> None:
3375     gca().minorticks_on()
3376 
3377 
3378 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3379 @_copy_docstring_and_deprecators(Axes.pcolor)
3380 def pcolor(
3381     *args: ArrayLike,
3382     shading: Literal["flat", "nearest", "auto"] | None = None,
3383     alpha: float | None = None,
3384     norm: str | Normalize | None = None,
3385     cmap: str | Colormap | None = None,
3386     vmin: float | None = None,
3387     vmax: float | None = None,
3388     data=None,
3389     **kwargs,
3390 ) -> Collection:
3391     __ret = gca().pcolor(
3392         *args,
3393         shading=shading,
3394         alpha=alpha,
3395         norm=norm,
3396         cmap=cmap,
3397         vmin=vmin,
3398         vmax=vmax,
3399         **({"data": data} if data is not None else {}),
3400         **kwargs,
3401     )
3402     sci(__ret)
3403     return __ret
3404 
3405 
3406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3407 @_copy_docstring_and_deprecators(Axes.pcolormesh)
3408 def pcolormesh(
3409     *args: ArrayLike,
3410     alpha: float | None = None,
3411     norm: str | Normalize | None = None,
3412     cmap: str | Colormap | None = None,
3413     vmin: float | None = None,
3414     vmax: float | None = None,
3415     shading: Literal["flat", "nearest", "gouraud", "auto"] | None = None,
3416     antialiased: bool = False,
3417     data=None,
3418     **kwargs,
3419 ) -> QuadMesh:
3420     __ret = gca().pcolormesh(
3421         *args,
3422         alpha=alpha,
3423         norm=norm,
3424         cmap=cmap,
3425         vmin=vmin,
3426         vmax=vmax,
3427         shading=shading,
3428         antialiased=antialiased,
3429         **({"data": data} if data is not None else {}),
3430         **kwargs,
3431     )
3432     sci(__ret)
3433     return __ret
3434 
3435 
3436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3437 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
3438 def phase_spectrum(
3439     x: ArrayLike,
3440     Fs: float | None = None,
3441     Fc: int | None = None,
3442     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3443     pad_to: int | None = None,
3444     sides: Literal["default", "onesided", "twosided"] | None = None,
3445     *,
3446     data=None,
3447     **kwargs,
3448 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3449     return gca().phase_spectrum(
3450         x,
3451         Fs=Fs,
3452         Fc=Fc,
3453         window=window,
3454         pad_to=pad_to,
3455         sides=sides,
3456         **({"data": data} if data is not None else {}),
3457         **kwargs,
3458     )
3459 
3460 
3461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3462 @_copy_docstring_and_deprecators(Axes.pie)
3463 def pie(
3464     x: ArrayLike,
3465     explode: ArrayLike | None = None,
3466     labels: Sequence[str] | None = None,
3467     colors: ColorType | Sequence[ColorType] | None = None,
3468     autopct: str | Callable[[float], str] | None = None,
3469     pctdistance: float = 0.6,
3470     shadow: bool = False,
3471     labeldistance: float | None = 1.1,
3472     startangle: float = 0,
3473     radius: float = 1,
3474     counterclock: bool = True,
3475     wedgeprops: dict[str, Any] | None = None,
3476     textprops: dict[str, Any] | None = None,
3477     center: tuple[float, float] = (0, 0),
3478     frame: bool = False,
3479     rotatelabels: bool = False,
3480     *,
3481     normalize: bool = True,
3482     hatch: str | Sequence[str] | None = None,
3483     data=None,
3484 ) -> tuple[list[Wedge], list[Text]] | tuple[list[Wedge], list[Text], list[Text]]:
3485     return gca().pie(
3486         x,
3487         explode=explode,
3488         labels=labels,
3489         colors=colors,
3490         autopct=autopct,
3491         pctdistance=pctdistance,
3492         shadow=shadow,
3493         labeldistance=labeldistance,
3494         startangle=startangle,
3495         radius=radius,
3496         counterclock=counterclock,
3497         wedgeprops=wedgeprops,
3498         textprops=textprops,
3499         center=center,
3500         frame=frame,
3501         rotatelabels=rotatelabels,
3502         normalize=normalize,
3503         hatch=hatch,
3504         **({"data": data} if data is not None else {}),
3505     )
3506 
3507 
3508 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3509 @_copy_docstring_and_deprecators(Axes.plot)
3510 def plot(
3511     *args: float | ArrayLike | str,
3512     scalex: bool = True,
3513     scaley: bool = True,
3514     data=None,
3515     **kwargs,
3516 ) -> list[Line2D]:
3517     return gca().plot(
3518         *args,
3519         scalex=scalex,
3520         scaley=scaley,
3521         **({"data": data} if data is not None else {}),
3522         **kwargs,
3523     )
3524 
3525 
3526 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3527 @_copy_docstring_and_deprecators(Axes.plot_date)
3528 def plot_date(
3529     x: ArrayLike,
3530     y: ArrayLike,
3531     fmt: str = "o",
3532     tz: str | datetime.tzinfo | None = None,
3533     xdate: bool = True,
3534     ydate: bool = False,
3535     *,
3536     data=None,
3537     **kwargs,
3538 ) -> list[Line2D]:
3539     return gca().plot_date(
3540         x,
3541         y,
3542         fmt=fmt,
3543         tz=tz,
3544         xdate=xdate,
3545         ydate=ydate,
3546         **({"data": data} if data is not None else {}),
3547         **kwargs,
3548     )
3549 
3550 
3551 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3552 @_copy_docstring_and_deprecators(Axes.psd)
3553 def psd(
3554     x: ArrayLike,
3555     NFFT: int | None = None,
3556     Fs: float | None = None,
3557     Fc: int | None = None,
3558     detrend: Literal["none", "mean", "linear"]
3559     | Callable[[ArrayLike], ArrayLike]
3560     | None = None,
3561     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3562     noverlap: int | None = None,
3563     pad_to: int | None = None,
3564     sides: Literal["default", "onesided", "twosided"] | None = None,
3565     scale_by_freq: bool | None = None,
3566     return_line: bool | None = None,
3567     *,
3568     data=None,
3569     **kwargs,
3570 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
3571     return gca().psd(
3572         x,
3573         NFFT=NFFT,
3574         Fs=Fs,
3575         Fc=Fc,
3576         detrend=detrend,
3577         window=window,
3578         noverlap=noverlap,
3579         pad_to=pad_to,
3580         sides=sides,
3581         scale_by_freq=scale_by_freq,
3582         return_line=return_line,
3583         **({"data": data} if data is not None else {}),
3584         **kwargs,
3585     )
3586 
3587 
3588 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3589 @_copy_docstring_and_deprecators(Axes.quiver)
3590 def quiver(*args, data=None, **kwargs) -> Quiver:
3591     __ret = gca().quiver(
3592         *args, **({"data": data} if data is not None else {}), **kwargs
3593     )
3594     sci(__ret)
3595     return __ret
3596 
3597 
3598 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3599 @_copy_docstring_and_deprecators(Axes.quiverkey)
3600 def quiverkey(
3601     Q: Quiver, X: float, Y: float, U: float, label: str, **kwargs
3602 ) -> QuiverKey:
3603     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
3604 
3605 
3606 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3607 @_copy_docstring_and_deprecators(Axes.scatter)
3608 def scatter(
3609     x: float | ArrayLike,
3610     y: float | ArrayLike,
3611     s: float | ArrayLike | None = None,
3612     c: Sequence[ColorType] | ColorType | None = None,
3613     marker: MarkerType | None = None,
3614     cmap: str | Colormap | None = None,
3615     norm: str | Normalize | None = None,
3616     vmin: float | None = None,
3617     vmax: float | None = None,
3618     alpha: float | None = None,
3619     linewidths: float | Sequence[float] | None = None,
3620     *,
3621     edgecolors: Literal["face", "none"] | ColorType | Sequence[ColorType] | None = None,
3622     plotnonfinite: bool = False,
3623     data=None,
3624     **kwargs,
3625 ) -> PathCollection:
3626     __ret = gca().scatter(
3627         x,
3628         y,
3629         s=s,
3630         c=c,
3631         marker=marker,
3632         cmap=cmap,
3633         norm=norm,
3634         vmin=vmin,
3635         vmax=vmax,
3636         alpha=alpha,
3637         linewidths=linewidths,
3638         edgecolors=edgecolors,
3639         plotnonfinite=plotnonfinite,
3640         **({"data": data} if data is not None else {}),
3641         **kwargs,
3642     )
3643     sci(__ret)
3644     return __ret
3645 
3646 
3647 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3648 @_copy_docstring_and_deprecators(Axes.semilogx)
3649 def semilogx(*args, **kwargs) -> list[Line2D]:
3650     return gca().semilogx(*args, **kwargs)
3651 
3652 
3653 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3654 @_copy_docstring_and_deprecators(Axes.semilogy)
3655 def semilogy(*args, **kwargs) -> list[Line2D]:
3656     return gca().semilogy(*args, **kwargs)
3657 
3658 
3659 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3660 @_copy_docstring_and_deprecators(Axes.specgram)
3661 def specgram(
3662     x: ArrayLike,
3663     NFFT: int | None = None,
3664     Fs: float | None = None,
3665     Fc: int | None = None,
3666     detrend: Literal["none", "mean", "linear"]
3667     | Callable[[ArrayLike], ArrayLike]
3668     | None = None,
3669     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3670     noverlap: int | None = None,
3671     cmap: str | Colormap | None = None,
3672     xextent: tuple[float, float] | None = None,
3673     pad_to: int | None = None,
3674     sides: Literal["default", "onesided", "twosided"] | None = None,
3675     scale_by_freq: bool | None = None,
3676     mode: Literal["default", "psd", "magnitude", "angle", "phase"] | None = None,
3677     scale: Literal["default", "linear", "dB"] | None = None,
3678     vmin: float | None = None,
3679     vmax: float | None = None,
3680     *,
3681     data=None,
3682     **kwargs,
3683 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, AxesImage]:
3684     __ret = gca().specgram(
3685         x,
3686         NFFT=NFFT,
3687         Fs=Fs,
3688         Fc=Fc,
3689         detrend=detrend,
3690         window=window,
3691         noverlap=noverlap,
3692         cmap=cmap,
3693         xextent=xextent,
3694         pad_to=pad_to,
3695         sides=sides,
3696         scale_by_freq=scale_by_freq,
3697         mode=mode,
3698         scale=scale,
3699         vmin=vmin,
3700         vmax=vmax,
3701         **({"data": data} if data is not None else {}),
3702         **kwargs,
3703     )
3704     sci(__ret[-1])
3705     return __ret
3706 
3707 
3708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3709 @_copy_docstring_and_deprecators(Axes.spy)
3710 def spy(
3711     Z: ArrayLike,
3712     precision: float | Literal["present"] = 0,
3713     marker: str | None = None,
3714     markersize: float | None = None,
3715     aspect: Literal["equal", "auto"] | float | None = "equal",
3716     origin: Literal["upper", "lower"] = "upper",
3717     **kwargs,
3718 ) -> AxesImage:
3719     __ret = gca().spy(
3720         Z,
3721         precision=precision,
3722         marker=marker,
3723         markersize=markersize,
3724         aspect=aspect,
3725         origin=origin,
3726         **kwargs,
3727     )
3728     if isinstance(__ret, cm.ScalarMappable):
3729         sci(__ret)  # noqa
3730     return __ret
3731 
3732 
3733 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3734 @_copy_docstring_and_deprecators(Axes.stackplot)
3735 def stackplot(x, *args, labels=(), colors=None, baseline="zero", data=None, **kwargs):
3736     return gca().stackplot(
3737         x,
3738         *args,
3739         labels=labels,
3740         colors=colors,
3741         baseline=baseline,
3742         **({"data": data} if data is not None else {}),
3743         **kwargs,
3744     )
3745 
3746 
3747 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3748 @_copy_docstring_and_deprecators(Axes.stem)
3749 def stem(
3750     *args: ArrayLike | str,
3751     linefmt: str | None = None,
3752     markerfmt: str | None = None,
3753     basefmt: str | None = None,
3754     bottom: float = 0,
3755     label: str | None = None,
3756     orientation: Literal["vertical", "horizontal"] = "vertical",
3757     data=None,
3758 ) -> StemContainer:
3759     return gca().stem(
3760         *args,
3761         linefmt=linefmt,
3762         markerfmt=markerfmt,
3763         basefmt=basefmt,
3764         bottom=bottom,
3765         label=label,
3766         orientation=orientation,
3767         **({"data": data} if data is not None else {}),
3768     )
3769 
3770 
3771 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3772 @_copy_docstring_and_deprecators(Axes.step)
3773 def step(
3774     x: ArrayLike,
3775     y: ArrayLike,
3776     *args,
3777     where: Literal["pre", "post", "mid"] = "pre",
3778     data=None,
3779     **kwargs,
3780 ) -> list[Line2D]:
3781     return gca().step(
3782         x,
3783         y,
3784         *args,
3785         where=where,
3786         **({"data": data} if data is not None else {}),
3787         **kwargs,
3788     )
3789 
3790 
3791 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3792 @_copy_docstring_and_deprecators(Axes.streamplot)
3793 def streamplot(
3794     x,
3795     y,
3796     u,
3797     v,
3798     density=1,
3799     linewidth=None,
3800     color=None,
3801     cmap=None,
3802     norm=None,
3803     arrowsize=1,
3804     arrowstyle="-|>",
3805     minlength=0.1,
3806     transform=None,
3807     zorder=None,
3808     start_points=None,
3809     maxlength=4.0,
3810     integration_direction="both",
3811     broken_streamlines=True,
3812     *,
3813     data=None,
3814 ):
3815     __ret = gca().streamplot(
3816         x,
3817         y,
3818         u,
3819         v,
3820         density=density,
3821         linewidth=linewidth,
3822         color=color,
3823         cmap=cmap,
3824         norm=norm,
3825         arrowsize=arrowsize,
3826         arrowstyle=arrowstyle,
3827         minlength=minlength,
3828         transform=transform,
3829         zorder=zorder,
3830         start_points=start_points,
3831         maxlength=maxlength,
3832         integration_direction=integration_direction,
3833         broken_streamlines=broken_streamlines,
3834         **({"data": data} if data is not None else {}),
3835     )
3836     sci(__ret.lines)
3837     return __ret
3838 
3839 
3840 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3841 @_copy_docstring_and_deprecators(Axes.table)
3842 def table(
3843     cellText=None,
3844     cellColours=None,
3845     cellLoc="right",
3846     colWidths=None,
3847     rowLabels=None,
3848     rowColours=None,
3849     rowLoc="left",
3850     colLabels=None,
3851     colColours=None,
3852     colLoc="center",
3853     loc="bottom",
3854     bbox=None,
3855     edges="closed",
3856     **kwargs,
3857 ):
3858     return gca().table(
3859         cellText=cellText,
3860         cellColours=cellColours,
3861         cellLoc=cellLoc,
3862         colWidths=colWidths,
3863         rowLabels=rowLabels,
3864         rowColours=rowColours,
3865         rowLoc=rowLoc,
3866         colLabels=colLabels,
3867         colColours=colColours,
3868         colLoc=colLoc,
3869         loc=loc,
3870         bbox=bbox,
3871         edges=edges,
3872         **kwargs,
3873     )
3874 
3875 
3876 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3877 @_copy_docstring_and_deprecators(Axes.text)
3878 def text(
3879     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
3880 ) -> Text:
3881     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
3882 
3883 
3884 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3885 @_copy_docstring_and_deprecators(Axes.tick_params)
3886 def tick_params(axis: Literal["both", "x", "y"] = "both", **kwargs) -> None:
3887     gca().tick_params(axis=axis, **kwargs)
3888 
3889 
3890 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3891 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
3892 def ticklabel_format(
3893     *,
3894     axis: Literal["both", "x", "y"] = "both",
3895     style: Literal["", "sci", "scientific", "plain"] = "",
3896     scilimits: tuple[int, int] | None = None,
3897     useOffset: bool | float | None = None,
3898     useLocale: bool | None = None,
3899     useMathText: bool | None = None,
3900 ) -> None:
3901     gca().ticklabel_format(
3902         axis=axis,
3903         style=style,
3904         scilimits=scilimits,
3905         useOffset=useOffset,
3906         useLocale=useLocale,
3907         useMathText=useMathText,
3908     )
3909 
3910 
3911 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3912 @_copy_docstring_and_deprecators(Axes.tricontour)
3913 def tricontour(*args, **kwargs):
3914     __ret = gca().tricontour(*args, **kwargs)
3915     if __ret._A is not None:  # type: ignore[attr-defined]
3916         sci(__ret)
3917     return __ret
3918 
3919 
3920 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3921 @_copy_docstring_and_deprecators(Axes.tricontourf)
3922 def tricontourf(*args, **kwargs):
3923     __ret = gca().tricontourf(*args, **kwargs)
3924     if __ret._A is not None:  # type: ignore[attr-defined]
3925         sci(__ret)
3926     return __ret
3927 
3928 
3929 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3930 @_copy_docstring_and_deprecators(Axes.tripcolor)
3931 def tripcolor(
3932     *args,
3933     alpha=1.0,
3934     norm=None,
3935     cmap=None,
3936     vmin=None,
3937     vmax=None,
3938     shading="flat",
3939     facecolors=None,
3940     **kwargs,
3941 ):
3942     __ret = gca().tripcolor(
3943         *args,
3944         alpha=alpha,
3945         norm=norm,
3946         cmap=cmap,
3947         vmin=vmin,
3948         vmax=vmax,
3949         shading=shading,
3950         facecolors=facecolors,
3951         **kwargs,
3952     )
3953     sci(__ret)
3954     return __ret
3955 
3956 
3957 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3958 @_copy_docstring_and_deprecators(Axes.triplot)
3959 def triplot(*args, **kwargs):
3960     return gca().triplot(*args, **kwargs)
3961 
3962 
3963 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3964 @_copy_docstring_and_deprecators(Axes.violinplot)
3965 def violinplot(
3966     dataset: ArrayLike | Sequence[ArrayLike],
3967     positions: ArrayLike | None = None,
3968     vert: bool = True,
3969     widths: float | ArrayLike = 0.5,
3970     showmeans: bool = False,
3971     showextrema: bool = True,
3972     showmedians: bool = False,
3973     quantiles: Sequence[float | Sequence[float]] | None = None,
3974     points: int = 100,
3975     bw_method: Literal["scott", "silverman"]
3976     | float
3977     | Callable[[GaussianKDE], float]
3978     | None = None,
3979     *,
3980     data=None,
3981 ) -> dict[str, Collection]:
3982     return gca().violinplot(
3983         dataset,
3984         positions=positions,
3985         vert=vert,
3986         widths=widths,
3987         showmeans=showmeans,
3988         showextrema=showextrema,
3989         showmedians=showmedians,
3990         quantiles=quantiles,
3991         points=points,
3992         bw_method=bw_method,
3993         **({"data": data} if data is not None else {}),
3994     )
3995 
3996 
3997 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3998 @_copy_docstring_and_deprecators(Axes.vlines)
3999 def vlines(
4000     x: float | ArrayLike,
4001     ymin: float | ArrayLike,
4002     ymax: float | ArrayLike,
4003     colors: ColorType | Sequence[ColorType] | None = None,
4004     linestyles: LineStyleType = "solid",
4005     label: str = "",
4006     *,
4007     data=None,
4008     **kwargs,
4009 ) -> LineCollection:
4010     return gca().vlines(
4011         x,
4012         ymin,
4013         ymax,
4014         colors=colors,
4015         linestyles=linestyles,
4016         label=label,
4017         **({"data": data} if data is not None else {}),
4018         **kwargs,
4019     )
4020 
4021 
4022 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4023 @_copy_docstring_and_deprecators(Axes.xcorr)
4024 def xcorr(
4025     x: ArrayLike,
4026     y: ArrayLike,
4027     normed: bool = True,
4028     detrend: Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
4029     usevlines: bool = True,
4030     maxlags: int = 10,
4031     *,
4032     data=None,
4033     **kwargs,
4034 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
4035     return gca().xcorr(
4036         x,
4037         y,
4038         normed=normed,
4039         detrend=detrend,
4040         usevlines=usevlines,
4041         maxlags=maxlags,
4042         **({"data": data} if data is not None else {}),
4043         **kwargs,
4044     )
4045 
4046 
4047 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4048 @_copy_docstring_and_deprecators(Axes._sci)
4049 def sci(im: ScalarMappable) -> None:
4050     gca()._sci(im)
4051 
4052 
4053 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4054 @_copy_docstring_and_deprecators(Axes.set_title)
4055 def title(
4056     label: str,
4057     fontdict: dict[str, Any] | None = None,
4058     loc: Literal["left", "center", "right"] | None = None,
4059     pad: float | None = None,
4060     *,
4061     y: float | None = None,
4062     **kwargs,
4063 ) -> Text:
4064     return gca().set_title(label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
4065 
4066 
4067 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4068 @_copy_docstring_and_deprecators(Axes.set_xlabel)
4069 def xlabel(
4070     xlabel: str,
4071     fontdict: dict[str, Any] | None = None,
4072     labelpad: float | None = None,
4073     *,
4074     loc: Literal["left", "center", "right"] | None = None,
4075     **kwargs,
4076 ) -> Text:
4077     return gca().set_xlabel(
4078         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4079     )
4080 
4081 
4082 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4083 @_copy_docstring_and_deprecators(Axes.set_ylabel)
4084 def ylabel(
4085     ylabel: str,
4086     fontdict: dict[str, Any] | None = None,
4087     labelpad: float | None = None,
4088     *,
4089     loc: Literal["bottom", "center", "top"] | None = None,
4090     **kwargs,
4091 ) -> Text:
4092     return gca().set_ylabel(
4093         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4094     )
4095 
4096 
4097 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4098 @_copy_docstring_and_deprecators(Axes.set_xscale)
4099 def xscale(value: str | ScaleBase, **kwargs) -> None:
4100     gca().set_xscale(value, **kwargs)
4101 
4102 
4103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4104 @_copy_docstring_and_deprecators(Axes.set_yscale)
4105 def yscale(value: str | ScaleBase, **kwargs) -> None:
4106     gca().set_yscale(value, **kwargs)
4107 
4108 
4109 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4110 def autumn() -> None:
4111     """
4112     Set the colormap to 'autumn'.
4113 
4114     This changes the default colormap as well as the colormap of the current
4115     image if there is one. See ``help(colormaps)`` for more information.
4116     """
4117     set_cmap("autumn")
4118 
4119 
4120 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4121 def bone() -> None:
4122     """
4123     Set the colormap to 'bone'.
4124 
4125     This changes the default colormap as well as the colormap of the current
4126     image if there is one. See ``help(colormaps)`` for more information.
4127     """
4128     set_cmap("bone")
4129 
4130 
4131 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4132 def cool() -> None:
4133     """
4134     Set the colormap to 'cool'.
4135 
4136     This changes the default colormap as well as the colormap of the current
4137     image if there is one. See ``help(colormaps)`` for more information.
4138     """
4139     set_cmap("cool")
4140 
4141 
4142 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4143 def copper() -> None:
4144     """
4145     Set the colormap to 'copper'.
4146 
4147     This changes the default colormap as well as the colormap of the current
4148     image if there is one. See ``help(colormaps)`` for more information.
4149     """
4150     set_cmap("copper")
4151 
4152 
4153 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4154 def flag() -> None:
4155     """
4156     Set the colormap to 'flag'.
4157 
4158     This changes the default colormap as well as the colormap of the current
4159     image if there is one. See ``help(colormaps)`` for more information.
4160     """
4161     set_cmap("flag")
4162 
4163 
4164 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4165 def gray() -> None:
4166     """
4167     Set the colormap to 'gray'.
4168 
4169     This changes the default colormap as well as the colormap of the current
4170     image if there is one. See ``help(colormaps)`` for more information.
4171     """
4172     set_cmap("gray")
4173 
4174 
4175 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4176 def hot() -> None:
4177     """
4178     Set the colormap to 'hot'.
4179 
4180     This changes the default colormap as well as the colormap of the current
4181     image if there is one. See ``help(colormaps)`` for more information.
4182     """
4183     set_cmap("hot")
4184 
4185 
4186 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4187 def hsv() -> None:
4188     """
4189     Set the colormap to 'hsv'.
4190 
4191     This changes the default colormap as well as the colormap of the current
4192     image if there is one. See ``help(colormaps)`` for more information.
4193     """
4194     set_cmap("hsv")
4195 
4196 
4197 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4198 def jet() -> None:
4199     """
4200     Set the colormap to 'jet'.
4201 
4202     This changes the default colormap as well as the colormap of the current
4203     image if there is one. See ``help(colormaps)`` for more information.
4204     """
4205     set_cmap("jet")
4206 
4207 
4208 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4209 def pink() -> None:
4210     """
4211     Set the colormap to 'pink'.
4212 
4213     This changes the default colormap as well as the colormap of the current
4214     image if there is one. See ``help(colormaps)`` for more information.
4215     """
4216     set_cmap("pink")
4217 
4218 
4219 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4220 def prism() -> None:
4221     """
4222     Set the colormap to 'prism'.
4223 
4224     This changes the default colormap as well as the colormap of the current
4225     image if there is one. See ``help(colormaps)`` for more information.
4226     """
4227     set_cmap("prism")
4228 
4229 
4230 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4231 def spring() -> None:
4232     """
4233     Set the colormap to 'spring'.
4234 
4235     This changes the default colormap as well as the colormap of the current
4236     image if there is one. See ``help(colormaps)`` for more information.
4237     """
4238     set_cmap("spring")
4239 
4240 
4241 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4242 def summer() -> None:
4243     """
4244     Set the colormap to 'summer'.
4245 
4246     This changes the default colormap as well as the colormap of the current
4247     image if there is one. See ``help(colormaps)`` for more information.
4248     """
4249     set_cmap("summer")
4250 
4251 
4252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4253 def winter() -> None:
4254     """
4255     Set the colormap to 'winter'.
4256 
4257     This changes the default colormap as well as the colormap of the current
4258     image if there is one. See ``help(colormaps)`` for more information.
4259     """
4260     set_cmap("winter")
4261 
4262 
4263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4264 def magma() -> None:
4265     """
4266     Set the colormap to 'magma'.
4267 
4268     This changes the default colormap as well as the colormap of the current
4269     image if there is one. See ``help(colormaps)`` for more information.
4270     """
4271     set_cmap("magma")
4272 
4273 
4274 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4275 def inferno() -> None:
4276     """
4277     Set the colormap to 'inferno'.
4278 
4279     This changes the default colormap as well as the colormap of the current
4280     image if there is one. See ``help(colormaps)`` for more information.
4281     """
4282     set_cmap("inferno")
4283 
4284 
4285 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4286 def plasma() -> None:
4287     """
4288     Set the colormap to 'plasma'.
4289 
4290     This changes the default colormap as well as the colormap of the current
4291     image if there is one. See ``help(colormaps)`` for more information.
4292     """
4293     set_cmap("plasma")
4294 
4295 
4296 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4297 def viridis() -> None:
4298     """
4299     Set the colormap to 'viridis'.
4300 
4301     This changes the default colormap as well as the colormap of the current
4302     image if there is one. See ``help(colormaps)`` for more information.
4303     """
4304     set_cmap("viridis")
4305 
4306 
4307 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4308 def nipy_spectral() -> None:
4309     """
4310     Set the colormap to 'nipy_spectral'.
4311 
4312     This changes the default colormap as well as the colormap of the current
4313     image if there is one. See ``help(colormaps)`` for more information.
4314     """
4315     set_cmap("nipy_spectral")

</code><intended_behavior>In `pyplot.py`, adjustments should be made to ensure that backend switching via `%matplotlib` magic does not interfere with the visibility of GUI windows created under different backends. Specifically, this involves preserving the state of GUI windows upon backend switches. Methods related to backend switching and interactive mode toggling (`ion()`, `ioff()`) may need to be modified to check the current backend and manage GUI windows accordingly, without closing them unintentionally. The exact implementation would depend on identifying a method to tag certain figures to remain unaffected by backend changes or maintaining a global state of figures that should not be closed upon backend switches.</intended_behavior>, <file>lib/matplotlib/backend_bases.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Abstract base classes define the primitives that renderers and
3 graphics contexts must implement to serve as a Matplotlib backend.
4 
5 `RendererBase`
6     An abstract base class to handle drawing/rendering operations.
7 
8 `FigureCanvasBase`
9     The abstraction layer that separates the `.Figure` from the backend
10     specific details like a user interface drawing area.
11 
12 `GraphicsContextBase`
13     An abstract base class that provides color, line styles, etc.
14 
15 `Event`
16     The base class for all of the Matplotlib event handling.  Derived classes
17     such as `KeyEvent` and `MouseEvent` store the meta data like keys and
18     buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates.
19 
20 `ShowBase`
21     The base class for the ``Show`` class of each interactive backend; the
22     'show' callable is then set to ``Show.__call__``.
23 
24 `ToolContainerBase`
25     The base class for the Toolbar class of each interactive backend.
26 """
27 
28 from collections import namedtuple
29 from contextlib import ExitStack, contextmanager, nullcontext
30 from enum import Enum, IntEnum
31 import functools
32 import importlib
33 import inspect
34 import io
35 import itertools
36 import logging
37 import os
38 import sys
39 import time
40 import weakref
41 from weakref import WeakKeyDictionary
42 
43 import numpy as np
44 
45 import matplotlib as mpl
46 from matplotlib import (
47     _api, backend_tools as tools, cbook, colors, _docstring, text,
48     _tight_bbox, transforms, widgets, get_backend, is_interactive, rcParams)
49 from matplotlib._pylab_helpers import Gcf
50 from matplotlib.backend_managers import ToolManager
51 from matplotlib.cbook import _setattr_cm
52 from matplotlib.layout_engine import ConstrainedLayoutEngine
53 from matplotlib.path import Path
54 from matplotlib.texmanager import TexManager
55 from matplotlib.transforms import Affine2D
56 from matplotlib._enums import JoinStyle, CapStyle
57 
58 
59 _log = logging.getLogger(__name__)
60 _default_filetypes = {
61     'eps': 'Encapsulated Postscript',
62     'jpg': 'Joint Photographic Experts Group',
63     'jpeg': 'Joint Photographic Experts Group',
64     'pdf': 'Portable Document Format',
65     'pgf': 'PGF code for LaTeX',
66     'png': 'Portable Network Graphics',
67     'ps': 'Postscript',
68     'raw': 'Raw RGBA bitmap',
69     'rgba': 'Raw RGBA bitmap',
70     'svg': 'Scalable Vector Graphics',
71     'svgz': 'Scalable Vector Graphics',
72     'tif': 'Tagged Image File Format',
73     'tiff': 'Tagged Image File Format',
74     'webp': 'WebP Image Format',
75 }
76 _default_backends = {
77     'eps': 'matplotlib.backends.backend_ps',
78     'jpg': 'matplotlib.backends.backend_agg',
79     'jpeg': 'matplotlib.backends.backend_agg',
80     'pdf': 'matplotlib.backends.backend_pdf',
81     'pgf': 'matplotlib.backends.backend_pgf',
82     'png': 'matplotlib.backends.backend_agg',
83     'ps': 'matplotlib.backends.backend_ps',
84     'raw': 'matplotlib.backends.backend_agg',
85     'rgba': 'matplotlib.backends.backend_agg',
86     'svg': 'matplotlib.backends.backend_svg',
87     'svgz': 'matplotlib.backends.backend_svg',
88     'tif': 'matplotlib.backends.backend_agg',
89     'tiff': 'matplotlib.backends.backend_agg',
90     'webp': 'matplotlib.backends.backend_agg',
91 }
92 
93 
94 def _safe_pyplot_import():
95     """
96     Import and return ``pyplot``, correctly setting the backend if one is
97     already forced.
98     """
99     try:
100         import matplotlib.pyplot as plt
101     except ImportError:  # Likely due to a framework mismatch.
102         current_framework = cbook._get_running_interactive_framework()
103         if current_framework is None:
104             raise  # No, something else went wrong, likely with the install...
105         backend_mapping = {
106             'qt': 'qtagg',
107             'gtk3': 'gtk3agg',
108             'gtk4': 'gtk4agg',
109             'wx': 'wxagg',
110             'tk': 'tkagg',
111             'macosx': 'macosx',
112             'headless': 'agg',
113         }
114         backend = backend_mapping[current_framework]
115         rcParams["backend"] = mpl.rcParamsOrig["backend"] = backend
116         import matplotlib.pyplot as plt  # Now this should succeed.
117     return plt
118 
119 
120 def register_backend(format, backend, description=None):
121     """
122     Register a backend for saving to a given file format.
123 
124     Parameters
125     ----------
126     format : str
127         File extension
128     backend : module string or canvas class
129         Backend for handling file output
130     description : str, default: ""
131         Description of the file type.
132     """
133     if description is None:
134         description = ''
135     _default_backends[format] = backend
136     _default_filetypes[format] = description
137 
138 
139 def get_registered_canvas_class(format):
140     """
141     Return the registered default canvas for given file format.
142     Handles deferred import of required backend.
143     """
144     if format not in _default_backends:
145         return None
146     backend_class = _default_backends[format]
147     if isinstance(backend_class, str):
148         backend_class = importlib.import_module(backend_class).FigureCanvas
149         _default_backends[format] = backend_class
150     return backend_class
151 
152 
153 class RendererBase:
154     """
155     An abstract base class to handle drawing/rendering operations.
156 
157     The following methods must be implemented in the backend for full
158     functionality (though just implementing `draw_path` alone would give a
159     highly capable backend):
160 
161     * `draw_path`
162     * `draw_image`
163     * `draw_gouraud_triangles`
164 
165     The following methods *should* be implemented in the backend for
166     optimization reasons:
167 
168     * `draw_text`
169     * `draw_markers`
170     * `draw_path_collection`
171     * `draw_quad_mesh`
172     """
173     def __init__(self):
174         super().__init__()
175         self._texmanager = None
176         self._text2path = text.TextToPath()
177         self._raster_depth = 0
178         self._rasterizing = False
179 
180     def open_group(self, s, gid=None):
181         """
182         Open a grouping element with label *s* and *gid* (if set) as id.
183 
184         Only used by the SVG renderer.
185         """
186 
187     def close_group(self, s):
188         """
189         Close a grouping element with label *s*.
190 
191         Only used by the SVG renderer.
192         """
193 
194     def draw_path(self, gc, path, transform, rgbFace=None):
195         """Draw a `~.path.Path` instance using the given affine transform."""
196         raise NotImplementedError
197 
198     def draw_markers(self, gc, marker_path, marker_trans, path,
199                      trans, rgbFace=None):
200         """
201         Draw a marker at each of *path*'s vertices (excluding control points).
202 
203         The base (fallback) implementation makes multiple calls to `draw_path`.
204         Backends may want to override this method in order to draw the marker
205         only once and reuse it multiple times.
206 
207         Parameters
208         ----------
209         gc : `.GraphicsContextBase`
210             The graphics context.
211         marker_trans : `~matplotlib.transforms.Transform`
212             An affine transform applied to the marker.
213         trans : `~matplotlib.transforms.Transform`
214             An affine transform applied to the path.
215         """
216         for vertices, codes in path.iter_segments(trans, simplify=False):
217             if len(vertices):
218                 x, y = vertices[-2:]
219                 self.draw_path(gc, marker_path,
220                                marker_trans +
221                                transforms.Affine2D().translate(x, y),
222                                rgbFace)
223 
224     def draw_path_collection(self, gc, master_transform, paths, all_transforms,
225                              offsets, offset_trans, facecolors, edgecolors,
226                              linewidths, linestyles, antialiaseds, urls,
227                              offset_position):
228         """
229         Draw a collection of *paths*.
230 
231         Each path is first transformed by the corresponding entry
232         in *all_transforms* (a list of (3, 3) matrices) and then by
233         *master_transform*.  They are then translated by the corresponding
234         entry in *offsets*, which has been first transformed by *offset_trans*.
235 
236         *facecolors*, *edgecolors*, *linewidths*, *linestyles*, and
237         *antialiased* are lists that set the corresponding properties.
238 
239         *offset_position* is unused now, but the argument is kept for
240         backwards compatibility.
241 
242         The base (fallback) implementation makes multiple calls to `draw_path`.
243         Backends may want to override this in order to render each set of
244         path data only once, and then reference that path multiple times with
245         the different offsets, colors, styles etc.  The generator methods
246         `_iter_collection_raw_paths` and `_iter_collection` are provided to
247         help with (and standardize) the implementation across backends.  It
248         is highly recommended to use those generators, so that changes to the
249         behavior of `draw_path_collection` can be made globally.
250         """
251         path_ids = self._iter_collection_raw_paths(master_transform,
252                                                    paths, all_transforms)
253 
254         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
255                 gc, list(path_ids), offsets, offset_trans,
256                 facecolors, edgecolors, linewidths, linestyles,
257                 antialiaseds, urls, offset_position):
258             path, transform = path_id
259             # Only apply another translation if we have an offset, else we
260             # reuse the initial transform.
261             if xo != 0 or yo != 0:
262                 # The transformation can be used by multiple paths. Since
263                 # translate is a inplace operation, we need to copy the
264                 # transformation by .frozen() before applying the translation.
265                 transform = transform.frozen()
266                 transform.translate(xo, yo)
267             self.draw_path(gc0, path, transform, rgbFace)
268 
269     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,
270                        coordinates, offsets, offsetTrans, facecolors,
271                        antialiased, edgecolors):
272         """
273         Draw a quadmesh.
274 
275         The base (fallback) implementation converts the quadmesh to paths and
276         then calls `draw_path_collection`.
277         """
278 
279         from matplotlib.collections import QuadMesh
280         paths = QuadMesh._convert_mesh_to_paths(coordinates)
281 
282         if edgecolors is None:
283             edgecolors = facecolors
284         linewidths = np.array([gc.get_linewidth()], float)
285 
286         return self.draw_path_collection(
287             gc, master_transform, paths, [], offsets, offsetTrans, facecolors,
288             edgecolors, linewidths, [], [antialiased], [None], 'screen')
289 
290     @_api.deprecated("3.7", alternative="draw_gouraud_triangles")
291     def draw_gouraud_triangle(self, gc, points, colors, transform):
292         """
293         Draw a Gouraud-shaded triangle.
294 
295         Parameters
296         ----------
297         gc : `.GraphicsContextBase`
298             The graphics context.
299         points : (3, 2) array-like
300             Array of (x, y) points for the triangle.
301         colors : (3, 4) array-like
302             RGBA colors for each point of the triangle.
303         transform : `~matplotlib.transforms.Transform`
304             An affine transform to apply to the points.
305         """
306         raise NotImplementedError
307 
308     def draw_gouraud_triangles(self, gc, triangles_array, colors_array,
309                                transform):
310         """
311         Draw a series of Gouraud triangles.
312 
313         Parameters
314         ----------
315         gc : `.GraphicsContextBase`
316             The graphics context.
317         triangles_array : (N, 3, 2) array-like
318             Array of *N* (x, y) points for the triangles.
319         colors_array : (N, 3, 4) array-like
320             Array of *N* RGBA colors for each point of the triangles.
321         transform : `~matplotlib.transforms.Transform`
322             An affine transform to apply to the points.
323         """
324         raise NotImplementedError
325 
326     def _iter_collection_raw_paths(self, master_transform, paths,
327                                    all_transforms):
328         """
329         Helper method (along with `_iter_collection`) to implement
330         `draw_path_collection` in a memory-efficient manner.
331 
332         This method yields all of the base path/transform combinations, given a
333         master transform, a list of paths and list of transforms.
334 
335         The arguments should be exactly what is passed in to
336         `draw_path_collection`.
337 
338         The backend should take each yielded path and transform and create an
339         object that can be referenced (reused) later.
340         """
341         Npaths = len(paths)
342         Ntransforms = len(all_transforms)
343         N = max(Npaths, Ntransforms)
344 
345         if Npaths == 0:
346             return
347 
348         transform = transforms.IdentityTransform()
349         for i in range(N):
350             path = paths[i % Npaths]
351             if Ntransforms:
352                 transform = Affine2D(all_transforms[i % Ntransforms])
353             yield path, transform + master_transform
354 
355     def _iter_collection_uses_per_path(self, paths, all_transforms,
356                                        offsets, facecolors, edgecolors):
357         """
358         Compute how many times each raw path object returned by
359         `_iter_collection_raw_paths` would be used when calling
360         `_iter_collection`. This is intended for the backend to decide
361         on the tradeoff between using the paths in-line and storing
362         them once and reusing. Rounds up in case the number of uses
363         is not the same for every path.
364         """
365         Npaths = len(paths)
366         if Npaths == 0 or len(facecolors) == len(edgecolors) == 0:
367             return 0
368         Npath_ids = max(Npaths, len(all_transforms))
369         N = max(Npath_ids, len(offsets))
370         return (N + Npath_ids - 1) // Npath_ids
371 
372     def _iter_collection(self, gc, path_ids, offsets, offset_trans, facecolors,
373                          edgecolors, linewidths, linestyles,
374                          antialiaseds, urls, offset_position):
375         """
376         Helper method (along with `_iter_collection_raw_paths`) to implement
377         `draw_path_collection` in a memory-efficient manner.
378 
379         This method yields all of the path, offset and graphics context
380         combinations to draw the path collection.  The caller should already
381         have looped over the results of `_iter_collection_raw_paths` to draw
382         this collection.
383 
384         The arguments should be the same as that passed into
385         `draw_path_collection`, with the exception of *path_ids*, which is a
386         list of arbitrary objects that the backend will use to reference one of
387         the paths created in the `_iter_collection_raw_paths` stage.
388 
389         Each yielded result is of the form::
390 
391            xo, yo, path_id, gc, rgbFace
392 
393         where *xo*, *yo* is an offset; *path_id* is one of the elements of
394         *path_ids*; *gc* is a graphics context and *rgbFace* is a color to
395         use for filling the path.
396         """
397         Npaths = len(path_ids)
398         Noffsets = len(offsets)
399         N = max(Npaths, Noffsets)
400         Nfacecolors = len(facecolors)
401         Nedgecolors = len(edgecolors)
402         Nlinewidths = len(linewidths)
403         Nlinestyles = len(linestyles)
404         Nurls = len(urls)
405 
406         if (Nfacecolors == 0 and Nedgecolors == 0) or Npaths == 0:
407             return
408 
409         gc0 = self.new_gc()
410         gc0.copy_properties(gc)
411 
412         def cycle_or_default(seq, default=None):
413             # Cycle over *seq* if it is not empty; else always yield *default*.
414             return (itertools.cycle(seq) if len(seq)
415                     else itertools.repeat(default))
416 
417         pathids = cycle_or_default(path_ids)
418         toffsets = cycle_or_default(offset_trans.transform(offsets), (0, 0))
419         fcs = cycle_or_default(facecolors)
420         ecs = cycle_or_default(edgecolors)
421         lws = cycle_or_default(linewidths)
422         lss = cycle_or_default(linestyles)
423         aas = cycle_or_default(antialiaseds)
424         urls = cycle_or_default(urls)
425 
426         if Nedgecolors == 0:
427             gc0.set_linewidth(0.0)
428 
429         for pathid, (xo, yo), fc, ec, lw, ls, aa, url in itertools.islice(
430                 zip(pathids, toffsets, fcs, ecs, lws, lss, aas, urls), N):
431             if not (np.isfinite(xo) and np.isfinite(yo)):
432                 continue
433             if Nedgecolors:
434                 if Nlinewidths:
435                     gc0.set_linewidth(lw)
436                 if Nlinestyles:
437                     gc0.set_dashes(*ls)
438                 if len(ec) == 4 and ec[3] == 0.0:
439                     gc0.set_linewidth(0)
440                 else:
441                     gc0.set_foreground(ec)
442             if fc is not None and len(fc) == 4 and fc[3] == 0:
443                 fc = None
444             gc0.set_antialiased(aa)
445             if Nurls:
446                 gc0.set_url(url)
447             yield xo, yo, pathid, gc0, fc
448         gc0.restore()
449 
450     def get_image_magnification(self):
451         """
452         Get the factor by which to magnify images passed to `draw_image`.
453         Allows a backend to have images at a different resolution to other
454         artists.
455         """
456         return 1.0
457 
458     def draw_image(self, gc, x, y, im, transform=None):
459         """
460         Draw an RGBA image.
461 
462         Parameters
463         ----------
464         gc : `.GraphicsContextBase`
465             A graphics context with clipping information.
466 
467         x : scalar
468             The distance in physical units (i.e., dots or pixels) from the left
469             hand side of the canvas.
470 
471         y : scalar
472             The distance in physical units (i.e., dots or pixels) from the
473             bottom side of the canvas.
474 
475         im : (N, M, 4) array of `numpy.uint8`
476             An array of RGBA pixels.
477 
478         transform : `~matplotlib.transforms.Affine2DBase`
479             If and only if the concrete backend is written such that
480             `option_scale_image` returns ``True``, an affine transformation
481             (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The
482             translation vector of the transformation is given in physical units
483             (i.e., dots or pixels). Note that the transformation does not
484             override *x* and *y*, and has to be applied *before* translating
485             the result by *x* and *y* (this can be accomplished by adding *x*
486             and *y* to the translation vector defined by *transform*).
487         """
488         raise NotImplementedError
489 
490     def option_image_nocomposite(self):
491         """
492         Return whether image composition by Matplotlib should be skipped.
493 
494         Raster backends should usually return False (letting the C-level
495         rasterizer take care of image composition); vector backends should
496         usually return ``not rcParams["image.composite_image"]``.
497         """
498         return False
499 
500     def option_scale_image(self):
501         """
502         Return whether arbitrary affine transformations in `draw_image` are
503         supported (True for most vector backends).
504         """
505         return False
506 
507     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):
508         """
509         Draw a TeX instance.
510 
511         Parameters
512         ----------
513         gc : `.GraphicsContextBase`
514             The graphics context.
515         x : float
516             The x location of the text in display coords.
517         y : float
518             The y location of the text baseline in display coords.
519         s : str
520             The TeX text string.
521         prop : `~matplotlib.font_manager.FontProperties`
522             The font properties.
523         angle : float
524             The rotation angle in degrees anti-clockwise.
525         mtext : `~matplotlib.text.Text`
526             The original text object to be rendered.
527         """
528         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath="TeX")
529 
530     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):
531         """
532         Draw a text instance.
533 
534         Parameters
535         ----------
536         gc : `.GraphicsContextBase`
537             The graphics context.
538         x : float
539             The x location of the text in display coords.
540         y : float
541             The y location of the text baseline in display coords.
542         s : str
543             The text string.
544         prop : `~matplotlib.font_manager.FontProperties`
545             The font properties.
546         angle : float
547             The rotation angle in degrees anti-clockwise.
548         ismath : bool or "TeX"
549             If True, use mathtext parser. If "TeX", use tex for rendering.
550         mtext : `~matplotlib.text.Text`
551             The original text object to be rendered.
552 
553         Notes
554         -----
555         **Note for backend implementers:**
556 
557         When you are trying to determine if you have gotten your bounding box
558         right (which is what enables the text layout/alignment to work
559         properly), it helps to change the line in text.py::
560 
561             if 0: bbox_artist(self, renderer)
562 
563         to if 1, and then the actual bounding box will be plotted along with
564         your text.
565         """
566 
567         self._draw_text_as_path(gc, x, y, s, prop, angle, ismath)
568 
569     def _get_text_path_transform(self, x, y, s, prop, angle, ismath):
570         """
571         Return the text path and transform.
572 
573         Parameters
574         ----------
575         x : float
576             The x location of the text in display coords.
577         y : float
578             The y location of the text baseline in display coords.
579         s : str
580             The text to be converted.
581         prop : `~matplotlib.font_manager.FontProperties`
582             The font property.
583         angle : float
584             Angle in degrees to render the text at.
585         ismath : bool or "TeX"
586             If True, use mathtext parser. If "TeX", use tex for rendering.
587         """
588 
589         text2path = self._text2path
590         fontsize = self.points_to_pixels(prop.get_size_in_points())
591         verts, codes = text2path.get_text_path(prop, s, ismath=ismath)
592 
593         path = Path(verts, codes)
594         angle = np.deg2rad(angle)
595         if self.flipy():
596             width, height = self.get_canvas_width_height()
597             transform = (Affine2D()
598                          .scale(fontsize / text2path.FONT_SCALE)
599                          .rotate(angle)
600                          .translate(x, height - y))
601         else:
602             transform = (Affine2D()
603                          .scale(fontsize / text2path.FONT_SCALE)
604                          .rotate(angle)
605                          .translate(x, y))
606 
607         return path, transform
608 
609     def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):
610         """
611         Draw the text by converting them to paths using `.TextToPath`.
612 
613         Parameters
614         ----------
615         gc : `.GraphicsContextBase`
616             The graphics context.
617         x : float
618             The x location of the text in display coords.
619         y : float
620             The y location of the text baseline in display coords.
621         s : str
622             The text to be converted.
623         prop : `~matplotlib.font_manager.FontProperties`
624             The font property.
625         angle : float
626             Angle in degrees to render the text at.
627         ismath : bool or "TeX"
628             If True, use mathtext parser. If "TeX", use tex for rendering.
629         """
630         path, transform = self._get_text_path_transform(
631             x, y, s, prop, angle, ismath)
632         color = gc.get_rgb()
633         gc.set_linewidth(0.0)
634         self.draw_path(gc, path, transform, rgbFace=color)
635 
636     def get_text_width_height_descent(self, s, prop, ismath):
637         """
638         Get the width, height, and descent (offset from the bottom to the baseline), in
639         display coords, of the string *s* with `.FontProperties` *prop*.
640 
641         Whitespace at the start and the end of *s* is included in the reported width.
642         """
643         fontsize = prop.get_size_in_points()
644 
645         if ismath == 'TeX':
646             # todo: handle properties
647             return self.get_texmanager().get_text_width_height_descent(
648                 s, fontsize, renderer=self)
649 
650         dpi = self.points_to_pixels(72)
651         if ismath:
652             dims = self._text2path.mathtext_parser.parse(s, dpi, prop)
653             return dims[0:3]  # return width, height, descent
654 
655         flags = self._text2path._get_hinting_flag()
656         font = self._text2path._get_font(prop)
657         font.set_size(fontsize, dpi)
658         # the width and height of unrotated string
659         font.set_text(s, 0.0, flags=flags)
660         w, h = font.get_width_height()
661         d = font.get_descent()
662         w /= 64.0  # convert from subpixels
663         h /= 64.0
664         d /= 64.0
665         return w, h, d
666 
667     def flipy(self):
668         """
669         Return whether y values increase from top to bottom.
670 
671         Note that this only affects drawing of texts.
672         """
673         return True
674 
675     def get_canvas_width_height(self):
676         """Return the canvas width and height in display coords."""
677         return 1, 1
678 
679     def get_texmanager(self):
680         """Return the `.TexManager` instance."""
681         if self._texmanager is None:
682             self._texmanager = TexManager()
683         return self._texmanager
684 
685     def new_gc(self):
686         """Return an instance of a `.GraphicsContextBase`."""
687         return GraphicsContextBase()
688 
689     def points_to_pixels(self, points):
690         """
691         Convert points to display units.
692 
693         You need to override this function (unless your backend
694         doesn't have a dpi, e.g., postscript or svg).  Some imaging
695         systems assume some value for pixels per inch::
696 
697             points to pixels = points * pixels_per_inch/72 * dpi/72
698 
699         Parameters
700         ----------
701         points : float or array-like
702 
703         Returns
704         -------
705         Points converted to pixels
706         """
707         return points
708 
709     def start_rasterizing(self):
710         """
711         Switch to the raster renderer.
712 
713         Used by `.MixedModeRenderer`.
714         """
715 
716     def stop_rasterizing(self):
717         """
718         Switch back to the vector renderer and draw the contents of the raster
719         renderer as an image on the vector renderer.
720 
721         Used by `.MixedModeRenderer`.
722         """
723 
724     def start_filter(self):
725         """
726         Switch to a temporary renderer for image filtering effects.
727 
728         Currently only supported by the agg renderer.
729         """
730 
731     def stop_filter(self, filter_func):
732         """
733         Switch back to the original renderer.  The contents of the temporary
734         renderer is processed with the *filter_func* and is drawn on the
735         original renderer as an image.
736 
737         Currently only supported by the agg renderer.
738         """
739 
740     def _draw_disabled(self):
741         """
742         Context manager to temporary disable drawing.
743 
744         This is used for getting the drawn size of Artists.  This lets us
745         run the draw process to update any Python state but does not pay the
746         cost of the draw_XYZ calls on the canvas.
747         """
748         no_ops = {
749             meth_name: lambda *args, **kwargs: None
750             for meth_name in dir(RendererBase)
751             if (meth_name.startswith("draw_")
752                 or meth_name in ["open_group", "close_group"])
753         }
754 
755         return _setattr_cm(self, **no_ops)
756 
757 
758 class GraphicsContextBase:
759     """An abstract base class that provides color, line styles, etc."""
760 
761     def __init__(self):
762         self._alpha = 1.0
763         self._forced_alpha = False  # if True, _alpha overrides A from RGBA
764         self._antialiased = 1  # use 0, 1 not True, False for extension code
765         self._capstyle = CapStyle('butt')
766         self._cliprect = None
767         self._clippath = None
768         self._dashes = 0, None
769         self._joinstyle = JoinStyle('round')
770         self._linestyle = 'solid'
771         self._linewidth = 1
772         self._rgb = (0.0, 0.0, 0.0, 1.0)
773         self._hatch = None
774         self._hatch_color = colors.to_rgba(rcParams['hatch.color'])
775         self._hatch_linewidth = rcParams['hatch.linewidth']
776         self._url = None
777         self._gid = None
778         self._snap = None
779         self._sketch = None
780 
781     def copy_properties(self, gc):
782         """Copy properties from *gc* to self."""
783         self._alpha = gc._alpha
784         self._forced_alpha = gc._forced_alpha
785         self._antialiased = gc._antialiased
786         self._capstyle = gc._capstyle
787         self._cliprect = gc._cliprect
788         self._clippath = gc._clippath
789         self._dashes = gc._dashes
790         self._joinstyle = gc._joinstyle
791         self._linestyle = gc._linestyle
792         self._linewidth = gc._linewidth
793         self._rgb = gc._rgb
794         self._hatch = gc._hatch
795         self._hatch_color = gc._hatch_color
796         self._hatch_linewidth = gc._hatch_linewidth
797         self._url = gc._url
798         self._gid = gc._gid
799         self._snap = gc._snap
800         self._sketch = gc._sketch
801 
802     def restore(self):
803         """
804         Restore the graphics context from the stack - needed only
805         for backends that save graphics contexts on a stack.
806         """
807 
808     def get_alpha(self):
809         """
810         Return the alpha value used for blending - not supported on all
811         backends.
812         """
813         return self._alpha
814 
815     def get_antialiased(self):
816         """Return whether the object should try to do antialiased rendering."""
817         return self._antialiased
818 
819     def get_capstyle(self):
820         """Return the `.CapStyle`."""
821         return self._capstyle.name
822 
823     def get_clip_rectangle(self):
824         """
825         Return the clip rectangle as a `~matplotlib.transforms.Bbox` instance.
826         """
827         return self._cliprect
828 
829     def get_clip_path(self):
830         """
831         Return the clip path in the form (path, transform), where path
832         is a `~.path.Path` instance, and transform is
833         an affine transform to apply to the path before clipping.
834         """
835         if self._clippath is not None:
836             tpath, tr = self._clippath.get_transformed_path_and_affine()
837             if np.all(np.isfinite(tpath.vertices)):
838                 return tpath, tr
839             else:
840                 _log.warning("Ill-defined clip_path detected. Returning None.")
841                 return None, None
842         return None, None
843 
844     def get_dashes(self):
845         """
846         Return the dash style as an (offset, dash-list) pair.
847 
848         See `.set_dashes` for details.
849 
850         Default value is (None, None).
851         """
852         return self._dashes
853 
854     def get_forced_alpha(self):
855         """
856         Return whether the value given by get_alpha() should be used to
857         override any other alpha-channel values.
858         """
859         return self._forced_alpha
860 
861     def get_joinstyle(self):
862         """Return the `.JoinStyle`."""
863         return self._joinstyle.name
864 
865     def get_linewidth(self):
866         """Return the line width in points."""
867         return self._linewidth
868 
869     def get_rgb(self):
870         """Return a tuple of three or four floats from 0-1."""
871         return self._rgb
872 
873     def get_url(self):
874         """Return a url if one is set, None otherwise."""
875         return self._url
876 
877     def get_gid(self):
878         """Return the object identifier if one is set, None otherwise."""
879         return self._gid
880 
881     def get_snap(self):
882         """
883         Return the snap setting, which can be:
884 
885         * True: snap vertices to the nearest pixel center
886         * False: leave vertices as-is
887         * None: (auto) If the path contains only rectilinear line segments,
888           round to the nearest pixel center
889         """
890         return self._snap
891 
892     def set_alpha(self, alpha):
893         """
894         Set the alpha value used for blending - not supported on all backends.
895 
896         If ``alpha=None`` (the default), the alpha components of the
897         foreground and fill colors will be used to set their respective
898         transparencies (where applicable); otherwise, ``alpha`` will override
899         them.
900         """
901         if alpha is not None:
902             self._alpha = alpha
903             self._forced_alpha = True
904         else:
905             self._alpha = 1.0
906             self._forced_alpha = False
907         self.set_foreground(self._rgb, isRGBA=True)
908 
909     def set_antialiased(self, b):
910         """Set whether object should be drawn with antialiased rendering."""
911         # Use ints to make life easier on extension code trying to read the gc.
912         self._antialiased = int(bool(b))
913 
914     @_docstring.interpd
915     def set_capstyle(self, cs):
916         """
917         Set how to draw endpoints of lines.
918 
919         Parameters
920         ----------
921         cs : `.CapStyle` or %(CapStyle)s
922         """
923         self._capstyle = CapStyle(cs)
924 
925     def set_clip_rectangle(self, rectangle):
926         """Set the clip rectangle to a `.Bbox` or None."""
927         self._cliprect = rectangle
928 
929     def set_clip_path(self, path):
930         """Set the clip path to a `.TransformedPath` or None."""
931         _api.check_isinstance((transforms.TransformedPath, None), path=path)
932         self._clippath = path
933 
934     def set_dashes(self, dash_offset, dash_list):
935         """
936         Set the dash style for the gc.
937 
938         Parameters
939         ----------
940         dash_offset : float
941             Distance, in points, into the dash pattern at which to
942             start the pattern. It is usually set to 0.
943         dash_list : array-like or None
944             The on-off sequence as points.  None specifies a solid line. All
945             values must otherwise be non-negative (:math:`\\ge 0`).
946 
947         Notes
948         -----
949         See p. 666 of the PostScript
950         `Language Reference
951         <https://www.adobe.com/jp/print/postscript/pdfs/PLRM.pdf>`_
952         for more info.
953         """
954         if dash_list is not None:
955             dl = np.asarray(dash_list)
956             if np.any(dl < 0.0):
957                 raise ValueError(
958                     "All values in the dash list must be non-negative")
959             if dl.size and not np.any(dl > 0.0):
960                 raise ValueError(
961                     'At least one value in the dash list must be positive')
962         self._dashes = dash_offset, dash_list
963 
964     def set_foreground(self, fg, isRGBA=False):
965         """
966         Set the foreground color.
967 
968         Parameters
969         ----------
970         fg : color
971         isRGBA : bool
972             If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be
973             set to True to improve performance.
974         """
975         if self._forced_alpha and isRGBA:
976             self._rgb = fg[:3] + (self._alpha,)
977         elif self._forced_alpha:
978             self._rgb = colors.to_rgba(fg, self._alpha)
979         elif isRGBA:
980             self._rgb = fg
981         else:
982             self._rgb = colors.to_rgba(fg)
983 
984     @_docstring.interpd
985     def set_joinstyle(self, js):
986         """
987         Set how to draw connections between line segments.
988 
989         Parameters
990         ----------
991         js : `.JoinStyle` or %(JoinStyle)s
992         """
993         self._joinstyle = JoinStyle(js)
994 
995     def set_linewidth(self, w):
996         """Set the linewidth in points."""
997         self._linewidth = float(w)
998 
999     def set_url(self, url):
1000         """Set the url for links in compatible backends."""
1001         self._url = url
1002 
1003     def set_gid(self, id):
1004         """Set the id."""
1005         self._gid = id
1006 
1007     def set_snap(self, snap):
1008         """
1009         Set the snap setting which may be:
1010 
1011         * True: snap vertices to the nearest pixel center
1012         * False: leave vertices as-is
1013         * None: (auto) If the path contains only rectilinear line segments,
1014           round to the nearest pixel center
1015         """
1016         self._snap = snap
1017 
1018     def set_hatch(self, hatch):
1019         """Set the hatch style (for fills)."""
1020         self._hatch = hatch
1021 
1022     def get_hatch(self):
1023         """Get the current hatch style."""
1024         return self._hatch
1025 
1026     def get_hatch_path(self, density=6.0):
1027         """Return a `.Path` for the current hatch."""
1028         hatch = self.get_hatch()
1029         if hatch is None:
1030             return None
1031         return Path.hatch(hatch, density)
1032 
1033     def get_hatch_color(self):
1034         """Get the hatch color."""
1035         return self._hatch_color
1036 
1037     def set_hatch_color(self, hatch_color):
1038         """Set the hatch color."""
1039         self._hatch_color = hatch_color
1040 
1041     def get_hatch_linewidth(self):
1042         """Get the hatch linewidth."""
1043         return self._hatch_linewidth
1044 
1045     def get_sketch_params(self):
1046         """
1047         Return the sketch parameters for the artist.
1048 
1049         Returns
1050         -------
1051         tuple or `None`
1052 
1053             A 3-tuple with the following elements:
1054 
1055             * ``scale``: The amplitude of the wiggle perpendicular to the
1056               source line.
1057             * ``length``: The length of the wiggle along the line.
1058             * ``randomness``: The scale factor by which the length is
1059               shrunken or expanded.
1060 
1061             May return `None` if no sketch parameters were set.
1062         """
1063         return self._sketch
1064 
1065     def set_sketch_params(self, scale=None, length=None, randomness=None):
1066         """
1067         Set the sketch parameters.
1068 
1069         Parameters
1070         ----------
1071         scale : float, optional
1072             The amplitude of the wiggle perpendicular to the source line, in
1073             pixels.  If scale is `None`, or not provided, no sketch filter will
1074             be provided.
1075         length : float, default: 128
1076             The length of the wiggle along the line, in pixels.
1077         randomness : float, default: 16
1078             The scale factor by which the length is shrunken or expanded.
1079         """
1080         self._sketch = (
1081             None if scale is None
1082             else (scale, length or 128., randomness or 16.))
1083 
1084 
1085 class TimerBase:
1086     """
1087     A base class for providing timer events, useful for things animations.
1088     Backends need to implement a few specific methods in order to use their
1089     own timing mechanisms so that the timer events are integrated into their
1090     event loops.
1091 
1092     Subclasses must override the following methods:
1093 
1094     - ``_timer_start``: Backend-specific code for starting the timer.
1095     - ``_timer_stop``: Backend-specific code for stopping the timer.
1096 
1097     Subclasses may additionally override the following methods:
1098 
1099     - ``_timer_set_single_shot``: Code for setting the timer to single shot
1100       operating mode, if supported by the timer object.  If not, the `Timer`
1101       class itself will store the flag and the ``_on_timer`` method should be
1102       overridden to support such behavior.
1103 
1104     - ``_timer_set_interval``: Code for setting the interval on the timer, if
1105       there is a method for doing so on the timer object.
1106 
1107     - ``_on_timer``: The internal function that any timer object should call,
1108       which will handle the task of running all callbacks that have been set.
1109     """
1110 
1111     def __init__(self, interval=None, callbacks=None):
1112         """
1113         Parameters
1114         ----------
1115         interval : int, default: 1000ms
1116             The time between timer events in milliseconds.  Will be stored as
1117             ``timer.interval``.
1118         callbacks : list[tuple[callable, tuple, dict]]
1119             List of (func, args, kwargs) tuples that will be called upon
1120             timer events.  This list is accessible as ``timer.callbacks`` and
1121             can be manipulated directly, or the functions `add_callback` and
1122             `remove_callback` can be used.
1123         """
1124         self.callbacks = [] if callbacks is None else callbacks.copy()
1125         # Set .interval and not ._interval to go through the property setter.
1126         self.interval = 1000 if interval is None else interval
1127         self.single_shot = False
1128 
1129     def __del__(self):
1130         """Need to stop timer and possibly disconnect timer."""
1131         self._timer_stop()
1132 
1133     def start(self, interval=None):
1134         """
1135         Start the timer object.
1136 
1137         Parameters
1138         ----------
1139         interval : int, optional
1140             Timer interval in milliseconds; overrides a previously set interval
1141             if provided.
1142         """
1143         if interval is not None:
1144             self.interval = interval
1145         self._timer_start()
1146 
1147     def stop(self):
1148         """Stop the timer."""
1149         self._timer_stop()
1150 
1151     def _timer_start(self):
1152         pass
1153 
1154     def _timer_stop(self):
1155         pass
1156 
1157     @property
1158     def interval(self):
1159         """The time between timer events, in milliseconds."""
1160         return self._interval
1161 
1162     @interval.setter
1163     def interval(self, interval):
1164         # Force to int since none of the backends actually support fractional
1165         # milliseconds, and some error or give warnings.
1166         # Some backends also fail when interval == 0, so ensure >= 1 msec
1167         interval = max(int(interval), 1)
1168         self._interval = interval
1169         self._timer_set_interval()
1170 
1171     @property
1172     def single_shot(self):
1173         """Whether this timer should stop after a single run."""
1174         return self._single
1175 
1176     @single_shot.setter
1177     def single_shot(self, ss):
1178         self._single = ss
1179         self._timer_set_single_shot()
1180 
1181     def add_callback(self, func, *args, **kwargs):
1182         """
1183         Register *func* to be called by timer when the event fires. Any
1184         additional arguments provided will be passed to *func*.
1185 
1186         This function returns *func*, which makes it possible to use it as a
1187         decorator.
1188         """
1189         self.callbacks.append((func, args, kwargs))
1190         return func
1191 
1192     def remove_callback(self, func, *args, **kwargs):
1193         """
1194         Remove *func* from list of callbacks.
1195 
1196         *args* and *kwargs* are optional and used to distinguish between copies
1197         of the same function registered to be called with different arguments.
1198         This behavior is deprecated.  In the future, ``*args, **kwargs`` won't
1199         be considered anymore; to keep a specific callback removable by itself,
1200         pass it to `add_callback` as a `functools.partial` object.
1201         """
1202         if args or kwargs:
1203             _api.warn_deprecated(
1204                 "3.1", message="In a future version, Timer.remove_callback "
1205                 "will not take *args, **kwargs anymore, but remove all "
1206                 "callbacks where the callable matches; to keep a specific "
1207                 "callback removable by itself, pass it to add_callback as a "
1208                 "functools.partial object.")
1209             self.callbacks.remove((func, args, kwargs))
1210         else:
1211             funcs = [c[0] for c in self.callbacks]
1212             if func in funcs:
1213                 self.callbacks.pop(funcs.index(func))
1214 
1215     def _timer_set_interval(self):
1216         """Used to set interval on underlying timer object."""
1217 
1218     def _timer_set_single_shot(self):
1219         """Used to set single shot on underlying timer object."""
1220 
1221     def _on_timer(self):
1222         """
1223         Runs all function that have been registered as callbacks. Functions
1224         can return False (or 0) if they should not be called any more. If there
1225         are no callbacks, the timer is automatically stopped.
1226         """
1227         for func, args, kwargs in self.callbacks:
1228             ret = func(*args, **kwargs)
1229             # docstring above explains why we use `if ret == 0` here,
1230             # instead of `if not ret`.
1231             # This will also catch `ret == False` as `False == 0`
1232             # but does not annoy the linters
1233             # https://docs.python.org/3/library/stdtypes.html#boolean-values
1234             if ret == 0:
1235                 self.callbacks.remove((func, args, kwargs))
1236 
1237         if len(self.callbacks) == 0:
1238             self.stop()
1239 
1240 
1241 class Event:
1242     """
1243     A Matplotlib event.
1244 
1245     The following attributes are defined and shown with their default values.
1246     Subclasses may define additional attributes.
1247 
1248     Attributes
1249     ----------
1250     name : str
1251         The event name.
1252     canvas : `FigureCanvasBase`
1253         The backend-specific canvas instance generating the event.
1254     guiEvent
1255         The GUI event that triggered the Matplotlib event.
1256     """
1257 
1258     def __init__(self, name, canvas, guiEvent=None):
1259         self.name = name
1260         self.canvas = canvas
1261         self._guiEvent = guiEvent
1262         self._guiEvent_deleted = False
1263 
1264     def _process(self):
1265         """Process this event on ``self.canvas``, then unset ``guiEvent``."""
1266         self.canvas.callbacks.process(self.name, self)
1267         self._guiEvent_deleted = True
1268 
1269     @property
1270     def guiEvent(self):
1271         # After deprecation elapses: remove _guiEvent_deleted; make guiEvent a plain
1272         # attribute set to None by _process.
1273         if self._guiEvent_deleted:
1274             _api.warn_deprecated(
1275                 "3.8", message="Accessing guiEvent outside of the original GUI event "
1276                 "handler is unsafe and deprecated since %(since)s; in the future, the "
1277                 "attribute will be set to None after quitting the event handler.  You "
1278                 "may separately record the value of the guiEvent attribute at your own "
1279                 "risk.")
1280         return self._guiEvent
1281 
1282 
1283 class DrawEvent(Event):
1284     """
1285     An event triggered by a draw operation on the canvas.
1286 
1287     In most backends, callbacks subscribed to this event will be fired after
1288     the rendering is complete but before the screen is updated. Any extra
1289     artists drawn to the canvas's renderer will be reflected without an
1290     explicit call to ``blit``.
1291 
1292     .. warning::
1293 
1294        Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may
1295        not be safe with all backends and may cause infinite recursion.
1296 
1297     A DrawEvent has a number of special attributes in addition to those defined
1298     by the parent `Event` class.
1299 
1300     Attributes
1301     ----------
1302     renderer : `RendererBase`
1303         The renderer for the draw event.
1304     """
1305     def __init__(self, name, canvas, renderer):
1306         super().__init__(name, canvas)
1307         self.renderer = renderer
1308 
1309 
1310 class ResizeEvent(Event):
1311     """
1312     An event triggered by a canvas resize.
1313 
1314     A ResizeEvent has a number of special attributes in addition to those
1315     defined by the parent `Event` class.
1316 
1317     Attributes
1318     ----------
1319     width : int
1320         Width of the canvas in pixels.
1321     height : int
1322         Height of the canvas in pixels.
1323     """
1324 
1325     def __init__(self, name, canvas):
1326         super().__init__(name, canvas)
1327         self.width, self.height = canvas.get_width_height()
1328 
1329 
1330 class CloseEvent(Event):
1331     """An event triggered by a figure being closed."""
1332 
1333 
1334 class LocationEvent(Event):
1335     """
1336     An event that has a screen location.
1337 
1338     A LocationEvent has a number of special attributes in addition to those
1339     defined by the parent `Event` class.
1340 
1341     Attributes
1342     ----------
1343     x, y : int or None
1344         Event location in pixels from bottom left of canvas.
1345     inaxes : `~matplotlib.axes.Axes` or None
1346         The `~.axes.Axes` instance over which the mouse is, if any.
1347     xdata, ydata : float or None
1348         Data coordinates of the mouse within *inaxes*, or *None* if the mouse
1349         is not over an Axes.
1350     modifiers : frozenset
1351         The keyboard modifiers currently being pressed (except for KeyEvent).
1352     """
1353 
1354     # Fully delete all occurrences of lastevent after deprecation elapses.
1355     _lastevent = None
1356     lastevent = _api.deprecated("3.8")(
1357         _api.classproperty(lambda cls: cls._lastevent))
1358     _last_axes_ref = None
1359 
1360     def __init__(self, name, canvas, x, y, guiEvent=None, *, modifiers=None):
1361         super().__init__(name, canvas, guiEvent=guiEvent)
1362         # x position - pixels from left of canvas
1363         self.x = int(x) if x is not None else x
1364         # y position - pixels from right of canvas
1365         self.y = int(y) if y is not None else y
1366         self.inaxes = None  # the Axes instance the mouse is over
1367         self.xdata = None   # x coord of mouse in data coords
1368         self.ydata = None   # y coord of mouse in data coords
1369         self.modifiers = frozenset(modifiers if modifiers is not None else [])
1370 
1371         if x is None or y is None:
1372             # cannot check if event was in Axes if no (x, y) info
1373             return
1374 
1375         self._set_inaxes(self.canvas.inaxes((x, y))
1376                          if self.canvas.mouse_grabber is None else
1377                          self.canvas.mouse_grabber,
1378                          (x, y))
1379 
1380     # Splitting _set_inaxes out is useful for the axes_leave_event handler: it
1381     # needs to generate synthetic LocationEvents with manually-set inaxes.  In
1382     # that latter case, xy has already been cast to int so it can directly be
1383     # read from self.x, self.y; in the normal case, however, it is more
1384     # accurate to pass the untruncated float x, y values passed to the ctor.
1385 
1386     def _set_inaxes(self, inaxes, xy=None):
1387         self.inaxes = inaxes
1388         if inaxes is not None:
1389             try:
1390                 self.xdata, self.ydata = inaxes.transData.inverted().transform(
1391                     xy if xy is not None else (self.x, self.y))
1392             except ValueError:
1393                 pass
1394 
1395 
1396 class MouseButton(IntEnum):
1397     LEFT = 1
1398     MIDDLE = 2
1399     RIGHT = 3
1400     BACK = 8
1401     FORWARD = 9
1402 
1403 
1404 class MouseEvent(LocationEvent):
1405     """
1406     A mouse event ('button_press_event', 'button_release_event', \
1407 'scroll_event', 'motion_notify_event').
1408 
1409     A MouseEvent has a number of special attributes in addition to those
1410     defined by the parent `Event` and `LocationEvent` classes.
1411 
1412     Attributes
1413     ----------
1414     button : None or `MouseButton` or {'up', 'down'}
1415         The button pressed. 'up' and 'down' are used for scroll events.
1416 
1417         Note that LEFT and RIGHT actually refer to the "primary" and
1418         "secondary" buttons, i.e. if the user inverts their left and right
1419         buttons ("left-handed setting") then the LEFT button will be the one
1420         physically on the right.
1421 
1422         If this is unset, *name* is "scroll_event", and *step* is nonzero, then
1423         this will be set to "up" or "down" depending on the sign of *step*.
1424 
1425     key : None or str
1426         The key pressed when the mouse event triggered, e.g. 'shift'.
1427         See `KeyEvent`.
1428 
1429         .. warning::
1430            This key is currently obtained from the last 'key_press_event' or
1431            'key_release_event' that occurred within the canvas.  Thus, if the
1432            last change of keyboard state occurred while the canvas did not have
1433            focus, this attribute will be wrong.  On the other hand, the
1434            ``modifiers`` attribute should always be correct, but it can only
1435            report on modifier keys.
1436 
1437     step : float
1438         The number of scroll steps (positive for 'up', negative for 'down').
1439         This applies only to 'scroll_event' and defaults to 0 otherwise.
1440 
1441     dblclick : bool
1442         Whether the event is a double-click. This applies only to
1443         'button_press_event' and is False otherwise. In particular, it's
1444         not used in 'button_release_event'.
1445 
1446     Examples
1447     --------
1448     ::
1449 
1450         def on_press(event):
1451             print('you pressed', event.button, event.xdata, event.ydata)
1452 
1453         cid = fig.canvas.mpl_connect('button_press_event', on_press)
1454     """
1455 
1456     def __init__(self, name, canvas, x, y, button=None, key=None,
1457                  step=0, dblclick=False, guiEvent=None, *, modifiers=None):
1458         super().__init__(
1459             name, canvas, x, y, guiEvent=guiEvent, modifiers=modifiers)
1460         if button in MouseButton.__members__.values():
1461             button = MouseButton(button)
1462         if name == "scroll_event" and button is None:
1463             if step > 0:
1464                 button = "up"
1465             elif step < 0:
1466                 button = "down"
1467         self.button = button
1468         self.key = key
1469         self.step = step
1470         self.dblclick = dblclick
1471 
1472     def __str__(self):
1473         return (f"{self.name}: "
1474                 f"xy=({self.x}, {self.y}) xydata=({self.xdata}, {self.ydata}) "
1475                 f"button={self.button} dblclick={self.dblclick} "
1476                 f"inaxes={self.inaxes}")
1477 
1478 
1479 class PickEvent(Event):
1480     """
1481     A pick event.
1482 
1483     This event is fired when the user picks a location on the canvas
1484     sufficiently close to an artist that has been made pickable with
1485     `.Artist.set_picker`.
1486 
1487     A PickEvent has a number of special attributes in addition to those defined
1488     by the parent `Event` class.
1489 
1490     Attributes
1491     ----------
1492     mouseevent : `MouseEvent`
1493         The mouse event that generated the pick.
1494     artist : `~matplotlib.artist.Artist`
1495         The picked artist.  Note that artists are not pickable by default
1496         (see `.Artist.set_picker`).
1497     other
1498         Additional attributes may be present depending on the type of the
1499         picked object; e.g., a `.Line2D` pick may define different extra
1500         attributes than a `.PatchCollection` pick.
1501 
1502     Examples
1503     --------
1504     Bind a function ``on_pick()`` to pick events, that prints the coordinates
1505     of the picked data point::
1506 
1507         ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance
1508 
1509         def on_pick(event):
1510             line = event.artist
1511             xdata, ydata = line.get_data()
1512             ind = event.ind
1513             print(f'on pick line: {xdata[ind]:.3f}, {ydata[ind]:.3f}')
1514 
1515         cid = fig.canvas.mpl_connect('pick_event', on_pick)
1516     """
1517 
1518     def __init__(self, name, canvas, mouseevent, artist,
1519                  guiEvent=None, **kwargs):
1520         if guiEvent is None:
1521             guiEvent = mouseevent.guiEvent
1522         super().__init__(name, canvas, guiEvent)
1523         self.mouseevent = mouseevent
1524         self.artist = artist
1525         self.__dict__.update(kwargs)
1526 
1527 
1528 class KeyEvent(LocationEvent):
1529     """
1530     A key event (key press, key release).
1531 
1532     A KeyEvent has a number of special attributes in addition to those defined
1533     by the parent `Event` and `LocationEvent` classes.
1534 
1535     Attributes
1536     ----------
1537     key : None or str
1538         The key(s) pressed. Could be *None*, a single case sensitive Unicode
1539         character ("g", "G", "#", etc.), a special key ("control", "shift",
1540         "f1", "up", etc.) or a combination of the above (e.g., "ctrl+alt+g",
1541         "ctrl+alt+G").
1542 
1543     Notes
1544     -----
1545     Modifier keys will be prefixed to the pressed key and will be in the order
1546     "ctrl", "alt", "super". The exception to this rule is when the pressed key
1547     is itself a modifier key, therefore "ctrl+alt" and "alt+control" can both
1548     be valid key values.
1549 
1550     Examples
1551     --------
1552     ::
1553 
1554         def on_key(event):
1555             print('you pressed', event.key, event.xdata, event.ydata)
1556 
1557         cid = fig.canvas.mpl_connect('key_press_event', on_key)
1558     """
1559 
1560     def __init__(self, name, canvas, key, x=0, y=0, guiEvent=None):
1561         super().__init__(name, canvas, x, y, guiEvent=guiEvent)
1562         self.key = key
1563 
1564 
1565 # Default callback for key events.
1566 def _key_handler(event):
1567     # Dead reckoning of key.
1568     if event.name == "key_press_event":
1569         event.canvas._key = event.key
1570     elif event.name == "key_release_event":
1571         event.canvas._key = None
1572 
1573 
1574 # Default callback for mouse events.
1575 def _mouse_handler(event):
1576     # Dead-reckoning of button and key.
1577     if event.name == "button_press_event":
1578         event.canvas._button = event.button
1579     elif event.name == "button_release_event":
1580         event.canvas._button = None
1581     elif event.name == "motion_notify_event" and event.button is None:
1582         event.button = event.canvas._button
1583     if event.key is None:
1584         event.key = event.canvas._key
1585     # Emit axes_enter/axes_leave.
1586     if event.name == "motion_notify_event":
1587         last_ref = LocationEvent._last_axes_ref
1588         last_axes = last_ref() if last_ref else None
1589         if last_axes != event.inaxes:
1590             if last_axes is not None:
1591                 # Create a synthetic LocationEvent for the axes_leave_event.
1592                 # Its inaxes attribute needs to be manually set (because the
1593                 # cursor is actually *out* of that axes at that point); this is
1594                 # done with the internal _set_inaxes method which ensures that
1595                 # the xdata and ydata attributes are also correct.
1596                 try:
1597                     leave_event = LocationEvent(
1598                         "axes_leave_event", last_axes.figure.canvas,
1599                         event.x, event.y, event.guiEvent,
1600                         modifiers=event.modifiers)
1601                     leave_event._set_inaxes(last_axes)
1602                     last_axes.figure.canvas.callbacks.process(
1603                         "axes_leave_event", leave_event)
1604                 except Exception:
1605                     pass  # The last canvas may already have been torn down.
1606             if event.inaxes is not None:
1607                 event.canvas.callbacks.process("axes_enter_event", event)
1608         LocationEvent._last_axes_ref = (
1609             weakref.ref(event.inaxes) if event.inaxes else None)
1610         LocationEvent._lastevent = (
1611             None if event.name == "figure_leave_event" else event)
1612 
1613 
1614 def _get_renderer(figure, print_method=None):
1615     """
1616     Get the renderer that would be used to save a `.Figure`.
1617 
1618     If you need a renderer without any active draw methods use
1619     renderer._draw_disabled to temporary patch them out at your call site.
1620     """
1621     # This is implemented by triggering a draw, then immediately jumping out of
1622     # Figure.draw() by raising an exception.
1623 
1624     class Done(Exception):
1625         pass
1626 
1627     def _draw(renderer): raise Done(renderer)
1628 
1629     with cbook._setattr_cm(figure, draw=_draw), ExitStack() as stack:
1630         if print_method is None:
1631             fmt = figure.canvas.get_default_filetype()
1632             # Even for a canvas' default output type, a canvas switch may be
1633             # needed, e.g. for FigureCanvasBase.
1634             print_method = stack.enter_context(
1635                 figure.canvas._switch_canvas_and_return_print_method(fmt))
1636         try:
1637             print_method(io.BytesIO())
1638         except Done as exc:
1639             renderer, = exc.args
1640             return renderer
1641         else:
1642             raise RuntimeError(f"{print_method} did not call Figure.draw, so "
1643                                f"no renderer is available")
1644 
1645 
1646 def _no_output_draw(figure):
1647     # _no_output_draw was promoted to the figure level, but
1648     # keep this here in case someone was calling it...
1649     figure.draw_without_rendering()
1650 
1651 
1652 def _is_non_interactive_terminal_ipython(ip):
1653     """
1654     Return whether we are in a terminal IPython, but non interactive.
1655 
1656     When in _terminal_ IPython, ip.parent will have and `interact` attribute,
1657     if this attribute is False we do not setup eventloop integration as the
1658     user will _not_ interact with IPython. In all other case (ZMQKernel, or is
1659     interactive), we do.
1660     """
1661     return (hasattr(ip, 'parent')
1662             and (ip.parent is not None)
1663             and getattr(ip.parent, 'interact', None) is False)
1664 
1665 
1666 class FigureCanvasBase:
1667     """
1668     The canvas the figure renders into.
1669 
1670     Attributes
1671     ----------
1672     figure : `~matplotlib.figure.Figure`
1673         A high-level figure instance.
1674     """
1675 
1676     # Set to one of {"qt", "gtk3", "gtk4", "wx", "tk", "macosx"} if an
1677     # interactive framework is required, or None otherwise.
1678     required_interactive_framework = None
1679 
1680     # The manager class instantiated by new_manager.
1681     # (This is defined as a classproperty because the manager class is
1682     # currently defined *after* the canvas class, but one could also assign
1683     # ``FigureCanvasBase.manager_class = FigureManagerBase``
1684     # after defining both classes.)
1685     manager_class = _api.classproperty(lambda cls: FigureManagerBase)
1686 
1687     events = [
1688         'resize_event',
1689         'draw_event',
1690         'key_press_event',
1691         'key_release_event',
1692         'button_press_event',
1693         'button_release_event',
1694         'scroll_event',
1695         'motion_notify_event',
1696         'pick_event',
1697         'figure_enter_event',
1698         'figure_leave_event',
1699         'axes_enter_event',
1700         'axes_leave_event',
1701         'close_event'
1702     ]
1703 
1704     fixed_dpi = None
1705 
1706     filetypes = _default_filetypes
1707 
1708     @_api.classproperty
1709     def supports_blit(cls):
1710         """If this Canvas sub-class supports blitting."""
1711         return (hasattr(cls, "copy_from_bbox")
1712                 and hasattr(cls, "restore_region"))
1713 
1714     def __init__(self, figure=None):
1715         from matplotlib.figure import Figure
1716         self._fix_ipython_backend2gui()
1717         self._is_idle_drawing = True
1718         self._is_saving = False
1719         if figure is None:
1720             figure = Figure()
1721         figure.set_canvas(self)
1722         self.figure = figure
1723         self.manager = None
1724         self.widgetlock = widgets.LockDraw()
1725         self._button = None  # the button pressed
1726         self._key = None  # the key pressed
1727         self.mouse_grabber = None  # the Axes currently grabbing mouse
1728         self.toolbar = None  # NavigationToolbar2 will set me
1729         self._is_idle_drawing = False
1730         # We don't want to scale up the figure DPI more than once.
1731         figure._original_dpi = figure.dpi
1732         self._device_pixel_ratio = 1
1733         super().__init__()  # Typically the GUI widget init (if any).
1734 
1735     callbacks = property(lambda self: self.figure._canvas_callbacks)
1736     button_pick_id = property(lambda self: self.figure._button_pick_id)
1737     scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)
1738 
1739     @classmethod
1740     @functools.cache
1741     def _fix_ipython_backend2gui(cls):
1742         # Fix hard-coded module -> toolkit mapping in IPython (used for
1743         # `ipython --auto`).  This cannot be done at import time due to
1744         # ordering issues, so we do it when creating a canvas, and should only
1745         # be done once per class (hence the `cache`).
1746         if sys.modules.get("IPython") is None:
1747             return
1748         import IPython
1749         ip = IPython.get_ipython()
1750         if not ip:
1751             return
1752         from IPython.core import pylabtools as pt
1753         if (not hasattr(pt, "backend2gui")
1754                 or not hasattr(ip, "enable_matplotlib")):
1755             # In case we ever move the patch to IPython and remove these APIs,
1756             # don't break on our side.
1757             return
1758         backend2gui_rif = {
1759             "qt": "qt",
1760             "gtk3": "gtk3",
1761             "gtk4": "gtk4",
1762             "wx": "wx",
1763             "macosx": "osx",
1764         }.get(cls.required_interactive_framework)
1765         if backend2gui_rif:
1766             if _is_non_interactive_terminal_ipython(ip):
1767                 ip.enable_gui(backend2gui_rif)
1768 
1769     @classmethod
1770     def new_manager(cls, figure, num):
1771         """
1772         Create a new figure manager for *figure*, using this canvas class.
1773 
1774         Notes
1775         -----
1776         This method should not be reimplemented in subclasses.  If
1777         custom manager creation logic is needed, please reimplement
1778         ``FigureManager.create_with_canvas``.
1779         """
1780         return cls.manager_class.create_with_canvas(cls, figure, num)
1781 
1782     @contextmanager
1783     def _idle_draw_cntx(self):
1784         self._is_idle_drawing = True
1785         try:
1786             yield
1787         finally:
1788             self._is_idle_drawing = False
1789 
1790     def is_saving(self):
1791         """
1792         Return whether the renderer is in the process of saving
1793         to a file, rather than rendering for an on-screen buffer.
1794         """
1795         return self._is_saving
1796 
1797     def blit(self, bbox=None):
1798         """Blit the canvas in bbox (default entire canvas)."""
1799 
1800     def inaxes(self, xy):
1801         """
1802         Return the topmost visible `~.axes.Axes` containing the point *xy*.
1803 
1804         Parameters
1805         ----------
1806         xy : (float, float)
1807             (x, y) pixel positions from left/bottom of the canvas.
1808 
1809         Returns
1810         -------
1811         `~matplotlib.axes.Axes` or None
1812             The topmost visible Axes containing the point, or None if there
1813             is no Axes at the point.
1814         """
1815         axes_list = [a for a in self.figure.get_axes()
1816                      if a.patch.contains_point(xy) and a.get_visible()]
1817         if axes_list:
1818             axes = cbook._topmost_artist(axes_list)
1819         else:
1820             axes = None
1821 
1822         return axes
1823 
1824     def grab_mouse(self, ax):
1825         """
1826         Set the child `~.axes.Axes` which is grabbing the mouse events.
1827 
1828         Usually called by the widgets themselves. It is an error to call this
1829         if the mouse is already grabbed by another Axes.
1830         """
1831         if self.mouse_grabber not in (None, ax):
1832             raise RuntimeError("Another Axes already grabs mouse input")
1833         self.mouse_grabber = ax
1834 
1835     def release_mouse(self, ax):
1836         """
1837         Release the mouse grab held by the `~.axes.Axes` *ax*.
1838 
1839         Usually called by the widgets. It is ok to call this even if *ax*
1840         doesn't have the mouse grab currently.
1841         """
1842         if self.mouse_grabber is ax:
1843             self.mouse_grabber = None
1844 
1845     def set_cursor(self, cursor):
1846         """
1847         Set the current cursor.
1848 
1849         This may have no effect if the backend does not display anything.
1850 
1851         If required by the backend, this method should trigger an update in
1852         the backend event loop after the cursor is set, as this method may be
1853         called e.g. before a long-running task during which the GUI is not
1854         updated.
1855 
1856         Parameters
1857         ----------
1858         cursor : `.Cursors`
1859             The cursor to display over the canvas. Note: some backends may
1860             change the cursor for the entire window.
1861         """
1862 
1863     def draw(self, *args, **kwargs):
1864         """
1865         Render the `.Figure`.
1866 
1867         This method must walk the artist tree, even if no output is produced,
1868         because it triggers deferred work that users may want to access
1869         before saving output to disk. For example computing limits,
1870         auto-limits, and tick values.
1871         """
1872 
1873     def draw_idle(self, *args, **kwargs):
1874         """
1875         Request a widget redraw once control returns to the GUI event loop.
1876 
1877         Even if multiple calls to `draw_idle` occur before control returns
1878         to the GUI event loop, the figure will only be rendered once.
1879 
1880         Notes
1881         -----
1882         Backends may choose to override the method and implement their own
1883         strategy to prevent multiple renderings.
1884 
1885         """
1886         if not self._is_idle_drawing:
1887             with self._idle_draw_cntx():
1888                 self.draw(*args, **kwargs)
1889 
1890     @property
1891     def device_pixel_ratio(self):
1892         """
1893         The ratio of physical to logical pixels used for the canvas on screen.
1894 
1895         By default, this is 1, meaning physical and logical pixels are the same
1896         size. Subclasses that support High DPI screens may set this property to
1897         indicate that said ratio is different. All Matplotlib interaction,
1898         unless working directly with the canvas, remains in logical pixels.
1899 
1900         """
1901         return self._device_pixel_ratio
1902 
1903     def _set_device_pixel_ratio(self, ratio):
1904         """
1905         Set the ratio of physical to logical pixels used for the canvas.
1906 
1907         Subclasses that support High DPI screens can set this property to
1908         indicate that said ratio is different. The canvas itself will be
1909         created at the physical size, while the client side will use the
1910         logical size. Thus the DPI of the Figure will change to be scaled by
1911         this ratio. Implementations that support High DPI screens should use
1912         physical pixels for events so that transforms back to Axes space are
1913         correct.
1914 
1915         By default, this is 1, meaning physical and logical pixels are the same
1916         size.
1917 
1918         Parameters
1919         ----------
1920         ratio : float
1921             The ratio of logical to physical pixels used for the canvas.
1922 
1923         Returns
1924         -------
1925         bool
1926             Whether the ratio has changed. Backends may interpret this as a
1927             signal to resize the window, repaint the canvas, or change any
1928             other relevant properties.
1929         """
1930         if self._device_pixel_ratio == ratio:
1931             return False
1932         # In cases with mixed resolution displays, we need to be careful if the
1933         # device pixel ratio changes - in this case we need to resize the
1934         # canvas accordingly. Some backends provide events that indicate a
1935         # change in DPI, but those that don't will update this before drawing.
1936         dpi = ratio * self.figure._original_dpi
1937         self.figure._set_dpi(dpi, forward=False)
1938         self._device_pixel_ratio = ratio
1939         return True
1940 
1941     def get_width_height(self, *, physical=False):
1942         """
1943         Return the figure width and height in integral points or pixels.
1944 
1945         When the figure is used on High DPI screens (and the backend supports
1946         it), the truncation to integers occurs after scaling by the device
1947         pixel ratio.
1948 
1949         Parameters
1950         ----------
1951         physical : bool, default: False
1952             Whether to return true physical pixels or logical pixels. Physical
1953             pixels may be used by backends that support HiDPI, but still
1954             configure the canvas using its actual size.
1955 
1956         Returns
1957         -------
1958         width, height : int
1959             The size of the figure, in points or pixels, depending on the
1960             backend.
1961         """
1962         return tuple(int(size / (1 if physical else self.device_pixel_ratio))
1963                      for size in self.figure.bbox.max)
1964 
1965     @classmethod
1966     def get_supported_filetypes(cls):
1967         """Return dict of savefig file formats supported by this backend."""
1968         return cls.filetypes
1969 
1970     @classmethod
1971     def get_supported_filetypes_grouped(cls):
1972         """
1973         Return a dict of savefig file formats supported by this backend,
1974         where the keys are a file type name, such as 'Joint Photographic
1975         Experts Group', and the values are a list of filename extensions used
1976         for that filetype, such as ['jpg', 'jpeg'].
1977         """
1978         groupings = {}
1979         for ext, name in cls.filetypes.items():
1980             groupings.setdefault(name, []).append(ext)
1981             groupings[name].sort()
1982         return groupings
1983 
1984     @contextmanager
1985     def _switch_canvas_and_return_print_method(self, fmt, backend=None):
1986         """
1987         Context manager temporarily setting the canvas for saving the figure::
1988 
1989             with canvas._switch_canvas_and_return_print_method(fmt, backend) \\
1990                     as print_method:
1991                 # ``print_method`` is a suitable ``print_{fmt}`` method, and
1992                 # the figure's canvas is temporarily switched to the method's
1993                 # canvas within the with... block.  ``print_method`` is also
1994                 # wrapped to suppress extra kwargs passed by ``print_figure``.
1995 
1996         Parameters
1997         ----------
1998         fmt : str
1999             If *backend* is None, then determine a suitable canvas class for
2000             saving to format *fmt* -- either the current canvas class, if it
2001             supports *fmt*, or whatever `get_registered_canvas_class` returns;
2002             switch the figure canvas to that canvas class.
2003         backend : str or None, default: None
2004             If not None, switch the figure canvas to the ``FigureCanvas`` class
2005             of the given backend.
2006         """
2007         canvas = None
2008         if backend is not None:
2009             # Return a specific canvas class, if requested.
2010             canvas_class = (
2011                 importlib.import_module(cbook._backend_module_name(backend))
2012                 .FigureCanvas)
2013             if not hasattr(canvas_class, f"print_{fmt}"):
2014                 raise ValueError(
2015                     f"The {backend!r} backend does not support {fmt} output")
2016             canvas = canvas_class(self.figure)
2017         elif hasattr(self, f"print_{fmt}"):
2018             # Return the current canvas if it supports the requested format.
2019             canvas = self
2020         else:
2021             # Return a default canvas for the requested format, if it exists.
2022             canvas_class = get_registered_canvas_class(fmt)
2023             if canvas_class is None:
2024                 raise ValueError(
2025                     "Format {!r} is not supported (supported formats: {})".format(
2026                         fmt, ", ".join(sorted(self.get_supported_filetypes()))))
2027             canvas = canvas_class(self.figure)
2028         canvas._is_saving = self._is_saving
2029         meth = getattr(canvas, f"print_{fmt}")
2030         mod = (meth.func.__module__
2031                if hasattr(meth, "func")  # partialmethod, e.g. backend_wx.
2032                else meth.__module__)
2033         if mod.startswith(("matplotlib.", "mpl_toolkits.")):
2034             optional_kws = {  # Passed by print_figure for other renderers.
2035                 "dpi", "facecolor", "edgecolor", "orientation",
2036                 "bbox_inches_restore"}
2037             skip = optional_kws - {*inspect.signature(meth).parameters}
2038             print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(
2039                 *args, **{k: v for k, v in kwargs.items() if k not in skip}))
2040         else:  # Let third-parties do as they see fit.
2041             print_method = meth
2042         try:
2043             yield print_method
2044         finally:
2045             self.figure.canvas = self
2046 
2047     def print_figure(
2048             self, filename, dpi=None, facecolor=None, edgecolor=None,
2049             orientation='portrait', format=None, *,
2050             bbox_inches=None, pad_inches=None, bbox_extra_artists=None,
2051             backend=None, **kwargs):
2052         """
2053         Render the figure to hardcopy. Set the figure patch face and edge
2054         colors.  This is useful because some of the GUIs have a gray figure
2055         face color background and you'll probably want to override this on
2056         hardcopy.
2057 
2058         Parameters
2059         ----------
2060         filename : str or path-like or file-like
2061             The file where the figure is saved.
2062 
2063         dpi : float, default: :rc:`savefig.dpi`
2064             The dots per inch to save the figure in.
2065 
2066         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
2067             The facecolor of the figure.  If 'auto', use the current figure
2068             facecolor.
2069 
2070         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
2071             The edgecolor of the figure.  If 'auto', use the current figure
2072             edgecolor.
2073 
2074         orientation : {'landscape', 'portrait'}, default: 'portrait'
2075             Only currently applies to PostScript printing.
2076 
2077         format : str, optional
2078             Force a specific file format. If not given, the format is inferred
2079             from the *filename* extension, and if that fails from
2080             :rc:`savefig.format`.
2081 
2082         bbox_inches : 'tight' or `.Bbox`, default: :rc:`savefig.bbox`
2083             Bounding box in inches: only the given portion of the figure is
2084             saved.  If 'tight', try to figure out the tight bbox of the figure.
2085 
2086         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
2087             Amount of padding in inches around the figure when bbox_inches is
2088             'tight'. If 'layout' use the padding from the constrained or
2089             compressed layout engine; ignored if one of those engines is not in
2090             use.
2091 
2092         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2093             A list of extra artists that will be considered when the
2094             tight bbox is calculated.
2095 
2096         backend : str, optional
2097             Use a non-default backend to render the file, e.g. to render a
2098             png file with the "cairo" backend rather than the default "agg",
2099             or a pdf file with the "pgf" backend rather than the default
2100             "pdf".  Note that the default backend is normally sufficient.  See
2101             :ref:`the-builtin-backends` for a list of valid backends for each
2102             file format.  Custom backends can be referenced as "module://...".
2103         """
2104         if format is None:
2105             # get format from filename, or from backend's default filetype
2106             if isinstance(filename, os.PathLike):
2107                 filename = os.fspath(filename)
2108             if isinstance(filename, str):
2109                 format = os.path.splitext(filename)[1][1:]
2110             if format is None or format == '':
2111                 format = self.get_default_filetype()
2112                 if isinstance(filename, str):
2113                     filename = filename.rstrip('.') + '.' + format
2114         format = format.lower()
2115 
2116         if dpi is None:
2117             dpi = rcParams['savefig.dpi']
2118         if dpi == 'figure':
2119             dpi = getattr(self.figure, '_original_dpi', self.figure.dpi)
2120 
2121         # Remove the figure manager, if any, to avoid resizing the GUI widget.
2122         with cbook._setattr_cm(self, manager=None), \
2123              self._switch_canvas_and_return_print_method(format, backend) \
2124                  as print_method, \
2125              cbook._setattr_cm(self.figure, dpi=dpi), \
2126              cbook._setattr_cm(self.figure.canvas, _device_pixel_ratio=1), \
2127              cbook._setattr_cm(self.figure.canvas, _is_saving=True), \
2128              ExitStack() as stack:
2129 
2130             for prop in ["facecolor", "edgecolor"]:
2131                 color = locals()[prop]
2132                 if color is None:
2133                     color = rcParams[f"savefig.{prop}"]
2134                 if not cbook._str_equal(color, "auto"):
2135                     stack.enter_context(self.figure._cm_set(**{prop: color}))
2136 
2137             if bbox_inches is None:
2138                 bbox_inches = rcParams['savefig.bbox']
2139 
2140             layout_engine = self.figure.get_layout_engine()
2141             if layout_engine is not None or bbox_inches == "tight":
2142                 # we need to trigger a draw before printing to make sure
2143                 # CL works.  "tight" also needs a draw to get the right
2144                 # locations:
2145                 renderer = _get_renderer(
2146                     self.figure,
2147                     functools.partial(
2148                         print_method, orientation=orientation)
2149                 )
2150                 # we do this instead of `self.figure.draw_without_rendering`
2151                 # so that we can inject the orientation
2152                 with getattr(renderer, "_draw_disabled", nullcontext)():
2153                     self.figure.draw(renderer)
2154             if bbox_inches:
2155                 if bbox_inches == "tight":
2156                     bbox_inches = self.figure.get_tightbbox(
2157                         renderer, bbox_extra_artists=bbox_extra_artists)
2158                     if (isinstance(layout_engine, ConstrainedLayoutEngine) and
2159                             pad_inches == "layout"):
2160                         h_pad = layout_engine.get()["h_pad"]
2161                         w_pad = layout_engine.get()["w_pad"]
2162                     else:
2163                         if pad_inches in [None, "layout"]:
2164                             pad_inches = rcParams['savefig.pad_inches']
2165                         h_pad = w_pad = pad_inches
2166                     bbox_inches = bbox_inches.padded(w_pad, h_pad)
2167 
2168                 # call adjust_bbox to save only the given area
2169                 restore_bbox = _tight_bbox.adjust_bbox(
2170                     self.figure, bbox_inches, self.figure.canvas.fixed_dpi)
2171 
2172                 _bbox_inches_restore = (bbox_inches, restore_bbox)
2173             else:
2174                 _bbox_inches_restore = None
2175 
2176             # we have already done layout above, so turn it off:
2177             stack.enter_context(self.figure._cm_set(layout_engine='none'))
2178             try:
2179                 # _get_renderer may change the figure dpi (as vector formats
2180                 # force the figure dpi to 72), so we need to set it again here.
2181                 with cbook._setattr_cm(self.figure, dpi=dpi):
2182                     result = print_method(
2183                         filename,
2184                         facecolor=facecolor,
2185                         edgecolor=edgecolor,
2186                         orientation=orientation,
2187                         bbox_inches_restore=_bbox_inches_restore,
2188                         **kwargs)
2189             finally:
2190                 if bbox_inches and restore_bbox:
2191                     restore_bbox()
2192 
2193             return result
2194 
2195     @classmethod
2196     def get_default_filetype(cls):
2197         """
2198         Return the default savefig file format as specified in
2199         :rc:`savefig.format`.
2200 
2201         The returned string does not include a period. This method is
2202         overridden in backends that only support a single file type.
2203         """
2204         return rcParams['savefig.format']
2205 
2206     def get_default_filename(self):
2207         """
2208         Return a string, which includes extension, suitable for use as
2209         a default filename.
2210         """
2211         basename = (self.manager.get_window_title() if self.manager is not None
2212                     else '')
2213         basename = (basename or 'image').replace(' ', '_')
2214         filetype = self.get_default_filetype()
2215         filename = basename + '.' + filetype
2216         return filename
2217 
2218     @_api.deprecated("3.8")
2219     def switch_backends(self, FigureCanvasClass):
2220         """
2221         Instantiate an instance of FigureCanvasClass
2222 
2223         This is used for backend switching, e.g., to instantiate a
2224         FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is
2225         not done, so any changes to one of the instances (e.g., setting
2226         figure size or line props), will be reflected in the other
2227         """
2228         newCanvas = FigureCanvasClass(self.figure)
2229         newCanvas._is_saving = self._is_saving
2230         return newCanvas
2231 
2232     def mpl_connect(self, s, func):
2233         """
2234         Bind function *func* to event *s*.
2235 
2236         Parameters
2237         ----------
2238         s : str
2239             One of the following events ids:
2240 
2241             - 'button_press_event'
2242             - 'button_release_event'
2243             - 'draw_event'
2244             - 'key_press_event'
2245             - 'key_release_event'
2246             - 'motion_notify_event'
2247             - 'pick_event'
2248             - 'resize_event'
2249             - 'scroll_event'
2250             - 'figure_enter_event',
2251             - 'figure_leave_event',
2252             - 'axes_enter_event',
2253             - 'axes_leave_event'
2254             - 'close_event'.
2255 
2256         func : callable
2257             The callback function to be executed, which must have the
2258             signature::
2259 
2260                 def func(event: Event) -> Any
2261 
2262             For the location events (button and key press/release), if the
2263             mouse is over the Axes, the ``inaxes`` attribute of the event will
2264             be set to the `~matplotlib.axes.Axes` the event occurs is over, and
2265             additionally, the variables ``xdata`` and ``ydata`` attributes will
2266             be set to the mouse location in data coordinates.  See `.KeyEvent`
2267             and `.MouseEvent` for more info.
2268 
2269             .. note::
2270 
2271                 If func is a method, this only stores a weak reference to the
2272                 method. Thus, the figure does not influence the lifetime of
2273                 the associated object. Usually, you want to make sure that the
2274                 object is kept alive throughout the lifetime of the figure by
2275                 holding a reference to it.
2276 
2277         Returns
2278         -------
2279         cid
2280             A connection id that can be used with
2281             `.FigureCanvasBase.mpl_disconnect`.
2282 
2283         Examples
2284         --------
2285         ::
2286 
2287             def on_press(event):
2288                 print('you pressed', event.button, event.xdata, event.ydata)
2289 
2290             cid = canvas.mpl_connect('button_press_event', on_press)
2291         """
2292 
2293         return self.callbacks.connect(s, func)
2294 
2295     def mpl_disconnect(self, cid):
2296         """
2297         Disconnect the callback with id *cid*.
2298 
2299         Examples
2300         --------
2301         ::
2302 
2303             cid = canvas.mpl_connect('button_press_event', on_press)
2304             # ... later
2305             canvas.mpl_disconnect(cid)
2306         """
2307         self.callbacks.disconnect(cid)
2308 
2309     # Internal subclasses can override _timer_cls instead of new_timer, though
2310     # this is not a public API for third-party subclasses.
2311     _timer_cls = TimerBase
2312 
2313     def new_timer(self, interval=None, callbacks=None):
2314         """
2315         Create a new backend-specific subclass of `.Timer`.
2316 
2317         This is useful for getting periodic events through the backend's native
2318         event loop.  Implemented only for backends with GUIs.
2319 
2320         Parameters
2321         ----------
2322         interval : int
2323             Timer interval in milliseconds.
2324 
2325         callbacks : list[tuple[callable, tuple, dict]]
2326             Sequence of (func, args, kwargs) where ``func(*args, **kwargs)``
2327             will be executed by the timer every *interval*.
2328 
2329             Callbacks which return ``False`` or ``0`` will be removed from the
2330             timer.
2331 
2332         Examples
2333         --------
2334         >>> timer = fig.canvas.new_timer(callbacks=[(f1, (1,), {'a': 3})])
2335         """
2336         return self._timer_cls(interval=interval, callbacks=callbacks)
2337 
2338     def flush_events(self):
2339         """
2340         Flush the GUI events for the figure.
2341 
2342         Interactive backends need to reimplement this method.
2343         """
2344 
2345     def start_event_loop(self, timeout=0):
2346         """
2347         Start a blocking event loop.
2348 
2349         Such an event loop is used by interactive functions, such as
2350         `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for
2351         events.
2352 
2353         The event loop blocks until a callback function triggers
2354         `stop_event_loop`, or *timeout* is reached.
2355 
2356         If *timeout* is 0 or negative, never timeout.
2357 
2358         Only interactive backends need to reimplement this method and it relies
2359         on `flush_events` being properly implemented.
2360 
2361         Interactive backends should implement this in a more native way.
2362         """
2363         if timeout <= 0:
2364             timeout = np.inf
2365         timestep = 0.01
2366         counter = 0
2367         self._looping = True
2368         while self._looping and counter * timestep < timeout:
2369             self.flush_events()
2370             time.sleep(timestep)
2371             counter += 1
2372 
2373     def stop_event_loop(self):
2374         """
2375         Stop the current blocking event loop.
2376 
2377         Interactive backends need to reimplement this to match
2378         `start_event_loop`
2379         """
2380         self._looping = False
2381 
2382 
2383 def key_press_handler(event, canvas=None, toolbar=None):
2384     """
2385     Implement the default Matplotlib key bindings for the canvas and toolbar
2386     described at :ref:`key-event-handling`.
2387 
2388     Parameters
2389     ----------
2390     event : `KeyEvent`
2391         A key press/release event.
2392     canvas : `FigureCanvasBase`, default: ``event.canvas``
2393         The backend-specific canvas instance.  This parameter is kept for
2394         back-compatibility, but, if set, should always be equal to
2395         ``event.canvas``.
2396     toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar``
2397         The navigation cursor toolbar.  This parameter is kept for
2398         back-compatibility, but, if set, should always be equal to
2399         ``event.canvas.toolbar``.
2400     """
2401     # these bindings happen whether you are over an Axes or not
2402 
2403     if event.key is None:
2404         return
2405     if canvas is None:
2406         canvas = event.canvas
2407     if toolbar is None:
2408         toolbar = canvas.toolbar
2409 
2410     # Load key-mappings from rcParams.
2411     fullscreen_keys = rcParams['keymap.fullscreen']
2412     home_keys = rcParams['keymap.home']
2413     back_keys = rcParams['keymap.back']
2414     forward_keys = rcParams['keymap.forward']
2415     pan_keys = rcParams['keymap.pan']
2416     zoom_keys = rcParams['keymap.zoom']
2417     save_keys = rcParams['keymap.save']
2418     quit_keys = rcParams['keymap.quit']
2419     quit_all_keys = rcParams['keymap.quit_all']
2420     grid_keys = rcParams['keymap.grid']
2421     grid_minor_keys = rcParams['keymap.grid_minor']
2422     toggle_yscale_keys = rcParams['keymap.yscale']
2423     toggle_xscale_keys = rcParams['keymap.xscale']
2424 
2425     # toggle fullscreen mode ('f', 'ctrl + f')
2426     if event.key in fullscreen_keys:
2427         try:
2428             canvas.manager.full_screen_toggle()
2429         except AttributeError:
2430             pass
2431 
2432     # quit the figure (default key 'ctrl+w')
2433     if event.key in quit_keys:
2434         Gcf.destroy_fig(canvas.figure)
2435     if event.key in quit_all_keys:
2436         Gcf.destroy_all()
2437 
2438     if toolbar is not None:
2439         # home or reset mnemonic  (default key 'h', 'home' and 'r')
2440         if event.key in home_keys:
2441             toolbar.home()
2442         # forward / backward keys to enable left handed quick navigation
2443         # (default key for backward: 'left', 'backspace' and 'c')
2444         elif event.key in back_keys:
2445             toolbar.back()
2446         # (default key for forward: 'right' and 'v')
2447         elif event.key in forward_keys:
2448             toolbar.forward()
2449         # pan mnemonic (default key 'p')
2450         elif event.key in pan_keys:
2451             toolbar.pan()
2452             toolbar._update_cursor(event)
2453         # zoom mnemonic (default key 'o')
2454         elif event.key in zoom_keys:
2455             toolbar.zoom()
2456             toolbar._update_cursor(event)
2457         # saving current figure (default key 's')
2458         elif event.key in save_keys:
2459             toolbar.save_figure()
2460 
2461     if event.inaxes is None:
2462         return
2463 
2464     # these bindings require the mouse to be over an Axes to trigger
2465     def _get_uniform_gridstate(ticks):
2466         # Return True/False if all grid lines are on or off, None if they are
2467         # not all in the same state.
2468         if all(tick.gridline.get_visible() for tick in ticks):
2469             return True
2470         elif not any(tick.gridline.get_visible() for tick in ticks):
2471             return False
2472         else:
2473             return None
2474 
2475     ax = event.inaxes
2476     # toggle major grids in current Axes (default key 'g')
2477     # Both here and below (for 'G'), we do nothing if *any* grid (major or
2478     # minor, x or y) is not in a uniform state, to avoid messing up user
2479     # customization.
2480     if (event.key in grid_keys
2481             # Exclude minor grids not in a uniform state.
2482             and None not in [_get_uniform_gridstate(ax.xaxis.minorTicks),
2483                              _get_uniform_gridstate(ax.yaxis.minorTicks)]):
2484         x_state = _get_uniform_gridstate(ax.xaxis.majorTicks)
2485         y_state = _get_uniform_gridstate(ax.yaxis.majorTicks)
2486         cycle = [(False, False), (True, False), (True, True), (False, True)]
2487         try:
2488             x_state, y_state = (
2489                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])
2490         except ValueError:
2491             # Exclude major grids not in a uniform state.
2492             pass
2493         else:
2494             # If turning major grids off, also turn minor grids off.
2495             ax.grid(x_state, which="major" if x_state else "both", axis="x")
2496             ax.grid(y_state, which="major" if y_state else "both", axis="y")
2497             canvas.draw_idle()
2498     # toggle major and minor grids in current Axes (default key 'G')
2499     if (event.key in grid_minor_keys
2500             # Exclude major grids not in a uniform state.
2501             and None not in [_get_uniform_gridstate(ax.xaxis.majorTicks),
2502                              _get_uniform_gridstate(ax.yaxis.majorTicks)]):
2503         x_state = _get_uniform_gridstate(ax.xaxis.minorTicks)
2504         y_state = _get_uniform_gridstate(ax.yaxis.minorTicks)
2505         cycle = [(False, False), (True, False), (True, True), (False, True)]
2506         try:
2507             x_state, y_state = (
2508                 cycle[(cycle.index((x_state, y_state)) + 1) % len(cycle)])
2509         except ValueError:
2510             # Exclude minor grids not in a uniform state.
2511             pass
2512         else:
2513             ax.grid(x_state, which="both", axis="x")
2514             ax.grid(y_state, which="both", axis="y")
2515             canvas.draw_idle()
2516     # toggle scaling of y-axes between 'log and 'linear' (default key 'l')
2517     elif event.key in toggle_yscale_keys:
2518         scale = ax.get_yscale()
2519         if scale == 'log':
2520             ax.set_yscale('linear')
2521             ax.figure.canvas.draw_idle()
2522         elif scale == 'linear':
2523             try:
2524                 ax.set_yscale('log')
2525             except ValueError as exc:
2526                 _log.warning(str(exc))
2527                 ax.set_yscale('linear')
2528             ax.figure.canvas.draw_idle()
2529     # toggle scaling of x-axes between 'log and 'linear' (default key 'k')
2530     elif event.key in toggle_xscale_keys:
2531         scalex = ax.get_xscale()
2532         if scalex == 'log':
2533             ax.set_xscale('linear')
2534             ax.figure.canvas.draw_idle()
2535         elif scalex == 'linear':
2536             try:
2537                 ax.set_xscale('log')
2538             except ValueError as exc:
2539                 _log.warning(str(exc))
2540                 ax.set_xscale('linear')
2541             ax.figure.canvas.draw_idle()
2542 
2543 
2544 def button_press_handler(event, canvas=None, toolbar=None):
2545     """
2546     The default Matplotlib button actions for extra mouse buttons.
2547 
2548     Parameters are as for `key_press_handler`, except that *event* is a
2549     `MouseEvent`.
2550     """
2551     if canvas is None:
2552         canvas = event.canvas
2553     if toolbar is None:
2554         toolbar = canvas.toolbar
2555     if toolbar is not None:
2556         button_name = str(MouseButton(event.button))
2557         if button_name in rcParams['keymap.back']:
2558             toolbar.back()
2559         elif button_name in rcParams['keymap.forward']:
2560             toolbar.forward()
2561 
2562 
2563 class NonGuiException(Exception):
2564     """Raised when trying show a figure in a non-GUI backend."""
2565     pass
2566 
2567 
2568 class FigureManagerBase:
2569     """
2570     A backend-independent abstraction of a figure container and controller.
2571 
2572     The figure manager is used by pyplot to interact with the window in a
2573     backend-independent way. It's an adapter for the real (GUI) framework that
2574     represents the visual figure on screen.
2575 
2576     GUI backends define from this class to translate common operations such
2577     as *show* or *resize* to the GUI-specific code. Non-GUI backends do not
2578     support these operations an can just use the base class.
2579 
2580     This following basic operations are accessible:
2581 
2582     **Window operations**
2583 
2584     - `~.FigureManagerBase.show`
2585     - `~.FigureManagerBase.destroy`
2586     - `~.FigureManagerBase.full_screen_toggle`
2587     - `~.FigureManagerBase.resize`
2588     - `~.FigureManagerBase.get_window_title`
2589     - `~.FigureManagerBase.set_window_title`
2590 
2591     **Key and mouse button press handling**
2592 
2593     The figure manager sets up default key and mouse button press handling by
2594     hooking up the `.key_press_handler` to the matplotlib event system. This
2595     ensures the same shortcuts and mouse actions across backends.
2596 
2597     **Other operations**
2598 
2599     Subclasses will have additional attributes and functions to access
2600     additional functionality. This is of course backend-specific. For example,
2601     most GUI backends have ``window`` and ``toolbar`` attributes that give
2602     access to the native GUI widgets of the respective framework.
2603 
2604     Attributes
2605     ----------
2606     canvas : `FigureCanvasBase`
2607         The backend-specific canvas instance.
2608 
2609     num : int or str
2610         The figure number.
2611 
2612     key_press_handler_id : int
2613         The default key handler cid, when using the toolmanager.
2614         To disable the default key press handling use::
2615 
2616             figure.canvas.mpl_disconnect(
2617                 figure.canvas.manager.key_press_handler_id)
2618 
2619     button_press_handler_id : int
2620         The default mouse button handler cid, when using the toolmanager.
2621         To disable the default button press handling use::
2622 
2623             figure.canvas.mpl_disconnect(
2624                 figure.canvas.manager.button_press_handler_id)
2625     """
2626 
2627     _toolbar2_class = None
2628     _toolmanager_toolbar_class = None
2629 
2630     def __init__(self, canvas, num):
2631         self.canvas = canvas
2632         canvas.manager = self  # store a pointer to parent
2633         self.num = num
2634         self.set_window_title(f"Figure {num:d}")
2635 
2636         self.key_press_handler_id = None
2637         self.button_press_handler_id = None
2638         if rcParams['toolbar'] != 'toolmanager':
2639             self.key_press_handler_id = self.canvas.mpl_connect(
2640                 'key_press_event', key_press_handler)
2641             self.button_press_handler_id = self.canvas.mpl_connect(
2642                 'button_press_event', button_press_handler)
2643 
2644         self.toolmanager = (ToolManager(canvas.figure)
2645                             if mpl.rcParams['toolbar'] == 'toolmanager'
2646                             else None)
2647         if (mpl.rcParams["toolbar"] == "toolbar2"
2648                 and self._toolbar2_class):
2649             self.toolbar = self._toolbar2_class(self.canvas)
2650         elif (mpl.rcParams["toolbar"] == "toolmanager"
2651                 and self._toolmanager_toolbar_class):
2652             self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)
2653         else:
2654             self.toolbar = None
2655 
2656         if self.toolmanager:
2657             tools.add_tools_to_manager(self.toolmanager)
2658             if self.toolbar:
2659                 tools.add_tools_to_container(self.toolbar)
2660 
2661         @self.canvas.figure.add_axobserver
2662         def notify_axes_change(fig):
2663             # Called whenever the current Axes is changed.
2664             if self.toolmanager is None and self.toolbar is not None:
2665                 self.toolbar.update()
2666 
2667     @classmethod
2668     def create_with_canvas(cls, canvas_class, figure, num):
2669         """
2670         Create a manager for a given *figure* using a specific *canvas_class*.
2671 
2672         Backends should override this method if they have specific needs for
2673         setting up the canvas or the manager.
2674         """
2675         return cls(canvas_class(figure), num)
2676 
2677     @classmethod
2678     def start_main_loop(cls):
2679         """
2680         Start the main event loop.
2681 
2682         This method is called by `.FigureManagerBase.pyplot_show`, which is the
2683         implementation of `.pyplot.show`.  To customize the behavior of
2684         `.pyplot.show`, interactive backends should usually override
2685         `~.FigureManagerBase.start_main_loop`; if more customized logic is
2686         necessary, `~.FigureManagerBase.pyplot_show` can also be overridden.
2687         """
2688 
2689     @classmethod
2690     def pyplot_show(cls, *, block=None):
2691         """
2692         Show all figures.  This method is the implementation of `.pyplot.show`.
2693 
2694         To customize the behavior of `.pyplot.show`, interactive backends
2695         should usually override `~.FigureManagerBase.start_main_loop`; if more
2696         customized logic is necessary, `~.FigureManagerBase.pyplot_show` can
2697         also be overridden.
2698 
2699         Parameters
2700         ----------
2701         block : bool, optional
2702             Whether to block by calling ``start_main_loop``.  The default,
2703             None, means to block if we are neither in IPython's ``%pylab`` mode
2704             nor in ``interactive`` mode.
2705         """
2706         managers = Gcf.get_all_fig_managers()
2707         if not managers:
2708             return
2709         for manager in managers:
2710             try:
2711                 manager.show()  # Emits a warning for non-interactive backend.
2712             except NonGuiException as exc:
2713                 _api.warn_external(str(exc))
2714         if block is None:
2715             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython
2716             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always
2717             # set to False).
2718             pyplot_show = getattr(sys.modules.get("matplotlib.pyplot"), "show", None)
2719             ipython_pylab = hasattr(pyplot_show, "_needmain")
2720             block = not ipython_pylab and not is_interactive()
2721         if block:
2722             cls.start_main_loop()
2723 
2724     def show(self):
2725         """
2726         For GUI backends, show the figure window and redraw.
2727         For non-GUI backends, raise an exception, unless running headless (i.e.
2728         on Linux with an unset DISPLAY); this exception is converted to a
2729         warning in `.Figure.show`.
2730         """
2731         # This should be overridden in GUI backends.
2732         if sys.platform == "linux" and not os.environ.get("DISPLAY"):
2733             # We cannot check _get_running_interactive_framework() ==
2734             # "headless" because that would also suppress the warning when
2735             # $DISPLAY exists but is invalid, which is more likely an error and
2736             # thus warrants a warning.
2737             return
2738         raise NonGuiException(
2739             f"Matplotlib is currently using {get_backend()}, which is a "
2740             f"non-GUI backend, so cannot show the figure.")
2741 
2742     def destroy(self):
2743         pass
2744 
2745     def full_screen_toggle(self):
2746         pass
2747 
2748     def resize(self, w, h):
2749         """For GUI backends, resize the window (in physical pixels)."""
2750 
2751     def get_window_title(self):
2752         """
2753         Return the title text of the window containing the figure, or None
2754         if there is no window (e.g., a PS backend).
2755         """
2756         return 'image'
2757 
2758     def set_window_title(self, title):
2759         """
2760         Set the title text of the window containing the figure.
2761 
2762         This has no effect for non-GUI (e.g., PS) backends.
2763         """
2764 
2765 
2766 cursors = tools.cursors
2767 
2768 
2769 class _Mode(str, Enum):
2770     NONE = ""
2771     PAN = "pan/zoom"
2772     ZOOM = "zoom rect"
2773 
2774     def __str__(self):
2775         return self.value
2776 
2777     @property
2778     def _navigate_mode(self):
2779         return self.name if self is not _Mode.NONE else None
2780 
2781 
2782 class NavigationToolbar2:
2783     """
2784     Base class for the navigation cursor, version 2.
2785 
2786     Backends must implement a canvas that handles connections for
2787     'button_press_event' and 'button_release_event'.  See
2788     :meth:`FigureCanvasBase.mpl_connect` for more information.
2789 
2790     They must also define
2791 
2792     :meth:`save_figure`
2793         Save the current figure.
2794 
2795     :meth:`draw_rubberband` (optional)
2796         Draw the zoom to rect "rubberband" rectangle.
2797 
2798     :meth:`set_message` (optional)
2799         Display message.
2800 
2801     :meth:`set_history_buttons` (optional)
2802         You can change the history back / forward buttons to indicate disabled / enabled
2803         state.
2804 
2805     and override ``__init__`` to set up the toolbar -- without forgetting to
2806     call the base-class init.  Typically, ``__init__`` needs to set up toolbar
2807     buttons connected to the `home`, `back`, `forward`, `pan`, `zoom`, and
2808     `save_figure` methods and using standard icons in the "images" subdirectory
2809     of the data path.
2810 
2811     That's it, we'll do the rest!
2812     """
2813 
2814     # list of toolitems to add to the toolbar, format is:
2815     # (
2816     #   text, # the text of the button (often not visible to users)
2817     #   tooltip_text, # the tooltip shown on hover (where possible)
2818     #   image_file, # name of the image for the button (without the extension)
2819     #   name_of_method, # name of the method in NavigationToolbar2 to call
2820     # )
2821     toolitems = (
2822         ('Home', 'Reset original view', 'home', 'home'),
2823         ('Back', 'Back to previous view', 'back', 'back'),
2824         ('Forward', 'Forward to next view', 'forward', 'forward'),
2825         (None, None, None, None),
2826         ('Pan',
2827          'Left button pans, Right button zooms\n'
2828          'x/y fixes axis, CTRL fixes aspect',
2829          'move', 'pan'),
2830         ('Zoom', 'Zoom to rectangle\nx/y fixes axis', 'zoom_to_rect', 'zoom'),
2831         ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'),
2832         (None, None, None, None),
2833         ('Save', 'Save the figure', 'filesave', 'save_figure'),
2834       )
2835 
2836     def __init__(self, canvas):
2837         self.canvas = canvas
2838         canvas.toolbar = self
2839         self._nav_stack = cbook._Stack()
2840         # This cursor will be set after the initial draw.
2841         self._last_cursor = tools.Cursors.POINTER
2842 
2843         self._id_press = self.canvas.mpl_connect(
2844             'button_press_event', self._zoom_pan_handler)
2845         self._id_release = self.canvas.mpl_connect(
2846             'button_release_event', self._zoom_pan_handler)
2847         self._id_drag = self.canvas.mpl_connect(
2848             'motion_notify_event', self.mouse_move)
2849         self._pan_info = None
2850         self._zoom_info = None
2851 
2852         self.mode = _Mode.NONE  # a mode string for the status bar
2853         self.set_history_buttons()
2854 
2855     def set_message(self, s):
2856         """Display a message on toolbar or in status bar."""
2857 
2858     def draw_rubberband(self, event, x0, y0, x1, y1):
2859         """
2860         Draw a rectangle rubberband to indicate zoom limits.
2861 
2862         Note that it is not guaranteed that ``x0 <= x1`` and ``y0 <= y1``.
2863         """
2864 
2865     def remove_rubberband(self):
2866         """Remove the rubberband."""
2867 
2868     def home(self, *args):
2869         """
2870         Restore the original view.
2871 
2872         For convenience of being directly connected as a GUI callback, which
2873         often get passed additional parameters, this method accepts arbitrary
2874         parameters, but does not use them.
2875         """
2876         self._nav_stack.home()
2877         self.set_history_buttons()
2878         self._update_view()
2879 
2880     def back(self, *args):
2881         """
2882         Move back up the view lim stack.
2883 
2884         For convenience of being directly connected as a GUI callback, which
2885         often get passed additional parameters, this method accepts arbitrary
2886         parameters, but does not use them.
2887         """
2888         self._nav_stack.back()
2889         self.set_history_buttons()
2890         self._update_view()
2891 
2892     def forward(self, *args):
2893         """
2894         Move forward in the view lim stack.
2895 
2896         For convenience of being directly connected as a GUI callback, which
2897         often get passed additional parameters, this method accepts arbitrary
2898         parameters, but does not use them.
2899         """
2900         self._nav_stack.forward()
2901         self.set_history_buttons()
2902         self._update_view()
2903 
2904     def _update_cursor(self, event):
2905         """
2906         Update the cursor after a mouse move event or a tool (de)activation.
2907         """
2908         if self.mode and event.inaxes and event.inaxes.get_navigate():
2909             if (self.mode == _Mode.ZOOM
2910                     and self._last_cursor != tools.Cursors.SELECT_REGION):
2911                 self.canvas.set_cursor(tools.Cursors.SELECT_REGION)
2912                 self._last_cursor = tools.Cursors.SELECT_REGION
2913             elif (self.mode == _Mode.PAN
2914                   and self._last_cursor != tools.Cursors.MOVE):
2915                 self.canvas.set_cursor(tools.Cursors.MOVE)
2916                 self._last_cursor = tools.Cursors.MOVE
2917         elif self._last_cursor != tools.Cursors.POINTER:
2918             self.canvas.set_cursor(tools.Cursors.POINTER)
2919             self._last_cursor = tools.Cursors.POINTER
2920 
2921     @contextmanager
2922     def _wait_cursor_for_draw_cm(self):
2923         """
2924         Set the cursor to a wait cursor when drawing the canvas.
2925 
2926         In order to avoid constantly changing the cursor when the canvas
2927         changes frequently, do nothing if this context was triggered during the
2928         last second.  (Optimally we'd prefer only setting the wait cursor if
2929         the *current* draw takes too long, but the current draw blocks the GUI
2930         thread).
2931         """
2932         self._draw_time, last_draw_time = (
2933             time.time(), getattr(self, "_draw_time", -np.inf))
2934         if self._draw_time - last_draw_time > 1:
2935             try:
2936                 self.canvas.set_cursor(tools.Cursors.WAIT)
2937                 yield
2938             finally:
2939                 self.canvas.set_cursor(self._last_cursor)
2940         else:
2941             yield
2942 
2943     @staticmethod
2944     def _mouse_event_to_message(event):
2945         if event.inaxes and event.inaxes.get_navigate():
2946             try:
2947                 s = event.inaxes.format_coord(event.xdata, event.ydata)
2948             except (ValueError, OverflowError):
2949                 pass
2950             else:
2951                 s = s.rstrip()
2952                 artists = [a for a in event.inaxes._mouseover_set
2953                            if a.contains(event)[0] and a.get_visible()]
2954                 if artists:
2955                     a = cbook._topmost_artist(artists)
2956                     if a is not event.inaxes.patch:
2957                         data = a.get_cursor_data(event)
2958                         if data is not None:
2959                             data_str = a.format_cursor_data(data).rstrip()
2960                             if data_str:
2961                                 s = s + '\n' + data_str
2962                 return s
2963         return ""
2964 
2965     def mouse_move(self, event):
2966         self._update_cursor(event)
2967         self.set_message(self._mouse_event_to_message(event))
2968 
2969     def _zoom_pan_handler(self, event):
2970         if self.mode == _Mode.PAN:
2971             if event.name == "button_press_event":
2972                 self.press_pan(event)
2973             elif event.name == "button_release_event":
2974                 self.release_pan(event)
2975         if self.mode == _Mode.ZOOM:
2976             if event.name == "button_press_event":
2977                 self.press_zoom(event)
2978             elif event.name == "button_release_event":
2979                 self.release_zoom(event)
2980 
2981     def pan(self, *args):
2982         """
2983         Toggle the pan/zoom tool.
2984 
2985         Pan with left button, zoom with right.
2986         """
2987         if not self.canvas.widgetlock.available(self):
2988             self.set_message("pan unavailable")
2989             return
2990         if self.mode == _Mode.PAN:
2991             self.mode = _Mode.NONE
2992             self.canvas.widgetlock.release(self)
2993         else:
2994             self.mode = _Mode.PAN
2995             self.canvas.widgetlock(self)
2996         for a in self.canvas.figure.get_axes():
2997             a.set_navigate_mode(self.mode._navigate_mode)
2998 
2999     _PanInfo = namedtuple("_PanInfo", "button axes cid")
3000 
3001     def press_pan(self, event):
3002         """Callback for mouse button press in pan/zoom mode."""
3003         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]
3004                 or event.x is None or event.y is None):
3005             return
3006         axes = [a for a in self.canvas.figure.get_axes()
3007                 if a.in_axes(event) and a.get_navigate() and a.can_pan()]
3008         if not axes:
3009             return
3010         if self._nav_stack() is None:
3011             self.push_current()  # set the home button to this view
3012         for ax in axes:
3013             ax.start_pan(event.x, event.y, event.button)
3014         self.canvas.mpl_disconnect(self._id_drag)
3015         id_drag = self.canvas.mpl_connect("motion_notify_event", self.drag_pan)
3016         self._pan_info = self._PanInfo(
3017             button=event.button, axes=axes, cid=id_drag)
3018 
3019     def drag_pan(self, event):
3020         """Callback for dragging in pan/zoom mode."""
3021         for ax in self._pan_info.axes:
3022             # Using the recorded button at the press is safer than the current
3023             # button, as multiple buttons can get pressed during motion.
3024             ax.drag_pan(self._pan_info.button, event.key, event.x, event.y)
3025         self.canvas.draw_idle()
3026 
3027     def release_pan(self, event):
3028         """Callback for mouse button release in pan/zoom mode."""
3029         if self._pan_info is None:
3030             return
3031         self.canvas.mpl_disconnect(self._pan_info.cid)
3032         self._id_drag = self.canvas.mpl_connect(
3033             'motion_notify_event', self.mouse_move)
3034         for ax in self._pan_info.axes:
3035             ax.end_pan()
3036         self.canvas.draw_idle()
3037         self._pan_info = None
3038         self.push_current()
3039 
3040     def zoom(self, *args):
3041         if not self.canvas.widgetlock.available(self):
3042             self.set_message("zoom unavailable")
3043             return
3044         """Toggle zoom to rect mode."""
3045         if self.mode == _Mode.ZOOM:
3046             self.mode = _Mode.NONE
3047             self.canvas.widgetlock.release(self)
3048         else:
3049             self.mode = _Mode.ZOOM
3050             self.canvas.widgetlock(self)
3051         for a in self.canvas.figure.get_axes():
3052             a.set_navigate_mode(self.mode._navigate_mode)
3053 
3054     _ZoomInfo = namedtuple("_ZoomInfo", "direction start_xy axes cid cbar")
3055 
3056     def press_zoom(self, event):
3057         """Callback for mouse button press in zoom to rect mode."""
3058         if (event.button not in [MouseButton.LEFT, MouseButton.RIGHT]
3059                 or event.x is None or event.y is None):
3060             return
3061         axes = [a for a in self.canvas.figure.get_axes()
3062                 if a.in_axes(event) and a.get_navigate() and a.can_zoom()]
3063         if not axes:
3064             return
3065         if self._nav_stack() is None:
3066             self.push_current()  # set the home button to this view
3067         id_zoom = self.canvas.mpl_connect(
3068             "motion_notify_event", self.drag_zoom)
3069         # A colorbar is one-dimensional, so we extend the zoom rectangle out
3070         # to the edge of the Axes bbox in the other dimension. To do that we
3071         # store the orientation of the colorbar for later.
3072         if hasattr(axes[0], "_colorbar"):
3073             cbar = axes[0]._colorbar.orientation
3074         else:
3075             cbar = None
3076         self._zoom_info = self._ZoomInfo(
3077             direction="in" if event.button == 1 else "out",
3078             start_xy=(event.x, event.y), axes=axes, cid=id_zoom, cbar=cbar)
3079 
3080     def drag_zoom(self, event):
3081         """Callback for dragging in zoom mode."""
3082         start_xy = self._zoom_info.start_xy
3083         ax = self._zoom_info.axes[0]
3084         (x1, y1), (x2, y2) = np.clip(
3085             [start_xy, [event.x, event.y]], ax.bbox.min, ax.bbox.max)
3086         key = event.key
3087         # Force the key on colorbars to extend the short-axis bbox
3088         if self._zoom_info.cbar == "horizontal":
3089             key = "x"
3090         elif self._zoom_info.cbar == "vertical":
3091             key = "y"
3092         if key == "x":
3093             y1, y2 = ax.bbox.intervaly
3094         elif key == "y":
3095             x1, x2 = ax.bbox.intervalx
3096 
3097         self.draw_rubberband(event, x1, y1, x2, y2)
3098 
3099     def release_zoom(self, event):
3100         """Callback for mouse button release in zoom to rect mode."""
3101         if self._zoom_info is None:
3102             return
3103 
3104         # We don't check the event button here, so that zooms can be cancelled
3105         # by (pressing and) releasing another mouse button.
3106         self.canvas.mpl_disconnect(self._zoom_info.cid)
3107         self.remove_rubberband()
3108 
3109         start_x, start_y = self._zoom_info.start_xy
3110         key = event.key
3111         # Force the key on colorbars to ignore the zoom-cancel on the
3112         # short-axis side
3113         if self._zoom_info.cbar == "horizontal":
3114             key = "x"
3115         elif self._zoom_info.cbar == "vertical":
3116             key = "y"
3117         # Ignore single clicks: 5 pixels is a threshold that allows the user to
3118         # "cancel" a zoom action by zooming by less than 5 pixels.
3119         if ((abs(event.x - start_x) < 5 and key != "y") or
3120                 (abs(event.y - start_y) < 5 and key != "x")):
3121             self.canvas.draw_idle()
3122             self._zoom_info = None
3123             return
3124 
3125         for i, ax in enumerate(self._zoom_info.axes):
3126             # Detect whether this Axes is twinned with an earlier Axes in the
3127             # list of zoomed Axes, to avoid double zooming.
3128             twinx = any(ax.get_shared_x_axes().joined(ax, prev)
3129                         for prev in self._zoom_info.axes[:i])
3130             twiny = any(ax.get_shared_y_axes().joined(ax, prev)
3131                         for prev in self._zoom_info.axes[:i])
3132             ax._set_view_from_bbox(
3133                 (start_x, start_y, event.x, event.y),
3134                 self._zoom_info.direction, key, twinx, twiny)
3135 
3136         self.canvas.draw_idle()
3137         self._zoom_info = None
3138         self.push_current()
3139 
3140     def push_current(self):
3141         """Push the current view limits and position onto the stack."""
3142         self._nav_stack.push(
3143             WeakKeyDictionary(
3144                 {ax: (ax._get_view(),
3145                       # Store both the original and modified positions.
3146                       (ax.get_position(True).frozen(),
3147                        ax.get_position().frozen()))
3148                  for ax in self.canvas.figure.axes}))
3149         self.set_history_buttons()
3150 
3151     def _update_view(self):
3152         """
3153         Update the viewlim and position from the view and position stack for
3154         each Axes.
3155         """
3156         nav_info = self._nav_stack()
3157         if nav_info is None:
3158             return
3159         # Retrieve all items at once to avoid any risk of GC deleting an Axes
3160         # while in the middle of the loop below.
3161         items = list(nav_info.items())
3162         for ax, (view, (pos_orig, pos_active)) in items:
3163             ax._set_view(view)
3164             # Restore both the original and modified positions
3165             ax._set_position(pos_orig, 'original')
3166             ax._set_position(pos_active, 'active')
3167         self.canvas.draw_idle()
3168 
3169     def configure_subplots(self, *args):
3170         if hasattr(self, "subplot_tool"):
3171             self.subplot_tool.figure.canvas.manager.show()
3172             return
3173         # This import needs to happen here due to circular imports.
3174         from matplotlib.figure import Figure
3175         with mpl.rc_context({"toolbar": "none"}):  # No navbar for the toolfig.
3176             manager = type(self.canvas).new_manager(Figure(figsize=(6, 3)), -1)
3177         manager.set_window_title("Subplot configuration tool")
3178         tool_fig = manager.canvas.figure
3179         tool_fig.subplots_adjust(top=0.9)
3180         self.subplot_tool = widgets.SubplotTool(self.canvas.figure, tool_fig)
3181         cid = self.canvas.mpl_connect(
3182             "close_event", lambda e: manager.destroy())
3183 
3184         def on_tool_fig_close(e):
3185             self.canvas.mpl_disconnect(cid)
3186             del self.subplot_tool
3187 
3188         tool_fig.canvas.mpl_connect("close_event", on_tool_fig_close)
3189         manager.show()
3190         return self.subplot_tool
3191 
3192     def save_figure(self, *args):
3193         """Save the current figure."""
3194         raise NotImplementedError
3195 
3196     def update(self):
3197         """Reset the Axes stack."""
3198         self._nav_stack.clear()
3199         self.set_history_buttons()
3200 
3201     def set_history_buttons(self):
3202         """Enable or disable the back/forward button."""
3203 
3204 
3205 class ToolContainerBase:
3206     """
3207     Base class for all tool containers, e.g. toolbars.
3208 
3209     Attributes
3210     ----------
3211     toolmanager : `.ToolManager`
3212         The tools with which this `ToolContainer` wants to communicate.
3213     """
3214 
3215     _icon_extension = '.png'
3216     """
3217     Toolcontainer button icon image format extension
3218 
3219     **String**: Image extension
3220     """
3221 
3222     def __init__(self, toolmanager):
3223         self.toolmanager = toolmanager
3224         toolmanager.toolmanager_connect(
3225             'tool_message_event',
3226             lambda event: self.set_message(event.message))
3227         toolmanager.toolmanager_connect(
3228             'tool_removed_event',
3229             lambda event: self.remove_toolitem(event.tool.name))
3230 
3231     def _tool_toggled_cbk(self, event):
3232         """
3233         Capture the 'tool_trigger_[name]'
3234 
3235         This only gets used for toggled tools.
3236         """
3237         self.toggle_toolitem(event.tool.name, event.tool.toggled)
3238 
3239     def add_tool(self, tool, group, position=-1):
3240         """
3241         Add a tool to this container.
3242 
3243         Parameters
3244         ----------
3245         tool : tool_like
3246             The tool to add, see `.ToolManager.get_tool`.
3247         group : str
3248             The name of the group to add this tool to.
3249         position : int, default: -1
3250             The position within the group to place this tool.
3251         """
3252         tool = self.toolmanager.get_tool(tool)
3253         image = self._get_image_filename(tool.image)
3254         toggle = getattr(tool, 'toggled', None) is not None
3255         self.add_toolitem(tool.name, group, position,
3256                           image, tool.description, toggle)
3257         if toggle:
3258             self.toolmanager.toolmanager_connect('tool_trigger_%s' % tool.name,
3259                                                  self._tool_toggled_cbk)
3260             # If initially toggled
3261             if tool.toggled:
3262                 self.toggle_toolitem(tool.name, True)
3263 
3264     def _get_image_filename(self, image):
3265         """Find the image based on its name."""
3266         if not image:
3267             return None
3268 
3269         basedir = cbook._get_data_path("images")
3270         for fname in [
3271             image,
3272             image + self._icon_extension,
3273             str(basedir / image),
3274             str(basedir / (image + self._icon_extension)),
3275         ]:
3276             if os.path.isfile(fname):
3277                 return fname
3278 
3279     def trigger_tool(self, name):
3280         """
3281         Trigger the tool.
3282 
3283         Parameters
3284         ----------
3285         name : str
3286             Name (id) of the tool triggered from within the container.
3287         """
3288         self.toolmanager.trigger_tool(name, sender=self)
3289 
3290     def add_toolitem(self, name, group, position, image, description, toggle):
3291         """
3292         Add a toolitem to the container.
3293 
3294         This method must be implemented per backend.
3295 
3296         The callback associated with the button click event,
3297         must be *exactly* ``self.trigger_tool(name)``.
3298 
3299         Parameters
3300         ----------
3301         name : str
3302             Name of the tool to add, this gets used as the tool's ID and as the
3303             default label of the buttons.
3304         group : str
3305             Name of the group that this tool belongs to.
3306         position : int
3307             Position of the tool within its group, if -1 it goes at the end.
3308         image : str
3309             Filename of the image for the button or `None`.
3310         description : str
3311             Description of the tool, used for the tooltips.
3312         toggle : bool
3313             * `True` : The button is a toggle (change the pressed/unpressed
3314               state between consecutive clicks).
3315             * `False` : The button is a normal button (returns to unpressed
3316               state after release).
3317         """
3318         raise NotImplementedError
3319 
3320     def toggle_toolitem(self, name, toggled):
3321         """
3322         Toggle the toolitem without firing event.
3323 
3324         Parameters
3325         ----------
3326         name : str
3327             Id of the tool to toggle.
3328         toggled : bool
3329             Whether to set this tool as toggled or not.
3330         """
3331         raise NotImplementedError
3332 
3333     def remove_toolitem(self, name):
3334         """
3335         Remove a toolitem from the `ToolContainer`.
3336 
3337         This method must get implemented per backend.
3338 
3339         Called when `.ToolManager` emits a `tool_removed_event`.
3340 
3341         Parameters
3342         ----------
3343         name : str
3344             Name of the tool to remove.
3345         """
3346         raise NotImplementedError
3347 
3348     def set_message(self, s):
3349         """
3350         Display a message on the toolbar.
3351 
3352         Parameters
3353         ----------
3354         s : str
3355             Message text.
3356         """
3357         raise NotImplementedError
3358 
3359 
3360 class _Backend:
3361     # A backend can be defined by using the following pattern:
3362     #
3363     # @_Backend.export
3364     # class FooBackend(_Backend):
3365     #     # override the attributes and methods documented below.
3366 
3367     # `backend_version` may be overridden by the subclass.
3368     backend_version = "unknown"
3369 
3370     # The `FigureCanvas` class must be defined.
3371     FigureCanvas = None
3372 
3373     # For interactive backends, the `FigureManager` class must be overridden.
3374     FigureManager = FigureManagerBase
3375 
3376     # For interactive backends, `mainloop` should be a function taking no
3377     # argument and starting the backend main loop.  It should be left as None
3378     # for non-interactive backends.
3379     mainloop = None
3380 
3381     # The following methods will be automatically defined and exported, but
3382     # can be overridden.
3383 
3384     @classmethod
3385     def new_figure_manager(cls, num, *args, **kwargs):
3386         """Create a new figure manager instance."""
3387         # This import needs to happen here due to circular imports.
3388         from matplotlib.figure import Figure
3389         fig_cls = kwargs.pop('FigureClass', Figure)
3390         fig = fig_cls(*args, **kwargs)
3391         return cls.new_figure_manager_given_figure(num, fig)
3392 
3393     @classmethod
3394     def new_figure_manager_given_figure(cls, num, figure):
3395         """Create a new figure manager instance for the given figure."""
3396         return cls.FigureCanvas.new_manager(figure, num)
3397 
3398     @classmethod
3399     def draw_if_interactive(cls):
3400         manager_class = cls.FigureCanvas.manager_class
3401         # Interactive backends reimplement start_main_loop or pyplot_show.
3402         backend_is_interactive = (
3403             manager_class.start_main_loop != FigureManagerBase.start_main_loop
3404             or manager_class.pyplot_show != FigureManagerBase.pyplot_show)
3405         if backend_is_interactive and is_interactive():
3406             manager = Gcf.get_active()
3407             if manager:
3408                 manager.canvas.draw_idle()
3409 
3410     @classmethod
3411     def show(cls, *, block=None):
3412         """
3413         Show all figures.
3414 
3415         `show` blocks by calling `mainloop` if *block* is ``True``, or if it
3416         is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in
3417         `interactive` mode.
3418         """
3419         managers = Gcf.get_all_fig_managers()
3420         if not managers:
3421             return
3422         for manager in managers:
3423             try:
3424                 manager.show()  # Emits a warning for non-interactive backend.
3425             except NonGuiException as exc:
3426                 _api.warn_external(str(exc))
3427         if cls.mainloop is None:
3428             return
3429         if block is None:
3430             # Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython
3431             # (>= 0.10) tacks a _needmain attribute onto pyplot.show (always
3432             # set to False).
3433             pyplot_show = getattr(sys.modules.get("matplotlib.pyplot"), "show", None)
3434             ipython_pylab = hasattr(pyplot_show, "_needmain")
3435             block = not ipython_pylab and not is_interactive()
3436         if block:
3437             cls.mainloop()
3438 
3439     # This method is the one actually exporting the required methods.
3440 
3441     @staticmethod
3442     def export(cls):
3443         for name in [
3444                 "backend_version",
3445                 "FigureCanvas",
3446                 "FigureManager",
3447                 "new_figure_manager",
3448                 "new_figure_manager_given_figure",
3449                 "draw_if_interactive",
3450                 "show",
3451         ]:
3452             setattr(sys.modules[cls.__module__], name, getattr(cls, name))
3453 
3454         # For back-compatibility, generate a shim `Show` class.
3455 
3456         class Show(ShowBase):
3457             def mainloop(self):
3458                 return cls.mainloop()
3459 
3460         setattr(sys.modules[cls.__module__], "Show", Show)
3461         return cls
3462 
3463 
3464 class ShowBase(_Backend):
3465     """
3466     Simple base class to generate a ``show()`` function in backends.
3467 
3468     Subclass must override ``mainloop()`` method.
3469     """
3470 
3471     def __call__(self, block=None):
3472         return self.show(block=block)

</code><intended_behavior>This file, which is likely involved in the fundamental implementation of display mechanisms across backends, may require modifications to the `show()` method implementations specific to different backends. The adjustments should ensure that figures designated to remain open (perhaps through a mechanism introduced in `pyplot.py`) are not closed when the backend switches to `inline`. This could involve enhancing the `show()` method or related utility functions to acknowledge the new state management logic introduced in `pyplot.py` for backend switching, maintaining the figure's visibility as needed.</intended_behavior>]
2025-10-15 07:58:22.135 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:58:22.135 | INFO     | Search-only: skipping patch selection
2025-10-15 07:58:22.236 | INFO     | Task matplotlib__matplotlib-26472 completed successfully.
2025-10-15 07:58:22.237 | INFO     | No patch generated. You can try running ACR again.
