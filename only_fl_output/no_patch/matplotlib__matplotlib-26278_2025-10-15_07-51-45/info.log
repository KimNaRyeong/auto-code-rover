2025-10-15 07:51:45.552 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:51:49.529 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=533, output_tokens=12, cost=0.005690
2025-10-15 07:51:49.530 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 07:51:49.533 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:51:55.600 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=841, output_tokens=265, cost=0.016360
2025-10-15 07:51:55.605 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:51:59.164 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=619, output_tokens=70, cost=0.008290
2025-10-15 07:51:59.165 | DEBUG    | Extracted a valid json.
2025-10-15 07:51:59.166 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ContourSet\")",
        "search_method_in_class(\"contourf\", \"pyplot\")",
        "search_method_in_class(\"__init__\", \"ContourSet\")",
        "search_code(\"clip_path=poly\")"
    ],
    "bug_locations": []
}
2025-10-15 07:51:59.246 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:51:59.247 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:52:20.135 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3733, output_tokens=749, cost=0.059800
2025-10-15 07:52:20.149 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:52:32.177 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4698, output_tokens=442, cost=0.060240
2025-10-15 07:52:32.186 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:52:43.491 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=796, output_tokens=327, cost=0.017770
2025-10-15 07:52:43.492 | DEBUG    | Extracted a valid json.
2025-10-15 07:52:43.493 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"contourf\")"],
    "bug_locations":[
        {
            "file": "lib/matplotlib/contour.py",
            "class": "ContourSet",
            "method": "__init__",
            "intended_behavior": "The `__init__` method should be capable of handling a `clip_path` kwarg. This involves ensuring that when a `clip_path` argument is provided, it is applied to the entire ContourSet or individually to each of its collections. The code should process this argument explicitly, possibly by adding a mechanism within the `__init__` method or within a setup method called by `__init__`, which applies the clip path to the ContourSet. This change respects the intended behavior by making the `clip_path` functionality consistent with other plotting functions and allowing users to directly clip contours via the function call without requiring post-hoc adjustment."
        },
        {
            "file": "",
            "class": "",
            "method": "contourf",
            "intended_behavior": "The `contourf` function should be updated to ensure that any kwargs, including `clip_path`, are properly passed to `ContourSet`. This would likely involve adjusting how kwargs are processed and forwarded in the `contourf` function call, ensuring `clip_path` is recognized and handed to `ContourSet` effectively. The precise adjustment would aim to preserve the existing functionality while adding support for direct clipping, thereby enhancing the API's consistency and usability for clipping plots within specified paths."
        }
    ]
}
2025-10-15 07:52:43.504 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:52:43.505 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:53:00.251 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5342, output_tokens=743, cost=0.075710
2025-10-15 07:53:00.265 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:53:10.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6301, output_tokens=472, cost=0.077170
2025-10-15 07:53:10.810 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:53:21.299 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=826, output_tokens=418, cost=0.020800
2025-10-15 07:53:21.300 | DEBUG    | Extracted a valid json.
2025-10-15 07:53:21.300 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "contourf",
            "intended_behavior": "The `contourf` method within the `Axes` class should be modified to ensure that `clip_path` kwarg is explicitly recognized and effectively passed to the `ContourSet` instantiation. This ensures the `clip_path` affects the plotting as intended. The method must maintain backward compatibility and all existing functionality, with the additional capability of handling the `clip_path` argument to clip the contours according to the specified path. The intended behavior is such that if a `clip_path` kwarg is present, it should be used to apply clipping to the contour plot, directly within the construction or setup of the `ContourSet` object, without the need for further adjustments post-creation."
        },
        {
            "file": "lib/matplotlib/contour.py",
            "class": "ContourSet",
            "method": "(Potentially new or `__init__`)",
            "intended_behavior": "If adjustments in `axes/_axes.py` are insufficient alone and require changes at the `ContourSet` level, the `ContourSet` class may need a modification or a new method to properly accept and utilize the `clip_path` kwarg passed from `axes/_axes.py`. The modification could involve adjusting the `__init__` method or adding a new method that applies the `clip_path` to all constituent collections of the `ContourSet`. This might be accomplished by iterating over the collections in the `ContourSet` and applying the `clip_path` to each. The expected result is that the `ContourSet` object, when created or updated, would respect the `clip_path` by clipping the contours according to the specified path. This should be done while ensuring any other functionality and kwargs handling remains unaffected for backward compatibility."
        }
    ]
}
2025-10-15 07:53:21.331 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>contourf</method>
<code>
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours

</code><intended_behavior>The `contourf` method within the `Axes` class should be modified to ensure that `clip_path` kwarg is explicitly recognized and effectively passed to the `ContourSet` instantiation. This ensures the `clip_path` affects the plotting as intended. The method must maintain backward compatibility and all existing functionality, with the additional capability of handling the `clip_path` argument to clip the contours according to the specified path. The intended behavior is such that if a `clip_path` kwarg is present, it should be used to apply clipping to the contour plot, directly within the construction or setup of the `ContourSet` object, without the need for further adjustments post-creation.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `~matplotlib.text.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, kwargs = mlegend._parse_legend_args([self], *args, **kwargs)
320         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
321         self.legend_._remove_method = self._remove_legend
322         return self.legend_
323 
324     def _remove_legend(self, legend):
325         self.legend_ = None
326 
327     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
328         """
329         Add a child inset Axes to this existing Axes.
330 
331         Warnings
332         --------
333         This method is experimental as of 3.0, and the API may change.
334 
335         Parameters
336         ----------
337         bounds : [x0, y0, width, height]
338             Lower-left corner of inset Axes, and its width and height.
339 
340         transform : `.Transform`
341             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
342             Axes-relative coordinates.
343 
344         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
345 'polar', 'rectilinear', str}, optional
346             The projection type of the inset `~.axes.Axes`. *str* is the name
347             of a custom projection, see `~matplotlib.projections`. The default
348             None results in a 'rectilinear' projection.
349 
350         polar : bool, default: False
351             If True, equivalent to projection='polar'.
352 
353         axes_class : subclass type of `~.axes.Axes`, optional
354             The `.axes.Axes` subclass that is instantiated.  This parameter
355             is incompatible with *projection* and *polar*.  See
356             :ref:`axisartist_users-guide-index` for examples.
357 
358         zorder : number
359             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
360             to change whether it is above or below data plotted on the
361             parent Axes.
362 
363         **kwargs
364             Other keyword arguments are passed on to the inset Axes class.
365 
366         Returns
367         -------
368         ax
369             The created `~.axes.Axes` instance.
370 
371         Examples
372         --------
373         This example makes two inset Axes, the first is in Axes-relative
374         coordinates, and the second in data-coordinates::
375 
376             fig, ax = plt.subplots()
377             ax.plot(range(10))
378             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
379             axin2 = ax.inset_axes(
380                     [5, 7, 2.3, 2.3], transform=ax.transData)
381 
382         """
383         if transform is None:
384             transform = self.transAxes
385         kwargs.setdefault('label', 'inset_axes')
386 
387         # This puts the rectangle into figure-relative coordinates.
388         inset_locator = _TransformedBoundsLocator(bounds, transform)
389         bounds = inset_locator(self, None).bounds
390         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
391         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
392 
393         # this locator lets the axes move if in data coordinates.
394         # it gets called in `ax.apply_aspect() (of all places)
395         inset_ax.set_axes_locator(inset_locator)
396 
397         self.add_child_axes(inset_ax)
398 
399         return inset_ax
400 
401     @_docstring.dedent_interpd
402     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
403                        facecolor='none', edgecolor='0.5', alpha=0.5,
404                        zorder=4.99, **kwargs):
405         """
406         Add an inset indicator to the Axes.  This is a rectangle on the plot
407         at the position indicated by *bounds* that optionally has lines that
408         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
409 
410         Warnings
411         --------
412         This method is experimental as of 3.0, and the API may change.
413 
414         Parameters
415         ----------
416         bounds : [x0, y0, width, height]
417             Lower-left corner of rectangle to be marked, and its width
418             and height.
419 
420         inset_ax : `.Axes`
421             An optional inset Axes to draw connecting lines to.  Two lines are
422             drawn connecting the indicator box to the inset Axes on corners
423             chosen so as to not overlap with the indicator box.
424 
425         transform : `.Transform`
426             Transform for the rectangle coordinates. Defaults to
427             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
428             coordinates.
429 
430         facecolor : color, default: 'none'
431             Facecolor of the rectangle.
432 
433         edgecolor : color, default: '0.5'
434             Color of the rectangle and color of the connecting lines.
435 
436         alpha : float, default: 0.5
437             Transparency of the rectangle and connector lines.
438 
439         zorder : float, default: 4.99
440             Drawing order of the rectangle and connector lines.  The default,
441             4.99, is just below the default level of inset Axes.
442 
443         **kwargs
444             Other keyword arguments are passed on to the `.Rectangle` patch:
445 
446             %(Rectangle:kwdoc)s
447 
448         Returns
449         -------
450         rectangle_patch : `.patches.Rectangle`
451              The indicator frame.
452 
453         connector_lines : 4-tuple of `.patches.ConnectionPatch`
454             The four connector lines connecting to (lower_left, upper_left,
455             lower_right upper_right) corners of *inset_ax*. Two lines are
456             set with visibility to *False*,  but the user can set the
457             visibility to True if the automatic choice is not deemed correct.
458 
459         """
460         # to make the axes connectors work, we need to apply the aspect to
461         # the parent axes.
462         self.apply_aspect()
463 
464         if transform is None:
465             transform = self.transData
466         kwargs.setdefault('label', '_indicate_inset')
467 
468         x, y, width, height = bounds
469         rectangle_patch = mpatches.Rectangle(
470             (x, y), width, height,
471             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
472             zorder=zorder, transform=transform, **kwargs)
473         self.add_patch(rectangle_patch)
474 
475         connects = []
476 
477         if inset_ax is not None:
478             # connect the inset_axes to the rectangle
479             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
480                 # inset_ax positions are in axes coordinates
481                 # The 0, 1 values define the four edges if the inset_ax
482                 # lower_left, upper_left, lower_right upper_right.
483                 ex, ey = xy_inset_ax
484                 if self.xaxis.get_inverted():
485                     ex = 1 - ex
486                 if self.yaxis.get_inverted():
487                     ey = 1 - ey
488                 xy_data = x + ex * width, y + ey * height
489                 p = mpatches.ConnectionPatch(
490                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
491                     xyB=xy_data, coordsB=self.transData,
492                     arrowstyle="-", zorder=zorder,
493                     edgecolor=edgecolor, alpha=alpha)
494                 connects.append(p)
495                 self.add_patch(p)
496 
497             # decide which two of the lines to keep visible....
498             pos = inset_ax.get_position()
499             bboxins = pos.transformed(self.figure.transSubfigure)
500             rectbbox = mtransforms.Bbox.from_bounds(
501                 *bounds
502             ).transformed(transform)
503             x0 = rectbbox.x0 < bboxins.x0
504             x1 = rectbbox.x1 < bboxins.x1
505             y0 = rectbbox.y0 < bboxins.y0
506             y1 = rectbbox.y1 < bboxins.y1
507             connects[0].set_visible(x0 ^ y0)
508             connects[1].set_visible(x0 == y1)
509             connects[2].set_visible(x1 == y0)
510             connects[3].set_visible(x1 ^ y1)
511 
512         return rectangle_patch, tuple(connects) if connects else None
513 
514     def indicate_inset_zoom(self, inset_ax, **kwargs):
515         """
516         Add an inset indicator rectangle to the Axes based on the axis
517         limits for an *inset_ax* and draw connectors between *inset_ax*
518         and the rectangle.
519 
520         Warnings
521         --------
522         This method is experimental as of 3.0, and the API may change.
523 
524         Parameters
525         ----------
526         inset_ax : `.Axes`
527             Inset Axes to draw connecting lines to.  Two lines are
528             drawn connecting the indicator box to the inset Axes on corners
529             chosen so as to not overlap with the indicator box.
530 
531         **kwargs
532             Other keyword arguments are passed on to `.Axes.indicate_inset`
533 
534         Returns
535         -------
536         rectangle_patch : `.patches.Rectangle`
537              Rectangle artist.
538 
539         connector_lines : 4-tuple of `.patches.ConnectionPatch`
540             Each of four connector lines coming from the rectangle drawn on
541             this axis, in the order lower left, upper left, lower right,
542             upper right.
543             Two are set with visibility to *False*,  but the user can
544             set the visibility to *True* if the automatic choice is not deemed
545             correct.
546         """
547 
548         xlim = inset_ax.get_xlim()
549         ylim = inset_ax.get_ylim()
550         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
551         return self.indicate_inset(rect, inset_ax, **kwargs)
552 
553     @_docstring.dedent_interpd
554     def secondary_xaxis(self, location, *, functions=None, **kwargs):
555         """
556         Add a second x-axis to this `~.axes.Axes`.
557 
558         For example if we want to have a second scale for the data plotted on
559         the xaxis.
560 
561         %(_secax_docstring)s
562 
563         Examples
564         --------
565         The main axis shows frequency, and the secondary axis shows period.
566 
567         .. plot::
568 
569             fig, ax = plt.subplots()
570             ax.loglog(range(1, 360, 5), range(1, 360, 5))
571             ax.set_xlabel('frequency [Hz]')
572 
573             def invert(x):
574                 # 1/x with special treatment of x == 0
575                 x = np.array(x).astype(float)
576                 near_zero = np.isclose(x, 0)
577                 x[near_zero] = np.inf
578                 x[~near_zero] = 1 / x[~near_zero]
579                 return x
580 
581             # the inverse of 1/x is itself
582             secax = ax.secondary_xaxis('top', functions=(invert, invert))
583             secax.set_xlabel('Period [s]')
584             plt.show()
585         """
586         if location in ['top', 'bottom'] or isinstance(location, Real):
587             secondary_ax = SecondaryAxis(self, 'x', location, functions,
588                                          **kwargs)
589             self.add_child_axes(secondary_ax)
590             return secondary_ax
591         else:
592             raise ValueError('secondary_xaxis location must be either '
593                              'a float or "top"/"bottom"')
594 
595     @_docstring.dedent_interpd
596     def secondary_yaxis(self, location, *, functions=None, **kwargs):
597         """
598         Add a second y-axis to this `~.axes.Axes`.
599 
600         For example if we want to have a second scale for the data plotted on
601         the yaxis.
602 
603         %(_secax_docstring)s
604 
605         Examples
606         --------
607         Add a secondary Axes that converts from radians to degrees
608 
609         .. plot::
610 
611             fig, ax = plt.subplots()
612             ax.plot(range(1, 360, 5), range(1, 360, 5))
613             ax.set_ylabel('degrees')
614             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
615                                                            np.rad2deg))
616             secax.set_ylabel('radians')
617         """
618         if location in ['left', 'right'] or isinstance(location, Real):
619             secondary_ax = SecondaryAxis(self, 'y', location,
620                                          functions, **kwargs)
621             self.add_child_axes(secondary_ax)
622             return secondary_ax
623         else:
624             raise ValueError('secondary_yaxis location must be either '
625                              'a float or "left"/"right"')
626 
627     @_docstring.dedent_interpd
628     def text(self, x, y, s, fontdict=None, **kwargs):
629         """
630         Add text to the Axes.
631 
632         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
633 
634         Parameters
635         ----------
636         x, y : float
637             The position to place the text. By default, this is in data
638             coordinates. The coordinate system can be changed using the
639             *transform* parameter.
640 
641         s : str
642             The text.
643 
644         fontdict : dict, default: None
645 
646             .. admonition:: Discouraged
647 
648                The use of *fontdict* is discouraged. Parameters should be passed as
649                individual keyword arguments or using dictionary-unpacking
650                ``text(..., **fontdict)``.
651 
652             A dictionary to override the default text properties. If fontdict
653             is None, the defaults are determined by `.rcParams`.
654 
655         Returns
656         -------
657         `.Text`
658             The created `.Text` instance.
659 
660         Other Parameters
661         ----------------
662         **kwargs : `~matplotlib.text.Text` properties.
663             Other miscellaneous text parameters.
664 
665             %(Text:kwdoc)s
666 
667         Examples
668         --------
669         Individual keyword arguments can be used to override any given
670         parameter::
671 
672             >>> text(x, y, s, fontsize=12)
673 
674         The default transform specifies that text is in data coords,
675         alternatively, you can specify text in axis coords ((0, 0) is
676         lower-left and (1, 1) is upper-right).  The example below places
677         text in the center of the Axes::
678 
679             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
680             ...      verticalalignment='center', transform=ax.transAxes)
681 
682         You can put a rectangular box around the text instance (e.g., to
683         set a background color) by using the keyword *bbox*.  *bbox* is
684         a dictionary of `~matplotlib.patches.Rectangle`
685         properties.  For example::
686 
687             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
688         """
689         effective_kwargs = {
690             'verticalalignment': 'baseline',
691             'horizontalalignment': 'left',
692             'transform': self.transData,
693             'clip_on': False,
694             **(fontdict if fontdict is not None else {}),
695             **kwargs,
696         }
697         t = mtext.Text(x, y, text=s, **effective_kwargs)
698         if t.get_clip_path() is None:
699             t.set_clip_path(self.patch)
700         self._add_text(t)
701         return t
702 
703     @_docstring.dedent_interpd
704     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
705                  arrowprops=None, annotation_clip=None, **kwargs):
706         # Signature must match Annotation. This is verified in
707         # test_annotate_signature().
708         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
709                              textcoords=textcoords, arrowprops=arrowprops,
710                              annotation_clip=annotation_clip, **kwargs)
711         a.set_transform(mtransforms.IdentityTransform())
712         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
713             a.set_clip_path(self.patch)
714         self._add_text(a)
715         return a
716     annotate.__doc__ = mtext.Annotation.__init__.__doc__
717     #### Lines and spans
718 
719     @_docstring.dedent_interpd
720     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
721         """
722         Add a horizontal line across the Axes.
723 
724         Parameters
725         ----------
726         y : float, default: 0
727             y position in data coordinates of the horizontal line.
728 
729         xmin : float, default: 0
730             Should be between 0 and 1, 0 being the far left of the plot, 1 the
731             far right of the plot.
732 
733         xmax : float, default: 1
734             Should be between 0 and 1, 0 being the far left of the plot, 1 the
735             far right of the plot.
736 
737         Returns
738         -------
739         `~matplotlib.lines.Line2D`
740 
741         Other Parameters
742         ----------------
743         **kwargs
744             Valid keyword arguments are `.Line2D` properties, except for
745             'transform':
746 
747             %(Line2D:kwdoc)s
748 
749         See Also
750         --------
751         hlines : Add horizontal lines in data coordinates.
752         axhspan : Add a horizontal span (rectangle) across the axis.
753         axline : Add a line with an arbitrary slope.
754 
755         Examples
756         --------
757         * draw a thick red hline at 'y' = 0 that spans the xrange::
758 
759             >>> axhline(linewidth=4, color='r')
760 
761         * draw a default hline at 'y' = 1 that spans the xrange::
762 
763             >>> axhline(y=1)
764 
765         * draw a default hline at 'y' = .5 that spans the middle half of
766           the xrange::
767 
768             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
769         """
770         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
771         if "transform" in kwargs:
772             raise ValueError("'transform' is not allowed as a keyword "
773                              "argument; axhline generates its own transform.")
774         ymin, ymax = self.get_ybound()
775 
776         # Strip away the units for comparison with non-unitized bounds.
777         yy, = self._process_unit_info([("y", y)], kwargs)
778         scaley = (yy < ymin) or (yy > ymax)
779 
780         trans = self.get_yaxis_transform(which='grid')
781         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
782         self.add_line(l)
783         if scaley:
784             self._request_autoscale_view("y")
785         return l
786 
787     @_docstring.dedent_interpd
788     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
789         """
790         Add a vertical line across the Axes.
791 
792         Parameters
793         ----------
794         x : float, default: 0
795             x position in data coordinates of the vertical line.
796 
797         ymin : float, default: 0
798             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
799             top of the plot.
800 
801         ymax : float, default: 1
802             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
803             top of the plot.
804 
805         Returns
806         -------
807         `~matplotlib.lines.Line2D`
808 
809         Other Parameters
810         ----------------
811         **kwargs
812             Valid keyword arguments are `.Line2D` properties, except for
813             'transform':
814 
815             %(Line2D:kwdoc)s
816 
817         See Also
818         --------
819         vlines : Add vertical lines in data coordinates.
820         axvspan : Add a vertical span (rectangle) across the axis.
821         axline : Add a line with an arbitrary slope.
822 
823         Examples
824         --------
825         * draw a thick red vline at *x* = 0 that spans the yrange::
826 
827             >>> axvline(linewidth=4, color='r')
828 
829         * draw a default vline at *x* = 1 that spans the yrange::
830 
831             >>> axvline(x=1)
832 
833         * draw a default vline at *x* = .5 that spans the middle half of
834           the yrange::
835 
836             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
837         """
838         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
839         if "transform" in kwargs:
840             raise ValueError("'transform' is not allowed as a keyword "
841                              "argument; axvline generates its own transform.")
842         xmin, xmax = self.get_xbound()
843 
844         # Strip away the units for comparison with non-unitized bounds.
845         xx, = self._process_unit_info([("x", x)], kwargs)
846         scalex = (xx < xmin) or (xx > xmax)
847 
848         trans = self.get_xaxis_transform(which='grid')
849         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
850         self.add_line(l)
851         if scalex:
852             self._request_autoscale_view("x")
853         return l
854 
855     @staticmethod
856     def _check_no_units(vals, names):
857         # Helper method to check that vals are not unitized
858         for val, name in zip(vals, names):
859             if not munits._is_natively_supported(val):
860                 raise ValueError(f"{name} must be a single scalar value, "
861                                  f"but got {val}")
862 
863     @_docstring.dedent_interpd
864     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
865         """
866         Add an infinitely long straight line.
867 
868         The line can be defined either by two points *xy1* and *xy2*, or
869         by one point *xy1* and a *slope*.
870 
871         This draws a straight line "on the screen", regardless of the x and y
872         scales, and is thus also suitable for drawing exponential decays in
873         semilog plots, power laws in loglog plots, etc. However, *slope*
874         should only be used with linear scales; It has no clear meaning for
875         all other scales, and thus the behavior is undefined. Please specify
876         the line using the points *xy1*, *xy2* for non-linear scales.
877 
878         The *transform* keyword argument only applies to the points *xy1*,
879         *xy2*. The *slope* (if given) is always in data coordinates. This can
880         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
881         slope.
882 
883         Parameters
884         ----------
885         xy1, xy2 : (float, float)
886             Points for the line to pass through.
887             Either *xy2* or *slope* has to be given.
888         slope : float, optional
889             The slope of the line. Either *xy2* or *slope* has to be given.
890 
891         Returns
892         -------
893         `.Line2D`
894 
895         Other Parameters
896         ----------------
897         **kwargs
898             Valid kwargs are `.Line2D` properties
899 
900             %(Line2D:kwdoc)s
901 
902         See Also
903         --------
904         axhline : for horizontal lines
905         axvline : for vertical lines
906 
907         Examples
908         --------
909         Draw a thick red line passing through (0, 0) and (1, 1)::
910 
911             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
912         """
913         if slope is not None and (self.get_xscale() != 'linear' or
914                                   self.get_yscale() != 'linear'):
915             raise TypeError("'slope' cannot be used with non-linear scales")
916 
917         datalim = [xy1] if xy2 is None else [xy1, xy2]
918         if "transform" in kwargs:
919             # if a transform is passed (i.e. line points not in data space),
920             # data limits should not be adjusted.
921             datalim = []
922 
923         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
924         # Like add_line, but correctly handling data limits.
925         self._set_artist_props(line)
926         if line.get_clip_path() is None:
927             line.set_clip_path(self.patch)
928         if not line.get_label():
929             line.set_label(f"_child{len(self._children)}")
930         self._children.append(line)
931         line._remove_method = self._children.remove
932         self.update_datalim(datalim)
933 
934         self._request_autoscale_view()
935         return line
936 
937     @_docstring.dedent_interpd
938     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
939         """
940         Add a horizontal span (rectangle) across the Axes.
941 
942         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
943         the whole x-axis horizontally.  The x-span can be set using *xmin*
944         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
945         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
946         the limits set by `~.Axes.set_xlim`.
947 
948         Parameters
949         ----------
950         ymin : float
951             Lower y-coordinate of the span, in data units.
952         ymax : float
953             Upper y-coordinate of the span, in data units.
954         xmin : float, default: 0
955             Lower x-coordinate of the span, in x-axis (0-1) units.
956         xmax : float, default: 1
957             Upper x-coordinate of the span, in x-axis (0-1) units.
958 
959         Returns
960         -------
961         `~matplotlib.patches.Polygon`
962             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
963 
964         Other Parameters
965         ----------------
966         **kwargs : `~matplotlib.patches.Polygon` properties
967 
968         %(Polygon:kwdoc)s
969 
970         See Also
971         --------
972         axvspan : Add a vertical span across the Axes.
973         """
974         # Strip units away.
975         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
976         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
977 
978         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
979         p = mpatches.Polygon(verts, **kwargs)
980         p.set_transform(self.get_yaxis_transform(which="grid"))
981         self.add_patch(p)
982         self._request_autoscale_view("y")
983         return p
984 
985     @_docstring.dedent_interpd
986     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
987         """
988         Add a vertical span (rectangle) across the Axes.
989 
990         The rectangle spans from *xmin* to *xmax* horizontally, and, by
991         default, the whole y-axis vertically.  The y-span can be set using
992         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
993         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
994         regardless of the limits set by `~.Axes.set_ylim`.
995 
996         Parameters
997         ----------
998         xmin : float
999             Lower x-coordinate of the span, in data units.
1000         xmax : float
1001             Upper x-coordinate of the span, in data units.
1002         ymin : float, default: 0
1003             Lower y-coordinate of the span, in y-axis units (0-1).
1004         ymax : float, default: 1
1005             Upper y-coordinate of the span, in y-axis units (0-1).
1006 
1007         Returns
1008         -------
1009         `~matplotlib.patches.Polygon`
1010             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1011 
1012         Other Parameters
1013         ----------------
1014         **kwargs : `~matplotlib.patches.Polygon` properties
1015 
1016         %(Polygon:kwdoc)s
1017 
1018         See Also
1019         --------
1020         axhspan : Add a horizontal span across the Axes.
1021 
1022         Examples
1023         --------
1024         Draw a vertical, green, translucent rectangle from x = 1.25 to
1025         x = 1.55 that spans the yrange of the Axes.
1026 
1027         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1028 
1029         """
1030         # Strip units away.
1031         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1032         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1033 
1034         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1035         p = mpatches.Polygon(verts, **kwargs)
1036         p.set_transform(self.get_xaxis_transform(which="grid"))
1037         p.get_path()._interpolation_steps = 100
1038         self.add_patch(p)
1039         self._request_autoscale_view("x")
1040         return p
1041 
1042     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1043                       label_namer="y")
1044     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1045                label='', **kwargs):
1046         """
1047         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1048 
1049         Parameters
1050         ----------
1051         y : float or array-like
1052             y-indexes where to plot the lines.
1053 
1054         xmin, xmax : float or array-like
1055             Respective beginning and end of each line. If scalars are
1056             provided, all lines will have the same length.
1057 
1058         colors : color or list of colors, default: :rc:`lines.color`
1059 
1060         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1061 
1062         label : str, default: ''
1063 
1064         Returns
1065         -------
1066         `~matplotlib.collections.LineCollection`
1067 
1068         Other Parameters
1069         ----------------
1070         data : indexable object, optional
1071             DATA_PARAMETER_PLACEHOLDER
1072         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1073 
1074         See Also
1075         --------
1076         vlines : vertical lines
1077         axhline : horizontal line across the Axes
1078         """
1079 
1080         # We do the conversion first since not all unitized data is uniform
1081         xmin, xmax, y = self._process_unit_info(
1082             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1083 
1084         if not np.iterable(y):
1085             y = [y]
1086         if not np.iterable(xmin):
1087             xmin = [xmin]
1088         if not np.iterable(xmax):
1089             xmax = [xmax]
1090 
1091         # Create and combine masked_arrays from input
1092         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1093         y = np.ravel(y)
1094         xmin = np.ravel(xmin)
1095         xmax = np.ravel(xmax)
1096 
1097         masked_verts = np.ma.empty((len(y), 2, 2))
1098         masked_verts[:, 0, 0] = xmin
1099         masked_verts[:, 0, 1] = y
1100         masked_verts[:, 1, 0] = xmax
1101         masked_verts[:, 1, 1] = y
1102 
1103         lines = mcoll.LineCollection(masked_verts, colors=colors,
1104                                      linestyles=linestyles, label=label)
1105         self.add_collection(lines, autolim=False)
1106         lines._internal_update(kwargs)
1107 
1108         if len(y) > 0:
1109             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1110             # the case of y being a masked *object* array (as can be generated
1111             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1112             updatex = True
1113             updatey = True
1114             if self.name == "rectilinear":
1115                 datalim = lines.get_datalim(self.transData)
1116                 t = lines.get_transform()
1117                 updatex, updatey = t.contains_branch_seperately(self.transData)
1118                 minx = np.nanmin(datalim.xmin)
1119                 maxx = np.nanmax(datalim.xmax)
1120                 miny = np.nanmin(datalim.ymin)
1121                 maxy = np.nanmax(datalim.ymax)
1122             else:
1123                 minx = np.nanmin(masked_verts[..., 0])
1124                 maxx = np.nanmax(masked_verts[..., 0])
1125                 miny = np.nanmin(masked_verts[..., 1])
1126                 maxy = np.nanmax(masked_verts[..., 1])
1127 
1128             corners = (minx, miny), (maxx, maxy)
1129             self.update_datalim(corners, updatex, updatey)
1130             self._request_autoscale_view()
1131         return lines
1132 
1133     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1134                       label_namer="x")
1135     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1136                label='', **kwargs):
1137         """
1138         Plot vertical lines at each *x* from *ymin* to *ymax*.
1139 
1140         Parameters
1141         ----------
1142         x : float or array-like
1143             x-indexes where to plot the lines.
1144 
1145         ymin, ymax : float or array-like
1146             Respective beginning and end of each line. If scalars are
1147             provided, all lines will have the same length.
1148 
1149         colors : color or list of colors, default: :rc:`lines.color`
1150 
1151         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1152 
1153         label : str, default: ''
1154 
1155         Returns
1156         -------
1157         `~matplotlib.collections.LineCollection`
1158 
1159         Other Parameters
1160         ----------------
1161         data : indexable object, optional
1162             DATA_PARAMETER_PLACEHOLDER
1163         **kwargs : `~matplotlib.collections.LineCollection` properties.
1164 
1165         See Also
1166         --------
1167         hlines : horizontal lines
1168         axvline : vertical line across the Axes
1169         """
1170 
1171         # We do the conversion first since not all unitized data is uniform
1172         x, ymin, ymax = self._process_unit_info(
1173             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1174 
1175         if not np.iterable(x):
1176             x = [x]
1177         if not np.iterable(ymin):
1178             ymin = [ymin]
1179         if not np.iterable(ymax):
1180             ymax = [ymax]
1181 
1182         # Create and combine masked_arrays from input
1183         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1184         x = np.ravel(x)
1185         ymin = np.ravel(ymin)
1186         ymax = np.ravel(ymax)
1187 
1188         masked_verts = np.ma.empty((len(x), 2, 2))
1189         masked_verts[:, 0, 0] = x
1190         masked_verts[:, 0, 1] = ymin
1191         masked_verts[:, 1, 0] = x
1192         masked_verts[:, 1, 1] = ymax
1193 
1194         lines = mcoll.LineCollection(masked_verts, colors=colors,
1195                                      linestyles=linestyles, label=label)
1196         self.add_collection(lines, autolim=False)
1197         lines._internal_update(kwargs)
1198 
1199         if len(x) > 0:
1200             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1201             # the case of x being a masked *object* array (as can be generated
1202             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1203             updatex = True
1204             updatey = True
1205             if self.name == "rectilinear":
1206                 datalim = lines.get_datalim(self.transData)
1207                 t = lines.get_transform()
1208                 updatex, updatey = t.contains_branch_seperately(self.transData)
1209                 minx = np.nanmin(datalim.xmin)
1210                 maxx = np.nanmax(datalim.xmax)
1211                 miny = np.nanmin(datalim.ymin)
1212                 maxy = np.nanmax(datalim.ymax)
1213             else:
1214                 minx = np.nanmin(masked_verts[..., 0])
1215                 maxx = np.nanmax(masked_verts[..., 0])
1216                 miny = np.nanmin(masked_verts[..., 1])
1217                 maxy = np.nanmax(masked_verts[..., 1])
1218 
1219             corners = (minx, miny), (maxx, maxy)
1220             self.update_datalim(corners, updatex, updatey)
1221             self._request_autoscale_view()
1222         return lines
1223 
1224     @_preprocess_data(replace_names=["positions", "lineoffsets",
1225                                      "linelengths", "linewidths",
1226                                      "colors", "linestyles"])
1227     @_docstring.dedent_interpd
1228     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1229                   linelengths=1, linewidths=None, colors=None, alpha=None,
1230                   linestyles='solid', **kwargs):
1231         """
1232         Plot identical parallel lines at the given positions.
1233 
1234         This type of plot is commonly used in neuroscience for representing
1235         neural events, where it is usually called a spike raster, dot raster,
1236         or raster plot.
1237 
1238         However, it is useful in any situation where you wish to show the
1239         timing or position of multiple sets of discrete events, such as the
1240         arrival times of people to a business on each day of the month or the
1241         date of hurricanes each year of the last century.
1242 
1243         Parameters
1244         ----------
1245         positions : array-like or list of array-like
1246             A 1D array-like defines the positions of one sequence of events.
1247 
1248             Multiple groups of events may be passed as a list of array-likes.
1249             Each group can be styled independently by passing lists of values
1250             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1251             *linestyles*.
1252 
1253             Note that *positions* can be a 2D array, but in practice different
1254             event groups usually have different counts so that one will use a
1255             list of different-length arrays rather than a 2D array.
1256 
1257         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1258             The direction of the event sequence:
1259 
1260             - 'horizontal': the events are arranged horizontally.
1261               The indicator lines are vertical.
1262             - 'vertical': the events are arranged vertically.
1263               The indicator lines are horizontal.
1264 
1265         lineoffsets : float or array-like, default: 1
1266             The offset of the center of the lines from the origin, in the
1267             direction orthogonal to *orientation*.
1268 
1269             If *positions* is 2D, this can be a sequence with length matching
1270             the length of *positions*.
1271 
1272         linelengths : float or array-like, default: 1
1273             The total height of the lines (i.e. the lines stretches from
1274             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1275 
1276             If *positions* is 2D, this can be a sequence with length matching
1277             the length of *positions*.
1278 
1279         linewidths : float or array-like, default: :rc:`lines.linewidth`
1280             The line width(s) of the event lines, in points.
1281 
1282             If *positions* is 2D, this can be a sequence with length matching
1283             the length of *positions*.
1284 
1285         colors : color or list of colors, default: :rc:`lines.color`
1286             The color(s) of the event lines.
1287 
1288             If *positions* is 2D, this can be a sequence with length matching
1289             the length of *positions*.
1290 
1291         alpha : float or array-like, default: 1
1292             The alpha blending value(s), between 0 (transparent) and 1
1293             (opaque).
1294 
1295             If *positions* is 2D, this can be a sequence with length matching
1296             the length of *positions*.
1297 
1298         linestyles : str or tuple or list of such values, default: 'solid'
1299             Default is 'solid'. Valid strings are ['solid', 'dashed',
1300             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1301             should be of the form::
1302 
1303                 (offset, onoffseq),
1304 
1305             where *onoffseq* is an even length tuple of on and off ink
1306             in points.
1307 
1308             If *positions* is 2D, this can be a sequence with length matching
1309             the length of *positions*.
1310 
1311         data : indexable object, optional
1312             DATA_PARAMETER_PLACEHOLDER
1313 
1314         **kwargs
1315             Other keyword arguments are line collection properties.  See
1316             `.LineCollection` for a list of the valid properties.
1317 
1318         Returns
1319         -------
1320         list of `.EventCollection`
1321             The `.EventCollection` that were added.
1322 
1323         Notes
1324         -----
1325         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1326         only a single value is given, that value is applied to all lines. If an
1327         array-like is given, it must have the same length as *positions*, and
1328         each value will be applied to the corresponding row of the array.
1329 
1330         Examples
1331         --------
1332         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1333         """
1334 
1335         lineoffsets, linelengths = self._process_unit_info(
1336                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1337 
1338         # fix positions, noting that it can be a list of lists:
1339         if not np.iterable(positions):
1340             positions = [positions]
1341         elif any(np.iterable(position) for position in positions):
1342             positions = [np.asanyarray(position) for position in positions]
1343         else:
1344             positions = [np.asanyarray(positions)]
1345 
1346         poss = []
1347         for position in positions:
1348             poss += self._process_unit_info([("x", position)], kwargs)
1349         positions = poss
1350 
1351         # prevent 'singular' keys from **kwargs dict from overriding the effect
1352         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1353         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1354         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1355         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1356 
1357         if not np.iterable(lineoffsets):
1358             lineoffsets = [lineoffsets]
1359         if not np.iterable(linelengths):
1360             linelengths = [linelengths]
1361         if not np.iterable(linewidths):
1362             linewidths = [linewidths]
1363         if not np.iterable(colors):
1364             colors = [colors]
1365         if not np.iterable(alpha):
1366             alpha = [alpha]
1367         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1368             linestyles = [linestyles]
1369 
1370         lineoffsets = np.asarray(lineoffsets)
1371         linelengths = np.asarray(linelengths)
1372         linewidths = np.asarray(linewidths)
1373 
1374         if len(lineoffsets) == 0:
1375             raise ValueError('lineoffsets cannot be empty')
1376         if len(linelengths) == 0:
1377             raise ValueError('linelengths cannot be empty')
1378         if len(linestyles) == 0:
1379             raise ValueError('linestyles cannot be empty')
1380         if len(linewidths) == 0:
1381             raise ValueError('linewidths cannot be empty')
1382         if len(alpha) == 0:
1383             raise ValueError('alpha cannot be empty')
1384         if len(colors) == 0:
1385             colors = [None]
1386         try:
1387             # Early conversion of the colors into RGBA values to take care
1388             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1389             colors = mcolors.to_rgba_array(colors)
1390         except ValueError:
1391             # Will fail if any element of *colors* is None. But as long
1392             # as len(colors) == 1 or len(positions), the rest of the
1393             # code should process *colors* properly.
1394             pass
1395 
1396         if len(lineoffsets) == 1 and len(positions) != 1:
1397             lineoffsets = np.tile(lineoffsets, len(positions))
1398             lineoffsets[0] = 0
1399             lineoffsets = np.cumsum(lineoffsets)
1400         if len(linelengths) == 1:
1401             linelengths = np.tile(linelengths, len(positions))
1402         if len(linewidths) == 1:
1403             linewidths = np.tile(linewidths, len(positions))
1404         if len(colors) == 1:
1405             colors = list(colors) * len(positions)
1406         if len(alpha) == 1:
1407             alpha = list(alpha) * len(positions)
1408         if len(linestyles) == 1:
1409             linestyles = [linestyles] * len(positions)
1410 
1411         if len(lineoffsets) != len(positions):
1412             raise ValueError('lineoffsets and positions are unequal sized '
1413                              'sequences')
1414         if len(linelengths) != len(positions):
1415             raise ValueError('linelengths and positions are unequal sized '
1416                              'sequences')
1417         if len(linewidths) != len(positions):
1418             raise ValueError('linewidths and positions are unequal sized '
1419                              'sequences')
1420         if len(colors) != len(positions):
1421             raise ValueError('colors and positions are unequal sized '
1422                              'sequences')
1423         if len(alpha) != len(positions):
1424             raise ValueError('alpha and positions are unequal sized '
1425                              'sequences')
1426         if len(linestyles) != len(positions):
1427             raise ValueError('linestyles and positions are unequal sized '
1428                              'sequences')
1429 
1430         colls = []
1431         for position, lineoffset, linelength, linewidth, color, alpha_, \
1432             linestyle in \
1433                 zip(positions, lineoffsets, linelengths, linewidths,
1434                     colors, alpha, linestyles):
1435             coll = mcoll.EventCollection(position,
1436                                          orientation=orientation,
1437                                          lineoffset=lineoffset,
1438                                          linelength=linelength,
1439                                          linewidth=linewidth,
1440                                          color=color,
1441                                          alpha=alpha_,
1442                                          linestyle=linestyle)
1443             self.add_collection(coll, autolim=False)
1444             coll._internal_update(kwargs)
1445             colls.append(coll)
1446 
1447         if len(positions) > 0:
1448             # try to get min/max
1449             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1450                        if len(_p) > 0]
1451             # if we have any non-empty positions, try to autoscale
1452             if len(min_max) > 0:
1453                 mins, maxes = zip(*min_max)
1454                 minpos = np.min(mins)
1455                 maxpos = np.max(maxes)
1456 
1457                 minline = (lineoffsets - linelengths).min()
1458                 maxline = (lineoffsets + linelengths).max()
1459 
1460                 if orientation == "vertical":
1461                     corners = (minline, minpos), (maxline, maxpos)
1462                 else:  # "horizontal"
1463                     corners = (minpos, minline), (maxpos, maxline)
1464                 self.update_datalim(corners)
1465                 self._request_autoscale_view()
1466 
1467         return colls
1468 
1469     #### Basic plotting
1470 
1471     # Uses a custom implementation of data-kwarg handling in
1472     # _process_plot_var_args.
1473     @_docstring.dedent_interpd
1474     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1475         """
1476         Plot y versus x as lines and/or markers.
1477 
1478         Call signatures::
1479 
1480             plot([x], y, [fmt], *, data=None, **kwargs)
1481             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1482 
1483         The coordinates of the points or line nodes are given by *x*, *y*.
1484 
1485         The optional parameter *fmt* is a convenient way for defining basic
1486         formatting like color, marker and linestyle. It's a shortcut string
1487         notation described in the *Notes* section below.
1488 
1489         >>> plot(x, y)        # plot x and y using default line style and color
1490         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1491         >>> plot(y)           # plot y using x as index array 0..N-1
1492         >>> plot(y, 'r+')     # ditto, but with red plusses
1493 
1494         You can use `.Line2D` properties as keyword arguments for more
1495         control on the appearance. Line properties and *fmt* can be mixed.
1496         The following two calls yield identical results:
1497 
1498         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1499         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1500         ...      linewidth=2, markersize=12)
1501 
1502         When conflicting with *fmt*, keyword arguments take precedence.
1503 
1504 
1505         **Plotting labelled data**
1506 
1507         There's a convenient way for plotting objects with labelled data (i.e.
1508         data that can be accessed by index ``obj['y']``). Instead of giving
1509         the data in *x* and *y*, you can provide the object in the *data*
1510         parameter and just give the labels for *x* and *y*::
1511 
1512         >>> plot('xlabel', 'ylabel', data=obj)
1513 
1514         All indexable objects are supported. This could e.g. be a `dict`, a
1515         `pandas.DataFrame` or a structured numpy array.
1516 
1517 
1518         **Plotting multiple sets of data**
1519 
1520         There are various ways to plot multiple sets of data.
1521 
1522         - The most straight forward way is just to call `plot` multiple times.
1523           Example:
1524 
1525           >>> plot(x1, y1, 'bo')
1526           >>> plot(x2, y2, 'go')
1527 
1528         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1529           for every column. If both *x* and *y* are 2D, they must have the
1530           same shape. If only one of them is 2D with shape (N, m) the other
1531           must have length N and will be used for every data set m.
1532 
1533           Example:
1534 
1535           >>> x = [1, 2, 3]
1536           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1537           >>> plot(x, y)
1538 
1539           is equivalent to:
1540 
1541           >>> for col in range(y.shape[1]):
1542           ...     plot(x, y[:, col])
1543 
1544         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1545           groups::
1546 
1547           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1548 
1549           In this case, any additional keyword argument applies to all
1550           datasets. Also, this syntax cannot be combined with the *data*
1551           parameter.
1552 
1553         By default, each line is assigned a different style specified by a
1554         'style cycle'. The *fmt* and line property parameters are only
1555         necessary if you want explicit deviations from these defaults.
1556         Alternatively, you can also change the style cycle using
1557         :rc:`axes.prop_cycle`.
1558 
1559 
1560         Parameters
1561         ----------
1562         x, y : array-like or scalar
1563             The horizontal / vertical coordinates of the data points.
1564             *x* values are optional and default to ``range(len(y))``.
1565 
1566             Commonly, these parameters are 1D arrays.
1567 
1568             They can also be scalars, or two-dimensional (in that case, the
1569             columns represent separate data sets).
1570 
1571             These arguments cannot be passed as keywords.
1572 
1573         fmt : str, optional
1574             A format string, e.g. 'ro' for red circles. See the *Notes*
1575             section for a full description of the format strings.
1576 
1577             Format strings are just an abbreviation for quickly setting
1578             basic line properties. All of these and more can also be
1579             controlled by keyword arguments.
1580 
1581             This argument cannot be passed as keyword.
1582 
1583         data : indexable object, optional
1584             An object with labelled data. If given, provide the label names to
1585             plot in *x* and *y*.
1586 
1587             .. note::
1588                 Technically there's a slight ambiguity in calls where the
1589                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1590                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1591                 the former interpretation is chosen, but a warning is issued.
1592                 You may suppress the warning by adding an empty format string
1593                 ``plot('n', 'o', '', data=obj)``.
1594 
1595         Returns
1596         -------
1597         list of `.Line2D`
1598             A list of lines representing the plotted data.
1599 
1600         Other Parameters
1601         ----------------
1602         scalex, scaley : bool, default: True
1603             These parameters determine if the view limits are adapted to the
1604             data limits. The values are passed on to
1605             `~.axes.Axes.autoscale_view`.
1606 
1607         **kwargs : `~matplotlib.lines.Line2D` properties, optional
1608             *kwargs* are used to specify properties like a line label (for
1609             auto legends), linewidth, antialiasing, marker face color.
1610             Example::
1611 
1612             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1613             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1614 
1615             If you specify multiple lines with one plot call, the kwargs apply
1616             to all those lines. In case the label object is iterable, each
1617             element is used as labels for each set of data.
1618 
1619             Here is a list of available `.Line2D` properties:
1620 
1621             %(Line2D:kwdoc)s
1622 
1623         See Also
1624         --------
1625         scatter : XY scatter plot with markers of varying size and/or color (
1626             sometimes also called bubble chart).
1627 
1628         Notes
1629         -----
1630         **Format Strings**
1631 
1632         A format string consists of a part for color, marker and line::
1633 
1634             fmt = '[marker][line][color]'
1635 
1636         Each of them is optional. If not provided, the value from the style
1637         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1638         the data will be a line without markers.
1639 
1640         Other combinations such as ``[color][marker][line]`` are also
1641         supported, but note that their parsing may be ambiguous.
1642 
1643         **Markers**
1644 
1645         =============   ===============================
1646         character       description
1647         =============   ===============================
1648         ``'.'``         point marker
1649         ``','``         pixel marker
1650         ``'o'``         circle marker
1651         ``'v'``         triangle_down marker
1652         ``'^'``         triangle_up marker
1653         ``'<'``         triangle_left marker
1654         ``'>'``         triangle_right marker
1655         ``'1'``         tri_down marker
1656         ``'2'``         tri_up marker
1657         ``'3'``         tri_left marker
1658         ``'4'``         tri_right marker
1659         ``'8'``         octagon marker
1660         ``'s'``         square marker
1661         ``'p'``         pentagon marker
1662         ``'P'``         plus (filled) marker
1663         ``'*'``         star marker
1664         ``'h'``         hexagon1 marker
1665         ``'H'``         hexagon2 marker
1666         ``'+'``         plus marker
1667         ``'x'``         x marker
1668         ``'X'``         x (filled) marker
1669         ``'D'``         diamond marker
1670         ``'d'``         thin_diamond marker
1671         ``'|'``         vline marker
1672         ``'_'``         hline marker
1673         =============   ===============================
1674 
1675         **Line Styles**
1676 
1677         =============    ===============================
1678         character        description
1679         =============    ===============================
1680         ``'-'``          solid line style
1681         ``'--'``         dashed line style
1682         ``'-.'``         dash-dot line style
1683         ``':'``          dotted line style
1684         =============    ===============================
1685 
1686         Example format strings::
1687 
1688             'b'    # blue markers with default shape
1689             'or'   # red circles
1690             '-g'   # green solid line
1691             '--'   # dashed line with default color
1692             '^k:'  # black triangle_up markers connected by a dotted line
1693 
1694         **Colors**
1695 
1696         The supported color abbreviations are the single letter codes
1697 
1698         =============    ===============================
1699         character        color
1700         =============    ===============================
1701         ``'b'``          blue
1702         ``'g'``          green
1703         ``'r'``          red
1704         ``'c'``          cyan
1705         ``'m'``          magenta
1706         ``'y'``          yellow
1707         ``'k'``          black
1708         ``'w'``          white
1709         =============    ===============================
1710 
1711         and the ``'CN'`` colors that index into the default property cycle.
1712 
1713         If the color is the only part of the format string, you can
1714         additionally use any  `matplotlib.colors` spec, e.g. full names
1715         (``'green'``) or hex strings (``'#008000'``).
1716         """
1717         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1718         lines = [*self._get_lines(*args, data=data, **kwargs)]
1719         for line in lines:
1720             self.add_line(line)
1721         if scalex:
1722             self._request_autoscale_view("x")
1723         if scaley:
1724             self._request_autoscale_view("y")
1725         return lines
1726 
1727     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1728     @_docstring.dedent_interpd
1729     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1730                   **kwargs):
1731         """
1732         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1733 
1734         .. admonition:: Discouraged
1735 
1736             This method exists for historic reasons and will be deprecated in
1737             the future.
1738 
1739             - ``datetime``-like data should directly be plotted using
1740               `~.Axes.plot`.
1741             -  If you need to plot plain numeric data as :ref:`date-format` or
1742                need to set a timezone, call ``ax.xaxis.axis_date`` /
1743                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1744                `.Axis.axis_date`.
1745 
1746         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1747         However, the axis labels are formatted as dates depending on *xdate*
1748         and *ydate*.  Note that `.plot` will work with `datetime` and
1749         `numpy.datetime64` objects without resorting to this method.
1750 
1751         Parameters
1752         ----------
1753         x, y : array-like
1754             The coordinates of the data points. If *xdate* or *ydate* is
1755             *True*, the respective values *x* or *y* are interpreted as
1756             :ref:`Matplotlib dates <date-format>`.
1757 
1758         fmt : str, optional
1759             The plot format string. For details, see the corresponding
1760             parameter in `.plot`.
1761 
1762         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1763             The time zone to use in labeling dates.
1764 
1765         xdate : bool, default: True
1766             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1767 
1768         ydate : bool, default: False
1769             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1770 
1771         Returns
1772         -------
1773         list of `.Line2D`
1774             Objects representing the plotted data.
1775 
1776         Other Parameters
1777         ----------------
1778         data : indexable object, optional
1779             DATA_PARAMETER_PLACEHOLDER
1780         **kwargs
1781             Keyword arguments control the `.Line2D` properties:
1782 
1783             %(Line2D:kwdoc)s
1784 
1785         See Also
1786         --------
1787         matplotlib.dates : Helper functions on dates.
1788         matplotlib.dates.date2num : Convert dates to num.
1789         matplotlib.dates.num2date : Convert num to dates.
1790         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1791 
1792         Notes
1793         -----
1794         If you are using custom date tickers and formatters, it may be
1795         necessary to set the formatters/locators after the call to
1796         `.plot_date`. `.plot_date` will set the default tick locator to
1797         `.AutoDateLocator` (if the tick locator is not already set to a
1798         `.DateLocator` instance) and the default tick formatter to
1799         `.AutoDateFormatter` (if the tick formatter is not already set to a
1800         `.DateFormatter` instance).
1801         """
1802         if xdate:
1803             self.xaxis_date(tz)
1804         if ydate:
1805             self.yaxis_date(tz)
1806         return self.plot(x, y, fmt, **kwargs)
1807 
1808     # @_preprocess_data() # let 'plot' do the unpacking..
1809     @_docstring.dedent_interpd
1810     def loglog(self, *args, **kwargs):
1811         """
1812         Make a plot with log scaling on both the x- and y-axis.
1813 
1814         Call signatures::
1815 
1816             loglog([x], y, [fmt], data=None, **kwargs)
1817             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1818 
1819         This is just a thin wrapper around `.plot` which additionally changes
1820         both the x-axis and the y-axis to log scaling. All the concepts and
1821         parameters of plot can be used here as well.
1822 
1823         The additional parameters *base*, *subs* and *nonpositive* control the
1824         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1825         `.Axes.set_yscale`. To use different properties on the x-axis and the
1826         y-axis, use e.g.
1827         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1828 
1829         Parameters
1830         ----------
1831         base : float, default: 10
1832             Base of the logarithm.
1833 
1834         subs : sequence, optional
1835             The location of the minor ticks. If *None*, reasonable locations
1836             are automatically chosen depending on the number of decades in the
1837             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1838 
1839         nonpositive : {'mask', 'clip'}, default: 'clip'
1840             Non-positive values can be masked as invalid, or clipped to a very
1841             small positive number.
1842 
1843         **kwargs
1844             All parameters supported by `.plot`.
1845 
1846         Returns
1847         -------
1848         list of `.Line2D`
1849             Objects representing the plotted data.
1850         """
1851         dx = {k: v for k, v in kwargs.items()
1852               if k in ['base', 'subs', 'nonpositive',
1853                        'basex', 'subsx', 'nonposx']}
1854         self.set_xscale('log', **dx)
1855         dy = {k: v for k, v in kwargs.items()
1856               if k in ['base', 'subs', 'nonpositive',
1857                        'basey', 'subsy', 'nonposy']}
1858         self.set_yscale('log', **dy)
1859         return self.plot(
1860             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1861 
1862     # @_preprocess_data() # let 'plot' do the unpacking..
1863     @_docstring.dedent_interpd
1864     def semilogx(self, *args, **kwargs):
1865         """
1866         Make a plot with log scaling on the x-axis.
1867 
1868         Call signatures::
1869 
1870             semilogx([x], y, [fmt], data=None, **kwargs)
1871             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1872 
1873         This is just a thin wrapper around `.plot` which additionally changes
1874         the x-axis to log scaling. All the concepts and parameters of plot can
1875         be used here as well.
1876 
1877         The additional parameters *base*, *subs*, and *nonpositive* control the
1878         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1879 
1880         Parameters
1881         ----------
1882         base : float, default: 10
1883             Base of the x logarithm.
1884 
1885         subs : array-like, optional
1886             The location of the minor xticks. If *None*, reasonable locations
1887             are automatically chosen depending on the number of decades in the
1888             plot. See `.Axes.set_xscale` for details.
1889 
1890         nonpositive : {'mask', 'clip'}, default: 'clip'
1891             Non-positive values in x can be masked as invalid, or clipped to a
1892             very small positive number.
1893 
1894         **kwargs
1895             All parameters supported by `.plot`.
1896 
1897         Returns
1898         -------
1899         list of `.Line2D`
1900             Objects representing the plotted data.
1901         """
1902         d = {k: v for k, v in kwargs.items()
1903              if k in ['base', 'subs', 'nonpositive',
1904                       'basex', 'subsx', 'nonposx']}
1905         self.set_xscale('log', **d)
1906         return self.plot(
1907             *args, **{k: v for k, v in kwargs.items() if k not in d})
1908 
1909     # @_preprocess_data() # let 'plot' do the unpacking..
1910     @_docstring.dedent_interpd
1911     def semilogy(self, *args, **kwargs):
1912         """
1913         Make a plot with log scaling on the y-axis.
1914 
1915         Call signatures::
1916 
1917             semilogy([x], y, [fmt], data=None, **kwargs)
1918             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1919 
1920         This is just a thin wrapper around `.plot` which additionally changes
1921         the y-axis to log scaling. All the concepts and parameters of plot can
1922         be used here as well.
1923 
1924         The additional parameters *base*, *subs*, and *nonpositive* control the
1925         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1926 
1927         Parameters
1928         ----------
1929         base : float, default: 10
1930             Base of the y logarithm.
1931 
1932         subs : array-like, optional
1933             The location of the minor yticks. If *None*, reasonable locations
1934             are automatically chosen depending on the number of decades in the
1935             plot. See `.Axes.set_yscale` for details.
1936 
1937         nonpositive : {'mask', 'clip'}, default: 'clip'
1938             Non-positive values in y can be masked as invalid, or clipped to a
1939             very small positive number.
1940 
1941         **kwargs
1942             All parameters supported by `.plot`.
1943 
1944         Returns
1945         -------
1946         list of `.Line2D`
1947             Objects representing the plotted data.
1948         """
1949         d = {k: v for k, v in kwargs.items()
1950              if k in ['base', 'subs', 'nonpositive',
1951                       'basey', 'subsy', 'nonposy']}
1952         self.set_yscale('log', **d)
1953         return self.plot(
1954             *args, **{k: v for k, v in kwargs.items() if k not in d})
1955 
1956     @_preprocess_data(replace_names=["x"], label_namer="x")
1957     def acorr(self, x, **kwargs):
1958         """
1959         Plot the autocorrelation of *x*.
1960 
1961         Parameters
1962         ----------
1963         x : array-like
1964 
1965         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1966             A detrending function applied to *x*.  It must have the
1967             signature ::
1968 
1969                 detrend(x: np.ndarray) -> np.ndarray
1970 
1971         normed : bool, default: True
1972             If ``True``, input vectors are normalised to unit length.
1973 
1974         usevlines : bool, default: True
1975             Determines the plot style.
1976 
1977             If ``True``, vertical lines are plotted from 0 to the acorr value
1978             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1979             at y=0 using `.Axes.axhline`.
1980 
1981             If ``False``, markers are plotted at the acorr values using
1982             `.Axes.plot`.
1983 
1984         maxlags : int, default: 10
1985             Number of lags to show. If ``None``, will return all
1986             ``2 * len(x) - 1`` lags.
1987 
1988         Returns
1989         -------
1990         lags : array (length ``2*maxlags+1``)
1991             The lag vector.
1992         c : array  (length ``2*maxlags+1``)
1993             The auto correlation vector.
1994         line : `.LineCollection` or `.Line2D`
1995             `.Artist` added to the Axes of the correlation:
1996 
1997             - `.LineCollection` if *usevlines* is True.
1998             - `.Line2D` if *usevlines* is False.
1999         b : `~matplotlib.lines.Line2D` or None
2000             Horizontal line at 0 if *usevlines* is True
2001             None *usevlines* is False.
2002 
2003         Other Parameters
2004         ----------------
2005         linestyle : `~matplotlib.lines.Line2D` property, optional
2006             The linestyle for plotting the data points.
2007             Only used if *usevlines* is ``False``.
2008 
2009         marker : str, default: 'o'
2010             The marker for plotting the data points.
2011             Only used if *usevlines* is ``False``.
2012 
2013         data : indexable object, optional
2014             DATA_PARAMETER_PLACEHOLDER
2015 
2016         **kwargs
2017             Additional parameters are passed to `.Axes.vlines` and
2018             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2019             passed to `.Axes.plot`.
2020 
2021         Notes
2022         -----
2023         The cross correlation is performed with `numpy.correlate` with
2024         ``mode = "full"``.
2025         """
2026         return self.xcorr(x, x, **kwargs)
2027 
2028     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2029     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2030               usevlines=True, maxlags=10, **kwargs):
2031         r"""
2032         Plot the cross correlation between *x* and *y*.
2033 
2034         The correlation with lag k is defined as
2035         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2036         conjugate of :math:`y`.
2037 
2038         Parameters
2039         ----------
2040         x, y : array-like of length n
2041 
2042         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2043             A detrending function applied to *x* and *y*.  It must have the
2044             signature ::
2045 
2046                 detrend(x: np.ndarray) -> np.ndarray
2047 
2048         normed : bool, default: True
2049             If ``True``, input vectors are normalised to unit length.
2050 
2051         usevlines : bool, default: True
2052             Determines the plot style.
2053 
2054             If ``True``, vertical lines are plotted from 0 to the xcorr value
2055             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2056             at y=0 using `.Axes.axhline`.
2057 
2058             If ``False``, markers are plotted at the xcorr values using
2059             `.Axes.plot`.
2060 
2061         maxlags : int, default: 10
2062             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2063             lags.
2064 
2065         Returns
2066         -------
2067         lags : array (length ``2*maxlags+1``)
2068             The lag vector.
2069         c : array  (length ``2*maxlags+1``)
2070             The auto correlation vector.
2071         line : `.LineCollection` or `.Line2D`
2072             `.Artist` added to the Axes of the correlation:
2073 
2074             - `.LineCollection` if *usevlines* is True.
2075             - `.Line2D` if *usevlines* is False.
2076         b : `~matplotlib.lines.Line2D` or None
2077             Horizontal line at 0 if *usevlines* is True
2078             None *usevlines* is False.
2079 
2080         Other Parameters
2081         ----------------
2082         linestyle : `~matplotlib.lines.Line2D` property, optional
2083             The linestyle for plotting the data points.
2084             Only used if *usevlines* is ``False``.
2085 
2086         marker : str, default: 'o'
2087             The marker for plotting the data points.
2088             Only used if *usevlines* is ``False``.
2089 
2090         data : indexable object, optional
2091             DATA_PARAMETER_PLACEHOLDER
2092 
2093         **kwargs
2094             Additional parameters are passed to `.Axes.vlines` and
2095             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2096             passed to `.Axes.plot`.
2097 
2098         Notes
2099         -----
2100         The cross correlation is performed with `numpy.correlate` with
2101         ``mode = "full"``.
2102         """
2103         Nx = len(x)
2104         if Nx != len(y):
2105             raise ValueError('x and y must be equal length')
2106 
2107         x = detrend(np.asarray(x))
2108         y = detrend(np.asarray(y))
2109 
2110         correls = np.correlate(x, y, mode="full")
2111 
2112         if normed:
2113             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2114 
2115         if maxlags is None:
2116             maxlags = Nx - 1
2117 
2118         if maxlags >= Nx or maxlags < 1:
2119             raise ValueError('maxlags must be None or strictly '
2120                              'positive < %d' % Nx)
2121 
2122         lags = np.arange(-maxlags, maxlags + 1)
2123         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2124 
2125         if usevlines:
2126             a = self.vlines(lags, [0], correls, **kwargs)
2127             # Make label empty so only vertical lines get a legend entry
2128             kwargs.pop('label', '')
2129             b = self.axhline(**kwargs)
2130         else:
2131             kwargs.setdefault('marker', 'o')
2132             kwargs.setdefault('linestyle', 'None')
2133             a, = self.plot(lags, correls, **kwargs)
2134             b = None
2135         return lags, correls, a, b
2136 
2137     #### Specialized plotting
2138 
2139     # @_preprocess_data() # let 'plot' do the unpacking..
2140     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2141         """
2142         Make a step plot.
2143 
2144         Call signatures::
2145 
2146             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2147             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2148 
2149         This is just a thin wrapper around `.plot` which changes some
2150         formatting options. Most of the concepts and parameters of plot can be
2151         used here as well.
2152 
2153         .. note::
2154 
2155             This method uses a standard plot with a step drawstyle: The *x*
2156             values are the reference positions and steps extend left/right/both
2157             directions depending on *where*.
2158 
2159             For the common case where you know the values and edges of the
2160             steps, use `~.Axes.stairs` instead.
2161 
2162         Parameters
2163         ----------
2164         x : array-like
2165             1D sequence of x positions. It is assumed, but not checked, that
2166             it is uniformly increasing.
2167 
2168         y : array-like
2169             1D sequence of y levels.
2170 
2171         fmt : str, optional
2172             A format string, e.g. 'g' for a green line. See `.plot` for a more
2173             detailed description.
2174 
2175             Note: While full format strings are accepted, it is recommended to
2176             only specify the color. Line styles are currently ignored (use
2177             the keyword argument *linestyle* instead). Markers are accepted
2178             and plotted on the given positions, however, this is a rarely
2179             needed feature for step plots.
2180 
2181         where : {'pre', 'post', 'mid'}, default: 'pre'
2182             Define where the steps should be placed:
2183 
2184             - 'pre': The y value is continued constantly to the left from
2185               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2186               value ``y[i]``.
2187             - 'post': The y value is continued constantly to the right from
2188               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2189               value ``y[i]``.
2190             - 'mid': Steps occur half-way between the *x* positions.
2191 
2192         data : indexable object, optional
2193             An object with labelled data. If given, provide the label names to
2194             plot in *x* and *y*.
2195 
2196         **kwargs
2197             Additional parameters are the same as those for `.plot`.
2198 
2199         Returns
2200         -------
2201         list of `.Line2D`
2202             Objects representing the plotted data.
2203         """
2204         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2205         kwargs['drawstyle'] = 'steps-' + where
2206         return self.plot(x, y, *args, data=data, **kwargs)
2207 
2208     @staticmethod
2209     def _convert_dx(dx, x0, xconv, convert):
2210         """
2211         Small helper to do logic of width conversion flexibly.
2212 
2213         *dx* and *x0* have units, but *xconv* has already been converted
2214         to unitless (and is an ndarray).  This allows the *dx* to have units
2215         that are different from *x0*, but are still accepted by the
2216         ``__add__`` operator of *x0*.
2217         """
2218 
2219         # x should be an array...
2220         assert type(xconv) is np.ndarray
2221 
2222         if xconv.size == 0:
2223             # xconv has already been converted, but maybe empty...
2224             return convert(dx)
2225 
2226         try:
2227             # attempt to add the width to x0; this works for
2228             # datetime+timedelta, for instance
2229 
2230             # only use the first element of x and x0.  This saves
2231             # having to be sure addition works across the whole
2232             # vector.  This is particularly an issue if
2233             # x0 and dx are lists so x0 + dx just concatenates the lists.
2234             # We can't just cast x0 and dx to numpy arrays because that
2235             # removes the units from unit packages like `pint` that
2236             # wrap numpy arrays.
2237             try:
2238                 x0 = cbook._safe_first_finite(x0)
2239             except (TypeError, IndexError, KeyError):
2240                 pass
2241 
2242             try:
2243                 x = cbook._safe_first_finite(xconv)
2244             except (TypeError, IndexError, KeyError):
2245                 x = xconv
2246 
2247             delist = False
2248             if not np.iterable(dx):
2249                 dx = [dx]
2250                 delist = True
2251             dx = [convert(x0 + ddx) - x for ddx in dx]
2252             if delist:
2253                 dx = dx[0]
2254         except (ValueError, TypeError, AttributeError):
2255             # if the above fails (for any reason) just fallback to what
2256             # we do by default and convert dx by itself.
2257             dx = convert(dx)
2258         return dx
2259 
2260     @_preprocess_data()
2261     @_docstring.dedent_interpd
2262     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2263             **kwargs):
2264         r"""
2265         Make a bar plot.
2266 
2267         The bars are positioned at *x* with the given *align*\ment. Their
2268         dimensions are given by *height* and *width*. The vertical baseline
2269         is *bottom* (default 0).
2270 
2271         Many parameters can take either a single value applying to all bars
2272         or a sequence of values, one for each bar.
2273 
2274         Parameters
2275         ----------
2276         x : float or array-like
2277             The x coordinates of the bars. See also *align* for the
2278             alignment of the bars to the coordinates.
2279 
2280         height : float or array-like
2281             The height(s) of the bars.
2282 
2283             Note that if *bottom* has units (e.g. datetime), *height* should be in
2284             units that are a difference from the value of *bottom* (e.g. timedelta).
2285 
2286         width : float or array-like, default: 0.8
2287             The width(s) of the bars.
2288 
2289             Note that if *x* has units (e.g. datetime), then *width* should be in
2290             units that are a difference (e.g. timedelta) around the *x* values.
2291 
2292         bottom : float or array-like, default: 0
2293             The y coordinate(s) of the bottom side(s) of the bars.
2294 
2295             Note that if *bottom* has units, then the y-axis will get a Locator and
2296             Formatter appropriate for the units (e.g. dates, or categorical).
2297 
2298         align : {'center', 'edge'}, default: 'center'
2299             Alignment of the bars to the *x* coordinates:
2300 
2301             - 'center': Center the base on the *x* positions.
2302             - 'edge': Align the left edges of the bars with the *x* positions.
2303 
2304             To align the bars on the right edge pass a negative *width* and
2305             ``align='edge'``.
2306 
2307         Returns
2308         -------
2309         `.BarContainer`
2310             Container with all the bars and optionally errorbars.
2311 
2312         Other Parameters
2313         ----------------
2314         color : color or list of color, optional
2315             The colors of the bar faces.
2316 
2317         edgecolor : color or list of color, optional
2318             The colors of the bar edges.
2319 
2320         linewidth : float or array-like, optional
2321             Width of the bar edge(s). If 0, don't draw edges.
2322 
2323         tick_label : str or list of str, optional
2324             The tick labels of the bars.
2325             Default: None (Use default numeric labels.)
2326 
2327         label : str or list of str, optional
2328             A single label is attached to the resulting `.BarContainer` as a
2329             label for the whole dataset.
2330             If a list is provided, it must be the same length as *x* and
2331             labels the individual bars. Repeated labels are not de-duplicated
2332             and will cause repeated label entries, so this is best used when
2333             bars also differ in style (e.g., by passing a list to *color*.)
2334 
2335         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2336             If not *None*, add horizontal / vertical errorbars to the bar tips.
2337             The values are +/- sizes relative to the data:
2338 
2339             - scalar: symmetric +/- values for all bars
2340             - shape(N,): symmetric +/- values for each bar
2341             - shape(2, N): Separate - and + values for each bar. First row
2342               contains the lower errors, the second row contains the upper
2343               errors.
2344             - *None*: No errorbar. (Default)
2345 
2346             See :doc:`/gallery/statistics/errorbar_features` for an example on
2347             the usage of *xerr* and *yerr*.
2348 
2349         ecolor : color or list of color, default: 'black'
2350             The line color of the errorbars.
2351 
2352         capsize : float, default: :rc:`errorbar.capsize`
2353            The length of the error bar caps in points.
2354 
2355         error_kw : dict, optional
2356             Dictionary of keyword arguments to be passed to the
2357             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2358             here take precedence over the independent keyword arguments.
2359 
2360         log : bool, default: False
2361             If *True*, set the y-axis to be log scale.
2362 
2363         data : indexable object, optional
2364             DATA_PARAMETER_PLACEHOLDER
2365 
2366         **kwargs : `.Rectangle` properties
2367 
2368         %(Rectangle:kwdoc)s
2369 
2370         See Also
2371         --------
2372         barh : Plot a horizontal bar plot.
2373 
2374         Notes
2375         -----
2376         Stacked bars can be achieved by passing individual *bottom* values per
2377         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2378         """
2379         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2380         color = kwargs.pop('color', None)
2381         if color is None:
2382             color = self._get_patches_for_fill.get_next_color()
2383         edgecolor = kwargs.pop('edgecolor', None)
2384         linewidth = kwargs.pop('linewidth', None)
2385         hatch = kwargs.pop('hatch', None)
2386 
2387         # Because xerr and yerr will be passed to errorbar, most dimension
2388         # checking and processing will be left to the errorbar method.
2389         xerr = kwargs.pop('xerr', None)
2390         yerr = kwargs.pop('yerr', None)
2391         error_kw = kwargs.pop('error_kw', {})
2392         ezorder = error_kw.pop('zorder', None)
2393         if ezorder is None:
2394             ezorder = kwargs.get('zorder', None)
2395             if ezorder is not None:
2396                 # If using the bar zorder, increment slightly to make sure
2397                 # errorbars are drawn on top of bars
2398                 ezorder += 0.01
2399         error_kw.setdefault('zorder', ezorder)
2400         ecolor = kwargs.pop('ecolor', 'k')
2401         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2402         error_kw.setdefault('ecolor', ecolor)
2403         error_kw.setdefault('capsize', capsize)
2404 
2405         # The keyword argument *orientation* is used by barh() to defer all
2406         # logic and drawing to bar(). It is considered internal and is
2407         # intentionally not mentioned in the docstring.
2408         orientation = kwargs.pop('orientation', 'vertical')
2409         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2410         log = kwargs.pop('log', False)
2411         label = kwargs.pop('label', '')
2412         tick_labels = kwargs.pop('tick_label', None)
2413 
2414         y = bottom  # Matches barh call signature.
2415         if orientation == 'vertical':
2416             if y is None:
2417                 y = 0
2418         else:  # horizontal
2419             if x is None:
2420                 x = 0
2421 
2422         if orientation == 'vertical':
2423             # It is possible for y (bottom) to contain unit information.
2424             # However, it is also possible for y=0 for the default and height
2425             # to contain unit information.  This will prioritize the units of y.
2426             self._process_unit_info(
2427                 [("x", x), ("y", y), ("y", height)], kwargs, convert=False)
2428             if log:
2429                 self.set_yscale('log', nonpositive='clip')
2430         else:  # horizontal
2431             # It is possible for x (left) to contain unit information.
2432             # However, it is also possible for x=0 for the default and width
2433             # to contain unit information.  This will prioritize the units of x.
2434             self._process_unit_info(
2435                 [("x", x), ("x", width), ("y", y)], kwargs, convert=False)
2436             if log:
2437                 self.set_xscale('log', nonpositive='clip')
2438 
2439         # lets do some conversions now since some types cannot be
2440         # subtracted uniformly
2441         if self.xaxis is not None:
2442             x0 = x
2443             x = np.asarray(self.convert_xunits(x))
2444             width = self._convert_dx(width, x0, x, self.convert_xunits)
2445             if xerr is not None:
2446                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2447         if self.yaxis is not None:
2448             y0 = y
2449             y = np.asarray(self.convert_yunits(y))
2450             height = self._convert_dx(height, y0, y, self.convert_yunits)
2451             if yerr is not None:
2452                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2453 
2454         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2455             # Make args iterable too.
2456             np.atleast_1d(x), height, width, y, linewidth, hatch)
2457 
2458         # Now that units have been converted, set the tick locations.
2459         if orientation == 'vertical':
2460             tick_label_axis = self.xaxis
2461             tick_label_position = x
2462         else:  # horizontal
2463             tick_label_axis = self.yaxis
2464             tick_label_position = y
2465 
2466         if not isinstance(label, str) and np.iterable(label):
2467             bar_container_label = '_nolegend_'
2468             patch_labels = label
2469         else:
2470             bar_container_label = label
2471             patch_labels = ['_nolegend_'] * len(x)
2472         if len(patch_labels) != len(x):
2473             raise ValueError(f'number of labels ({len(patch_labels)}) '
2474                              f'does not match number of bars ({len(x)}).')
2475 
2476         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2477         hatch = itertools.cycle(np.atleast_1d(hatch))
2478         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2479                                 # Fallback if color == "none".
2480                                 itertools.repeat('none'))
2481         if edgecolor is None:
2482             edgecolor = itertools.repeat(None)
2483         else:
2484             edgecolor = itertools.chain(
2485                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2486                 # Fallback if edgecolor == "none".
2487                 itertools.repeat('none'))
2488 
2489         # We will now resolve the alignment and really have
2490         # left, bottom, width, height vectors
2491         _api.check_in_list(['center', 'edge'], align=align)
2492         if align == 'center':
2493             if orientation == 'vertical':
2494                 try:
2495                     left = x - width / 2
2496                 except TypeError as e:
2497                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2498                                     f'and width ({width.dtype}) '
2499                                     f'are incompatible') from e
2500                 bottom = y
2501             else:  # horizontal
2502                 try:
2503                     bottom = y - height / 2
2504                 except TypeError as e:
2505                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2506                                     f'and height ({height.dtype}) '
2507                                     f'are incompatible') from e
2508                 left = x
2509         else:  # edge
2510             left = x
2511             bottom = y
2512 
2513         patches = []
2514         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2515                    hatch, patch_labels)
2516         for l, b, w, h, c, e, lw, htch, lbl in args:
2517             r = mpatches.Rectangle(
2518                 xy=(l, b), width=w, height=h,
2519                 facecolor=c,
2520                 edgecolor=e,
2521                 linewidth=lw,
2522                 label=lbl,
2523                 hatch=htch,
2524                 )
2525             r._internal_update(kwargs)
2526             r.get_path()._interpolation_steps = 100
2527             if orientation == 'vertical':
2528                 r.sticky_edges.y.append(b)
2529             else:  # horizontal
2530                 r.sticky_edges.x.append(l)
2531             self.add_patch(r)
2532             patches.append(r)
2533 
2534         if xerr is not None or yerr is not None:
2535             if orientation == 'vertical':
2536                 # using list comps rather than arrays to preserve unit info
2537                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2538                 ey = [b + h for b, h in zip(bottom, height)]
2539 
2540             else:  # horizontal
2541                 # using list comps rather than arrays to preserve unit info
2542                 ex = [l + w for l, w in zip(left, width)]
2543                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2544 
2545             error_kw.setdefault("label", '_nolegend_')
2546 
2547             errorbar = self.errorbar(ex, ey,
2548                                      yerr=yerr, xerr=xerr,
2549                                      fmt='none', **error_kw)
2550         else:
2551             errorbar = None
2552 
2553         self._request_autoscale_view()
2554 
2555         if orientation == 'vertical':
2556             datavalues = height
2557         else:  # horizontal
2558             datavalues = width
2559 
2560         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2561                                      orientation=orientation,
2562                                      label=bar_container_label)
2563         self.add_container(bar_container)
2564 
2565         if tick_labels is not None:
2566             tick_labels = np.broadcast_to(tick_labels, len(patches))
2567             tick_label_axis.set_ticks(tick_label_position)
2568             tick_label_axis.set_ticklabels(tick_labels)
2569 
2570         return bar_container
2571 
2572     # @_preprocess_data() # let 'bar' do the unpacking..
2573     @_docstring.dedent_interpd
2574     def barh(self, y, width, height=0.8, left=None, *, align="center",
2575              data=None, **kwargs):
2576         r"""
2577         Make a horizontal bar plot.
2578 
2579         The bars are positioned at *y* with the given *align*\ment. Their
2580         dimensions are given by *width* and *height*. The horizontal baseline
2581         is *left* (default 0).
2582 
2583         Many parameters can take either a single value applying to all bars
2584         or a sequence of values, one for each bar.
2585 
2586         Parameters
2587         ----------
2588         y : float or array-like
2589             The y coordinates of the bars. See also *align* for the
2590             alignment of the bars to the coordinates.
2591 
2592         width : float or array-like
2593             The width(s) of the bars.
2594 
2595             Note that if *left* has units (e.g. datetime), *width* should be in
2596             units that are a difference from the value of *left* (e.g. timedelta).
2597 
2598         height : float or array-like, default: 0.8
2599             The heights of the bars.
2600 
2601             Note that if *y* has units (e.g. datetime), then *height* should be in
2602             units that are a difference (e.g. timedelta) around the *y* values.
2603 
2604         left : float or array-like, default: 0
2605             The x coordinates of the left side(s) of the bars.
2606 
2607             Note that if *left* has units, then the x-axis will get a Locator and
2608             Formatter appropriate for the units (e.g. dates, or categorical).
2609 
2610         align : {'center', 'edge'}, default: 'center'
2611             Alignment of the base to the *y* coordinates*:
2612 
2613             - 'center': Center the bars on the *y* positions.
2614             - 'edge': Align the bottom edges of the bars with the *y*
2615               positions.
2616 
2617             To align the bars on the top edge pass a negative *height* and
2618             ``align='edge'``.
2619 
2620         Returns
2621         -------
2622         `.BarContainer`
2623             Container with all the bars and optionally errorbars.
2624 
2625         Other Parameters
2626         ----------------
2627         color : color or list of color, optional
2628             The colors of the bar faces.
2629 
2630         edgecolor : color or list of color, optional
2631             The colors of the bar edges.
2632 
2633         linewidth : float or array-like, optional
2634             Width of the bar edge(s). If 0, don't draw edges.
2635 
2636         tick_label : str or list of str, optional
2637             The tick labels of the bars.
2638             Default: None (Use default numeric labels.)
2639 
2640         label : str or list of str, optional
2641             A single label is attached to the resulting `.BarContainer` as a
2642             label for the whole dataset.
2643             If a list is provided, it must be the same length as *y* and
2644             labels the individual bars. Repeated labels are not de-duplicated
2645             and will cause repeated label entries, so this is best used when
2646             bars also differ in style (e.g., by passing a list to *color*.)
2647 
2648         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2649             If not *None*, add horizontal / vertical errorbars to the bar tips.
2650             The values are +/- sizes relative to the data:
2651 
2652             - scalar: symmetric +/- values for all bars
2653             - shape(N,): symmetric +/- values for each bar
2654             - shape(2, N): Separate - and + values for each bar. First row
2655               contains the lower errors, the second row contains the upper
2656               errors.
2657             - *None*: No errorbar. (default)
2658 
2659             See :doc:`/gallery/statistics/errorbar_features` for an example on
2660             the usage of *xerr* and *yerr*.
2661 
2662         ecolor : color or list of color, default: 'black'
2663             The line color of the errorbars.
2664 
2665         capsize : float, default: :rc:`errorbar.capsize`
2666            The length of the error bar caps in points.
2667 
2668         error_kw : dict, optional
2669             Dictionary of keyword arguments to be passed to the
2670             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2671             here take precedence over the independent keyword arguments.
2672 
2673         log : bool, default: False
2674             If ``True``, set the x-axis to be log scale.
2675 
2676         data : indexable object, optional
2677             If given, all parameters also accept a string ``s``, which is
2678             interpreted as ``data[s]`` (unless this raises an exception).
2679 
2680         **kwargs : `.Rectangle` properties
2681 
2682         %(Rectangle:kwdoc)s
2683 
2684         See Also
2685         --------
2686         bar : Plot a vertical bar plot.
2687 
2688         Notes
2689         -----
2690         Stacked bars can be achieved by passing individual *left* values per
2691         bar. See
2692         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2693         """
2694         kwargs.setdefault('orientation', 'horizontal')
2695         patches = self.bar(x=left, height=height, width=width, bottom=y,
2696                            align=align, data=data, **kwargs)
2697         return patches
2698 
2699     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2700                   padding=0, **kwargs):
2701         """
2702         Label a bar plot.
2703 
2704         Adds labels to bars in the given `.BarContainer`.
2705         You may need to adjust the axis limits to fit the labels.
2706 
2707         Parameters
2708         ----------
2709         container : `.BarContainer`
2710             Container with all the bars and optionally errorbars, likely
2711             returned from `.bar` or `.barh`.
2712 
2713         labels : array-like, optional
2714             A list of label texts, that should be displayed. If not given, the
2715             label texts will be the data values formatted with *fmt*.
2716 
2717         fmt : str or callable, default: '%g'
2718             An unnamed %-style or {}-style format string for the label or a
2719             function to call with the value as the first argument.
2720             When *fmt* is a string and can be interpreted in both formats,
2721             %-style takes precedence over {}-style.
2722 
2723             .. versionadded:: 3.7
2724                Support for {}-style format string and callables.
2725 
2726         label_type : {'edge', 'center'}, default: 'edge'
2727             The label type. Possible values:
2728 
2729             - 'edge': label placed at the end-point of the bar segment, and the
2730               value displayed will be the position of that end-point.
2731             - 'center': label placed in the center of the bar segment, and the
2732               value displayed will be the length of that segment.
2733               (useful for stacked bars, i.e.,
2734               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2735 
2736         padding : float, default: 0
2737             Distance of label from the end of the bar, in points.
2738 
2739         **kwargs
2740             Any remaining keyword arguments are passed through to
2741             `.Axes.annotate`. The alignment parameters (
2742             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2743             not supported because the labels are automatically aligned to
2744             the bars.
2745 
2746         Returns
2747         -------
2748         list of `.Text`
2749             A list of `.Text` instances for the labels.
2750         """
2751         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2752             if key in kwargs:
2753                 raise ValueError(
2754                     f"Passing {key!r} to bar_label() is not supported.")
2755 
2756         a, b = self.yaxis.get_view_interval()
2757         y_inverted = a > b
2758         c, d = self.xaxis.get_view_interval()
2759         x_inverted = c > d
2760 
2761         # want to know whether to put label on positive or negative direction
2762         # cannot use np.sign here because it will return 0 if x == 0
2763         def sign(x):
2764             return 1 if x >= 0 else -1
2765 
2766         _api.check_in_list(['edge', 'center'], label_type=label_type)
2767 
2768         bars = container.patches
2769         errorbar = container.errorbar
2770         datavalues = container.datavalues
2771         orientation = container.orientation
2772 
2773         if errorbar:
2774             # check "ErrorbarContainer" for the definition of these elements
2775             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2776             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2777             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2778             errs = barlinecol.get_segments()
2779         else:
2780             errs = []
2781 
2782         if labels is None:
2783             labels = []
2784 
2785         annotations = []
2786 
2787         for bar, err, dat, lbl in itertools.zip_longest(
2788                 bars, errs, datavalues, labels
2789         ):
2790             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2791             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2792 
2793             if orientation == "vertical":
2794                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2795                 length = abs(y0 - y1)
2796             else:  # horizontal
2797                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2798                 length = abs(x0 - x1)
2799 
2800             if err is None or np.size(err) == 0:
2801                 endpt = extrema
2802             elif orientation == "vertical":
2803                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2804             else:  # horizontal
2805                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2806 
2807             if label_type == "center":
2808                 value = sign(dat) * length
2809             else:  # edge
2810                 value = extrema
2811 
2812             if label_type == "center":
2813                 xy = (0.5, 0.5)
2814                 kwargs["xycoords"] = (
2815                     lambda r, b=bar:
2816                         mtransforms.Bbox.intersection(
2817                             b.get_window_extent(r), b.get_clip_box()
2818                         ) or mtransforms.Bbox.null()
2819                 )
2820             else:  # edge
2821                 if orientation == "vertical":
2822                     xy = xc, endpt
2823                 else:  # horizontal
2824                     xy = endpt, yc
2825 
2826             if orientation == "vertical":
2827                 y_direction = -1 if y_inverted else 1
2828                 xytext = 0, y_direction * sign(dat) * padding
2829             else:  # horizontal
2830                 x_direction = -1 if x_inverted else 1
2831                 xytext = x_direction * sign(dat) * padding, 0
2832 
2833             if label_type == "center":
2834                 ha, va = "center", "center"
2835             else:  # edge
2836                 if orientation == "vertical":
2837                     ha = 'center'
2838                     if y_inverted:
2839                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2840                     else:
2841                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2842                 else:  # horizontal
2843                     if x_inverted:
2844                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2845                     else:
2846                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2847                     va = 'center'
2848 
2849             if np.isnan(dat):
2850                 lbl = ''
2851 
2852             if lbl is None:
2853                 if isinstance(fmt, str):
2854                     lbl = cbook._auto_format_str(fmt, value)
2855                 elif callable(fmt):
2856                     lbl = fmt(value)
2857                 else:
2858                     raise TypeError("fmt must be a str or callable")
2859             annotation = self.annotate(lbl,
2860                                        xy, xytext, textcoords="offset points",
2861                                        ha=ha, va=va, **kwargs)
2862             annotations.append(annotation)
2863 
2864         return annotations
2865 
2866     @_preprocess_data()
2867     @_docstring.dedent_interpd
2868     def broken_barh(self, xranges, yrange, **kwargs):
2869         """
2870         Plot a horizontal sequence of rectangles.
2871 
2872         A rectangle is drawn for each element of *xranges*. All rectangles
2873         have the same vertical position and size defined by *yrange*.
2874 
2875         Parameters
2876         ----------
2877         xranges : sequence of tuples (*xmin*, *xwidth*)
2878             The x-positions and extents of the rectangles. For each tuple
2879             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2880             *xwidth*.
2881         yrange : (*ymin*, *yheight*)
2882             The y-position and extent for all the rectangles.
2883 
2884         Returns
2885         -------
2886         `~.collections.PolyCollection`
2887 
2888         Other Parameters
2889         ----------------
2890         data : indexable object, optional
2891             DATA_PARAMETER_PLACEHOLDER
2892         **kwargs : `.PolyCollection` properties
2893 
2894             Each *kwarg* can be either a single argument applying to all
2895             rectangles, e.g.::
2896 
2897                 facecolors='black'
2898 
2899             or a sequence of arguments over which is cycled, e.g.::
2900 
2901                 facecolors=('black', 'blue')
2902 
2903             would create interleaving black and blue rectangles.
2904 
2905             Supported keywords:
2906 
2907             %(PolyCollection:kwdoc)s
2908         """
2909         # process the unit information
2910         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2911         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2912         self._process_unit_info(
2913             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2914 
2915         vertices = []
2916         y0, dy = yrange
2917         y0, y1 = self.convert_yunits((y0, y0 + dy))
2918         for xr in xranges:  # convert the absolute values, not the x and dx
2919             try:
2920                 x0, dx = xr
2921             except Exception:
2922                 raise ValueError(
2923                     "each range in xrange must be a sequence with two "
2924                     "elements (i.e. xrange must be an (N, 2) array)") from None
2925             x0, x1 = self.convert_xunits((x0, x0 + dx))
2926             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2927 
2928         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2929         self.add_collection(col, autolim=True)
2930         self._request_autoscale_view()
2931 
2932         return col
2933 
2934     @_preprocess_data()
2935     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2936              label=None, orientation='vertical'):
2937         """
2938         Create a stem plot.
2939 
2940         A stem plot draws lines perpendicular to a baseline at each location
2941         *locs* from the baseline to *heads*, and places a marker there. For
2942         vertical stem plots (the default), the *locs* are *x* positions, and
2943         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2944         *y* positions, and the *heads* are *x* values.
2945 
2946         Call signature::
2947 
2948           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2949 
2950         The *locs*-positions are optional. *linefmt* may be provided as
2951         positional, but all other formats must be provided as keyword
2952         arguments.
2953 
2954         Parameters
2955         ----------
2956         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2957             For vertical stem plots, the x-positions of the stems.
2958             For horizontal stem plots, the y-positions of the stems.
2959 
2960         heads : array-like
2961             For vertical stem plots, the y-values of the stem heads.
2962             For horizontal stem plots, the x-values of the stem heads.
2963 
2964         linefmt : str, optional
2965             A string defining the color and/or linestyle of the vertical lines:
2966 
2967             =========  =============
2968             Character  Line Style
2969             =========  =============
2970             ``'-'``    solid line
2971             ``'--'``   dashed line
2972             ``'-.'``   dash-dot line
2973             ``':'``    dotted line
2974             =========  =============
2975 
2976             Default: 'C0-', i.e. solid line with the first color of the color
2977             cycle.
2978 
2979             Note: Markers specified through this parameter (e.g. 'x') will be
2980             silently ignored. Instead, markers should be specified using
2981             *markerfmt*.
2982 
2983         markerfmt : str, optional
2984             A string defining the color and/or shape of the markers at the stem
2985             heads. If the marker is not given, use the marker 'o', i.e. filled
2986             circles. If the color is not given, use the color from *linefmt*.
2987 
2988         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2989             A format string defining the properties of the baseline.
2990 
2991         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2992             If 'vertical', will produce a plot with stems oriented vertically,
2993             If 'horizontal', the stems will be oriented horizontally.
2994 
2995         bottom : float, default: 0
2996             The y/x-position of the baseline (depending on orientation).
2997 
2998         label : str, default: None
2999             The label to use for the stems in legends.
3000 
3001         data : indexable object, optional
3002             DATA_PARAMETER_PLACEHOLDER
3003 
3004         Returns
3005         -------
3006         `.StemContainer`
3007             The container may be treated like a tuple
3008             (*markerline*, *stemlines*, *baseline*)
3009 
3010         Notes
3011         -----
3012         .. seealso::
3013             The MATLAB function
3014             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
3015             which inspired this method.
3016         """
3017         if not 1 <= len(args) <= 3:
3018             raise _api.nargs_error('stem', '1-3', len(args))
3019         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3020 
3021         if len(args) == 1:
3022             heads, = args
3023             locs = np.arange(len(heads))
3024             args = ()
3025         elif isinstance(args[1], str):
3026             heads, *args = args
3027             locs = np.arange(len(heads))
3028         else:
3029             locs, heads, *args = args
3030 
3031         if orientation == 'vertical':
3032             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3033         else:  # horizontal
3034             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3035 
3036         # resolve line format
3037         if linefmt is None:
3038             linefmt = args[0] if len(args) > 0 else "C0-"
3039         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3040 
3041         # resolve marker format
3042         if markerfmt is None:
3043             # if not given as kwarg, fall back to 'o'
3044             markerfmt = "o"
3045         if markerfmt == '':
3046             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3047         markerstyle, markermarker, markercolor = \
3048             _process_plot_format(markerfmt)
3049         if markermarker is None:
3050             markermarker = 'o'
3051         if markerstyle is None:
3052             markerstyle = 'None'
3053         if markercolor is None:
3054             markercolor = linecolor
3055 
3056         # resolve baseline format
3057         if basefmt is None:
3058             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3059                        "C3-")
3060         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3061 
3062         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3063         if linestyle is None:
3064             linestyle = mpl.rcParams['lines.linestyle']
3065         xlines = self.vlines if orientation == "vertical" else self.hlines
3066         stemlines = xlines(
3067             locs, bottom, heads,
3068             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3069 
3070         if orientation == 'horizontal':
3071             marker_x = heads
3072             marker_y = locs
3073             baseline_x = [bottom, bottom]
3074             baseline_y = [np.min(locs), np.max(locs)]
3075         else:
3076             marker_x = locs
3077             marker_y = heads
3078             baseline_x = [np.min(locs), np.max(locs)]
3079             baseline_y = [bottom, bottom]
3080 
3081         markerline, = self.plot(marker_x, marker_y,
3082                                 color=markercolor, linestyle=markerstyle,
3083                                 marker=markermarker, label="_nolegend_")
3084 
3085         baseline, = self.plot(baseline_x, baseline_y,
3086                               color=basecolor, linestyle=basestyle,
3087                               marker=basemarker, label="_nolegend_")
3088 
3089         stem_container = StemContainer((markerline, stemlines, baseline),
3090                                        label=label)
3091         self.add_container(stem_container)
3092         return stem_container
3093 
3094     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3095     def pie(self, x, explode=None, labels=None, colors=None,
3096             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3097             startangle=0, radius=1, counterclock=True,
3098             wedgeprops=None, textprops=None, center=(0, 0),
3099             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3100         """
3101         Plot a pie chart.
3102 
3103         Make a pie chart of array *x*.  The fractional area of each wedge is
3104         given by ``x/sum(x)``.
3105 
3106         The wedges are plotted counterclockwise, by default starting from the
3107         x-axis.
3108 
3109         Parameters
3110         ----------
3111         x : 1D array-like
3112             The wedge sizes.
3113 
3114         explode : array-like, default: None
3115             If not *None*, is a ``len(x)`` array which specifies the fraction
3116             of the radius with which to offset each wedge.
3117 
3118         labels : list, default: None
3119             A sequence of strings providing the labels for each wedge
3120 
3121         colors : color or array-like of color, default: None
3122             A sequence of colors through which the pie chart will cycle.  If
3123             *None*, will use the colors in the currently active cycle.
3124 
3125         hatch : str or list, default: None
3126             Hatching pattern applied to all pie wedges or sequence of patterns
3127             through which the chart will cycle. For a list of valid patterns,
3128             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3129 
3130             .. versionadded:: 3.7
3131 
3132         autopct : None or str or callable, default: None
3133             If not *None*, *autopct* is a string or function used to label the
3134             wedges with their numeric value. The label will be placed inside
3135             the wedge. If *autopct* is a format string, the label will be
3136             ``fmt % pct``. If *autopct* is a function, then it will be called.
3137 
3138         pctdistance : float, default: 0.6
3139             The relative distance along the radius at which the text
3140             generated by *autopct* is drawn. To draw the text outside the pie,
3141             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3142             ``None``.
3143 
3144         labeldistance : float or None, default: 1.1
3145             The relative distance along the radius at which the labels are
3146             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3147             If set to ``None``, labels are not drawn but are still stored for
3148             use in `.legend`.
3149 
3150         shadow : bool or dict, default: False
3151             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3152             passing the properties in the dict to `.Shadow`.
3153 
3154             .. versionadded:: 3.8
3155                 *shadow* can be a dict.
3156 
3157         startangle : float, default: 0 degrees
3158             The angle by which the start of the pie is rotated,
3159             counterclockwise from the x-axis.
3160 
3161         radius : float, default: 1
3162             The radius of the pie.
3163 
3164         counterclock : bool, default: True
3165             Specify fractions direction, clockwise or counterclockwise.
3166 
3167         wedgeprops : dict, default: None
3168             Dict of arguments passed to each `.patches.Wedge` of the pie.
3169             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3170             the wedge border lines equal to 3. By default, ``clip_on=False``.
3171             When there is a conflict between these properties and other
3172             keywords, properties passed to *wedgeprops* take precedence.
3173 
3174         textprops : dict, default: None
3175             Dict of arguments to pass to the text objects.
3176 
3177         center : (float, float), default: (0, 0)
3178             The coordinates of the center of the chart.
3179 
3180         frame : bool, default: False
3181             Plot Axes frame with the chart if true.
3182 
3183         rotatelabels : bool, default: False
3184             Rotate each label to the angle of the corresponding slice if true.
3185 
3186         normalize : bool, default: True
3187             When *True*, always make a full pie by normalizing x so that
3188             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3189             and raises a `ValueError` for ``sum(x) > 1``.
3190 
3191         data : indexable object, optional
3192             DATA_PARAMETER_PLACEHOLDER
3193 
3194         Returns
3195         -------
3196         patches : list
3197             A sequence of `matplotlib.patches.Wedge` instances
3198 
3199         texts : list
3200             A list of the label `.Text` instances.
3201 
3202         autotexts : list
3203             A list of `.Text` instances for the numeric labels. This will only
3204             be returned if the parameter *autopct* is not *None*.
3205 
3206         Notes
3207         -----
3208         The pie chart will probably look best if the figure and Axes are
3209         square, or the Axes aspect is equal.
3210         This method sets the aspect ratio of the axis to "equal".
3211         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3212         """
3213         self.set_aspect('equal')
3214         # The use of float32 is "historical", but can't be changed without
3215         # regenerating the test baselines.
3216         x = np.asarray(x, np.float32)
3217         if x.ndim > 1:
3218             raise ValueError("x must be 1D")
3219 
3220         if np.any(x < 0):
3221             raise ValueError("Wedge sizes 'x' must be non negative values")
3222 
3223         sx = x.sum()
3224 
3225         if normalize:
3226             x = x / sx
3227         elif sx > 1:
3228             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3229         if labels is None:
3230             labels = [''] * len(x)
3231         if explode is None:
3232             explode = [0] * len(x)
3233         if len(x) != len(labels):
3234             raise ValueError("'label' must be of length 'x'")
3235         if len(x) != len(explode):
3236             raise ValueError("'explode' must be of length 'x'")
3237         if colors is None:
3238             get_next_color = self._get_patches_for_fill.get_next_color
3239         else:
3240             color_cycle = itertools.cycle(colors)
3241 
3242             def get_next_color():
3243                 return next(color_cycle)
3244 
3245         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3246 
3247         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3248         if radius <= 0:
3249             raise ValueError(f'radius must be a positive number, not {radius}')
3250 
3251         # Starting theta1 is the start fraction of the circle
3252         theta1 = startangle / 360
3253 
3254         if wedgeprops is None:
3255             wedgeprops = {}
3256         if textprops is None:
3257             textprops = {}
3258 
3259         texts = []
3260         slices = []
3261         autotexts = []
3262 
3263         for frac, label, expl in zip(x, labels, explode):
3264             x, y = center
3265             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3266             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3267             x += expl * math.cos(thetam)
3268             y += expl * math.sin(thetam)
3269 
3270             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3271                                360. * max(theta1, theta2),
3272                                facecolor=get_next_color(),
3273                                hatch=next(hatch_cycle),
3274                                clip_on=False,
3275                                label=label)
3276             w.set(**wedgeprops)
3277             slices.append(w)
3278             self.add_patch(w)
3279 
3280             if shadow:
3281                 # Make sure to add a shadow after the call to add_patch so the
3282                 # figure and transform props will be set.
3283                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3284                 if isinstance(shadow, dict):
3285                     shadow_dict.update(shadow)
3286                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3287 
3288             if labeldistance is not None:
3289                 xt = x + labeldistance * radius * math.cos(thetam)
3290                 yt = y + labeldistance * radius * math.sin(thetam)
3291                 label_alignment_h = 'left' if xt > 0 else 'right'
3292                 label_alignment_v = 'center'
3293                 label_rotation = 'horizontal'
3294                 if rotatelabels:
3295                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3296                     label_rotation = (np.rad2deg(thetam)
3297                                       + (0 if xt > 0 else 180))
3298                 t = self.text(xt, yt, label,
3299                               clip_on=False,
3300                               horizontalalignment=label_alignment_h,
3301                               verticalalignment=label_alignment_v,
3302                               rotation=label_rotation,
3303                               size=mpl.rcParams['xtick.labelsize'])
3304                 t.set(**textprops)
3305                 texts.append(t)
3306 
3307             if autopct is not None:
3308                 xt = x + pctdistance * radius * math.cos(thetam)
3309                 yt = y + pctdistance * radius * math.sin(thetam)
3310                 if isinstance(autopct, str):
3311                     s = autopct % (100. * frac)
3312                 elif callable(autopct):
3313                     s = autopct(100. * frac)
3314                 else:
3315                     raise TypeError(
3316                         'autopct must be callable or a format string')
3317                 t = self.text(xt, yt, s,
3318                               clip_on=False,
3319                               horizontalalignment='center',
3320                               verticalalignment='center')
3321                 t.set(**textprops)
3322                 autotexts.append(t)
3323 
3324             theta1 = theta2
3325 
3326         if frame:
3327             self._request_autoscale_view()
3328         else:
3329             self.set(frame_on=False, xticks=[], yticks=[],
3330                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3331                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3332 
3333         if autopct is None:
3334             return slices, texts
3335         else:
3336             return slices, texts, autotexts
3337 
3338     @staticmethod
3339     def _errorevery_to_mask(x, errorevery):
3340         """
3341         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3342 
3343         This function is split out to be usable both by 2D and 3D errorbars.
3344         """
3345         if isinstance(errorevery, Integral):
3346             errorevery = (0, errorevery)
3347         if isinstance(errorevery, tuple):
3348             if (len(errorevery) == 2 and
3349                     isinstance(errorevery[0], Integral) and
3350                     isinstance(errorevery[1], Integral)):
3351                 errorevery = slice(errorevery[0], None, errorevery[1])
3352             else:
3353                 raise ValueError(
3354                     f'{errorevery=!r} is a not a tuple of two integers')
3355         elif isinstance(errorevery, slice):
3356             pass
3357         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3358             try:
3359                 x[errorevery]  # fancy indexing
3360             except (ValueError, IndexError) as err:
3361                 raise ValueError(
3362                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3363                     "index to match 'xerr'/'yerr'") from err
3364         else:
3365             raise ValueError(f"{errorevery=!r} is not a recognized value")
3366         everymask = np.zeros(len(x), bool)
3367         everymask[errorevery] = True
3368         return everymask
3369 
3370     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3371                       label_namer="y")
3372     @_docstring.dedent_interpd
3373     def errorbar(self, x, y, yerr=None, xerr=None,
3374                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3375                  barsabove=False, lolims=False, uplims=False,
3376                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3377                  **kwargs):
3378         """
3379         Plot y versus x as lines and/or markers with attached errorbars.
3380 
3381         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3382         sizes. By default, this draws the data markers/lines as well the
3383         errorbars. Use fmt='none' to draw errorbars without any data markers.
3384 
3385         .. versionadded:: 3.7
3386            Caps and error lines are drawn in polar coordinates on polar plots.
3387 
3388 
3389         Parameters
3390         ----------
3391         x, y : float or array-like
3392             The data positions.
3393 
3394         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3395             The errorbar sizes:
3396 
3397             - scalar: Symmetric +/- values for all data points.
3398             - shape(N,): Symmetric +/-values for each data point.
3399             - shape(2, N): Separate - and + values for each bar. First row
3400               contains the lower errors, the second row contains the upper
3401               errors.
3402             - *None*: No errorbar.
3403 
3404             All values must be >= 0.
3405 
3406             See :doc:`/gallery/statistics/errorbar_features`
3407             for an example on the usage of ``xerr`` and ``yerr``.
3408 
3409         fmt : str, default: ''
3410             The format for the data points / data lines. See `.plot` for
3411             details.
3412 
3413             Use 'none' (case-insensitive) to plot errorbars without any data
3414             markers.
3415 
3416         ecolor : color, default: None
3417             The color of the errorbar lines.  If None, use the color of the
3418             line connecting the markers.
3419 
3420         elinewidth : float, default: None
3421             The linewidth of the errorbar lines. If None, the linewidth of
3422             the current style is used.
3423 
3424         capsize : float, default: :rc:`errorbar.capsize`
3425             The length of the error bar caps in points.
3426 
3427         capthick : float, default: None
3428             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3429             This setting is a more sensible name for the property that
3430             controls the thickness of the error bar cap in points. For
3431             backwards compatibility, if *mew* or *markeredgewidth* are given,
3432             then they will over-ride *capthick*. This may change in future
3433             releases.
3434 
3435         barsabove : bool, default: False
3436             If True, will plot the errorbars above the plot
3437             symbols. Default is below.
3438 
3439         lolims, uplims, xlolims, xuplims : bool, default: False
3440             These arguments can be used to indicate that a value gives only
3441             upper/lower limits.  In that case a caret symbol is used to
3442             indicate this. *lims*-arguments may be scalars, or array-likes of
3443             the same length as *xerr* and *yerr*.  To use limits with inverted
3444             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3445             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3446             *lolims* to True means that the y-value is a *lower* limit of the
3447             True value, so, only an *upward*-pointing arrow will be drawn!
3448 
3449         errorevery : int or (int, int), default: 1
3450             draws error bars on a subset of the data. *errorevery* =N draws
3451             error bars on the points (x[::N], y[::N]).
3452             *errorevery* =(start, N) draws error bars on the points
3453             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3454             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3455             Used to avoid overlapping error bars when two series share x-axis
3456             values.
3457 
3458         Returns
3459         -------
3460         `.ErrorbarContainer`
3461             The container contains:
3462 
3463             - plotline: `~matplotlib.lines.Line2D` instance of x, y plot markers
3464               and/or line.
3465             - caplines: A tuple of `~matplotlib.lines.Line2D` instances of the error
3466               bar caps.
3467             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3468               vertical error ranges.
3469 
3470         Other Parameters
3471         ----------------
3472         data : indexable object, optional
3473             DATA_PARAMETER_PLACEHOLDER
3474 
3475         **kwargs
3476             All other keyword arguments are passed on to the `~.Axes.plot` call
3477             drawing the markers. For example, this code makes big red squares
3478             with thick green edges::
3479 
3480                 x, y, yerr = rand(3, 10)
3481                 errorbar(x, y, yerr, marker='s', mfc='red',
3482                          mec='green', ms=20, mew=4)
3483 
3484             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3485             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3486             and *markeredgewidth*.
3487 
3488             Valid kwargs for the marker properties are:
3489 
3490             - *dashes*
3491             - *dash_capstyle*
3492             - *dash_joinstyle*
3493             - *drawstyle*
3494             - *fillstyle*
3495             - *linestyle*
3496             - *marker*
3497             - *markeredgecolor*
3498             - *markeredgewidth*
3499             - *markerfacecolor*
3500             - *markerfacecoloralt*
3501             - *markersize*
3502             - *markevery*
3503             - *solid_capstyle*
3504             - *solid_joinstyle*
3505 
3506             Refer to the corresponding `.Line2D` property for more details:
3507 
3508             %(Line2D:kwdoc)s
3509         """
3510         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3511         # Drop anything that comes in as None to use the default instead.
3512         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3513         kwargs.setdefault('zorder', 2)
3514 
3515         # Casting to object arrays preserves units.
3516         if not isinstance(x, np.ndarray):
3517             x = np.asarray(x, dtype=object)
3518         if not isinstance(y, np.ndarray):
3519             y = np.asarray(y, dtype=object)
3520 
3521         def _upcast_err(err):
3522             """
3523             Safely handle tuple of containers that carry units.
3524 
3525             This function covers the case where the input to the xerr/yerr is a
3526             length 2 tuple of equal length ndarray-subclasses that carry the
3527             unit information in the container.
3528 
3529             If we have a tuple of nested numpy array (subclasses), we defer
3530             coercing the units to be consistent to the underlying unit
3531             library (and implicitly the broadcasting).
3532 
3533             Otherwise, fallback to casting to an object array.
3534             """
3535 
3536             if (
3537                     # make sure it is not a scalar
3538                     np.iterable(err) and
3539                     # and it is not empty
3540                     len(err) > 0 and
3541                     # and the first element is an array sub-class use
3542                     # safe_first_element because getitem is index-first not
3543                     # location first on pandas objects so err[0] almost always
3544                     # fails.
3545                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3546             ):
3547                 # Get the type of the first element
3548                 atype = type(cbook._safe_first_finite(err))
3549                 # Promote the outer container to match the inner container
3550                 if atype is np.ndarray:
3551                     # Converts using np.asarray, because data cannot
3552                     # be directly passed to init of np.ndarray
3553                     return np.asarray(err, dtype=object)
3554                 # If atype is not np.ndarray, directly pass data to init.
3555                 # This works for types such as unyts and astropy units
3556                 return atype(err)
3557             # Otherwise wrap it in an object array
3558             return np.asarray(err, dtype=object)
3559 
3560         if xerr is not None and not isinstance(xerr, np.ndarray):
3561             xerr = _upcast_err(xerr)
3562         if yerr is not None and not isinstance(yerr, np.ndarray):
3563             yerr = _upcast_err(yerr)
3564         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3565         if len(x) != len(y):
3566             raise ValueError("'x' and 'y' must have the same size")
3567 
3568         everymask = self._errorevery_to_mask(x, errorevery)
3569 
3570         label = kwargs.pop("label", None)
3571         kwargs['label'] = '_nolegend_'
3572 
3573         # Create the main line and determine overall kwargs for child artists.
3574         # We avoid calling self.plot() directly, or self._get_lines(), because
3575         # that would call self._process_unit_info again, and do other indirect
3576         # data processing.
3577         (data_line, base_style), = self._get_lines._plot_args(
3578             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3579 
3580         # Do this after creating `data_line` to avoid modifying `base_style`.
3581         if barsabove:
3582             data_line.set_zorder(kwargs['zorder'] - .1)
3583         else:
3584             data_line.set_zorder(kwargs['zorder'] + .1)
3585 
3586         # Add line to plot, or throw it away and use it to determine kwargs.
3587         if fmt.lower() != 'none':
3588             self.add_line(data_line)
3589         else:
3590             data_line = None
3591             # Remove alpha=0 color that _get_lines._plot_args returns for
3592             # 'none' format, and replace it with user-specified color, if
3593             # supplied.
3594             base_style.pop('color')
3595             if 'color' in kwargs:
3596                 base_style['color'] = kwargs.pop('color')
3597 
3598         if 'color' not in base_style:
3599             base_style['color'] = 'C0'
3600         if ecolor is None:
3601             ecolor = base_style['color']
3602 
3603         # Eject any line-specific information from format string, as it's not
3604         # needed for bars or caps.
3605         for key in ['marker', 'markersize', 'markerfacecolor',
3606                     'markerfacecoloralt',
3607                     'markeredgewidth', 'markeredgecolor', 'markevery',
3608                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3609                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3610                     'dashes']:
3611             base_style.pop(key, None)
3612 
3613         # Make the style dict for the line collections (the bars).
3614         eb_lines_style = {**base_style, 'color': ecolor}
3615 
3616         if elinewidth is not None:
3617             eb_lines_style['linewidth'] = elinewidth
3618         elif 'linewidth' in kwargs:
3619             eb_lines_style['linewidth'] = kwargs['linewidth']
3620 
3621         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3622             if key in kwargs:
3623                 eb_lines_style[key] = kwargs[key]
3624 
3625         # Make the style dict for caps (the "hats").
3626         eb_cap_style = {**base_style, 'linestyle': 'none'}
3627         if capsize is None:
3628             capsize = mpl.rcParams["errorbar.capsize"]
3629         if capsize > 0:
3630             eb_cap_style['markersize'] = 2. * capsize
3631         if capthick is not None:
3632             eb_cap_style['markeredgewidth'] = capthick
3633 
3634         # For backwards-compat, allow explicit setting of
3635         # 'markeredgewidth' to over-ride capthick.
3636         for key in ('markeredgewidth', 'transform', 'alpha',
3637                     'zorder', 'rasterized'):
3638             if key in kwargs:
3639                 eb_cap_style[key] = kwargs[key]
3640         eb_cap_style['color'] = ecolor
3641 
3642         barcols = []
3643         caplines = {'x': [], 'y': []}
3644 
3645         # Vectorized fancy-indexer.
3646         def apply_mask(arrays, mask):
3647             return [array[mask] for array in arrays]
3648 
3649         # dep: dependent dataset, indep: independent dataset
3650         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3651              marker, lomarker, himarker) in [
3652                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3653                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3654                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3655                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3656         ]:
3657             if err is None:
3658                 continue
3659             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3660             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3661             try:
3662                 np.broadcast_to(err, (2, len(dep)))
3663             except ValueError:
3664                 raise ValueError(
3665                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3666                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3667                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3668             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3669             if np.any(np.less(err, -err, out=res, where=(err == err))):
3670                 # like err<0, but also works for timedelta and nan.
3671                 raise ValueError(
3672                     f"'{dep_axis}err' must not contain negative values")
3673             # This is like
3674             #     elow, ehigh = np.broadcast_to(...)
3675             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3676             # except that broadcast_to would strip units.
3677             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3678             barcols.append(lines_func(
3679                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3680             if self.name == "polar" and dep_axis == "x":
3681                 for b in barcols:
3682                     for p in b.get_paths():
3683                         p._interpolation_steps = 2
3684             # Normal errorbars for points without upper/lower limits.
3685             nolims = ~(lolims | uplims)
3686             if nolims.any() and capsize > 0:
3687                 indep_masked, lo_masked, hi_masked = apply_mask(
3688                     [indep, low, high], nolims & everymask)
3689                 for lh_masked in [lo_masked, hi_masked]:
3690                     # Since this has to work for x and y as dependent data, we
3691                     # first set both x and y to the independent variable and
3692                     # overwrite the respective dependent data in a second step.
3693                     line = mlines.Line2D(indep_masked, indep_masked,
3694                                          marker=marker, **eb_cap_style)
3695                     line.set(**{f"{dep_axis}data": lh_masked})
3696                     caplines[dep_axis].append(line)
3697             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3698                 if not lims.any():
3699                     continue
3700                 hlmarker = (
3701                     himarker
3702                     if self._axis_map[dep_axis].get_inverted() ^ idx
3703                     else lomarker)
3704                 x_masked, y_masked, hl_masked = apply_mask(
3705                     [x, y, hl], lims & everymask)
3706                 # As above, we set the dependent data in a second step.
3707                 line = mlines.Line2D(x_masked, y_masked,
3708                                      marker=hlmarker, **eb_cap_style)
3709                 line.set(**{f"{dep_axis}data": hl_masked})
3710                 caplines[dep_axis].append(line)
3711                 if capsize > 0:
3712                     caplines[dep_axis].append(mlines.Line2D(
3713                         x_masked, y_masked, marker=marker, **eb_cap_style))
3714         if self.name == 'polar':
3715             for axis in caplines:
3716                 for l in caplines[axis]:
3717                     # Rotate caps to be perpendicular to the error bars
3718                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3719                         rotation = mtransforms.Affine2D().rotate(theta)
3720                         if axis == 'y':
3721                             rotation.rotate(-np.pi / 2)
3722                         ms = mmarkers.MarkerStyle(marker=marker,
3723                                                   transform=rotation)
3724                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3725                                                     **eb_cap_style))
3726         else:
3727             for axis in caplines:
3728                 for l in caplines[axis]:
3729                     self.add_line(l)
3730 
3731         self._request_autoscale_view()
3732         caplines = caplines['x'] + caplines['y']
3733         errorbar_container = ErrorbarContainer(
3734             (data_line, tuple(caplines), tuple(barcols)),
3735             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3736             label=label)
3737         self.containers.append(errorbar_container)
3738 
3739         return errorbar_container  # (l0, caplines, barcols)
3740 
3741     @_preprocess_data()
3742     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3743                 positions=None, widths=None, patch_artist=None,
3744                 bootstrap=None, usermedians=None, conf_intervals=None,
3745                 meanline=None, showmeans=None, showcaps=None,
3746                 showbox=None, showfliers=None, boxprops=None,
3747                 labels=None, flierprops=None, medianprops=None,
3748                 meanprops=None, capprops=None, whiskerprops=None,
3749                 manage_ticks=True, autorange=False, zorder=None,
3750                 capwidths=None):
3751         """
3752         Draw a box and whisker plot.
3753 
3754         The box extends from the first quartile (Q1) to the third
3755         quartile (Q3) of the data, with a line at the median.
3756         The whiskers extend from the box to the farthest data point
3757         lying within 1.5x the inter-quartile range (IQR) from the box.
3758         Flier points are those past the end of the whiskers.
3759         See https://en.wikipedia.org/wiki/Box_plot for reference.
3760 
3761         .. code-block:: none
3762 
3763                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3764                                |-----:-----|
3765                o      |--------|     :     |--------|    o  o
3766                                |-----:-----|
3767              flier             <----------->            fliers
3768                                     IQR
3769 
3770 
3771         Parameters
3772         ----------
3773         x : Array or a sequence of vectors.
3774             The input data.  If a 2D array, a boxplot is drawn for each column
3775             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3776             array in *x*.
3777 
3778         notch : bool, default: False
3779             Whether to draw a notched boxplot (`True`), or a rectangular
3780             boxplot (`False`).  The notches represent the confidence interval
3781             (CI) around the median.  The documentation for *bootstrap*
3782             describes how the locations of the notches are computed by
3783             default, but their locations may also be overridden by setting the
3784             *conf_intervals* parameter.
3785 
3786             .. note::
3787 
3788                 In cases where the values of the CI are less than the
3789                 lower quartile or greater than the upper quartile, the
3790                 notches will extend beyond the box, giving it a
3791                 distinctive "flipped" appearance. This is expected
3792                 behavior and consistent with other statistical
3793                 visualization packages.
3794 
3795         sym : str, optional
3796             The default symbol for flier points.  An empty string ('') hides
3797             the fliers.  If `None`, then the fliers default to 'b+'.  More
3798             control is provided by the *flierprops* parameter.
3799 
3800         vert : bool, default: True
3801             If `True`, draws vertical boxes.
3802             If `False`, draw horizontal boxes.
3803 
3804         whis : float or (float, float), default: 1.5
3805             The position of the whiskers.
3806 
3807             If a float, the lower whisker is at the lowest datum above
3808             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3809             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3810             third quartiles.  The default value of ``whis = 1.5`` corresponds
3811             to Tukey's original definition of boxplots.
3812 
3813             If a pair of floats, they indicate the percentiles at which to
3814             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3815             (0, 100) results in whiskers covering the whole range of the data.
3816 
3817             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3818             to (0, 100) (cover the whole range of the data) if *autorange* is
3819             True.
3820 
3821             Beyond the whiskers, data are considered outliers and are plotted
3822             as individual points.
3823 
3824         bootstrap : int, optional
3825             Specifies whether to bootstrap the confidence intervals
3826             around the median for notched boxplots. If *bootstrap* is
3827             None, no bootstrapping is performed, and notches are
3828             calculated using a Gaussian-based asymptotic approximation
3829             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3830             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3831             the number of times to bootstrap the median to determine its
3832             95% confidence intervals. Values between 1000 and 10000 are
3833             recommended.
3834 
3835         usermedians : 1D array-like, optional
3836             A 1D array-like of length ``len(x)``.  Each entry that is not
3837             `None` forces the value of the median for the corresponding
3838             dataset.  For entries that are `None`, the medians are computed
3839             by Matplotlib as normal.
3840 
3841         conf_intervals : array-like, optional
3842             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3843             None forces the location of the corresponding notch (which is
3844             only drawn if *notch* is `True`).  For entries that are `None`,
3845             the notches are computed by the method specified by the other
3846             parameters (e.g., *bootstrap*).
3847 
3848         positions : array-like, optional
3849             The positions of the boxes. The ticks and limits are
3850             automatically set to match the positions. Defaults to
3851             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3852 
3853         widths : float or array-like
3854             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3855             between extreme positions)``, if that is smaller.
3856 
3857         patch_artist : bool, default: False
3858             If `False` produces boxes with the Line2D artist. Otherwise,
3859             boxes are drawn with Patch artists.
3860 
3861         labels : sequence, optional
3862             Labels for each dataset (one per dataset).
3863 
3864         manage_ticks : bool, default: True
3865             If True, the tick locations and labels will be adjusted to match
3866             the boxplot positions.
3867 
3868         autorange : bool, default: False
3869             When `True` and the data are distributed such that the 25th and
3870             75th percentiles are equal, *whis* is set to (0, 100) such
3871             that the whisker ends are at the minimum and maximum of the data.
3872 
3873         meanline : bool, default: False
3874             If `True` (and *showmeans* is `True`), will try to render the
3875             mean as a line spanning the full width of the box according to
3876             *meanprops* (see below).  Not recommended if *shownotches* is also
3877             True.  Otherwise, means will be shown as points.
3878 
3879         zorder : float, default: ``Line2D.zorder = 2``
3880             The zorder of the boxplot.
3881 
3882         Returns
3883         -------
3884         dict
3885           A dictionary mapping each component of the boxplot to a list
3886           of the `.Line2D` instances created. That dictionary has the
3887           following keys (assuming vertical boxplots):
3888 
3889           - ``boxes``: the main body of the boxplot showing the
3890             quartiles and the median's confidence intervals if
3891             enabled.
3892 
3893           - ``medians``: horizontal lines at the median of each box.
3894 
3895           - ``whiskers``: the vertical lines extending to the most
3896             extreme, non-outlier data points.
3897 
3898           - ``caps``: the horizontal lines at the ends of the
3899             whiskers.
3900 
3901           - ``fliers``: points representing data that extend beyond
3902             the whiskers (fliers).
3903 
3904           - ``means``: points or lines representing the means.
3905 
3906         Other Parameters
3907         ----------------
3908         showcaps : bool, default: True
3909             Show the caps on the ends of whiskers.
3910         showbox : bool, default: True
3911             Show the central box.
3912         showfliers : bool, default: True
3913             Show the outliers beyond the caps.
3914         showmeans : bool, default: False
3915             Show the arithmetic means.
3916         capprops : dict, default: None
3917             The style of the caps.
3918         capwidths : float or array, default: None
3919             The widths of the caps.
3920         boxprops : dict, default: None
3921             The style of the box.
3922         whiskerprops : dict, default: None
3923             The style of the whiskers.
3924         flierprops : dict, default: None
3925             The style of the fliers.
3926         medianprops : dict, default: None
3927             The style of the median.
3928         meanprops : dict, default: None
3929             The style of the mean.
3930         data : indexable object, optional
3931             DATA_PARAMETER_PLACEHOLDER
3932 
3933         See Also
3934         --------
3935         violinplot : Draw an estimate of the probability density function.
3936         """
3937 
3938         # Missing arguments default to rcParams.
3939         if whis is None:
3940             whis = mpl.rcParams['boxplot.whiskers']
3941         if bootstrap is None:
3942             bootstrap = mpl.rcParams['boxplot.bootstrap']
3943 
3944         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3945                                        labels=labels, autorange=autorange)
3946         if notch is None:
3947             notch = mpl.rcParams['boxplot.notch']
3948         if vert is None:
3949             vert = mpl.rcParams['boxplot.vertical']
3950         if patch_artist is None:
3951             patch_artist = mpl.rcParams['boxplot.patchartist']
3952         if meanline is None:
3953             meanline = mpl.rcParams['boxplot.meanline']
3954         if showmeans is None:
3955             showmeans = mpl.rcParams['boxplot.showmeans']
3956         if showcaps is None:
3957             showcaps = mpl.rcParams['boxplot.showcaps']
3958         if showbox is None:
3959             showbox = mpl.rcParams['boxplot.showbox']
3960         if showfliers is None:
3961             showfliers = mpl.rcParams['boxplot.showfliers']
3962 
3963         if boxprops is None:
3964             boxprops = {}
3965         if whiskerprops is None:
3966             whiskerprops = {}
3967         if capprops is None:
3968             capprops = {}
3969         if medianprops is None:
3970             medianprops = {}
3971         if meanprops is None:
3972             meanprops = {}
3973         if flierprops is None:
3974             flierprops = {}
3975 
3976         if patch_artist:
3977             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3978             if 'color' in boxprops:
3979                 boxprops['edgecolor'] = boxprops.pop('color')
3980 
3981         # if non-default sym value, put it into the flier dictionary
3982         # the logic for providing the default symbol ('b+') now lives
3983         # in bxp in the initial value of flierkw
3984         # handle all of the *sym* related logic here so we only have to pass
3985         # on the flierprops dict.
3986         if sym is not None:
3987             # no-flier case, which should really be done with
3988             # 'showfliers=False' but none-the-less deal with it to keep back
3989             # compatibility
3990             if sym == '':
3991                 # blow away existing dict and make one for invisible markers
3992                 flierprops = dict(linestyle='none', marker='', color='none')
3993                 # turn the fliers off just to be safe
3994                 showfliers = False
3995             # now process the symbol string
3996             else:
3997                 # process the symbol string
3998                 # discarded linestyle
3999                 _, marker, color = _process_plot_format(sym)
4000                 # if we have a marker, use it
4001                 if marker is not None:
4002                     flierprops['marker'] = marker
4003                 # if we have a color, use it
4004                 if color is not None:
4005                     # assume that if color is passed in the user want
4006                     # filled symbol, if the users want more control use
4007                     # flierprops
4008                     flierprops['color'] = color
4009                     flierprops['markerfacecolor'] = color
4010                     flierprops['markeredgecolor'] = color
4011 
4012         # replace medians if necessary:
4013         if usermedians is not None:
4014             if (len(np.ravel(usermedians)) != len(bxpstats) or
4015                     np.shape(usermedians)[0] != len(bxpstats)):
4016                 raise ValueError(
4017                     "'usermedians' and 'x' have different lengths")
4018             else:
4019                 # reassign medians as necessary
4020                 for stats, med in zip(bxpstats, usermedians):
4021                     if med is not None:
4022                         stats['med'] = med
4023 
4024         if conf_intervals is not None:
4025             if len(conf_intervals) != len(bxpstats):
4026                 raise ValueError(
4027                     "'conf_intervals' and 'x' have different lengths")
4028             else:
4029                 for stats, ci in zip(bxpstats, conf_intervals):
4030                     if ci is not None:
4031                         if len(ci) != 2:
4032                             raise ValueError('each confidence interval must '
4033                                              'have two values')
4034                         else:
4035                             if ci[0] is not None:
4036                                 stats['cilo'] = ci[0]
4037                             if ci[1] is not None:
4038                                 stats['cihi'] = ci[1]
4039 
4040         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4041                            vert=vert, patch_artist=patch_artist,
4042                            shownotches=notch, showmeans=showmeans,
4043                            showcaps=showcaps, showbox=showbox,
4044                            boxprops=boxprops, flierprops=flierprops,
4045                            medianprops=medianprops, meanprops=meanprops,
4046                            meanline=meanline, showfliers=showfliers,
4047                            capprops=capprops, whiskerprops=whiskerprops,
4048                            manage_ticks=manage_ticks, zorder=zorder,
4049                            capwidths=capwidths)
4050         return artists
4051 
4052     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4053             patch_artist=False, shownotches=False, showmeans=False,
4054             showcaps=True, showbox=True, showfliers=True,
4055             boxprops=None, whiskerprops=None, flierprops=None,
4056             medianprops=None, capprops=None, meanprops=None,
4057             meanline=False, manage_ticks=True, zorder=None,
4058             capwidths=None):
4059         """
4060         Drawing function for box and whisker plots.
4061 
4062         Make a box and whisker plot for each column of *x* or each
4063         vector in sequence *x*.  The box extends from the lower to
4064         upper quartile values of the data, with a line at the median.
4065         The whiskers extend from the box to show the range of the
4066         data.  Flier points are those past the end of the whiskers.
4067 
4068         Parameters
4069         ----------
4070         bxpstats : list of dicts
4071           A list of dictionaries containing stats for each boxplot.
4072           Required keys are:
4073 
4074           - ``med``: Median (scalar).
4075           - ``q1``, ``q3``: First & third quartiles (scalars).
4076           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4077 
4078           Optional keys are:
4079 
4080           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4081           - ``fliers``: Data beyond the whiskers (array-like).
4082             Needed if ``showfliers=True``.
4083           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4084             about the median. Needed if ``shownotches=True``.
4085           - ``label``: Name of the dataset (str).  If available,
4086             this will be used a tick label for the boxplot
4087 
4088         positions : array-like, default: [1, 2, ..., n]
4089           The positions of the boxes. The ticks and limits
4090           are automatically set to match the positions.
4091 
4092         widths : float or array-like, default: None
4093           The widths of the boxes.  The default is
4094           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4095 
4096         capwidths : float or array-like, default: None
4097           Either a scalar or a vector and sets the width of each cap.
4098           The default is ``0.5*(with of the box)``, see *widths*.
4099 
4100         vert : bool, default: True
4101           If `True` (default), makes the boxes vertical.
4102           If `False`, makes horizontal boxes.
4103 
4104         patch_artist : bool, default: False
4105           If `False` produces boxes with the `.Line2D` artist.
4106           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4107 
4108         shownotches, showmeans, showcaps, showbox, showfliers : bool
4109           Whether to draw the CI notches, the mean value (both default to
4110           False), the caps, the box, and the fliers (all three default to
4111           True).
4112 
4113         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4114  dict, optional
4115           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4116           means.
4117 
4118         meanline : bool, default: False
4119           If `True` (and *showmeans* is `True`), will try to render the mean
4120           as a line spanning the full width of the box according to
4121           *meanprops*. Not recommended if *shownotches* is also True.
4122           Otherwise, means will be shown as points.
4123 
4124         manage_ticks : bool, default: True
4125           If True, the tick locations and labels will be adjusted to match the
4126           boxplot positions.
4127 
4128         zorder : float, default: ``Line2D.zorder = 2``
4129           The zorder of the resulting boxplot.
4130 
4131         Returns
4132         -------
4133         dict
4134           A dictionary mapping each component of the boxplot to a list
4135           of the `.Line2D` instances created. That dictionary has the
4136           following keys (assuming vertical boxplots):
4137 
4138           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4139             the median's confidence intervals if enabled.
4140           - ``medians``: horizontal lines at the median of each box.
4141           - ``whiskers``: vertical lines up to the last non-outlier data.
4142           - ``caps``: horizontal lines at the ends of the whiskers.
4143           - ``fliers``: points representing data beyond the whiskers (fliers).
4144           - ``means``: points or lines representing the means.
4145 
4146         Examples
4147         --------
4148         .. plot:: gallery/statistics/bxp.py
4149         """
4150 
4151         # lists of artists to be output
4152         whiskers = []
4153         caps = []
4154         boxes = []
4155         medians = []
4156         means = []
4157         fliers = []
4158 
4159         # empty list of xticklabels
4160         datalabels = []
4161 
4162         # Use default zorder if none specified
4163         if zorder is None:
4164             zorder = mlines.Line2D.zorder
4165 
4166         zdelta = 0.1
4167 
4168         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4169             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4170                  if k.startswith(f'boxplot.{subkey}props')}
4171             d['zorder'] = zorder + zdelta
4172             if not usemarker:
4173                 d['marker'] = ''
4174             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4175             return d
4176 
4177         box_kw = {
4178             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4179             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4180             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4181             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4182                           else mpl.rcParams['patch.facecolor']),
4183             'zorder': zorder,
4184             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4185         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4186         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4187         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4188         flier_kw = merge_kw_rc('flier', flierprops)
4189         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4190         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4191         removed_prop = 'marker' if meanline else 'linestyle'
4192         # Only remove the property if it's not set explicitly as a parameter.
4193         if meanprops is None or removed_prop not in meanprops:
4194             mean_kw[removed_prop] = ''
4195 
4196         # vertical or horizontal plot?
4197         maybe_swap = slice(None) if vert else slice(None, None, -1)
4198 
4199         def do_plot(xs, ys, **kwargs):
4200             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4201 
4202         def do_patch(xs, ys, **kwargs):
4203             path = mpath.Path._create_closed(
4204                 np.column_stack([xs, ys][maybe_swap]))
4205             patch = mpatches.PathPatch(path, **kwargs)
4206             self.add_artist(patch)
4207             return patch
4208 
4209         # input validation
4210         N = len(bxpstats)
4211         datashape_message = ("List of boxplot statistics and `{0}` "
4212                              "values must have same the length")
4213         # check position
4214         if positions is None:
4215             positions = list(range(1, N + 1))
4216         elif len(positions) != N:
4217             raise ValueError(datashape_message.format("positions"))
4218 
4219         positions = np.array(positions)
4220         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4221             raise TypeError("positions should be an iterable of numbers")
4222 
4223         # width
4224         if widths is None:
4225             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4226         elif np.isscalar(widths):
4227             widths = [widths] * N
4228         elif len(widths) != N:
4229             raise ValueError(datashape_message.format("widths"))
4230 
4231         # capwidth
4232         if capwidths is None:
4233             capwidths = 0.5 * np.array(widths)
4234         elif np.isscalar(capwidths):
4235             capwidths = [capwidths] * N
4236         elif len(capwidths) != N:
4237             raise ValueError(datashape_message.format("capwidths"))
4238 
4239         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4240                                                capwidths):
4241             # try to find a new label
4242             datalabels.append(stats.get('label', pos))
4243 
4244             # whisker coords
4245             whis_x = [pos, pos]
4246             whislo_y = [stats['q1'], stats['whislo']]
4247             whishi_y = [stats['q3'], stats['whishi']]
4248             # cap coords
4249             cap_left = pos - capwidth * 0.5
4250             cap_right = pos + capwidth * 0.5
4251             cap_x = [cap_left, cap_right]
4252             cap_lo = np.full(2, stats['whislo'])
4253             cap_hi = np.full(2, stats['whishi'])
4254             # box and median coords
4255             box_left = pos - width * 0.5
4256             box_right = pos + width * 0.5
4257             med_y = [stats['med'], stats['med']]
4258             # notched boxes
4259             if shownotches:
4260                 notch_left = pos - width * 0.25
4261                 notch_right = pos + width * 0.25
4262                 box_x = [box_left, box_right, box_right, notch_right,
4263                          box_right, box_right, box_left, box_left, notch_left,
4264                          box_left, box_left]
4265                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4266                          stats['med'], stats['cihi'], stats['q3'],
4267                          stats['q3'], stats['cihi'], stats['med'],
4268                          stats['cilo'], stats['q1']]
4269                 med_x = [notch_left, notch_right]
4270             # plain boxes
4271             else:
4272                 box_x = [box_left, box_right, box_right, box_left, box_left]
4273                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4274                          stats['q1']]
4275                 med_x = [box_left, box_right]
4276 
4277             # maybe draw the box
4278             if showbox:
4279                 do_box = do_patch if patch_artist else do_plot
4280                 boxes.append(do_box(box_x, box_y, **box_kw))
4281             # draw the whiskers
4282             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4283             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4284             # maybe draw the caps
4285             if showcaps:
4286                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4287                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4288             # draw the medians
4289             medians.append(do_plot(med_x, med_y, **median_kw))
4290             # maybe draw the means
4291             if showmeans:
4292                 if meanline:
4293                     means.append(do_plot(
4294                         [box_left, box_right], [stats['mean'], stats['mean']],
4295                         **mean_kw
4296                     ))
4297                 else:
4298                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4299             # maybe draw the fliers
4300             if showfliers:
4301                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4302                 flier_y = stats['fliers']
4303                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4304 
4305         if manage_ticks:
4306             axis_name = "x" if vert else "y"
4307             interval = getattr(self.dataLim, f"interval{axis_name}")
4308             axis = self._axis_map[axis_name]
4309             positions = axis.convert_units(positions)
4310             # The 0.5 additional padding ensures reasonable-looking boxes
4311             # even when drawing a single box.  We set the sticky edge to
4312             # prevent margins expansion, in order to match old behavior (back
4313             # when separate calls to boxplot() would completely reset the axis
4314             # limits regardless of what was drawn before).  The sticky edges
4315             # are attached to the median lines, as they are always present.
4316             interval[:] = (min(interval[0], min(positions) - .5),
4317                            max(interval[1], max(positions) + .5))
4318             for median, position in zip(medians, positions):
4319                 getattr(median.sticky_edges, axis_name).extend(
4320                     [position - .5, position + .5])
4321             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4322             locator = axis.get_major_locator()
4323             if not isinstance(axis.get_major_locator(),
4324                               mticker.FixedLocator):
4325                 locator = mticker.FixedLocator([])
4326                 axis.set_major_locator(locator)
4327             locator.locs = np.array([*locator.locs, *positions])
4328             formatter = axis.get_major_formatter()
4329             if not isinstance(axis.get_major_formatter(),
4330                               mticker.FixedFormatter):
4331                 formatter = mticker.FixedFormatter([])
4332                 axis.set_major_formatter(formatter)
4333             formatter.seq = [*formatter.seq, *datalabels]
4334 
4335             self._request_autoscale_view()
4336 
4337         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4338                     medians=medians, fliers=fliers, means=means)
4339 
4340     @staticmethod
4341     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4342                                   get_next_color_func):
4343         """
4344         Helper function to process color related arguments of `.Axes.scatter`.
4345 
4346         Argument precedence for facecolors:
4347 
4348         - c (if not None)
4349         - kwargs['facecolor']
4350         - kwargs['facecolors']
4351         - kwargs['color'] (==kwcolor)
4352         - 'b' if in classic mode else the result of ``get_next_color_func()``
4353 
4354         Argument precedence for edgecolors:
4355 
4356         - kwargs['edgecolor']
4357         - edgecolors (is an explicit kw argument in scatter())
4358         - kwargs['color'] (==kwcolor)
4359         - 'face' if not in classic mode else None
4360 
4361         Parameters
4362         ----------
4363         c : color or sequence or sequence of color or None
4364             See argument description of `.Axes.scatter`.
4365         edgecolors : color or sequence of color or {'face', 'none'} or None
4366             See argument description of `.Axes.scatter`.
4367         kwargs : dict
4368             Additional kwargs. If these keys exist, we pop and process them:
4369             'facecolors', 'facecolor', 'edgecolor', 'color'
4370             Note: The dict is modified by this function.
4371         xsize : int
4372             The size of the x and y arrays passed to `.Axes.scatter`.
4373         get_next_color_func : callable
4374             A callable that returns a color. This color is used as facecolor
4375             if no other color is provided.
4376 
4377             Note, that this is a function rather than a fixed color value to
4378             support conditional evaluation of the next color.  As of the
4379             current implementation obtaining the next color from the
4380             property cycle advances the cycle. This must only happen if we
4381             actually use the color, which will only be decided within this
4382             method.
4383 
4384         Returns
4385         -------
4386         c
4387             The input *c* if it was not *None*, else a color derived from the
4388             other inputs or defaults.
4389         colors : array(N, 4) or None
4390             The facecolors as RGBA values, or *None* if a colormap is used.
4391         edgecolors
4392             The edgecolor.
4393 
4394         """
4395         facecolors = kwargs.pop('facecolors', None)
4396         facecolors = kwargs.pop('facecolor', facecolors)
4397         edgecolors = kwargs.pop('edgecolor', edgecolors)
4398 
4399         kwcolor = kwargs.pop('color', None)
4400 
4401         if kwcolor is not None and c is not None:
4402             raise ValueError("Supply a 'c' argument or a 'color'"
4403                              " kwarg but not both; they differ but"
4404                              " their functionalities overlap.")
4405 
4406         if kwcolor is not None:
4407             try:
4408                 mcolors.to_rgba_array(kwcolor)
4409             except ValueError as err:
4410                 raise ValueError(
4411                     "'color' kwarg must be a color or sequence of color "
4412                     "specs.  For a sequence of values to be color-mapped, use "
4413                     "the 'c' argument instead.") from err
4414             if edgecolors is None:
4415                 edgecolors = kwcolor
4416             if facecolors is None:
4417                 facecolors = kwcolor
4418 
4419         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4420             edgecolors = mpl.rcParams['scatter.edgecolors']
4421 
4422         c_was_none = c is None
4423         if c is None:
4424             c = (facecolors if facecolors is not None
4425                  else "b" if mpl.rcParams['_internal.classic_mode']
4426                  else get_next_color_func())
4427         c_is_string_or_strings = (
4428             isinstance(c, str)
4429             or (np.iterable(c) and len(c) > 0
4430                 and isinstance(cbook._safe_first_finite(c), str)))
4431 
4432         def invalid_shape_exception(csize, xsize):
4433             return ValueError(
4434                 f"'c' argument has {csize} elements, which is inconsistent "
4435                 f"with 'x' and 'y' with size {xsize}.")
4436 
4437         c_is_mapped = False  # Unless proven otherwise below.
4438         valid_shape = True  # Unless proven otherwise below.
4439         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4440             try:  # First, does 'c' look suitable for value-mapping?
4441                 c = np.asanyarray(c, dtype=float)
4442             except ValueError:
4443                 pass  # Failed to convert to float array; must be color specs.
4444             else:
4445                 # handle the documented special case of a 2D array with 1
4446                 # row which as RGB(A) to broadcast.
4447                 if c.shape == (1, 4) or c.shape == (1, 3):
4448                     c_is_mapped = False
4449                     if c.size != xsize:
4450                         valid_shape = False
4451                 # If c can be either mapped values or an RGB(A) color, prefer
4452                 # the former if shapes match, the latter otherwise.
4453                 elif c.size == xsize:
4454                     c = c.ravel()
4455                     c_is_mapped = True
4456                 else:  # Wrong size; it must not be intended for mapping.
4457                     if c.shape in ((3,), (4,)):
4458                         _api.warn_external(
4459                             "*c* argument looks like a single numeric RGB or "
4460                             "RGBA sequence, which should be avoided as value-"
4461                             "mapping will have precedence in case its length "
4462                             "matches with *x* & *y*.  Please use the *color* "
4463                             "keyword-argument or provide a 2D array "
4464                             "with a single row if you intend to specify "
4465                             "the same RGB or RGBA value for all points.")
4466                     valid_shape = False
4467         if not c_is_mapped:
4468             try:  # Is 'c' acceptable as PathCollection facecolors?
4469                 colors = mcolors.to_rgba_array(c)
4470             except (TypeError, ValueError) as err:
4471                 if "RGBA values should be within 0-1 range" in str(err):
4472                     raise
4473                 else:
4474                     if not valid_shape:
4475                         raise invalid_shape_exception(c.size, xsize) from err
4476                     # Both the mapping *and* the RGBA conversion failed: pretty
4477                     # severe failure => one may appreciate a verbose feedback.
4478                     raise ValueError(
4479                         f"'c' argument must be a color, a sequence of colors, "
4480                         f"or a sequence of numbers, not {c!r}") from err
4481             else:
4482                 if len(colors) not in (0, 1, xsize):
4483                     # NB: remember that a single color is also acceptable.
4484                     # Besides *colors* will be an empty array if c == 'none'.
4485                     raise invalid_shape_exception(len(colors), xsize)
4486         else:
4487             colors = None  # use cmap, norm after collection is created
4488         return c, colors, edgecolors
4489 
4490     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4491                                      "edgecolors", "c", "facecolor",
4492                                      "facecolors", "color"],
4493                       label_namer="y")
4494     @_docstring.interpd
4495     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4496                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4497                 edgecolors=None, plotnonfinite=False, **kwargs):
4498         """
4499         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4500 
4501         Parameters
4502         ----------
4503         x, y : float or array-like, shape (n, )
4504             The data positions.
4505 
4506         s : float or array-like, shape (n, ), optional
4507             The marker size in points**2 (typographic points are 1/72 in.).
4508             Default is ``rcParams['lines.markersize'] ** 2``.
4509 
4510             The linewidth and edgecolor can visually interact with the marker
4511             size, and can lead to artifacts if the marker size is smaller than
4512             the linewidth.
4513 
4514             If the linewidth is greater than 0 and the edgecolor is anything
4515             but *'none'*, then the effective size of the marker will be
4516             increased by half the linewidth because the stroke will be centered
4517             on the edge of the shape.
4518 
4519             To eliminate the marker edge either set *linewidth=0* or
4520             *edgecolor='none'*.
4521 
4522         c : array-like or list of colors or color, optional
4523             The marker colors. Possible values:
4524 
4525             - A scalar or sequence of n numbers to be mapped to colors using
4526               *cmap* and *norm*.
4527             - A 2D array in which the rows are RGB or RGBA.
4528             - A sequence of colors of length n.
4529             - A single color format string.
4530 
4531             Note that *c* should not be a single numeric RGB or RGBA sequence
4532             because that is indistinguishable from an array of values to be
4533             colormapped. If you want to specify the same RGB or RGBA value for
4534             all points, use a 2D array with a single row.  Otherwise,
4535             value-matching will have precedence in case of a size matching with
4536             *x* and *y*.
4537 
4538             If you wish to specify a single color for all points
4539             prefer the *color* keyword argument.
4540 
4541             Defaults to `None`. In that case the marker color is determined
4542             by the value of *color*, *facecolor* or *facecolors*. In case
4543             those are not specified or `None`, the marker color is determined
4544             by the next color of the ``Axes``' current "shape and fill" color
4545             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4546 
4547         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4548             The marker style. *marker* can be either an instance of the class
4549             or the text shorthand for a particular marker.
4550             See :mod:`matplotlib.markers` for more information about marker
4551             styles.
4552 
4553         %(cmap_doc)s
4554 
4555             This parameter is ignored if *c* is RGB(A).
4556 
4557         %(norm_doc)s
4558 
4559             This parameter is ignored if *c* is RGB(A).
4560 
4561         %(vmin_vmax_doc)s
4562 
4563             This parameter is ignored if *c* is RGB(A).
4564 
4565         alpha : float, default: None
4566             The alpha blending value, between 0 (transparent) and 1 (opaque).
4567 
4568         linewidths : float or array-like, default: :rc:`lines.linewidth`
4569             The linewidth of the marker edges. Note: The default *edgecolors*
4570             is 'face'. You may want to change this as well.
4571 
4572         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4573 default: :rc:`scatter.edgecolors`
4574             The edge color of the marker. Possible values:
4575 
4576             - 'face': The edge color will always be the same as the face color.
4577             - 'none': No patch boundary will be drawn.
4578             - A color or sequence of colors.
4579 
4580             For non-filled markers, *edgecolors* is ignored. Instead, the color
4581             is determined like with 'face', i.e. from *c*, *colors*, or
4582             *facecolors*.
4583 
4584         plotnonfinite : bool, default: False
4585             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4586             or ``nan``). If ``True`` the points are drawn with the *bad*
4587             colormap color (see `.Colormap.set_bad`).
4588 
4589         Returns
4590         -------
4591         `~matplotlib.collections.PathCollection`
4592 
4593         Other Parameters
4594         ----------------
4595         data : indexable object, optional
4596             DATA_PARAMETER_PLACEHOLDER
4597         **kwargs : `~matplotlib.collections.Collection` properties
4598 
4599         See Also
4600         --------
4601         plot : To plot scatter plots when markers are identical in size and
4602             color.
4603 
4604         Notes
4605         -----
4606         * The `.plot` function will be faster for scatterplots where markers
4607           don't vary in size or color.
4608 
4609         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4610           case all masks will be combined and only unmasked points will be
4611           plotted.
4612 
4613         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4614           may be input as N-D arrays, but within scatter they will be
4615           flattened. The exception is *c*, which will be flattened only if its
4616           size matches the size of *x* and *y*.
4617 
4618         """
4619         # add edgecolors and linewidths to kwargs so they
4620         # can be processed by normailze_kwargs
4621         if edgecolors is not None:
4622             kwargs.update({'edgecolors': edgecolors})
4623         if linewidths is not None:
4624             kwargs.update({'linewidths': linewidths})
4625 
4626         kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
4627         # re direct linewidth and edgecolor so it can be
4628         # further processed by the rest of the function
4629         linewidths = kwargs.pop('linewidth', None)
4630         edgecolors = kwargs.pop('edgecolor', None)
4631         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4632         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4633         # np.ma.ravel yields an ndarray, not a masked array,
4634         # unless its argument is a masked array.
4635         x = np.ma.ravel(x)
4636         y = np.ma.ravel(y)
4637         if x.size != y.size:
4638             raise ValueError("x and y must be the same size")
4639 
4640         if s is None:
4641             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4642                  mpl.rcParams['lines.markersize'] ** 2.0)
4643         s = np.ma.ravel(s)
4644         if (len(s) not in (1, x.size) or
4645                 (not np.issubdtype(s.dtype, np.floating) and
4646                  not np.issubdtype(s.dtype, np.integer))):
4647             raise ValueError(
4648                 "s must be a scalar, "
4649                 "or float array-like with the same size as x and y")
4650 
4651         # get the original edgecolor the user passed before we normalize
4652         orig_edgecolor = edgecolors
4653         if edgecolors is None:
4654             orig_edgecolor = kwargs.get('edgecolor', None)
4655         c, colors, edgecolors = \
4656             self._parse_scatter_color_args(
4657                 c, edgecolors, kwargs, x.size,
4658                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4659 
4660         if plotnonfinite and colors is None:
4661             c = np.ma.masked_invalid(c)
4662             x, y, s, edgecolors, linewidths = \
4663                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4664         else:
4665             x, y, s, c, colors, edgecolors, linewidths = \
4666                 cbook._combine_masks(
4667                     x, y, s, c, colors, edgecolors, linewidths)
4668         # Unmask edgecolors if it was actually a single RGB or RGBA.
4669         if (x.size in (3, 4)
4670                 and np.ma.is_masked(edgecolors)
4671                 and not np.ma.is_masked(orig_edgecolor)):
4672             edgecolors = edgecolors.data
4673 
4674         scales = s   # Renamed for readability below.
4675 
4676         # load default marker from rcParams
4677         if marker is None:
4678             marker = mpl.rcParams['scatter.marker']
4679 
4680         if isinstance(marker, mmarkers.MarkerStyle):
4681             marker_obj = marker
4682         else:
4683             marker_obj = mmarkers.MarkerStyle(marker)
4684 
4685         path = marker_obj.get_path().transformed(
4686             marker_obj.get_transform())
4687         if not marker_obj.is_filled():
4688             if orig_edgecolor is not None:
4689                 _api.warn_external(
4690                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4691                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4692                     "ignoring the edgecolor in favor of the facecolor.  This "
4693                     "behavior may change in the future."
4694                 )
4695             # We need to handle markers that cannot be filled (like
4696             # '+' and 'x') differently than markers that can be
4697             # filled, but have their fillstyle set to 'none'.  This is
4698             # to get:
4699             #
4700             #  - respecting the fillestyle if set
4701             #  - maintaining back-compatibility for querying the facecolor of
4702             #    the un-fillable markers.
4703             #
4704             # While not an ideal situation, but is better than the
4705             # alternatives.
4706             if marker_obj.get_fillstyle() == 'none':
4707                 # promote the facecolor to be the edgecolor
4708                 edgecolors = colors
4709                 # set the facecolor to 'none' (at the last chance) because
4710                 # we cannot fill a path if the facecolor is non-null
4711                 # (which is defendable at the renderer level).
4712                 colors = 'none'
4713             else:
4714                 # if we are not nulling the face color we can do this
4715                 # simpler
4716                 edgecolors = 'face'
4717 
4718             if linewidths is None:
4719                 linewidths = mpl.rcParams['lines.linewidth']
4720             elif np.iterable(linewidths):
4721                 linewidths = [
4722                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4723                     for lw in linewidths]
4724 
4725         offsets = np.ma.column_stack([x, y])
4726 
4727         collection = mcoll.PathCollection(
4728             (path,), scales,
4729             facecolors=colors,
4730             edgecolors=edgecolors,
4731             linewidths=linewidths,
4732             offsets=offsets,
4733             offset_transform=kwargs.pop('transform', self.transData),
4734             alpha=alpha,
4735         )
4736         collection.set_transform(mtransforms.IdentityTransform())
4737         if colors is None:
4738             collection.set_array(c)
4739             collection.set_cmap(cmap)
4740             collection.set_norm(norm)
4741             collection._scale_norm(norm, vmin, vmax)
4742         else:
4743             extra_kwargs = {
4744                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4745                     }
4746             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4747             if any(extra_keys):
4748                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4749                 _api.warn_external(
4750                     "No data for colormapping provided via 'c'. "
4751                     f"Parameters {keys_str} will be ignored")
4752         collection._internal_update(kwargs)
4753 
4754         # Classic mode only:
4755         # ensure there are margins to allow for the
4756         # finite size of the symbols.  In v2.x, margins
4757         # are present by default, so we disable this
4758         # scatter-specific override.
4759         if mpl.rcParams['_internal.classic_mode']:
4760             if self._xmargin < 0.05 and x.size > 0:
4761                 self.set_xmargin(0.05)
4762             if self._ymargin < 0.05 and x.size > 0:
4763                 self.set_ymargin(0.05)
4764 
4765         self.add_collection(collection)
4766         self._request_autoscale_view()
4767 
4768         return collection
4769 
4770     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4771     @_docstring.dedent_interpd
4772     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4773                xscale='linear', yscale='linear', extent=None,
4774                cmap=None, norm=None, vmin=None, vmax=None,
4775                alpha=None, linewidths=None, edgecolors='face',
4776                reduce_C_function=np.mean, mincnt=None, marginals=False,
4777                **kwargs):
4778         """
4779         Make a 2D hexagonal binning plot of points *x*, *y*.
4780 
4781         If *C* is *None*, the value of the hexagon is determined by the number
4782         of points in the hexagon. Otherwise, *C* specifies values at the
4783         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4784         using *reduce_C_function*.
4785 
4786         Parameters
4787         ----------
4788         x, y : array-like
4789             The data positions. *x* and *y* must be of the same length.
4790 
4791         C : array-like, optional
4792             If given, these values are accumulated in the bins. Otherwise,
4793             every point has a value of 1. Must be of the same length as *x*
4794             and *y*.
4795 
4796         gridsize : int or (int, int), default: 100
4797             If a single int, the number of hexagons in the *x*-direction.
4798             The number of hexagons in the *y*-direction is chosen such that
4799             the hexagons are approximately regular.
4800 
4801             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4802             in the *x*-direction and the *y*-direction. In the
4803             *y*-direction, counting is done along vertically aligned
4804             hexagons, not along the zig-zag chains of hexagons; see the
4805             following illustration.
4806 
4807             .. plot::
4808 
4809                import numpy
4810                import matplotlib.pyplot as plt
4811 
4812                np.random.seed(19680801)
4813                n= 300
4814                x = np.random.standard_normal(n)
4815                y = np.random.standard_normal(n)
4816 
4817                fig, ax = plt.subplots(figsize=(4, 4))
4818                h = ax.hexbin(x, y, gridsize=(5, 3))
4819                hx, hy = h.get_offsets().T
4820                ax.plot(hx[24::3], hy[24::3], 'ro-')
4821                ax.plot(hx[-3:], hy[-3:], 'ro-')
4822                ax.set_title('gridsize=(5, 3)')
4823                ax.axis('off')
4824 
4825             To get approximately regular hexagons, choose
4826             :math:`n_x = \\sqrt{3}\\,n_y`.
4827 
4828         bins : 'log' or int or sequence, default: None
4829             Discretization of the hexagon values.
4830 
4831             - If *None*, no binning is applied; the color of each hexagon
4832               directly corresponds to its count value.
4833             - If 'log', use a logarithmic scale for the colormap.
4834               Internally, :math:`log_{10}(i+1)` is used to determine the
4835               hexagon color. This is equivalent to ``norm=LogNorm()``.
4836             - If an integer, divide the counts in the specified number
4837               of bins, and color the hexagons accordingly.
4838             - If a sequence of values, the values of the lower bound of
4839               the bins to be used.
4840 
4841         xscale : {'linear', 'log'}, default: 'linear'
4842             Use a linear or log10 scale on the horizontal axis.
4843 
4844         yscale : {'linear', 'log'}, default: 'linear'
4845             Use a linear or log10 scale on the vertical axis.
4846 
4847         mincnt : int > 0, default: *None*
4848             If not *None*, only display cells with more than *mincnt*
4849             number of points in the cell.
4850 
4851         marginals : bool, default: *False*
4852             If marginals is *True*, plot the marginal density as
4853             colormapped rectangles along the bottom of the x-axis and
4854             left of the y-axis.
4855 
4856         extent : 4-tuple of float, default: *None*
4857             The limits of the bins (xmin, xmax, ymin, ymax).
4858             The default assigns the limits based on
4859             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4860 
4861             If *xscale* or *yscale* is set to 'log', the limits are
4862             expected to be the exponent for a power of 10. E.g. for
4863             x-limits of 1 and 50 in 'linear' scale and y-limits
4864             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4865 
4866         Returns
4867         -------
4868         `~matplotlib.collections.PolyCollection`
4869             A `.PolyCollection` defining the hexagonal bins.
4870 
4871             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4872               the x, y positions of the M hexagon centers.
4873             - `.PolyCollection.get_array` contains the values of the M
4874               hexagons.
4875 
4876             If *marginals* is *True*, horizontal
4877             bar and vertical bar (both PolyCollections) will be attached
4878             to the return collection as attributes *hbar* and *vbar*.
4879 
4880         Other Parameters
4881         ----------------
4882         %(cmap_doc)s
4883 
4884         %(norm_doc)s
4885 
4886         %(vmin_vmax_doc)s
4887 
4888         alpha : float between 0 and 1, optional
4889             The alpha blending value, between 0 (transparent) and 1 (opaque).
4890 
4891         linewidths : float, default: *None*
4892             If *None*, defaults to :rc:`patch.linewidth`.
4893 
4894         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4895             The color of the hexagon edges. Possible values are:
4896 
4897             - 'face': Draw the edges in the same color as the fill color.
4898             - 'none': No edges are drawn. This can sometimes lead to unsightly
4899               unpainted pixels between the hexagons.
4900             - *None*: Draw outlines in the default color.
4901             - An explicit color.
4902 
4903         reduce_C_function : callable, default: `numpy.mean`
4904             The function to aggregate *C* within the bins. It is ignored if
4905             *C* is not given. This must have the signature::
4906 
4907                 def reduce_C_function(C: array) -> float
4908 
4909             Commonly used functions are:
4910 
4911             - `numpy.mean`: average of the points
4912             - `numpy.sum`: integral of the point values
4913             - `numpy.amax`: value taken from the largest point
4914 
4915         data : indexable object, optional
4916             DATA_PARAMETER_PLACEHOLDER
4917 
4918         **kwargs : `~matplotlib.collections.PolyCollection` properties
4919             All other keyword arguments are passed on to `.PolyCollection`:
4920 
4921             %(PolyCollection:kwdoc)s
4922 
4923         See Also
4924         --------
4925         hist2d : 2D histogram rectangular bins
4926         """
4927         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4928 
4929         x, y, C = cbook.delete_masked_points(x, y, C)
4930 
4931         # Set the size of the hexagon grid
4932         if np.iterable(gridsize):
4933             nx, ny = gridsize
4934         else:
4935             nx = gridsize
4936             ny = int(nx / math.sqrt(3))
4937         # Count the number of data in each hexagon
4938         x = np.asarray(x, float)
4939         y = np.asarray(y, float)
4940 
4941         # Will be log()'d if necessary, and then rescaled.
4942         tx = x
4943         ty = y
4944 
4945         if xscale == 'log':
4946             if np.any(x <= 0.0):
4947                 raise ValueError(
4948                     "x contains non-positive values, so cannot be log-scaled")
4949             tx = np.log10(tx)
4950         if yscale == 'log':
4951             if np.any(y <= 0.0):
4952                 raise ValueError(
4953                     "y contains non-positive values, so cannot be log-scaled")
4954             ty = np.log10(ty)
4955         if extent is not None:
4956             xmin, xmax, ymin, ymax = extent
4957         else:
4958             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4959             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4960 
4961             # to avoid issues with singular data, expand the min/max pairs
4962             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4963             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4964 
4965         nx1 = nx + 1
4966         ny1 = ny + 1
4967         nx2 = nx
4968         ny2 = ny
4969         n = nx1 * ny1 + nx2 * ny2
4970 
4971         # In the x-direction, the hexagons exactly cover the region from
4972         # xmin to xmax. Need some padding to avoid roundoff errors.
4973         padding = 1.e-9 * (xmax - xmin)
4974         xmin -= padding
4975         xmax += padding
4976         sx = (xmax - xmin) / nx
4977         sy = (ymax - ymin) / ny
4978         # Positions in hexagon index coordinates.
4979         ix = (tx - xmin) / sx
4980         iy = (ty - ymin) / sy
4981         ix1 = np.round(ix).astype(int)
4982         iy1 = np.round(iy).astype(int)
4983         ix2 = np.floor(ix).astype(int)
4984         iy2 = np.floor(iy).astype(int)
4985         # flat indices, plus one so that out-of-range points go to position 0.
4986         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4987                       ix1 * ny1 + iy1 + 1, 0)
4988         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4989                       ix2 * ny2 + iy2 + 1, 0)
4990 
4991         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4992         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4993         bdist = (d1 < d2)
4994 
4995         if C is None:  # [1:] drops out-of-range points.
4996             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4997             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4998             accum = np.concatenate([counts1, counts2]).astype(float)
4999             if mincnt is not None:
5000                 accum[accum < mincnt] = np.nan
5001             C = np.ones(len(x))
5002         else:
5003             # store the C values in a list per hexagon index
5004             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
5005             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
5006             for i in range(len(x)):
5007                 if bdist[i]:
5008                     Cs_at_i1[i1[i]].append(C[i])
5009                 else:
5010                     Cs_at_i2[i2[i]].append(C[i])
5011             if mincnt is None:
5012                 mincnt = 0
5013             accum = np.array(
5014                 [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
5015                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
5016                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
5017                 float)
5018 
5019         good_idxs = ~np.isnan(accum)
5020 
5021         offsets = np.zeros((n, 2), float)
5022         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
5023         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
5024         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
5025         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
5026         offsets[:, 0] *= sx
5027         offsets[:, 1] *= sy
5028         offsets[:, 0] += xmin
5029         offsets[:, 1] += ymin
5030         # remove accumulation bins with no data
5031         offsets = offsets[good_idxs, :]
5032         accum = accum[good_idxs]
5033 
5034         polygon = [sx, sy / 3] * np.array(
5035             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5036 
5037         if linewidths is None:
5038             linewidths = [mpl.rcParams['patch.linewidth']]
5039 
5040         if xscale == 'log' or yscale == 'log':
5041             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5042             if xscale == 'log':
5043                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5044                 xmin = 10.0 ** xmin
5045                 xmax = 10.0 ** xmax
5046                 self.set_xscale(xscale)
5047             if yscale == 'log':
5048                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5049                 ymin = 10.0 ** ymin
5050                 ymax = 10.0 ** ymax
5051                 self.set_yscale(yscale)
5052             collection = mcoll.PolyCollection(
5053                 polygons,
5054                 edgecolors=edgecolors,
5055                 linewidths=linewidths,
5056                 )
5057         else:
5058             collection = mcoll.PolyCollection(
5059                 [polygon],
5060                 edgecolors=edgecolors,
5061                 linewidths=linewidths,
5062                 offsets=offsets,
5063                 offset_transform=mtransforms.AffineDeltaTransform(
5064                     self.transData),
5065             )
5066 
5067         # Set normalizer if bins is 'log'
5068         if bins == 'log':
5069             if norm is not None:
5070                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5071                                    f"can be supplied, ignoring bins={bins}")
5072             else:
5073                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5074                 vmin = vmax = None
5075             bins = None
5076 
5077         # autoscale the norm with current accum values if it hasn't been set
5078         if norm is not None:
5079             if norm.vmin is None and norm.vmax is None:
5080                 norm.autoscale(accum)
5081 
5082         if bins is not None:
5083             if not np.iterable(bins):
5084                 minimum, maximum = min(accum), max(accum)
5085                 bins -= 1  # one less edge than bins
5086                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5087             bins = np.sort(bins)
5088             accum = bins.searchsorted(accum)
5089 
5090         collection.set_array(accum)
5091         collection.set_cmap(cmap)
5092         collection.set_norm(norm)
5093         collection.set_alpha(alpha)
5094         collection._internal_update(kwargs)
5095         collection._scale_norm(norm, vmin, vmax)
5096 
5097         corners = ((xmin, ymin), (xmax, ymax))
5098         self.update_datalim(corners)
5099         self._request_autoscale_view(tight=True)
5100 
5101         # add the collection last
5102         self.add_collection(collection, autolim=False)
5103         if not marginals:
5104             return collection
5105 
5106         # Process marginals
5107         bars = []
5108         for zname, z, zmin, zmax, zscale, nbins in [
5109                 ("x", x, xmin, xmax, xscale, nx),
5110                 ("y", y, ymin, ymax, yscale, 2 * ny),
5111         ]:
5112 
5113             if zscale == "log":
5114                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5115             else:
5116                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5117 
5118             verts = np.empty((nbins, 4, 2))
5119             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5120             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5121             verts[:, 0, 1] = verts[:, 3, 1] = .00
5122             verts[:, 1, 1] = verts[:, 2, 1] = .05
5123             if zname == "y":
5124                 verts = verts[:, :, ::-1]  # Swap x and y.
5125 
5126             # Sort z-values into bins defined by bin_edges.
5127             bin_idxs = np.searchsorted(bin_edges, z) - 1
5128             values = np.empty(nbins)
5129             for i in range(nbins):
5130                 # Get C-values for each bin, and compute bin value with
5131                 # reduce_C_function.
5132                 ci = C[bin_idxs == i]
5133                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5134 
5135             mask = ~np.isnan(values)
5136             verts = verts[mask]
5137             values = values[mask]
5138 
5139             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5140             bar = mcoll.PolyCollection(
5141                 verts, transform=trans, edgecolors="face")
5142             bar.set_array(values)
5143             bar.set_cmap(cmap)
5144             bar.set_norm(norm)
5145             bar.set_alpha(alpha)
5146             bar._internal_update(kwargs)
5147             bars.append(self.add_collection(bar, autolim=False))
5148 
5149         collection.hbar, collection.vbar = bars
5150 
5151         def on_changed(collection):
5152             collection.hbar.set_cmap(collection.get_cmap())
5153             collection.hbar.set_cmap(collection.get_cmap())
5154             collection.vbar.set_clim(collection.get_clim())
5155             collection.vbar.set_clim(collection.get_clim())
5156 
5157         collection.callbacks.connect('changed', on_changed)
5158 
5159         return collection
5160 
5161     @_docstring.dedent_interpd
5162     def arrow(self, x, y, dx, dy, **kwargs):
5163         """
5164         Add an arrow to the Axes.
5165 
5166         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5167 
5168         Parameters
5169         ----------
5170         %(FancyArrow)s
5171 
5172         Returns
5173         -------
5174         `.FancyArrow`
5175             The created `.FancyArrow` object.
5176 
5177         Notes
5178         -----
5179         The resulting arrow is affected by the Axes aspect ratio and limits.
5180         This may produce an arrow whose head is not square with its stem. To
5181         create an arrow whose head is square with its stem,
5182         use :meth:`annotate` for example:
5183 
5184         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5185         ...             arrowprops=dict(arrowstyle="->"))
5186 
5187         """
5188         # Strip away units for the underlying patch since units
5189         # do not make sense to most patch-like code
5190         x = self.convert_xunits(x)
5191         y = self.convert_yunits(y)
5192         dx = self.convert_xunits(dx)
5193         dy = self.convert_yunits(dy)
5194 
5195         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5196         self.add_patch(a)
5197         self._request_autoscale_view()
5198         return a
5199 
5200     @_docstring.copy(mquiver.QuiverKey.__init__)
5201     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5202         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5203         self.add_artist(qk)
5204         return qk
5205 
5206     # Handle units for x and y, if they've been passed
5207     def _quiver_units(self, args, kwargs):
5208         if len(args) > 3:
5209             x, y = args[0:2]
5210             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5211             return (x, y) + args[2:]
5212         return args
5213 
5214     # args can be a combination of X, Y, U, V, C and all should be replaced
5215     @_preprocess_data()
5216     @_docstring.dedent_interpd
5217     def quiver(self, *args, **kwargs):
5218         """%(quiver_doc)s"""
5219         # Make sure units are handled for x and y values
5220         args = self._quiver_units(args, kwargs)
5221         q = mquiver.Quiver(self, *args, **kwargs)
5222         self.add_collection(q, autolim=True)
5223         self._request_autoscale_view()
5224         return q
5225 
5226     # args can be some combination of X, Y, U, V, C and all should be replaced
5227     @_preprocess_data()
5228     @_docstring.dedent_interpd
5229     def barbs(self, *args, **kwargs):
5230         """%(barbs_doc)s"""
5231         # Make sure units are handled for x and y values
5232         args = self._quiver_units(args, kwargs)
5233         b = mquiver.Barbs(self, *args, **kwargs)
5234         self.add_collection(b, autolim=True)
5235         self._request_autoscale_view()
5236         return b
5237 
5238     # Uses a custom implementation of data-kwarg handling in
5239     # _process_plot_var_args.
5240     def fill(self, *args, data=None, **kwargs):
5241         """
5242         Plot filled polygons.
5243 
5244         Parameters
5245         ----------
5246         *args : sequence of x, y, [color]
5247             Each polygon is defined by the lists of *x* and *y* positions of
5248             its nodes, optionally followed by a *color* specifier. See
5249             :mod:`matplotlib.colors` for supported color specifiers. The
5250             standard color cycle is used for polygons without a color
5251             specifier.
5252 
5253             You can plot multiple polygons by providing multiple *x*, *y*,
5254             *[color]* groups.
5255 
5256             For example, each of the following is legal::
5257 
5258                 ax.fill(x, y)                    # a polygon with default color
5259                 ax.fill(x, y, "b")               # a blue polygon
5260                 ax.fill(x, y, x2, y2)            # two polygons
5261                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5262 
5263         data : indexable object, optional
5264             An object with labelled data. If given, provide the label names to
5265             plot in *x* and *y*, e.g.::
5266 
5267                 ax.fill("time", "signal",
5268                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5269 
5270         Returns
5271         -------
5272         list of `~matplotlib.patches.Polygon`
5273 
5274         Other Parameters
5275         ----------------
5276         **kwargs : `~matplotlib.patches.Polygon` properties
5277 
5278         Notes
5279         -----
5280         Use :meth:`fill_between` if you would like to fill the region between
5281         two curves.
5282         """
5283         # For compatibility(!), get aliases from Line2D rather than Patch.
5284         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5285         # _get_patches_for_fill returns a generator, convert it to a list.
5286         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5287         for poly in patches:
5288             self.add_patch(poly)
5289         self._request_autoscale_view()
5290         return patches
5291 
5292     def _fill_between_x_or_y(
5293             self, ind_dir, ind, dep1, dep2=0, *,
5294             where=None, interpolate=False, step=None, **kwargs):
5295         # Common implementation between fill_between (*ind_dir*="x") and
5296         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5297         # *dep* the dependent variable.  The docstring below is interpolated
5298         # to generate both methods' docstrings.
5299         """
5300         Fill the area between two {dir} curves.
5301 
5302         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5303         *{dep}2*).  This creates one or multiple polygons describing the filled
5304         area.
5305 
5306         You may exclude some {dir} sections from filling using *where*.
5307 
5308         By default, the edges connect the given points directly.  Use *step*
5309         if the filling should be a step function, i.e. constant in between
5310         *{ind}*.
5311 
5312         Parameters
5313         ----------
5314         {ind} : array (length N)
5315             The {ind} coordinates of the nodes defining the curves.
5316 
5317         {dep}1 : array (length N) or scalar
5318             The {dep} coordinates of the nodes defining the first curve.
5319 
5320         {dep}2 : array (length N) or scalar, default: 0
5321             The {dep} coordinates of the nodes defining the second curve.
5322 
5323         where : array of bool (length N), optional
5324             Define *where* to exclude some {dir} regions from being filled.
5325             The filled regions are defined by the coordinates ``{ind}[where]``.
5326             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5327             ``where[i] and where[i+1]``.  Note that this definition implies
5328             that an isolated *True* value between two *False* values in *where*
5329             will not result in filling.  Both sides of the *True* position
5330             remain unfilled due to the adjacent *False* values.
5331 
5332         interpolate : bool, default: False
5333             This option is only relevant if *where* is used and the two curves
5334             are crossing each other.
5335 
5336             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5337             similar.  By default, the nodes of the polygon defining the filled
5338             region will only be placed at the positions in the *{ind}* array.
5339             Such a polygon cannot describe the above semantics close to the
5340             intersection.  The {ind}-sections containing the intersection are
5341             simply clipped.
5342 
5343             Setting *interpolate* to *True* will calculate the actual
5344             intersection point and extend the filled region up to this point.
5345 
5346         step : {{'pre', 'post', 'mid'}}, optional
5347             Define *step* if the filling should be a step function,
5348             i.e. constant in between *{ind}*.  The value determines where the
5349             step will occur:
5350 
5351             - 'pre': The y value is continued constantly to the left from
5352               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5353               value ``y[i]``.
5354             - 'post': The y value is continued constantly to the right from
5355               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5356               value ``y[i]``.
5357             - 'mid': Steps occur half-way between the *x* positions.
5358 
5359         Returns
5360         -------
5361         `.PolyCollection`
5362             A `.PolyCollection` containing the plotted polygons.
5363 
5364         Other Parameters
5365         ----------------
5366         data : indexable object, optional
5367             DATA_PARAMETER_PLACEHOLDER
5368 
5369         **kwargs
5370             All other keyword arguments are passed on to `.PolyCollection`.
5371             They control the `.Polygon` properties:
5372 
5373             %(PolyCollection:kwdoc)s
5374 
5375         See Also
5376         --------
5377         fill_between : Fill between two sets of y-values.
5378         fill_betweenx : Fill between two sets of x-values.
5379         """
5380 
5381         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5382 
5383         if not mpl.rcParams["_internal.classic_mode"]:
5384             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5385             if not any(c in kwargs for c in ("color", "facecolor")):
5386                 kwargs["facecolor"] = \
5387                     self._get_patches_for_fill.get_next_color()
5388 
5389         # Handle united data, such as dates
5390         ind, dep1, dep2 = map(
5391             ma.masked_invalid, self._process_unit_info(
5392                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5393 
5394         for name, array in [
5395                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5396             if array.ndim > 1:
5397                 raise ValueError(f"{name!r} is not 1-dimensional")
5398 
5399         if where is None:
5400             where = True
5401         else:
5402             where = np.asarray(where, dtype=bool)
5403             if where.size != ind.size:
5404                 raise ValueError(f"where size ({where.size}) does not match "
5405                                  f"{ind_dir} size ({ind.size})")
5406         where = where & ~functools.reduce(
5407             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5408 
5409         ind, dep1, dep2 = np.broadcast_arrays(
5410             np.atleast_1d(ind), dep1, dep2, subok=True)
5411 
5412         polys = []
5413         for idx0, idx1 in cbook.contiguous_regions(where):
5414             indslice = ind[idx0:idx1]
5415             dep1slice = dep1[idx0:idx1]
5416             dep2slice = dep2[idx0:idx1]
5417             if step is not None:
5418                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5419                 indslice, dep1slice, dep2slice = \
5420                     step_func(indslice, dep1slice, dep2slice)
5421 
5422             if not len(indslice):
5423                 continue
5424 
5425             N = len(indslice)
5426             pts = np.zeros((2 * N + 2, 2))
5427 
5428             if interpolate:
5429                 def get_interp_point(idx):
5430                     im1 = max(idx - 1, 0)
5431                     ind_values = ind[im1:idx+1]
5432                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5433                     dep1_values = dep1[im1:idx+1]
5434 
5435                     if len(diff_values) == 2:
5436                         if np.ma.is_masked(diff_values[1]):
5437                             return ind[im1], dep1[im1]
5438                         elif np.ma.is_masked(diff_values[0]):
5439                             return ind[idx], dep1[idx]
5440 
5441                     diff_order = diff_values.argsort()
5442                     diff_root_ind = np.interp(
5443                         0, diff_values[diff_order], ind_values[diff_order])
5444                     ind_order = ind_values.argsort()
5445                     diff_root_dep = np.interp(
5446                         diff_root_ind,
5447                         ind_values[ind_order], dep1_values[ind_order])
5448                     return diff_root_ind, diff_root_dep
5449 
5450                 start = get_interp_point(idx0)
5451                 end = get_interp_point(idx1)
5452             else:
5453                 # Handle scalar dep2 (e.g. 0): the fill should go all
5454                 # the way down to 0 even if none of the dep1 sample points do.
5455                 start = indslice[0], dep2slice[0]
5456                 end = indslice[-1], dep2slice[-1]
5457 
5458             pts[0] = start
5459             pts[N + 1] = end
5460 
5461             pts[1:N+1, 0] = indslice
5462             pts[1:N+1, 1] = dep1slice
5463             pts[N+2:, 0] = indslice[::-1]
5464             pts[N+2:, 1] = dep2slice[::-1]
5465 
5466             if ind_dir == "y":
5467                 pts = pts[:, ::-1]
5468 
5469             polys.append(pts)
5470 
5471         collection = mcoll.PolyCollection(polys, **kwargs)
5472 
5473         # now update the datalim and autoscale
5474         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5475                             np.column_stack([ind[where], dep2[where]])])
5476         if ind_dir == "y":
5477             pts = pts[:, ::-1]
5478 
5479         up_x = up_y = True
5480         if "transform" in kwargs:
5481             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5482         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5483 
5484         self.add_collection(collection, autolim=False)
5485         self._request_autoscale_view()
5486         return collection
5487 
5488     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5489                      step=None, **kwargs):
5490         return self._fill_between_x_or_y(
5491             "x", x, y1, y2,
5492             where=where, interpolate=interpolate, step=step, **kwargs)
5493 
5494     if _fill_between_x_or_y.__doc__:
5495         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5496             dir="horizontal", ind="x", dep="y"
5497         )
5498     fill_between = _preprocess_data(
5499         _docstring.dedent_interpd(fill_between),
5500         replace_names=["x", "y1", "y2", "where"])
5501 
5502     def fill_betweenx(self, y, x1, x2=0, where=None,
5503                       step=None, interpolate=False, **kwargs):
5504         return self._fill_between_x_or_y(
5505             "y", y, x1, x2,
5506             where=where, interpolate=interpolate, step=step, **kwargs)
5507 
5508     if _fill_between_x_or_y.__doc__:
5509         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5510             dir="vertical", ind="y", dep="x"
5511         )
5512     fill_betweenx = _preprocess_data(
5513         _docstring.dedent_interpd(fill_betweenx),
5514         replace_names=["y", "x1", "x2", "where"])
5515 
5516     #### plotting z(x, y): imshow, pcolor and relatives, contour
5517 
5518     @_preprocess_data()
5519     @_docstring.interpd
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im
5742 
5743     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5744         # - create X and Y if not present;
5745         # - reshape X and Y as needed if they are 1-D;
5746         # - check for proper sizes based on `shading` kwarg;
5747         # - reset shading if shading='auto' to flat or nearest
5748         #   depending on size;
5749 
5750         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5751         try:
5752             _api.check_in_list(_valid_shading, shading=shading)
5753         except ValueError:
5754             _api.warn_external(f"shading value '{shading}' not in list of "
5755                                f"valid values {_valid_shading}. Setting "
5756                                "shading='auto'.")
5757             shading = 'auto'
5758 
5759         if len(args) == 1:
5760             C = np.asanyarray(args[0])
5761             nrows, ncols = C.shape[:2]
5762             if shading in ['gouraud', 'nearest']:
5763                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5764             else:
5765                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5766                 shading = 'flat'
5767             C = cbook.safe_masked_invalid(C, copy=True)
5768             return X, Y, C, shading
5769 
5770         if len(args) == 3:
5771             # Check x and y for bad data...
5772             C = np.asanyarray(args[2])
5773             # unit conversion allows e.g. datetime objects as axis values
5774             X, Y = args[:2]
5775             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5776             X, Y = [cbook.safe_masked_invalid(a, copy=True) for a in [X, Y]]
5777 
5778             if funcname == 'pcolormesh':
5779                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5780                     raise ValueError(
5781                         'x and y arguments to pcolormesh cannot have '
5782                         'non-finite values or be of type '
5783                         'numpy.ma.MaskedArray with masked values')
5784             nrows, ncols = C.shape[:2]
5785         else:
5786             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5787 
5788         Nx = X.shape[-1]
5789         Ny = Y.shape[0]
5790         if X.ndim != 2 or X.shape[0] == 1:
5791             x = X.reshape(1, Nx)
5792             X = x.repeat(Ny, axis=0)
5793         if Y.ndim != 2 or Y.shape[1] == 1:
5794             y = Y.reshape(Ny, 1)
5795             Y = y.repeat(Nx, axis=1)
5796         if X.shape != Y.shape:
5797             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5798                             f'see help({funcname})')
5799 
5800         if shading == 'auto':
5801             if ncols == Nx and nrows == Ny:
5802                 shading = 'nearest'
5803             else:
5804                 shading = 'flat'
5805 
5806         if shading == 'flat':
5807             if (Nx, Ny) != (ncols + 1, nrows + 1):
5808                 raise TypeError(f"Dimensions of C {C.shape} should"
5809                                 f" be one smaller than X({Nx}) and Y({Ny})"
5810                                 f" while using shading='flat'"
5811                                 f" see help({funcname})")
5812         else:    # ['nearest', 'gouraud']:
5813             if (Nx, Ny) != (ncols, nrows):
5814                 raise TypeError('Dimensions of C %s are incompatible with'
5815                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5816                                     C.shape, Nx, Ny, funcname))
5817             if shading == 'nearest':
5818                 # grid is specified at the center, so define corners
5819                 # at the midpoints between the grid centers and then use the
5820                 # flat algorithm.
5821                 def _interp_grid(X):
5822                     # helper for below
5823                     if np.shape(X)[1] > 1:
5824                         dX = np.diff(X, axis=1)/2.
5825                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5826                             _api.warn_external(
5827                                 f"The input coordinates to {funcname} are "
5828                                 "interpreted as cell centers, but are not "
5829                                 "monotonically increasing or decreasing. "
5830                                 "This may lead to incorrectly calculated cell "
5831                                 "edges, in which case, please supply "
5832                                 f"explicit cell edges to {funcname}.")
5833 
5834                         hstack = np.ma.hstack if np.ma.isMA(X) else np.hstack
5835                         X = hstack((X[:, [0]] - dX[:, [0]],
5836                                     X[:, :-1] + dX,
5837                                     X[:, [-1]] + dX[:, [-1]]))
5838                     else:
5839                         # This is just degenerate, but we can't reliably guess
5840                         # a dX if there is just one value.
5841                         X = np.hstack((X, X))
5842                     return X
5843 
5844                 if ncols == Nx:
5845                     X = _interp_grid(X)
5846                     Y = _interp_grid(Y)
5847                 if nrows == Ny:
5848                     X = _interp_grid(X.T).T
5849                     Y = _interp_grid(Y.T).T
5850                 shading = 'flat'
5851 
5852         C = cbook.safe_masked_invalid(C, copy=True)
5853         return X, Y, C, shading
5854 
5855     @_preprocess_data()
5856     @_docstring.dedent_interpd
5857     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5858                vmin=None, vmax=None, **kwargs):
5859         r"""
5860         Create a pseudocolor plot with a non-regular rectangular grid.
5861 
5862         Call signature::
5863 
5864             pcolor([X, Y,] C, **kwargs)
5865 
5866         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5867 
5868         .. hint::
5869 
5870             ``pcolor()`` can be very slow for large arrays. In most
5871             cases you should use the similar but much faster
5872             `~.Axes.pcolormesh` instead. See
5873             :ref:`Differences between pcolor() and pcolormesh()
5874             <differences-pcolor-pcolormesh>` for a discussion of the
5875             differences.
5876 
5877         Parameters
5878         ----------
5879         C : 2D array-like
5880             The color-mapped values.  Color-mapping is controlled by *cmap*,
5881             *norm*, *vmin*, and *vmax*.
5882 
5883         X, Y : array-like, optional
5884             The coordinates of the corners of quadrilaterals of a pcolormesh::
5885 
5886                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5887                                       ●╶───╴●
5888                                       │     │
5889                                       ●╶───╴●
5890                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5891 
5892             Note that the column index corresponds to the x-coordinate, and
5893             the row index corresponds to y. For details, see the
5894             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5895 
5896             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5897             greater than those of *C*, and the quadrilateral is colored due
5898             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5899             dimensions, a warning will be raised and the last row and column
5900             of *C* will be ignored.
5901 
5902             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5903             the same as those of *C* (if not, a ValueError will be raised). The
5904             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5905 
5906             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5907             expanded as needed into the appropriate 2D arrays, making a
5908             rectangular grid.
5909 
5910         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5911             The fill style for the quadrilateral. Possible values:
5912 
5913             - 'flat': A solid color is used for each quad. The color of the
5914               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5915               ``C[i, j]``. The dimensions of *X* and *Y* should be
5916               one greater than those of *C*; if they are the same as *C*,
5917               then a deprecation warning is raised, and the last row
5918               and column of *C* are dropped.
5919             - 'nearest': Each grid point will have a color centered on it,
5920               extending halfway between the adjacent grid centers.  The
5921               dimensions of *X* and *Y* must be the same as *C*.
5922             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5923               larger than *C*.  Choose 'nearest' if dimensions are the same.
5924 
5925             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5926             for more description.
5927 
5928         %(cmap_doc)s
5929 
5930         %(norm_doc)s
5931 
5932         %(vmin_vmax_doc)s
5933 
5934         edgecolors : {'none', None, 'face', color, color sequence}, optional
5935             The color of the edges. Defaults to 'none'. Possible values:
5936 
5937             - 'none' or '': No edge.
5938             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5939               :rc:`patch.force_edgecolor` has to be True for this to work.
5940             - 'face': Use the adjacent face color.
5941             - A color or sequence of colors will set the edge color.
5942 
5943             The singular form *edgecolor* works as an alias.
5944 
5945         alpha : float, default: None
5946             The alpha blending value of the face color, between 0 (transparent)
5947             and 1 (opaque). Note: The edgecolor is currently not affected by
5948             this.
5949 
5950         snap : bool, default: False
5951             Whether to snap the mesh to pixel boundaries.
5952 
5953         Returns
5954         -------
5955         `matplotlib.collections.PolyQuadMesh`
5956 
5957         Other Parameters
5958         ----------------
5959         antialiaseds : bool, default: False
5960             The default *antialiaseds* is False if the default
5961             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5962             at patch boundaries, and works regardless of the value of alpha.
5963             If *edgecolors* is not "none", then the default *antialiaseds*
5964             is taken from :rc:`patch.antialiased`.
5965             Stroking the edges may be preferred if *alpha* is 1, but will
5966             cause artifacts otherwise.
5967 
5968         data : indexable object, optional
5969             DATA_PARAMETER_PLACEHOLDER
5970 
5971         **kwargs
5972             Additionally, the following arguments are allowed. They are passed
5973             along to the `~matplotlib.collections.PolyQuadMesh` constructor:
5974 
5975         %(PolyCollection:kwdoc)s
5976 
5977         See Also
5978         --------
5979         pcolormesh : for an explanation of the differences between
5980             pcolor and pcolormesh.
5981         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5982             faster alternative.
5983 
5984         Notes
5985         -----
5986         **Masked arrays**
5987 
5988         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5989         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5990         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5991         plotted.
5992 
5993         .. _axes-pcolor-grid-orientation:
5994 
5995         **Grid orientation**
5996 
5997         The grid orientation follows the standard matrix convention: An array
5998         *C* with shape (nrows, ncolumns) is plotted with the column number as
5999         *X* and the row number as *Y*.
6000         """
6001 
6002         if shading is None:
6003             shading = mpl.rcParams['pcolor.shading']
6004         shading = shading.lower()
6005         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
6006                                             kwargs=kwargs)
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiaseds' in kwargs:
6021             kwargs['antialiased'] = kwargs.pop('antialiaseds')
6022         if 'antialiased' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiased'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         if np.ma.isMaskedArray(X) or np.ma.isMaskedArray(Y):
6028             stack = np.ma.stack
6029             X = np.ma.asarray(X)
6030             Y = np.ma.asarray(Y)
6031             # For bounds collections later
6032             x = X.compressed()
6033             y = Y.compressed()
6034         else:
6035             stack = np.stack
6036             x = X
6037             y = Y
6038         coords = stack([X, Y], axis=-1)
6039 
6040         collection = mcoll.PolyQuadMesh(
6041             coords, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6042         collection._scale_norm(norm, vmin, vmax)
6043 
6044         # Transform from native to data coordinates?
6045         t = collection._transform
6046         if (not isinstance(t, mtransforms.Transform) and
6047                 hasattr(t, '_as_mpl_transform')):
6048             t = t._as_mpl_transform(self.axes)
6049 
6050         if t and any(t.contains_branch_seperately(self.transData)):
6051             trans_to_data = t - self.transData
6052             pts = np.vstack([x, y]).T.astype(float)
6053             transformed_pts = trans_to_data.transform(pts)
6054             x = transformed_pts[..., 0]
6055             y = transformed_pts[..., 1]
6056 
6057         self.add_collection(collection, autolim=False)
6058 
6059         minx = np.min(x)
6060         maxx = np.max(x)
6061         miny = np.min(y)
6062         maxy = np.max(y)
6063         collection.sticky_edges.x[:] = [minx, maxx]
6064         collection.sticky_edges.y[:] = [miny, maxy]
6065         corners = (minx, miny), (maxx, maxy)
6066         self.update_datalim(corners)
6067         self._request_autoscale_view()
6068         return collection
6069 
6070     @_preprocess_data()
6071     @_docstring.dedent_interpd
6072     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6073                    vmax=None, shading=None, antialiased=False, **kwargs):
6074         """
6075         Create a pseudocolor plot with a non-regular rectangular grid.
6076 
6077         Call signature::
6078 
6079             pcolormesh([X, Y,] C, **kwargs)
6080 
6081         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6082 
6083         .. hint::
6084 
6085            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6086            and preferred in most cases. For a detailed discussion on the
6087            differences see :ref:`Differences between pcolor() and pcolormesh()
6088            <differences-pcolor-pcolormesh>`.
6089 
6090         Parameters
6091         ----------
6092         C : array-like
6093             The mesh data. Supported array shapes are:
6094 
6095             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6096               colors using normalization and a colormap. See parameters *norm*,
6097               *cmap*, *vmin*, *vmax*.
6098             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6099             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6100               i.e. including transparency.
6101 
6102             The first two dimensions (M, N) define the rows and columns of
6103             the mesh data.
6104 
6105         X, Y : array-like, optional
6106             The coordinates of the corners of quadrilaterals of a pcolormesh::
6107 
6108                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6109                                       ●╶───╴●
6110                                       │     │
6111                                       ●╶───╴●
6112                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6113 
6114             Note that the column index corresponds to the x-coordinate, and
6115             the row index corresponds to y. For details, see the
6116             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6117 
6118             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6119             greater than those of *C*, and the quadrilateral is colored due
6120             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6121             dimensions, a warning will be raised and the last row and column
6122             of *C* will be ignored.
6123 
6124             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6125             and *Y* should be the same as those of *C* (if not, a ValueError
6126             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6127             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6128             interpolation is caried out between the quadrilateral corners.
6129 
6130             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6131             expanded as needed into the appropriate 2D arrays, making a
6132             rectangular grid.
6133 
6134         %(cmap_doc)s
6135 
6136         %(norm_doc)s
6137 
6138         %(vmin_vmax_doc)s
6139 
6140         edgecolors : {'none', None, 'face', color, color sequence}, optional
6141             The color of the edges. Defaults to 'none'. Possible values:
6142 
6143             - 'none' or '': No edge.
6144             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6145               :rc:`patch.force_edgecolor` has to be True for this to work.
6146             - 'face': Use the adjacent face color.
6147             - A color or sequence of colors will set the edge color.
6148 
6149             The singular form *edgecolor* works as an alias.
6150 
6151         alpha : float, default: None
6152             The alpha blending value, between 0 (transparent) and 1 (opaque).
6153 
6154         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6155             The fill style for the quadrilateral; defaults to
6156             :rc:`pcolor.shading`. Possible values:
6157 
6158             - 'flat': A solid color is used for each quad. The color of the
6159               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6160               ``C[i, j]``. The dimensions of *X* and *Y* should be
6161               one greater than those of *C*; if they are the same as *C*,
6162               then a deprecation warning is raised, and the last row
6163               and column of *C* are dropped.
6164             - 'nearest': Each grid point will have a color centered on it,
6165               extending halfway between the adjacent grid centers.  The
6166               dimensions of *X* and *Y* must be the same as *C*.
6167             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6168               corners (i', j') are given by ``C[i', j']``. The color values of
6169               the area in between is interpolated from the corner values.
6170               The dimensions of *X* and *Y* must be the same as *C*. When
6171               Gouraud shading is used, *edgecolors* is ignored.
6172             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6173               larger than *C*.  Choose 'nearest' if dimensions are the same.
6174 
6175             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6176             for more description.
6177 
6178         snap : bool, default: False
6179             Whether to snap the mesh to pixel boundaries.
6180 
6181         rasterized : bool, optional
6182             Rasterize the pcolormesh when drawing vector graphics.  This can
6183             speed up rendering and produce smaller files for large data sets.
6184             See also :doc:`/gallery/misc/rasterization_demo`.
6185 
6186         Returns
6187         -------
6188         `matplotlib.collections.QuadMesh`
6189 
6190         Other Parameters
6191         ----------------
6192         data : indexable object, optional
6193             DATA_PARAMETER_PLACEHOLDER
6194 
6195         **kwargs
6196             Additionally, the following arguments are allowed. They are passed
6197             along to the `~matplotlib.collections.QuadMesh` constructor:
6198 
6199         %(QuadMesh:kwdoc)s
6200 
6201         See Also
6202         --------
6203         pcolor : An alternative implementation with slightly different
6204             features. For a detailed discussion on the differences see
6205             :ref:`Differences between pcolor() and pcolormesh()
6206             <differences-pcolor-pcolormesh>`.
6207         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6208             faster alternative.
6209 
6210         Notes
6211         -----
6212         **Masked arrays**
6213 
6214         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6215         quadrilateral will be transparent. Masking of *X* and *Y* is not
6216         supported. Use `~.Axes.pcolor` if you need this functionality.
6217 
6218         .. _axes-pcolormesh-grid-orientation:
6219 
6220         **Grid orientation**
6221 
6222         The grid orientation follows the standard matrix convention: An array
6223         *C* with shape (nrows, ncolumns) is plotted with the column number as
6224         *X* and the row number as *Y*.
6225 
6226         .. _differences-pcolor-pcolormesh:
6227 
6228         **Differences between pcolor() and pcolormesh()**
6229 
6230         Both methods are used to create a pseudocolor plot of a 2D array
6231         using quadrilaterals.
6232 
6233         The main difference lies in the created object and internal data
6234         handling:
6235         While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`
6236         returns a `.QuadMesh`. The latter is more specialized for the given
6237         purpose and thus is faster. It should almost always be preferred.
6238 
6239         There is also a slight difference in the handling of masked arrays.
6240         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6241         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6242         and *Y*. The reason lies in the internal handling of the masked values.
6243         `~.Axes.pcolor` leaves out the respective polygons from the
6244         PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked
6245         elements to transparent. You can see the difference when using
6246         edgecolors. While all edges are drawn irrespective of masking in a
6247         QuadMesh, the edge between two adjacent masked quadrilaterals in
6248         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6249         exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual
6250         polygon, it also supports applying hatches and linestyles to the collection.
6251 
6252         Another difference is the support of Gouraud shading in
6253         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6254 
6255         """
6256         if shading is None:
6257             shading = mpl.rcParams['pcolor.shading']
6258         shading = shading.lower()
6259         kwargs.setdefault('edgecolors', 'none')
6260 
6261         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6262                                             shading=shading, kwargs=kwargs)
6263         coords = np.stack([X, Y], axis=-1)
6264 
6265         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6266 
6267         collection = mcoll.QuadMesh(
6268             coords, antialiased=antialiased, shading=shading,
6269             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6270         collection._scale_norm(norm, vmin, vmax)
6271 
6272         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6273 
6274         # Transform from native to data coordinates?
6275         t = collection._transform
6276         if (not isinstance(t, mtransforms.Transform) and
6277                 hasattr(t, '_as_mpl_transform')):
6278             t = t._as_mpl_transform(self.axes)
6279 
6280         if t and any(t.contains_branch_seperately(self.transData)):
6281             trans_to_data = t - self.transData
6282             coords = trans_to_data.transform(coords)
6283 
6284         self.add_collection(collection, autolim=False)
6285 
6286         minx, miny = np.min(coords, axis=0)
6287         maxx, maxy = np.max(coords, axis=0)
6288         collection.sticky_edges.x[:] = [minx, maxx]
6289         collection.sticky_edges.y[:] = [miny, maxy]
6290         corners = (minx, miny), (maxx, maxy)
6291         self.update_datalim(corners)
6292         self._request_autoscale_view()
6293         return collection
6294 
6295     @_preprocess_data()
6296     @_docstring.dedent_interpd
6297     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6298                    vmax=None, **kwargs):
6299         """
6300         Create a pseudocolor plot with a non-regular rectangular grid.
6301 
6302         Call signature::
6303 
6304           ax.pcolorfast([X, Y], C, /, **kwargs)
6305 
6306         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6307         It's designed to provide the fastest pcolor-type plotting with the
6308         Agg backend. To achieve this, it uses different algorithms internally
6309         depending on the complexity of the input grid (regular rectangular,
6310         non-regular rectangular or arbitrary quadrilateral).
6311 
6312         .. warning::
6313 
6314            This method is experimental. Compared to `~.Axes.pcolor` or
6315            `~.Axes.pcolormesh` it has some limitations:
6316 
6317            - It supports only flat shading (no outlines)
6318            - It lacks support for log scaling of the axes.
6319            - It does not have a pyplot wrapper.
6320 
6321         Parameters
6322         ----------
6323         C : array-like
6324             The image data. Supported array shapes are:
6325 
6326             - (M, N): an image with scalar data.  Color-mapping is controlled
6327               by *cmap*, *norm*, *vmin*, and *vmax*.
6328             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6329             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6330               i.e. including transparency.
6331 
6332             The first two dimensions (M, N) define the rows and columns of
6333             the image.
6334 
6335             This parameter can only be passed positionally.
6336 
6337         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6338             *X* and *Y* are used to specify the coordinates of the
6339             quadrilaterals. There are different ways to do this:
6340 
6341             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6342               a *uniform rectangular grid*.
6343 
6344               The tuples define the outer edges of the grid. All individual
6345               quadrilaterals will be of the same size. This is the fastest
6346               version.
6347 
6348             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6349               grid*.
6350 
6351               In this case *X* and *Y* have to be monotonic 1D arrays of length
6352               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6353 
6354               The speed is intermediate. Note: The grid is checked, and if
6355               found to be uniform the fast version is used.
6356 
6357             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6358               grid* (i.e. if the quadrilaterals are not rectangular).
6359 
6360               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6361               specifying the x and y coordinates of the corners of the colored
6362               quadrilaterals.
6363 
6364               This is the most general, but the slowest to render.  It may
6365               produce faster and more compact output using ps, pdf, and
6366               svg backends, however.
6367 
6368             These arguments can only be passed positionally.
6369 
6370         %(cmap_doc)s
6371 
6372             This parameter is ignored if *C* is RGB(A).
6373 
6374         %(norm_doc)s
6375 
6376             This parameter is ignored if *C* is RGB(A).
6377 
6378         %(vmin_vmax_doc)s
6379 
6380             This parameter is ignored if *C* is RGB(A).
6381 
6382         alpha : float, default: None
6383             The alpha blending value, between 0 (transparent) and 1 (opaque).
6384 
6385         snap : bool, default: False
6386             Whether to snap the mesh to pixel boundaries.
6387 
6388         Returns
6389         -------
6390         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6391             The return type depends on the type of grid:
6392 
6393             - `.AxesImage` for a regular rectangular grid.
6394             - `.PcolorImage` for a non-regular rectangular grid.
6395             - `.QuadMesh` for a non-rectangular grid.
6396 
6397         Other Parameters
6398         ----------------
6399         data : indexable object, optional
6400             DATA_PARAMETER_PLACEHOLDER
6401 
6402         **kwargs
6403             Supported additional parameters depend on the type of grid.
6404             See return types of *image* for further description.
6405         """
6406 
6407         C = args[-1]
6408         nr, nc = np.shape(C)[:2]
6409         if len(args) == 1:
6410             style = "image"
6411             x = [0, nc]
6412             y = [0, nr]
6413         elif len(args) == 3:
6414             x, y = args[:2]
6415             x = np.asarray(x)
6416             y = np.asarray(y)
6417             if x.ndim == 1 and y.ndim == 1:
6418                 if x.size == 2 and y.size == 2:
6419                     style = "image"
6420                 else:
6421                     dx = np.diff(x)
6422                     dy = np.diff(y)
6423                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6424                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6425                         style = "image"
6426                     else:
6427                         style = "pcolorimage"
6428             elif x.ndim == 2 and y.ndim == 2:
6429                 style = "quadmesh"
6430             else:
6431                 raise TypeError("arguments do not match valid signatures")
6432         else:
6433             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6434 
6435         if style == "quadmesh":
6436             # data point in each cell is value at lower left corner
6437             coords = np.stack([x, y], axis=-1)
6438             if np.ndim(C) not in {2, 3}:
6439                 raise ValueError("C must be 2D or 3D")
6440             collection = mcoll.QuadMesh(
6441                 coords, array=C,
6442                 alpha=alpha, cmap=cmap, norm=norm,
6443                 antialiased=False, edgecolors="none")
6444             self.add_collection(collection, autolim=False)
6445             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6446             ret = collection
6447 
6448         else:  # It's one of the two image styles.
6449             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6450             if style == "image":
6451                 im = mimage.AxesImage(
6452                     self, cmap=cmap, norm=norm,
6453                     data=C, alpha=alpha, extent=extent,
6454                     interpolation='nearest', origin='lower',
6455                     **kwargs)
6456             elif style == "pcolorimage":
6457                 im = mimage.PcolorImage(
6458                     self, x, y, C,
6459                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6460                     **kwargs)
6461             self.add_image(im)
6462             ret = im
6463 
6464         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6465             ret._scale_norm(norm, vmin, vmax)
6466 
6467         if ret.get_clip_path() is None:
6468             # image does not already have clipping set, clip to axes patch
6469             ret.set_clip_path(self.patch)
6470 
6471         ret.sticky_edges.x[:] = [xl, xr]
6472         ret.sticky_edges.y[:] = [yb, yt]
6473         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6474         self._request_autoscale_view(tight=True)
6475         return ret
6476 
6477     @_preprocess_data()
6478     @_docstring.dedent_interpd
6479     def contour(self, *args, **kwargs):
6480         """
6481         Plot contour lines.
6482 
6483         Call signature::
6484 
6485             contour([X, Y,] Z, [levels], **kwargs)
6486         %(contour_doc)s
6487         """
6488         kwargs['filled'] = False
6489         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6490         self._request_autoscale_view()
6491         return contours
6492 
6493     @_preprocess_data()
6494     @_docstring.dedent_interpd
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours
6508 
6509     def clabel(self, CS, levels=None, **kwargs):
6510         """
6511         Label a contour plot.
6512 
6513         Adds labels to line contours in given `.ContourSet`.
6514 
6515         Parameters
6516         ----------
6517         CS : `.ContourSet` instance
6518             Line contours to label.
6519 
6520         levels : array-like, optional
6521             A list of level values, that should be labeled. The list must be
6522             a subset of ``CS.levels``. If not given, all levels are labeled.
6523 
6524         **kwargs
6525             All other parameters are documented in `~.ContourLabeler.clabel`.
6526         """
6527         return CS.clabel(levels, **kwargs)
6528 
6529     #### Data analysis
6530 
6531     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6532     def hist(self, x, bins=None, range=None, density=False, weights=None,
6533              cumulative=False, bottom=None, histtype='bar', align='mid',
6534              orientation='vertical', rwidth=None, log=False,
6535              color=None, label=None, stacked=False, **kwargs):
6536         """
6537         Compute and plot a histogram.
6538 
6539         This method uses `numpy.histogram` to bin the data in *x* and count the
6540         number of values in each bin, then draws the distribution either as a
6541         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6542         *weights* parameters are forwarded to `numpy.histogram`.
6543 
6544         If the data has already been binned and counted, use `~.bar` or
6545         `~.stairs` to plot the distribution::
6546 
6547             counts, bins = np.histogram(x)
6548             plt.stairs(counts, bins)
6549 
6550         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6551         treating each bin as a single point with a weight equal to its count::
6552 
6553             plt.hist(bins[:-1], bins, weights=counts)
6554 
6555         The data input *x* can be a singular array, a list of datasets of
6556         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6557         which each column is a dataset. Note that the ndarray form is
6558         transposed relative to the list form. If the input is an array, then
6559         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6560         sequence of arrays, then the return value is a tuple
6561         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6562 
6563         Masked arrays are not supported.
6564 
6565         Parameters
6566         ----------
6567         x : (n,) array or sequence of (n,) arrays
6568             Input values, this takes either a single array or a sequence of
6569             arrays which are not required to be of the same length.
6570 
6571         bins : int or sequence or str, default: :rc:`hist.bins`
6572             If *bins* is an integer, it defines the number of equal-width bins
6573             in the range.
6574 
6575             If *bins* is a sequence, it defines the bin edges, including the
6576             left edge of the first bin and the right edge of the last bin;
6577             in this case, bins may be unequally spaced.  All but the last
6578             (righthand-most) bin is half-open.  In other words, if *bins* is::
6579 
6580                 [1, 2, 3, 4]
6581 
6582             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6583             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6584             *includes* 4.
6585 
6586             If *bins* is a string, it is one of the binning strategies
6587             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6588             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6589 
6590         range : tuple or None, default: None
6591             The lower and upper range of the bins. Lower and upper outliers
6592             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6593             Range has no effect if *bins* is a sequence.
6594 
6595             If *bins* is a sequence or *range* is specified, autoscaling
6596             is based on the specified bin range instead of the
6597             range of x.
6598 
6599         density : bool, default: False
6600             If ``True``, draw and return a probability density: each bin
6601             will display the bin's raw count divided by the total number of
6602             counts *and the bin width*
6603             (``density = counts / (sum(counts) * np.diff(bins))``),
6604             so that the area under the histogram integrates to 1
6605             (``np.sum(density * np.diff(bins)) == 1``).
6606 
6607             If *stacked* is also ``True``, the sum of the histograms is
6608             normalized to 1.
6609 
6610         weights : (n,) array-like or None, default: None
6611             An array of weights, of the same shape as *x*.  Each value in
6612             *x* only contributes its associated weight towards the bin count
6613             (instead of 1).  If *density* is ``True``, the weights are
6614             normalized, so that the integral of the density over the range
6615             remains 1.
6616 
6617         cumulative : bool or -1, default: False
6618             If ``True``, then a histogram is computed where each bin gives the
6619             counts in that bin plus all bins for smaller values. The last bin
6620             gives the total number of datapoints.
6621 
6622             If *density* is also ``True`` then the histogram is normalized such
6623             that the last bin equals 1.
6624 
6625             If *cumulative* is a number less than 0 (e.g., -1), the direction
6626             of accumulation is reversed.  In this case, if *density* is also
6627             ``True``, then the histogram is normalized such that the first bin
6628             equals 1.
6629 
6630         bottom : array-like, scalar, or None, default: None
6631             Location of the bottom of each bin, i.e. bins are drawn from
6632             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6633             of each bin is shifted by the same amount. If an array, each bin
6634             is shifted independently and the length of bottom must match the
6635             number of bins. If None, defaults to 0.
6636 
6637         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6638             The type of histogram to draw.
6639 
6640             - 'bar' is a traditional bar-type histogram.  If multiple data
6641               are given the bars are arranged side by side.
6642             - 'barstacked' is a bar-type histogram where multiple
6643               data are stacked on top of each other.
6644             - 'step' generates a lineplot that is by default unfilled.
6645             - 'stepfilled' generates a lineplot that is by default filled.
6646 
6647         align : {'left', 'mid', 'right'}, default: 'mid'
6648             The horizontal alignment of the histogram bars.
6649 
6650             - 'left': bars are centered on the left bin edges.
6651             - 'mid': bars are centered between the bin edges.
6652             - 'right': bars are centered on the right bin edges.
6653 
6654         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6655             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6656             and the *bottom* kwarg will be the left edges.
6657 
6658         rwidth : float or None, default: None
6659             The relative width of the bars as a fraction of the bin width.  If
6660             ``None``, automatically compute the width.
6661 
6662             Ignored if *histtype* is 'step' or 'stepfilled'.
6663 
6664         log : bool, default: False
6665             If ``True``, the histogram axis will be set to a log scale.
6666 
6667         color : color or array-like of colors or None, default: None
6668             Color or sequence of colors, one per dataset.  Default (``None``)
6669             uses the standard line color sequence.
6670 
6671         label : str or None, default: None
6672             String, or sequence of strings to match multiple datasets.  Bar
6673             charts yield multiple patches per dataset, but only the first gets
6674             the label, so that `~.Axes.legend` will work as expected.
6675 
6676         stacked : bool, default: False
6677             If ``True``, multiple data are stacked on top of each other If
6678             ``False`` multiple data are arranged side by side if histtype is
6679             'bar' or on top of each other if histtype is 'step'
6680 
6681         Returns
6682         -------
6683         n : array or list of arrays
6684             The values of the histogram bins. See *density* and *weights* for a
6685             description of the possible semantics.  If input *x* is an array,
6686             then this is an array of length *nbins*. If input is a sequence of
6687             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6688             the values of the histograms for each of the arrays in the same
6689             order.  The dtype of the array *n* (or of its element arrays) will
6690             always be float even if no weighting or normalization is used.
6691 
6692         bins : array
6693             The edges of the bins. Length nbins + 1 (nbins left edges and right
6694             edge of last bin).  Always a single array even when multiple data
6695             sets are passed in.
6696 
6697         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6698 such objects
6699             Container of individual artists used to create the histogram
6700             or list of such containers if there are multiple input datasets.
6701 
6702         Other Parameters
6703         ----------------
6704         data : indexable object, optional
6705             DATA_PARAMETER_PLACEHOLDER
6706 
6707         **kwargs
6708             `~matplotlib.patches.Patch` properties
6709 
6710         See Also
6711         --------
6712         hist2d : 2D histogram with rectangular bins
6713         hexbin : 2D histogram with hexagonal bins
6714         stairs : Plot a pre-computed histogram
6715         bar : Plot a pre-computed histogram
6716 
6717         Notes
6718         -----
6719         For large numbers of bins (>1000), plotting can be significantly
6720         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6721         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6722         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6723         """
6724         # Avoid shadowing the builtin.
6725         bin_range = range
6726         from builtins import range
6727 
6728         if np.isscalar(x):
6729             x = [x]
6730 
6731         if bins is None:
6732             bins = mpl.rcParams['hist.bins']
6733 
6734         # Validate string inputs here to avoid cluttering subsequent code.
6735         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6736                            histtype=histtype)
6737         _api.check_in_list(['left', 'mid', 'right'], align=align)
6738         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6739 
6740         if histtype == 'barstacked' and not stacked:
6741             stacked = True
6742 
6743         # Massage 'x' for processing.
6744         x = cbook._reshape_2D(x, 'x')
6745         nx = len(x)  # number of datasets
6746 
6747         # Process unit information.  _process_unit_info sets the unit and
6748         # converts the first dataset; then we convert each following dataset
6749         # one at a time.
6750         if orientation == "vertical":
6751             convert_units = self.convert_xunits
6752             x = [*self._process_unit_info([("x", x[0])], kwargs),
6753                  *map(convert_units, x[1:])]
6754         else:  # horizontal
6755             convert_units = self.convert_yunits
6756             x = [*self._process_unit_info([("y", x[0])], kwargs),
6757                  *map(convert_units, x[1:])]
6758 
6759         if bin_range is not None:
6760             bin_range = convert_units(bin_range)
6761 
6762         if not cbook.is_scalar_or_string(bins):
6763             bins = convert_units(bins)
6764 
6765         # We need to do to 'weights' what was done to 'x'
6766         if weights is not None:
6767             w = cbook._reshape_2D(weights, 'weights')
6768         else:
6769             w = [None] * nx
6770 
6771         if len(w) != nx:
6772             raise ValueError('weights should have the same shape as x')
6773 
6774         input_empty = True
6775         for xi, wi in zip(x, w):
6776             len_xi = len(xi)
6777             if wi is not None and len(wi) != len_xi:
6778                 raise ValueError('weights should have the same shape as x')
6779             if len_xi:
6780                 input_empty = False
6781 
6782         if color is None:
6783             colors = [self._get_lines.get_next_color() for i in range(nx)]
6784         else:
6785             colors = mcolors.to_rgba_array(color)
6786             if len(colors) != nx:
6787                 raise ValueError(f"The 'color' keyword argument must have one "
6788                                  f"color per dataset, but {nx} datasets and "
6789                                  f"{len(colors)} colors were provided")
6790 
6791         hist_kwargs = dict()
6792 
6793         # if the bin_range is not given, compute without nan numpy
6794         # does not do this for us when guessing the range (but will
6795         # happily ignore nans when computing the histogram).
6796         if bin_range is None:
6797             xmin = np.inf
6798             xmax = -np.inf
6799             for xi in x:
6800                 if len(xi):
6801                     # python's min/max ignore nan,
6802                     # np.minnan returns nan for all nan input
6803                     xmin = min(xmin, np.nanmin(xi))
6804                     xmax = max(xmax, np.nanmax(xi))
6805             if xmin <= xmax:  # Only happens if we have seen a finite value.
6806                 bin_range = (xmin, xmax)
6807 
6808         # If bins are not specified either explicitly or via range,
6809         # we need to figure out the range required for all datasets,
6810         # and supply that to np.histogram.
6811         if not input_empty and len(x) > 1:
6812             if weights is not None:
6813                 _w = np.concatenate(w)
6814             else:
6815                 _w = None
6816             bins = np.histogram_bin_edges(
6817                 np.concatenate(x), bins, bin_range, _w)
6818         else:
6819             hist_kwargs['range'] = bin_range
6820 
6821         density = bool(density)
6822         if density and not stacked:
6823             hist_kwargs['density'] = density
6824 
6825         # List to store all the top coordinates of the histograms
6826         tops = []  # Will have shape (n_datasets, n_bins).
6827         # Loop through datasets
6828         for i in range(nx):
6829             # this will automatically overwrite bins,
6830             # so that each histogram uses the same bins
6831             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6832             tops.append(m)
6833         tops = np.array(tops, float)  # causes problems later if it's an int
6834         bins = np.array(bins, float)  # causes problems if float16
6835         if stacked:
6836             tops = tops.cumsum(axis=0)
6837             # If a stacked density plot, normalize so the area of all the
6838             # stacked histograms together is 1
6839             if density:
6840                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6841         if cumulative:
6842             slc = slice(None)
6843             if isinstance(cumulative, Number) and cumulative < 0:
6844                 slc = slice(None, None, -1)
6845             if density:
6846                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6847             else:
6848                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6849 
6850         patches = []
6851 
6852         if histtype.startswith('bar'):
6853 
6854             totwidth = np.diff(bins)
6855 
6856             if rwidth is not None:
6857                 dr = np.clip(rwidth, 0, 1)
6858             elif (len(tops) > 1 and
6859                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6860                 dr = 0.8
6861             else:
6862                 dr = 1.0
6863 
6864             if histtype == 'bar' and not stacked:
6865                 width = dr * totwidth / nx
6866                 dw = width
6867                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6868             elif histtype == 'barstacked' or stacked:
6869                 width = dr * totwidth
6870                 boffset, dw = 0.0, 0.0
6871 
6872             if align == 'mid':
6873                 boffset += 0.5 * totwidth
6874             elif align == 'right':
6875                 boffset += totwidth
6876 
6877             if orientation == 'horizontal':
6878                 _barfunc = self.barh
6879                 bottom_kwarg = 'left'
6880             else:  # orientation == 'vertical'
6881                 _barfunc = self.bar
6882                 bottom_kwarg = 'bottom'
6883 
6884             for top, color in zip(tops, colors):
6885                 if bottom is None:
6886                     bottom = np.zeros(len(top))
6887                 if stacked:
6888                     height = top - bottom
6889                 else:
6890                     height = top
6891                 bars = _barfunc(bins[:-1]+boffset, height, width,
6892                                 align='center', log=log,
6893                                 color=color, **{bottom_kwarg: bottom})
6894                 patches.append(bars)
6895                 if stacked:
6896                     bottom = top
6897                 boffset += dw
6898             # Remove stickies from all bars but the lowest ones, as otherwise
6899             # margin expansion would be unable to cross the stickies in the
6900             # middle of the bars.
6901             for bars in patches[1:]:
6902                 for patch in bars:
6903                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6904 
6905         elif histtype.startswith('step'):
6906             # these define the perimeter of the polygon
6907             x = np.zeros(4 * len(bins) - 3)
6908             y = np.zeros(4 * len(bins) - 3)
6909 
6910             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6911             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6912 
6913             if bottom is None:
6914                 bottom = 0
6915 
6916             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6917             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6918 
6919             if log:
6920                 if orientation == 'horizontal':
6921                     self.set_xscale('log', nonpositive='clip')
6922                 else:  # orientation == 'vertical'
6923                     self.set_yscale('log', nonpositive='clip')
6924 
6925             if align == 'left':
6926                 x -= 0.5*(bins[1]-bins[0])
6927             elif align == 'right':
6928                 x += 0.5*(bins[1]-bins[0])
6929 
6930             # If fill kwarg is set, it will be passed to the patch collection,
6931             # overriding this
6932             fill = (histtype == 'stepfilled')
6933 
6934             xvals, yvals = [], []
6935             for top in tops:
6936                 if stacked:
6937                     # top of the previous polygon becomes the bottom
6938                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6939                 # set the top of this polygon
6940                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6941 
6942                 # The starting point of the polygon has not yet been
6943                 # updated. So far only the endpoint was adjusted. This
6944                 # assignment closes the polygon. The redundant endpoint is
6945                 # later discarded (for step and stepfilled).
6946                 y[0] = y[-1]
6947 
6948                 if orientation == 'horizontal':
6949                     xvals.append(y.copy())
6950                     yvals.append(x.copy())
6951                 else:
6952                     xvals.append(x.copy())
6953                     yvals.append(y.copy())
6954 
6955             # stepfill is closed, step is not
6956             split = -1 if fill else 2 * len(bins)
6957             # add patches in reverse order so that when stacking,
6958             # items lower in the stack are plotted on top of
6959             # items higher in the stack
6960             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6961                 patches.append(self.fill(
6962                     x[:split], y[:split],
6963                     closed=True if fill else None,
6964                     facecolor=color,
6965                     edgecolor=None if fill else color,
6966                     fill=fill if fill else None,
6967                     zorder=None if fill else mlines.Line2D.zorder))
6968             for patch_list in patches:
6969                 for patch in patch_list:
6970                     if orientation == 'vertical':
6971                         patch.sticky_edges.y.append(0)
6972                     elif orientation == 'horizontal':
6973                         patch.sticky_edges.x.append(0)
6974 
6975             # we return patches, so put it back in the expected order
6976             patches.reverse()
6977 
6978         # If None, make all labels None (via zip_longest below); otherwise,
6979         # cast each element to str, but keep a single str as it.
6980         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6981         for patch, lbl in itertools.zip_longest(patches, labels):
6982             if patch:
6983                 p = patch[0]
6984                 p._internal_update(kwargs)
6985                 if lbl is not None:
6986                     p.set_label(lbl)
6987                 for p in patch[1:]:
6988                     p._internal_update(kwargs)
6989                     p.set_label('_nolegend_')
6990 
6991         if nx == 1:
6992             return tops[0], bins, patches[0]
6993         else:
6994             patch_type = ("BarContainer" if histtype.startswith("bar")
6995                           else "list[Polygon]")
6996             return tops, bins, cbook.silent_list(patch_type, patches)
6997 
6998     @_preprocess_data()
6999     def stairs(self, values, edges=None, *,
7000                orientation='vertical', baseline=0, fill=False, **kwargs):
7001         """
7002         A stepwise constant function as a line with bounding edges
7003         or a filled plot.
7004 
7005         Parameters
7006         ----------
7007         values : array-like
7008             The step heights.
7009 
7010         edges : array-like
7011             The edge positions, with ``len(edges) == len(vals) + 1``,
7012             between which the curve takes on vals values.
7013 
7014         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7015             The direction of the steps. Vertical means that *values* are along
7016             the y-axis, and edges are along the x-axis.
7017 
7018         baseline : float, array-like or None, default: 0
7019             The bottom value of the bounding edges or when
7020             ``fill=True``, position of lower edge. If *fill* is
7021             True or an array is passed to *baseline*, a closed
7022             path is drawn.
7023 
7024         fill : bool, default: False
7025             Whether the area under the step curve should be filled.
7026 
7027         Returns
7028         -------
7029         StepPatch : `~matplotlib.patches.StepPatch`
7030 
7031         Other Parameters
7032         ----------------
7033         data : indexable object, optional
7034             DATA_PARAMETER_PLACEHOLDER
7035 
7036         **kwargs
7037             `~matplotlib.patches.StepPatch` properties
7038 
7039         """
7040 
7041         if 'color' in kwargs:
7042             _color = kwargs.pop('color')
7043         else:
7044             _color = self._get_lines.get_next_color()
7045         if fill:
7046             kwargs.setdefault('linewidth', 0)
7047             kwargs.setdefault('facecolor', _color)
7048         else:
7049             kwargs.setdefault('edgecolor', _color)
7050 
7051         if edges is None:
7052             edges = np.arange(len(values) + 1)
7053 
7054         edges, values, baseline = self._process_unit_info(
7055             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7056 
7057         patch = mpatches.StepPatch(values,
7058                                    edges,
7059                                    baseline=baseline,
7060                                    orientation=orientation,
7061                                    fill=fill,
7062                                    **kwargs)
7063         self.add_patch(patch)
7064         if baseline is None:
7065             baseline = 0
7066         if orientation == 'vertical':
7067             patch.sticky_edges.y.append(np.min(baseline))
7068             self.update_datalim([(edges[0], np.min(baseline))])
7069         else:
7070             patch.sticky_edges.x.append(np.min(baseline))
7071             self.update_datalim([(np.min(baseline), edges[0])])
7072         self._request_autoscale_view()
7073         return patch
7074 
7075     @_preprocess_data(replace_names=["x", "y", "weights"])
7076     @_docstring.dedent_interpd
7077     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7078                cmin=None, cmax=None, **kwargs):
7079         """
7080         Make a 2D histogram plot.
7081 
7082         Parameters
7083         ----------
7084         x, y : array-like, shape (n, )
7085             Input values
7086 
7087         bins : None or int or [int, int] or array-like or [array, array]
7088 
7089             The bin specification:
7090 
7091             - If int, the number of bins for the two dimensions
7092               (nx=ny=bins).
7093             - If ``[int, int]``, the number of bins in each dimension
7094               (nx, ny = bins).
7095             - If array-like, the bin edges for the two dimensions
7096               (x_edges=y_edges=bins).
7097             - If ``[array, array]``, the bin edges in each dimension
7098               (x_edges, y_edges = bins).
7099 
7100             The default value is 10.
7101 
7102         range : array-like shape(2, 2), optional
7103             The leftmost and rightmost edges of the bins along each dimension
7104             (if not specified explicitly in the bins parameters): ``[[xmin,
7105             xmax], [ymin, ymax]]``. All values outside of this range will be
7106             considered outliers and not tallied in the histogram.
7107 
7108         density : bool, default: False
7109             Normalize histogram.  See the documentation for the *density*
7110             parameter of `~.Axes.hist` for more details.
7111 
7112         weights : array-like, shape (n, ), optional
7113             An array of values w_i weighing each sample (x_i, y_i).
7114 
7115         cmin, cmax : float, default: None
7116             All bins that has count less than *cmin* or more than *cmax* will
7117             not be displayed (set to NaN before passing to imshow) and these
7118             count values in the return value count histogram will also be set
7119             to nan upon return.
7120 
7121         Returns
7122         -------
7123         h : 2D array
7124             The bi-dimensional histogram of samples x and y. Values in x are
7125             histogrammed along the first dimension and values in y are
7126             histogrammed along the second dimension.
7127         xedges : 1D array
7128             The bin edges along the x-axis.
7129         yedges : 1D array
7130             The bin edges along the y-axis.
7131         image : `~.matplotlib.collections.QuadMesh`
7132 
7133         Other Parameters
7134         ----------------
7135         %(cmap_doc)s
7136 
7137         %(norm_doc)s
7138 
7139         %(vmin_vmax_doc)s
7140 
7141         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7142             The alpha blending value.
7143 
7144         data : indexable object, optional
7145             DATA_PARAMETER_PLACEHOLDER
7146 
7147         **kwargs
7148             Additional parameters are passed along to the
7149             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7150             constructor.
7151 
7152         See Also
7153         --------
7154         hist : 1D histogram plotting
7155         hexbin : 2D histogram with hexagonal bins
7156 
7157         Notes
7158         -----
7159         - Currently ``hist2d`` calculates its own axis limits, and any limits
7160           previously set are ignored.
7161         - Rendering the histogram with a logarithmic color scale is
7162           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7163           keyword argument. Likewise, power-law normalization (similar
7164           in effect to gamma correction) can be accomplished with
7165           `.colors.PowerNorm`.
7166         """
7167 
7168         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7169                                            density=density, weights=weights)
7170 
7171         if cmin is not None:
7172             h[h < cmin] = None
7173         if cmax is not None:
7174             h[h > cmax] = None
7175 
7176         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7177         self.set_xlim(xedges[0], xedges[-1])
7178         self.set_ylim(yedges[0], yedges[-1])
7179 
7180         return h, xedges, yedges, pc
7181 
7182     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7183     @_docstring.dedent_interpd
7184     def ecdf(self, x, weights=None, *, complementary=False,
7185              orientation="vertical", compress=False, **kwargs):
7186         """
7187         Compute and plot the empirical cumulative distribution function of *x*.
7188 
7189         .. versionadded:: 3.8
7190 
7191         Parameters
7192         ----------
7193         x : 1d array-like
7194             The input data.  Infinite entries are kept (and move the relevant
7195             end of the ecdf from 0/1), but NaNs and masked values are errors.
7196 
7197         weights : 1d array-like or None, default: None
7198             The weights of the entries; must have the same shape as *x*.
7199             Weights corresponding to NaN data points are dropped, and then the
7200             remaining weights are normalized to sum to 1.  If unset, all
7201             entries have the same weight.
7202 
7203         complementary : bool, default: False
7204             Whether to plot a cumulative distribution function, which increases
7205             from 0 to 1 (the default), or a complementary cumulative
7206             distribution function, which decreases from 1 to 0.
7207 
7208         orientation : {"vertical", "horizontal"}, default: "vertical"
7209             Whether the entries are plotted along the x-axis ("vertical", the
7210             default) or the y-axis ("horizontal").  This parameter takes the
7211             same values as in `~.Axes.hist`.
7212 
7213         compress : bool, default: False
7214             Whether multiple entries with the same values are grouped together
7215             (with a summed weight) before plotting.  This is mainly useful if
7216             *x* contains many identical data points, to decrease the rendering
7217             complexity of the plot. If *x* contains no duplicate points, this
7218             has no effect and just uses some time and memory.
7219 
7220         Other Parameters
7221         ----------------
7222         data : indexable object, optional
7223             DATA_PARAMETER_PLACEHOLDER
7224 
7225         **kwargs
7226             Keyword arguments control the `.Line2D` properties:
7227 
7228             %(Line2D:kwdoc)s
7229 
7230         Returns
7231         -------
7232         `.Line2D`
7233 
7234         Notes
7235         -----
7236         The ecdf plot can be thought of as a cumulative histogram with one bin
7237         per data entry; i.e. it reports on the entire dataset without any
7238         arbitrary binning.
7239 
7240         If *x* contains NaNs or masked entries, either remove them first from
7241         the array (if they should not taken into account), or replace them by
7242         -inf or +inf (if they should be sorted at the beginning or the end of
7243         the array).
7244         """
7245         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7246         if "drawstyle" in kwargs or "ds" in kwargs:
7247             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7248         if np.ma.getmask(x).any():
7249             raise ValueError("ecdf() does not support masked entries")
7250         x = np.asarray(x)
7251         if np.isnan(x).any():
7252             raise ValueError("ecdf() does not support NaNs")
7253         argsort = np.argsort(x)
7254         x = x[argsort]
7255         if weights is None:
7256             # Ensure that we end at exactly 1, avoiding floating point errors.
7257             cum_weights = (1 + np.arange(len(x))) / len(x)
7258         else:
7259             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7260             cum_weights = np.cumsum(weights / np.sum(weights))
7261         if compress:
7262             # Get indices of unique x values.
7263             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7264             x = x[compress_idxs]
7265             cum_weights = cum_weights[compress_idxs]
7266         if orientation == "vertical":
7267             if not complementary:
7268                 line, = self.plot([x[0], *x], [0, *cum_weights],
7269                                   drawstyle="steps-post", **kwargs)
7270             else:
7271                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7272                                   drawstyle="steps-pre", **kwargs)
7273             line.sticky_edges.y[:] = [0, 1]
7274         else:  # orientation == "horizontal":
7275             if not complementary:
7276                 line, = self.plot([0, *cum_weights], [x[0], *x],
7277                                   drawstyle="steps-pre", **kwargs)
7278             else:
7279                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7280                                   drawstyle="steps-post", **kwargs)
7281             line.sticky_edges.x[:] = [0, 1]
7282         return line
7283 
7284     @_preprocess_data(replace_names=["x"])
7285     @_docstring.dedent_interpd
7286     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7287             window=None, noverlap=None, pad_to=None,
7288             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7289         r"""
7290         Plot the power spectral density.
7291 
7292         The power spectral density :math:`P_{xx}` by Welch's average
7293         periodogram method.  The vector *x* is divided into *NFFT* length
7294         segments.  Each segment is detrended by function *detrend* and
7295         windowed by function *window*.  *noverlap* gives the length of
7296         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7297         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7298         with a scaling to correct for power loss due to windowing.
7299 
7300         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7301 
7302         Parameters
7303         ----------
7304         x : 1-D array or sequence
7305             Array or sequence containing the data
7306 
7307         %(Spectral)s
7308 
7309         %(PSD)s
7310 
7311         noverlap : int, default: 0 (no overlap)
7312             The number of points of overlap between segments.
7313 
7314         Fc : int, default: 0
7315             The center frequency of *x*, which offsets the x extents of the
7316             plot to reflect the frequency range used when a signal is acquired
7317             and then filtered and downsampled to baseband.
7318 
7319         return_line : bool, default: False
7320             Whether to include the line object plotted in the returned values.
7321 
7322         Returns
7323         -------
7324         Pxx : 1-D array
7325             The values for the power spectrum :math:`P_{xx}` before scaling
7326             (real valued).
7327 
7328         freqs : 1-D array
7329             The frequencies corresponding to the elements in *Pxx*.
7330 
7331         line : `~matplotlib.lines.Line2D`
7332             The line created by this function.
7333             Only returned if *return_line* is True.
7334 
7335         Other Parameters
7336         ----------------
7337         data : indexable object, optional
7338             DATA_PARAMETER_PLACEHOLDER
7339 
7340         **kwargs
7341             Keyword arguments control the `.Line2D` properties:
7342 
7343             %(Line2D:kwdoc)s
7344 
7345         See Also
7346         --------
7347         specgram
7348             Differs in the default overlap; in not returning the mean of the
7349             segment periodograms; in returning the times of the segments; and
7350             in plotting a colormap instead of a line.
7351         magnitude_spectrum
7352             Plots the magnitude spectrum.
7353         csd
7354             Plots the spectral density between two signals.
7355 
7356         Notes
7357         -----
7358         For plotting, the power is plotted as
7359         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7360         is returned.
7361 
7362         References
7363         ----------
7364         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7365         John Wiley & Sons (1986)
7366         """
7367         if Fc is None:
7368             Fc = 0
7369 
7370         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7371                               window=window, noverlap=noverlap, pad_to=pad_to,
7372                               sides=sides, scale_by_freq=scale_by_freq)
7373         freqs += Fc
7374 
7375         if scale_by_freq in (None, True):
7376             psd_units = 'dB/Hz'
7377         else:
7378             psd_units = 'dB'
7379 
7380         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7381         self.set_xlabel('Frequency')
7382         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7383         self.grid(True)
7384 
7385         vmin, vmax = self.get_ybound()
7386         step = max(10 * int(np.log10(vmax - vmin)), 1)
7387         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7388         self.set_yticks(ticks)
7389 
7390         if return_line is None or not return_line:
7391             return pxx, freqs
7392         else:
7393             return pxx, freqs, line
7394 
7395     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7396     @_docstring.dedent_interpd
7397     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7398             window=None, noverlap=None, pad_to=None,
7399             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7400         r"""
7401         Plot the cross-spectral density.
7402 
7403         The cross spectral density :math:`P_{xy}` by Welch's average
7404         periodogram method.  The vectors *x* and *y* are divided into
7405         *NFFT* length segments.  Each segment is detrended by function
7406         *detrend* and windowed by function *window*.  *noverlap* gives
7407         the length of the overlap between segments.  The product of
7408         the direct FFTs of *x* and *y* are averaged over each segment
7409         to compute :math:`P_{xy}`, with a scaling to correct for power
7410         loss due to windowing.
7411 
7412         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7413         padded to *NFFT*.
7414 
7415         Parameters
7416         ----------
7417         x, y : 1-D arrays or sequences
7418             Arrays or sequences containing the data.
7419 
7420         %(Spectral)s
7421 
7422         %(PSD)s
7423 
7424         noverlap : int, default: 0 (no overlap)
7425             The number of points of overlap between segments.
7426 
7427         Fc : int, default: 0
7428             The center frequency of *x*, which offsets the x extents of the
7429             plot to reflect the frequency range used when a signal is acquired
7430             and then filtered and downsampled to baseband.
7431 
7432         return_line : bool, default: False
7433             Whether to include the line object plotted in the returned values.
7434 
7435         Returns
7436         -------
7437         Pxy : 1-D array
7438             The values for the cross spectrum :math:`P_{xy}` before scaling
7439             (complex valued).
7440 
7441         freqs : 1-D array
7442             The frequencies corresponding to the elements in *Pxy*.
7443 
7444         line : `~matplotlib.lines.Line2D`
7445             The line created by this function.
7446             Only returned if *return_line* is True.
7447 
7448         Other Parameters
7449         ----------------
7450         data : indexable object, optional
7451             DATA_PARAMETER_PLACEHOLDER
7452 
7453         **kwargs
7454             Keyword arguments control the `.Line2D` properties:
7455 
7456             %(Line2D:kwdoc)s
7457 
7458         See Also
7459         --------
7460         psd : is equivalent to setting ``y = x``.
7461 
7462         Notes
7463         -----
7464         For plotting, the power is plotted as
7465         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7466         is returned.
7467 
7468         References
7469         ----------
7470         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7471         John Wiley & Sons (1986)
7472         """
7473         if Fc is None:
7474             Fc = 0
7475 
7476         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7477                               window=window, noverlap=noverlap, pad_to=pad_to,
7478                               sides=sides, scale_by_freq=scale_by_freq)
7479         # pxy is complex
7480         freqs += Fc
7481 
7482         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7483         self.set_xlabel('Frequency')
7484         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7485         self.grid(True)
7486 
7487         vmin, vmax = self.get_ybound()
7488         step = max(10 * int(np.log10(vmax - vmin)), 1)
7489         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7490         self.set_yticks(ticks)
7491 
7492         if return_line is None or not return_line:
7493             return pxy, freqs
7494         else:
7495             return pxy, freqs, line
7496 
7497     @_preprocess_data(replace_names=["x"])
7498     @_docstring.dedent_interpd
7499     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7500                            pad_to=None, sides=None, scale=None,
7501                            **kwargs):
7502         """
7503         Plot the magnitude spectrum.
7504 
7505         Compute the magnitude spectrum of *x*.  Data is padded to a
7506         length of *pad_to* and the windowing function *window* is applied to
7507         the signal.
7508 
7509         Parameters
7510         ----------
7511         x : 1-D array or sequence
7512             Array or sequence containing the data.
7513 
7514         %(Spectral)s
7515 
7516         %(Single_Spectrum)s
7517 
7518         scale : {'default', 'linear', 'dB'}
7519             The scaling of the values in the *spec*.  'linear' is no scaling.
7520             'dB' returns the values in dB scale, i.e., the dB amplitude
7521             (20 * log10). 'default' is 'linear'.
7522 
7523         Fc : int, default: 0
7524             The center frequency of *x*, which offsets the x extents of the
7525             plot to reflect the frequency range used when a signal is acquired
7526             and then filtered and downsampled to baseband.
7527 
7528         Returns
7529         -------
7530         spectrum : 1-D array
7531             The values for the magnitude spectrum before scaling (real valued).
7532 
7533         freqs : 1-D array
7534             The frequencies corresponding to the elements in *spectrum*.
7535 
7536         line : `~matplotlib.lines.Line2D`
7537             The line created by this function.
7538 
7539         Other Parameters
7540         ----------------
7541         data : indexable object, optional
7542             DATA_PARAMETER_PLACEHOLDER
7543 
7544         **kwargs
7545             Keyword arguments control the `.Line2D` properties:
7546 
7547             %(Line2D:kwdoc)s
7548 
7549         See Also
7550         --------
7551         psd
7552             Plots the power spectral density.
7553         angle_spectrum
7554             Plots the angles of the corresponding frequencies.
7555         phase_spectrum
7556             Plots the phase (unwrapped angle) of the corresponding frequencies.
7557         specgram
7558             Can plot the magnitude spectrum of segments within the signal in a
7559             colormap.
7560         """
7561         if Fc is None:
7562             Fc = 0
7563 
7564         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7565                                               pad_to=pad_to, sides=sides)
7566         freqs += Fc
7567 
7568         yunits = _api.check_getitem(
7569             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7570              'dB': 'dB'},
7571             scale=scale)
7572         if yunits == 'energy':
7573             Z = spec
7574         else:  # yunits == 'dB'
7575             Z = 20. * np.log10(spec)
7576 
7577         line, = self.plot(freqs, Z, **kwargs)
7578         self.set_xlabel('Frequency')
7579         self.set_ylabel('Magnitude (%s)' % yunits)
7580 
7581         return spec, freqs, line
7582 
7583     @_preprocess_data(replace_names=["x"])
7584     @_docstring.dedent_interpd
7585     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7586                        pad_to=None, sides=None, **kwargs):
7587         """
7588         Plot the angle spectrum.
7589 
7590         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7591         Data is padded to a length of *pad_to* and the windowing function
7592         *window* is applied to the signal.
7593 
7594         Parameters
7595         ----------
7596         x : 1-D array or sequence
7597             Array or sequence containing the data.
7598 
7599         %(Spectral)s
7600 
7601         %(Single_Spectrum)s
7602 
7603         Fc : int, default: 0
7604             The center frequency of *x*, which offsets the x extents of the
7605             plot to reflect the frequency range used when a signal is acquired
7606             and then filtered and downsampled to baseband.
7607 
7608         Returns
7609         -------
7610         spectrum : 1-D array
7611             The values for the angle spectrum in radians (real valued).
7612 
7613         freqs : 1-D array
7614             The frequencies corresponding to the elements in *spectrum*.
7615 
7616         line : `~matplotlib.lines.Line2D`
7617             The line created by this function.
7618 
7619         Other Parameters
7620         ----------------
7621         data : indexable object, optional
7622             DATA_PARAMETER_PLACEHOLDER
7623 
7624         **kwargs
7625             Keyword arguments control the `.Line2D` properties:
7626 
7627             %(Line2D:kwdoc)s
7628 
7629         See Also
7630         --------
7631         magnitude_spectrum
7632             Plots the magnitudes of the corresponding frequencies.
7633         phase_spectrum
7634             Plots the unwrapped version of this function.
7635         specgram
7636             Can plot the angle spectrum of segments within the signal in a
7637             colormap.
7638         """
7639         if Fc is None:
7640             Fc = 0
7641 
7642         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7643                                           pad_to=pad_to, sides=sides)
7644         freqs += Fc
7645 
7646         lines = self.plot(freqs, spec, **kwargs)
7647         self.set_xlabel('Frequency')
7648         self.set_ylabel('Angle (radians)')
7649 
7650         return spec, freqs, lines[0]
7651 
7652     @_preprocess_data(replace_names=["x"])
7653     @_docstring.dedent_interpd
7654     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7655                        pad_to=None, sides=None, **kwargs):
7656         """
7657         Plot the phase spectrum.
7658 
7659         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7660         Data is padded to a length of *pad_to* and the windowing function
7661         *window* is applied to the signal.
7662 
7663         Parameters
7664         ----------
7665         x : 1-D array or sequence
7666             Array or sequence containing the data
7667 
7668         %(Spectral)s
7669 
7670         %(Single_Spectrum)s
7671 
7672         Fc : int, default: 0
7673             The center frequency of *x*, which offsets the x extents of the
7674             plot to reflect the frequency range used when a signal is acquired
7675             and then filtered and downsampled to baseband.
7676 
7677         Returns
7678         -------
7679         spectrum : 1-D array
7680             The values for the phase spectrum in radians (real valued).
7681 
7682         freqs : 1-D array
7683             The frequencies corresponding to the elements in *spectrum*.
7684 
7685         line : `~matplotlib.lines.Line2D`
7686             The line created by this function.
7687 
7688         Other Parameters
7689         ----------------
7690         data : indexable object, optional
7691             DATA_PARAMETER_PLACEHOLDER
7692 
7693         **kwargs
7694             Keyword arguments control the `.Line2D` properties:
7695 
7696             %(Line2D:kwdoc)s
7697 
7698         See Also
7699         --------
7700         magnitude_spectrum
7701             Plots the magnitudes of the corresponding frequencies.
7702         angle_spectrum
7703             Plots the wrapped version of this function.
7704         specgram
7705             Can plot the phase spectrum of segments within the signal in a
7706             colormap.
7707         """
7708         if Fc is None:
7709             Fc = 0
7710 
7711         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7712                                           pad_to=pad_to, sides=sides)
7713         freqs += Fc
7714 
7715         lines = self.plot(freqs, spec, **kwargs)
7716         self.set_xlabel('Frequency')
7717         self.set_ylabel('Phase (radians)')
7718 
7719         return spec, freqs, lines[0]
7720 
7721     @_preprocess_data(replace_names=["x", "y"])
7722     @_docstring.dedent_interpd
7723     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7724                window=mlab.window_hanning, noverlap=0, pad_to=None,
7725                sides='default', scale_by_freq=None, **kwargs):
7726         r"""
7727         Plot the coherence between *x* and *y*.
7728 
7729         Coherence is the normalized cross spectral density:
7730 
7731         .. math::
7732 
7733           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7734 
7735         Parameters
7736         ----------
7737         %(Spectral)s
7738 
7739         %(PSD)s
7740 
7741         noverlap : int, default: 0 (no overlap)
7742             The number of points of overlap between blocks.
7743 
7744         Fc : int, default: 0
7745             The center frequency of *x*, which offsets the x extents of the
7746             plot to reflect the frequency range used when a signal is acquired
7747             and then filtered and downsampled to baseband.
7748 
7749         Returns
7750         -------
7751         Cxy : 1-D array
7752             The coherence vector.
7753 
7754         freqs : 1-D array
7755             The frequencies for the elements in *Cxy*.
7756 
7757         Other Parameters
7758         ----------------
7759         data : indexable object, optional
7760             DATA_PARAMETER_PLACEHOLDER
7761 
7762         **kwargs
7763             Keyword arguments control the `.Line2D` properties:
7764 
7765             %(Line2D:kwdoc)s
7766 
7767         References
7768         ----------
7769         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7770         John Wiley & Sons (1986)
7771         """
7772         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7773                                  window=window, noverlap=noverlap,
7774                                  scale_by_freq=scale_by_freq, sides=sides,
7775                                  pad_to=pad_to)
7776         freqs += Fc
7777 
7778         self.plot(freqs, cxy, **kwargs)
7779         self.set_xlabel('Frequency')
7780         self.set_ylabel('Coherence')
7781         self.grid(True)
7782 
7783         return cxy, freqs
7784 
7785     @_preprocess_data(replace_names=["x"])
7786     @_docstring.dedent_interpd
7787     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7788                  window=None, noverlap=None,
7789                  cmap=None, xextent=None, pad_to=None, sides=None,
7790                  scale_by_freq=None, mode=None, scale=None,
7791                  vmin=None, vmax=None, **kwargs):
7792         """
7793         Plot a spectrogram.
7794 
7795         Compute and plot a spectrogram of data in *x*.  Data are split into
7796         *NFFT* length segments and the spectrum of each section is
7797         computed.  The windowing function *window* is applied to each
7798         segment, and the amount of overlap of each segment is
7799         specified with *noverlap*. The spectrogram is plotted as a colormap
7800         (using imshow).
7801 
7802         Parameters
7803         ----------
7804         x : 1-D array or sequence
7805             Array or sequence containing the data.
7806 
7807         %(Spectral)s
7808 
7809         %(PSD)s
7810 
7811         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7812             What sort of spectrum to use.  Default is 'psd', which takes the
7813             power spectral density.  'magnitude' returns the magnitude
7814             spectrum.  'angle' returns the phase spectrum without unwrapping.
7815             'phase' returns the phase spectrum with unwrapping.
7816 
7817         noverlap : int, default: 128
7818             The number of points of overlap between blocks.
7819 
7820         scale : {'default', 'linear', 'dB'}
7821             The scaling of the values in the *spec*.  'linear' is no scaling.
7822             'dB' returns the values in dB scale.  When *mode* is 'psd',
7823             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7824             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7825             'magnitude' and 'linear' otherwise.  This must be 'linear'
7826             if *mode* is 'angle' or 'phase'.
7827 
7828         Fc : int, default: 0
7829             The center frequency of *x*, which offsets the x extents of the
7830             plot to reflect the frequency range used when a signal is acquired
7831             and then filtered and downsampled to baseband.
7832 
7833         cmap : `.Colormap`, default: :rc:`image.cmap`
7834 
7835         xextent : *None* or (xmin, xmax)
7836             The image extent along the x-axis. The default sets *xmin* to the
7837             left border of the first bin (*spectrum* column) and *xmax* to the
7838             right border of the last bin. Note that for *noverlap>0* the width
7839             of the bins is smaller than those of the segments.
7840 
7841         data : indexable object, optional
7842             DATA_PARAMETER_PLACEHOLDER
7843 
7844         **kwargs
7845             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7846             which makes the specgram image. The origin keyword argument
7847             is not supported.
7848 
7849         Returns
7850         -------
7851         spectrum : 2D array
7852             Columns are the periodograms of successive segments.
7853 
7854         freqs : 1-D array
7855             The frequencies corresponding to the rows in *spectrum*.
7856 
7857         t : 1-D array
7858             The times corresponding to midpoints of segments (i.e., the columns
7859             in *spectrum*).
7860 
7861         im : `.AxesImage`
7862             The image created by imshow containing the spectrogram.
7863 
7864         See Also
7865         --------
7866         psd
7867             Differs in the default overlap; in returning the mean of the
7868             segment periodograms; in not returning times; and in generating a
7869             line plot instead of colormap.
7870         magnitude_spectrum
7871             A single spectrum, similar to having a single segment when *mode*
7872             is 'magnitude'. Plots a line instead of a colormap.
7873         angle_spectrum
7874             A single spectrum, similar to having a single segment when *mode*
7875             is 'angle'. Plots a line instead of a colormap.
7876         phase_spectrum
7877             A single spectrum, similar to having a single segment when *mode*
7878             is 'phase'. Plots a line instead of a colormap.
7879 
7880         Notes
7881         -----
7882         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7883         is set to 'psd'.
7884         """
7885         if NFFT is None:
7886             NFFT = 256  # same default as in mlab.specgram()
7887         if Fc is None:
7888             Fc = 0  # same default as in mlab._spectral_helper()
7889         if noverlap is None:
7890             noverlap = 128  # same default as in mlab.specgram()
7891         if Fs is None:
7892             Fs = 2  # same default as in mlab._spectral_helper()
7893 
7894         if mode == 'complex':
7895             raise ValueError('Cannot plot a complex specgram')
7896 
7897         if scale is None or scale == 'default':
7898             if mode in ['angle', 'phase']:
7899                 scale = 'linear'
7900             else:
7901                 scale = 'dB'
7902         elif mode in ['angle', 'phase'] and scale == 'dB':
7903             raise ValueError('Cannot use dB scale with angle or phase mode')
7904 
7905         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7906                                        detrend=detrend, window=window,
7907                                        noverlap=noverlap, pad_to=pad_to,
7908                                        sides=sides,
7909                                        scale_by_freq=scale_by_freq,
7910                                        mode=mode)
7911 
7912         if scale == 'linear':
7913             Z = spec
7914         elif scale == 'dB':
7915             if mode is None or mode == 'default' or mode == 'psd':
7916                 Z = 10. * np.log10(spec)
7917             else:
7918                 Z = 20. * np.log10(spec)
7919         else:
7920             raise ValueError(f'Unknown scale {scale!r}')
7921 
7922         Z = np.flipud(Z)
7923 
7924         if xextent is None:
7925             # padding is needed for first and last segment:
7926             pad_xextent = (NFFT-noverlap) / Fs / 2
7927             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7928         xmin, xmax = xextent
7929         freqs += Fc
7930         extent = xmin, xmax, freqs[0], freqs[-1]
7931 
7932         if 'origin' in kwargs:
7933             raise _api.kwarg_error("specgram", "origin")
7934 
7935         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7936                          origin='upper', **kwargs)
7937         self.axis('auto')
7938 
7939         return spec, freqs, t, im
7940 
7941     @_docstring.dedent_interpd
7942     def spy(self, Z, precision=0, marker=None, markersize=None,
7943             aspect='equal', origin="upper", **kwargs):
7944         """
7945         Plot the sparsity pattern of a 2D array.
7946 
7947         This visualizes the non-zero values of the array.
7948 
7949         Two plotting styles are available: image and marker. Both
7950         are available for full arrays, but only the marker style
7951         works for `scipy.sparse.spmatrix` instances.
7952 
7953         **Image style**
7954 
7955         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7956         extra remaining keyword arguments are passed to this method.
7957 
7958         **Marker style**
7959 
7960         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7961         *None*, a `.Line2D` object will be returned with the value of marker
7962         determining the marker type, and any remaining keyword arguments
7963         passed to `~.Axes.plot`.
7964 
7965         Parameters
7966         ----------
7967         Z : (M, N) array-like
7968             The array to be plotted.
7969 
7970         precision : float or 'present', default: 0
7971             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7972             values of :math:`|Z| > precision` will be plotted.
7973 
7974             For `scipy.sparse.spmatrix` instances, you can also
7975             pass 'present'. In this case any value present in the array
7976             will be plotted, even if it is identically zero.
7977 
7978         aspect : {'equal', 'auto', None} or float, default: 'equal'
7979             The aspect ratio of the Axes.  This parameter is particularly
7980             relevant for images since it determines whether data pixels are
7981             square.
7982 
7983             This parameter is a shortcut for explicitly calling
7984             `.Axes.set_aspect`. See there for further details.
7985 
7986             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7987             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7988               that the data fit in the Axes. In general, this will result in
7989               non-square pixels.
7990             - *None*: Use :rc:`image.aspect`.
7991 
7992         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7993             Place the [0, 0] index of the array in the upper left or lower left
7994             corner of the Axes. The convention 'upper' is typically used for
7995             matrices and images.
7996 
7997         Returns
7998         -------
7999         `~matplotlib.image.AxesImage` or `.Line2D`
8000             The return type depends on the plotting style (see above).
8001 
8002         Other Parameters
8003         ----------------
8004         **kwargs
8005             The supported additional parameters depend on the plotting style.
8006 
8007             For the image style, you can pass the following additional
8008             parameters of `~.Axes.imshow`:
8009 
8010             - *cmap*
8011             - *alpha*
8012             - *url*
8013             - any `.Artist` properties (passed on to the `.AxesImage`)
8014 
8015             For the marker style, you can pass any `.Line2D` property except
8016             for *linestyle*:
8017 
8018             %(Line2D:kwdoc)s
8019         """
8020         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8021             marker = 's'
8022         _api.check_in_list(["upper", "lower"], origin=origin)
8023         if marker is None and markersize is None:
8024             Z = np.asarray(Z)
8025             mask = np.abs(Z) > precision
8026 
8027             if 'cmap' not in kwargs:
8028                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8029                                                         name='binary')
8030             if 'interpolation' in kwargs:
8031                 raise _api.kwarg_error("spy", "interpolation")
8032             if 'norm' not in kwargs:
8033                 kwargs['norm'] = mcolors.NoNorm()
8034             ret = self.imshow(mask, interpolation='nearest',
8035                               aspect=aspect, origin=origin,
8036                               **kwargs)
8037         else:
8038             if hasattr(Z, 'tocoo'):
8039                 c = Z.tocoo()
8040                 if precision == 'present':
8041                     y = c.row
8042                     x = c.col
8043                 else:
8044                     nonzero = np.abs(c.data) > precision
8045                     y = c.row[nonzero]
8046                     x = c.col[nonzero]
8047             else:
8048                 Z = np.asarray(Z)
8049                 nonzero = np.abs(Z) > precision
8050                 y, x = np.nonzero(nonzero)
8051             if marker is None:
8052                 marker = 's'
8053             if markersize is None:
8054                 markersize = 10
8055             if 'linestyle' in kwargs:
8056                 raise _api.kwarg_error("spy", "linestyle")
8057             ret = mlines.Line2D(
8058                 x, y, linestyle='None', marker=marker, markersize=markersize,
8059                 **kwargs)
8060             self.add_line(ret)
8061             nr, nc = Z.shape
8062             self.set_xlim(-0.5, nc - 0.5)
8063             if origin == "upper":
8064                 self.set_ylim(nr - 0.5, -0.5)
8065             else:
8066                 self.set_ylim(-0.5, nr - 0.5)
8067             self.set_aspect(aspect)
8068         self.title.set_y(1.05)
8069         if origin == "upper":
8070             self.xaxis.tick_top()
8071         else:  # lower
8072             self.xaxis.tick_bottom()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return ret
8079 
8080     def matshow(self, Z, **kwargs):
8081         """
8082         Plot the values of a 2D matrix or array as color-coded image.
8083 
8084         The matrix will be shown the way it would be printed, with the first
8085         row at the top.  Row and column numbering is zero-based.
8086 
8087         Parameters
8088         ----------
8089         Z : (M, N) array-like
8090             The matrix to be displayed.
8091 
8092         Returns
8093         -------
8094         `~matplotlib.image.AxesImage`
8095 
8096         Other Parameters
8097         ----------------
8098         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8099 
8100         See Also
8101         --------
8102         imshow : More general function to plot data on a 2D regular raster.
8103 
8104         Notes
8105         -----
8106         This is just a convenience function wrapping `.imshow` to set useful
8107         defaults for displaying a matrix. In particular:
8108 
8109         - Set ``origin='upper'``.
8110         - Set ``interpolation='nearest'``.
8111         - Set ``aspect='equal'``.
8112         - Ticks are placed to the left and above.
8113         - Ticks are formatted to show integer indices.
8114 
8115         """
8116         Z = np.asanyarray(Z)
8117         kw = {'origin': 'upper',
8118               'interpolation': 'nearest',
8119               'aspect': 'equal',          # (already the imshow default)
8120               **kwargs}
8121         im = self.imshow(Z, **kw)
8122         self.title.set_y(1.05)
8123         self.xaxis.tick_top()
8124         self.xaxis.set_ticks_position('both')
8125         self.xaxis.set_major_locator(
8126             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8127         self.yaxis.set_major_locator(
8128             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8129         return im
8130 
8131     @_preprocess_data(replace_names=["dataset"])
8132     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8133                    showmeans=False, showextrema=True, showmedians=False,
8134                    quantiles=None, points=100, bw_method=None):
8135         """
8136         Make a violin plot.
8137 
8138         Make a violin plot for each column of *dataset* or each vector in
8139         sequence *dataset*.  Each filled area extends to represent the
8140         entire data range, with optional lines at the mean, the median,
8141         the minimum, the maximum, and user-specified quantiles.
8142 
8143         Parameters
8144         ----------
8145         dataset : Array or a sequence of vectors.
8146           The input data.
8147 
8148         positions : array-like, default: [1, 2, ..., n]
8149           The positions of the violins. The ticks and limits are
8150           automatically set to match the positions.
8151 
8152         vert : bool, default: True.
8153           If true, creates a vertical violin plot.
8154           Otherwise, creates a horizontal violin plot.
8155 
8156         widths : array-like, default: 0.5
8157           Either a scalar or a vector that sets the maximal width of
8158           each violin. The default is 0.5, which uses about half of the
8159           available horizontal space.
8160 
8161         showmeans : bool, default: False
8162           If `True`, will toggle rendering of the means.
8163 
8164         showextrema : bool, default: True
8165           If `True`, will toggle rendering of the extrema.
8166 
8167         showmedians : bool, default: False
8168           If `True`, will toggle rendering of the medians.
8169 
8170         quantiles : array-like, default: None
8171           If not None, set a list of floats in interval [0, 1] for each violin,
8172           which stands for the quantiles that will be rendered for that
8173           violin.
8174 
8175         points : int, default: 100
8176           Defines the number of points to evaluate each of the
8177           gaussian kernel density estimations at.
8178 
8179         bw_method : str, scalar or callable, optional
8180           The method used to calculate the estimator bandwidth.  This can be
8181           'scott', 'silverman', a scalar constant or a callable.  If a
8182           scalar, this will be used directly as `kde.factor`.  If a
8183           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8184           its only parameter and return a scalar. If None (default), 'scott'
8185           is used.
8186 
8187         data : indexable object, optional
8188             DATA_PARAMETER_PLACEHOLDER
8189 
8190         Returns
8191         -------
8192         dict
8193           A dictionary mapping each component of the violinplot to a
8194           list of the corresponding collection instances created. The
8195           dictionary has the following keys:
8196 
8197           - ``bodies``: A list of the `~.collections.PolyCollection`
8198             instances containing the filled area of each violin.
8199 
8200           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8201             the mean values of each of the violin's distribution.
8202 
8203           - ``cmins``: A `~.collections.LineCollection` instance that marks
8204             the bottom of each violin's distribution.
8205 
8206           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8207             the top of each violin's distribution.
8208 
8209           - ``cbars``: A `~.collections.LineCollection` instance that marks
8210             the centers of each violin's distribution.
8211 
8212           - ``cmedians``: A `~.collections.LineCollection` instance that
8213             marks the median values of each of the violin's distribution.
8214 
8215           - ``cquantiles``: A `~.collections.LineCollection` instance created
8216             to identify the quantile values of each of the violin's
8217             distribution.
8218 
8219         """
8220 
8221         def _kde_method(X, coords):
8222             # Unpack in case of e.g. Pandas or xarray object
8223             X = cbook._unpack_to_numpy(X)
8224             # fallback gracefully if the vector contains only one value
8225             if np.all(X[0] == X):
8226                 return (X[0] == coords).astype(float)
8227             kde = mlab.GaussianKDE(X, bw_method)
8228             return kde.evaluate(coords)
8229 
8230         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8231                                      quantiles=quantiles)
8232         return self.violin(vpstats, positions=positions, vert=vert,
8233                            widths=widths, showmeans=showmeans,
8234                            showextrema=showextrema, showmedians=showmedians)
8235 
8236     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8237                showmeans=False, showextrema=True, showmedians=False):
8238         """
8239         Drawing function for violin plots.
8240 
8241         Draw a violin plot for each column of *vpstats*. Each filled area
8242         extends to represent the entire data range, with optional lines at the
8243         mean, the median, the minimum, the maximum, and the quantiles values.
8244 
8245         Parameters
8246         ----------
8247         vpstats : list of dicts
8248           A list of dictionaries containing stats for each violin plot.
8249           Required keys are:
8250 
8251           - ``coords``: A list of scalars containing the coordinates that
8252             the violin's kernel density estimate were evaluated at.
8253 
8254           - ``vals``: A list of scalars containing the values of the
8255             kernel density estimate at each of the coordinates given
8256             in *coords*.
8257 
8258           - ``mean``: The mean value for this violin's dataset.
8259 
8260           - ``median``: The median value for this violin's dataset.
8261 
8262           - ``min``: The minimum value for this violin's dataset.
8263 
8264           - ``max``: The maximum value for this violin's dataset.
8265 
8266           Optional keys are:
8267 
8268           - ``quantiles``: A list of scalars containing the quantile values
8269             for this violin's dataset.
8270 
8271         positions : array-like, default: [1, 2, ..., n]
8272           The positions of the violins. The ticks and limits are
8273           automatically set to match the positions.
8274 
8275         vert : bool, default: True.
8276           If true, plots the violins vertically.
8277           Otherwise, plots the violins horizontally.
8278 
8279         widths : array-like, default: 0.5
8280           Either a scalar or a vector that sets the maximal width of
8281           each violin. The default is 0.5, which uses about half of the
8282           available horizontal space.
8283 
8284         showmeans : bool, default: False
8285           If true, will toggle rendering of the means.
8286 
8287         showextrema : bool, default: True
8288           If true, will toggle rendering of the extrema.
8289 
8290         showmedians : bool, default: False
8291           If true, will toggle rendering of the medians.
8292 
8293         Returns
8294         -------
8295         dict
8296           A dictionary mapping each component of the violinplot to a
8297           list of the corresponding collection instances created. The
8298           dictionary has the following keys:
8299 
8300           - ``bodies``: A list of the `~.collections.PolyCollection`
8301             instances containing the filled area of each violin.
8302 
8303           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8304             the mean values of each of the violin's distribution.
8305 
8306           - ``cmins``: A `~.collections.LineCollection` instance that marks
8307             the bottom of each violin's distribution.
8308 
8309           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8310             the top of each violin's distribution.
8311 
8312           - ``cbars``: A `~.collections.LineCollection` instance that marks
8313             the centers of each violin's distribution.
8314 
8315           - ``cmedians``: A `~.collections.LineCollection` instance that
8316             marks the median values of each of the violin's distribution.
8317 
8318           - ``cquantiles``: A `~.collections.LineCollection` instance created
8319             to identify the quantiles values of each of the violin's
8320             distribution.
8321         """
8322 
8323         # Statistical quantities to be plotted on the violins
8324         means = []
8325         mins = []
8326         maxes = []
8327         medians = []
8328         quantiles = []
8329 
8330         qlens = []  # Number of quantiles in each dataset.
8331 
8332         artists = {}  # Collections to be returned
8333 
8334         N = len(vpstats)
8335         datashape_message = ("List of violinplot statistics and `{0}` "
8336                              "values must have the same length")
8337 
8338         # Validate positions
8339         if positions is None:
8340             positions = range(1, N + 1)
8341         elif len(positions) != N:
8342             raise ValueError(datashape_message.format("positions"))
8343 
8344         # Validate widths
8345         if np.isscalar(widths):
8346             widths = [widths] * N
8347         elif len(widths) != N:
8348             raise ValueError(datashape_message.format("widths"))
8349 
8350         # Calculate ranges for statistics lines (shape (2, N)).
8351         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8352 
8353         # Colors.
8354         if mpl.rcParams['_internal.classic_mode']:
8355             fillcolor = 'y'
8356             linecolor = 'r'
8357         else:
8358             fillcolor = linecolor = self._get_lines.get_next_color()
8359 
8360         # Check whether we are rendering vertically or horizontally
8361         if vert:
8362             fill = self.fill_betweenx
8363             perp_lines = functools.partial(self.hlines, colors=linecolor)
8364             par_lines = functools.partial(self.vlines, colors=linecolor)
8365         else:
8366             fill = self.fill_between
8367             perp_lines = functools.partial(self.vlines, colors=linecolor)
8368             par_lines = functools.partial(self.hlines, colors=linecolor)
8369 
8370         # Render violins
8371         bodies = []
8372         for stats, pos, width in zip(vpstats, positions, widths):
8373             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8374             vals = np.array(stats['vals'])
8375             vals = 0.5 * width * vals / vals.max()
8376             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8377                             facecolor=fillcolor, alpha=0.3)]
8378             means.append(stats['mean'])
8379             mins.append(stats['min'])
8380             maxes.append(stats['max'])
8381             medians.append(stats['median'])
8382             q = stats.get('quantiles')  # a list of floats, or None
8383             if q is None:
8384                 q = []
8385             quantiles.extend(q)
8386             qlens.append(len(q))
8387         artists['bodies'] = bodies
8388 
8389         if showmeans:  # Render means
8390             artists['cmeans'] = perp_lines(means, *line_ends)
8391         if showextrema:  # Render extrema
8392             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8393             artists['cmins'] = perp_lines(mins, *line_ends)
8394             artists['cbars'] = par_lines(positions, mins, maxes)
8395         if showmedians:  # Render medians
8396             artists['cmedians'] = perp_lines(medians, *line_ends)
8397         if quantiles:  # Render quantiles: each width is repeated qlen times.
8398             artists['cquantiles'] = perp_lines(
8399                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8400 
8401         return artists
8402 
8403     # Methods that are entirely implemented in other modules.
8404 
8405     table = mtable.table
8406 
8407     # args can be either Y or y1, y2, ... and all should be replaced
8408     stackplot = _preprocess_data()(mstack.stackplot)
8409 
8410     streamplot = _preprocess_data(
8411         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8412 
8413     tricontour = mtri.tricontour
8414     tricontourf = mtri.tricontourf
8415     tripcolor = mtri.tripcolor
8416     triplot = mtri.triplot
8417 
8418     def _get_aspect_ratio(self):
8419         """
8420         Convenience method to calculate the aspect ratio of the axes in
8421         the display coordinate system.
8422         """
8423         figure_size = self.get_figure().get_size_inches()
8424         ll, ur = self.get_position() * figure_size
8425         width, height = ur - ll
8426         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/contour.py</file>
<class>ContourSet</class>
<method>None</method>
<code>
706 class ContourSet(ContourLabeler, mcoll.Collection):
707     """
708     Store a set of contour lines or filled regions.
709 
710     User-callable method: `~.Axes.clabel`
711 
712     Parameters
713     ----------
714     ax : `~matplotlib.axes.Axes`
715 
716     levels : [level0, level1, ..., leveln]
717         A list of floating point numbers indicating the contour levels.
718 
719     allsegs : [level0segs, level1segs, ...]
720         List of all the polygon segments for all the *levels*.
721         For contour lines ``len(allsegs) == len(levels)``, and for
722         filled contour regions ``len(allsegs) = len(levels)-1``. The lists
723         should look like ::
724 
725             level0segs = [polygon0, polygon1, ...]
726             polygon0 = [[x0, y0], [x1, y1], ...]
727 
728     allkinds : ``None`` or [level0kinds, level1kinds, ...]
729         Optional list of all the polygon vertex kinds (code types), as
730         described and used in Path. This is used to allow multiply-
731         connected paths such as holes within filled polygons.
732         If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
733         should look like ::
734 
735             level0kinds = [polygon0kinds, ...]
736             polygon0kinds = [vertexcode0, vertexcode1, ...]
737 
738         If *allkinds* is not ``None``, usually all polygons for a
739         particular contour level are grouped together so that
740         ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.
741 
742     **kwargs
743         Keyword arguments are as described in the docstring of
744         `~.Axes.contour`.
745 
746     %(contour_set_attributes)s
747     """
748 
749     def __init__(self, ax, *args,
750                  levels=None, filled=False, linewidths=None, linestyles=None,
751                  hatches=(None,), alpha=None, origin=None, extent=None,
752                  cmap=None, colors=None, norm=None, vmin=None, vmax=None,
753                  extend='neither', antialiased=None, nchunk=0, locator=None,
754                  transform=None, negative_linestyles=None,
755                  **kwargs):
756         """
757         Draw contour lines or filled regions, depending on
758         whether keyword arg *filled* is ``False`` (default) or ``True``.
759 
760         Call signature::
761 
762             ContourSet(ax, levels, allsegs, [allkinds], **kwargs)
763 
764         Parameters
765         ----------
766         ax : `~matplotlib.axes.Axes`
767             The `~.axes.Axes` object to draw on.
768 
769         levels : [level0, level1, ..., leveln]
770             A list of floating point numbers indicating the contour
771             levels.
772 
773         allsegs : [level0segs, level1segs, ...]
774             List of all the polygon segments for all the *levels*.
775             For contour lines ``len(allsegs) == len(levels)``, and for
776             filled contour regions ``len(allsegs) = len(levels)-1``. The lists
777             should look like ::
778 
779                 level0segs = [polygon0, polygon1, ...]
780                 polygon0 = [[x0, y0], [x1, y1], ...]
781 
782         allkinds : [level0kinds, level1kinds, ...], optional
783             Optional list of all the polygon vertex kinds (code types), as
784             described and used in Path. This is used to allow multiply-
785             connected paths such as holes within filled polygons.
786             If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
787             should look like ::
788 
789                 level0kinds = [polygon0kinds, ...]
790                 polygon0kinds = [vertexcode0, vertexcode1, ...]
791 
792             If *allkinds* is not ``None``, usually all polygons for a
793             particular contour level are grouped together so that
794             ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.
795 
796         **kwargs
797             Keyword arguments are as described in the docstring of
798             `~.Axes.contour`.
799         """
800         if antialiased is None and filled:
801             # Eliminate artifacts; we are not stroking the boundaries.
802             antialiased = False
803             # The default for line contours will be taken from the
804             # LineCollection default, which uses :rc:`lines.antialiased`.
805         super().__init__(
806             antialiaseds=antialiased,
807             alpha=alpha,
808             transform=transform,
809         )
810         self.axes = ax
811         self.levels = levels
812         self.filled = filled
813         self.hatches = hatches
814         self.origin = origin
815         self.extent = extent
816         self.colors = colors
817         self.extend = extend
818 
819         self.nchunk = nchunk
820         self.locator = locator
821         if (isinstance(norm, mcolors.LogNorm)
822                 or isinstance(self.locator, ticker.LogLocator)):
823             self.logscale = True
824             if norm is None:
825                 norm = mcolors.LogNorm()
826         else:
827             self.logscale = False
828 
829         _api.check_in_list([None, 'lower', 'upper', 'image'], origin=origin)
830         if self.extent is not None and len(self.extent) != 4:
831             raise ValueError(
832                 "If given, 'extent' must be None or (x0, x1, y0, y1)")
833         if self.colors is not None and cmap is not None:
834             raise ValueError('Either colors or cmap must be None')
835         if self.origin == 'image':
836             self.origin = mpl.rcParams['image.origin']
837 
838         self._orig_linestyles = linestyles  # Only kept for user access.
839         self.negative_linestyles = negative_linestyles
840         # If negative_linestyles was not defined as a keyword argument, define
841         # negative_linestyles with rcParams
842         if self.negative_linestyles is None:
843             self.negative_linestyles = \
844                 mpl.rcParams['contour.negative_linestyle']
845 
846         kwargs = self._process_args(*args, **kwargs)
847         self._process_levels()
848 
849         self._extend_min = self.extend in ['min', 'both']
850         self._extend_max = self.extend in ['max', 'both']
851         if self.colors is not None:
852             ncolors = len(self.levels)
853             if self.filled:
854                 ncolors -= 1
855             i0 = 0
856 
857             # Handle the case where colors are given for the extended
858             # parts of the contour.
859 
860             use_set_under_over = False
861             # if we are extending the lower end, and we've been given enough
862             # colors then skip the first color in the resulting cmap. For the
863             # extend_max case we don't need to worry about passing more colors
864             # than ncolors as ListedColormap will clip.
865             total_levels = (ncolors +
866                             int(self._extend_min) +
867                             int(self._extend_max))
868             if (len(self.colors) == total_levels and
869                     (self._extend_min or self._extend_max)):
870                 use_set_under_over = True
871                 if self._extend_min:
872                     i0 = 1
873 
874             cmap = mcolors.ListedColormap(self.colors[i0:None], N=ncolors)
875 
876             if use_set_under_over:
877                 if self._extend_min:
878                     cmap.set_under(self.colors[0])
879                 if self._extend_max:
880                     cmap.set_over(self.colors[-1])
881 
882         # label lists must be initialized here
883         self.labelTexts = []
884         self.labelCValues = []
885 
886         self.set_cmap(cmap)
887         if norm is not None:
888             self.set_norm(norm)
889         if vmin is not None:
890             self.norm.vmin = vmin
891         if vmax is not None:
892             self.norm.vmax = vmax
893         self._process_colors()
894 
895         if self._paths is None:
896             self._paths = self._make_paths_from_contour_generator()
897 
898         if self.filled:
899             if linewidths is not None:
900                 _api.warn_external('linewidths is ignored by contourf')
901             # Lower and upper contour levels.
902             lowers, uppers = self._get_lowers_and_uppers()
903             self.set(
904                 edgecolor="none",
905                 # Default zorder taken from Collection
906                 zorder=kwargs.pop("zorder", 1),
907             )
908 
909         else:
910             self.set(
911                 facecolor="none",
912                 linewidths=self._process_linewidths(linewidths),
913                 linestyle=self._process_linestyles(linestyles),
914                 # Default zorder taken from LineCollection, which is higher
915                 # than for filled contours so that lines are displayed on top.
916                 zorder=kwargs.pop("zorder", 2),
917                 label="_nolegend_",
918             )
919 
920         self.axes.add_collection(self, autolim=False)
921         self.sticky_edges.x[:] = [self._mins[0], self._maxs[0]]
922         self.sticky_edges.y[:] = [self._mins[1], self._maxs[1]]
923         self.axes.update_datalim([self._mins, self._maxs])
924         self.axes.autoscale_view(tight=True)
925 
926         self.changed()  # set the colors
927 
928         if kwargs:
929             _api.warn_external(
930                 'The following kwargs were not used by contour: ' +
931                 ", ".join(map(repr, kwargs))
932             )
933 
934     allsegs = _api.deprecated("3.8", pending=True)(property(lambda self: [
935         p.vertices for c in self.collections for p in c.get_paths()]))
936     allkinds = _api.deprecated("3.8", pending=True)(property(lambda self: [
937         p.codes for c in self.collections for p in c.get_paths()]))
938     tcolors = _api.deprecated("3.8")(property(lambda self: [
939         (tuple(rgba),) for rgba in self.to_rgba(self.cvalues, self.alpha)]))
940     tlinewidths = _api.deprecated("3.8")(property(lambda self: [
941         (w,) for w in self.get_linewidths()]))
942     alpha = property(lambda self: self.get_alpha())
943     linestyles = property(lambda self: self._orig_linestyles)
944 
945     @_api.deprecated("3.8")
946     @property
947     def collections(self):
948         # On access, make oneself invisible and instead add the old-style collections
949         # (one PathCollection per level).  We do not try to further split contours into
950         # connected components as we already lost track of what pairs of contours need
951         # to be considered as single units to draw filled regions with holes.
952         if not hasattr(self, "_old_style_split_collections"):
953             self.set_visible(False)
954             fcs = self.get_facecolor()
955             ecs = self.get_edgecolor()
956             lws = self.get_linewidth()
957             lss = self.get_linestyle()
958             self._old_style_split_collections = []
959             for idx, path in enumerate(self._paths):
960                 pc = mcoll.PathCollection(
961                     [path] if len(path.vertices) else [],
962                     alpha=self.get_alpha(),
963                     antialiaseds=self._antialiaseds[idx % len(self._antialiaseds)],
964                     transform=self.get_transform(),
965                     zorder=self.get_zorder(),
966                     label="_nolegend_",
967                     facecolor=fcs[idx] if len(fcs) else "none",
968                     edgecolor=ecs[idx] if len(ecs) else "none",
969                     linewidths=[lws[idx % len(lws)]],
970                     linestyles=[lss[idx % len(lss)]],
971                 )
972                 if self.filled:
973                     pc.set(hatch=self.hatches[idx % len(self.hatches)])
974                 self._old_style_split_collections.append(pc)
975             for col in self._old_style_split_collections:
976                 self.axes.add_collection(col)
977         return self._old_style_split_collections
978 
979     def get_transform(self):
980         """Return the `.Transform` instance used by this ContourSet."""
981         if self._transform is None:
982             self._transform = self.axes.transData
983         elif (not isinstance(self._transform, mtransforms.Transform)
984               and hasattr(self._transform, '_as_mpl_transform')):
985             self._transform = self._transform._as_mpl_transform(self.axes)
986         return self._transform
987 
988     def __getstate__(self):
989         state = self.__dict__.copy()
990         # the C object _contour_generator cannot currently be pickled. This
991         # isn't a big issue as it is not actually used once the contour has
992         # been calculated.
993         state['_contour_generator'] = None
994         return state
995 
996     def legend_elements(self, variable_name='x', str_format=str):
997         """
998         Return a list of artists and labels suitable for passing through
999         to `~.Axes.legend` which represent this ContourSet.
1000 
1001         The labels have the form "0 < x <= 1" stating the data ranges which
1002         the artists represent.
1003 
1004         Parameters
1005         ----------
1006         variable_name : str
1007             The string used inside the inequality used on the labels.
1008         str_format : function: float -> str
1009             Function used to format the numbers in the labels.
1010 
1011         Returns
1012         -------
1013         artists : list[`.Artist`]
1014             A list of the artists.
1015         labels : list[str]
1016             A list of the labels.
1017         """
1018         artists = []
1019         labels = []
1020 
1021         if self.filled:
1022             lowers, uppers = self._get_lowers_and_uppers()
1023             n_levels = len(self._paths)
1024             for idx in range(n_levels):
1025                 artists.append(mpatches.Rectangle(
1026                     (0, 0), 1, 1,
1027                     facecolor=self.get_facecolor()[idx],
1028                     hatch=self.hatches[idx % len(self.hatches)],
1029                 ))
1030                 lower = str_format(lowers[idx])
1031                 upper = str_format(uppers[idx])
1032                 if idx == 0 and self.extend in ('min', 'both'):
1033                     labels.append(fr'${variable_name} \leq {lower}s$')
1034                 elif idx == n_levels - 1 and self.extend in ('max', 'both'):
1035                     labels.append(fr'${variable_name} > {upper}s$')
1036                 else:
1037                     labels.append(fr'${lower} < {variable_name} \leq {upper}$')
1038         else:
1039             for idx, level in enumerate(self.levels):
1040                 artists.append(Line2D(
1041                     [], [],
1042                     color=self.get_edgecolor()[idx],
1043                     linewidth=self.get_linewidths()[idx],
1044                     linestyle=self.get_linestyles()[idx],
1045                 ))
1046                 labels.append(fr'${variable_name} = {str_format(level)}$')
1047 
1048         return artists, labels
1049 
1050     def _process_args(self, *args, **kwargs):
1051         """
1052         Process *args* and *kwargs*; override in derived classes.
1053 
1054         Must set self.levels, self.zmin and self.zmax, and update axes limits.
1055         """
1056         self.levels = args[0]
1057         allsegs = args[1]
1058         allkinds = args[2] if len(args) > 2 else None
1059         self.zmax = np.max(self.levels)
1060         self.zmin = np.min(self.levels)
1061 
1062         if allkinds is None:
1063             allkinds = [[None] * len(segs) for segs in allsegs]
1064 
1065         # Check lengths of levels and allsegs.
1066         if self.filled:
1067             if len(allsegs) != len(self.levels) - 1:
1068                 raise ValueError('must be one less number of segments as '
1069                                  'levels')
1070         else:
1071             if len(allsegs) != len(self.levels):
1072                 raise ValueError('must be same number of segments as levels')
1073 
1074         # Check length of allkinds.
1075         if len(allkinds) != len(allsegs):
1076             raise ValueError('allkinds has different length to allsegs')
1077 
1078         # Determine x, y bounds and update axes data limits.
1079         flatseglist = [s for seg in allsegs for s in seg]
1080         points = np.concatenate(flatseglist, axis=0)
1081         self._mins = points.min(axis=0)
1082         self._maxs = points.max(axis=0)
1083 
1084         # Each entry in (allsegs, allkinds) is a list of (segs, kinds): segs is a list
1085         # of (N, 2) arrays of xy coordinates, kinds is a list of arrays of corresponding
1086         # pathcodes.  However, kinds can also be None; in which case all paths in that
1087         # list are codeless (this case is normalized above).  These lists are used to
1088         # construct paths, which then get concatenated.
1089         self._paths = [Path.make_compound_path(*map(Path, segs, kinds))
1090                        for segs, kinds in zip(allsegs, allkinds)]
1091 
1092         return kwargs
1093 
1094     def _make_paths_from_contour_generator(self):
1095         """Compute ``paths`` using C extension."""
1096         if self._paths is not None:
1097             return self._paths
1098         paths = []
1099         empty_path = Path(np.empty((0, 2)))
1100         if self.filled:
1101             lowers, uppers = self._get_lowers_and_uppers()
1102             for level, level_upper in zip(lowers, uppers):
1103                 vertices, kinds = \
1104                     self._contour_generator.create_filled_contour(
1105                         level, level_upper)
1106                 paths.append(Path(np.concatenate(vertices), np.concatenate(kinds))
1107                              if len(vertices) else empty_path)
1108         else:
1109             for level in self.levels:
1110                 vertices, kinds = self._contour_generator.create_contour(level)
1111                 paths.append(Path(np.concatenate(vertices), np.concatenate(kinds))
1112                              if len(vertices) else empty_path)
1113         return paths
1114 
1115     def _get_lowers_and_uppers(self):
1116         """
1117         Return ``(lowers, uppers)`` for filled contours.
1118         """
1119         lowers = self._levels[:-1]
1120         if self.zmin == lowers[0]:
1121             # Include minimum values in lowest interval
1122             lowers = lowers.copy()  # so we don't change self._levels
1123             if self.logscale:
1124                 lowers[0] = 0.99 * self.zmin
1125             else:
1126                 lowers[0] -= 1
1127         uppers = self._levels[1:]
1128         return (lowers, uppers)
1129 
1130     def changed(self):
1131         if not hasattr(self, "cvalues"):
1132             self._process_colors()  # Sets cvalues.
1133         # Force an autoscale immediately because self.to_rgba() calls
1134         # autoscale_None() internally with the data passed to it,
1135         # so if vmin/vmax are not set yet, this would override them with
1136         # content from *cvalues* rather than levels like we want
1137         self.norm.autoscale_None(self.levels)
1138         self.set_array(self.cvalues)
1139         self.update_scalarmappable()
1140         alphas = np.broadcast_to(self.get_alpha(), len(self.cvalues))
1141         for label, cv, alpha in zip(self.labelTexts, self.labelCValues, alphas):
1142             label.set_alpha(alpha)
1143             label.set_color(self.labelMappable.to_rgba(cv))
1144         super().changed()
1145 
1146     def _autolev(self, N):
1147         """
1148         Select contour levels to span the data.
1149 
1150         The target number of levels, *N*, is used only when the
1151         scale is not log and default locator is used.
1152 
1153         We need two more levels for filled contours than for
1154         line contours, because for the latter we need to specify
1155         the lower and upper boundary of each range. For example,
1156         a single contour boundary, say at z = 0, requires only
1157         one contour line, but two filled regions, and therefore
1158         three levels to provide boundaries for both regions.
1159         """
1160         if self.locator is None:
1161             if self.logscale:
1162                 self.locator = ticker.LogLocator()
1163             else:
1164                 self.locator = ticker.MaxNLocator(N + 1, min_n_ticks=1)
1165 
1166         lev = self.locator.tick_values(self.zmin, self.zmax)
1167 
1168         try:
1169             if self.locator._symmetric:
1170                 return lev
1171         except AttributeError:
1172             pass
1173 
1174         # Trim excess levels the locator may have supplied.
1175         under = np.nonzero(lev < self.zmin)[0]
1176         i0 = under[-1] if len(under) else 0
1177         over = np.nonzero(lev > self.zmax)[0]
1178         i1 = over[0] + 1 if len(over) else len(lev)
1179         if self.extend in ('min', 'both'):
1180             i0 += 1
1181         if self.extend in ('max', 'both'):
1182             i1 -= 1
1183 
1184         if i1 - i0 < 3:
1185             i0, i1 = 0, len(lev)
1186 
1187         return lev[i0:i1]
1188 
1189     def _process_contour_level_args(self, args, z_dtype):
1190         """
1191         Determine the contour levels and store in self.levels.
1192         """
1193         if self.levels is None:
1194             if args:
1195                 levels_arg = args[0]
1196             elif np.issubdtype(z_dtype, bool):
1197                 if self.filled:
1198                     levels_arg = [0, .5, 1]
1199                 else:
1200                     levels_arg = [.5]
1201             else:
1202                 levels_arg = 7  # Default, hard-wired.
1203         else:
1204             levels_arg = self.levels
1205         if isinstance(levels_arg, Integral):
1206             self.levels = self._autolev(levels_arg)
1207         else:
1208             self.levels = np.asarray(levels_arg, np.float64)
1209         if self.filled and len(self.levels) < 2:
1210             raise ValueError("Filled contours require at least 2 levels.")
1211         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:
1212             raise ValueError("Contour levels must be increasing")
1213 
1214     def _process_levels(self):
1215         """
1216         Assign values to :attr:`layers` based on :attr:`levels`,
1217         adding extended layers as needed if contours are filled.
1218 
1219         For line contours, layers simply coincide with levels;
1220         a line is a thin layer.  No extended levels are needed
1221         with line contours.
1222         """
1223         # Make a private _levels to include extended regions; we
1224         # want to leave the original levels attribute unchanged.
1225         # (Colorbar needs this even for line contours.)
1226         self._levels = list(self.levels)
1227 
1228         if self.logscale:
1229             lower, upper = 1e-250, 1e250
1230         else:
1231             lower, upper = -1e250, 1e250
1232 
1233         if self.extend in ('both', 'min'):
1234             self._levels.insert(0, lower)
1235         if self.extend in ('both', 'max'):
1236             self._levels.append(upper)
1237         self._levels = np.asarray(self._levels)
1238 
1239         if not self.filled:
1240             self.layers = self.levels
1241             return
1242 
1243         # Layer values are mid-way between levels in screen space.
1244         if self.logscale:
1245             # Avoid overflow by taking sqrt before multiplying.
1246             self.layers = (np.sqrt(self._levels[:-1])
1247                            * np.sqrt(self._levels[1:]))
1248         else:
1249             self.layers = 0.5 * (self._levels[:-1] + self._levels[1:])
1250 
1251     def _process_colors(self):
1252         """
1253         Color argument processing for contouring.
1254 
1255         Note that we base the colormapping on the contour levels
1256         and layers, not on the actual range of the Z values.  This
1257         means we don't have to worry about bad values in Z, and we
1258         always have the full dynamic range available for the selected
1259         levels.
1260 
1261         The color is based on the midpoint of the layer, except for
1262         extended end layers.  By default, the norm vmin and vmax
1263         are the extreme values of the non-extended levels.  Hence,
1264         the layer color extremes are not the extreme values of
1265         the colormap itself, but approach those values as the number
1266         of levels increases.  An advantage of this scheme is that
1267         line contours, when added to filled contours, take on
1268         colors that are consistent with those of the filled regions;
1269         for example, a contour line on the boundary between two
1270         regions will have a color intermediate between those
1271         of the regions.
1272 
1273         """
1274         self.monochrome = self.cmap.monochrome
1275         if self.colors is not None:
1276             # Generate integers for direct indexing.
1277             i0, i1 = 0, len(self.levels)
1278             if self.filled:
1279                 i1 -= 1
1280                 # Out of range indices for over and under:
1281                 if self.extend in ('both', 'min'):
1282                     i0 -= 1
1283                 if self.extend in ('both', 'max'):
1284                     i1 += 1
1285             self.cvalues = list(range(i0, i1))
1286             self.set_norm(mcolors.NoNorm())
1287         else:
1288             self.cvalues = self.layers
1289         self.norm.autoscale_None(self.levels)
1290         self.set_array(self.cvalues)
1291         self.update_scalarmappable()
1292         if self.extend in ('both', 'max', 'min'):
1293             self.norm.clip = False
1294 
1295     def _process_linewidths(self, linewidths):
1296         Nlev = len(self.levels)
1297         if linewidths is None:
1298             default_linewidth = mpl.rcParams['contour.linewidth']
1299             if default_linewidth is None:
1300                 default_linewidth = mpl.rcParams['lines.linewidth']
1301             return [default_linewidth] * Nlev
1302         elif not np.iterable(linewidths):
1303             return [linewidths] * Nlev
1304         else:
1305             linewidths = list(linewidths)
1306             return (linewidths * math.ceil(Nlev / len(linewidths)))[:Nlev]
1307 
1308     def _process_linestyles(self, linestyles):
1309         Nlev = len(self.levels)
1310         if linestyles is None:
1311             tlinestyles = ['solid'] * Nlev
1312             if self.monochrome:
1313                 eps = - (self.zmax - self.zmin) * 1e-15
1314                 for i, lev in enumerate(self.levels):
1315                     if lev < eps:
1316                         tlinestyles[i] = self.negative_linestyles
1317         else:
1318             if isinstance(linestyles, str):
1319                 tlinestyles = [linestyles] * Nlev
1320             elif np.iterable(linestyles):
1321                 tlinestyles = list(linestyles)
1322                 if len(tlinestyles) < Nlev:
1323                     nreps = int(np.ceil(Nlev / len(linestyles)))
1324                     tlinestyles = tlinestyles * nreps
1325                 if len(tlinestyles) > Nlev:
1326                     tlinestyles = tlinestyles[:Nlev]
1327             else:
1328                 raise ValueError("Unrecognized type for linestyles kwarg")
1329         return tlinestyles
1330 
1331     def _find_nearest_contour(self, xy, indices=None):
1332         """
1333         Find the point in the unfilled contour plot that is closest (in screen
1334         space) to point *xy*.
1335 
1336         Parameters
1337         ----------
1338         xy : tuple[float, float]
1339             The reference point (in screen space).
1340         indices : list of int or None, default: None
1341             Indices of contour levels to consider.  If None (the default), all levels
1342             are considered.
1343 
1344         Returns
1345         -------
1346         idx_level_min : int
1347             The index of the contour level closest to *xy*.
1348         idx_vtx_min : int
1349             The index of the `.Path` segment closest to *xy* (at that level).
1350         proj : (float, float)
1351             The point in the contour plot closest to *xy*.
1352         """
1353 
1354         # Convert each contour segment to pixel coordinates and then compare the given
1355         # point to those coordinates for each contour. This is fast enough in normal
1356         # cases, but speedups may be possible.
1357 
1358         if self.filled:
1359             raise ValueError("Method does not support filled contours")
1360 
1361         if indices is None:
1362             indices = range(len(self._paths))
1363 
1364         d2min = np.inf
1365         idx_level_min = idx_vtx_min = proj_min = None
1366 
1367         for idx_level in indices:
1368             path = self._paths[idx_level]
1369             if not len(path.vertices):
1370                 continue
1371             lc = self.get_transform().transform(path.vertices)
1372             d2, proj, leg = _find_closest_point_on_path(lc, xy)
1373             if d2 < d2min:
1374                 d2min = d2
1375                 idx_level_min = idx_level
1376                 idx_vtx_min = leg[1]
1377                 proj_min = proj
1378 
1379         return idx_level_min, idx_vtx_min, proj_min
1380 
1381     @_api.deprecated("3.8")
1382     def find_nearest_contour(self, x, y, indices=None, pixel=True):
1383         """
1384         Find the point in the contour plot that is closest to ``(x, y)``.
1385 
1386         This method does not support filled contours.
1387 
1388         Parameters
1389         ----------
1390         x, y : float
1391             The reference point.
1392         indices : list of int or None, default: None
1393             Indices of contour levels to consider.  If None (the default), all
1394             levels are considered.
1395         pixel : bool, default: True
1396             If *True*, measure distance in pixel (screen) space, which is
1397             useful for manual contour labeling; else, measure distance in axes
1398             space.
1399 
1400         Returns
1401         -------
1402         contour : `.Collection`
1403             The contour that is closest to ``(x, y)``.
1404         segment : int
1405             The index of the `.Path` in *contour* that is closest to
1406             ``(x, y)``.
1407         index : int
1408             The index of the path segment in *segment* that is closest to
1409             ``(x, y)``.
1410         xmin, ymin : float
1411             The point in the contour plot that is closest to ``(x, y)``.
1412         d2 : float
1413             The squared distance from ``(xmin, ymin)`` to ``(x, y)``.
1414         """
1415 
1416         # This function uses a method that is probably quite
1417         # inefficient based on converting each contour segment to
1418         # pixel coordinates and then comparing the given point to
1419         # those coordinates for each contour.  This will probably be
1420         # quite slow for complex contours, but for normal use it works
1421         # sufficiently well that the time is not noticeable.
1422         # Nonetheless, improvements could probably be made.
1423 
1424         if self.filled:
1425             raise ValueError("Method does not support filled contours.")
1426 
1427         if indices is None:
1428             indices = range(len(self.collections))
1429 
1430         d2min = np.inf
1431         conmin = None
1432         segmin = None
1433         imin = None
1434         xmin = None
1435         ymin = None
1436 
1437         point = np.array([x, y])
1438 
1439         for icon in indices:
1440             con = self.collections[icon]
1441             trans = con.get_transform()
1442             paths = con.get_paths()
1443 
1444             for segNum, linepath in enumerate(paths):
1445                 lc = linepath.vertices
1446                 # transfer all data points to screen coordinates if desired
1447                 if pixel:
1448                     lc = trans.transform(lc)
1449 
1450                 d2, xc, leg = _find_closest_point_on_path(lc, point)
1451                 if d2 < d2min:
1452                     d2min = d2
1453                     conmin = icon
1454                     segmin = segNum
1455                     imin = leg[1]
1456                     xmin = xc[0]
1457                     ymin = xc[1]
1458 
1459         return (conmin, segmin, imin, xmin, ymin, d2min)
1460 
1461     def draw(self, renderer):
1462         paths = self._paths
1463         n_paths = len(paths)
1464         if not self.filled or all(hatch is None for hatch in self.hatches):
1465             super().draw(renderer)
1466             return
1467         # In presence of hatching, draw contours one at a time.
1468         for idx in range(n_paths):
1469             with cbook._setattr_cm(self, _paths=[paths[idx]]), self._cm_set(
1470                 hatch=self.hatches[idx % len(self.hatches)],
1471                 array=[self.get_array()[idx]],
1472                 linewidths=[self.get_linewidths()[idx % len(self.get_linewidths())]],
1473                 linestyles=[self.get_linestyles()[idx % len(self.get_linestyles())]],
1474             ):
1475                 super().draw(renderer)

</code><intended_behavior>If adjustments in `axes/_axes.py` are insufficient alone and require changes at the `ContourSet` level, the `ContourSet` class may need a modification or a new method to properly accept and utilize the `clip_path` kwarg passed from `axes/_axes.py`. The modification could involve adjusting the `__init__` method or adding a new method that applies the `clip_path` to all constituent collections of the `ContourSet`. This might be accomplished by iterating over the collections in the `ContourSet` and applying the `clip_path` to each. The expected result is that the `ContourSet` object, when created or updated, would respect the `clip_path` by clipping the contours according to the specified path. This should be done while ensuring any other functionality and kwargs handling remains unaffected for backward compatibility.</intended_behavior>]
2025-10-15 07:53:21.333 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>contourf</method>
<code>
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours

</code><intended_behavior>The `contourf` method within the `Axes` class should be modified to ensure that `clip_path` kwarg is explicitly recognized and effectively passed to the `ContourSet` instantiation. This ensures the `clip_path` affects the plotting as intended. The method must maintain backward compatibility and all existing functionality, with the additional capability of handling the `clip_path` argument to clip the contours according to the specified path. The intended behavior is such that if a `clip_path` kwarg is present, it should be used to apply clipping to the contour plot, directly within the construction or setup of the `ContourSet` object, without the need for further adjustments post-creation.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `~matplotlib.text.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, kwargs = mlegend._parse_legend_args([self], *args, **kwargs)
320         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
321         self.legend_._remove_method = self._remove_legend
322         return self.legend_
323 
324     def _remove_legend(self, legend):
325         self.legend_ = None
326 
327     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
328         """
329         Add a child inset Axes to this existing Axes.
330 
331         Warnings
332         --------
333         This method is experimental as of 3.0, and the API may change.
334 
335         Parameters
336         ----------
337         bounds : [x0, y0, width, height]
338             Lower-left corner of inset Axes, and its width and height.
339 
340         transform : `.Transform`
341             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
342             Axes-relative coordinates.
343 
344         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
345 'polar', 'rectilinear', str}, optional
346             The projection type of the inset `~.axes.Axes`. *str* is the name
347             of a custom projection, see `~matplotlib.projections`. The default
348             None results in a 'rectilinear' projection.
349 
350         polar : bool, default: False
351             If True, equivalent to projection='polar'.
352 
353         axes_class : subclass type of `~.axes.Axes`, optional
354             The `.axes.Axes` subclass that is instantiated.  This parameter
355             is incompatible with *projection* and *polar*.  See
356             :ref:`axisartist_users-guide-index` for examples.
357 
358         zorder : number
359             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
360             to change whether it is above or below data plotted on the
361             parent Axes.
362 
363         **kwargs
364             Other keyword arguments are passed on to the inset Axes class.
365 
366         Returns
367         -------
368         ax
369             The created `~.axes.Axes` instance.
370 
371         Examples
372         --------
373         This example makes two inset Axes, the first is in Axes-relative
374         coordinates, and the second in data-coordinates::
375 
376             fig, ax = plt.subplots()
377             ax.plot(range(10))
378             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
379             axin2 = ax.inset_axes(
380                     [5, 7, 2.3, 2.3], transform=ax.transData)
381 
382         """
383         if transform is None:
384             transform = self.transAxes
385         kwargs.setdefault('label', 'inset_axes')
386 
387         # This puts the rectangle into figure-relative coordinates.
388         inset_locator = _TransformedBoundsLocator(bounds, transform)
389         bounds = inset_locator(self, None).bounds
390         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
391         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
392 
393         # this locator lets the axes move if in data coordinates.
394         # it gets called in `ax.apply_aspect() (of all places)
395         inset_ax.set_axes_locator(inset_locator)
396 
397         self.add_child_axes(inset_ax)
398 
399         return inset_ax
400 
401     @_docstring.dedent_interpd
402     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
403                        facecolor='none', edgecolor='0.5', alpha=0.5,
404                        zorder=4.99, **kwargs):
405         """
406         Add an inset indicator to the Axes.  This is a rectangle on the plot
407         at the position indicated by *bounds* that optionally has lines that
408         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
409 
410         Warnings
411         --------
412         This method is experimental as of 3.0, and the API may change.
413 
414         Parameters
415         ----------
416         bounds : [x0, y0, width, height]
417             Lower-left corner of rectangle to be marked, and its width
418             and height.
419 
420         inset_ax : `.Axes`
421             An optional inset Axes to draw connecting lines to.  Two lines are
422             drawn connecting the indicator box to the inset Axes on corners
423             chosen so as to not overlap with the indicator box.
424 
425         transform : `.Transform`
426             Transform for the rectangle coordinates. Defaults to
427             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
428             coordinates.
429 
430         facecolor : color, default: 'none'
431             Facecolor of the rectangle.
432 
433         edgecolor : color, default: '0.5'
434             Color of the rectangle and color of the connecting lines.
435 
436         alpha : float, default: 0.5
437             Transparency of the rectangle and connector lines.
438 
439         zorder : float, default: 4.99
440             Drawing order of the rectangle and connector lines.  The default,
441             4.99, is just below the default level of inset Axes.
442 
443         **kwargs
444             Other keyword arguments are passed on to the `.Rectangle` patch:
445 
446             %(Rectangle:kwdoc)s
447 
448         Returns
449         -------
450         rectangle_patch : `.patches.Rectangle`
451              The indicator frame.
452 
453         connector_lines : 4-tuple of `.patches.ConnectionPatch`
454             The four connector lines connecting to (lower_left, upper_left,
455             lower_right upper_right) corners of *inset_ax*. Two lines are
456             set with visibility to *False*,  but the user can set the
457             visibility to True if the automatic choice is not deemed correct.
458 
459         """
460         # to make the axes connectors work, we need to apply the aspect to
461         # the parent axes.
462         self.apply_aspect()
463 
464         if transform is None:
465             transform = self.transData
466         kwargs.setdefault('label', '_indicate_inset')
467 
468         x, y, width, height = bounds
469         rectangle_patch = mpatches.Rectangle(
470             (x, y), width, height,
471             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
472             zorder=zorder, transform=transform, **kwargs)
473         self.add_patch(rectangle_patch)
474 
475         connects = []
476 
477         if inset_ax is not None:
478             # connect the inset_axes to the rectangle
479             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
480                 # inset_ax positions are in axes coordinates
481                 # The 0, 1 values define the four edges if the inset_ax
482                 # lower_left, upper_left, lower_right upper_right.
483                 ex, ey = xy_inset_ax
484                 if self.xaxis.get_inverted():
485                     ex = 1 - ex
486                 if self.yaxis.get_inverted():
487                     ey = 1 - ey
488                 xy_data = x + ex * width, y + ey * height
489                 p = mpatches.ConnectionPatch(
490                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
491                     xyB=xy_data, coordsB=self.transData,
492                     arrowstyle="-", zorder=zorder,
493                     edgecolor=edgecolor, alpha=alpha)
494                 connects.append(p)
495                 self.add_patch(p)
496 
497             # decide which two of the lines to keep visible....
498             pos = inset_ax.get_position()
499             bboxins = pos.transformed(self.figure.transSubfigure)
500             rectbbox = mtransforms.Bbox.from_bounds(
501                 *bounds
502             ).transformed(transform)
503             x0 = rectbbox.x0 < bboxins.x0
504             x1 = rectbbox.x1 < bboxins.x1
505             y0 = rectbbox.y0 < bboxins.y0
506             y1 = rectbbox.y1 < bboxins.y1
507             connects[0].set_visible(x0 ^ y0)
508             connects[1].set_visible(x0 == y1)
509             connects[2].set_visible(x1 == y0)
510             connects[3].set_visible(x1 ^ y1)
511 
512         return rectangle_patch, tuple(connects) if connects else None
513 
514     def indicate_inset_zoom(self, inset_ax, **kwargs):
515         """
516         Add an inset indicator rectangle to the Axes based on the axis
517         limits for an *inset_ax* and draw connectors between *inset_ax*
518         and the rectangle.
519 
520         Warnings
521         --------
522         This method is experimental as of 3.0, and the API may change.
523 
524         Parameters
525         ----------
526         inset_ax : `.Axes`
527             Inset Axes to draw connecting lines to.  Two lines are
528             drawn connecting the indicator box to the inset Axes on corners
529             chosen so as to not overlap with the indicator box.
530 
531         **kwargs
532             Other keyword arguments are passed on to `.Axes.indicate_inset`
533 
534         Returns
535         -------
536         rectangle_patch : `.patches.Rectangle`
537              Rectangle artist.
538 
539         connector_lines : 4-tuple of `.patches.ConnectionPatch`
540             Each of four connector lines coming from the rectangle drawn on
541             this axis, in the order lower left, upper left, lower right,
542             upper right.
543             Two are set with visibility to *False*,  but the user can
544             set the visibility to *True* if the automatic choice is not deemed
545             correct.
546         """
547 
548         xlim = inset_ax.get_xlim()
549         ylim = inset_ax.get_ylim()
550         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
551         return self.indicate_inset(rect, inset_ax, **kwargs)
552 
553     @_docstring.dedent_interpd
554     def secondary_xaxis(self, location, *, functions=None, **kwargs):
555         """
556         Add a second x-axis to this `~.axes.Axes`.
557 
558         For example if we want to have a second scale for the data plotted on
559         the xaxis.
560 
561         %(_secax_docstring)s
562 
563         Examples
564         --------
565         The main axis shows frequency, and the secondary axis shows period.
566 
567         .. plot::
568 
569             fig, ax = plt.subplots()
570             ax.loglog(range(1, 360, 5), range(1, 360, 5))
571             ax.set_xlabel('frequency [Hz]')
572 
573             def invert(x):
574                 # 1/x with special treatment of x == 0
575                 x = np.array(x).astype(float)
576                 near_zero = np.isclose(x, 0)
577                 x[near_zero] = np.inf
578                 x[~near_zero] = 1 / x[~near_zero]
579                 return x
580 
581             # the inverse of 1/x is itself
582             secax = ax.secondary_xaxis('top', functions=(invert, invert))
583             secax.set_xlabel('Period [s]')
584             plt.show()
585         """
586         if location in ['top', 'bottom'] or isinstance(location, Real):
587             secondary_ax = SecondaryAxis(self, 'x', location, functions,
588                                          **kwargs)
589             self.add_child_axes(secondary_ax)
590             return secondary_ax
591         else:
592             raise ValueError('secondary_xaxis location must be either '
593                              'a float or "top"/"bottom"')
594 
595     @_docstring.dedent_interpd
596     def secondary_yaxis(self, location, *, functions=None, **kwargs):
597         """
598         Add a second y-axis to this `~.axes.Axes`.
599 
600         For example if we want to have a second scale for the data plotted on
601         the yaxis.
602 
603         %(_secax_docstring)s
604 
605         Examples
606         --------
607         Add a secondary Axes that converts from radians to degrees
608 
609         .. plot::
610 
611             fig, ax = plt.subplots()
612             ax.plot(range(1, 360, 5), range(1, 360, 5))
613             ax.set_ylabel('degrees')
614             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
615                                                            np.rad2deg))
616             secax.set_ylabel('radians')
617         """
618         if location in ['left', 'right'] or isinstance(location, Real):
619             secondary_ax = SecondaryAxis(self, 'y', location,
620                                          functions, **kwargs)
621             self.add_child_axes(secondary_ax)
622             return secondary_ax
623         else:
624             raise ValueError('secondary_yaxis location must be either '
625                              'a float or "left"/"right"')
626 
627     @_docstring.dedent_interpd
628     def text(self, x, y, s, fontdict=None, **kwargs):
629         """
630         Add text to the Axes.
631 
632         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
633 
634         Parameters
635         ----------
636         x, y : float
637             The position to place the text. By default, this is in data
638             coordinates. The coordinate system can be changed using the
639             *transform* parameter.
640 
641         s : str
642             The text.
643 
644         fontdict : dict, default: None
645 
646             .. admonition:: Discouraged
647 
648                The use of *fontdict* is discouraged. Parameters should be passed as
649                individual keyword arguments or using dictionary-unpacking
650                ``text(..., **fontdict)``.
651 
652             A dictionary to override the default text properties. If fontdict
653             is None, the defaults are determined by `.rcParams`.
654 
655         Returns
656         -------
657         `.Text`
658             The created `.Text` instance.
659 
660         Other Parameters
661         ----------------
662         **kwargs : `~matplotlib.text.Text` properties.
663             Other miscellaneous text parameters.
664 
665             %(Text:kwdoc)s
666 
667         Examples
668         --------
669         Individual keyword arguments can be used to override any given
670         parameter::
671 
672             >>> text(x, y, s, fontsize=12)
673 
674         The default transform specifies that text is in data coords,
675         alternatively, you can specify text in axis coords ((0, 0) is
676         lower-left and (1, 1) is upper-right).  The example below places
677         text in the center of the Axes::
678 
679             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
680             ...      verticalalignment='center', transform=ax.transAxes)
681 
682         You can put a rectangular box around the text instance (e.g., to
683         set a background color) by using the keyword *bbox*.  *bbox* is
684         a dictionary of `~matplotlib.patches.Rectangle`
685         properties.  For example::
686 
687             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
688         """
689         effective_kwargs = {
690             'verticalalignment': 'baseline',
691             'horizontalalignment': 'left',
692             'transform': self.transData,
693             'clip_on': False,
694             **(fontdict if fontdict is not None else {}),
695             **kwargs,
696         }
697         t = mtext.Text(x, y, text=s, **effective_kwargs)
698         if t.get_clip_path() is None:
699             t.set_clip_path(self.patch)
700         self._add_text(t)
701         return t
702 
703     @_docstring.dedent_interpd
704     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
705                  arrowprops=None, annotation_clip=None, **kwargs):
706         # Signature must match Annotation. This is verified in
707         # test_annotate_signature().
708         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
709                              textcoords=textcoords, arrowprops=arrowprops,
710                              annotation_clip=annotation_clip, **kwargs)
711         a.set_transform(mtransforms.IdentityTransform())
712         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
713             a.set_clip_path(self.patch)
714         self._add_text(a)
715         return a
716     annotate.__doc__ = mtext.Annotation.__init__.__doc__
717     #### Lines and spans
718 
719     @_docstring.dedent_interpd
720     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
721         """
722         Add a horizontal line across the Axes.
723 
724         Parameters
725         ----------
726         y : float, default: 0
727             y position in data coordinates of the horizontal line.
728 
729         xmin : float, default: 0
730             Should be between 0 and 1, 0 being the far left of the plot, 1 the
731             far right of the plot.
732 
733         xmax : float, default: 1
734             Should be between 0 and 1, 0 being the far left of the plot, 1 the
735             far right of the plot.
736 
737         Returns
738         -------
739         `~matplotlib.lines.Line2D`
740 
741         Other Parameters
742         ----------------
743         **kwargs
744             Valid keyword arguments are `.Line2D` properties, except for
745             'transform':
746 
747             %(Line2D:kwdoc)s
748 
749         See Also
750         --------
751         hlines : Add horizontal lines in data coordinates.
752         axhspan : Add a horizontal span (rectangle) across the axis.
753         axline : Add a line with an arbitrary slope.
754 
755         Examples
756         --------
757         * draw a thick red hline at 'y' = 0 that spans the xrange::
758 
759             >>> axhline(linewidth=4, color='r')
760 
761         * draw a default hline at 'y' = 1 that spans the xrange::
762 
763             >>> axhline(y=1)
764 
765         * draw a default hline at 'y' = .5 that spans the middle half of
766           the xrange::
767 
768             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
769         """
770         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
771         if "transform" in kwargs:
772             raise ValueError("'transform' is not allowed as a keyword "
773                              "argument; axhline generates its own transform.")
774         ymin, ymax = self.get_ybound()
775 
776         # Strip away the units for comparison with non-unitized bounds.
777         yy, = self._process_unit_info([("y", y)], kwargs)
778         scaley = (yy < ymin) or (yy > ymax)
779 
780         trans = self.get_yaxis_transform(which='grid')
781         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
782         self.add_line(l)
783         if scaley:
784             self._request_autoscale_view("y")
785         return l
786 
787     @_docstring.dedent_interpd
788     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
789         """
790         Add a vertical line across the Axes.
791 
792         Parameters
793         ----------
794         x : float, default: 0
795             x position in data coordinates of the vertical line.
796 
797         ymin : float, default: 0
798             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
799             top of the plot.
800 
801         ymax : float, default: 1
802             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
803             top of the plot.
804 
805         Returns
806         -------
807         `~matplotlib.lines.Line2D`
808 
809         Other Parameters
810         ----------------
811         **kwargs
812             Valid keyword arguments are `.Line2D` properties, except for
813             'transform':
814 
815             %(Line2D:kwdoc)s
816 
817         See Also
818         --------
819         vlines : Add vertical lines in data coordinates.
820         axvspan : Add a vertical span (rectangle) across the axis.
821         axline : Add a line with an arbitrary slope.
822 
823         Examples
824         --------
825         * draw a thick red vline at *x* = 0 that spans the yrange::
826 
827             >>> axvline(linewidth=4, color='r')
828 
829         * draw a default vline at *x* = 1 that spans the yrange::
830 
831             >>> axvline(x=1)
832 
833         * draw a default vline at *x* = .5 that spans the middle half of
834           the yrange::
835 
836             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
837         """
838         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
839         if "transform" in kwargs:
840             raise ValueError("'transform' is not allowed as a keyword "
841                              "argument; axvline generates its own transform.")
842         xmin, xmax = self.get_xbound()
843 
844         # Strip away the units for comparison with non-unitized bounds.
845         xx, = self._process_unit_info([("x", x)], kwargs)
846         scalex = (xx < xmin) or (xx > xmax)
847 
848         trans = self.get_xaxis_transform(which='grid')
849         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
850         self.add_line(l)
851         if scalex:
852             self._request_autoscale_view("x")
853         return l
854 
855     @staticmethod
856     def _check_no_units(vals, names):
857         # Helper method to check that vals are not unitized
858         for val, name in zip(vals, names):
859             if not munits._is_natively_supported(val):
860                 raise ValueError(f"{name} must be a single scalar value, "
861                                  f"but got {val}")
862 
863     @_docstring.dedent_interpd
864     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
865         """
866         Add an infinitely long straight line.
867 
868         The line can be defined either by two points *xy1* and *xy2*, or
869         by one point *xy1* and a *slope*.
870 
871         This draws a straight line "on the screen", regardless of the x and y
872         scales, and is thus also suitable for drawing exponential decays in
873         semilog plots, power laws in loglog plots, etc. However, *slope*
874         should only be used with linear scales; It has no clear meaning for
875         all other scales, and thus the behavior is undefined. Please specify
876         the line using the points *xy1*, *xy2* for non-linear scales.
877 
878         The *transform* keyword argument only applies to the points *xy1*,
879         *xy2*. The *slope* (if given) is always in data coordinates. This can
880         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
881         slope.
882 
883         Parameters
884         ----------
885         xy1, xy2 : (float, float)
886             Points for the line to pass through.
887             Either *xy2* or *slope* has to be given.
888         slope : float, optional
889             The slope of the line. Either *xy2* or *slope* has to be given.
890 
891         Returns
892         -------
893         `.Line2D`
894 
895         Other Parameters
896         ----------------
897         **kwargs
898             Valid kwargs are `.Line2D` properties
899 
900             %(Line2D:kwdoc)s
901 
902         See Also
903         --------
904         axhline : for horizontal lines
905         axvline : for vertical lines
906 
907         Examples
908         --------
909         Draw a thick red line passing through (0, 0) and (1, 1)::
910 
911             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
912         """
913         if slope is not None and (self.get_xscale() != 'linear' or
914                                   self.get_yscale() != 'linear'):
915             raise TypeError("'slope' cannot be used with non-linear scales")
916 
917         datalim = [xy1] if xy2 is None else [xy1, xy2]
918         if "transform" in kwargs:
919             # if a transform is passed (i.e. line points not in data space),
920             # data limits should not be adjusted.
921             datalim = []
922 
923         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
924         # Like add_line, but correctly handling data limits.
925         self._set_artist_props(line)
926         if line.get_clip_path() is None:
927             line.set_clip_path(self.patch)
928         if not line.get_label():
929             line.set_label(f"_child{len(self._children)}")
930         self._children.append(line)
931         line._remove_method = self._children.remove
932         self.update_datalim(datalim)
933 
934         self._request_autoscale_view()
935         return line
936 
937     @_docstring.dedent_interpd
938     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
939         """
940         Add a horizontal span (rectangle) across the Axes.
941 
942         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
943         the whole x-axis horizontally.  The x-span can be set using *xmin*
944         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
945         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
946         the limits set by `~.Axes.set_xlim`.
947 
948         Parameters
949         ----------
950         ymin : float
951             Lower y-coordinate of the span, in data units.
952         ymax : float
953             Upper y-coordinate of the span, in data units.
954         xmin : float, default: 0
955             Lower x-coordinate of the span, in x-axis (0-1) units.
956         xmax : float, default: 1
957             Upper x-coordinate of the span, in x-axis (0-1) units.
958 
959         Returns
960         -------
961         `~matplotlib.patches.Polygon`
962             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
963 
964         Other Parameters
965         ----------------
966         **kwargs : `~matplotlib.patches.Polygon` properties
967 
968         %(Polygon:kwdoc)s
969 
970         See Also
971         --------
972         axvspan : Add a vertical span across the Axes.
973         """
974         # Strip units away.
975         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
976         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
977 
978         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
979         p = mpatches.Polygon(verts, **kwargs)
980         p.set_transform(self.get_yaxis_transform(which="grid"))
981         self.add_patch(p)
982         self._request_autoscale_view("y")
983         return p
984 
985     @_docstring.dedent_interpd
986     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
987         """
988         Add a vertical span (rectangle) across the Axes.
989 
990         The rectangle spans from *xmin* to *xmax* horizontally, and, by
991         default, the whole y-axis vertically.  The y-span can be set using
992         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
993         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
994         regardless of the limits set by `~.Axes.set_ylim`.
995 
996         Parameters
997         ----------
998         xmin : float
999             Lower x-coordinate of the span, in data units.
1000         xmax : float
1001             Upper x-coordinate of the span, in data units.
1002         ymin : float, default: 0
1003             Lower y-coordinate of the span, in y-axis units (0-1).
1004         ymax : float, default: 1
1005             Upper y-coordinate of the span, in y-axis units (0-1).
1006 
1007         Returns
1008         -------
1009         `~matplotlib.patches.Polygon`
1010             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1011 
1012         Other Parameters
1013         ----------------
1014         **kwargs : `~matplotlib.patches.Polygon` properties
1015 
1016         %(Polygon:kwdoc)s
1017 
1018         See Also
1019         --------
1020         axhspan : Add a horizontal span across the Axes.
1021 
1022         Examples
1023         --------
1024         Draw a vertical, green, translucent rectangle from x = 1.25 to
1025         x = 1.55 that spans the yrange of the Axes.
1026 
1027         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1028 
1029         """
1030         # Strip units away.
1031         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1032         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1033 
1034         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1035         p = mpatches.Polygon(verts, **kwargs)
1036         p.set_transform(self.get_xaxis_transform(which="grid"))
1037         p.get_path()._interpolation_steps = 100
1038         self.add_patch(p)
1039         self._request_autoscale_view("x")
1040         return p
1041 
1042     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1043                       label_namer="y")
1044     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1045                label='', **kwargs):
1046         """
1047         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1048 
1049         Parameters
1050         ----------
1051         y : float or array-like
1052             y-indexes where to plot the lines.
1053 
1054         xmin, xmax : float or array-like
1055             Respective beginning and end of each line. If scalars are
1056             provided, all lines will have the same length.
1057 
1058         colors : color or list of colors, default: :rc:`lines.color`
1059 
1060         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1061 
1062         label : str, default: ''
1063 
1064         Returns
1065         -------
1066         `~matplotlib.collections.LineCollection`
1067 
1068         Other Parameters
1069         ----------------
1070         data : indexable object, optional
1071             DATA_PARAMETER_PLACEHOLDER
1072         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1073 
1074         See Also
1075         --------
1076         vlines : vertical lines
1077         axhline : horizontal line across the Axes
1078         """
1079 
1080         # We do the conversion first since not all unitized data is uniform
1081         xmin, xmax, y = self._process_unit_info(
1082             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1083 
1084         if not np.iterable(y):
1085             y = [y]
1086         if not np.iterable(xmin):
1087             xmin = [xmin]
1088         if not np.iterable(xmax):
1089             xmax = [xmax]
1090 
1091         # Create and combine masked_arrays from input
1092         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1093         y = np.ravel(y)
1094         xmin = np.ravel(xmin)
1095         xmax = np.ravel(xmax)
1096 
1097         masked_verts = np.ma.empty((len(y), 2, 2))
1098         masked_verts[:, 0, 0] = xmin
1099         masked_verts[:, 0, 1] = y
1100         masked_verts[:, 1, 0] = xmax
1101         masked_verts[:, 1, 1] = y
1102 
1103         lines = mcoll.LineCollection(masked_verts, colors=colors,
1104                                      linestyles=linestyles, label=label)
1105         self.add_collection(lines, autolim=False)
1106         lines._internal_update(kwargs)
1107 
1108         if len(y) > 0:
1109             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1110             # the case of y being a masked *object* array (as can be generated
1111             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1112             updatex = True
1113             updatey = True
1114             if self.name == "rectilinear":
1115                 datalim = lines.get_datalim(self.transData)
1116                 t = lines.get_transform()
1117                 updatex, updatey = t.contains_branch_seperately(self.transData)
1118                 minx = np.nanmin(datalim.xmin)
1119                 maxx = np.nanmax(datalim.xmax)
1120                 miny = np.nanmin(datalim.ymin)
1121                 maxy = np.nanmax(datalim.ymax)
1122             else:
1123                 minx = np.nanmin(masked_verts[..., 0])
1124                 maxx = np.nanmax(masked_verts[..., 0])
1125                 miny = np.nanmin(masked_verts[..., 1])
1126                 maxy = np.nanmax(masked_verts[..., 1])
1127 
1128             corners = (minx, miny), (maxx, maxy)
1129             self.update_datalim(corners, updatex, updatey)
1130             self._request_autoscale_view()
1131         return lines
1132 
1133     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1134                       label_namer="x")
1135     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1136                label='', **kwargs):
1137         """
1138         Plot vertical lines at each *x* from *ymin* to *ymax*.
1139 
1140         Parameters
1141         ----------
1142         x : float or array-like
1143             x-indexes where to plot the lines.
1144 
1145         ymin, ymax : float or array-like
1146             Respective beginning and end of each line. If scalars are
1147             provided, all lines will have the same length.
1148 
1149         colors : color or list of colors, default: :rc:`lines.color`
1150 
1151         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1152 
1153         label : str, default: ''
1154 
1155         Returns
1156         -------
1157         `~matplotlib.collections.LineCollection`
1158 
1159         Other Parameters
1160         ----------------
1161         data : indexable object, optional
1162             DATA_PARAMETER_PLACEHOLDER
1163         **kwargs : `~matplotlib.collections.LineCollection` properties.
1164 
1165         See Also
1166         --------
1167         hlines : horizontal lines
1168         axvline : vertical line across the Axes
1169         """
1170 
1171         # We do the conversion first since not all unitized data is uniform
1172         x, ymin, ymax = self._process_unit_info(
1173             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1174 
1175         if not np.iterable(x):
1176             x = [x]
1177         if not np.iterable(ymin):
1178             ymin = [ymin]
1179         if not np.iterable(ymax):
1180             ymax = [ymax]
1181 
1182         # Create and combine masked_arrays from input
1183         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1184         x = np.ravel(x)
1185         ymin = np.ravel(ymin)
1186         ymax = np.ravel(ymax)
1187 
1188         masked_verts = np.ma.empty((len(x), 2, 2))
1189         masked_verts[:, 0, 0] = x
1190         masked_verts[:, 0, 1] = ymin
1191         masked_verts[:, 1, 0] = x
1192         masked_verts[:, 1, 1] = ymax
1193 
1194         lines = mcoll.LineCollection(masked_verts, colors=colors,
1195                                      linestyles=linestyles, label=label)
1196         self.add_collection(lines, autolim=False)
1197         lines._internal_update(kwargs)
1198 
1199         if len(x) > 0:
1200             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1201             # the case of x being a masked *object* array (as can be generated
1202             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1203             updatex = True
1204             updatey = True
1205             if self.name == "rectilinear":
1206                 datalim = lines.get_datalim(self.transData)
1207                 t = lines.get_transform()
1208                 updatex, updatey = t.contains_branch_seperately(self.transData)
1209                 minx = np.nanmin(datalim.xmin)
1210                 maxx = np.nanmax(datalim.xmax)
1211                 miny = np.nanmin(datalim.ymin)
1212                 maxy = np.nanmax(datalim.ymax)
1213             else:
1214                 minx = np.nanmin(masked_verts[..., 0])
1215                 maxx = np.nanmax(masked_verts[..., 0])
1216                 miny = np.nanmin(masked_verts[..., 1])
1217                 maxy = np.nanmax(masked_verts[..., 1])
1218 
1219             corners = (minx, miny), (maxx, maxy)
1220             self.update_datalim(corners, updatex, updatey)
1221             self._request_autoscale_view()
1222         return lines
1223 
1224     @_preprocess_data(replace_names=["positions", "lineoffsets",
1225                                      "linelengths", "linewidths",
1226                                      "colors", "linestyles"])
1227     @_docstring.dedent_interpd
1228     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1229                   linelengths=1, linewidths=None, colors=None, alpha=None,
1230                   linestyles='solid', **kwargs):
1231         """
1232         Plot identical parallel lines at the given positions.
1233 
1234         This type of plot is commonly used in neuroscience for representing
1235         neural events, where it is usually called a spike raster, dot raster,
1236         or raster plot.
1237 
1238         However, it is useful in any situation where you wish to show the
1239         timing or position of multiple sets of discrete events, such as the
1240         arrival times of people to a business on each day of the month or the
1241         date of hurricanes each year of the last century.
1242 
1243         Parameters
1244         ----------
1245         positions : array-like or list of array-like
1246             A 1D array-like defines the positions of one sequence of events.
1247 
1248             Multiple groups of events may be passed as a list of array-likes.
1249             Each group can be styled independently by passing lists of values
1250             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1251             *linestyles*.
1252 
1253             Note that *positions* can be a 2D array, but in practice different
1254             event groups usually have different counts so that one will use a
1255             list of different-length arrays rather than a 2D array.
1256 
1257         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1258             The direction of the event sequence:
1259 
1260             - 'horizontal': the events are arranged horizontally.
1261               The indicator lines are vertical.
1262             - 'vertical': the events are arranged vertically.
1263               The indicator lines are horizontal.
1264 
1265         lineoffsets : float or array-like, default: 1
1266             The offset of the center of the lines from the origin, in the
1267             direction orthogonal to *orientation*.
1268 
1269             If *positions* is 2D, this can be a sequence with length matching
1270             the length of *positions*.
1271 
1272         linelengths : float or array-like, default: 1
1273             The total height of the lines (i.e. the lines stretches from
1274             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1275 
1276             If *positions* is 2D, this can be a sequence with length matching
1277             the length of *positions*.
1278 
1279         linewidths : float or array-like, default: :rc:`lines.linewidth`
1280             The line width(s) of the event lines, in points.
1281 
1282             If *positions* is 2D, this can be a sequence with length matching
1283             the length of *positions*.
1284 
1285         colors : color or list of colors, default: :rc:`lines.color`
1286             The color(s) of the event lines.
1287 
1288             If *positions* is 2D, this can be a sequence with length matching
1289             the length of *positions*.
1290 
1291         alpha : float or array-like, default: 1
1292             The alpha blending value(s), between 0 (transparent) and 1
1293             (opaque).
1294 
1295             If *positions* is 2D, this can be a sequence with length matching
1296             the length of *positions*.
1297 
1298         linestyles : str or tuple or list of such values, default: 'solid'
1299             Default is 'solid'. Valid strings are ['solid', 'dashed',
1300             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1301             should be of the form::
1302 
1303                 (offset, onoffseq),
1304 
1305             where *onoffseq* is an even length tuple of on and off ink
1306             in points.
1307 
1308             If *positions* is 2D, this can be a sequence with length matching
1309             the length of *positions*.
1310 
1311         data : indexable object, optional
1312             DATA_PARAMETER_PLACEHOLDER
1313 
1314         **kwargs
1315             Other keyword arguments are line collection properties.  See
1316             `.LineCollection` for a list of the valid properties.
1317 
1318         Returns
1319         -------
1320         list of `.EventCollection`
1321             The `.EventCollection` that were added.
1322 
1323         Notes
1324         -----
1325         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1326         only a single value is given, that value is applied to all lines. If an
1327         array-like is given, it must have the same length as *positions*, and
1328         each value will be applied to the corresponding row of the array.
1329 
1330         Examples
1331         --------
1332         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1333         """
1334 
1335         lineoffsets, linelengths = self._process_unit_info(
1336                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1337 
1338         # fix positions, noting that it can be a list of lists:
1339         if not np.iterable(positions):
1340             positions = [positions]
1341         elif any(np.iterable(position) for position in positions):
1342             positions = [np.asanyarray(position) for position in positions]
1343         else:
1344             positions = [np.asanyarray(positions)]
1345 
1346         poss = []
1347         for position in positions:
1348             poss += self._process_unit_info([("x", position)], kwargs)
1349         positions = poss
1350 
1351         # prevent 'singular' keys from **kwargs dict from overriding the effect
1352         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1353         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1354         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1355         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1356 
1357         if not np.iterable(lineoffsets):
1358             lineoffsets = [lineoffsets]
1359         if not np.iterable(linelengths):
1360             linelengths = [linelengths]
1361         if not np.iterable(linewidths):
1362             linewidths = [linewidths]
1363         if not np.iterable(colors):
1364             colors = [colors]
1365         if not np.iterable(alpha):
1366             alpha = [alpha]
1367         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1368             linestyles = [linestyles]
1369 
1370         lineoffsets = np.asarray(lineoffsets)
1371         linelengths = np.asarray(linelengths)
1372         linewidths = np.asarray(linewidths)
1373 
1374         if len(lineoffsets) == 0:
1375             raise ValueError('lineoffsets cannot be empty')
1376         if len(linelengths) == 0:
1377             raise ValueError('linelengths cannot be empty')
1378         if len(linestyles) == 0:
1379             raise ValueError('linestyles cannot be empty')
1380         if len(linewidths) == 0:
1381             raise ValueError('linewidths cannot be empty')
1382         if len(alpha) == 0:
1383             raise ValueError('alpha cannot be empty')
1384         if len(colors) == 0:
1385             colors = [None]
1386         try:
1387             # Early conversion of the colors into RGBA values to take care
1388             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1389             colors = mcolors.to_rgba_array(colors)
1390         except ValueError:
1391             # Will fail if any element of *colors* is None. But as long
1392             # as len(colors) == 1 or len(positions), the rest of the
1393             # code should process *colors* properly.
1394             pass
1395 
1396         if len(lineoffsets) == 1 and len(positions) != 1:
1397             lineoffsets = np.tile(lineoffsets, len(positions))
1398             lineoffsets[0] = 0
1399             lineoffsets = np.cumsum(lineoffsets)
1400         if len(linelengths) == 1:
1401             linelengths = np.tile(linelengths, len(positions))
1402         if len(linewidths) == 1:
1403             linewidths = np.tile(linewidths, len(positions))
1404         if len(colors) == 1:
1405             colors = list(colors) * len(positions)
1406         if len(alpha) == 1:
1407             alpha = list(alpha) * len(positions)
1408         if len(linestyles) == 1:
1409             linestyles = [linestyles] * len(positions)
1410 
1411         if len(lineoffsets) != len(positions):
1412             raise ValueError('lineoffsets and positions are unequal sized '
1413                              'sequences')
1414         if len(linelengths) != len(positions):
1415             raise ValueError('linelengths and positions are unequal sized '
1416                              'sequences')
1417         if len(linewidths) != len(positions):
1418             raise ValueError('linewidths and positions are unequal sized '
1419                              'sequences')
1420         if len(colors) != len(positions):
1421             raise ValueError('colors and positions are unequal sized '
1422                              'sequences')
1423         if len(alpha) != len(positions):
1424             raise ValueError('alpha and positions are unequal sized '
1425                              'sequences')
1426         if len(linestyles) != len(positions):
1427             raise ValueError('linestyles and positions are unequal sized '
1428                              'sequences')
1429 
1430         colls = []
1431         for position, lineoffset, linelength, linewidth, color, alpha_, \
1432             linestyle in \
1433                 zip(positions, lineoffsets, linelengths, linewidths,
1434                     colors, alpha, linestyles):
1435             coll = mcoll.EventCollection(position,
1436                                          orientation=orientation,
1437                                          lineoffset=lineoffset,
1438                                          linelength=linelength,
1439                                          linewidth=linewidth,
1440                                          color=color,
1441                                          alpha=alpha_,
1442                                          linestyle=linestyle)
1443             self.add_collection(coll, autolim=False)
1444             coll._internal_update(kwargs)
1445             colls.append(coll)
1446 
1447         if len(positions) > 0:
1448             # try to get min/max
1449             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1450                        if len(_p) > 0]
1451             # if we have any non-empty positions, try to autoscale
1452             if len(min_max) > 0:
1453                 mins, maxes = zip(*min_max)
1454                 minpos = np.min(mins)
1455                 maxpos = np.max(maxes)
1456 
1457                 minline = (lineoffsets - linelengths).min()
1458                 maxline = (lineoffsets + linelengths).max()
1459 
1460                 if orientation == "vertical":
1461                     corners = (minline, minpos), (maxline, maxpos)
1462                 else:  # "horizontal"
1463                     corners = (minpos, minline), (maxpos, maxline)
1464                 self.update_datalim(corners)
1465                 self._request_autoscale_view()
1466 
1467         return colls
1468 
1469     #### Basic plotting
1470 
1471     # Uses a custom implementation of data-kwarg handling in
1472     # _process_plot_var_args.
1473     @_docstring.dedent_interpd
1474     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1475         """
1476         Plot y versus x as lines and/or markers.
1477 
1478         Call signatures::
1479 
1480             plot([x], y, [fmt], *, data=None, **kwargs)
1481             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1482 
1483         The coordinates of the points or line nodes are given by *x*, *y*.
1484 
1485         The optional parameter *fmt* is a convenient way for defining basic
1486         formatting like color, marker and linestyle. It's a shortcut string
1487         notation described in the *Notes* section below.
1488 
1489         >>> plot(x, y)        # plot x and y using default line style and color
1490         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1491         >>> plot(y)           # plot y using x as index array 0..N-1
1492         >>> plot(y, 'r+')     # ditto, but with red plusses
1493 
1494         You can use `.Line2D` properties as keyword arguments for more
1495         control on the appearance. Line properties and *fmt* can be mixed.
1496         The following two calls yield identical results:
1497 
1498         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1499         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1500         ...      linewidth=2, markersize=12)
1501 
1502         When conflicting with *fmt*, keyword arguments take precedence.
1503 
1504 
1505         **Plotting labelled data**
1506 
1507         There's a convenient way for plotting objects with labelled data (i.e.
1508         data that can be accessed by index ``obj['y']``). Instead of giving
1509         the data in *x* and *y*, you can provide the object in the *data*
1510         parameter and just give the labels for *x* and *y*::
1511 
1512         >>> plot('xlabel', 'ylabel', data=obj)
1513 
1514         All indexable objects are supported. This could e.g. be a `dict`, a
1515         `pandas.DataFrame` or a structured numpy array.
1516 
1517 
1518         **Plotting multiple sets of data**
1519 
1520         There are various ways to plot multiple sets of data.
1521 
1522         - The most straight forward way is just to call `plot` multiple times.
1523           Example:
1524 
1525           >>> plot(x1, y1, 'bo')
1526           >>> plot(x2, y2, 'go')
1527 
1528         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1529           for every column. If both *x* and *y* are 2D, they must have the
1530           same shape. If only one of them is 2D with shape (N, m) the other
1531           must have length N and will be used for every data set m.
1532 
1533           Example:
1534 
1535           >>> x = [1, 2, 3]
1536           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1537           >>> plot(x, y)
1538 
1539           is equivalent to:
1540 
1541           >>> for col in range(y.shape[1]):
1542           ...     plot(x, y[:, col])
1543 
1544         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1545           groups::
1546 
1547           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1548 
1549           In this case, any additional keyword argument applies to all
1550           datasets. Also, this syntax cannot be combined with the *data*
1551           parameter.
1552 
1553         By default, each line is assigned a different style specified by a
1554         'style cycle'. The *fmt* and line property parameters are only
1555         necessary if you want explicit deviations from these defaults.
1556         Alternatively, you can also change the style cycle using
1557         :rc:`axes.prop_cycle`.
1558 
1559 
1560         Parameters
1561         ----------
1562         x, y : array-like or scalar
1563             The horizontal / vertical coordinates of the data points.
1564             *x* values are optional and default to ``range(len(y))``.
1565 
1566             Commonly, these parameters are 1D arrays.
1567 
1568             They can also be scalars, or two-dimensional (in that case, the
1569             columns represent separate data sets).
1570 
1571             These arguments cannot be passed as keywords.
1572 
1573         fmt : str, optional
1574             A format string, e.g. 'ro' for red circles. See the *Notes*
1575             section for a full description of the format strings.
1576 
1577             Format strings are just an abbreviation for quickly setting
1578             basic line properties. All of these and more can also be
1579             controlled by keyword arguments.
1580 
1581             This argument cannot be passed as keyword.
1582 
1583         data : indexable object, optional
1584             An object with labelled data. If given, provide the label names to
1585             plot in *x* and *y*.
1586 
1587             .. note::
1588                 Technically there's a slight ambiguity in calls where the
1589                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1590                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1591                 the former interpretation is chosen, but a warning is issued.
1592                 You may suppress the warning by adding an empty format string
1593                 ``plot('n', 'o', '', data=obj)``.
1594 
1595         Returns
1596         -------
1597         list of `.Line2D`
1598             A list of lines representing the plotted data.
1599 
1600         Other Parameters
1601         ----------------
1602         scalex, scaley : bool, default: True
1603             These parameters determine if the view limits are adapted to the
1604             data limits. The values are passed on to
1605             `~.axes.Axes.autoscale_view`.
1606 
1607         **kwargs : `~matplotlib.lines.Line2D` properties, optional
1608             *kwargs* are used to specify properties like a line label (for
1609             auto legends), linewidth, antialiasing, marker face color.
1610             Example::
1611 
1612             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1613             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1614 
1615             If you specify multiple lines with one plot call, the kwargs apply
1616             to all those lines. In case the label object is iterable, each
1617             element is used as labels for each set of data.
1618 
1619             Here is a list of available `.Line2D` properties:
1620 
1621             %(Line2D:kwdoc)s
1622 
1623         See Also
1624         --------
1625         scatter : XY scatter plot with markers of varying size and/or color (
1626             sometimes also called bubble chart).
1627 
1628         Notes
1629         -----
1630         **Format Strings**
1631 
1632         A format string consists of a part for color, marker and line::
1633 
1634             fmt = '[marker][line][color]'
1635 
1636         Each of them is optional. If not provided, the value from the style
1637         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1638         the data will be a line without markers.
1639 
1640         Other combinations such as ``[color][marker][line]`` are also
1641         supported, but note that their parsing may be ambiguous.
1642 
1643         **Markers**
1644 
1645         =============   ===============================
1646         character       description
1647         =============   ===============================
1648         ``'.'``         point marker
1649         ``','``         pixel marker
1650         ``'o'``         circle marker
1651         ``'v'``         triangle_down marker
1652         ``'^'``         triangle_up marker
1653         ``'<'``         triangle_left marker
1654         ``'>'``         triangle_right marker
1655         ``'1'``         tri_down marker
1656         ``'2'``         tri_up marker
1657         ``'3'``         tri_left marker
1658         ``'4'``         tri_right marker
1659         ``'8'``         octagon marker
1660         ``'s'``         square marker
1661         ``'p'``         pentagon marker
1662         ``'P'``         plus (filled) marker
1663         ``'*'``         star marker
1664         ``'h'``         hexagon1 marker
1665         ``'H'``         hexagon2 marker
1666         ``'+'``         plus marker
1667         ``'x'``         x marker
1668         ``'X'``         x (filled) marker
1669         ``'D'``         diamond marker
1670         ``'d'``         thin_diamond marker
1671         ``'|'``         vline marker
1672         ``'_'``         hline marker
1673         =============   ===============================
1674 
1675         **Line Styles**
1676 
1677         =============    ===============================
1678         character        description
1679         =============    ===============================
1680         ``'-'``          solid line style
1681         ``'--'``         dashed line style
1682         ``'-.'``         dash-dot line style
1683         ``':'``          dotted line style
1684         =============    ===============================
1685 
1686         Example format strings::
1687 
1688             'b'    # blue markers with default shape
1689             'or'   # red circles
1690             '-g'   # green solid line
1691             '--'   # dashed line with default color
1692             '^k:'  # black triangle_up markers connected by a dotted line
1693 
1694         **Colors**
1695 
1696         The supported color abbreviations are the single letter codes
1697 
1698         =============    ===============================
1699         character        color
1700         =============    ===============================
1701         ``'b'``          blue
1702         ``'g'``          green
1703         ``'r'``          red
1704         ``'c'``          cyan
1705         ``'m'``          magenta
1706         ``'y'``          yellow
1707         ``'k'``          black
1708         ``'w'``          white
1709         =============    ===============================
1710 
1711         and the ``'CN'`` colors that index into the default property cycle.
1712 
1713         If the color is the only part of the format string, you can
1714         additionally use any  `matplotlib.colors` spec, e.g. full names
1715         (``'green'``) or hex strings (``'#008000'``).
1716         """
1717         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1718         lines = [*self._get_lines(*args, data=data, **kwargs)]
1719         for line in lines:
1720             self.add_line(line)
1721         if scalex:
1722             self._request_autoscale_view("x")
1723         if scaley:
1724             self._request_autoscale_view("y")
1725         return lines
1726 
1727     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1728     @_docstring.dedent_interpd
1729     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1730                   **kwargs):
1731         """
1732         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1733 
1734         .. admonition:: Discouraged
1735 
1736             This method exists for historic reasons and will be deprecated in
1737             the future.
1738 
1739             - ``datetime``-like data should directly be plotted using
1740               `~.Axes.plot`.
1741             -  If you need to plot plain numeric data as :ref:`date-format` or
1742                need to set a timezone, call ``ax.xaxis.axis_date`` /
1743                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1744                `.Axis.axis_date`.
1745 
1746         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1747         However, the axis labels are formatted as dates depending on *xdate*
1748         and *ydate*.  Note that `.plot` will work with `datetime` and
1749         `numpy.datetime64` objects without resorting to this method.
1750 
1751         Parameters
1752         ----------
1753         x, y : array-like
1754             The coordinates of the data points. If *xdate* or *ydate* is
1755             *True*, the respective values *x* or *y* are interpreted as
1756             :ref:`Matplotlib dates <date-format>`.
1757 
1758         fmt : str, optional
1759             The plot format string. For details, see the corresponding
1760             parameter in `.plot`.
1761 
1762         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1763             The time zone to use in labeling dates.
1764 
1765         xdate : bool, default: True
1766             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1767 
1768         ydate : bool, default: False
1769             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1770 
1771         Returns
1772         -------
1773         list of `.Line2D`
1774             Objects representing the plotted data.
1775 
1776         Other Parameters
1777         ----------------
1778         data : indexable object, optional
1779             DATA_PARAMETER_PLACEHOLDER
1780         **kwargs
1781             Keyword arguments control the `.Line2D` properties:
1782 
1783             %(Line2D:kwdoc)s
1784 
1785         See Also
1786         --------
1787         matplotlib.dates : Helper functions on dates.
1788         matplotlib.dates.date2num : Convert dates to num.
1789         matplotlib.dates.num2date : Convert num to dates.
1790         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1791 
1792         Notes
1793         -----
1794         If you are using custom date tickers and formatters, it may be
1795         necessary to set the formatters/locators after the call to
1796         `.plot_date`. `.plot_date` will set the default tick locator to
1797         `.AutoDateLocator` (if the tick locator is not already set to a
1798         `.DateLocator` instance) and the default tick formatter to
1799         `.AutoDateFormatter` (if the tick formatter is not already set to a
1800         `.DateFormatter` instance).
1801         """
1802         if xdate:
1803             self.xaxis_date(tz)
1804         if ydate:
1805             self.yaxis_date(tz)
1806         return self.plot(x, y, fmt, **kwargs)
1807 
1808     # @_preprocess_data() # let 'plot' do the unpacking..
1809     @_docstring.dedent_interpd
1810     def loglog(self, *args, **kwargs):
1811         """
1812         Make a plot with log scaling on both the x- and y-axis.
1813 
1814         Call signatures::
1815 
1816             loglog([x], y, [fmt], data=None, **kwargs)
1817             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1818 
1819         This is just a thin wrapper around `.plot` which additionally changes
1820         both the x-axis and the y-axis to log scaling. All the concepts and
1821         parameters of plot can be used here as well.
1822 
1823         The additional parameters *base*, *subs* and *nonpositive* control the
1824         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1825         `.Axes.set_yscale`. To use different properties on the x-axis and the
1826         y-axis, use e.g.
1827         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1828 
1829         Parameters
1830         ----------
1831         base : float, default: 10
1832             Base of the logarithm.
1833 
1834         subs : sequence, optional
1835             The location of the minor ticks. If *None*, reasonable locations
1836             are automatically chosen depending on the number of decades in the
1837             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1838 
1839         nonpositive : {'mask', 'clip'}, default: 'clip'
1840             Non-positive values can be masked as invalid, or clipped to a very
1841             small positive number.
1842 
1843         **kwargs
1844             All parameters supported by `.plot`.
1845 
1846         Returns
1847         -------
1848         list of `.Line2D`
1849             Objects representing the plotted data.
1850         """
1851         dx = {k: v for k, v in kwargs.items()
1852               if k in ['base', 'subs', 'nonpositive',
1853                        'basex', 'subsx', 'nonposx']}
1854         self.set_xscale('log', **dx)
1855         dy = {k: v for k, v in kwargs.items()
1856               if k in ['base', 'subs', 'nonpositive',
1857                        'basey', 'subsy', 'nonposy']}
1858         self.set_yscale('log', **dy)
1859         return self.plot(
1860             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1861 
1862     # @_preprocess_data() # let 'plot' do the unpacking..
1863     @_docstring.dedent_interpd
1864     def semilogx(self, *args, **kwargs):
1865         """
1866         Make a plot with log scaling on the x-axis.
1867 
1868         Call signatures::
1869 
1870             semilogx([x], y, [fmt], data=None, **kwargs)
1871             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1872 
1873         This is just a thin wrapper around `.plot` which additionally changes
1874         the x-axis to log scaling. All the concepts and parameters of plot can
1875         be used here as well.
1876 
1877         The additional parameters *base*, *subs*, and *nonpositive* control the
1878         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1879 
1880         Parameters
1881         ----------
1882         base : float, default: 10
1883             Base of the x logarithm.
1884 
1885         subs : array-like, optional
1886             The location of the minor xticks. If *None*, reasonable locations
1887             are automatically chosen depending on the number of decades in the
1888             plot. See `.Axes.set_xscale` for details.
1889 
1890         nonpositive : {'mask', 'clip'}, default: 'clip'
1891             Non-positive values in x can be masked as invalid, or clipped to a
1892             very small positive number.
1893 
1894         **kwargs
1895             All parameters supported by `.plot`.
1896 
1897         Returns
1898         -------
1899         list of `.Line2D`
1900             Objects representing the plotted data.
1901         """
1902         d = {k: v for k, v in kwargs.items()
1903              if k in ['base', 'subs', 'nonpositive',
1904                       'basex', 'subsx', 'nonposx']}
1905         self.set_xscale('log', **d)
1906         return self.plot(
1907             *args, **{k: v for k, v in kwargs.items() if k not in d})
1908 
1909     # @_preprocess_data() # let 'plot' do the unpacking..
1910     @_docstring.dedent_interpd
1911     def semilogy(self, *args, **kwargs):
1912         """
1913         Make a plot with log scaling on the y-axis.
1914 
1915         Call signatures::
1916 
1917             semilogy([x], y, [fmt], data=None, **kwargs)
1918             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1919 
1920         This is just a thin wrapper around `.plot` which additionally changes
1921         the y-axis to log scaling. All the concepts and parameters of plot can
1922         be used here as well.
1923 
1924         The additional parameters *base*, *subs*, and *nonpositive* control the
1925         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1926 
1927         Parameters
1928         ----------
1929         base : float, default: 10
1930             Base of the y logarithm.
1931 
1932         subs : array-like, optional
1933             The location of the minor yticks. If *None*, reasonable locations
1934             are automatically chosen depending on the number of decades in the
1935             plot. See `.Axes.set_yscale` for details.
1936 
1937         nonpositive : {'mask', 'clip'}, default: 'clip'
1938             Non-positive values in y can be masked as invalid, or clipped to a
1939             very small positive number.
1940 
1941         **kwargs
1942             All parameters supported by `.plot`.
1943 
1944         Returns
1945         -------
1946         list of `.Line2D`
1947             Objects representing the plotted data.
1948         """
1949         d = {k: v for k, v in kwargs.items()
1950              if k in ['base', 'subs', 'nonpositive',
1951                       'basey', 'subsy', 'nonposy']}
1952         self.set_yscale('log', **d)
1953         return self.plot(
1954             *args, **{k: v for k, v in kwargs.items() if k not in d})
1955 
1956     @_preprocess_data(replace_names=["x"], label_namer="x")
1957     def acorr(self, x, **kwargs):
1958         """
1959         Plot the autocorrelation of *x*.
1960 
1961         Parameters
1962         ----------
1963         x : array-like
1964 
1965         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1966             A detrending function applied to *x*.  It must have the
1967             signature ::
1968 
1969                 detrend(x: np.ndarray) -> np.ndarray
1970 
1971         normed : bool, default: True
1972             If ``True``, input vectors are normalised to unit length.
1973 
1974         usevlines : bool, default: True
1975             Determines the plot style.
1976 
1977             If ``True``, vertical lines are plotted from 0 to the acorr value
1978             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1979             at y=0 using `.Axes.axhline`.
1980 
1981             If ``False``, markers are plotted at the acorr values using
1982             `.Axes.plot`.
1983 
1984         maxlags : int, default: 10
1985             Number of lags to show. If ``None``, will return all
1986             ``2 * len(x) - 1`` lags.
1987 
1988         Returns
1989         -------
1990         lags : array (length ``2*maxlags+1``)
1991             The lag vector.
1992         c : array  (length ``2*maxlags+1``)
1993             The auto correlation vector.
1994         line : `.LineCollection` or `.Line2D`
1995             `.Artist` added to the Axes of the correlation:
1996 
1997             - `.LineCollection` if *usevlines* is True.
1998             - `.Line2D` if *usevlines* is False.
1999         b : `~matplotlib.lines.Line2D` or None
2000             Horizontal line at 0 if *usevlines* is True
2001             None *usevlines* is False.
2002 
2003         Other Parameters
2004         ----------------
2005         linestyle : `~matplotlib.lines.Line2D` property, optional
2006             The linestyle for plotting the data points.
2007             Only used if *usevlines* is ``False``.
2008 
2009         marker : str, default: 'o'
2010             The marker for plotting the data points.
2011             Only used if *usevlines* is ``False``.
2012 
2013         data : indexable object, optional
2014             DATA_PARAMETER_PLACEHOLDER
2015 
2016         **kwargs
2017             Additional parameters are passed to `.Axes.vlines` and
2018             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2019             passed to `.Axes.plot`.
2020 
2021         Notes
2022         -----
2023         The cross correlation is performed with `numpy.correlate` with
2024         ``mode = "full"``.
2025         """
2026         return self.xcorr(x, x, **kwargs)
2027 
2028     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2029     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2030               usevlines=True, maxlags=10, **kwargs):
2031         r"""
2032         Plot the cross correlation between *x* and *y*.
2033 
2034         The correlation with lag k is defined as
2035         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2036         conjugate of :math:`y`.
2037 
2038         Parameters
2039         ----------
2040         x, y : array-like of length n
2041 
2042         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2043             A detrending function applied to *x* and *y*.  It must have the
2044             signature ::
2045 
2046                 detrend(x: np.ndarray) -> np.ndarray
2047 
2048         normed : bool, default: True
2049             If ``True``, input vectors are normalised to unit length.
2050 
2051         usevlines : bool, default: True
2052             Determines the plot style.
2053 
2054             If ``True``, vertical lines are plotted from 0 to the xcorr value
2055             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2056             at y=0 using `.Axes.axhline`.
2057 
2058             If ``False``, markers are plotted at the xcorr values using
2059             `.Axes.plot`.
2060 
2061         maxlags : int, default: 10
2062             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2063             lags.
2064 
2065         Returns
2066         -------
2067         lags : array (length ``2*maxlags+1``)
2068             The lag vector.
2069         c : array  (length ``2*maxlags+1``)
2070             The auto correlation vector.
2071         line : `.LineCollection` or `.Line2D`
2072             `.Artist` added to the Axes of the correlation:
2073 
2074             - `.LineCollection` if *usevlines* is True.
2075             - `.Line2D` if *usevlines* is False.
2076         b : `~matplotlib.lines.Line2D` or None
2077             Horizontal line at 0 if *usevlines* is True
2078             None *usevlines* is False.
2079 
2080         Other Parameters
2081         ----------------
2082         linestyle : `~matplotlib.lines.Line2D` property, optional
2083             The linestyle for plotting the data points.
2084             Only used if *usevlines* is ``False``.
2085 
2086         marker : str, default: 'o'
2087             The marker for plotting the data points.
2088             Only used if *usevlines* is ``False``.
2089 
2090         data : indexable object, optional
2091             DATA_PARAMETER_PLACEHOLDER
2092 
2093         **kwargs
2094             Additional parameters are passed to `.Axes.vlines` and
2095             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2096             passed to `.Axes.plot`.
2097 
2098         Notes
2099         -----
2100         The cross correlation is performed with `numpy.correlate` with
2101         ``mode = "full"``.
2102         """
2103         Nx = len(x)
2104         if Nx != len(y):
2105             raise ValueError('x and y must be equal length')
2106 
2107         x = detrend(np.asarray(x))
2108         y = detrend(np.asarray(y))
2109 
2110         correls = np.correlate(x, y, mode="full")
2111 
2112         if normed:
2113             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2114 
2115         if maxlags is None:
2116             maxlags = Nx - 1
2117 
2118         if maxlags >= Nx or maxlags < 1:
2119             raise ValueError('maxlags must be None or strictly '
2120                              'positive < %d' % Nx)
2121 
2122         lags = np.arange(-maxlags, maxlags + 1)
2123         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2124 
2125         if usevlines:
2126             a = self.vlines(lags, [0], correls, **kwargs)
2127             # Make label empty so only vertical lines get a legend entry
2128             kwargs.pop('label', '')
2129             b = self.axhline(**kwargs)
2130         else:
2131             kwargs.setdefault('marker', 'o')
2132             kwargs.setdefault('linestyle', 'None')
2133             a, = self.plot(lags, correls, **kwargs)
2134             b = None
2135         return lags, correls, a, b
2136 
2137     #### Specialized plotting
2138 
2139     # @_preprocess_data() # let 'plot' do the unpacking..
2140     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2141         """
2142         Make a step plot.
2143 
2144         Call signatures::
2145 
2146             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2147             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2148 
2149         This is just a thin wrapper around `.plot` which changes some
2150         formatting options. Most of the concepts and parameters of plot can be
2151         used here as well.
2152 
2153         .. note::
2154 
2155             This method uses a standard plot with a step drawstyle: The *x*
2156             values are the reference positions and steps extend left/right/both
2157             directions depending on *where*.
2158 
2159             For the common case where you know the values and edges of the
2160             steps, use `~.Axes.stairs` instead.
2161 
2162         Parameters
2163         ----------
2164         x : array-like
2165             1D sequence of x positions. It is assumed, but not checked, that
2166             it is uniformly increasing.
2167 
2168         y : array-like
2169             1D sequence of y levels.
2170 
2171         fmt : str, optional
2172             A format string, e.g. 'g' for a green line. See `.plot` for a more
2173             detailed description.
2174 
2175             Note: While full format strings are accepted, it is recommended to
2176             only specify the color. Line styles are currently ignored (use
2177             the keyword argument *linestyle* instead). Markers are accepted
2178             and plotted on the given positions, however, this is a rarely
2179             needed feature for step plots.
2180 
2181         where : {'pre', 'post', 'mid'}, default: 'pre'
2182             Define where the steps should be placed:
2183 
2184             - 'pre': The y value is continued constantly to the left from
2185               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2186               value ``y[i]``.
2187             - 'post': The y value is continued constantly to the right from
2188               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2189               value ``y[i]``.
2190             - 'mid': Steps occur half-way between the *x* positions.
2191 
2192         data : indexable object, optional
2193             An object with labelled data. If given, provide the label names to
2194             plot in *x* and *y*.
2195 
2196         **kwargs
2197             Additional parameters are the same as those for `.plot`.
2198 
2199         Returns
2200         -------
2201         list of `.Line2D`
2202             Objects representing the plotted data.
2203         """
2204         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2205         kwargs['drawstyle'] = 'steps-' + where
2206         return self.plot(x, y, *args, data=data, **kwargs)
2207 
2208     @staticmethod
2209     def _convert_dx(dx, x0, xconv, convert):
2210         """
2211         Small helper to do logic of width conversion flexibly.
2212 
2213         *dx* and *x0* have units, but *xconv* has already been converted
2214         to unitless (and is an ndarray).  This allows the *dx* to have units
2215         that are different from *x0*, but are still accepted by the
2216         ``__add__`` operator of *x0*.
2217         """
2218 
2219         # x should be an array...
2220         assert type(xconv) is np.ndarray
2221 
2222         if xconv.size == 0:
2223             # xconv has already been converted, but maybe empty...
2224             return convert(dx)
2225 
2226         try:
2227             # attempt to add the width to x0; this works for
2228             # datetime+timedelta, for instance
2229 
2230             # only use the first element of x and x0.  This saves
2231             # having to be sure addition works across the whole
2232             # vector.  This is particularly an issue if
2233             # x0 and dx are lists so x0 + dx just concatenates the lists.
2234             # We can't just cast x0 and dx to numpy arrays because that
2235             # removes the units from unit packages like `pint` that
2236             # wrap numpy arrays.
2237             try:
2238                 x0 = cbook._safe_first_finite(x0)
2239             except (TypeError, IndexError, KeyError):
2240                 pass
2241 
2242             try:
2243                 x = cbook._safe_first_finite(xconv)
2244             except (TypeError, IndexError, KeyError):
2245                 x = xconv
2246 
2247             delist = False
2248             if not np.iterable(dx):
2249                 dx = [dx]
2250                 delist = True
2251             dx = [convert(x0 + ddx) - x for ddx in dx]
2252             if delist:
2253                 dx = dx[0]
2254         except (ValueError, TypeError, AttributeError):
2255             # if the above fails (for any reason) just fallback to what
2256             # we do by default and convert dx by itself.
2257             dx = convert(dx)
2258         return dx
2259 
2260     @_preprocess_data()
2261     @_docstring.dedent_interpd
2262     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2263             **kwargs):
2264         r"""
2265         Make a bar plot.
2266 
2267         The bars are positioned at *x* with the given *align*\ment. Their
2268         dimensions are given by *height* and *width*. The vertical baseline
2269         is *bottom* (default 0).
2270 
2271         Many parameters can take either a single value applying to all bars
2272         or a sequence of values, one for each bar.
2273 
2274         Parameters
2275         ----------
2276         x : float or array-like
2277             The x coordinates of the bars. See also *align* for the
2278             alignment of the bars to the coordinates.
2279 
2280         height : float or array-like
2281             The height(s) of the bars.
2282 
2283             Note that if *bottom* has units (e.g. datetime), *height* should be in
2284             units that are a difference from the value of *bottom* (e.g. timedelta).
2285 
2286         width : float or array-like, default: 0.8
2287             The width(s) of the bars.
2288 
2289             Note that if *x* has units (e.g. datetime), then *width* should be in
2290             units that are a difference (e.g. timedelta) around the *x* values.
2291 
2292         bottom : float or array-like, default: 0
2293             The y coordinate(s) of the bottom side(s) of the bars.
2294 
2295             Note that if *bottom* has units, then the y-axis will get a Locator and
2296             Formatter appropriate for the units (e.g. dates, or categorical).
2297 
2298         align : {'center', 'edge'}, default: 'center'
2299             Alignment of the bars to the *x* coordinates:
2300 
2301             - 'center': Center the base on the *x* positions.
2302             - 'edge': Align the left edges of the bars with the *x* positions.
2303 
2304             To align the bars on the right edge pass a negative *width* and
2305             ``align='edge'``.
2306 
2307         Returns
2308         -------
2309         `.BarContainer`
2310             Container with all the bars and optionally errorbars.
2311 
2312         Other Parameters
2313         ----------------
2314         color : color or list of color, optional
2315             The colors of the bar faces.
2316 
2317         edgecolor : color or list of color, optional
2318             The colors of the bar edges.
2319 
2320         linewidth : float or array-like, optional
2321             Width of the bar edge(s). If 0, don't draw edges.
2322 
2323         tick_label : str or list of str, optional
2324             The tick labels of the bars.
2325             Default: None (Use default numeric labels.)
2326 
2327         label : str or list of str, optional
2328             A single label is attached to the resulting `.BarContainer` as a
2329             label for the whole dataset.
2330             If a list is provided, it must be the same length as *x* and
2331             labels the individual bars. Repeated labels are not de-duplicated
2332             and will cause repeated label entries, so this is best used when
2333             bars also differ in style (e.g., by passing a list to *color*.)
2334 
2335         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2336             If not *None*, add horizontal / vertical errorbars to the bar tips.
2337             The values are +/- sizes relative to the data:
2338 
2339             - scalar: symmetric +/- values for all bars
2340             - shape(N,): symmetric +/- values for each bar
2341             - shape(2, N): Separate - and + values for each bar. First row
2342               contains the lower errors, the second row contains the upper
2343               errors.
2344             - *None*: No errorbar. (Default)
2345 
2346             See :doc:`/gallery/statistics/errorbar_features` for an example on
2347             the usage of *xerr* and *yerr*.
2348 
2349         ecolor : color or list of color, default: 'black'
2350             The line color of the errorbars.
2351 
2352         capsize : float, default: :rc:`errorbar.capsize`
2353            The length of the error bar caps in points.
2354 
2355         error_kw : dict, optional
2356             Dictionary of keyword arguments to be passed to the
2357             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2358             here take precedence over the independent keyword arguments.
2359 
2360         log : bool, default: False
2361             If *True*, set the y-axis to be log scale.
2362 
2363         data : indexable object, optional
2364             DATA_PARAMETER_PLACEHOLDER
2365 
2366         **kwargs : `.Rectangle` properties
2367 
2368         %(Rectangle:kwdoc)s
2369 
2370         See Also
2371         --------
2372         barh : Plot a horizontal bar plot.
2373 
2374         Notes
2375         -----
2376         Stacked bars can be achieved by passing individual *bottom* values per
2377         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2378         """
2379         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2380         color = kwargs.pop('color', None)
2381         if color is None:
2382             color = self._get_patches_for_fill.get_next_color()
2383         edgecolor = kwargs.pop('edgecolor', None)
2384         linewidth = kwargs.pop('linewidth', None)
2385         hatch = kwargs.pop('hatch', None)
2386 
2387         # Because xerr and yerr will be passed to errorbar, most dimension
2388         # checking and processing will be left to the errorbar method.
2389         xerr = kwargs.pop('xerr', None)
2390         yerr = kwargs.pop('yerr', None)
2391         error_kw = kwargs.pop('error_kw', {})
2392         ezorder = error_kw.pop('zorder', None)
2393         if ezorder is None:
2394             ezorder = kwargs.get('zorder', None)
2395             if ezorder is not None:
2396                 # If using the bar zorder, increment slightly to make sure
2397                 # errorbars are drawn on top of bars
2398                 ezorder += 0.01
2399         error_kw.setdefault('zorder', ezorder)
2400         ecolor = kwargs.pop('ecolor', 'k')
2401         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2402         error_kw.setdefault('ecolor', ecolor)
2403         error_kw.setdefault('capsize', capsize)
2404 
2405         # The keyword argument *orientation* is used by barh() to defer all
2406         # logic and drawing to bar(). It is considered internal and is
2407         # intentionally not mentioned in the docstring.
2408         orientation = kwargs.pop('orientation', 'vertical')
2409         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2410         log = kwargs.pop('log', False)
2411         label = kwargs.pop('label', '')
2412         tick_labels = kwargs.pop('tick_label', None)
2413 
2414         y = bottom  # Matches barh call signature.
2415         if orientation == 'vertical':
2416             if y is None:
2417                 y = 0
2418         else:  # horizontal
2419             if x is None:
2420                 x = 0
2421 
2422         if orientation == 'vertical':
2423             # It is possible for y (bottom) to contain unit information.
2424             # However, it is also possible for y=0 for the default and height
2425             # to contain unit information.  This will prioritize the units of y.
2426             self._process_unit_info(
2427                 [("x", x), ("y", y), ("y", height)], kwargs, convert=False)
2428             if log:
2429                 self.set_yscale('log', nonpositive='clip')
2430         else:  # horizontal
2431             # It is possible for x (left) to contain unit information.
2432             # However, it is also possible for x=0 for the default and width
2433             # to contain unit information.  This will prioritize the units of x.
2434             self._process_unit_info(
2435                 [("x", x), ("x", width), ("y", y)], kwargs, convert=False)
2436             if log:
2437                 self.set_xscale('log', nonpositive='clip')
2438 
2439         # lets do some conversions now since some types cannot be
2440         # subtracted uniformly
2441         if self.xaxis is not None:
2442             x0 = x
2443             x = np.asarray(self.convert_xunits(x))
2444             width = self._convert_dx(width, x0, x, self.convert_xunits)
2445             if xerr is not None:
2446                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2447         if self.yaxis is not None:
2448             y0 = y
2449             y = np.asarray(self.convert_yunits(y))
2450             height = self._convert_dx(height, y0, y, self.convert_yunits)
2451             if yerr is not None:
2452                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2453 
2454         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2455             # Make args iterable too.
2456             np.atleast_1d(x), height, width, y, linewidth, hatch)
2457 
2458         # Now that units have been converted, set the tick locations.
2459         if orientation == 'vertical':
2460             tick_label_axis = self.xaxis
2461             tick_label_position = x
2462         else:  # horizontal
2463             tick_label_axis = self.yaxis
2464             tick_label_position = y
2465 
2466         if not isinstance(label, str) and np.iterable(label):
2467             bar_container_label = '_nolegend_'
2468             patch_labels = label
2469         else:
2470             bar_container_label = label
2471             patch_labels = ['_nolegend_'] * len(x)
2472         if len(patch_labels) != len(x):
2473             raise ValueError(f'number of labels ({len(patch_labels)}) '
2474                              f'does not match number of bars ({len(x)}).')
2475 
2476         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2477         hatch = itertools.cycle(np.atleast_1d(hatch))
2478         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2479                                 # Fallback if color == "none".
2480                                 itertools.repeat('none'))
2481         if edgecolor is None:
2482             edgecolor = itertools.repeat(None)
2483         else:
2484             edgecolor = itertools.chain(
2485                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2486                 # Fallback if edgecolor == "none".
2487                 itertools.repeat('none'))
2488 
2489         # We will now resolve the alignment and really have
2490         # left, bottom, width, height vectors
2491         _api.check_in_list(['center', 'edge'], align=align)
2492         if align == 'center':
2493             if orientation == 'vertical':
2494                 try:
2495                     left = x - width / 2
2496                 except TypeError as e:
2497                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2498                                     f'and width ({width.dtype}) '
2499                                     f'are incompatible') from e
2500                 bottom = y
2501             else:  # horizontal
2502                 try:
2503                     bottom = y - height / 2
2504                 except TypeError as e:
2505                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2506                                     f'and height ({height.dtype}) '
2507                                     f'are incompatible') from e
2508                 left = x
2509         else:  # edge
2510             left = x
2511             bottom = y
2512 
2513         patches = []
2514         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2515                    hatch, patch_labels)
2516         for l, b, w, h, c, e, lw, htch, lbl in args:
2517             r = mpatches.Rectangle(
2518                 xy=(l, b), width=w, height=h,
2519                 facecolor=c,
2520                 edgecolor=e,
2521                 linewidth=lw,
2522                 label=lbl,
2523                 hatch=htch,
2524                 )
2525             r._internal_update(kwargs)
2526             r.get_path()._interpolation_steps = 100
2527             if orientation == 'vertical':
2528                 r.sticky_edges.y.append(b)
2529             else:  # horizontal
2530                 r.sticky_edges.x.append(l)
2531             self.add_patch(r)
2532             patches.append(r)
2533 
2534         if xerr is not None or yerr is not None:
2535             if orientation == 'vertical':
2536                 # using list comps rather than arrays to preserve unit info
2537                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2538                 ey = [b + h for b, h in zip(bottom, height)]
2539 
2540             else:  # horizontal
2541                 # using list comps rather than arrays to preserve unit info
2542                 ex = [l + w for l, w in zip(left, width)]
2543                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2544 
2545             error_kw.setdefault("label", '_nolegend_')
2546 
2547             errorbar = self.errorbar(ex, ey,
2548                                      yerr=yerr, xerr=xerr,
2549                                      fmt='none', **error_kw)
2550         else:
2551             errorbar = None
2552 
2553         self._request_autoscale_view()
2554 
2555         if orientation == 'vertical':
2556             datavalues = height
2557         else:  # horizontal
2558             datavalues = width
2559 
2560         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2561                                      orientation=orientation,
2562                                      label=bar_container_label)
2563         self.add_container(bar_container)
2564 
2565         if tick_labels is not None:
2566             tick_labels = np.broadcast_to(tick_labels, len(patches))
2567             tick_label_axis.set_ticks(tick_label_position)
2568             tick_label_axis.set_ticklabels(tick_labels)
2569 
2570         return bar_container
2571 
2572     # @_preprocess_data() # let 'bar' do the unpacking..
2573     @_docstring.dedent_interpd
2574     def barh(self, y, width, height=0.8, left=None, *, align="center",
2575              data=None, **kwargs):
2576         r"""
2577         Make a horizontal bar plot.
2578 
2579         The bars are positioned at *y* with the given *align*\ment. Their
2580         dimensions are given by *width* and *height*. The horizontal baseline
2581         is *left* (default 0).
2582 
2583         Many parameters can take either a single value applying to all bars
2584         or a sequence of values, one for each bar.
2585 
2586         Parameters
2587         ----------
2588         y : float or array-like
2589             The y coordinates of the bars. See also *align* for the
2590             alignment of the bars to the coordinates.
2591 
2592         width : float or array-like
2593             The width(s) of the bars.
2594 
2595             Note that if *left* has units (e.g. datetime), *width* should be in
2596             units that are a difference from the value of *left* (e.g. timedelta).
2597 
2598         height : float or array-like, default: 0.8
2599             The heights of the bars.
2600 
2601             Note that if *y* has units (e.g. datetime), then *height* should be in
2602             units that are a difference (e.g. timedelta) around the *y* values.
2603 
2604         left : float or array-like, default: 0
2605             The x coordinates of the left side(s) of the bars.
2606 
2607             Note that if *left* has units, then the x-axis will get a Locator and
2608             Formatter appropriate for the units (e.g. dates, or categorical).
2609 
2610         align : {'center', 'edge'}, default: 'center'
2611             Alignment of the base to the *y* coordinates*:
2612 
2613             - 'center': Center the bars on the *y* positions.
2614             - 'edge': Align the bottom edges of the bars with the *y*
2615               positions.
2616 
2617             To align the bars on the top edge pass a negative *height* and
2618             ``align='edge'``.
2619 
2620         Returns
2621         -------
2622         `.BarContainer`
2623             Container with all the bars and optionally errorbars.
2624 
2625         Other Parameters
2626         ----------------
2627         color : color or list of color, optional
2628             The colors of the bar faces.
2629 
2630         edgecolor : color or list of color, optional
2631             The colors of the bar edges.
2632 
2633         linewidth : float or array-like, optional
2634             Width of the bar edge(s). If 0, don't draw edges.
2635 
2636         tick_label : str or list of str, optional
2637             The tick labels of the bars.
2638             Default: None (Use default numeric labels.)
2639 
2640         label : str or list of str, optional
2641             A single label is attached to the resulting `.BarContainer` as a
2642             label for the whole dataset.
2643             If a list is provided, it must be the same length as *y* and
2644             labels the individual bars. Repeated labels are not de-duplicated
2645             and will cause repeated label entries, so this is best used when
2646             bars also differ in style (e.g., by passing a list to *color*.)
2647 
2648         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2649             If not *None*, add horizontal / vertical errorbars to the bar tips.
2650             The values are +/- sizes relative to the data:
2651 
2652             - scalar: symmetric +/- values for all bars
2653             - shape(N,): symmetric +/- values for each bar
2654             - shape(2, N): Separate - and + values for each bar. First row
2655               contains the lower errors, the second row contains the upper
2656               errors.
2657             - *None*: No errorbar. (default)
2658 
2659             See :doc:`/gallery/statistics/errorbar_features` for an example on
2660             the usage of *xerr* and *yerr*.
2661 
2662         ecolor : color or list of color, default: 'black'
2663             The line color of the errorbars.
2664 
2665         capsize : float, default: :rc:`errorbar.capsize`
2666            The length of the error bar caps in points.
2667 
2668         error_kw : dict, optional
2669             Dictionary of keyword arguments to be passed to the
2670             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2671             here take precedence over the independent keyword arguments.
2672 
2673         log : bool, default: False
2674             If ``True``, set the x-axis to be log scale.
2675 
2676         data : indexable object, optional
2677             If given, all parameters also accept a string ``s``, which is
2678             interpreted as ``data[s]`` (unless this raises an exception).
2679 
2680         **kwargs : `.Rectangle` properties
2681 
2682         %(Rectangle:kwdoc)s
2683 
2684         See Also
2685         --------
2686         bar : Plot a vertical bar plot.
2687 
2688         Notes
2689         -----
2690         Stacked bars can be achieved by passing individual *left* values per
2691         bar. See
2692         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2693         """
2694         kwargs.setdefault('orientation', 'horizontal')
2695         patches = self.bar(x=left, height=height, width=width, bottom=y,
2696                            align=align, data=data, **kwargs)
2697         return patches
2698 
2699     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2700                   padding=0, **kwargs):
2701         """
2702         Label a bar plot.
2703 
2704         Adds labels to bars in the given `.BarContainer`.
2705         You may need to adjust the axis limits to fit the labels.
2706 
2707         Parameters
2708         ----------
2709         container : `.BarContainer`
2710             Container with all the bars and optionally errorbars, likely
2711             returned from `.bar` or `.barh`.
2712 
2713         labels : array-like, optional
2714             A list of label texts, that should be displayed. If not given, the
2715             label texts will be the data values formatted with *fmt*.
2716 
2717         fmt : str or callable, default: '%g'
2718             An unnamed %-style or {}-style format string for the label or a
2719             function to call with the value as the first argument.
2720             When *fmt* is a string and can be interpreted in both formats,
2721             %-style takes precedence over {}-style.
2722 
2723             .. versionadded:: 3.7
2724                Support for {}-style format string and callables.
2725 
2726         label_type : {'edge', 'center'}, default: 'edge'
2727             The label type. Possible values:
2728 
2729             - 'edge': label placed at the end-point of the bar segment, and the
2730               value displayed will be the position of that end-point.
2731             - 'center': label placed in the center of the bar segment, and the
2732               value displayed will be the length of that segment.
2733               (useful for stacked bars, i.e.,
2734               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2735 
2736         padding : float, default: 0
2737             Distance of label from the end of the bar, in points.
2738 
2739         **kwargs
2740             Any remaining keyword arguments are passed through to
2741             `.Axes.annotate`. The alignment parameters (
2742             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2743             not supported because the labels are automatically aligned to
2744             the bars.
2745 
2746         Returns
2747         -------
2748         list of `.Text`
2749             A list of `.Text` instances for the labels.
2750         """
2751         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2752             if key in kwargs:
2753                 raise ValueError(
2754                     f"Passing {key!r} to bar_label() is not supported.")
2755 
2756         a, b = self.yaxis.get_view_interval()
2757         y_inverted = a > b
2758         c, d = self.xaxis.get_view_interval()
2759         x_inverted = c > d
2760 
2761         # want to know whether to put label on positive or negative direction
2762         # cannot use np.sign here because it will return 0 if x == 0
2763         def sign(x):
2764             return 1 if x >= 0 else -1
2765 
2766         _api.check_in_list(['edge', 'center'], label_type=label_type)
2767 
2768         bars = container.patches
2769         errorbar = container.errorbar
2770         datavalues = container.datavalues
2771         orientation = container.orientation
2772 
2773         if errorbar:
2774             # check "ErrorbarContainer" for the definition of these elements
2775             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2776             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2777             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2778             errs = barlinecol.get_segments()
2779         else:
2780             errs = []
2781 
2782         if labels is None:
2783             labels = []
2784 
2785         annotations = []
2786 
2787         for bar, err, dat, lbl in itertools.zip_longest(
2788                 bars, errs, datavalues, labels
2789         ):
2790             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2791             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2792 
2793             if orientation == "vertical":
2794                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2795                 length = abs(y0 - y1)
2796             else:  # horizontal
2797                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2798                 length = abs(x0 - x1)
2799 
2800             if err is None or np.size(err) == 0:
2801                 endpt = extrema
2802             elif orientation == "vertical":
2803                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2804             else:  # horizontal
2805                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2806 
2807             if label_type == "center":
2808                 value = sign(dat) * length
2809             else:  # edge
2810                 value = extrema
2811 
2812             if label_type == "center":
2813                 xy = (0.5, 0.5)
2814                 kwargs["xycoords"] = (
2815                     lambda r, b=bar:
2816                         mtransforms.Bbox.intersection(
2817                             b.get_window_extent(r), b.get_clip_box()
2818                         ) or mtransforms.Bbox.null()
2819                 )
2820             else:  # edge
2821                 if orientation == "vertical":
2822                     xy = xc, endpt
2823                 else:  # horizontal
2824                     xy = endpt, yc
2825 
2826             if orientation == "vertical":
2827                 y_direction = -1 if y_inverted else 1
2828                 xytext = 0, y_direction * sign(dat) * padding
2829             else:  # horizontal
2830                 x_direction = -1 if x_inverted else 1
2831                 xytext = x_direction * sign(dat) * padding, 0
2832 
2833             if label_type == "center":
2834                 ha, va = "center", "center"
2835             else:  # edge
2836                 if orientation == "vertical":
2837                     ha = 'center'
2838                     if y_inverted:
2839                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2840                     else:
2841                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2842                 else:  # horizontal
2843                     if x_inverted:
2844                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2845                     else:
2846                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2847                     va = 'center'
2848 
2849             if np.isnan(dat):
2850                 lbl = ''
2851 
2852             if lbl is None:
2853                 if isinstance(fmt, str):
2854                     lbl = cbook._auto_format_str(fmt, value)
2855                 elif callable(fmt):
2856                     lbl = fmt(value)
2857                 else:
2858                     raise TypeError("fmt must be a str or callable")
2859             annotation = self.annotate(lbl,
2860                                        xy, xytext, textcoords="offset points",
2861                                        ha=ha, va=va, **kwargs)
2862             annotations.append(annotation)
2863 
2864         return annotations
2865 
2866     @_preprocess_data()
2867     @_docstring.dedent_interpd
2868     def broken_barh(self, xranges, yrange, **kwargs):
2869         """
2870         Plot a horizontal sequence of rectangles.
2871 
2872         A rectangle is drawn for each element of *xranges*. All rectangles
2873         have the same vertical position and size defined by *yrange*.
2874 
2875         Parameters
2876         ----------
2877         xranges : sequence of tuples (*xmin*, *xwidth*)
2878             The x-positions and extents of the rectangles. For each tuple
2879             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2880             *xwidth*.
2881         yrange : (*ymin*, *yheight*)
2882             The y-position and extent for all the rectangles.
2883 
2884         Returns
2885         -------
2886         `~.collections.PolyCollection`
2887 
2888         Other Parameters
2889         ----------------
2890         data : indexable object, optional
2891             DATA_PARAMETER_PLACEHOLDER
2892         **kwargs : `.PolyCollection` properties
2893 
2894             Each *kwarg* can be either a single argument applying to all
2895             rectangles, e.g.::
2896 
2897                 facecolors='black'
2898 
2899             or a sequence of arguments over which is cycled, e.g.::
2900 
2901                 facecolors=('black', 'blue')
2902 
2903             would create interleaving black and blue rectangles.
2904 
2905             Supported keywords:
2906 
2907             %(PolyCollection:kwdoc)s
2908         """
2909         # process the unit information
2910         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2911         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2912         self._process_unit_info(
2913             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2914 
2915         vertices = []
2916         y0, dy = yrange
2917         y0, y1 = self.convert_yunits((y0, y0 + dy))
2918         for xr in xranges:  # convert the absolute values, not the x and dx
2919             try:
2920                 x0, dx = xr
2921             except Exception:
2922                 raise ValueError(
2923                     "each range in xrange must be a sequence with two "
2924                     "elements (i.e. xrange must be an (N, 2) array)") from None
2925             x0, x1 = self.convert_xunits((x0, x0 + dx))
2926             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2927 
2928         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2929         self.add_collection(col, autolim=True)
2930         self._request_autoscale_view()
2931 
2932         return col
2933 
2934     @_preprocess_data()
2935     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2936              label=None, orientation='vertical'):
2937         """
2938         Create a stem plot.
2939 
2940         A stem plot draws lines perpendicular to a baseline at each location
2941         *locs* from the baseline to *heads*, and places a marker there. For
2942         vertical stem plots (the default), the *locs* are *x* positions, and
2943         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2944         *y* positions, and the *heads* are *x* values.
2945 
2946         Call signature::
2947 
2948           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2949 
2950         The *locs*-positions are optional. *linefmt* may be provided as
2951         positional, but all other formats must be provided as keyword
2952         arguments.
2953 
2954         Parameters
2955         ----------
2956         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2957             For vertical stem plots, the x-positions of the stems.
2958             For horizontal stem plots, the y-positions of the stems.
2959 
2960         heads : array-like
2961             For vertical stem plots, the y-values of the stem heads.
2962             For horizontal stem plots, the x-values of the stem heads.
2963 
2964         linefmt : str, optional
2965             A string defining the color and/or linestyle of the vertical lines:
2966 
2967             =========  =============
2968             Character  Line Style
2969             =========  =============
2970             ``'-'``    solid line
2971             ``'--'``   dashed line
2972             ``'-.'``   dash-dot line
2973             ``':'``    dotted line
2974             =========  =============
2975 
2976             Default: 'C0-', i.e. solid line with the first color of the color
2977             cycle.
2978 
2979             Note: Markers specified through this parameter (e.g. 'x') will be
2980             silently ignored. Instead, markers should be specified using
2981             *markerfmt*.
2982 
2983         markerfmt : str, optional
2984             A string defining the color and/or shape of the markers at the stem
2985             heads. If the marker is not given, use the marker 'o', i.e. filled
2986             circles. If the color is not given, use the color from *linefmt*.
2987 
2988         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2989             A format string defining the properties of the baseline.
2990 
2991         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2992             If 'vertical', will produce a plot with stems oriented vertically,
2993             If 'horizontal', the stems will be oriented horizontally.
2994 
2995         bottom : float, default: 0
2996             The y/x-position of the baseline (depending on orientation).
2997 
2998         label : str, default: None
2999             The label to use for the stems in legends.
3000 
3001         data : indexable object, optional
3002             DATA_PARAMETER_PLACEHOLDER
3003 
3004         Returns
3005         -------
3006         `.StemContainer`
3007             The container may be treated like a tuple
3008             (*markerline*, *stemlines*, *baseline*)
3009 
3010         Notes
3011         -----
3012         .. seealso::
3013             The MATLAB function
3014             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
3015             which inspired this method.
3016         """
3017         if not 1 <= len(args) <= 3:
3018             raise _api.nargs_error('stem', '1-3', len(args))
3019         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3020 
3021         if len(args) == 1:
3022             heads, = args
3023             locs = np.arange(len(heads))
3024             args = ()
3025         elif isinstance(args[1], str):
3026             heads, *args = args
3027             locs = np.arange(len(heads))
3028         else:
3029             locs, heads, *args = args
3030 
3031         if orientation == 'vertical':
3032             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3033         else:  # horizontal
3034             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3035 
3036         # resolve line format
3037         if linefmt is None:
3038             linefmt = args[0] if len(args) > 0 else "C0-"
3039         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3040 
3041         # resolve marker format
3042         if markerfmt is None:
3043             # if not given as kwarg, fall back to 'o'
3044             markerfmt = "o"
3045         if markerfmt == '':
3046             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3047         markerstyle, markermarker, markercolor = \
3048             _process_plot_format(markerfmt)
3049         if markermarker is None:
3050             markermarker = 'o'
3051         if markerstyle is None:
3052             markerstyle = 'None'
3053         if markercolor is None:
3054             markercolor = linecolor
3055 
3056         # resolve baseline format
3057         if basefmt is None:
3058             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3059                        "C3-")
3060         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3061 
3062         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3063         if linestyle is None:
3064             linestyle = mpl.rcParams['lines.linestyle']
3065         xlines = self.vlines if orientation == "vertical" else self.hlines
3066         stemlines = xlines(
3067             locs, bottom, heads,
3068             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3069 
3070         if orientation == 'horizontal':
3071             marker_x = heads
3072             marker_y = locs
3073             baseline_x = [bottom, bottom]
3074             baseline_y = [np.min(locs), np.max(locs)]
3075         else:
3076             marker_x = locs
3077             marker_y = heads
3078             baseline_x = [np.min(locs), np.max(locs)]
3079             baseline_y = [bottom, bottom]
3080 
3081         markerline, = self.plot(marker_x, marker_y,
3082                                 color=markercolor, linestyle=markerstyle,
3083                                 marker=markermarker, label="_nolegend_")
3084 
3085         baseline, = self.plot(baseline_x, baseline_y,
3086                               color=basecolor, linestyle=basestyle,
3087                               marker=basemarker, label="_nolegend_")
3088 
3089         stem_container = StemContainer((markerline, stemlines, baseline),
3090                                        label=label)
3091         self.add_container(stem_container)
3092         return stem_container
3093 
3094     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3095     def pie(self, x, explode=None, labels=None, colors=None,
3096             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3097             startangle=0, radius=1, counterclock=True,
3098             wedgeprops=None, textprops=None, center=(0, 0),
3099             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3100         """
3101         Plot a pie chart.
3102 
3103         Make a pie chart of array *x*.  The fractional area of each wedge is
3104         given by ``x/sum(x)``.
3105 
3106         The wedges are plotted counterclockwise, by default starting from the
3107         x-axis.
3108 
3109         Parameters
3110         ----------
3111         x : 1D array-like
3112             The wedge sizes.
3113 
3114         explode : array-like, default: None
3115             If not *None*, is a ``len(x)`` array which specifies the fraction
3116             of the radius with which to offset each wedge.
3117 
3118         labels : list, default: None
3119             A sequence of strings providing the labels for each wedge
3120 
3121         colors : color or array-like of color, default: None
3122             A sequence of colors through which the pie chart will cycle.  If
3123             *None*, will use the colors in the currently active cycle.
3124 
3125         hatch : str or list, default: None
3126             Hatching pattern applied to all pie wedges or sequence of patterns
3127             through which the chart will cycle. For a list of valid patterns,
3128             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3129 
3130             .. versionadded:: 3.7
3131 
3132         autopct : None or str or callable, default: None
3133             If not *None*, *autopct* is a string or function used to label the
3134             wedges with their numeric value. The label will be placed inside
3135             the wedge. If *autopct* is a format string, the label will be
3136             ``fmt % pct``. If *autopct* is a function, then it will be called.
3137 
3138         pctdistance : float, default: 0.6
3139             The relative distance along the radius at which the text
3140             generated by *autopct* is drawn. To draw the text outside the pie,
3141             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3142             ``None``.
3143 
3144         labeldistance : float or None, default: 1.1
3145             The relative distance along the radius at which the labels are
3146             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3147             If set to ``None``, labels are not drawn but are still stored for
3148             use in `.legend`.
3149 
3150         shadow : bool or dict, default: False
3151             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3152             passing the properties in the dict to `.Shadow`.
3153 
3154             .. versionadded:: 3.8
3155                 *shadow* can be a dict.
3156 
3157         startangle : float, default: 0 degrees
3158             The angle by which the start of the pie is rotated,
3159             counterclockwise from the x-axis.
3160 
3161         radius : float, default: 1
3162             The radius of the pie.
3163 
3164         counterclock : bool, default: True
3165             Specify fractions direction, clockwise or counterclockwise.
3166 
3167         wedgeprops : dict, default: None
3168             Dict of arguments passed to each `.patches.Wedge` of the pie.
3169             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3170             the wedge border lines equal to 3. By default, ``clip_on=False``.
3171             When there is a conflict between these properties and other
3172             keywords, properties passed to *wedgeprops* take precedence.
3173 
3174         textprops : dict, default: None
3175             Dict of arguments to pass to the text objects.
3176 
3177         center : (float, float), default: (0, 0)
3178             The coordinates of the center of the chart.
3179 
3180         frame : bool, default: False
3181             Plot Axes frame with the chart if true.
3182 
3183         rotatelabels : bool, default: False
3184             Rotate each label to the angle of the corresponding slice if true.
3185 
3186         normalize : bool, default: True
3187             When *True*, always make a full pie by normalizing x so that
3188             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3189             and raises a `ValueError` for ``sum(x) > 1``.
3190 
3191         data : indexable object, optional
3192             DATA_PARAMETER_PLACEHOLDER
3193 
3194         Returns
3195         -------
3196         patches : list
3197             A sequence of `matplotlib.patches.Wedge` instances
3198 
3199         texts : list
3200             A list of the label `.Text` instances.
3201 
3202         autotexts : list
3203             A list of `.Text` instances for the numeric labels. This will only
3204             be returned if the parameter *autopct* is not *None*.
3205 
3206         Notes
3207         -----
3208         The pie chart will probably look best if the figure and Axes are
3209         square, or the Axes aspect is equal.
3210         This method sets the aspect ratio of the axis to "equal".
3211         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3212         """
3213         self.set_aspect('equal')
3214         # The use of float32 is "historical", but can't be changed without
3215         # regenerating the test baselines.
3216         x = np.asarray(x, np.float32)
3217         if x.ndim > 1:
3218             raise ValueError("x must be 1D")
3219 
3220         if np.any(x < 0):
3221             raise ValueError("Wedge sizes 'x' must be non negative values")
3222 
3223         sx = x.sum()
3224 
3225         if normalize:
3226             x = x / sx
3227         elif sx > 1:
3228             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3229         if labels is None:
3230             labels = [''] * len(x)
3231         if explode is None:
3232             explode = [0] * len(x)
3233         if len(x) != len(labels):
3234             raise ValueError("'label' must be of length 'x'")
3235         if len(x) != len(explode):
3236             raise ValueError("'explode' must be of length 'x'")
3237         if colors is None:
3238             get_next_color = self._get_patches_for_fill.get_next_color
3239         else:
3240             color_cycle = itertools.cycle(colors)
3241 
3242             def get_next_color():
3243                 return next(color_cycle)
3244 
3245         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3246 
3247         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3248         if radius <= 0:
3249             raise ValueError(f'radius must be a positive number, not {radius}')
3250 
3251         # Starting theta1 is the start fraction of the circle
3252         theta1 = startangle / 360
3253 
3254         if wedgeprops is None:
3255             wedgeprops = {}
3256         if textprops is None:
3257             textprops = {}
3258 
3259         texts = []
3260         slices = []
3261         autotexts = []
3262 
3263         for frac, label, expl in zip(x, labels, explode):
3264             x, y = center
3265             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3266             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3267             x += expl * math.cos(thetam)
3268             y += expl * math.sin(thetam)
3269 
3270             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3271                                360. * max(theta1, theta2),
3272                                facecolor=get_next_color(),
3273                                hatch=next(hatch_cycle),
3274                                clip_on=False,
3275                                label=label)
3276             w.set(**wedgeprops)
3277             slices.append(w)
3278             self.add_patch(w)
3279 
3280             if shadow:
3281                 # Make sure to add a shadow after the call to add_patch so the
3282                 # figure and transform props will be set.
3283                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3284                 if isinstance(shadow, dict):
3285                     shadow_dict.update(shadow)
3286                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3287 
3288             if labeldistance is not None:
3289                 xt = x + labeldistance * radius * math.cos(thetam)
3290                 yt = y + labeldistance * radius * math.sin(thetam)
3291                 label_alignment_h = 'left' if xt > 0 else 'right'
3292                 label_alignment_v = 'center'
3293                 label_rotation = 'horizontal'
3294                 if rotatelabels:
3295                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3296                     label_rotation = (np.rad2deg(thetam)
3297                                       + (0 if xt > 0 else 180))
3298                 t = self.text(xt, yt, label,
3299                               clip_on=False,
3300                               horizontalalignment=label_alignment_h,
3301                               verticalalignment=label_alignment_v,
3302                               rotation=label_rotation,
3303                               size=mpl.rcParams['xtick.labelsize'])
3304                 t.set(**textprops)
3305                 texts.append(t)
3306 
3307             if autopct is not None:
3308                 xt = x + pctdistance * radius * math.cos(thetam)
3309                 yt = y + pctdistance * radius * math.sin(thetam)
3310                 if isinstance(autopct, str):
3311                     s = autopct % (100. * frac)
3312                 elif callable(autopct):
3313                     s = autopct(100. * frac)
3314                 else:
3315                     raise TypeError(
3316                         'autopct must be callable or a format string')
3317                 t = self.text(xt, yt, s,
3318                               clip_on=False,
3319                               horizontalalignment='center',
3320                               verticalalignment='center')
3321                 t.set(**textprops)
3322                 autotexts.append(t)
3323 
3324             theta1 = theta2
3325 
3326         if frame:
3327             self._request_autoscale_view()
3328         else:
3329             self.set(frame_on=False, xticks=[], yticks=[],
3330                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3331                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3332 
3333         if autopct is None:
3334             return slices, texts
3335         else:
3336             return slices, texts, autotexts
3337 
3338     @staticmethod
3339     def _errorevery_to_mask(x, errorevery):
3340         """
3341         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3342 
3343         This function is split out to be usable both by 2D and 3D errorbars.
3344         """
3345         if isinstance(errorevery, Integral):
3346             errorevery = (0, errorevery)
3347         if isinstance(errorevery, tuple):
3348             if (len(errorevery) == 2 and
3349                     isinstance(errorevery[0], Integral) and
3350                     isinstance(errorevery[1], Integral)):
3351                 errorevery = slice(errorevery[0], None, errorevery[1])
3352             else:
3353                 raise ValueError(
3354                     f'{errorevery=!r} is a not a tuple of two integers')
3355         elif isinstance(errorevery, slice):
3356             pass
3357         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3358             try:
3359                 x[errorevery]  # fancy indexing
3360             except (ValueError, IndexError) as err:
3361                 raise ValueError(
3362                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3363                     "index to match 'xerr'/'yerr'") from err
3364         else:
3365             raise ValueError(f"{errorevery=!r} is not a recognized value")
3366         everymask = np.zeros(len(x), bool)
3367         everymask[errorevery] = True
3368         return everymask
3369 
3370     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3371                       label_namer="y")
3372     @_docstring.dedent_interpd
3373     def errorbar(self, x, y, yerr=None, xerr=None,
3374                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3375                  barsabove=False, lolims=False, uplims=False,
3376                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3377                  **kwargs):
3378         """
3379         Plot y versus x as lines and/or markers with attached errorbars.
3380 
3381         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3382         sizes. By default, this draws the data markers/lines as well the
3383         errorbars. Use fmt='none' to draw errorbars without any data markers.
3384 
3385         .. versionadded:: 3.7
3386            Caps and error lines are drawn in polar coordinates on polar plots.
3387 
3388 
3389         Parameters
3390         ----------
3391         x, y : float or array-like
3392             The data positions.
3393 
3394         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3395             The errorbar sizes:
3396 
3397             - scalar: Symmetric +/- values for all data points.
3398             - shape(N,): Symmetric +/-values for each data point.
3399             - shape(2, N): Separate - and + values for each bar. First row
3400               contains the lower errors, the second row contains the upper
3401               errors.
3402             - *None*: No errorbar.
3403 
3404             All values must be >= 0.
3405 
3406             See :doc:`/gallery/statistics/errorbar_features`
3407             for an example on the usage of ``xerr`` and ``yerr``.
3408 
3409         fmt : str, default: ''
3410             The format for the data points / data lines. See `.plot` for
3411             details.
3412 
3413             Use 'none' (case-insensitive) to plot errorbars without any data
3414             markers.
3415 
3416         ecolor : color, default: None
3417             The color of the errorbar lines.  If None, use the color of the
3418             line connecting the markers.
3419 
3420         elinewidth : float, default: None
3421             The linewidth of the errorbar lines. If None, the linewidth of
3422             the current style is used.
3423 
3424         capsize : float, default: :rc:`errorbar.capsize`
3425             The length of the error bar caps in points.
3426 
3427         capthick : float, default: None
3428             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3429             This setting is a more sensible name for the property that
3430             controls the thickness of the error bar cap in points. For
3431             backwards compatibility, if *mew* or *markeredgewidth* are given,
3432             then they will over-ride *capthick*. This may change in future
3433             releases.
3434 
3435         barsabove : bool, default: False
3436             If True, will plot the errorbars above the plot
3437             symbols. Default is below.
3438 
3439         lolims, uplims, xlolims, xuplims : bool, default: False
3440             These arguments can be used to indicate that a value gives only
3441             upper/lower limits.  In that case a caret symbol is used to
3442             indicate this. *lims*-arguments may be scalars, or array-likes of
3443             the same length as *xerr* and *yerr*.  To use limits with inverted
3444             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3445             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3446             *lolims* to True means that the y-value is a *lower* limit of the
3447             True value, so, only an *upward*-pointing arrow will be drawn!
3448 
3449         errorevery : int or (int, int), default: 1
3450             draws error bars on a subset of the data. *errorevery* =N draws
3451             error bars on the points (x[::N], y[::N]).
3452             *errorevery* =(start, N) draws error bars on the points
3453             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3454             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3455             Used to avoid overlapping error bars when two series share x-axis
3456             values.
3457 
3458         Returns
3459         -------
3460         `.ErrorbarContainer`
3461             The container contains:
3462 
3463             - plotline: `~matplotlib.lines.Line2D` instance of x, y plot markers
3464               and/or line.
3465             - caplines: A tuple of `~matplotlib.lines.Line2D` instances of the error
3466               bar caps.
3467             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3468               vertical error ranges.
3469 
3470         Other Parameters
3471         ----------------
3472         data : indexable object, optional
3473             DATA_PARAMETER_PLACEHOLDER
3474 
3475         **kwargs
3476             All other keyword arguments are passed on to the `~.Axes.plot` call
3477             drawing the markers. For example, this code makes big red squares
3478             with thick green edges::
3479 
3480                 x, y, yerr = rand(3, 10)
3481                 errorbar(x, y, yerr, marker='s', mfc='red',
3482                          mec='green', ms=20, mew=4)
3483 
3484             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3485             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3486             and *markeredgewidth*.
3487 
3488             Valid kwargs for the marker properties are:
3489 
3490             - *dashes*
3491             - *dash_capstyle*
3492             - *dash_joinstyle*
3493             - *drawstyle*
3494             - *fillstyle*
3495             - *linestyle*
3496             - *marker*
3497             - *markeredgecolor*
3498             - *markeredgewidth*
3499             - *markerfacecolor*
3500             - *markerfacecoloralt*
3501             - *markersize*
3502             - *markevery*
3503             - *solid_capstyle*
3504             - *solid_joinstyle*
3505 
3506             Refer to the corresponding `.Line2D` property for more details:
3507 
3508             %(Line2D:kwdoc)s
3509         """
3510         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3511         # Drop anything that comes in as None to use the default instead.
3512         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3513         kwargs.setdefault('zorder', 2)
3514 
3515         # Casting to object arrays preserves units.
3516         if not isinstance(x, np.ndarray):
3517             x = np.asarray(x, dtype=object)
3518         if not isinstance(y, np.ndarray):
3519             y = np.asarray(y, dtype=object)
3520 
3521         def _upcast_err(err):
3522             """
3523             Safely handle tuple of containers that carry units.
3524 
3525             This function covers the case where the input to the xerr/yerr is a
3526             length 2 tuple of equal length ndarray-subclasses that carry the
3527             unit information in the container.
3528 
3529             If we have a tuple of nested numpy array (subclasses), we defer
3530             coercing the units to be consistent to the underlying unit
3531             library (and implicitly the broadcasting).
3532 
3533             Otherwise, fallback to casting to an object array.
3534             """
3535 
3536             if (
3537                     # make sure it is not a scalar
3538                     np.iterable(err) and
3539                     # and it is not empty
3540                     len(err) > 0 and
3541                     # and the first element is an array sub-class use
3542                     # safe_first_element because getitem is index-first not
3543                     # location first on pandas objects so err[0] almost always
3544                     # fails.
3545                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3546             ):
3547                 # Get the type of the first element
3548                 atype = type(cbook._safe_first_finite(err))
3549                 # Promote the outer container to match the inner container
3550                 if atype is np.ndarray:
3551                     # Converts using np.asarray, because data cannot
3552                     # be directly passed to init of np.ndarray
3553                     return np.asarray(err, dtype=object)
3554                 # If atype is not np.ndarray, directly pass data to init.
3555                 # This works for types such as unyts and astropy units
3556                 return atype(err)
3557             # Otherwise wrap it in an object array
3558             return np.asarray(err, dtype=object)
3559 
3560         if xerr is not None and not isinstance(xerr, np.ndarray):
3561             xerr = _upcast_err(xerr)
3562         if yerr is not None and not isinstance(yerr, np.ndarray):
3563             yerr = _upcast_err(yerr)
3564         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3565         if len(x) != len(y):
3566             raise ValueError("'x' and 'y' must have the same size")
3567 
3568         everymask = self._errorevery_to_mask(x, errorevery)
3569 
3570         label = kwargs.pop("label", None)
3571         kwargs['label'] = '_nolegend_'
3572 
3573         # Create the main line and determine overall kwargs for child artists.
3574         # We avoid calling self.plot() directly, or self._get_lines(), because
3575         # that would call self._process_unit_info again, and do other indirect
3576         # data processing.
3577         (data_line, base_style), = self._get_lines._plot_args(
3578             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3579 
3580         # Do this after creating `data_line` to avoid modifying `base_style`.
3581         if barsabove:
3582             data_line.set_zorder(kwargs['zorder'] - .1)
3583         else:
3584             data_line.set_zorder(kwargs['zorder'] + .1)
3585 
3586         # Add line to plot, or throw it away and use it to determine kwargs.
3587         if fmt.lower() != 'none':
3588             self.add_line(data_line)
3589         else:
3590             data_line = None
3591             # Remove alpha=0 color that _get_lines._plot_args returns for
3592             # 'none' format, and replace it with user-specified color, if
3593             # supplied.
3594             base_style.pop('color')
3595             if 'color' in kwargs:
3596                 base_style['color'] = kwargs.pop('color')
3597 
3598         if 'color' not in base_style:
3599             base_style['color'] = 'C0'
3600         if ecolor is None:
3601             ecolor = base_style['color']
3602 
3603         # Eject any line-specific information from format string, as it's not
3604         # needed for bars or caps.
3605         for key in ['marker', 'markersize', 'markerfacecolor',
3606                     'markerfacecoloralt',
3607                     'markeredgewidth', 'markeredgecolor', 'markevery',
3608                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3609                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3610                     'dashes']:
3611             base_style.pop(key, None)
3612 
3613         # Make the style dict for the line collections (the bars).
3614         eb_lines_style = {**base_style, 'color': ecolor}
3615 
3616         if elinewidth is not None:
3617             eb_lines_style['linewidth'] = elinewidth
3618         elif 'linewidth' in kwargs:
3619             eb_lines_style['linewidth'] = kwargs['linewidth']
3620 
3621         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3622             if key in kwargs:
3623                 eb_lines_style[key] = kwargs[key]
3624 
3625         # Make the style dict for caps (the "hats").
3626         eb_cap_style = {**base_style, 'linestyle': 'none'}
3627         if capsize is None:
3628             capsize = mpl.rcParams["errorbar.capsize"]
3629         if capsize > 0:
3630             eb_cap_style['markersize'] = 2. * capsize
3631         if capthick is not None:
3632             eb_cap_style['markeredgewidth'] = capthick
3633 
3634         # For backwards-compat, allow explicit setting of
3635         # 'markeredgewidth' to over-ride capthick.
3636         for key in ('markeredgewidth', 'transform', 'alpha',
3637                     'zorder', 'rasterized'):
3638             if key in kwargs:
3639                 eb_cap_style[key] = kwargs[key]
3640         eb_cap_style['color'] = ecolor
3641 
3642         barcols = []
3643         caplines = {'x': [], 'y': []}
3644 
3645         # Vectorized fancy-indexer.
3646         def apply_mask(arrays, mask):
3647             return [array[mask] for array in arrays]
3648 
3649         # dep: dependent dataset, indep: independent dataset
3650         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3651              marker, lomarker, himarker) in [
3652                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3653                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3654                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3655                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3656         ]:
3657             if err is None:
3658                 continue
3659             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3660             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3661             try:
3662                 np.broadcast_to(err, (2, len(dep)))
3663             except ValueError:
3664                 raise ValueError(
3665                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3666                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3667                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3668             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3669             if np.any(np.less(err, -err, out=res, where=(err == err))):
3670                 # like err<0, but also works for timedelta and nan.
3671                 raise ValueError(
3672                     f"'{dep_axis}err' must not contain negative values")
3673             # This is like
3674             #     elow, ehigh = np.broadcast_to(...)
3675             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3676             # except that broadcast_to would strip units.
3677             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3678             barcols.append(lines_func(
3679                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3680             if self.name == "polar" and dep_axis == "x":
3681                 for b in barcols:
3682                     for p in b.get_paths():
3683                         p._interpolation_steps = 2
3684             # Normal errorbars for points without upper/lower limits.
3685             nolims = ~(lolims | uplims)
3686             if nolims.any() and capsize > 0:
3687                 indep_masked, lo_masked, hi_masked = apply_mask(
3688                     [indep, low, high], nolims & everymask)
3689                 for lh_masked in [lo_masked, hi_masked]:
3690                     # Since this has to work for x and y as dependent data, we
3691                     # first set both x and y to the independent variable and
3692                     # overwrite the respective dependent data in a second step.
3693                     line = mlines.Line2D(indep_masked, indep_masked,
3694                                          marker=marker, **eb_cap_style)
3695                     line.set(**{f"{dep_axis}data": lh_masked})
3696                     caplines[dep_axis].append(line)
3697             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3698                 if not lims.any():
3699                     continue
3700                 hlmarker = (
3701                     himarker
3702                     if self._axis_map[dep_axis].get_inverted() ^ idx
3703                     else lomarker)
3704                 x_masked, y_masked, hl_masked = apply_mask(
3705                     [x, y, hl], lims & everymask)
3706                 # As above, we set the dependent data in a second step.
3707                 line = mlines.Line2D(x_masked, y_masked,
3708                                      marker=hlmarker, **eb_cap_style)
3709                 line.set(**{f"{dep_axis}data": hl_masked})
3710                 caplines[dep_axis].append(line)
3711                 if capsize > 0:
3712                     caplines[dep_axis].append(mlines.Line2D(
3713                         x_masked, y_masked, marker=marker, **eb_cap_style))
3714         if self.name == 'polar':
3715             for axis in caplines:
3716                 for l in caplines[axis]:
3717                     # Rotate caps to be perpendicular to the error bars
3718                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3719                         rotation = mtransforms.Affine2D().rotate(theta)
3720                         if axis == 'y':
3721                             rotation.rotate(-np.pi / 2)
3722                         ms = mmarkers.MarkerStyle(marker=marker,
3723                                                   transform=rotation)
3724                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3725                                                     **eb_cap_style))
3726         else:
3727             for axis in caplines:
3728                 for l in caplines[axis]:
3729                     self.add_line(l)
3730 
3731         self._request_autoscale_view()
3732         caplines = caplines['x'] + caplines['y']
3733         errorbar_container = ErrorbarContainer(
3734             (data_line, tuple(caplines), tuple(barcols)),
3735             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3736             label=label)
3737         self.containers.append(errorbar_container)
3738 
3739         return errorbar_container  # (l0, caplines, barcols)
3740 
3741     @_preprocess_data()
3742     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3743                 positions=None, widths=None, patch_artist=None,
3744                 bootstrap=None, usermedians=None, conf_intervals=None,
3745                 meanline=None, showmeans=None, showcaps=None,
3746                 showbox=None, showfliers=None, boxprops=None,
3747                 labels=None, flierprops=None, medianprops=None,
3748                 meanprops=None, capprops=None, whiskerprops=None,
3749                 manage_ticks=True, autorange=False, zorder=None,
3750                 capwidths=None):
3751         """
3752         Draw a box and whisker plot.
3753 
3754         The box extends from the first quartile (Q1) to the third
3755         quartile (Q3) of the data, with a line at the median.
3756         The whiskers extend from the box to the farthest data point
3757         lying within 1.5x the inter-quartile range (IQR) from the box.
3758         Flier points are those past the end of the whiskers.
3759         See https://en.wikipedia.org/wiki/Box_plot for reference.
3760 
3761         .. code-block:: none
3762 
3763                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3764                                |-----:-----|
3765                o      |--------|     :     |--------|    o  o
3766                                |-----:-----|
3767              flier             <----------->            fliers
3768                                     IQR
3769 
3770 
3771         Parameters
3772         ----------
3773         x : Array or a sequence of vectors.
3774             The input data.  If a 2D array, a boxplot is drawn for each column
3775             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3776             array in *x*.
3777 
3778         notch : bool, default: False
3779             Whether to draw a notched boxplot (`True`), or a rectangular
3780             boxplot (`False`).  The notches represent the confidence interval
3781             (CI) around the median.  The documentation for *bootstrap*
3782             describes how the locations of the notches are computed by
3783             default, but their locations may also be overridden by setting the
3784             *conf_intervals* parameter.
3785 
3786             .. note::
3787 
3788                 In cases where the values of the CI are less than the
3789                 lower quartile or greater than the upper quartile, the
3790                 notches will extend beyond the box, giving it a
3791                 distinctive "flipped" appearance. This is expected
3792                 behavior and consistent with other statistical
3793                 visualization packages.
3794 
3795         sym : str, optional
3796             The default symbol for flier points.  An empty string ('') hides
3797             the fliers.  If `None`, then the fliers default to 'b+'.  More
3798             control is provided by the *flierprops* parameter.
3799 
3800         vert : bool, default: True
3801             If `True`, draws vertical boxes.
3802             If `False`, draw horizontal boxes.
3803 
3804         whis : float or (float, float), default: 1.5
3805             The position of the whiskers.
3806 
3807             If a float, the lower whisker is at the lowest datum above
3808             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3809             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3810             third quartiles.  The default value of ``whis = 1.5`` corresponds
3811             to Tukey's original definition of boxplots.
3812 
3813             If a pair of floats, they indicate the percentiles at which to
3814             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3815             (0, 100) results in whiskers covering the whole range of the data.
3816 
3817             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3818             to (0, 100) (cover the whole range of the data) if *autorange* is
3819             True.
3820 
3821             Beyond the whiskers, data are considered outliers and are plotted
3822             as individual points.
3823 
3824         bootstrap : int, optional
3825             Specifies whether to bootstrap the confidence intervals
3826             around the median for notched boxplots. If *bootstrap* is
3827             None, no bootstrapping is performed, and notches are
3828             calculated using a Gaussian-based asymptotic approximation
3829             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3830             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3831             the number of times to bootstrap the median to determine its
3832             95% confidence intervals. Values between 1000 and 10000 are
3833             recommended.
3834 
3835         usermedians : 1D array-like, optional
3836             A 1D array-like of length ``len(x)``.  Each entry that is not
3837             `None` forces the value of the median for the corresponding
3838             dataset.  For entries that are `None`, the medians are computed
3839             by Matplotlib as normal.
3840 
3841         conf_intervals : array-like, optional
3842             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3843             None forces the location of the corresponding notch (which is
3844             only drawn if *notch* is `True`).  For entries that are `None`,
3845             the notches are computed by the method specified by the other
3846             parameters (e.g., *bootstrap*).
3847 
3848         positions : array-like, optional
3849             The positions of the boxes. The ticks and limits are
3850             automatically set to match the positions. Defaults to
3851             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3852 
3853         widths : float or array-like
3854             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3855             between extreme positions)``, if that is smaller.
3856 
3857         patch_artist : bool, default: False
3858             If `False` produces boxes with the Line2D artist. Otherwise,
3859             boxes are drawn with Patch artists.
3860 
3861         labels : sequence, optional
3862             Labels for each dataset (one per dataset).
3863 
3864         manage_ticks : bool, default: True
3865             If True, the tick locations and labels will be adjusted to match
3866             the boxplot positions.
3867 
3868         autorange : bool, default: False
3869             When `True` and the data are distributed such that the 25th and
3870             75th percentiles are equal, *whis* is set to (0, 100) such
3871             that the whisker ends are at the minimum and maximum of the data.
3872 
3873         meanline : bool, default: False
3874             If `True` (and *showmeans* is `True`), will try to render the
3875             mean as a line spanning the full width of the box according to
3876             *meanprops* (see below).  Not recommended if *shownotches* is also
3877             True.  Otherwise, means will be shown as points.
3878 
3879         zorder : float, default: ``Line2D.zorder = 2``
3880             The zorder of the boxplot.
3881 
3882         Returns
3883         -------
3884         dict
3885           A dictionary mapping each component of the boxplot to a list
3886           of the `.Line2D` instances created. That dictionary has the
3887           following keys (assuming vertical boxplots):
3888 
3889           - ``boxes``: the main body of the boxplot showing the
3890             quartiles and the median's confidence intervals if
3891             enabled.
3892 
3893           - ``medians``: horizontal lines at the median of each box.
3894 
3895           - ``whiskers``: the vertical lines extending to the most
3896             extreme, non-outlier data points.
3897 
3898           - ``caps``: the horizontal lines at the ends of the
3899             whiskers.
3900 
3901           - ``fliers``: points representing data that extend beyond
3902             the whiskers (fliers).
3903 
3904           - ``means``: points or lines representing the means.
3905 
3906         Other Parameters
3907         ----------------
3908         showcaps : bool, default: True
3909             Show the caps on the ends of whiskers.
3910         showbox : bool, default: True
3911             Show the central box.
3912         showfliers : bool, default: True
3913             Show the outliers beyond the caps.
3914         showmeans : bool, default: False
3915             Show the arithmetic means.
3916         capprops : dict, default: None
3917             The style of the caps.
3918         capwidths : float or array, default: None
3919             The widths of the caps.
3920         boxprops : dict, default: None
3921             The style of the box.
3922         whiskerprops : dict, default: None
3923             The style of the whiskers.
3924         flierprops : dict, default: None
3925             The style of the fliers.
3926         medianprops : dict, default: None
3927             The style of the median.
3928         meanprops : dict, default: None
3929             The style of the mean.
3930         data : indexable object, optional
3931             DATA_PARAMETER_PLACEHOLDER
3932 
3933         See Also
3934         --------
3935         violinplot : Draw an estimate of the probability density function.
3936         """
3937 
3938         # Missing arguments default to rcParams.
3939         if whis is None:
3940             whis = mpl.rcParams['boxplot.whiskers']
3941         if bootstrap is None:
3942             bootstrap = mpl.rcParams['boxplot.bootstrap']
3943 
3944         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3945                                        labels=labels, autorange=autorange)
3946         if notch is None:
3947             notch = mpl.rcParams['boxplot.notch']
3948         if vert is None:
3949             vert = mpl.rcParams['boxplot.vertical']
3950         if patch_artist is None:
3951             patch_artist = mpl.rcParams['boxplot.patchartist']
3952         if meanline is None:
3953             meanline = mpl.rcParams['boxplot.meanline']
3954         if showmeans is None:
3955             showmeans = mpl.rcParams['boxplot.showmeans']
3956         if showcaps is None:
3957             showcaps = mpl.rcParams['boxplot.showcaps']
3958         if showbox is None:
3959             showbox = mpl.rcParams['boxplot.showbox']
3960         if showfliers is None:
3961             showfliers = mpl.rcParams['boxplot.showfliers']
3962 
3963         if boxprops is None:
3964             boxprops = {}
3965         if whiskerprops is None:
3966             whiskerprops = {}
3967         if capprops is None:
3968             capprops = {}
3969         if medianprops is None:
3970             medianprops = {}
3971         if meanprops is None:
3972             meanprops = {}
3973         if flierprops is None:
3974             flierprops = {}
3975 
3976         if patch_artist:
3977             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3978             if 'color' in boxprops:
3979                 boxprops['edgecolor'] = boxprops.pop('color')
3980 
3981         # if non-default sym value, put it into the flier dictionary
3982         # the logic for providing the default symbol ('b+') now lives
3983         # in bxp in the initial value of flierkw
3984         # handle all of the *sym* related logic here so we only have to pass
3985         # on the flierprops dict.
3986         if sym is not None:
3987             # no-flier case, which should really be done with
3988             # 'showfliers=False' but none-the-less deal with it to keep back
3989             # compatibility
3990             if sym == '':
3991                 # blow away existing dict and make one for invisible markers
3992                 flierprops = dict(linestyle='none', marker='', color='none')
3993                 # turn the fliers off just to be safe
3994                 showfliers = False
3995             # now process the symbol string
3996             else:
3997                 # process the symbol string
3998                 # discarded linestyle
3999                 _, marker, color = _process_plot_format(sym)
4000                 # if we have a marker, use it
4001                 if marker is not None:
4002                     flierprops['marker'] = marker
4003                 # if we have a color, use it
4004                 if color is not None:
4005                     # assume that if color is passed in the user want
4006                     # filled symbol, if the users want more control use
4007                     # flierprops
4008                     flierprops['color'] = color
4009                     flierprops['markerfacecolor'] = color
4010                     flierprops['markeredgecolor'] = color
4011 
4012         # replace medians if necessary:
4013         if usermedians is not None:
4014             if (len(np.ravel(usermedians)) != len(bxpstats) or
4015                     np.shape(usermedians)[0] != len(bxpstats)):
4016                 raise ValueError(
4017                     "'usermedians' and 'x' have different lengths")
4018             else:
4019                 # reassign medians as necessary
4020                 for stats, med in zip(bxpstats, usermedians):
4021                     if med is not None:
4022                         stats['med'] = med
4023 
4024         if conf_intervals is not None:
4025             if len(conf_intervals) != len(bxpstats):
4026                 raise ValueError(
4027                     "'conf_intervals' and 'x' have different lengths")
4028             else:
4029                 for stats, ci in zip(bxpstats, conf_intervals):
4030                     if ci is not None:
4031                         if len(ci) != 2:
4032                             raise ValueError('each confidence interval must '
4033                                              'have two values')
4034                         else:
4035                             if ci[0] is not None:
4036                                 stats['cilo'] = ci[0]
4037                             if ci[1] is not None:
4038                                 stats['cihi'] = ci[1]
4039 
4040         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4041                            vert=vert, patch_artist=patch_artist,
4042                            shownotches=notch, showmeans=showmeans,
4043                            showcaps=showcaps, showbox=showbox,
4044                            boxprops=boxprops, flierprops=flierprops,
4045                            medianprops=medianprops, meanprops=meanprops,
4046                            meanline=meanline, showfliers=showfliers,
4047                            capprops=capprops, whiskerprops=whiskerprops,
4048                            manage_ticks=manage_ticks, zorder=zorder,
4049                            capwidths=capwidths)
4050         return artists
4051 
4052     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4053             patch_artist=False, shownotches=False, showmeans=False,
4054             showcaps=True, showbox=True, showfliers=True,
4055             boxprops=None, whiskerprops=None, flierprops=None,
4056             medianprops=None, capprops=None, meanprops=None,
4057             meanline=False, manage_ticks=True, zorder=None,
4058             capwidths=None):
4059         """
4060         Drawing function for box and whisker plots.
4061 
4062         Make a box and whisker plot for each column of *x* or each
4063         vector in sequence *x*.  The box extends from the lower to
4064         upper quartile values of the data, with a line at the median.
4065         The whiskers extend from the box to show the range of the
4066         data.  Flier points are those past the end of the whiskers.
4067 
4068         Parameters
4069         ----------
4070         bxpstats : list of dicts
4071           A list of dictionaries containing stats for each boxplot.
4072           Required keys are:
4073 
4074           - ``med``: Median (scalar).
4075           - ``q1``, ``q3``: First & third quartiles (scalars).
4076           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4077 
4078           Optional keys are:
4079 
4080           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4081           - ``fliers``: Data beyond the whiskers (array-like).
4082             Needed if ``showfliers=True``.
4083           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4084             about the median. Needed if ``shownotches=True``.
4085           - ``label``: Name of the dataset (str).  If available,
4086             this will be used a tick label for the boxplot
4087 
4088         positions : array-like, default: [1, 2, ..., n]
4089           The positions of the boxes. The ticks and limits
4090           are automatically set to match the positions.
4091 
4092         widths : float or array-like, default: None
4093           The widths of the boxes.  The default is
4094           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4095 
4096         capwidths : float or array-like, default: None
4097           Either a scalar or a vector and sets the width of each cap.
4098           The default is ``0.5*(with of the box)``, see *widths*.
4099 
4100         vert : bool, default: True
4101           If `True` (default), makes the boxes vertical.
4102           If `False`, makes horizontal boxes.
4103 
4104         patch_artist : bool, default: False
4105           If `False` produces boxes with the `.Line2D` artist.
4106           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4107 
4108         shownotches, showmeans, showcaps, showbox, showfliers : bool
4109           Whether to draw the CI notches, the mean value (both default to
4110           False), the caps, the box, and the fliers (all three default to
4111           True).
4112 
4113         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4114  dict, optional
4115           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4116           means.
4117 
4118         meanline : bool, default: False
4119           If `True` (and *showmeans* is `True`), will try to render the mean
4120           as a line spanning the full width of the box according to
4121           *meanprops*. Not recommended if *shownotches* is also True.
4122           Otherwise, means will be shown as points.
4123 
4124         manage_ticks : bool, default: True
4125           If True, the tick locations and labels will be adjusted to match the
4126           boxplot positions.
4127 
4128         zorder : float, default: ``Line2D.zorder = 2``
4129           The zorder of the resulting boxplot.
4130 
4131         Returns
4132         -------
4133         dict
4134           A dictionary mapping each component of the boxplot to a list
4135           of the `.Line2D` instances created. That dictionary has the
4136           following keys (assuming vertical boxplots):
4137 
4138           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4139             the median's confidence intervals if enabled.
4140           - ``medians``: horizontal lines at the median of each box.
4141           - ``whiskers``: vertical lines up to the last non-outlier data.
4142           - ``caps``: horizontal lines at the ends of the whiskers.
4143           - ``fliers``: points representing data beyond the whiskers (fliers).
4144           - ``means``: points or lines representing the means.
4145 
4146         Examples
4147         --------
4148         .. plot:: gallery/statistics/bxp.py
4149         """
4150 
4151         # lists of artists to be output
4152         whiskers = []
4153         caps = []
4154         boxes = []
4155         medians = []
4156         means = []
4157         fliers = []
4158 
4159         # empty list of xticklabels
4160         datalabels = []
4161 
4162         # Use default zorder if none specified
4163         if zorder is None:
4164             zorder = mlines.Line2D.zorder
4165 
4166         zdelta = 0.1
4167 
4168         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4169             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4170                  if k.startswith(f'boxplot.{subkey}props')}
4171             d['zorder'] = zorder + zdelta
4172             if not usemarker:
4173                 d['marker'] = ''
4174             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4175             return d
4176 
4177         box_kw = {
4178             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4179             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4180             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4181             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4182                           else mpl.rcParams['patch.facecolor']),
4183             'zorder': zorder,
4184             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4185         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4186         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4187         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4188         flier_kw = merge_kw_rc('flier', flierprops)
4189         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4190         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4191         removed_prop = 'marker' if meanline else 'linestyle'
4192         # Only remove the property if it's not set explicitly as a parameter.
4193         if meanprops is None or removed_prop not in meanprops:
4194             mean_kw[removed_prop] = ''
4195 
4196         # vertical or horizontal plot?
4197         maybe_swap = slice(None) if vert else slice(None, None, -1)
4198 
4199         def do_plot(xs, ys, **kwargs):
4200             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4201 
4202         def do_patch(xs, ys, **kwargs):
4203             path = mpath.Path._create_closed(
4204                 np.column_stack([xs, ys][maybe_swap]))
4205             patch = mpatches.PathPatch(path, **kwargs)
4206             self.add_artist(patch)
4207             return patch
4208 
4209         # input validation
4210         N = len(bxpstats)
4211         datashape_message = ("List of boxplot statistics and `{0}` "
4212                              "values must have same the length")
4213         # check position
4214         if positions is None:
4215             positions = list(range(1, N + 1))
4216         elif len(positions) != N:
4217             raise ValueError(datashape_message.format("positions"))
4218 
4219         positions = np.array(positions)
4220         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4221             raise TypeError("positions should be an iterable of numbers")
4222 
4223         # width
4224         if widths is None:
4225             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4226         elif np.isscalar(widths):
4227             widths = [widths] * N
4228         elif len(widths) != N:
4229             raise ValueError(datashape_message.format("widths"))
4230 
4231         # capwidth
4232         if capwidths is None:
4233             capwidths = 0.5 * np.array(widths)
4234         elif np.isscalar(capwidths):
4235             capwidths = [capwidths] * N
4236         elif len(capwidths) != N:
4237             raise ValueError(datashape_message.format("capwidths"))
4238 
4239         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4240                                                capwidths):
4241             # try to find a new label
4242             datalabels.append(stats.get('label', pos))
4243 
4244             # whisker coords
4245             whis_x = [pos, pos]
4246             whislo_y = [stats['q1'], stats['whislo']]
4247             whishi_y = [stats['q3'], stats['whishi']]
4248             # cap coords
4249             cap_left = pos - capwidth * 0.5
4250             cap_right = pos + capwidth * 0.5
4251             cap_x = [cap_left, cap_right]
4252             cap_lo = np.full(2, stats['whislo'])
4253             cap_hi = np.full(2, stats['whishi'])
4254             # box and median coords
4255             box_left = pos - width * 0.5
4256             box_right = pos + width * 0.5
4257             med_y = [stats['med'], stats['med']]
4258             # notched boxes
4259             if shownotches:
4260                 notch_left = pos - width * 0.25
4261                 notch_right = pos + width * 0.25
4262                 box_x = [box_left, box_right, box_right, notch_right,
4263                          box_right, box_right, box_left, box_left, notch_left,
4264                          box_left, box_left]
4265                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4266                          stats['med'], stats['cihi'], stats['q3'],
4267                          stats['q3'], stats['cihi'], stats['med'],
4268                          stats['cilo'], stats['q1']]
4269                 med_x = [notch_left, notch_right]
4270             # plain boxes
4271             else:
4272                 box_x = [box_left, box_right, box_right, box_left, box_left]
4273                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4274                          stats['q1']]
4275                 med_x = [box_left, box_right]
4276 
4277             # maybe draw the box
4278             if showbox:
4279                 do_box = do_patch if patch_artist else do_plot
4280                 boxes.append(do_box(box_x, box_y, **box_kw))
4281             # draw the whiskers
4282             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4283             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4284             # maybe draw the caps
4285             if showcaps:
4286                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4287                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4288             # draw the medians
4289             medians.append(do_plot(med_x, med_y, **median_kw))
4290             # maybe draw the means
4291             if showmeans:
4292                 if meanline:
4293                     means.append(do_plot(
4294                         [box_left, box_right], [stats['mean'], stats['mean']],
4295                         **mean_kw
4296                     ))
4297                 else:
4298                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4299             # maybe draw the fliers
4300             if showfliers:
4301                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4302                 flier_y = stats['fliers']
4303                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4304 
4305         if manage_ticks:
4306             axis_name = "x" if vert else "y"
4307             interval = getattr(self.dataLim, f"interval{axis_name}")
4308             axis = self._axis_map[axis_name]
4309             positions = axis.convert_units(positions)
4310             # The 0.5 additional padding ensures reasonable-looking boxes
4311             # even when drawing a single box.  We set the sticky edge to
4312             # prevent margins expansion, in order to match old behavior (back
4313             # when separate calls to boxplot() would completely reset the axis
4314             # limits regardless of what was drawn before).  The sticky edges
4315             # are attached to the median lines, as they are always present.
4316             interval[:] = (min(interval[0], min(positions) - .5),
4317                            max(interval[1], max(positions) + .5))
4318             for median, position in zip(medians, positions):
4319                 getattr(median.sticky_edges, axis_name).extend(
4320                     [position - .5, position + .5])
4321             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4322             locator = axis.get_major_locator()
4323             if not isinstance(axis.get_major_locator(),
4324                               mticker.FixedLocator):
4325                 locator = mticker.FixedLocator([])
4326                 axis.set_major_locator(locator)
4327             locator.locs = np.array([*locator.locs, *positions])
4328             formatter = axis.get_major_formatter()
4329             if not isinstance(axis.get_major_formatter(),
4330                               mticker.FixedFormatter):
4331                 formatter = mticker.FixedFormatter([])
4332                 axis.set_major_formatter(formatter)
4333             formatter.seq = [*formatter.seq, *datalabels]
4334 
4335             self._request_autoscale_view()
4336 
4337         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4338                     medians=medians, fliers=fliers, means=means)
4339 
4340     @staticmethod
4341     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4342                                   get_next_color_func):
4343         """
4344         Helper function to process color related arguments of `.Axes.scatter`.
4345 
4346         Argument precedence for facecolors:
4347 
4348         - c (if not None)
4349         - kwargs['facecolor']
4350         - kwargs['facecolors']
4351         - kwargs['color'] (==kwcolor)
4352         - 'b' if in classic mode else the result of ``get_next_color_func()``
4353 
4354         Argument precedence for edgecolors:
4355 
4356         - kwargs['edgecolor']
4357         - edgecolors (is an explicit kw argument in scatter())
4358         - kwargs['color'] (==kwcolor)
4359         - 'face' if not in classic mode else None
4360 
4361         Parameters
4362         ----------
4363         c : color or sequence or sequence of color or None
4364             See argument description of `.Axes.scatter`.
4365         edgecolors : color or sequence of color or {'face', 'none'} or None
4366             See argument description of `.Axes.scatter`.
4367         kwargs : dict
4368             Additional kwargs. If these keys exist, we pop and process them:
4369             'facecolors', 'facecolor', 'edgecolor', 'color'
4370             Note: The dict is modified by this function.
4371         xsize : int
4372             The size of the x and y arrays passed to `.Axes.scatter`.
4373         get_next_color_func : callable
4374             A callable that returns a color. This color is used as facecolor
4375             if no other color is provided.
4376 
4377             Note, that this is a function rather than a fixed color value to
4378             support conditional evaluation of the next color.  As of the
4379             current implementation obtaining the next color from the
4380             property cycle advances the cycle. This must only happen if we
4381             actually use the color, which will only be decided within this
4382             method.
4383 
4384         Returns
4385         -------
4386         c
4387             The input *c* if it was not *None*, else a color derived from the
4388             other inputs or defaults.
4389         colors : array(N, 4) or None
4390             The facecolors as RGBA values, or *None* if a colormap is used.
4391         edgecolors
4392             The edgecolor.
4393 
4394         """
4395         facecolors = kwargs.pop('facecolors', None)
4396         facecolors = kwargs.pop('facecolor', facecolors)
4397         edgecolors = kwargs.pop('edgecolor', edgecolors)
4398 
4399         kwcolor = kwargs.pop('color', None)
4400 
4401         if kwcolor is not None and c is not None:
4402             raise ValueError("Supply a 'c' argument or a 'color'"
4403                              " kwarg but not both; they differ but"
4404                              " their functionalities overlap.")
4405 
4406         if kwcolor is not None:
4407             try:
4408                 mcolors.to_rgba_array(kwcolor)
4409             except ValueError as err:
4410                 raise ValueError(
4411                     "'color' kwarg must be a color or sequence of color "
4412                     "specs.  For a sequence of values to be color-mapped, use "
4413                     "the 'c' argument instead.") from err
4414             if edgecolors is None:
4415                 edgecolors = kwcolor
4416             if facecolors is None:
4417                 facecolors = kwcolor
4418 
4419         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4420             edgecolors = mpl.rcParams['scatter.edgecolors']
4421 
4422         c_was_none = c is None
4423         if c is None:
4424             c = (facecolors if facecolors is not None
4425                  else "b" if mpl.rcParams['_internal.classic_mode']
4426                  else get_next_color_func())
4427         c_is_string_or_strings = (
4428             isinstance(c, str)
4429             or (np.iterable(c) and len(c) > 0
4430                 and isinstance(cbook._safe_first_finite(c), str)))
4431 
4432         def invalid_shape_exception(csize, xsize):
4433             return ValueError(
4434                 f"'c' argument has {csize} elements, which is inconsistent "
4435                 f"with 'x' and 'y' with size {xsize}.")
4436 
4437         c_is_mapped = False  # Unless proven otherwise below.
4438         valid_shape = True  # Unless proven otherwise below.
4439         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4440             try:  # First, does 'c' look suitable for value-mapping?
4441                 c = np.asanyarray(c, dtype=float)
4442             except ValueError:
4443                 pass  # Failed to convert to float array; must be color specs.
4444             else:
4445                 # handle the documented special case of a 2D array with 1
4446                 # row which as RGB(A) to broadcast.
4447                 if c.shape == (1, 4) or c.shape == (1, 3):
4448                     c_is_mapped = False
4449                     if c.size != xsize:
4450                         valid_shape = False
4451                 # If c can be either mapped values or an RGB(A) color, prefer
4452                 # the former if shapes match, the latter otherwise.
4453                 elif c.size == xsize:
4454                     c = c.ravel()
4455                     c_is_mapped = True
4456                 else:  # Wrong size; it must not be intended for mapping.
4457                     if c.shape in ((3,), (4,)):
4458                         _api.warn_external(
4459                             "*c* argument looks like a single numeric RGB or "
4460                             "RGBA sequence, which should be avoided as value-"
4461                             "mapping will have precedence in case its length "
4462                             "matches with *x* & *y*.  Please use the *color* "
4463                             "keyword-argument or provide a 2D array "
4464                             "with a single row if you intend to specify "
4465                             "the same RGB or RGBA value for all points.")
4466                     valid_shape = False
4467         if not c_is_mapped:
4468             try:  # Is 'c' acceptable as PathCollection facecolors?
4469                 colors = mcolors.to_rgba_array(c)
4470             except (TypeError, ValueError) as err:
4471                 if "RGBA values should be within 0-1 range" in str(err):
4472                     raise
4473                 else:
4474                     if not valid_shape:
4475                         raise invalid_shape_exception(c.size, xsize) from err
4476                     # Both the mapping *and* the RGBA conversion failed: pretty
4477                     # severe failure => one may appreciate a verbose feedback.
4478                     raise ValueError(
4479                         f"'c' argument must be a color, a sequence of colors, "
4480                         f"or a sequence of numbers, not {c!r}") from err
4481             else:
4482                 if len(colors) not in (0, 1, xsize):
4483                     # NB: remember that a single color is also acceptable.
4484                     # Besides *colors* will be an empty array if c == 'none'.
4485                     raise invalid_shape_exception(len(colors), xsize)
4486         else:
4487             colors = None  # use cmap, norm after collection is created
4488         return c, colors, edgecolors
4489 
4490     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4491                                      "edgecolors", "c", "facecolor",
4492                                      "facecolors", "color"],
4493                       label_namer="y")
4494     @_docstring.interpd
4495     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4496                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4497                 edgecolors=None, plotnonfinite=False, **kwargs):
4498         """
4499         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4500 
4501         Parameters
4502         ----------
4503         x, y : float or array-like, shape (n, )
4504             The data positions.
4505 
4506         s : float or array-like, shape (n, ), optional
4507             The marker size in points**2 (typographic points are 1/72 in.).
4508             Default is ``rcParams['lines.markersize'] ** 2``.
4509 
4510             The linewidth and edgecolor can visually interact with the marker
4511             size, and can lead to artifacts if the marker size is smaller than
4512             the linewidth.
4513 
4514             If the linewidth is greater than 0 and the edgecolor is anything
4515             but *'none'*, then the effective size of the marker will be
4516             increased by half the linewidth because the stroke will be centered
4517             on the edge of the shape.
4518 
4519             To eliminate the marker edge either set *linewidth=0* or
4520             *edgecolor='none'*.
4521 
4522         c : array-like or list of colors or color, optional
4523             The marker colors. Possible values:
4524 
4525             - A scalar or sequence of n numbers to be mapped to colors using
4526               *cmap* and *norm*.
4527             - A 2D array in which the rows are RGB or RGBA.
4528             - A sequence of colors of length n.
4529             - A single color format string.
4530 
4531             Note that *c* should not be a single numeric RGB or RGBA sequence
4532             because that is indistinguishable from an array of values to be
4533             colormapped. If you want to specify the same RGB or RGBA value for
4534             all points, use a 2D array with a single row.  Otherwise,
4535             value-matching will have precedence in case of a size matching with
4536             *x* and *y*.
4537 
4538             If you wish to specify a single color for all points
4539             prefer the *color* keyword argument.
4540 
4541             Defaults to `None`. In that case the marker color is determined
4542             by the value of *color*, *facecolor* or *facecolors*. In case
4543             those are not specified or `None`, the marker color is determined
4544             by the next color of the ``Axes``' current "shape and fill" color
4545             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4546 
4547         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4548             The marker style. *marker* can be either an instance of the class
4549             or the text shorthand for a particular marker.
4550             See :mod:`matplotlib.markers` for more information about marker
4551             styles.
4552 
4553         %(cmap_doc)s
4554 
4555             This parameter is ignored if *c* is RGB(A).
4556 
4557         %(norm_doc)s
4558 
4559             This parameter is ignored if *c* is RGB(A).
4560 
4561         %(vmin_vmax_doc)s
4562 
4563             This parameter is ignored if *c* is RGB(A).
4564 
4565         alpha : float, default: None
4566             The alpha blending value, between 0 (transparent) and 1 (opaque).
4567 
4568         linewidths : float or array-like, default: :rc:`lines.linewidth`
4569             The linewidth of the marker edges. Note: The default *edgecolors*
4570             is 'face'. You may want to change this as well.
4571 
4572         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4573 default: :rc:`scatter.edgecolors`
4574             The edge color of the marker. Possible values:
4575 
4576             - 'face': The edge color will always be the same as the face color.
4577             - 'none': No patch boundary will be drawn.
4578             - A color or sequence of colors.
4579 
4580             For non-filled markers, *edgecolors* is ignored. Instead, the color
4581             is determined like with 'face', i.e. from *c*, *colors*, or
4582             *facecolors*.
4583 
4584         plotnonfinite : bool, default: False
4585             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4586             or ``nan``). If ``True`` the points are drawn with the *bad*
4587             colormap color (see `.Colormap.set_bad`).
4588 
4589         Returns
4590         -------
4591         `~matplotlib.collections.PathCollection`
4592 
4593         Other Parameters
4594         ----------------
4595         data : indexable object, optional
4596             DATA_PARAMETER_PLACEHOLDER
4597         **kwargs : `~matplotlib.collections.Collection` properties
4598 
4599         See Also
4600         --------
4601         plot : To plot scatter plots when markers are identical in size and
4602             color.
4603 
4604         Notes
4605         -----
4606         * The `.plot` function will be faster for scatterplots where markers
4607           don't vary in size or color.
4608 
4609         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4610           case all masks will be combined and only unmasked points will be
4611           plotted.
4612 
4613         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4614           may be input as N-D arrays, but within scatter they will be
4615           flattened. The exception is *c*, which will be flattened only if its
4616           size matches the size of *x* and *y*.
4617 
4618         """
4619         # add edgecolors and linewidths to kwargs so they
4620         # can be processed by normailze_kwargs
4621         if edgecolors is not None:
4622             kwargs.update({'edgecolors': edgecolors})
4623         if linewidths is not None:
4624             kwargs.update({'linewidths': linewidths})
4625 
4626         kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
4627         # re direct linewidth and edgecolor so it can be
4628         # further processed by the rest of the function
4629         linewidths = kwargs.pop('linewidth', None)
4630         edgecolors = kwargs.pop('edgecolor', None)
4631         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4632         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4633         # np.ma.ravel yields an ndarray, not a masked array,
4634         # unless its argument is a masked array.
4635         x = np.ma.ravel(x)
4636         y = np.ma.ravel(y)
4637         if x.size != y.size:
4638             raise ValueError("x and y must be the same size")
4639 
4640         if s is None:
4641             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4642                  mpl.rcParams['lines.markersize'] ** 2.0)
4643         s = np.ma.ravel(s)
4644         if (len(s) not in (1, x.size) or
4645                 (not np.issubdtype(s.dtype, np.floating) and
4646                  not np.issubdtype(s.dtype, np.integer))):
4647             raise ValueError(
4648                 "s must be a scalar, "
4649                 "or float array-like with the same size as x and y")
4650 
4651         # get the original edgecolor the user passed before we normalize
4652         orig_edgecolor = edgecolors
4653         if edgecolors is None:
4654             orig_edgecolor = kwargs.get('edgecolor', None)
4655         c, colors, edgecolors = \
4656             self._parse_scatter_color_args(
4657                 c, edgecolors, kwargs, x.size,
4658                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4659 
4660         if plotnonfinite and colors is None:
4661             c = np.ma.masked_invalid(c)
4662             x, y, s, edgecolors, linewidths = \
4663                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4664         else:
4665             x, y, s, c, colors, edgecolors, linewidths = \
4666                 cbook._combine_masks(
4667                     x, y, s, c, colors, edgecolors, linewidths)
4668         # Unmask edgecolors if it was actually a single RGB or RGBA.
4669         if (x.size in (3, 4)
4670                 and np.ma.is_masked(edgecolors)
4671                 and not np.ma.is_masked(orig_edgecolor)):
4672             edgecolors = edgecolors.data
4673 
4674         scales = s   # Renamed for readability below.
4675 
4676         # load default marker from rcParams
4677         if marker is None:
4678             marker = mpl.rcParams['scatter.marker']
4679 
4680         if isinstance(marker, mmarkers.MarkerStyle):
4681             marker_obj = marker
4682         else:
4683             marker_obj = mmarkers.MarkerStyle(marker)
4684 
4685         path = marker_obj.get_path().transformed(
4686             marker_obj.get_transform())
4687         if not marker_obj.is_filled():
4688             if orig_edgecolor is not None:
4689                 _api.warn_external(
4690                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4691                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4692                     "ignoring the edgecolor in favor of the facecolor.  This "
4693                     "behavior may change in the future."
4694                 )
4695             # We need to handle markers that cannot be filled (like
4696             # '+' and 'x') differently than markers that can be
4697             # filled, but have their fillstyle set to 'none'.  This is
4698             # to get:
4699             #
4700             #  - respecting the fillestyle if set
4701             #  - maintaining back-compatibility for querying the facecolor of
4702             #    the un-fillable markers.
4703             #
4704             # While not an ideal situation, but is better than the
4705             # alternatives.
4706             if marker_obj.get_fillstyle() == 'none':
4707                 # promote the facecolor to be the edgecolor
4708                 edgecolors = colors
4709                 # set the facecolor to 'none' (at the last chance) because
4710                 # we cannot fill a path if the facecolor is non-null
4711                 # (which is defendable at the renderer level).
4712                 colors = 'none'
4713             else:
4714                 # if we are not nulling the face color we can do this
4715                 # simpler
4716                 edgecolors = 'face'
4717 
4718             if linewidths is None:
4719                 linewidths = mpl.rcParams['lines.linewidth']
4720             elif np.iterable(linewidths):
4721                 linewidths = [
4722                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4723                     for lw in linewidths]
4724 
4725         offsets = np.ma.column_stack([x, y])
4726 
4727         collection = mcoll.PathCollection(
4728             (path,), scales,
4729             facecolors=colors,
4730             edgecolors=edgecolors,
4731             linewidths=linewidths,
4732             offsets=offsets,
4733             offset_transform=kwargs.pop('transform', self.transData),
4734             alpha=alpha,
4735         )
4736         collection.set_transform(mtransforms.IdentityTransform())
4737         if colors is None:
4738             collection.set_array(c)
4739             collection.set_cmap(cmap)
4740             collection.set_norm(norm)
4741             collection._scale_norm(norm, vmin, vmax)
4742         else:
4743             extra_kwargs = {
4744                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4745                     }
4746             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4747             if any(extra_keys):
4748                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4749                 _api.warn_external(
4750                     "No data for colormapping provided via 'c'. "
4751                     f"Parameters {keys_str} will be ignored")
4752         collection._internal_update(kwargs)
4753 
4754         # Classic mode only:
4755         # ensure there are margins to allow for the
4756         # finite size of the symbols.  In v2.x, margins
4757         # are present by default, so we disable this
4758         # scatter-specific override.
4759         if mpl.rcParams['_internal.classic_mode']:
4760             if self._xmargin < 0.05 and x.size > 0:
4761                 self.set_xmargin(0.05)
4762             if self._ymargin < 0.05 and x.size > 0:
4763                 self.set_ymargin(0.05)
4764 
4765         self.add_collection(collection)
4766         self._request_autoscale_view()
4767 
4768         return collection
4769 
4770     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4771     @_docstring.dedent_interpd
4772     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4773                xscale='linear', yscale='linear', extent=None,
4774                cmap=None, norm=None, vmin=None, vmax=None,
4775                alpha=None, linewidths=None, edgecolors='face',
4776                reduce_C_function=np.mean, mincnt=None, marginals=False,
4777                **kwargs):
4778         """
4779         Make a 2D hexagonal binning plot of points *x*, *y*.
4780 
4781         If *C* is *None*, the value of the hexagon is determined by the number
4782         of points in the hexagon. Otherwise, *C* specifies values at the
4783         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4784         using *reduce_C_function*.
4785 
4786         Parameters
4787         ----------
4788         x, y : array-like
4789             The data positions. *x* and *y* must be of the same length.
4790 
4791         C : array-like, optional
4792             If given, these values are accumulated in the bins. Otherwise,
4793             every point has a value of 1. Must be of the same length as *x*
4794             and *y*.
4795 
4796         gridsize : int or (int, int), default: 100
4797             If a single int, the number of hexagons in the *x*-direction.
4798             The number of hexagons in the *y*-direction is chosen such that
4799             the hexagons are approximately regular.
4800 
4801             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4802             in the *x*-direction and the *y*-direction. In the
4803             *y*-direction, counting is done along vertically aligned
4804             hexagons, not along the zig-zag chains of hexagons; see the
4805             following illustration.
4806 
4807             .. plot::
4808 
4809                import numpy
4810                import matplotlib.pyplot as plt
4811 
4812                np.random.seed(19680801)
4813                n= 300
4814                x = np.random.standard_normal(n)
4815                y = np.random.standard_normal(n)
4816 
4817                fig, ax = plt.subplots(figsize=(4, 4))
4818                h = ax.hexbin(x, y, gridsize=(5, 3))
4819                hx, hy = h.get_offsets().T
4820                ax.plot(hx[24::3], hy[24::3], 'ro-')
4821                ax.plot(hx[-3:], hy[-3:], 'ro-')
4822                ax.set_title('gridsize=(5, 3)')
4823                ax.axis('off')
4824 
4825             To get approximately regular hexagons, choose
4826             :math:`n_x = \\sqrt{3}\\,n_y`.
4827 
4828         bins : 'log' or int or sequence, default: None
4829             Discretization of the hexagon values.
4830 
4831             - If *None*, no binning is applied; the color of each hexagon
4832               directly corresponds to its count value.
4833             - If 'log', use a logarithmic scale for the colormap.
4834               Internally, :math:`log_{10}(i+1)` is used to determine the
4835               hexagon color. This is equivalent to ``norm=LogNorm()``.
4836             - If an integer, divide the counts in the specified number
4837               of bins, and color the hexagons accordingly.
4838             - If a sequence of values, the values of the lower bound of
4839               the bins to be used.
4840 
4841         xscale : {'linear', 'log'}, default: 'linear'
4842             Use a linear or log10 scale on the horizontal axis.
4843 
4844         yscale : {'linear', 'log'}, default: 'linear'
4845             Use a linear or log10 scale on the vertical axis.
4846 
4847         mincnt : int > 0, default: *None*
4848             If not *None*, only display cells with more than *mincnt*
4849             number of points in the cell.
4850 
4851         marginals : bool, default: *False*
4852             If marginals is *True*, plot the marginal density as
4853             colormapped rectangles along the bottom of the x-axis and
4854             left of the y-axis.
4855 
4856         extent : 4-tuple of float, default: *None*
4857             The limits of the bins (xmin, xmax, ymin, ymax).
4858             The default assigns the limits based on
4859             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4860 
4861             If *xscale* or *yscale* is set to 'log', the limits are
4862             expected to be the exponent for a power of 10. E.g. for
4863             x-limits of 1 and 50 in 'linear' scale and y-limits
4864             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4865 
4866         Returns
4867         -------
4868         `~matplotlib.collections.PolyCollection`
4869             A `.PolyCollection` defining the hexagonal bins.
4870 
4871             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4872               the x, y positions of the M hexagon centers.
4873             - `.PolyCollection.get_array` contains the values of the M
4874               hexagons.
4875 
4876             If *marginals* is *True*, horizontal
4877             bar and vertical bar (both PolyCollections) will be attached
4878             to the return collection as attributes *hbar* and *vbar*.
4879 
4880         Other Parameters
4881         ----------------
4882         %(cmap_doc)s
4883 
4884         %(norm_doc)s
4885 
4886         %(vmin_vmax_doc)s
4887 
4888         alpha : float between 0 and 1, optional
4889             The alpha blending value, between 0 (transparent) and 1 (opaque).
4890 
4891         linewidths : float, default: *None*
4892             If *None*, defaults to :rc:`patch.linewidth`.
4893 
4894         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4895             The color of the hexagon edges. Possible values are:
4896 
4897             - 'face': Draw the edges in the same color as the fill color.
4898             - 'none': No edges are drawn. This can sometimes lead to unsightly
4899               unpainted pixels between the hexagons.
4900             - *None*: Draw outlines in the default color.
4901             - An explicit color.
4902 
4903         reduce_C_function : callable, default: `numpy.mean`
4904             The function to aggregate *C* within the bins. It is ignored if
4905             *C* is not given. This must have the signature::
4906 
4907                 def reduce_C_function(C: array) -> float
4908 
4909             Commonly used functions are:
4910 
4911             - `numpy.mean`: average of the points
4912             - `numpy.sum`: integral of the point values
4913             - `numpy.amax`: value taken from the largest point
4914 
4915         data : indexable object, optional
4916             DATA_PARAMETER_PLACEHOLDER
4917 
4918         **kwargs : `~matplotlib.collections.PolyCollection` properties
4919             All other keyword arguments are passed on to `.PolyCollection`:
4920 
4921             %(PolyCollection:kwdoc)s
4922 
4923         See Also
4924         --------
4925         hist2d : 2D histogram rectangular bins
4926         """
4927         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4928 
4929         x, y, C = cbook.delete_masked_points(x, y, C)
4930 
4931         # Set the size of the hexagon grid
4932         if np.iterable(gridsize):
4933             nx, ny = gridsize
4934         else:
4935             nx = gridsize
4936             ny = int(nx / math.sqrt(3))
4937         # Count the number of data in each hexagon
4938         x = np.asarray(x, float)
4939         y = np.asarray(y, float)
4940 
4941         # Will be log()'d if necessary, and then rescaled.
4942         tx = x
4943         ty = y
4944 
4945         if xscale == 'log':
4946             if np.any(x <= 0.0):
4947                 raise ValueError(
4948                     "x contains non-positive values, so cannot be log-scaled")
4949             tx = np.log10(tx)
4950         if yscale == 'log':
4951             if np.any(y <= 0.0):
4952                 raise ValueError(
4953                     "y contains non-positive values, so cannot be log-scaled")
4954             ty = np.log10(ty)
4955         if extent is not None:
4956             xmin, xmax, ymin, ymax = extent
4957         else:
4958             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4959             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4960 
4961             # to avoid issues with singular data, expand the min/max pairs
4962             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4963             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4964 
4965         nx1 = nx + 1
4966         ny1 = ny + 1
4967         nx2 = nx
4968         ny2 = ny
4969         n = nx1 * ny1 + nx2 * ny2
4970 
4971         # In the x-direction, the hexagons exactly cover the region from
4972         # xmin to xmax. Need some padding to avoid roundoff errors.
4973         padding = 1.e-9 * (xmax - xmin)
4974         xmin -= padding
4975         xmax += padding
4976         sx = (xmax - xmin) / nx
4977         sy = (ymax - ymin) / ny
4978         # Positions in hexagon index coordinates.
4979         ix = (tx - xmin) / sx
4980         iy = (ty - ymin) / sy
4981         ix1 = np.round(ix).astype(int)
4982         iy1 = np.round(iy).astype(int)
4983         ix2 = np.floor(ix).astype(int)
4984         iy2 = np.floor(iy).astype(int)
4985         # flat indices, plus one so that out-of-range points go to position 0.
4986         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4987                       ix1 * ny1 + iy1 + 1, 0)
4988         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4989                       ix2 * ny2 + iy2 + 1, 0)
4990 
4991         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4992         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4993         bdist = (d1 < d2)
4994 
4995         if C is None:  # [1:] drops out-of-range points.
4996             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4997             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4998             accum = np.concatenate([counts1, counts2]).astype(float)
4999             if mincnt is not None:
5000                 accum[accum < mincnt] = np.nan
5001             C = np.ones(len(x))
5002         else:
5003             # store the C values in a list per hexagon index
5004             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
5005             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
5006             for i in range(len(x)):
5007                 if bdist[i]:
5008                     Cs_at_i1[i1[i]].append(C[i])
5009                 else:
5010                     Cs_at_i2[i2[i]].append(C[i])
5011             if mincnt is None:
5012                 mincnt = 0
5013             accum = np.array(
5014                 [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
5015                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
5016                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
5017                 float)
5018 
5019         good_idxs = ~np.isnan(accum)
5020 
5021         offsets = np.zeros((n, 2), float)
5022         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
5023         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
5024         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
5025         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
5026         offsets[:, 0] *= sx
5027         offsets[:, 1] *= sy
5028         offsets[:, 0] += xmin
5029         offsets[:, 1] += ymin
5030         # remove accumulation bins with no data
5031         offsets = offsets[good_idxs, :]
5032         accum = accum[good_idxs]
5033 
5034         polygon = [sx, sy / 3] * np.array(
5035             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5036 
5037         if linewidths is None:
5038             linewidths = [mpl.rcParams['patch.linewidth']]
5039 
5040         if xscale == 'log' or yscale == 'log':
5041             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5042             if xscale == 'log':
5043                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5044                 xmin = 10.0 ** xmin
5045                 xmax = 10.0 ** xmax
5046                 self.set_xscale(xscale)
5047             if yscale == 'log':
5048                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5049                 ymin = 10.0 ** ymin
5050                 ymax = 10.0 ** ymax
5051                 self.set_yscale(yscale)
5052             collection = mcoll.PolyCollection(
5053                 polygons,
5054                 edgecolors=edgecolors,
5055                 linewidths=linewidths,
5056                 )
5057         else:
5058             collection = mcoll.PolyCollection(
5059                 [polygon],
5060                 edgecolors=edgecolors,
5061                 linewidths=linewidths,
5062                 offsets=offsets,
5063                 offset_transform=mtransforms.AffineDeltaTransform(
5064                     self.transData),
5065             )
5066 
5067         # Set normalizer if bins is 'log'
5068         if bins == 'log':
5069             if norm is not None:
5070                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5071                                    f"can be supplied, ignoring bins={bins}")
5072             else:
5073                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5074                 vmin = vmax = None
5075             bins = None
5076 
5077         # autoscale the norm with current accum values if it hasn't been set
5078         if norm is not None:
5079             if norm.vmin is None and norm.vmax is None:
5080                 norm.autoscale(accum)
5081 
5082         if bins is not None:
5083             if not np.iterable(bins):
5084                 minimum, maximum = min(accum), max(accum)
5085                 bins -= 1  # one less edge than bins
5086                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5087             bins = np.sort(bins)
5088             accum = bins.searchsorted(accum)
5089 
5090         collection.set_array(accum)
5091         collection.set_cmap(cmap)
5092         collection.set_norm(norm)
5093         collection.set_alpha(alpha)
5094         collection._internal_update(kwargs)
5095         collection._scale_norm(norm, vmin, vmax)
5096 
5097         corners = ((xmin, ymin), (xmax, ymax))
5098         self.update_datalim(corners)
5099         self._request_autoscale_view(tight=True)
5100 
5101         # add the collection last
5102         self.add_collection(collection, autolim=False)
5103         if not marginals:
5104             return collection
5105 
5106         # Process marginals
5107         bars = []
5108         for zname, z, zmin, zmax, zscale, nbins in [
5109                 ("x", x, xmin, xmax, xscale, nx),
5110                 ("y", y, ymin, ymax, yscale, 2 * ny),
5111         ]:
5112 
5113             if zscale == "log":
5114                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5115             else:
5116                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5117 
5118             verts = np.empty((nbins, 4, 2))
5119             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5120             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5121             verts[:, 0, 1] = verts[:, 3, 1] = .00
5122             verts[:, 1, 1] = verts[:, 2, 1] = .05
5123             if zname == "y":
5124                 verts = verts[:, :, ::-1]  # Swap x and y.
5125 
5126             # Sort z-values into bins defined by bin_edges.
5127             bin_idxs = np.searchsorted(bin_edges, z) - 1
5128             values = np.empty(nbins)
5129             for i in range(nbins):
5130                 # Get C-values for each bin, and compute bin value with
5131                 # reduce_C_function.
5132                 ci = C[bin_idxs == i]
5133                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5134 
5135             mask = ~np.isnan(values)
5136             verts = verts[mask]
5137             values = values[mask]
5138 
5139             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5140             bar = mcoll.PolyCollection(
5141                 verts, transform=trans, edgecolors="face")
5142             bar.set_array(values)
5143             bar.set_cmap(cmap)
5144             bar.set_norm(norm)
5145             bar.set_alpha(alpha)
5146             bar._internal_update(kwargs)
5147             bars.append(self.add_collection(bar, autolim=False))
5148 
5149         collection.hbar, collection.vbar = bars
5150 
5151         def on_changed(collection):
5152             collection.hbar.set_cmap(collection.get_cmap())
5153             collection.hbar.set_cmap(collection.get_cmap())
5154             collection.vbar.set_clim(collection.get_clim())
5155             collection.vbar.set_clim(collection.get_clim())
5156 
5157         collection.callbacks.connect('changed', on_changed)
5158 
5159         return collection
5160 
5161     @_docstring.dedent_interpd
5162     def arrow(self, x, y, dx, dy, **kwargs):
5163         """
5164         Add an arrow to the Axes.
5165 
5166         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5167 
5168         Parameters
5169         ----------
5170         %(FancyArrow)s
5171 
5172         Returns
5173         -------
5174         `.FancyArrow`
5175             The created `.FancyArrow` object.
5176 
5177         Notes
5178         -----
5179         The resulting arrow is affected by the Axes aspect ratio and limits.
5180         This may produce an arrow whose head is not square with its stem. To
5181         create an arrow whose head is square with its stem,
5182         use :meth:`annotate` for example:
5183 
5184         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5185         ...             arrowprops=dict(arrowstyle="->"))
5186 
5187         """
5188         # Strip away units for the underlying patch since units
5189         # do not make sense to most patch-like code
5190         x = self.convert_xunits(x)
5191         y = self.convert_yunits(y)
5192         dx = self.convert_xunits(dx)
5193         dy = self.convert_yunits(dy)
5194 
5195         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5196         self.add_patch(a)
5197         self._request_autoscale_view()
5198         return a
5199 
5200     @_docstring.copy(mquiver.QuiverKey.__init__)
5201     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5202         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5203         self.add_artist(qk)
5204         return qk
5205 
5206     # Handle units for x and y, if they've been passed
5207     def _quiver_units(self, args, kwargs):
5208         if len(args) > 3:
5209             x, y = args[0:2]
5210             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5211             return (x, y) + args[2:]
5212         return args
5213 
5214     # args can be a combination of X, Y, U, V, C and all should be replaced
5215     @_preprocess_data()
5216     @_docstring.dedent_interpd
5217     def quiver(self, *args, **kwargs):
5218         """%(quiver_doc)s"""
5219         # Make sure units are handled for x and y values
5220         args = self._quiver_units(args, kwargs)
5221         q = mquiver.Quiver(self, *args, **kwargs)
5222         self.add_collection(q, autolim=True)
5223         self._request_autoscale_view()
5224         return q
5225 
5226     # args can be some combination of X, Y, U, V, C and all should be replaced
5227     @_preprocess_data()
5228     @_docstring.dedent_interpd
5229     def barbs(self, *args, **kwargs):
5230         """%(barbs_doc)s"""
5231         # Make sure units are handled for x and y values
5232         args = self._quiver_units(args, kwargs)
5233         b = mquiver.Barbs(self, *args, **kwargs)
5234         self.add_collection(b, autolim=True)
5235         self._request_autoscale_view()
5236         return b
5237 
5238     # Uses a custom implementation of data-kwarg handling in
5239     # _process_plot_var_args.
5240     def fill(self, *args, data=None, **kwargs):
5241         """
5242         Plot filled polygons.
5243 
5244         Parameters
5245         ----------
5246         *args : sequence of x, y, [color]
5247             Each polygon is defined by the lists of *x* and *y* positions of
5248             its nodes, optionally followed by a *color* specifier. See
5249             :mod:`matplotlib.colors` for supported color specifiers. The
5250             standard color cycle is used for polygons without a color
5251             specifier.
5252 
5253             You can plot multiple polygons by providing multiple *x*, *y*,
5254             *[color]* groups.
5255 
5256             For example, each of the following is legal::
5257 
5258                 ax.fill(x, y)                    # a polygon with default color
5259                 ax.fill(x, y, "b")               # a blue polygon
5260                 ax.fill(x, y, x2, y2)            # two polygons
5261                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5262 
5263         data : indexable object, optional
5264             An object with labelled data. If given, provide the label names to
5265             plot in *x* and *y*, e.g.::
5266 
5267                 ax.fill("time", "signal",
5268                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5269 
5270         Returns
5271         -------
5272         list of `~matplotlib.patches.Polygon`
5273 
5274         Other Parameters
5275         ----------------
5276         **kwargs : `~matplotlib.patches.Polygon` properties
5277 
5278         Notes
5279         -----
5280         Use :meth:`fill_between` if you would like to fill the region between
5281         two curves.
5282         """
5283         # For compatibility(!), get aliases from Line2D rather than Patch.
5284         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5285         # _get_patches_for_fill returns a generator, convert it to a list.
5286         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5287         for poly in patches:
5288             self.add_patch(poly)
5289         self._request_autoscale_view()
5290         return patches
5291 
5292     def _fill_between_x_or_y(
5293             self, ind_dir, ind, dep1, dep2=0, *,
5294             where=None, interpolate=False, step=None, **kwargs):
5295         # Common implementation between fill_between (*ind_dir*="x") and
5296         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5297         # *dep* the dependent variable.  The docstring below is interpolated
5298         # to generate both methods' docstrings.
5299         """
5300         Fill the area between two {dir} curves.
5301 
5302         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5303         *{dep}2*).  This creates one or multiple polygons describing the filled
5304         area.
5305 
5306         You may exclude some {dir} sections from filling using *where*.
5307 
5308         By default, the edges connect the given points directly.  Use *step*
5309         if the filling should be a step function, i.e. constant in between
5310         *{ind}*.
5311 
5312         Parameters
5313         ----------
5314         {ind} : array (length N)
5315             The {ind} coordinates of the nodes defining the curves.
5316 
5317         {dep}1 : array (length N) or scalar
5318             The {dep} coordinates of the nodes defining the first curve.
5319 
5320         {dep}2 : array (length N) or scalar, default: 0
5321             The {dep} coordinates of the nodes defining the second curve.
5322 
5323         where : array of bool (length N), optional
5324             Define *where* to exclude some {dir} regions from being filled.
5325             The filled regions are defined by the coordinates ``{ind}[where]``.
5326             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5327             ``where[i] and where[i+1]``.  Note that this definition implies
5328             that an isolated *True* value between two *False* values in *where*
5329             will not result in filling.  Both sides of the *True* position
5330             remain unfilled due to the adjacent *False* values.
5331 
5332         interpolate : bool, default: False
5333             This option is only relevant if *where* is used and the two curves
5334             are crossing each other.
5335 
5336             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5337             similar.  By default, the nodes of the polygon defining the filled
5338             region will only be placed at the positions in the *{ind}* array.
5339             Such a polygon cannot describe the above semantics close to the
5340             intersection.  The {ind}-sections containing the intersection are
5341             simply clipped.
5342 
5343             Setting *interpolate* to *True* will calculate the actual
5344             intersection point and extend the filled region up to this point.
5345 
5346         step : {{'pre', 'post', 'mid'}}, optional
5347             Define *step* if the filling should be a step function,
5348             i.e. constant in between *{ind}*.  The value determines where the
5349             step will occur:
5350 
5351             - 'pre': The y value is continued constantly to the left from
5352               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5353               value ``y[i]``.
5354             - 'post': The y value is continued constantly to the right from
5355               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5356               value ``y[i]``.
5357             - 'mid': Steps occur half-way between the *x* positions.
5358 
5359         Returns
5360         -------
5361         `.PolyCollection`
5362             A `.PolyCollection` containing the plotted polygons.
5363 
5364         Other Parameters
5365         ----------------
5366         data : indexable object, optional
5367             DATA_PARAMETER_PLACEHOLDER
5368 
5369         **kwargs
5370             All other keyword arguments are passed on to `.PolyCollection`.
5371             They control the `.Polygon` properties:
5372 
5373             %(PolyCollection:kwdoc)s
5374 
5375         See Also
5376         --------
5377         fill_between : Fill between two sets of y-values.
5378         fill_betweenx : Fill between two sets of x-values.
5379         """
5380 
5381         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5382 
5383         if not mpl.rcParams["_internal.classic_mode"]:
5384             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5385             if not any(c in kwargs for c in ("color", "facecolor")):
5386                 kwargs["facecolor"] = \
5387                     self._get_patches_for_fill.get_next_color()
5388 
5389         # Handle united data, such as dates
5390         ind, dep1, dep2 = map(
5391             ma.masked_invalid, self._process_unit_info(
5392                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5393 
5394         for name, array in [
5395                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5396             if array.ndim > 1:
5397                 raise ValueError(f"{name!r} is not 1-dimensional")
5398 
5399         if where is None:
5400             where = True
5401         else:
5402             where = np.asarray(where, dtype=bool)
5403             if where.size != ind.size:
5404                 raise ValueError(f"where size ({where.size}) does not match "
5405                                  f"{ind_dir} size ({ind.size})")
5406         where = where & ~functools.reduce(
5407             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5408 
5409         ind, dep1, dep2 = np.broadcast_arrays(
5410             np.atleast_1d(ind), dep1, dep2, subok=True)
5411 
5412         polys = []
5413         for idx0, idx1 in cbook.contiguous_regions(where):
5414             indslice = ind[idx0:idx1]
5415             dep1slice = dep1[idx0:idx1]
5416             dep2slice = dep2[idx0:idx1]
5417             if step is not None:
5418                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5419                 indslice, dep1slice, dep2slice = \
5420                     step_func(indslice, dep1slice, dep2slice)
5421 
5422             if not len(indslice):
5423                 continue
5424 
5425             N = len(indslice)
5426             pts = np.zeros((2 * N + 2, 2))
5427 
5428             if interpolate:
5429                 def get_interp_point(idx):
5430                     im1 = max(idx - 1, 0)
5431                     ind_values = ind[im1:idx+1]
5432                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5433                     dep1_values = dep1[im1:idx+1]
5434 
5435                     if len(diff_values) == 2:
5436                         if np.ma.is_masked(diff_values[1]):
5437                             return ind[im1], dep1[im1]
5438                         elif np.ma.is_masked(diff_values[0]):
5439                             return ind[idx], dep1[idx]
5440 
5441                     diff_order = diff_values.argsort()
5442                     diff_root_ind = np.interp(
5443                         0, diff_values[diff_order], ind_values[diff_order])
5444                     ind_order = ind_values.argsort()
5445                     diff_root_dep = np.interp(
5446                         diff_root_ind,
5447                         ind_values[ind_order], dep1_values[ind_order])
5448                     return diff_root_ind, diff_root_dep
5449 
5450                 start = get_interp_point(idx0)
5451                 end = get_interp_point(idx1)
5452             else:
5453                 # Handle scalar dep2 (e.g. 0): the fill should go all
5454                 # the way down to 0 even if none of the dep1 sample points do.
5455                 start = indslice[0], dep2slice[0]
5456                 end = indslice[-1], dep2slice[-1]
5457 
5458             pts[0] = start
5459             pts[N + 1] = end
5460 
5461             pts[1:N+1, 0] = indslice
5462             pts[1:N+1, 1] = dep1slice
5463             pts[N+2:, 0] = indslice[::-1]
5464             pts[N+2:, 1] = dep2slice[::-1]
5465 
5466             if ind_dir == "y":
5467                 pts = pts[:, ::-1]
5468 
5469             polys.append(pts)
5470 
5471         collection = mcoll.PolyCollection(polys, **kwargs)
5472 
5473         # now update the datalim and autoscale
5474         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5475                             np.column_stack([ind[where], dep2[where]])])
5476         if ind_dir == "y":
5477             pts = pts[:, ::-1]
5478 
5479         up_x = up_y = True
5480         if "transform" in kwargs:
5481             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5482         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5483 
5484         self.add_collection(collection, autolim=False)
5485         self._request_autoscale_view()
5486         return collection
5487 
5488     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5489                      step=None, **kwargs):
5490         return self._fill_between_x_or_y(
5491             "x", x, y1, y2,
5492             where=where, interpolate=interpolate, step=step, **kwargs)
5493 
5494     if _fill_between_x_or_y.__doc__:
5495         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5496             dir="horizontal", ind="x", dep="y"
5497         )
5498     fill_between = _preprocess_data(
5499         _docstring.dedent_interpd(fill_between),
5500         replace_names=["x", "y1", "y2", "where"])
5501 
5502     def fill_betweenx(self, y, x1, x2=0, where=None,
5503                       step=None, interpolate=False, **kwargs):
5504         return self._fill_between_x_or_y(
5505             "y", y, x1, x2,
5506             where=where, interpolate=interpolate, step=step, **kwargs)
5507 
5508     if _fill_between_x_or_y.__doc__:
5509         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5510             dir="vertical", ind="y", dep="x"
5511         )
5512     fill_betweenx = _preprocess_data(
5513         _docstring.dedent_interpd(fill_betweenx),
5514         replace_names=["y", "x1", "x2", "where"])
5515 
5516     #### plotting z(x, y): imshow, pcolor and relatives, contour
5517 
5518     @_preprocess_data()
5519     @_docstring.interpd
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im
5742 
5743     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5744         # - create X and Y if not present;
5745         # - reshape X and Y as needed if they are 1-D;
5746         # - check for proper sizes based on `shading` kwarg;
5747         # - reset shading if shading='auto' to flat or nearest
5748         #   depending on size;
5749 
5750         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5751         try:
5752             _api.check_in_list(_valid_shading, shading=shading)
5753         except ValueError:
5754             _api.warn_external(f"shading value '{shading}' not in list of "
5755                                f"valid values {_valid_shading}. Setting "
5756                                "shading='auto'.")
5757             shading = 'auto'
5758 
5759         if len(args) == 1:
5760             C = np.asanyarray(args[0])
5761             nrows, ncols = C.shape[:2]
5762             if shading in ['gouraud', 'nearest']:
5763                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5764             else:
5765                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5766                 shading = 'flat'
5767             C = cbook.safe_masked_invalid(C, copy=True)
5768             return X, Y, C, shading
5769 
5770         if len(args) == 3:
5771             # Check x and y for bad data...
5772             C = np.asanyarray(args[2])
5773             # unit conversion allows e.g. datetime objects as axis values
5774             X, Y = args[:2]
5775             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5776             X, Y = [cbook.safe_masked_invalid(a, copy=True) for a in [X, Y]]
5777 
5778             if funcname == 'pcolormesh':
5779                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5780                     raise ValueError(
5781                         'x and y arguments to pcolormesh cannot have '
5782                         'non-finite values or be of type '
5783                         'numpy.ma.MaskedArray with masked values')
5784             nrows, ncols = C.shape[:2]
5785         else:
5786             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5787 
5788         Nx = X.shape[-1]
5789         Ny = Y.shape[0]
5790         if X.ndim != 2 or X.shape[0] == 1:
5791             x = X.reshape(1, Nx)
5792             X = x.repeat(Ny, axis=0)
5793         if Y.ndim != 2 or Y.shape[1] == 1:
5794             y = Y.reshape(Ny, 1)
5795             Y = y.repeat(Nx, axis=1)
5796         if X.shape != Y.shape:
5797             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5798                             f'see help({funcname})')
5799 
5800         if shading == 'auto':
5801             if ncols == Nx and nrows == Ny:
5802                 shading = 'nearest'
5803             else:
5804                 shading = 'flat'
5805 
5806         if shading == 'flat':
5807             if (Nx, Ny) != (ncols + 1, nrows + 1):
5808                 raise TypeError(f"Dimensions of C {C.shape} should"
5809                                 f" be one smaller than X({Nx}) and Y({Ny})"
5810                                 f" while using shading='flat'"
5811                                 f" see help({funcname})")
5812         else:    # ['nearest', 'gouraud']:
5813             if (Nx, Ny) != (ncols, nrows):
5814                 raise TypeError('Dimensions of C %s are incompatible with'
5815                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5816                                     C.shape, Nx, Ny, funcname))
5817             if shading == 'nearest':
5818                 # grid is specified at the center, so define corners
5819                 # at the midpoints between the grid centers and then use the
5820                 # flat algorithm.
5821                 def _interp_grid(X):
5822                     # helper for below
5823                     if np.shape(X)[1] > 1:
5824                         dX = np.diff(X, axis=1)/2.
5825                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5826                             _api.warn_external(
5827                                 f"The input coordinates to {funcname} are "
5828                                 "interpreted as cell centers, but are not "
5829                                 "monotonically increasing or decreasing. "
5830                                 "This may lead to incorrectly calculated cell "
5831                                 "edges, in which case, please supply "
5832                                 f"explicit cell edges to {funcname}.")
5833 
5834                         hstack = np.ma.hstack if np.ma.isMA(X) else np.hstack
5835                         X = hstack((X[:, [0]] - dX[:, [0]],
5836                                     X[:, :-1] + dX,
5837                                     X[:, [-1]] + dX[:, [-1]]))
5838                     else:
5839                         # This is just degenerate, but we can't reliably guess
5840                         # a dX if there is just one value.
5841                         X = np.hstack((X, X))
5842                     return X
5843 
5844                 if ncols == Nx:
5845                     X = _interp_grid(X)
5846                     Y = _interp_grid(Y)
5847                 if nrows == Ny:
5848                     X = _interp_grid(X.T).T
5849                     Y = _interp_grid(Y.T).T
5850                 shading = 'flat'
5851 
5852         C = cbook.safe_masked_invalid(C, copy=True)
5853         return X, Y, C, shading
5854 
5855     @_preprocess_data()
5856     @_docstring.dedent_interpd
5857     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5858                vmin=None, vmax=None, **kwargs):
5859         r"""
5860         Create a pseudocolor plot with a non-regular rectangular grid.
5861 
5862         Call signature::
5863 
5864             pcolor([X, Y,] C, **kwargs)
5865 
5866         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5867 
5868         .. hint::
5869 
5870             ``pcolor()`` can be very slow for large arrays. In most
5871             cases you should use the similar but much faster
5872             `~.Axes.pcolormesh` instead. See
5873             :ref:`Differences between pcolor() and pcolormesh()
5874             <differences-pcolor-pcolormesh>` for a discussion of the
5875             differences.
5876 
5877         Parameters
5878         ----------
5879         C : 2D array-like
5880             The color-mapped values.  Color-mapping is controlled by *cmap*,
5881             *norm*, *vmin*, and *vmax*.
5882 
5883         X, Y : array-like, optional
5884             The coordinates of the corners of quadrilaterals of a pcolormesh::
5885 
5886                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5887                                       ●╶───╴●
5888                                       │     │
5889                                       ●╶───╴●
5890                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5891 
5892             Note that the column index corresponds to the x-coordinate, and
5893             the row index corresponds to y. For details, see the
5894             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5895 
5896             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5897             greater than those of *C*, and the quadrilateral is colored due
5898             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5899             dimensions, a warning will be raised and the last row and column
5900             of *C* will be ignored.
5901 
5902             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5903             the same as those of *C* (if not, a ValueError will be raised). The
5904             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5905 
5906             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5907             expanded as needed into the appropriate 2D arrays, making a
5908             rectangular grid.
5909 
5910         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5911             The fill style for the quadrilateral. Possible values:
5912 
5913             - 'flat': A solid color is used for each quad. The color of the
5914               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5915               ``C[i, j]``. The dimensions of *X* and *Y* should be
5916               one greater than those of *C*; if they are the same as *C*,
5917               then a deprecation warning is raised, and the last row
5918               and column of *C* are dropped.
5919             - 'nearest': Each grid point will have a color centered on it,
5920               extending halfway between the adjacent grid centers.  The
5921               dimensions of *X* and *Y* must be the same as *C*.
5922             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5923               larger than *C*.  Choose 'nearest' if dimensions are the same.
5924 
5925             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5926             for more description.
5927 
5928         %(cmap_doc)s
5929 
5930         %(norm_doc)s
5931 
5932         %(vmin_vmax_doc)s
5933 
5934         edgecolors : {'none', None, 'face', color, color sequence}, optional
5935             The color of the edges. Defaults to 'none'. Possible values:
5936 
5937             - 'none' or '': No edge.
5938             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5939               :rc:`patch.force_edgecolor` has to be True for this to work.
5940             - 'face': Use the adjacent face color.
5941             - A color or sequence of colors will set the edge color.
5942 
5943             The singular form *edgecolor* works as an alias.
5944 
5945         alpha : float, default: None
5946             The alpha blending value of the face color, between 0 (transparent)
5947             and 1 (opaque). Note: The edgecolor is currently not affected by
5948             this.
5949 
5950         snap : bool, default: False
5951             Whether to snap the mesh to pixel boundaries.
5952 
5953         Returns
5954         -------
5955         `matplotlib.collections.PolyQuadMesh`
5956 
5957         Other Parameters
5958         ----------------
5959         antialiaseds : bool, default: False
5960             The default *antialiaseds* is False if the default
5961             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5962             at patch boundaries, and works regardless of the value of alpha.
5963             If *edgecolors* is not "none", then the default *antialiaseds*
5964             is taken from :rc:`patch.antialiased`.
5965             Stroking the edges may be preferred if *alpha* is 1, but will
5966             cause artifacts otherwise.
5967 
5968         data : indexable object, optional
5969             DATA_PARAMETER_PLACEHOLDER
5970 
5971         **kwargs
5972             Additionally, the following arguments are allowed. They are passed
5973             along to the `~matplotlib.collections.PolyQuadMesh` constructor:
5974 
5975         %(PolyCollection:kwdoc)s
5976 
5977         See Also
5978         --------
5979         pcolormesh : for an explanation of the differences between
5980             pcolor and pcolormesh.
5981         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5982             faster alternative.
5983 
5984         Notes
5985         -----
5986         **Masked arrays**
5987 
5988         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5989         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5990         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5991         plotted.
5992 
5993         .. _axes-pcolor-grid-orientation:
5994 
5995         **Grid orientation**
5996 
5997         The grid orientation follows the standard matrix convention: An array
5998         *C* with shape (nrows, ncolumns) is plotted with the column number as
5999         *X* and the row number as *Y*.
6000         """
6001 
6002         if shading is None:
6003             shading = mpl.rcParams['pcolor.shading']
6004         shading = shading.lower()
6005         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
6006                                             kwargs=kwargs)
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiaseds' in kwargs:
6021             kwargs['antialiased'] = kwargs.pop('antialiaseds')
6022         if 'antialiased' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiased'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         if np.ma.isMaskedArray(X) or np.ma.isMaskedArray(Y):
6028             stack = np.ma.stack
6029             X = np.ma.asarray(X)
6030             Y = np.ma.asarray(Y)
6031             # For bounds collections later
6032             x = X.compressed()
6033             y = Y.compressed()
6034         else:
6035             stack = np.stack
6036             x = X
6037             y = Y
6038         coords = stack([X, Y], axis=-1)
6039 
6040         collection = mcoll.PolyQuadMesh(
6041             coords, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6042         collection._scale_norm(norm, vmin, vmax)
6043 
6044         # Transform from native to data coordinates?
6045         t = collection._transform
6046         if (not isinstance(t, mtransforms.Transform) and
6047                 hasattr(t, '_as_mpl_transform')):
6048             t = t._as_mpl_transform(self.axes)
6049 
6050         if t and any(t.contains_branch_seperately(self.transData)):
6051             trans_to_data = t - self.transData
6052             pts = np.vstack([x, y]).T.astype(float)
6053             transformed_pts = trans_to_data.transform(pts)
6054             x = transformed_pts[..., 0]
6055             y = transformed_pts[..., 1]
6056 
6057         self.add_collection(collection, autolim=False)
6058 
6059         minx = np.min(x)
6060         maxx = np.max(x)
6061         miny = np.min(y)
6062         maxy = np.max(y)
6063         collection.sticky_edges.x[:] = [minx, maxx]
6064         collection.sticky_edges.y[:] = [miny, maxy]
6065         corners = (minx, miny), (maxx, maxy)
6066         self.update_datalim(corners)
6067         self._request_autoscale_view()
6068         return collection
6069 
6070     @_preprocess_data()
6071     @_docstring.dedent_interpd
6072     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6073                    vmax=None, shading=None, antialiased=False, **kwargs):
6074         """
6075         Create a pseudocolor plot with a non-regular rectangular grid.
6076 
6077         Call signature::
6078 
6079             pcolormesh([X, Y,] C, **kwargs)
6080 
6081         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6082 
6083         .. hint::
6084 
6085            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6086            and preferred in most cases. For a detailed discussion on the
6087            differences see :ref:`Differences between pcolor() and pcolormesh()
6088            <differences-pcolor-pcolormesh>`.
6089 
6090         Parameters
6091         ----------
6092         C : array-like
6093             The mesh data. Supported array shapes are:
6094 
6095             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6096               colors using normalization and a colormap. See parameters *norm*,
6097               *cmap*, *vmin*, *vmax*.
6098             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6099             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6100               i.e. including transparency.
6101 
6102             The first two dimensions (M, N) define the rows and columns of
6103             the mesh data.
6104 
6105         X, Y : array-like, optional
6106             The coordinates of the corners of quadrilaterals of a pcolormesh::
6107 
6108                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6109                                       ●╶───╴●
6110                                       │     │
6111                                       ●╶───╴●
6112                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6113 
6114             Note that the column index corresponds to the x-coordinate, and
6115             the row index corresponds to y. For details, see the
6116             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6117 
6118             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6119             greater than those of *C*, and the quadrilateral is colored due
6120             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6121             dimensions, a warning will be raised and the last row and column
6122             of *C* will be ignored.
6123 
6124             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6125             and *Y* should be the same as those of *C* (if not, a ValueError
6126             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6127             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6128             interpolation is caried out between the quadrilateral corners.
6129 
6130             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6131             expanded as needed into the appropriate 2D arrays, making a
6132             rectangular grid.
6133 
6134         %(cmap_doc)s
6135 
6136         %(norm_doc)s
6137 
6138         %(vmin_vmax_doc)s
6139 
6140         edgecolors : {'none', None, 'face', color, color sequence}, optional
6141             The color of the edges. Defaults to 'none'. Possible values:
6142 
6143             - 'none' or '': No edge.
6144             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6145               :rc:`patch.force_edgecolor` has to be True for this to work.
6146             - 'face': Use the adjacent face color.
6147             - A color or sequence of colors will set the edge color.
6148 
6149             The singular form *edgecolor* works as an alias.
6150 
6151         alpha : float, default: None
6152             The alpha blending value, between 0 (transparent) and 1 (opaque).
6153 
6154         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6155             The fill style for the quadrilateral; defaults to
6156             :rc:`pcolor.shading`. Possible values:
6157 
6158             - 'flat': A solid color is used for each quad. The color of the
6159               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6160               ``C[i, j]``. The dimensions of *X* and *Y* should be
6161               one greater than those of *C*; if they are the same as *C*,
6162               then a deprecation warning is raised, and the last row
6163               and column of *C* are dropped.
6164             - 'nearest': Each grid point will have a color centered on it,
6165               extending halfway between the adjacent grid centers.  The
6166               dimensions of *X* and *Y* must be the same as *C*.
6167             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6168               corners (i', j') are given by ``C[i', j']``. The color values of
6169               the area in between is interpolated from the corner values.
6170               The dimensions of *X* and *Y* must be the same as *C*. When
6171               Gouraud shading is used, *edgecolors* is ignored.
6172             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6173               larger than *C*.  Choose 'nearest' if dimensions are the same.
6174 
6175             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6176             for more description.
6177 
6178         snap : bool, default: False
6179             Whether to snap the mesh to pixel boundaries.
6180 
6181         rasterized : bool, optional
6182             Rasterize the pcolormesh when drawing vector graphics.  This can
6183             speed up rendering and produce smaller files for large data sets.
6184             See also :doc:`/gallery/misc/rasterization_demo`.
6185 
6186         Returns
6187         -------
6188         `matplotlib.collections.QuadMesh`
6189 
6190         Other Parameters
6191         ----------------
6192         data : indexable object, optional
6193             DATA_PARAMETER_PLACEHOLDER
6194 
6195         **kwargs
6196             Additionally, the following arguments are allowed. They are passed
6197             along to the `~matplotlib.collections.QuadMesh` constructor:
6198 
6199         %(QuadMesh:kwdoc)s
6200 
6201         See Also
6202         --------
6203         pcolor : An alternative implementation with slightly different
6204             features. For a detailed discussion on the differences see
6205             :ref:`Differences between pcolor() and pcolormesh()
6206             <differences-pcolor-pcolormesh>`.
6207         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6208             faster alternative.
6209 
6210         Notes
6211         -----
6212         **Masked arrays**
6213 
6214         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6215         quadrilateral will be transparent. Masking of *X* and *Y* is not
6216         supported. Use `~.Axes.pcolor` if you need this functionality.
6217 
6218         .. _axes-pcolormesh-grid-orientation:
6219 
6220         **Grid orientation**
6221 
6222         The grid orientation follows the standard matrix convention: An array
6223         *C* with shape (nrows, ncolumns) is plotted with the column number as
6224         *X* and the row number as *Y*.
6225 
6226         .. _differences-pcolor-pcolormesh:
6227 
6228         **Differences between pcolor() and pcolormesh()**
6229 
6230         Both methods are used to create a pseudocolor plot of a 2D array
6231         using quadrilaterals.
6232 
6233         The main difference lies in the created object and internal data
6234         handling:
6235         While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`
6236         returns a `.QuadMesh`. The latter is more specialized for the given
6237         purpose and thus is faster. It should almost always be preferred.
6238 
6239         There is also a slight difference in the handling of masked arrays.
6240         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6241         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6242         and *Y*. The reason lies in the internal handling of the masked values.
6243         `~.Axes.pcolor` leaves out the respective polygons from the
6244         PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked
6245         elements to transparent. You can see the difference when using
6246         edgecolors. While all edges are drawn irrespective of masking in a
6247         QuadMesh, the edge between two adjacent masked quadrilaterals in
6248         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6249         exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual
6250         polygon, it also supports applying hatches and linestyles to the collection.
6251 
6252         Another difference is the support of Gouraud shading in
6253         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6254 
6255         """
6256         if shading is None:
6257             shading = mpl.rcParams['pcolor.shading']
6258         shading = shading.lower()
6259         kwargs.setdefault('edgecolors', 'none')
6260 
6261         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6262                                             shading=shading, kwargs=kwargs)
6263         coords = np.stack([X, Y], axis=-1)
6264 
6265         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6266 
6267         collection = mcoll.QuadMesh(
6268             coords, antialiased=antialiased, shading=shading,
6269             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6270         collection._scale_norm(norm, vmin, vmax)
6271 
6272         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6273 
6274         # Transform from native to data coordinates?
6275         t = collection._transform
6276         if (not isinstance(t, mtransforms.Transform) and
6277                 hasattr(t, '_as_mpl_transform')):
6278             t = t._as_mpl_transform(self.axes)
6279 
6280         if t and any(t.contains_branch_seperately(self.transData)):
6281             trans_to_data = t - self.transData
6282             coords = trans_to_data.transform(coords)
6283 
6284         self.add_collection(collection, autolim=False)
6285 
6286         minx, miny = np.min(coords, axis=0)
6287         maxx, maxy = np.max(coords, axis=0)
6288         collection.sticky_edges.x[:] = [minx, maxx]
6289         collection.sticky_edges.y[:] = [miny, maxy]
6290         corners = (minx, miny), (maxx, maxy)
6291         self.update_datalim(corners)
6292         self._request_autoscale_view()
6293         return collection
6294 
6295     @_preprocess_data()
6296     @_docstring.dedent_interpd
6297     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6298                    vmax=None, **kwargs):
6299         """
6300         Create a pseudocolor plot with a non-regular rectangular grid.
6301 
6302         Call signature::
6303 
6304           ax.pcolorfast([X, Y], C, /, **kwargs)
6305 
6306         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6307         It's designed to provide the fastest pcolor-type plotting with the
6308         Agg backend. To achieve this, it uses different algorithms internally
6309         depending on the complexity of the input grid (regular rectangular,
6310         non-regular rectangular or arbitrary quadrilateral).
6311 
6312         .. warning::
6313 
6314            This method is experimental. Compared to `~.Axes.pcolor` or
6315            `~.Axes.pcolormesh` it has some limitations:
6316 
6317            - It supports only flat shading (no outlines)
6318            - It lacks support for log scaling of the axes.
6319            - It does not have a pyplot wrapper.
6320 
6321         Parameters
6322         ----------
6323         C : array-like
6324             The image data. Supported array shapes are:
6325 
6326             - (M, N): an image with scalar data.  Color-mapping is controlled
6327               by *cmap*, *norm*, *vmin*, and *vmax*.
6328             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6329             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6330               i.e. including transparency.
6331 
6332             The first two dimensions (M, N) define the rows and columns of
6333             the image.
6334 
6335             This parameter can only be passed positionally.
6336 
6337         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6338             *X* and *Y* are used to specify the coordinates of the
6339             quadrilaterals. There are different ways to do this:
6340 
6341             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6342               a *uniform rectangular grid*.
6343 
6344               The tuples define the outer edges of the grid. All individual
6345               quadrilaterals will be of the same size. This is the fastest
6346               version.
6347 
6348             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6349               grid*.
6350 
6351               In this case *X* and *Y* have to be monotonic 1D arrays of length
6352               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6353 
6354               The speed is intermediate. Note: The grid is checked, and if
6355               found to be uniform the fast version is used.
6356 
6357             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6358               grid* (i.e. if the quadrilaterals are not rectangular).
6359 
6360               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6361               specifying the x and y coordinates of the corners of the colored
6362               quadrilaterals.
6363 
6364               This is the most general, but the slowest to render.  It may
6365               produce faster and more compact output using ps, pdf, and
6366               svg backends, however.
6367 
6368             These arguments can only be passed positionally.
6369 
6370         %(cmap_doc)s
6371 
6372             This parameter is ignored if *C* is RGB(A).
6373 
6374         %(norm_doc)s
6375 
6376             This parameter is ignored if *C* is RGB(A).
6377 
6378         %(vmin_vmax_doc)s
6379 
6380             This parameter is ignored if *C* is RGB(A).
6381 
6382         alpha : float, default: None
6383             The alpha blending value, between 0 (transparent) and 1 (opaque).
6384 
6385         snap : bool, default: False
6386             Whether to snap the mesh to pixel boundaries.
6387 
6388         Returns
6389         -------
6390         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6391             The return type depends on the type of grid:
6392 
6393             - `.AxesImage` for a regular rectangular grid.
6394             - `.PcolorImage` for a non-regular rectangular grid.
6395             - `.QuadMesh` for a non-rectangular grid.
6396 
6397         Other Parameters
6398         ----------------
6399         data : indexable object, optional
6400             DATA_PARAMETER_PLACEHOLDER
6401 
6402         **kwargs
6403             Supported additional parameters depend on the type of grid.
6404             See return types of *image* for further description.
6405         """
6406 
6407         C = args[-1]
6408         nr, nc = np.shape(C)[:2]
6409         if len(args) == 1:
6410             style = "image"
6411             x = [0, nc]
6412             y = [0, nr]
6413         elif len(args) == 3:
6414             x, y = args[:2]
6415             x = np.asarray(x)
6416             y = np.asarray(y)
6417             if x.ndim == 1 and y.ndim == 1:
6418                 if x.size == 2 and y.size == 2:
6419                     style = "image"
6420                 else:
6421                     dx = np.diff(x)
6422                     dy = np.diff(y)
6423                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6424                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6425                         style = "image"
6426                     else:
6427                         style = "pcolorimage"
6428             elif x.ndim == 2 and y.ndim == 2:
6429                 style = "quadmesh"
6430             else:
6431                 raise TypeError("arguments do not match valid signatures")
6432         else:
6433             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6434 
6435         if style == "quadmesh":
6436             # data point in each cell is value at lower left corner
6437             coords = np.stack([x, y], axis=-1)
6438             if np.ndim(C) not in {2, 3}:
6439                 raise ValueError("C must be 2D or 3D")
6440             collection = mcoll.QuadMesh(
6441                 coords, array=C,
6442                 alpha=alpha, cmap=cmap, norm=norm,
6443                 antialiased=False, edgecolors="none")
6444             self.add_collection(collection, autolim=False)
6445             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6446             ret = collection
6447 
6448         else:  # It's one of the two image styles.
6449             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6450             if style == "image":
6451                 im = mimage.AxesImage(
6452                     self, cmap=cmap, norm=norm,
6453                     data=C, alpha=alpha, extent=extent,
6454                     interpolation='nearest', origin='lower',
6455                     **kwargs)
6456             elif style == "pcolorimage":
6457                 im = mimage.PcolorImage(
6458                     self, x, y, C,
6459                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6460                     **kwargs)
6461             self.add_image(im)
6462             ret = im
6463 
6464         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6465             ret._scale_norm(norm, vmin, vmax)
6466 
6467         if ret.get_clip_path() is None:
6468             # image does not already have clipping set, clip to axes patch
6469             ret.set_clip_path(self.patch)
6470 
6471         ret.sticky_edges.x[:] = [xl, xr]
6472         ret.sticky_edges.y[:] = [yb, yt]
6473         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6474         self._request_autoscale_view(tight=True)
6475         return ret
6476 
6477     @_preprocess_data()
6478     @_docstring.dedent_interpd
6479     def contour(self, *args, **kwargs):
6480         """
6481         Plot contour lines.
6482 
6483         Call signature::
6484 
6485             contour([X, Y,] Z, [levels], **kwargs)
6486         %(contour_doc)s
6487         """
6488         kwargs['filled'] = False
6489         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6490         self._request_autoscale_view()
6491         return contours
6492 
6493     @_preprocess_data()
6494     @_docstring.dedent_interpd
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours
6508 
6509     def clabel(self, CS, levels=None, **kwargs):
6510         """
6511         Label a contour plot.
6512 
6513         Adds labels to line contours in given `.ContourSet`.
6514 
6515         Parameters
6516         ----------
6517         CS : `.ContourSet` instance
6518             Line contours to label.
6519 
6520         levels : array-like, optional
6521             A list of level values, that should be labeled. The list must be
6522             a subset of ``CS.levels``. If not given, all levels are labeled.
6523 
6524         **kwargs
6525             All other parameters are documented in `~.ContourLabeler.clabel`.
6526         """
6527         return CS.clabel(levels, **kwargs)
6528 
6529     #### Data analysis
6530 
6531     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6532     def hist(self, x, bins=None, range=None, density=False, weights=None,
6533              cumulative=False, bottom=None, histtype='bar', align='mid',
6534              orientation='vertical', rwidth=None, log=False,
6535              color=None, label=None, stacked=False, **kwargs):
6536         """
6537         Compute and plot a histogram.
6538 
6539         This method uses `numpy.histogram` to bin the data in *x* and count the
6540         number of values in each bin, then draws the distribution either as a
6541         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6542         *weights* parameters are forwarded to `numpy.histogram`.
6543 
6544         If the data has already been binned and counted, use `~.bar` or
6545         `~.stairs` to plot the distribution::
6546 
6547             counts, bins = np.histogram(x)
6548             plt.stairs(counts, bins)
6549 
6550         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6551         treating each bin as a single point with a weight equal to its count::
6552 
6553             plt.hist(bins[:-1], bins, weights=counts)
6554 
6555         The data input *x* can be a singular array, a list of datasets of
6556         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6557         which each column is a dataset. Note that the ndarray form is
6558         transposed relative to the list form. If the input is an array, then
6559         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6560         sequence of arrays, then the return value is a tuple
6561         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6562 
6563         Masked arrays are not supported.
6564 
6565         Parameters
6566         ----------
6567         x : (n,) array or sequence of (n,) arrays
6568             Input values, this takes either a single array or a sequence of
6569             arrays which are not required to be of the same length.
6570 
6571         bins : int or sequence or str, default: :rc:`hist.bins`
6572             If *bins* is an integer, it defines the number of equal-width bins
6573             in the range.
6574 
6575             If *bins* is a sequence, it defines the bin edges, including the
6576             left edge of the first bin and the right edge of the last bin;
6577             in this case, bins may be unequally spaced.  All but the last
6578             (righthand-most) bin is half-open.  In other words, if *bins* is::
6579 
6580                 [1, 2, 3, 4]
6581 
6582             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6583             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6584             *includes* 4.
6585 
6586             If *bins* is a string, it is one of the binning strategies
6587             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6588             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6589 
6590         range : tuple or None, default: None
6591             The lower and upper range of the bins. Lower and upper outliers
6592             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6593             Range has no effect if *bins* is a sequence.
6594 
6595             If *bins* is a sequence or *range* is specified, autoscaling
6596             is based on the specified bin range instead of the
6597             range of x.
6598 
6599         density : bool, default: False
6600             If ``True``, draw and return a probability density: each bin
6601             will display the bin's raw count divided by the total number of
6602             counts *and the bin width*
6603             (``density = counts / (sum(counts) * np.diff(bins))``),
6604             so that the area under the histogram integrates to 1
6605             (``np.sum(density * np.diff(bins)) == 1``).
6606 
6607             If *stacked* is also ``True``, the sum of the histograms is
6608             normalized to 1.
6609 
6610         weights : (n,) array-like or None, default: None
6611             An array of weights, of the same shape as *x*.  Each value in
6612             *x* only contributes its associated weight towards the bin count
6613             (instead of 1).  If *density* is ``True``, the weights are
6614             normalized, so that the integral of the density over the range
6615             remains 1.
6616 
6617         cumulative : bool or -1, default: False
6618             If ``True``, then a histogram is computed where each bin gives the
6619             counts in that bin plus all bins for smaller values. The last bin
6620             gives the total number of datapoints.
6621 
6622             If *density* is also ``True`` then the histogram is normalized such
6623             that the last bin equals 1.
6624 
6625             If *cumulative* is a number less than 0 (e.g., -1), the direction
6626             of accumulation is reversed.  In this case, if *density* is also
6627             ``True``, then the histogram is normalized such that the first bin
6628             equals 1.
6629 
6630         bottom : array-like, scalar, or None, default: None
6631             Location of the bottom of each bin, i.e. bins are drawn from
6632             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6633             of each bin is shifted by the same amount. If an array, each bin
6634             is shifted independently and the length of bottom must match the
6635             number of bins. If None, defaults to 0.
6636 
6637         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6638             The type of histogram to draw.
6639 
6640             - 'bar' is a traditional bar-type histogram.  If multiple data
6641               are given the bars are arranged side by side.
6642             - 'barstacked' is a bar-type histogram where multiple
6643               data are stacked on top of each other.
6644             - 'step' generates a lineplot that is by default unfilled.
6645             - 'stepfilled' generates a lineplot that is by default filled.
6646 
6647         align : {'left', 'mid', 'right'}, default: 'mid'
6648             The horizontal alignment of the histogram bars.
6649 
6650             - 'left': bars are centered on the left bin edges.
6651             - 'mid': bars are centered between the bin edges.
6652             - 'right': bars are centered on the right bin edges.
6653 
6654         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6655             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6656             and the *bottom* kwarg will be the left edges.
6657 
6658         rwidth : float or None, default: None
6659             The relative width of the bars as a fraction of the bin width.  If
6660             ``None``, automatically compute the width.
6661 
6662             Ignored if *histtype* is 'step' or 'stepfilled'.
6663 
6664         log : bool, default: False
6665             If ``True``, the histogram axis will be set to a log scale.
6666 
6667         color : color or array-like of colors or None, default: None
6668             Color or sequence of colors, one per dataset.  Default (``None``)
6669             uses the standard line color sequence.
6670 
6671         label : str or None, default: None
6672             String, or sequence of strings to match multiple datasets.  Bar
6673             charts yield multiple patches per dataset, but only the first gets
6674             the label, so that `~.Axes.legend` will work as expected.
6675 
6676         stacked : bool, default: False
6677             If ``True``, multiple data are stacked on top of each other If
6678             ``False`` multiple data are arranged side by side if histtype is
6679             'bar' or on top of each other if histtype is 'step'
6680 
6681         Returns
6682         -------
6683         n : array or list of arrays
6684             The values of the histogram bins. See *density* and *weights* for a
6685             description of the possible semantics.  If input *x* is an array,
6686             then this is an array of length *nbins*. If input is a sequence of
6687             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6688             the values of the histograms for each of the arrays in the same
6689             order.  The dtype of the array *n* (or of its element arrays) will
6690             always be float even if no weighting or normalization is used.
6691 
6692         bins : array
6693             The edges of the bins. Length nbins + 1 (nbins left edges and right
6694             edge of last bin).  Always a single array even when multiple data
6695             sets are passed in.
6696 
6697         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6698 such objects
6699             Container of individual artists used to create the histogram
6700             or list of such containers if there are multiple input datasets.
6701 
6702         Other Parameters
6703         ----------------
6704         data : indexable object, optional
6705             DATA_PARAMETER_PLACEHOLDER
6706 
6707         **kwargs
6708             `~matplotlib.patches.Patch` properties
6709 
6710         See Also
6711         --------
6712         hist2d : 2D histogram with rectangular bins
6713         hexbin : 2D histogram with hexagonal bins
6714         stairs : Plot a pre-computed histogram
6715         bar : Plot a pre-computed histogram
6716 
6717         Notes
6718         -----
6719         For large numbers of bins (>1000), plotting can be significantly
6720         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6721         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6722         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6723         """
6724         # Avoid shadowing the builtin.
6725         bin_range = range
6726         from builtins import range
6727 
6728         if np.isscalar(x):
6729             x = [x]
6730 
6731         if bins is None:
6732             bins = mpl.rcParams['hist.bins']
6733 
6734         # Validate string inputs here to avoid cluttering subsequent code.
6735         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6736                            histtype=histtype)
6737         _api.check_in_list(['left', 'mid', 'right'], align=align)
6738         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6739 
6740         if histtype == 'barstacked' and not stacked:
6741             stacked = True
6742 
6743         # Massage 'x' for processing.
6744         x = cbook._reshape_2D(x, 'x')
6745         nx = len(x)  # number of datasets
6746 
6747         # Process unit information.  _process_unit_info sets the unit and
6748         # converts the first dataset; then we convert each following dataset
6749         # one at a time.
6750         if orientation == "vertical":
6751             convert_units = self.convert_xunits
6752             x = [*self._process_unit_info([("x", x[0])], kwargs),
6753                  *map(convert_units, x[1:])]
6754         else:  # horizontal
6755             convert_units = self.convert_yunits
6756             x = [*self._process_unit_info([("y", x[0])], kwargs),
6757                  *map(convert_units, x[1:])]
6758 
6759         if bin_range is not None:
6760             bin_range = convert_units(bin_range)
6761 
6762         if not cbook.is_scalar_or_string(bins):
6763             bins = convert_units(bins)
6764 
6765         # We need to do to 'weights' what was done to 'x'
6766         if weights is not None:
6767             w = cbook._reshape_2D(weights, 'weights')
6768         else:
6769             w = [None] * nx
6770 
6771         if len(w) != nx:
6772             raise ValueError('weights should have the same shape as x')
6773 
6774         input_empty = True
6775         for xi, wi in zip(x, w):
6776             len_xi = len(xi)
6777             if wi is not None and len(wi) != len_xi:
6778                 raise ValueError('weights should have the same shape as x')
6779             if len_xi:
6780                 input_empty = False
6781 
6782         if color is None:
6783             colors = [self._get_lines.get_next_color() for i in range(nx)]
6784         else:
6785             colors = mcolors.to_rgba_array(color)
6786             if len(colors) != nx:
6787                 raise ValueError(f"The 'color' keyword argument must have one "
6788                                  f"color per dataset, but {nx} datasets and "
6789                                  f"{len(colors)} colors were provided")
6790 
6791         hist_kwargs = dict()
6792 
6793         # if the bin_range is not given, compute without nan numpy
6794         # does not do this for us when guessing the range (but will
6795         # happily ignore nans when computing the histogram).
6796         if bin_range is None:
6797             xmin = np.inf
6798             xmax = -np.inf
6799             for xi in x:
6800                 if len(xi):
6801                     # python's min/max ignore nan,
6802                     # np.minnan returns nan for all nan input
6803                     xmin = min(xmin, np.nanmin(xi))
6804                     xmax = max(xmax, np.nanmax(xi))
6805             if xmin <= xmax:  # Only happens if we have seen a finite value.
6806                 bin_range = (xmin, xmax)
6807 
6808         # If bins are not specified either explicitly or via range,
6809         # we need to figure out the range required for all datasets,
6810         # and supply that to np.histogram.
6811         if not input_empty and len(x) > 1:
6812             if weights is not None:
6813                 _w = np.concatenate(w)
6814             else:
6815                 _w = None
6816             bins = np.histogram_bin_edges(
6817                 np.concatenate(x), bins, bin_range, _w)
6818         else:
6819             hist_kwargs['range'] = bin_range
6820 
6821         density = bool(density)
6822         if density and not stacked:
6823             hist_kwargs['density'] = density
6824 
6825         # List to store all the top coordinates of the histograms
6826         tops = []  # Will have shape (n_datasets, n_bins).
6827         # Loop through datasets
6828         for i in range(nx):
6829             # this will automatically overwrite bins,
6830             # so that each histogram uses the same bins
6831             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6832             tops.append(m)
6833         tops = np.array(tops, float)  # causes problems later if it's an int
6834         bins = np.array(bins, float)  # causes problems if float16
6835         if stacked:
6836             tops = tops.cumsum(axis=0)
6837             # If a stacked density plot, normalize so the area of all the
6838             # stacked histograms together is 1
6839             if density:
6840                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6841         if cumulative:
6842             slc = slice(None)
6843             if isinstance(cumulative, Number) and cumulative < 0:
6844                 slc = slice(None, None, -1)
6845             if density:
6846                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6847             else:
6848                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6849 
6850         patches = []
6851 
6852         if histtype.startswith('bar'):
6853 
6854             totwidth = np.diff(bins)
6855 
6856             if rwidth is not None:
6857                 dr = np.clip(rwidth, 0, 1)
6858             elif (len(tops) > 1 and
6859                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6860                 dr = 0.8
6861             else:
6862                 dr = 1.0
6863 
6864             if histtype == 'bar' and not stacked:
6865                 width = dr * totwidth / nx
6866                 dw = width
6867                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6868             elif histtype == 'barstacked' or stacked:
6869                 width = dr * totwidth
6870                 boffset, dw = 0.0, 0.0
6871 
6872             if align == 'mid':
6873                 boffset += 0.5 * totwidth
6874             elif align == 'right':
6875                 boffset += totwidth
6876 
6877             if orientation == 'horizontal':
6878                 _barfunc = self.barh
6879                 bottom_kwarg = 'left'
6880             else:  # orientation == 'vertical'
6881                 _barfunc = self.bar
6882                 bottom_kwarg = 'bottom'
6883 
6884             for top, color in zip(tops, colors):
6885                 if bottom is None:
6886                     bottom = np.zeros(len(top))
6887                 if stacked:
6888                     height = top - bottom
6889                 else:
6890                     height = top
6891                 bars = _barfunc(bins[:-1]+boffset, height, width,
6892                                 align='center', log=log,
6893                                 color=color, **{bottom_kwarg: bottom})
6894                 patches.append(bars)
6895                 if stacked:
6896                     bottom = top
6897                 boffset += dw
6898             # Remove stickies from all bars but the lowest ones, as otherwise
6899             # margin expansion would be unable to cross the stickies in the
6900             # middle of the bars.
6901             for bars in patches[1:]:
6902                 for patch in bars:
6903                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6904 
6905         elif histtype.startswith('step'):
6906             # these define the perimeter of the polygon
6907             x = np.zeros(4 * len(bins) - 3)
6908             y = np.zeros(4 * len(bins) - 3)
6909 
6910             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6911             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6912 
6913             if bottom is None:
6914                 bottom = 0
6915 
6916             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6917             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6918 
6919             if log:
6920                 if orientation == 'horizontal':
6921                     self.set_xscale('log', nonpositive='clip')
6922                 else:  # orientation == 'vertical'
6923                     self.set_yscale('log', nonpositive='clip')
6924 
6925             if align == 'left':
6926                 x -= 0.5*(bins[1]-bins[0])
6927             elif align == 'right':
6928                 x += 0.5*(bins[1]-bins[0])
6929 
6930             # If fill kwarg is set, it will be passed to the patch collection,
6931             # overriding this
6932             fill = (histtype == 'stepfilled')
6933 
6934             xvals, yvals = [], []
6935             for top in tops:
6936                 if stacked:
6937                     # top of the previous polygon becomes the bottom
6938                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6939                 # set the top of this polygon
6940                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6941 
6942                 # The starting point of the polygon has not yet been
6943                 # updated. So far only the endpoint was adjusted. This
6944                 # assignment closes the polygon. The redundant endpoint is
6945                 # later discarded (for step and stepfilled).
6946                 y[0] = y[-1]
6947 
6948                 if orientation == 'horizontal':
6949                     xvals.append(y.copy())
6950                     yvals.append(x.copy())
6951                 else:
6952                     xvals.append(x.copy())
6953                     yvals.append(y.copy())
6954 
6955             # stepfill is closed, step is not
6956             split = -1 if fill else 2 * len(bins)
6957             # add patches in reverse order so that when stacking,
6958             # items lower in the stack are plotted on top of
6959             # items higher in the stack
6960             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6961                 patches.append(self.fill(
6962                     x[:split], y[:split],
6963                     closed=True if fill else None,
6964                     facecolor=color,
6965                     edgecolor=None if fill else color,
6966                     fill=fill if fill else None,
6967                     zorder=None if fill else mlines.Line2D.zorder))
6968             for patch_list in patches:
6969                 for patch in patch_list:
6970                     if orientation == 'vertical':
6971                         patch.sticky_edges.y.append(0)
6972                     elif orientation == 'horizontal':
6973                         patch.sticky_edges.x.append(0)
6974 
6975             # we return patches, so put it back in the expected order
6976             patches.reverse()
6977 
6978         # If None, make all labels None (via zip_longest below); otherwise,
6979         # cast each element to str, but keep a single str as it.
6980         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6981         for patch, lbl in itertools.zip_longest(patches, labels):
6982             if patch:
6983                 p = patch[0]
6984                 p._internal_update(kwargs)
6985                 if lbl is not None:
6986                     p.set_label(lbl)
6987                 for p in patch[1:]:
6988                     p._internal_update(kwargs)
6989                     p.set_label('_nolegend_')
6990 
6991         if nx == 1:
6992             return tops[0], bins, patches[0]
6993         else:
6994             patch_type = ("BarContainer" if histtype.startswith("bar")
6995                           else "list[Polygon]")
6996             return tops, bins, cbook.silent_list(patch_type, patches)
6997 
6998     @_preprocess_data()
6999     def stairs(self, values, edges=None, *,
7000                orientation='vertical', baseline=0, fill=False, **kwargs):
7001         """
7002         A stepwise constant function as a line with bounding edges
7003         or a filled plot.
7004 
7005         Parameters
7006         ----------
7007         values : array-like
7008             The step heights.
7009 
7010         edges : array-like
7011             The edge positions, with ``len(edges) == len(vals) + 1``,
7012             between which the curve takes on vals values.
7013 
7014         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7015             The direction of the steps. Vertical means that *values* are along
7016             the y-axis, and edges are along the x-axis.
7017 
7018         baseline : float, array-like or None, default: 0
7019             The bottom value of the bounding edges or when
7020             ``fill=True``, position of lower edge. If *fill* is
7021             True or an array is passed to *baseline*, a closed
7022             path is drawn.
7023 
7024         fill : bool, default: False
7025             Whether the area under the step curve should be filled.
7026 
7027         Returns
7028         -------
7029         StepPatch : `~matplotlib.patches.StepPatch`
7030 
7031         Other Parameters
7032         ----------------
7033         data : indexable object, optional
7034             DATA_PARAMETER_PLACEHOLDER
7035 
7036         **kwargs
7037             `~matplotlib.patches.StepPatch` properties
7038 
7039         """
7040 
7041         if 'color' in kwargs:
7042             _color = kwargs.pop('color')
7043         else:
7044             _color = self._get_lines.get_next_color()
7045         if fill:
7046             kwargs.setdefault('linewidth', 0)
7047             kwargs.setdefault('facecolor', _color)
7048         else:
7049             kwargs.setdefault('edgecolor', _color)
7050 
7051         if edges is None:
7052             edges = np.arange(len(values) + 1)
7053 
7054         edges, values, baseline = self._process_unit_info(
7055             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7056 
7057         patch = mpatches.StepPatch(values,
7058                                    edges,
7059                                    baseline=baseline,
7060                                    orientation=orientation,
7061                                    fill=fill,
7062                                    **kwargs)
7063         self.add_patch(patch)
7064         if baseline is None:
7065             baseline = 0
7066         if orientation == 'vertical':
7067             patch.sticky_edges.y.append(np.min(baseline))
7068             self.update_datalim([(edges[0], np.min(baseline))])
7069         else:
7070             patch.sticky_edges.x.append(np.min(baseline))
7071             self.update_datalim([(np.min(baseline), edges[0])])
7072         self._request_autoscale_view()
7073         return patch
7074 
7075     @_preprocess_data(replace_names=["x", "y", "weights"])
7076     @_docstring.dedent_interpd
7077     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7078                cmin=None, cmax=None, **kwargs):
7079         """
7080         Make a 2D histogram plot.
7081 
7082         Parameters
7083         ----------
7084         x, y : array-like, shape (n, )
7085             Input values
7086 
7087         bins : None or int or [int, int] or array-like or [array, array]
7088 
7089             The bin specification:
7090 
7091             - If int, the number of bins for the two dimensions
7092               (nx=ny=bins).
7093             - If ``[int, int]``, the number of bins in each dimension
7094               (nx, ny = bins).
7095             - If array-like, the bin edges for the two dimensions
7096               (x_edges=y_edges=bins).
7097             - If ``[array, array]``, the bin edges in each dimension
7098               (x_edges, y_edges = bins).
7099 
7100             The default value is 10.
7101 
7102         range : array-like shape(2, 2), optional
7103             The leftmost and rightmost edges of the bins along each dimension
7104             (if not specified explicitly in the bins parameters): ``[[xmin,
7105             xmax], [ymin, ymax]]``. All values outside of this range will be
7106             considered outliers and not tallied in the histogram.
7107 
7108         density : bool, default: False
7109             Normalize histogram.  See the documentation for the *density*
7110             parameter of `~.Axes.hist` for more details.
7111 
7112         weights : array-like, shape (n, ), optional
7113             An array of values w_i weighing each sample (x_i, y_i).
7114 
7115         cmin, cmax : float, default: None
7116             All bins that has count less than *cmin* or more than *cmax* will
7117             not be displayed (set to NaN before passing to imshow) and these
7118             count values in the return value count histogram will also be set
7119             to nan upon return.
7120 
7121         Returns
7122         -------
7123         h : 2D array
7124             The bi-dimensional histogram of samples x and y. Values in x are
7125             histogrammed along the first dimension and values in y are
7126             histogrammed along the second dimension.
7127         xedges : 1D array
7128             The bin edges along the x-axis.
7129         yedges : 1D array
7130             The bin edges along the y-axis.
7131         image : `~.matplotlib.collections.QuadMesh`
7132 
7133         Other Parameters
7134         ----------------
7135         %(cmap_doc)s
7136 
7137         %(norm_doc)s
7138 
7139         %(vmin_vmax_doc)s
7140 
7141         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7142             The alpha blending value.
7143 
7144         data : indexable object, optional
7145             DATA_PARAMETER_PLACEHOLDER
7146 
7147         **kwargs
7148             Additional parameters are passed along to the
7149             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7150             constructor.
7151 
7152         See Also
7153         --------
7154         hist : 1D histogram plotting
7155         hexbin : 2D histogram with hexagonal bins
7156 
7157         Notes
7158         -----
7159         - Currently ``hist2d`` calculates its own axis limits, and any limits
7160           previously set are ignored.
7161         - Rendering the histogram with a logarithmic color scale is
7162           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7163           keyword argument. Likewise, power-law normalization (similar
7164           in effect to gamma correction) can be accomplished with
7165           `.colors.PowerNorm`.
7166         """
7167 
7168         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7169                                            density=density, weights=weights)
7170 
7171         if cmin is not None:
7172             h[h < cmin] = None
7173         if cmax is not None:
7174             h[h > cmax] = None
7175 
7176         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7177         self.set_xlim(xedges[0], xedges[-1])
7178         self.set_ylim(yedges[0], yedges[-1])
7179 
7180         return h, xedges, yedges, pc
7181 
7182     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7183     @_docstring.dedent_interpd
7184     def ecdf(self, x, weights=None, *, complementary=False,
7185              orientation="vertical", compress=False, **kwargs):
7186         """
7187         Compute and plot the empirical cumulative distribution function of *x*.
7188 
7189         .. versionadded:: 3.8
7190 
7191         Parameters
7192         ----------
7193         x : 1d array-like
7194             The input data.  Infinite entries are kept (and move the relevant
7195             end of the ecdf from 0/1), but NaNs and masked values are errors.
7196 
7197         weights : 1d array-like or None, default: None
7198             The weights of the entries; must have the same shape as *x*.
7199             Weights corresponding to NaN data points are dropped, and then the
7200             remaining weights are normalized to sum to 1.  If unset, all
7201             entries have the same weight.
7202 
7203         complementary : bool, default: False
7204             Whether to plot a cumulative distribution function, which increases
7205             from 0 to 1 (the default), or a complementary cumulative
7206             distribution function, which decreases from 1 to 0.
7207 
7208         orientation : {"vertical", "horizontal"}, default: "vertical"
7209             Whether the entries are plotted along the x-axis ("vertical", the
7210             default) or the y-axis ("horizontal").  This parameter takes the
7211             same values as in `~.Axes.hist`.
7212 
7213         compress : bool, default: False
7214             Whether multiple entries with the same values are grouped together
7215             (with a summed weight) before plotting.  This is mainly useful if
7216             *x* contains many identical data points, to decrease the rendering
7217             complexity of the plot. If *x* contains no duplicate points, this
7218             has no effect and just uses some time and memory.
7219 
7220         Other Parameters
7221         ----------------
7222         data : indexable object, optional
7223             DATA_PARAMETER_PLACEHOLDER
7224 
7225         **kwargs
7226             Keyword arguments control the `.Line2D` properties:
7227 
7228             %(Line2D:kwdoc)s
7229 
7230         Returns
7231         -------
7232         `.Line2D`
7233 
7234         Notes
7235         -----
7236         The ecdf plot can be thought of as a cumulative histogram with one bin
7237         per data entry; i.e. it reports on the entire dataset without any
7238         arbitrary binning.
7239 
7240         If *x* contains NaNs or masked entries, either remove them first from
7241         the array (if they should not taken into account), or replace them by
7242         -inf or +inf (if they should be sorted at the beginning or the end of
7243         the array).
7244         """
7245         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7246         if "drawstyle" in kwargs or "ds" in kwargs:
7247             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7248         if np.ma.getmask(x).any():
7249             raise ValueError("ecdf() does not support masked entries")
7250         x = np.asarray(x)
7251         if np.isnan(x).any():
7252             raise ValueError("ecdf() does not support NaNs")
7253         argsort = np.argsort(x)
7254         x = x[argsort]
7255         if weights is None:
7256             # Ensure that we end at exactly 1, avoiding floating point errors.
7257             cum_weights = (1 + np.arange(len(x))) / len(x)
7258         else:
7259             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7260             cum_weights = np.cumsum(weights / np.sum(weights))
7261         if compress:
7262             # Get indices of unique x values.
7263             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7264             x = x[compress_idxs]
7265             cum_weights = cum_weights[compress_idxs]
7266         if orientation == "vertical":
7267             if not complementary:
7268                 line, = self.plot([x[0], *x], [0, *cum_weights],
7269                                   drawstyle="steps-post", **kwargs)
7270             else:
7271                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7272                                   drawstyle="steps-pre", **kwargs)
7273             line.sticky_edges.y[:] = [0, 1]
7274         else:  # orientation == "horizontal":
7275             if not complementary:
7276                 line, = self.plot([0, *cum_weights], [x[0], *x],
7277                                   drawstyle="steps-pre", **kwargs)
7278             else:
7279                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7280                                   drawstyle="steps-post", **kwargs)
7281             line.sticky_edges.x[:] = [0, 1]
7282         return line
7283 
7284     @_preprocess_data(replace_names=["x"])
7285     @_docstring.dedent_interpd
7286     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7287             window=None, noverlap=None, pad_to=None,
7288             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7289         r"""
7290         Plot the power spectral density.
7291 
7292         The power spectral density :math:`P_{xx}` by Welch's average
7293         periodogram method.  The vector *x* is divided into *NFFT* length
7294         segments.  Each segment is detrended by function *detrend* and
7295         windowed by function *window*.  *noverlap* gives the length of
7296         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7297         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7298         with a scaling to correct for power loss due to windowing.
7299 
7300         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7301 
7302         Parameters
7303         ----------
7304         x : 1-D array or sequence
7305             Array or sequence containing the data
7306 
7307         %(Spectral)s
7308 
7309         %(PSD)s
7310 
7311         noverlap : int, default: 0 (no overlap)
7312             The number of points of overlap between segments.
7313 
7314         Fc : int, default: 0
7315             The center frequency of *x*, which offsets the x extents of the
7316             plot to reflect the frequency range used when a signal is acquired
7317             and then filtered and downsampled to baseband.
7318 
7319         return_line : bool, default: False
7320             Whether to include the line object plotted in the returned values.
7321 
7322         Returns
7323         -------
7324         Pxx : 1-D array
7325             The values for the power spectrum :math:`P_{xx}` before scaling
7326             (real valued).
7327 
7328         freqs : 1-D array
7329             The frequencies corresponding to the elements in *Pxx*.
7330 
7331         line : `~matplotlib.lines.Line2D`
7332             The line created by this function.
7333             Only returned if *return_line* is True.
7334 
7335         Other Parameters
7336         ----------------
7337         data : indexable object, optional
7338             DATA_PARAMETER_PLACEHOLDER
7339 
7340         **kwargs
7341             Keyword arguments control the `.Line2D` properties:
7342 
7343             %(Line2D:kwdoc)s
7344 
7345         See Also
7346         --------
7347         specgram
7348             Differs in the default overlap; in not returning the mean of the
7349             segment periodograms; in returning the times of the segments; and
7350             in plotting a colormap instead of a line.
7351         magnitude_spectrum
7352             Plots the magnitude spectrum.
7353         csd
7354             Plots the spectral density between two signals.
7355 
7356         Notes
7357         -----
7358         For plotting, the power is plotted as
7359         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7360         is returned.
7361 
7362         References
7363         ----------
7364         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7365         John Wiley & Sons (1986)
7366         """
7367         if Fc is None:
7368             Fc = 0
7369 
7370         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7371                               window=window, noverlap=noverlap, pad_to=pad_to,
7372                               sides=sides, scale_by_freq=scale_by_freq)
7373         freqs += Fc
7374 
7375         if scale_by_freq in (None, True):
7376             psd_units = 'dB/Hz'
7377         else:
7378             psd_units = 'dB'
7379 
7380         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7381         self.set_xlabel('Frequency')
7382         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7383         self.grid(True)
7384 
7385         vmin, vmax = self.get_ybound()
7386         step = max(10 * int(np.log10(vmax - vmin)), 1)
7387         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7388         self.set_yticks(ticks)
7389 
7390         if return_line is None or not return_line:
7391             return pxx, freqs
7392         else:
7393             return pxx, freqs, line
7394 
7395     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7396     @_docstring.dedent_interpd
7397     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7398             window=None, noverlap=None, pad_to=None,
7399             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7400         r"""
7401         Plot the cross-spectral density.
7402 
7403         The cross spectral density :math:`P_{xy}` by Welch's average
7404         periodogram method.  The vectors *x* and *y* are divided into
7405         *NFFT* length segments.  Each segment is detrended by function
7406         *detrend* and windowed by function *window*.  *noverlap* gives
7407         the length of the overlap between segments.  The product of
7408         the direct FFTs of *x* and *y* are averaged over each segment
7409         to compute :math:`P_{xy}`, with a scaling to correct for power
7410         loss due to windowing.
7411 
7412         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7413         padded to *NFFT*.
7414 
7415         Parameters
7416         ----------
7417         x, y : 1-D arrays or sequences
7418             Arrays or sequences containing the data.
7419 
7420         %(Spectral)s
7421 
7422         %(PSD)s
7423 
7424         noverlap : int, default: 0 (no overlap)
7425             The number of points of overlap between segments.
7426 
7427         Fc : int, default: 0
7428             The center frequency of *x*, which offsets the x extents of the
7429             plot to reflect the frequency range used when a signal is acquired
7430             and then filtered and downsampled to baseband.
7431 
7432         return_line : bool, default: False
7433             Whether to include the line object plotted in the returned values.
7434 
7435         Returns
7436         -------
7437         Pxy : 1-D array
7438             The values for the cross spectrum :math:`P_{xy}` before scaling
7439             (complex valued).
7440 
7441         freqs : 1-D array
7442             The frequencies corresponding to the elements in *Pxy*.
7443 
7444         line : `~matplotlib.lines.Line2D`
7445             The line created by this function.
7446             Only returned if *return_line* is True.
7447 
7448         Other Parameters
7449         ----------------
7450         data : indexable object, optional
7451             DATA_PARAMETER_PLACEHOLDER
7452 
7453         **kwargs
7454             Keyword arguments control the `.Line2D` properties:
7455 
7456             %(Line2D:kwdoc)s
7457 
7458         See Also
7459         --------
7460         psd : is equivalent to setting ``y = x``.
7461 
7462         Notes
7463         -----
7464         For plotting, the power is plotted as
7465         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7466         is returned.
7467 
7468         References
7469         ----------
7470         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7471         John Wiley & Sons (1986)
7472         """
7473         if Fc is None:
7474             Fc = 0
7475 
7476         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7477                               window=window, noverlap=noverlap, pad_to=pad_to,
7478                               sides=sides, scale_by_freq=scale_by_freq)
7479         # pxy is complex
7480         freqs += Fc
7481 
7482         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7483         self.set_xlabel('Frequency')
7484         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7485         self.grid(True)
7486 
7487         vmin, vmax = self.get_ybound()
7488         step = max(10 * int(np.log10(vmax - vmin)), 1)
7489         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7490         self.set_yticks(ticks)
7491 
7492         if return_line is None or not return_line:
7493             return pxy, freqs
7494         else:
7495             return pxy, freqs, line
7496 
7497     @_preprocess_data(replace_names=["x"])
7498     @_docstring.dedent_interpd
7499     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7500                            pad_to=None, sides=None, scale=None,
7501                            **kwargs):
7502         """
7503         Plot the magnitude spectrum.
7504 
7505         Compute the magnitude spectrum of *x*.  Data is padded to a
7506         length of *pad_to* and the windowing function *window* is applied to
7507         the signal.
7508 
7509         Parameters
7510         ----------
7511         x : 1-D array or sequence
7512             Array or sequence containing the data.
7513 
7514         %(Spectral)s
7515 
7516         %(Single_Spectrum)s
7517 
7518         scale : {'default', 'linear', 'dB'}
7519             The scaling of the values in the *spec*.  'linear' is no scaling.
7520             'dB' returns the values in dB scale, i.e., the dB amplitude
7521             (20 * log10). 'default' is 'linear'.
7522 
7523         Fc : int, default: 0
7524             The center frequency of *x*, which offsets the x extents of the
7525             plot to reflect the frequency range used when a signal is acquired
7526             and then filtered and downsampled to baseband.
7527 
7528         Returns
7529         -------
7530         spectrum : 1-D array
7531             The values for the magnitude spectrum before scaling (real valued).
7532 
7533         freqs : 1-D array
7534             The frequencies corresponding to the elements in *spectrum*.
7535 
7536         line : `~matplotlib.lines.Line2D`
7537             The line created by this function.
7538 
7539         Other Parameters
7540         ----------------
7541         data : indexable object, optional
7542             DATA_PARAMETER_PLACEHOLDER
7543 
7544         **kwargs
7545             Keyword arguments control the `.Line2D` properties:
7546 
7547             %(Line2D:kwdoc)s
7548 
7549         See Also
7550         --------
7551         psd
7552             Plots the power spectral density.
7553         angle_spectrum
7554             Plots the angles of the corresponding frequencies.
7555         phase_spectrum
7556             Plots the phase (unwrapped angle) of the corresponding frequencies.
7557         specgram
7558             Can plot the magnitude spectrum of segments within the signal in a
7559             colormap.
7560         """
7561         if Fc is None:
7562             Fc = 0
7563 
7564         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7565                                               pad_to=pad_to, sides=sides)
7566         freqs += Fc
7567 
7568         yunits = _api.check_getitem(
7569             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7570              'dB': 'dB'},
7571             scale=scale)
7572         if yunits == 'energy':
7573             Z = spec
7574         else:  # yunits == 'dB'
7575             Z = 20. * np.log10(spec)
7576 
7577         line, = self.plot(freqs, Z, **kwargs)
7578         self.set_xlabel('Frequency')
7579         self.set_ylabel('Magnitude (%s)' % yunits)
7580 
7581         return spec, freqs, line
7582 
7583     @_preprocess_data(replace_names=["x"])
7584     @_docstring.dedent_interpd
7585     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7586                        pad_to=None, sides=None, **kwargs):
7587         """
7588         Plot the angle spectrum.
7589 
7590         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7591         Data is padded to a length of *pad_to* and the windowing function
7592         *window* is applied to the signal.
7593 
7594         Parameters
7595         ----------
7596         x : 1-D array or sequence
7597             Array or sequence containing the data.
7598 
7599         %(Spectral)s
7600 
7601         %(Single_Spectrum)s
7602 
7603         Fc : int, default: 0
7604             The center frequency of *x*, which offsets the x extents of the
7605             plot to reflect the frequency range used when a signal is acquired
7606             and then filtered and downsampled to baseband.
7607 
7608         Returns
7609         -------
7610         spectrum : 1-D array
7611             The values for the angle spectrum in radians (real valued).
7612 
7613         freqs : 1-D array
7614             The frequencies corresponding to the elements in *spectrum*.
7615 
7616         line : `~matplotlib.lines.Line2D`
7617             The line created by this function.
7618 
7619         Other Parameters
7620         ----------------
7621         data : indexable object, optional
7622             DATA_PARAMETER_PLACEHOLDER
7623 
7624         **kwargs
7625             Keyword arguments control the `.Line2D` properties:
7626 
7627             %(Line2D:kwdoc)s
7628 
7629         See Also
7630         --------
7631         magnitude_spectrum
7632             Plots the magnitudes of the corresponding frequencies.
7633         phase_spectrum
7634             Plots the unwrapped version of this function.
7635         specgram
7636             Can plot the angle spectrum of segments within the signal in a
7637             colormap.
7638         """
7639         if Fc is None:
7640             Fc = 0
7641 
7642         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7643                                           pad_to=pad_to, sides=sides)
7644         freqs += Fc
7645 
7646         lines = self.plot(freqs, spec, **kwargs)
7647         self.set_xlabel('Frequency')
7648         self.set_ylabel('Angle (radians)')
7649 
7650         return spec, freqs, lines[0]
7651 
7652     @_preprocess_data(replace_names=["x"])
7653     @_docstring.dedent_interpd
7654     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7655                        pad_to=None, sides=None, **kwargs):
7656         """
7657         Plot the phase spectrum.
7658 
7659         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7660         Data is padded to a length of *pad_to* and the windowing function
7661         *window* is applied to the signal.
7662 
7663         Parameters
7664         ----------
7665         x : 1-D array or sequence
7666             Array or sequence containing the data
7667 
7668         %(Spectral)s
7669 
7670         %(Single_Spectrum)s
7671 
7672         Fc : int, default: 0
7673             The center frequency of *x*, which offsets the x extents of the
7674             plot to reflect the frequency range used when a signal is acquired
7675             and then filtered and downsampled to baseband.
7676 
7677         Returns
7678         -------
7679         spectrum : 1-D array
7680             The values for the phase spectrum in radians (real valued).
7681 
7682         freqs : 1-D array
7683             The frequencies corresponding to the elements in *spectrum*.
7684 
7685         line : `~matplotlib.lines.Line2D`
7686             The line created by this function.
7687 
7688         Other Parameters
7689         ----------------
7690         data : indexable object, optional
7691             DATA_PARAMETER_PLACEHOLDER
7692 
7693         **kwargs
7694             Keyword arguments control the `.Line2D` properties:
7695 
7696             %(Line2D:kwdoc)s
7697 
7698         See Also
7699         --------
7700         magnitude_spectrum
7701             Plots the magnitudes of the corresponding frequencies.
7702         angle_spectrum
7703             Plots the wrapped version of this function.
7704         specgram
7705             Can plot the phase spectrum of segments within the signal in a
7706             colormap.
7707         """
7708         if Fc is None:
7709             Fc = 0
7710 
7711         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7712                                           pad_to=pad_to, sides=sides)
7713         freqs += Fc
7714 
7715         lines = self.plot(freqs, spec, **kwargs)
7716         self.set_xlabel('Frequency')
7717         self.set_ylabel('Phase (radians)')
7718 
7719         return spec, freqs, lines[0]
7720 
7721     @_preprocess_data(replace_names=["x", "y"])
7722     @_docstring.dedent_interpd
7723     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7724                window=mlab.window_hanning, noverlap=0, pad_to=None,
7725                sides='default', scale_by_freq=None, **kwargs):
7726         r"""
7727         Plot the coherence between *x* and *y*.
7728 
7729         Coherence is the normalized cross spectral density:
7730 
7731         .. math::
7732 
7733           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7734 
7735         Parameters
7736         ----------
7737         %(Spectral)s
7738 
7739         %(PSD)s
7740 
7741         noverlap : int, default: 0 (no overlap)
7742             The number of points of overlap between blocks.
7743 
7744         Fc : int, default: 0
7745             The center frequency of *x*, which offsets the x extents of the
7746             plot to reflect the frequency range used when a signal is acquired
7747             and then filtered and downsampled to baseband.
7748 
7749         Returns
7750         -------
7751         Cxy : 1-D array
7752             The coherence vector.
7753 
7754         freqs : 1-D array
7755             The frequencies for the elements in *Cxy*.
7756 
7757         Other Parameters
7758         ----------------
7759         data : indexable object, optional
7760             DATA_PARAMETER_PLACEHOLDER
7761 
7762         **kwargs
7763             Keyword arguments control the `.Line2D` properties:
7764 
7765             %(Line2D:kwdoc)s
7766 
7767         References
7768         ----------
7769         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7770         John Wiley & Sons (1986)
7771         """
7772         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7773                                  window=window, noverlap=noverlap,
7774                                  scale_by_freq=scale_by_freq, sides=sides,
7775                                  pad_to=pad_to)
7776         freqs += Fc
7777 
7778         self.plot(freqs, cxy, **kwargs)
7779         self.set_xlabel('Frequency')
7780         self.set_ylabel('Coherence')
7781         self.grid(True)
7782 
7783         return cxy, freqs
7784 
7785     @_preprocess_data(replace_names=["x"])
7786     @_docstring.dedent_interpd
7787     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7788                  window=None, noverlap=None,
7789                  cmap=None, xextent=None, pad_to=None, sides=None,
7790                  scale_by_freq=None, mode=None, scale=None,
7791                  vmin=None, vmax=None, **kwargs):
7792         """
7793         Plot a spectrogram.
7794 
7795         Compute and plot a spectrogram of data in *x*.  Data are split into
7796         *NFFT* length segments and the spectrum of each section is
7797         computed.  The windowing function *window* is applied to each
7798         segment, and the amount of overlap of each segment is
7799         specified with *noverlap*. The spectrogram is plotted as a colormap
7800         (using imshow).
7801 
7802         Parameters
7803         ----------
7804         x : 1-D array or sequence
7805             Array or sequence containing the data.
7806 
7807         %(Spectral)s
7808 
7809         %(PSD)s
7810 
7811         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7812             What sort of spectrum to use.  Default is 'psd', which takes the
7813             power spectral density.  'magnitude' returns the magnitude
7814             spectrum.  'angle' returns the phase spectrum without unwrapping.
7815             'phase' returns the phase spectrum with unwrapping.
7816 
7817         noverlap : int, default: 128
7818             The number of points of overlap between blocks.
7819 
7820         scale : {'default', 'linear', 'dB'}
7821             The scaling of the values in the *spec*.  'linear' is no scaling.
7822             'dB' returns the values in dB scale.  When *mode* is 'psd',
7823             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7824             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7825             'magnitude' and 'linear' otherwise.  This must be 'linear'
7826             if *mode* is 'angle' or 'phase'.
7827 
7828         Fc : int, default: 0
7829             The center frequency of *x*, which offsets the x extents of the
7830             plot to reflect the frequency range used when a signal is acquired
7831             and then filtered and downsampled to baseband.
7832 
7833         cmap : `.Colormap`, default: :rc:`image.cmap`
7834 
7835         xextent : *None* or (xmin, xmax)
7836             The image extent along the x-axis. The default sets *xmin* to the
7837             left border of the first bin (*spectrum* column) and *xmax* to the
7838             right border of the last bin. Note that for *noverlap>0* the width
7839             of the bins is smaller than those of the segments.
7840 
7841         data : indexable object, optional
7842             DATA_PARAMETER_PLACEHOLDER
7843 
7844         **kwargs
7845             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7846             which makes the specgram image. The origin keyword argument
7847             is not supported.
7848 
7849         Returns
7850         -------
7851         spectrum : 2D array
7852             Columns are the periodograms of successive segments.
7853 
7854         freqs : 1-D array
7855             The frequencies corresponding to the rows in *spectrum*.
7856 
7857         t : 1-D array
7858             The times corresponding to midpoints of segments (i.e., the columns
7859             in *spectrum*).
7860 
7861         im : `.AxesImage`
7862             The image created by imshow containing the spectrogram.
7863 
7864         See Also
7865         --------
7866         psd
7867             Differs in the default overlap; in returning the mean of the
7868             segment periodograms; in not returning times; and in generating a
7869             line plot instead of colormap.
7870         magnitude_spectrum
7871             A single spectrum, similar to having a single segment when *mode*
7872             is 'magnitude'. Plots a line instead of a colormap.
7873         angle_spectrum
7874             A single spectrum, similar to having a single segment when *mode*
7875             is 'angle'. Plots a line instead of a colormap.
7876         phase_spectrum
7877             A single spectrum, similar to having a single segment when *mode*
7878             is 'phase'. Plots a line instead of a colormap.
7879 
7880         Notes
7881         -----
7882         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7883         is set to 'psd'.
7884         """
7885         if NFFT is None:
7886             NFFT = 256  # same default as in mlab.specgram()
7887         if Fc is None:
7888             Fc = 0  # same default as in mlab._spectral_helper()
7889         if noverlap is None:
7890             noverlap = 128  # same default as in mlab.specgram()
7891         if Fs is None:
7892             Fs = 2  # same default as in mlab._spectral_helper()
7893 
7894         if mode == 'complex':
7895             raise ValueError('Cannot plot a complex specgram')
7896 
7897         if scale is None or scale == 'default':
7898             if mode in ['angle', 'phase']:
7899                 scale = 'linear'
7900             else:
7901                 scale = 'dB'
7902         elif mode in ['angle', 'phase'] and scale == 'dB':
7903             raise ValueError('Cannot use dB scale with angle or phase mode')
7904 
7905         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7906                                        detrend=detrend, window=window,
7907                                        noverlap=noverlap, pad_to=pad_to,
7908                                        sides=sides,
7909                                        scale_by_freq=scale_by_freq,
7910                                        mode=mode)
7911 
7912         if scale == 'linear':
7913             Z = spec
7914         elif scale == 'dB':
7915             if mode is None or mode == 'default' or mode == 'psd':
7916                 Z = 10. * np.log10(spec)
7917             else:
7918                 Z = 20. * np.log10(spec)
7919         else:
7920             raise ValueError(f'Unknown scale {scale!r}')
7921 
7922         Z = np.flipud(Z)
7923 
7924         if xextent is None:
7925             # padding is needed for first and last segment:
7926             pad_xextent = (NFFT-noverlap) / Fs / 2
7927             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7928         xmin, xmax = xextent
7929         freqs += Fc
7930         extent = xmin, xmax, freqs[0], freqs[-1]
7931 
7932         if 'origin' in kwargs:
7933             raise _api.kwarg_error("specgram", "origin")
7934 
7935         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7936                          origin='upper', **kwargs)
7937         self.axis('auto')
7938 
7939         return spec, freqs, t, im
7940 
7941     @_docstring.dedent_interpd
7942     def spy(self, Z, precision=0, marker=None, markersize=None,
7943             aspect='equal', origin="upper", **kwargs):
7944         """
7945         Plot the sparsity pattern of a 2D array.
7946 
7947         This visualizes the non-zero values of the array.
7948 
7949         Two plotting styles are available: image and marker. Both
7950         are available for full arrays, but only the marker style
7951         works for `scipy.sparse.spmatrix` instances.
7952 
7953         **Image style**
7954 
7955         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7956         extra remaining keyword arguments are passed to this method.
7957 
7958         **Marker style**
7959 
7960         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7961         *None*, a `.Line2D` object will be returned with the value of marker
7962         determining the marker type, and any remaining keyword arguments
7963         passed to `~.Axes.plot`.
7964 
7965         Parameters
7966         ----------
7967         Z : (M, N) array-like
7968             The array to be plotted.
7969 
7970         precision : float or 'present', default: 0
7971             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7972             values of :math:`|Z| > precision` will be plotted.
7973 
7974             For `scipy.sparse.spmatrix` instances, you can also
7975             pass 'present'. In this case any value present in the array
7976             will be plotted, even if it is identically zero.
7977 
7978         aspect : {'equal', 'auto', None} or float, default: 'equal'
7979             The aspect ratio of the Axes.  This parameter is particularly
7980             relevant for images since it determines whether data pixels are
7981             square.
7982 
7983             This parameter is a shortcut for explicitly calling
7984             `.Axes.set_aspect`. See there for further details.
7985 
7986             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7987             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7988               that the data fit in the Axes. In general, this will result in
7989               non-square pixels.
7990             - *None*: Use :rc:`image.aspect`.
7991 
7992         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7993             Place the [0, 0] index of the array in the upper left or lower left
7994             corner of the Axes. The convention 'upper' is typically used for
7995             matrices and images.
7996 
7997         Returns
7998         -------
7999         `~matplotlib.image.AxesImage` or `.Line2D`
8000             The return type depends on the plotting style (see above).
8001 
8002         Other Parameters
8003         ----------------
8004         **kwargs
8005             The supported additional parameters depend on the plotting style.
8006 
8007             For the image style, you can pass the following additional
8008             parameters of `~.Axes.imshow`:
8009 
8010             - *cmap*
8011             - *alpha*
8012             - *url*
8013             - any `.Artist` properties (passed on to the `.AxesImage`)
8014 
8015             For the marker style, you can pass any `.Line2D` property except
8016             for *linestyle*:
8017 
8018             %(Line2D:kwdoc)s
8019         """
8020         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8021             marker = 's'
8022         _api.check_in_list(["upper", "lower"], origin=origin)
8023         if marker is None and markersize is None:
8024             Z = np.asarray(Z)
8025             mask = np.abs(Z) > precision
8026 
8027             if 'cmap' not in kwargs:
8028                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8029                                                         name='binary')
8030             if 'interpolation' in kwargs:
8031                 raise _api.kwarg_error("spy", "interpolation")
8032             if 'norm' not in kwargs:
8033                 kwargs['norm'] = mcolors.NoNorm()
8034             ret = self.imshow(mask, interpolation='nearest',
8035                               aspect=aspect, origin=origin,
8036                               **kwargs)
8037         else:
8038             if hasattr(Z, 'tocoo'):
8039                 c = Z.tocoo()
8040                 if precision == 'present':
8041                     y = c.row
8042                     x = c.col
8043                 else:
8044                     nonzero = np.abs(c.data) > precision
8045                     y = c.row[nonzero]
8046                     x = c.col[nonzero]
8047             else:
8048                 Z = np.asarray(Z)
8049                 nonzero = np.abs(Z) > precision
8050                 y, x = np.nonzero(nonzero)
8051             if marker is None:
8052                 marker = 's'
8053             if markersize is None:
8054                 markersize = 10
8055             if 'linestyle' in kwargs:
8056                 raise _api.kwarg_error("spy", "linestyle")
8057             ret = mlines.Line2D(
8058                 x, y, linestyle='None', marker=marker, markersize=markersize,
8059                 **kwargs)
8060             self.add_line(ret)
8061             nr, nc = Z.shape
8062             self.set_xlim(-0.5, nc - 0.5)
8063             if origin == "upper":
8064                 self.set_ylim(nr - 0.5, -0.5)
8065             else:
8066                 self.set_ylim(-0.5, nr - 0.5)
8067             self.set_aspect(aspect)
8068         self.title.set_y(1.05)
8069         if origin == "upper":
8070             self.xaxis.tick_top()
8071         else:  # lower
8072             self.xaxis.tick_bottom()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return ret
8079 
8080     def matshow(self, Z, **kwargs):
8081         """
8082         Plot the values of a 2D matrix or array as color-coded image.
8083 
8084         The matrix will be shown the way it would be printed, with the first
8085         row at the top.  Row and column numbering is zero-based.
8086 
8087         Parameters
8088         ----------
8089         Z : (M, N) array-like
8090             The matrix to be displayed.
8091 
8092         Returns
8093         -------
8094         `~matplotlib.image.AxesImage`
8095 
8096         Other Parameters
8097         ----------------
8098         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8099 
8100         See Also
8101         --------
8102         imshow : More general function to plot data on a 2D regular raster.
8103 
8104         Notes
8105         -----
8106         This is just a convenience function wrapping `.imshow` to set useful
8107         defaults for displaying a matrix. In particular:
8108 
8109         - Set ``origin='upper'``.
8110         - Set ``interpolation='nearest'``.
8111         - Set ``aspect='equal'``.
8112         - Ticks are placed to the left and above.
8113         - Ticks are formatted to show integer indices.
8114 
8115         """
8116         Z = np.asanyarray(Z)
8117         kw = {'origin': 'upper',
8118               'interpolation': 'nearest',
8119               'aspect': 'equal',          # (already the imshow default)
8120               **kwargs}
8121         im = self.imshow(Z, **kw)
8122         self.title.set_y(1.05)
8123         self.xaxis.tick_top()
8124         self.xaxis.set_ticks_position('both')
8125         self.xaxis.set_major_locator(
8126             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8127         self.yaxis.set_major_locator(
8128             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8129         return im
8130 
8131     @_preprocess_data(replace_names=["dataset"])
8132     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8133                    showmeans=False, showextrema=True, showmedians=False,
8134                    quantiles=None, points=100, bw_method=None):
8135         """
8136         Make a violin plot.
8137 
8138         Make a violin plot for each column of *dataset* or each vector in
8139         sequence *dataset*.  Each filled area extends to represent the
8140         entire data range, with optional lines at the mean, the median,
8141         the minimum, the maximum, and user-specified quantiles.
8142 
8143         Parameters
8144         ----------
8145         dataset : Array or a sequence of vectors.
8146           The input data.
8147 
8148         positions : array-like, default: [1, 2, ..., n]
8149           The positions of the violins. The ticks and limits are
8150           automatically set to match the positions.
8151 
8152         vert : bool, default: True.
8153           If true, creates a vertical violin plot.
8154           Otherwise, creates a horizontal violin plot.
8155 
8156         widths : array-like, default: 0.5
8157           Either a scalar or a vector that sets the maximal width of
8158           each violin. The default is 0.5, which uses about half of the
8159           available horizontal space.
8160 
8161         showmeans : bool, default: False
8162           If `True`, will toggle rendering of the means.
8163 
8164         showextrema : bool, default: True
8165           If `True`, will toggle rendering of the extrema.
8166 
8167         showmedians : bool, default: False
8168           If `True`, will toggle rendering of the medians.
8169 
8170         quantiles : array-like, default: None
8171           If not None, set a list of floats in interval [0, 1] for each violin,
8172           which stands for the quantiles that will be rendered for that
8173           violin.
8174 
8175         points : int, default: 100
8176           Defines the number of points to evaluate each of the
8177           gaussian kernel density estimations at.
8178 
8179         bw_method : str, scalar or callable, optional
8180           The method used to calculate the estimator bandwidth.  This can be
8181           'scott', 'silverman', a scalar constant or a callable.  If a
8182           scalar, this will be used directly as `kde.factor`.  If a
8183           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8184           its only parameter and return a scalar. If None (default), 'scott'
8185           is used.
8186 
8187         data : indexable object, optional
8188             DATA_PARAMETER_PLACEHOLDER
8189 
8190         Returns
8191         -------
8192         dict
8193           A dictionary mapping each component of the violinplot to a
8194           list of the corresponding collection instances created. The
8195           dictionary has the following keys:
8196 
8197           - ``bodies``: A list of the `~.collections.PolyCollection`
8198             instances containing the filled area of each violin.
8199 
8200           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8201             the mean values of each of the violin's distribution.
8202 
8203           - ``cmins``: A `~.collections.LineCollection` instance that marks
8204             the bottom of each violin's distribution.
8205 
8206           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8207             the top of each violin's distribution.
8208 
8209           - ``cbars``: A `~.collections.LineCollection` instance that marks
8210             the centers of each violin's distribution.
8211 
8212           - ``cmedians``: A `~.collections.LineCollection` instance that
8213             marks the median values of each of the violin's distribution.
8214 
8215           - ``cquantiles``: A `~.collections.LineCollection` instance created
8216             to identify the quantile values of each of the violin's
8217             distribution.
8218 
8219         """
8220 
8221         def _kde_method(X, coords):
8222             # Unpack in case of e.g. Pandas or xarray object
8223             X = cbook._unpack_to_numpy(X)
8224             # fallback gracefully if the vector contains only one value
8225             if np.all(X[0] == X):
8226                 return (X[0] == coords).astype(float)
8227             kde = mlab.GaussianKDE(X, bw_method)
8228             return kde.evaluate(coords)
8229 
8230         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8231                                      quantiles=quantiles)
8232         return self.violin(vpstats, positions=positions, vert=vert,
8233                            widths=widths, showmeans=showmeans,
8234                            showextrema=showextrema, showmedians=showmedians)
8235 
8236     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8237                showmeans=False, showextrema=True, showmedians=False):
8238         """
8239         Drawing function for violin plots.
8240 
8241         Draw a violin plot for each column of *vpstats*. Each filled area
8242         extends to represent the entire data range, with optional lines at the
8243         mean, the median, the minimum, the maximum, and the quantiles values.
8244 
8245         Parameters
8246         ----------
8247         vpstats : list of dicts
8248           A list of dictionaries containing stats for each violin plot.
8249           Required keys are:
8250 
8251           - ``coords``: A list of scalars containing the coordinates that
8252             the violin's kernel density estimate were evaluated at.
8253 
8254           - ``vals``: A list of scalars containing the values of the
8255             kernel density estimate at each of the coordinates given
8256             in *coords*.
8257 
8258           - ``mean``: The mean value for this violin's dataset.
8259 
8260           - ``median``: The median value for this violin's dataset.
8261 
8262           - ``min``: The minimum value for this violin's dataset.
8263 
8264           - ``max``: The maximum value for this violin's dataset.
8265 
8266           Optional keys are:
8267 
8268           - ``quantiles``: A list of scalars containing the quantile values
8269             for this violin's dataset.
8270 
8271         positions : array-like, default: [1, 2, ..., n]
8272           The positions of the violins. The ticks and limits are
8273           automatically set to match the positions.
8274 
8275         vert : bool, default: True.
8276           If true, plots the violins vertically.
8277           Otherwise, plots the violins horizontally.
8278 
8279         widths : array-like, default: 0.5
8280           Either a scalar or a vector that sets the maximal width of
8281           each violin. The default is 0.5, which uses about half of the
8282           available horizontal space.
8283 
8284         showmeans : bool, default: False
8285           If true, will toggle rendering of the means.
8286 
8287         showextrema : bool, default: True
8288           If true, will toggle rendering of the extrema.
8289 
8290         showmedians : bool, default: False
8291           If true, will toggle rendering of the medians.
8292 
8293         Returns
8294         -------
8295         dict
8296           A dictionary mapping each component of the violinplot to a
8297           list of the corresponding collection instances created. The
8298           dictionary has the following keys:
8299 
8300           - ``bodies``: A list of the `~.collections.PolyCollection`
8301             instances containing the filled area of each violin.
8302 
8303           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8304             the mean values of each of the violin's distribution.
8305 
8306           - ``cmins``: A `~.collections.LineCollection` instance that marks
8307             the bottom of each violin's distribution.
8308 
8309           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8310             the top of each violin's distribution.
8311 
8312           - ``cbars``: A `~.collections.LineCollection` instance that marks
8313             the centers of each violin's distribution.
8314 
8315           - ``cmedians``: A `~.collections.LineCollection` instance that
8316             marks the median values of each of the violin's distribution.
8317 
8318           - ``cquantiles``: A `~.collections.LineCollection` instance created
8319             to identify the quantiles values of each of the violin's
8320             distribution.
8321         """
8322 
8323         # Statistical quantities to be plotted on the violins
8324         means = []
8325         mins = []
8326         maxes = []
8327         medians = []
8328         quantiles = []
8329 
8330         qlens = []  # Number of quantiles in each dataset.
8331 
8332         artists = {}  # Collections to be returned
8333 
8334         N = len(vpstats)
8335         datashape_message = ("List of violinplot statistics and `{0}` "
8336                              "values must have the same length")
8337 
8338         # Validate positions
8339         if positions is None:
8340             positions = range(1, N + 1)
8341         elif len(positions) != N:
8342             raise ValueError(datashape_message.format("positions"))
8343 
8344         # Validate widths
8345         if np.isscalar(widths):
8346             widths = [widths] * N
8347         elif len(widths) != N:
8348             raise ValueError(datashape_message.format("widths"))
8349 
8350         # Calculate ranges for statistics lines (shape (2, N)).
8351         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8352 
8353         # Colors.
8354         if mpl.rcParams['_internal.classic_mode']:
8355             fillcolor = 'y'
8356             linecolor = 'r'
8357         else:
8358             fillcolor = linecolor = self._get_lines.get_next_color()
8359 
8360         # Check whether we are rendering vertically or horizontally
8361         if vert:
8362             fill = self.fill_betweenx
8363             perp_lines = functools.partial(self.hlines, colors=linecolor)
8364             par_lines = functools.partial(self.vlines, colors=linecolor)
8365         else:
8366             fill = self.fill_between
8367             perp_lines = functools.partial(self.vlines, colors=linecolor)
8368             par_lines = functools.partial(self.hlines, colors=linecolor)
8369 
8370         # Render violins
8371         bodies = []
8372         for stats, pos, width in zip(vpstats, positions, widths):
8373             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8374             vals = np.array(stats['vals'])
8375             vals = 0.5 * width * vals / vals.max()
8376             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8377                             facecolor=fillcolor, alpha=0.3)]
8378             means.append(stats['mean'])
8379             mins.append(stats['min'])
8380             maxes.append(stats['max'])
8381             medians.append(stats['median'])
8382             q = stats.get('quantiles')  # a list of floats, or None
8383             if q is None:
8384                 q = []
8385             quantiles.extend(q)
8386             qlens.append(len(q))
8387         artists['bodies'] = bodies
8388 
8389         if showmeans:  # Render means
8390             artists['cmeans'] = perp_lines(means, *line_ends)
8391         if showextrema:  # Render extrema
8392             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8393             artists['cmins'] = perp_lines(mins, *line_ends)
8394             artists['cbars'] = par_lines(positions, mins, maxes)
8395         if showmedians:  # Render medians
8396             artists['cmedians'] = perp_lines(medians, *line_ends)
8397         if quantiles:  # Render quantiles: each width is repeated qlen times.
8398             artists['cquantiles'] = perp_lines(
8399                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8400 
8401         return artists
8402 
8403     # Methods that are entirely implemented in other modules.
8404 
8405     table = mtable.table
8406 
8407     # args can be either Y or y1, y2, ... and all should be replaced
8408     stackplot = _preprocess_data()(mstack.stackplot)
8409 
8410     streamplot = _preprocess_data(
8411         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8412 
8413     tricontour = mtri.tricontour
8414     tricontourf = mtri.tricontourf
8415     tripcolor = mtri.tripcolor
8416     triplot = mtri.triplot
8417 
8418     def _get_aspect_ratio(self):
8419         """
8420         Convenience method to calculate the aspect ratio of the axes in
8421         the display coordinate system.
8422         """
8423         figure_size = self.get_figure().get_size_inches()
8424         ll, ur = self.get_position() * figure_size
8425         width, height = ur - ll
8426         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/contour.py</file>
<class>ContourSet</class>
<method>None</method>
<code>
706 class ContourSet(ContourLabeler, mcoll.Collection):
707     """
708     Store a set of contour lines or filled regions.
709 
710     User-callable method: `~.Axes.clabel`
711 
712     Parameters
713     ----------
714     ax : `~matplotlib.axes.Axes`
715 
716     levels : [level0, level1, ..., leveln]
717         A list of floating point numbers indicating the contour levels.
718 
719     allsegs : [level0segs, level1segs, ...]
720         List of all the polygon segments for all the *levels*.
721         For contour lines ``len(allsegs) == len(levels)``, and for
722         filled contour regions ``len(allsegs) = len(levels)-1``. The lists
723         should look like ::
724 
725             level0segs = [polygon0, polygon1, ...]
726             polygon0 = [[x0, y0], [x1, y1], ...]
727 
728     allkinds : ``None`` or [level0kinds, level1kinds, ...]
729         Optional list of all the polygon vertex kinds (code types), as
730         described and used in Path. This is used to allow multiply-
731         connected paths such as holes within filled polygons.
732         If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
733         should look like ::
734 
735             level0kinds = [polygon0kinds, ...]
736             polygon0kinds = [vertexcode0, vertexcode1, ...]
737 
738         If *allkinds* is not ``None``, usually all polygons for a
739         particular contour level are grouped together so that
740         ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.
741 
742     **kwargs
743         Keyword arguments are as described in the docstring of
744         `~.Axes.contour`.
745 
746     %(contour_set_attributes)s
747     """
748 
749     def __init__(self, ax, *args,
750                  levels=None, filled=False, linewidths=None, linestyles=None,
751                  hatches=(None,), alpha=None, origin=None, extent=None,
752                  cmap=None, colors=None, norm=None, vmin=None, vmax=None,
753                  extend='neither', antialiased=None, nchunk=0, locator=None,
754                  transform=None, negative_linestyles=None,
755                  **kwargs):
756         """
757         Draw contour lines or filled regions, depending on
758         whether keyword arg *filled* is ``False`` (default) or ``True``.
759 
760         Call signature::
761 
762             ContourSet(ax, levels, allsegs, [allkinds], **kwargs)
763 
764         Parameters
765         ----------
766         ax : `~matplotlib.axes.Axes`
767             The `~.axes.Axes` object to draw on.
768 
769         levels : [level0, level1, ..., leveln]
770             A list of floating point numbers indicating the contour
771             levels.
772 
773         allsegs : [level0segs, level1segs, ...]
774             List of all the polygon segments for all the *levels*.
775             For contour lines ``len(allsegs) == len(levels)``, and for
776             filled contour regions ``len(allsegs) = len(levels)-1``. The lists
777             should look like ::
778 
779                 level0segs = [polygon0, polygon1, ...]
780                 polygon0 = [[x0, y0], [x1, y1], ...]
781 
782         allkinds : [level0kinds, level1kinds, ...], optional
783             Optional list of all the polygon vertex kinds (code types), as
784             described and used in Path. This is used to allow multiply-
785             connected paths such as holes within filled polygons.
786             If not ``None``, ``len(allkinds) == len(allsegs)``. The lists
787             should look like ::
788 
789                 level0kinds = [polygon0kinds, ...]
790                 polygon0kinds = [vertexcode0, vertexcode1, ...]
791 
792             If *allkinds* is not ``None``, usually all polygons for a
793             particular contour level are grouped together so that
794             ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.
795 
796         **kwargs
797             Keyword arguments are as described in the docstring of
798             `~.Axes.contour`.
799         """
800         if antialiased is None and filled:
801             # Eliminate artifacts; we are not stroking the boundaries.
802             antialiased = False
803             # The default for line contours will be taken from the
804             # LineCollection default, which uses :rc:`lines.antialiased`.
805         super().__init__(
806             antialiaseds=antialiased,
807             alpha=alpha,
808             transform=transform,
809         )
810         self.axes = ax
811         self.levels = levels
812         self.filled = filled
813         self.hatches = hatches
814         self.origin = origin
815         self.extent = extent
816         self.colors = colors
817         self.extend = extend
818 
819         self.nchunk = nchunk
820         self.locator = locator
821         if (isinstance(norm, mcolors.LogNorm)
822                 or isinstance(self.locator, ticker.LogLocator)):
823             self.logscale = True
824             if norm is None:
825                 norm = mcolors.LogNorm()
826         else:
827             self.logscale = False
828 
829         _api.check_in_list([None, 'lower', 'upper', 'image'], origin=origin)
830         if self.extent is not None and len(self.extent) != 4:
831             raise ValueError(
832                 "If given, 'extent' must be None or (x0, x1, y0, y1)")
833         if self.colors is not None and cmap is not None:
834             raise ValueError('Either colors or cmap must be None')
835         if self.origin == 'image':
836             self.origin = mpl.rcParams['image.origin']
837 
838         self._orig_linestyles = linestyles  # Only kept for user access.
839         self.negative_linestyles = negative_linestyles
840         # If negative_linestyles was not defined as a keyword argument, define
841         # negative_linestyles with rcParams
842         if self.negative_linestyles is None:
843             self.negative_linestyles = \
844                 mpl.rcParams['contour.negative_linestyle']
845 
846         kwargs = self._process_args(*args, **kwargs)
847         self._process_levels()
848 
849         self._extend_min = self.extend in ['min', 'both']
850         self._extend_max = self.extend in ['max', 'both']
851         if self.colors is not None:
852             ncolors = len(self.levels)
853             if self.filled:
854                 ncolors -= 1
855             i0 = 0
856 
857             # Handle the case where colors are given for the extended
858             # parts of the contour.
859 
860             use_set_under_over = False
861             # if we are extending the lower end, and we've been given enough
862             # colors then skip the first color in the resulting cmap. For the
863             # extend_max case we don't need to worry about passing more colors
864             # than ncolors as ListedColormap will clip.
865             total_levels = (ncolors +
866                             int(self._extend_min) +
867                             int(self._extend_max))
868             if (len(self.colors) == total_levels and
869                     (self._extend_min or self._extend_max)):
870                 use_set_under_over = True
871                 if self._extend_min:
872                     i0 = 1
873 
874             cmap = mcolors.ListedColormap(self.colors[i0:None], N=ncolors)
875 
876             if use_set_under_over:
877                 if self._extend_min:
878                     cmap.set_under(self.colors[0])
879                 if self._extend_max:
880                     cmap.set_over(self.colors[-1])
881 
882         # label lists must be initialized here
883         self.labelTexts = []
884         self.labelCValues = []
885 
886         self.set_cmap(cmap)
887         if norm is not None:
888             self.set_norm(norm)
889         if vmin is not None:
890             self.norm.vmin = vmin
891         if vmax is not None:
892             self.norm.vmax = vmax
893         self._process_colors()
894 
895         if self._paths is None:
896             self._paths = self._make_paths_from_contour_generator()
897 
898         if self.filled:
899             if linewidths is not None:
900                 _api.warn_external('linewidths is ignored by contourf')
901             # Lower and upper contour levels.
902             lowers, uppers = self._get_lowers_and_uppers()
903             self.set(
904                 edgecolor="none",
905                 # Default zorder taken from Collection
906                 zorder=kwargs.pop("zorder", 1),
907             )
908 
909         else:
910             self.set(
911                 facecolor="none",
912                 linewidths=self._process_linewidths(linewidths),
913                 linestyle=self._process_linestyles(linestyles),
914                 # Default zorder taken from LineCollection, which is higher
915                 # than for filled contours so that lines are displayed on top.
916                 zorder=kwargs.pop("zorder", 2),
917                 label="_nolegend_",
918             )
919 
920         self.axes.add_collection(self, autolim=False)
921         self.sticky_edges.x[:] = [self._mins[0], self._maxs[0]]
922         self.sticky_edges.y[:] = [self._mins[1], self._maxs[1]]
923         self.axes.update_datalim([self._mins, self._maxs])
924         self.axes.autoscale_view(tight=True)
925 
926         self.changed()  # set the colors
927 
928         if kwargs:
929             _api.warn_external(
930                 'The following kwargs were not used by contour: ' +
931                 ", ".join(map(repr, kwargs))
932             )
933 
934     allsegs = _api.deprecated("3.8", pending=True)(property(lambda self: [
935         p.vertices for c in self.collections for p in c.get_paths()]))
936     allkinds = _api.deprecated("3.8", pending=True)(property(lambda self: [
937         p.codes for c in self.collections for p in c.get_paths()]))
938     tcolors = _api.deprecated("3.8")(property(lambda self: [
939         (tuple(rgba),) for rgba in self.to_rgba(self.cvalues, self.alpha)]))
940     tlinewidths = _api.deprecated("3.8")(property(lambda self: [
941         (w,) for w in self.get_linewidths()]))
942     alpha = property(lambda self: self.get_alpha())
943     linestyles = property(lambda self: self._orig_linestyles)
944 
945     @_api.deprecated("3.8")
946     @property
947     def collections(self):
948         # On access, make oneself invisible and instead add the old-style collections
949         # (one PathCollection per level).  We do not try to further split contours into
950         # connected components as we already lost track of what pairs of contours need
951         # to be considered as single units to draw filled regions with holes.
952         if not hasattr(self, "_old_style_split_collections"):
953             self.set_visible(False)
954             fcs = self.get_facecolor()
955             ecs = self.get_edgecolor()
956             lws = self.get_linewidth()
957             lss = self.get_linestyle()
958             self._old_style_split_collections = []
959             for idx, path in enumerate(self._paths):
960                 pc = mcoll.PathCollection(
961                     [path] if len(path.vertices) else [],
962                     alpha=self.get_alpha(),
963                     antialiaseds=self._antialiaseds[idx % len(self._antialiaseds)],
964                     transform=self.get_transform(),
965                     zorder=self.get_zorder(),
966                     label="_nolegend_",
967                     facecolor=fcs[idx] if len(fcs) else "none",
968                     edgecolor=ecs[idx] if len(ecs) else "none",
969                     linewidths=[lws[idx % len(lws)]],
970                     linestyles=[lss[idx % len(lss)]],
971                 )
972                 if self.filled:
973                     pc.set(hatch=self.hatches[idx % len(self.hatches)])
974                 self._old_style_split_collections.append(pc)
975             for col in self._old_style_split_collections:
976                 self.axes.add_collection(col)
977         return self._old_style_split_collections
978 
979     def get_transform(self):
980         """Return the `.Transform` instance used by this ContourSet."""
981         if self._transform is None:
982             self._transform = self.axes.transData
983         elif (not isinstance(self._transform, mtransforms.Transform)
984               and hasattr(self._transform, '_as_mpl_transform')):
985             self._transform = self._transform._as_mpl_transform(self.axes)
986         return self._transform
987 
988     def __getstate__(self):
989         state = self.__dict__.copy()
990         # the C object _contour_generator cannot currently be pickled. This
991         # isn't a big issue as it is not actually used once the contour has
992         # been calculated.
993         state['_contour_generator'] = None
994         return state
995 
996     def legend_elements(self, variable_name='x', str_format=str):
997         """
998         Return a list of artists and labels suitable for passing through
999         to `~.Axes.legend` which represent this ContourSet.
1000 
1001         The labels have the form "0 < x <= 1" stating the data ranges which
1002         the artists represent.
1003 
1004         Parameters
1005         ----------
1006         variable_name : str
1007             The string used inside the inequality used on the labels.
1008         str_format : function: float -> str
1009             Function used to format the numbers in the labels.
1010 
1011         Returns
1012         -------
1013         artists : list[`.Artist`]
1014             A list of the artists.
1015         labels : list[str]
1016             A list of the labels.
1017         """
1018         artists = []
1019         labels = []
1020 
1021         if self.filled:
1022             lowers, uppers = self._get_lowers_and_uppers()
1023             n_levels = len(self._paths)
1024             for idx in range(n_levels):
1025                 artists.append(mpatches.Rectangle(
1026                     (0, 0), 1, 1,
1027                     facecolor=self.get_facecolor()[idx],
1028                     hatch=self.hatches[idx % len(self.hatches)],
1029                 ))
1030                 lower = str_format(lowers[idx])
1031                 upper = str_format(uppers[idx])
1032                 if idx == 0 and self.extend in ('min', 'both'):
1033                     labels.append(fr'${variable_name} \leq {lower}s$')
1034                 elif idx == n_levels - 1 and self.extend in ('max', 'both'):
1035                     labels.append(fr'${variable_name} > {upper}s$')
1036                 else:
1037                     labels.append(fr'${lower} < {variable_name} \leq {upper}$')
1038         else:
1039             for idx, level in enumerate(self.levels):
1040                 artists.append(Line2D(
1041                     [], [],
1042                     color=self.get_edgecolor()[idx],
1043                     linewidth=self.get_linewidths()[idx],
1044                     linestyle=self.get_linestyles()[idx],
1045                 ))
1046                 labels.append(fr'${variable_name} = {str_format(level)}$')
1047 
1048         return artists, labels
1049 
1050     def _process_args(self, *args, **kwargs):
1051         """
1052         Process *args* and *kwargs*; override in derived classes.
1053 
1054         Must set self.levels, self.zmin and self.zmax, and update axes limits.
1055         """
1056         self.levels = args[0]
1057         allsegs = args[1]
1058         allkinds = args[2] if len(args) > 2 else None
1059         self.zmax = np.max(self.levels)
1060         self.zmin = np.min(self.levels)
1061 
1062         if allkinds is None:
1063             allkinds = [[None] * len(segs) for segs in allsegs]
1064 
1065         # Check lengths of levels and allsegs.
1066         if self.filled:
1067             if len(allsegs) != len(self.levels) - 1:
1068                 raise ValueError('must be one less number of segments as '
1069                                  'levels')
1070         else:
1071             if len(allsegs) != len(self.levels):
1072                 raise ValueError('must be same number of segments as levels')
1073 
1074         # Check length of allkinds.
1075         if len(allkinds) != len(allsegs):
1076             raise ValueError('allkinds has different length to allsegs')
1077 
1078         # Determine x, y bounds and update axes data limits.
1079         flatseglist = [s for seg in allsegs for s in seg]
1080         points = np.concatenate(flatseglist, axis=0)
1081         self._mins = points.min(axis=0)
1082         self._maxs = points.max(axis=0)
1083 
1084         # Each entry in (allsegs, allkinds) is a list of (segs, kinds): segs is a list
1085         # of (N, 2) arrays of xy coordinates, kinds is a list of arrays of corresponding
1086         # pathcodes.  However, kinds can also be None; in which case all paths in that
1087         # list are codeless (this case is normalized above).  These lists are used to
1088         # construct paths, which then get concatenated.
1089         self._paths = [Path.make_compound_path(*map(Path, segs, kinds))
1090                        for segs, kinds in zip(allsegs, allkinds)]
1091 
1092         return kwargs
1093 
1094     def _make_paths_from_contour_generator(self):
1095         """Compute ``paths`` using C extension."""
1096         if self._paths is not None:
1097             return self._paths
1098         paths = []
1099         empty_path = Path(np.empty((0, 2)))
1100         if self.filled:
1101             lowers, uppers = self._get_lowers_and_uppers()
1102             for level, level_upper in zip(lowers, uppers):
1103                 vertices, kinds = \
1104                     self._contour_generator.create_filled_contour(
1105                         level, level_upper)
1106                 paths.append(Path(np.concatenate(vertices), np.concatenate(kinds))
1107                              if len(vertices) else empty_path)
1108         else:
1109             for level in self.levels:
1110                 vertices, kinds = self._contour_generator.create_contour(level)
1111                 paths.append(Path(np.concatenate(vertices), np.concatenate(kinds))
1112                              if len(vertices) else empty_path)
1113         return paths
1114 
1115     def _get_lowers_and_uppers(self):
1116         """
1117         Return ``(lowers, uppers)`` for filled contours.
1118         """
1119         lowers = self._levels[:-1]
1120         if self.zmin == lowers[0]:
1121             # Include minimum values in lowest interval
1122             lowers = lowers.copy()  # so we don't change self._levels
1123             if self.logscale:
1124                 lowers[0] = 0.99 * self.zmin
1125             else:
1126                 lowers[0] -= 1
1127         uppers = self._levels[1:]
1128         return (lowers, uppers)
1129 
1130     def changed(self):
1131         if not hasattr(self, "cvalues"):
1132             self._process_colors()  # Sets cvalues.
1133         # Force an autoscale immediately because self.to_rgba() calls
1134         # autoscale_None() internally with the data passed to it,
1135         # so if vmin/vmax are not set yet, this would override them with
1136         # content from *cvalues* rather than levels like we want
1137         self.norm.autoscale_None(self.levels)
1138         self.set_array(self.cvalues)
1139         self.update_scalarmappable()
1140         alphas = np.broadcast_to(self.get_alpha(), len(self.cvalues))
1141         for label, cv, alpha in zip(self.labelTexts, self.labelCValues, alphas):
1142             label.set_alpha(alpha)
1143             label.set_color(self.labelMappable.to_rgba(cv))
1144         super().changed()
1145 
1146     def _autolev(self, N):
1147         """
1148         Select contour levels to span the data.
1149 
1150         The target number of levels, *N*, is used only when the
1151         scale is not log and default locator is used.
1152 
1153         We need two more levels for filled contours than for
1154         line contours, because for the latter we need to specify
1155         the lower and upper boundary of each range. For example,
1156         a single contour boundary, say at z = 0, requires only
1157         one contour line, but two filled regions, and therefore
1158         three levels to provide boundaries for both regions.
1159         """
1160         if self.locator is None:
1161             if self.logscale:
1162                 self.locator = ticker.LogLocator()
1163             else:
1164                 self.locator = ticker.MaxNLocator(N + 1, min_n_ticks=1)
1165 
1166         lev = self.locator.tick_values(self.zmin, self.zmax)
1167 
1168         try:
1169             if self.locator._symmetric:
1170                 return lev
1171         except AttributeError:
1172             pass
1173 
1174         # Trim excess levels the locator may have supplied.
1175         under = np.nonzero(lev < self.zmin)[0]
1176         i0 = under[-1] if len(under) else 0
1177         over = np.nonzero(lev > self.zmax)[0]
1178         i1 = over[0] + 1 if len(over) else len(lev)
1179         if self.extend in ('min', 'both'):
1180             i0 += 1
1181         if self.extend in ('max', 'both'):
1182             i1 -= 1
1183 
1184         if i1 - i0 < 3:
1185             i0, i1 = 0, len(lev)
1186 
1187         return lev[i0:i1]
1188 
1189     def _process_contour_level_args(self, args, z_dtype):
1190         """
1191         Determine the contour levels and store in self.levels.
1192         """
1193         if self.levels is None:
1194             if args:
1195                 levels_arg = args[0]
1196             elif np.issubdtype(z_dtype, bool):
1197                 if self.filled:
1198                     levels_arg = [0, .5, 1]
1199                 else:
1200                     levels_arg = [.5]
1201             else:
1202                 levels_arg = 7  # Default, hard-wired.
1203         else:
1204             levels_arg = self.levels
1205         if isinstance(levels_arg, Integral):
1206             self.levels = self._autolev(levels_arg)
1207         else:
1208             self.levels = np.asarray(levels_arg, np.float64)
1209         if self.filled and len(self.levels) < 2:
1210             raise ValueError("Filled contours require at least 2 levels.")
1211         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:
1212             raise ValueError("Contour levels must be increasing")
1213 
1214     def _process_levels(self):
1215         """
1216         Assign values to :attr:`layers` based on :attr:`levels`,
1217         adding extended layers as needed if contours are filled.
1218 
1219         For line contours, layers simply coincide with levels;
1220         a line is a thin layer.  No extended levels are needed
1221         with line contours.
1222         """
1223         # Make a private _levels to include extended regions; we
1224         # want to leave the original levels attribute unchanged.
1225         # (Colorbar needs this even for line contours.)
1226         self._levels = list(self.levels)
1227 
1228         if self.logscale:
1229             lower, upper = 1e-250, 1e250
1230         else:
1231             lower, upper = -1e250, 1e250
1232 
1233         if self.extend in ('both', 'min'):
1234             self._levels.insert(0, lower)
1235         if self.extend in ('both', 'max'):
1236             self._levels.append(upper)
1237         self._levels = np.asarray(self._levels)
1238 
1239         if not self.filled:
1240             self.layers = self.levels
1241             return
1242 
1243         # Layer values are mid-way between levels in screen space.
1244         if self.logscale:
1245             # Avoid overflow by taking sqrt before multiplying.
1246             self.layers = (np.sqrt(self._levels[:-1])
1247                            * np.sqrt(self._levels[1:]))
1248         else:
1249             self.layers = 0.5 * (self._levels[:-1] + self._levels[1:])
1250 
1251     def _process_colors(self):
1252         """
1253         Color argument processing for contouring.
1254 
1255         Note that we base the colormapping on the contour levels
1256         and layers, not on the actual range of the Z values.  This
1257         means we don't have to worry about bad values in Z, and we
1258         always have the full dynamic range available for the selected
1259         levels.
1260 
1261         The color is based on the midpoint of the layer, except for
1262         extended end layers.  By default, the norm vmin and vmax
1263         are the extreme values of the non-extended levels.  Hence,
1264         the layer color extremes are not the extreme values of
1265         the colormap itself, but approach those values as the number
1266         of levels increases.  An advantage of this scheme is that
1267         line contours, when added to filled contours, take on
1268         colors that are consistent with those of the filled regions;
1269         for example, a contour line on the boundary between two
1270         regions will have a color intermediate between those
1271         of the regions.
1272 
1273         """
1274         self.monochrome = self.cmap.monochrome
1275         if self.colors is not None:
1276             # Generate integers for direct indexing.
1277             i0, i1 = 0, len(self.levels)
1278             if self.filled:
1279                 i1 -= 1
1280                 # Out of range indices for over and under:
1281                 if self.extend in ('both', 'min'):
1282                     i0 -= 1
1283                 if self.extend in ('both', 'max'):
1284                     i1 += 1
1285             self.cvalues = list(range(i0, i1))
1286             self.set_norm(mcolors.NoNorm())
1287         else:
1288             self.cvalues = self.layers
1289         self.norm.autoscale_None(self.levels)
1290         self.set_array(self.cvalues)
1291         self.update_scalarmappable()
1292         if self.extend in ('both', 'max', 'min'):
1293             self.norm.clip = False
1294 
1295     def _process_linewidths(self, linewidths):
1296         Nlev = len(self.levels)
1297         if linewidths is None:
1298             default_linewidth = mpl.rcParams['contour.linewidth']
1299             if default_linewidth is None:
1300                 default_linewidth = mpl.rcParams['lines.linewidth']
1301             return [default_linewidth] * Nlev
1302         elif not np.iterable(linewidths):
1303             return [linewidths] * Nlev
1304         else:
1305             linewidths = list(linewidths)
1306             return (linewidths * math.ceil(Nlev / len(linewidths)))[:Nlev]
1307 
1308     def _process_linestyles(self, linestyles):
1309         Nlev = len(self.levels)
1310         if linestyles is None:
1311             tlinestyles = ['solid'] * Nlev
1312             if self.monochrome:
1313                 eps = - (self.zmax - self.zmin) * 1e-15
1314                 for i, lev in enumerate(self.levels):
1315                     if lev < eps:
1316                         tlinestyles[i] = self.negative_linestyles
1317         else:
1318             if isinstance(linestyles, str):
1319                 tlinestyles = [linestyles] * Nlev
1320             elif np.iterable(linestyles):
1321                 tlinestyles = list(linestyles)
1322                 if len(tlinestyles) < Nlev:
1323                     nreps = int(np.ceil(Nlev / len(linestyles)))
1324                     tlinestyles = tlinestyles * nreps
1325                 if len(tlinestyles) > Nlev:
1326                     tlinestyles = tlinestyles[:Nlev]
1327             else:
1328                 raise ValueError("Unrecognized type for linestyles kwarg")
1329         return tlinestyles
1330 
1331     def _find_nearest_contour(self, xy, indices=None):
1332         """
1333         Find the point in the unfilled contour plot that is closest (in screen
1334         space) to point *xy*.
1335 
1336         Parameters
1337         ----------
1338         xy : tuple[float, float]
1339             The reference point (in screen space).
1340         indices : list of int or None, default: None
1341             Indices of contour levels to consider.  If None (the default), all levels
1342             are considered.
1343 
1344         Returns
1345         -------
1346         idx_level_min : int
1347             The index of the contour level closest to *xy*.
1348         idx_vtx_min : int
1349             The index of the `.Path` segment closest to *xy* (at that level).
1350         proj : (float, float)
1351             The point in the contour plot closest to *xy*.
1352         """
1353 
1354         # Convert each contour segment to pixel coordinates and then compare the given
1355         # point to those coordinates for each contour. This is fast enough in normal
1356         # cases, but speedups may be possible.
1357 
1358         if self.filled:
1359             raise ValueError("Method does not support filled contours")
1360 
1361         if indices is None:
1362             indices = range(len(self._paths))
1363 
1364         d2min = np.inf
1365         idx_level_min = idx_vtx_min = proj_min = None
1366 
1367         for idx_level in indices:
1368             path = self._paths[idx_level]
1369             if not len(path.vertices):
1370                 continue
1371             lc = self.get_transform().transform(path.vertices)
1372             d2, proj, leg = _find_closest_point_on_path(lc, xy)
1373             if d2 < d2min:
1374                 d2min = d2
1375                 idx_level_min = idx_level
1376                 idx_vtx_min = leg[1]
1377                 proj_min = proj
1378 
1379         return idx_level_min, idx_vtx_min, proj_min
1380 
1381     @_api.deprecated("3.8")
1382     def find_nearest_contour(self, x, y, indices=None, pixel=True):
1383         """
1384         Find the point in the contour plot that is closest to ``(x, y)``.
1385 
1386         This method does not support filled contours.
1387 
1388         Parameters
1389         ----------
1390         x, y : float
1391             The reference point.
1392         indices : list of int or None, default: None
1393             Indices of contour levels to consider.  If None (the default), all
1394             levels are considered.
1395         pixel : bool, default: True
1396             If *True*, measure distance in pixel (screen) space, which is
1397             useful for manual contour labeling; else, measure distance in axes
1398             space.
1399 
1400         Returns
1401         -------
1402         contour : `.Collection`
1403             The contour that is closest to ``(x, y)``.
1404         segment : int
1405             The index of the `.Path` in *contour* that is closest to
1406             ``(x, y)``.
1407         index : int
1408             The index of the path segment in *segment* that is closest to
1409             ``(x, y)``.
1410         xmin, ymin : float
1411             The point in the contour plot that is closest to ``(x, y)``.
1412         d2 : float
1413             The squared distance from ``(xmin, ymin)`` to ``(x, y)``.
1414         """
1415 
1416         # This function uses a method that is probably quite
1417         # inefficient based on converting each contour segment to
1418         # pixel coordinates and then comparing the given point to
1419         # those coordinates for each contour.  This will probably be
1420         # quite slow for complex contours, but for normal use it works
1421         # sufficiently well that the time is not noticeable.
1422         # Nonetheless, improvements could probably be made.
1423 
1424         if self.filled:
1425             raise ValueError("Method does not support filled contours.")
1426 
1427         if indices is None:
1428             indices = range(len(self.collections))
1429 
1430         d2min = np.inf
1431         conmin = None
1432         segmin = None
1433         imin = None
1434         xmin = None
1435         ymin = None
1436 
1437         point = np.array([x, y])
1438 
1439         for icon in indices:
1440             con = self.collections[icon]
1441             trans = con.get_transform()
1442             paths = con.get_paths()
1443 
1444             for segNum, linepath in enumerate(paths):
1445                 lc = linepath.vertices
1446                 # transfer all data points to screen coordinates if desired
1447                 if pixel:
1448                     lc = trans.transform(lc)
1449 
1450                 d2, xc, leg = _find_closest_point_on_path(lc, point)
1451                 if d2 < d2min:
1452                     d2min = d2
1453                     conmin = icon
1454                     segmin = segNum
1455                     imin = leg[1]
1456                     xmin = xc[0]
1457                     ymin = xc[1]
1458 
1459         return (conmin, segmin, imin, xmin, ymin, d2min)
1460 
1461     def draw(self, renderer):
1462         paths = self._paths
1463         n_paths = len(paths)
1464         if not self.filled or all(hatch is None for hatch in self.hatches):
1465             super().draw(renderer)
1466             return
1467         # In presence of hatching, draw contours one at a time.
1468         for idx in range(n_paths):
1469             with cbook._setattr_cm(self, _paths=[paths[idx]]), self._cm_set(
1470                 hatch=self.hatches[idx % len(self.hatches)],
1471                 array=[self.get_array()[idx]],
1472                 linewidths=[self.get_linewidths()[idx % len(self.get_linewidths())]],
1473                 linestyles=[self.get_linestyles()[idx % len(self.get_linestyles())]],
1474             ):
1475                 super().draw(renderer)

</code><intended_behavior>If adjustments in `axes/_axes.py` are insufficient alone and require changes at the `ContourSet` level, the `ContourSet` class may need a modification or a new method to properly accept and utilize the `clip_path` kwarg passed from `axes/_axes.py`. The modification could involve adjusting the `__init__` method or adding a new method that applies the `clip_path` to all constituent collections of the `ContourSet`. This might be accomplished by iterating over the collections in the `ContourSet` and applying the `clip_path` to each. The expected result is that the `ContourSet` object, when created or updated, would respect the `clip_path` by clipping the contours according to the specified path. This should be done while ensuring any other functionality and kwargs handling remains unaffected for backward compatibility.</intended_behavior>]
2025-10-15 07:53:21.335 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:53:21.335 | INFO     | Search-only: skipping patch selection
2025-10-15 07:53:21.434 | INFO     | Task matplotlib__matplotlib-26278 completed successfully.
2025-10-15 07:53:21.435 | INFO     | No patch generated. You can try running ACR again.
