2025-10-15 14:24:59.128 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 14:25:08.931 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=576, output_tokens=12, cost=0.006120
2025-10-15 14:25:20.939 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=756, output_tokens=442, cost=0.020820
2025-10-15 14:25:22.763 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:25:33.510 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=867, output_tokens=369, cost=0.019740
2025-10-15 14:25:33.519 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:25:36.377 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=723, output_tokens=69, cost=0.009300
2025-10-15 14:25:36.379 | DEBUG    | Extracted a valid json.
2025-10-15 14:25:36.379 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Expr\")",
        "search_method_in_class(\"__eq__\", \"Expr\")",
        "search_method(\"sympify\")",
        "search_method(\"parse_expr\")",
        "search_code(\"expr = eval(\")"
    ],
    "bug_locations": []
}
2025-10-15 14:25:36.532 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:25:36.533 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:26:01.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7900, output_tokens=896, cost=0.105880
2025-10-15 14:26:01.935 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:26:16.733 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9012, output_tokens=462, cost=0.103980
2025-10-15 14:26:16.743 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:26:28.297 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=816, output_tokens=337, cost=0.018270
2025-10-15 14:26:28.298 | DEBUG    | Extracted a valid json.
2025-10-15 14:26:28.298 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/expr.py",
            "class": "Expr",
            "method": "__eq__",
            "intended_behavior": "This method should have a mechanism to securely check equality without resorting to sympify for untrusted string representations that might get evaluated. A possible fix is enhancing the safety of sympify itself to prevent evaluation of arbitrary code or adding a preliminary check in __eq__ to avoid calling sympify with potentially dangerous inputs. Preserve equality checking functionality without evaluating repr strings of unknown objects."
        },
        {
            "file": "sympy/core/sympify.py",
            "class": "",
            "method": "sympify",
            "intended_behavior": "Modify the behavior to either securely parse string inputs without using eval or incorporate a more sophisticated method/input validation to ensure that only safe expressions are evaluated. The function should continue to convert a wide range of inputs into SymPy objects but with enhanced safety, explicitly avoiding the evaluation of arbitrary code through string representations."
        },
        {
            "file": "sympy/parsing/sympy_parser.py",
            "class": "",
            "method": "eval_expr",
            "intended_behavior": "Revisit the direct use of eval to ensure that it's not exposed to arbitrary code execution risks. This might involve replacing eval with a safer evaluation strategy or enforcing strict validation of the inputs before they reach eval. The function's capacity to convert parsed expressions into SymPy expressions should be maintained while ensuring the security and integrity of the operation."
        }
    ]
}
2025-10-15 14:26:28.304 | DEBUG    | Found override of __eq__ in Basic
2025-10-15 14:26:28.304 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x74155fd22c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x74146d85f0e0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x74146fb623e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x74146d85f0e0>, <app.raw_tasks.RawSweTask object at 0x74146d85f110>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x74146fb62480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x74146d5a1ca0>
    └ <function run_task_in_subprocess at 0x74146fb62660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x74146d5a1ca0>
    │        │      └ <function run_raw_task at 0x74146fb62700>
    │        └ <function ProcessPoolExecutor.submit at 0x74155f94a020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x74155f949da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x74155f949ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x74155f949f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x74146fd79100>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x74155fb14ea0>
    └ <ForkProcess name='ForkProcess-469' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-469' parent=45407 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x74155fb860c0>)>
    │    │        └ <ForkProcess name='ForkProcess-469' parent=45407 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-469' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-469' parent=45407 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-469' parent=45407 started>
    │    └ <function Popen._launch at 0x74146db7f7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x74146ee6e450>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x74155fb158a0>
           └ <ForkProcess name='ForkProcess-469' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x74155fb14e00>
    └ <ForkProcess name='ForkProcess-469' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-469' parent=45407 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x74146fd5e960>, <multiprocessing.queues.SimpleQueue object at 0x74146fb80f...
    │    │        └ <ForkProcess name='ForkProcess-469' parent=45407 started>
    │    └ <function _process_worker at 0x74155f9491c0>
    └ <ForkProcess name='ForkProcess-469' parent=45407 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x74155fdad640>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x74147096ec30>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x74155fdad640>
        │         └ <function run_raw_task at 0x74146fb62700>
        └ <concurrent.futures.process._CallItem object at 0x74155fdad640>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output/sympy__sympy-18057_2025-10-15_14-24-58'
             │            │    └ <function RawSweTask.to_task at 0x74146fb616c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x74147096ec30>
             └ <function do_inference at 0x74146fb628e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x74146fdf0400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7414702104a0>
       │                 │         │            └ SweTask(task_id='sympy__sympy-18057', problem_statement="Sympy incorrectly attempts to eval reprs in its __eq__ method\nPassi...
       │                 │         └ <app.manage.ProjectApiManager object at 0x74146e0843e0>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output/sympy__sympy-18057_2025-10-15_14-24-58/output_0')
       └ <function _run_one_task at 0x74146fdf18a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x74146fe9dbc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x74146d8b69f0>
                                  └ <app.manage.ProjectApiManager object at 0x74146e0843e0>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'sympy/core/expr.py', 'class': 'Expr', 'method': '__eq__', 'intended_behavior': 'This method should have a mechanism...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x74146fe9d8a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x74146e5aca70>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x74146d8b69f0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '__eq__'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/expr....
    │    │                      │   └ 'Expr'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/expr....
    │    └ <function SearchBackend._get_inherited_methods at 0x74146fe9d800>
    └ <app.search.search_backend.SearchBackend object at 0x74146e5aca70>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'Basic', 'method_name': '__eq__'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x74146fe9cf40>
                                  └ <app.search.search_backend.SearchBackend object at 0x74146e5aca70>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x74146e5aca70>, {'class_name': 'Basic', 'method_name': '__eq__'})
           └ <function SearchBackend.search_method_in_class at 0x74146fe9cea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-15 14:26:28.321 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>__eq__</method>
<code>
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True

</code><intended_behavior>This method should have a mechanism to securely check equality without resorting to sympify for untrusted string representations that might get evaluated. A possible fix is enhancing the safety of sympify itself to prevent evaluation of arbitrary code or adding a preliminary check in __eq__ to avoid calling sympify with potentially dangerous inputs. Preserve equality checking functionality without evaluating repr strings of unknown objects.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     def __hash__(self):
105         # hash cannot be cached using cache_it because infinite recurrence
106         # occurs as hash is needed for setting cache dictionary keys
107         h = self._mhash
108         if h is None:
109             h = hash((type(self).__name__,) + self._hashable_content())
110             self._mhash = h
111         return h
112 
113     def _hashable_content(self):
114         """Return a tuple of information about self that can be used to
115         compute the hash. If a class defines additional attributes,
116         like ``name`` in Symbol, then this method should be updated
117         accordingly to return such relevant attributes.
118         Defining more than _hashable_content is necessary if __eq__ has
119         been defined by a class. See note about this in Basic.__eq__."""
120         return self._args
121 
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True
143 
144     # ***************
145     # * Arithmetics *
146     # ***************
147     # Expr and its sublcasses use _op_priority to determine which object
148     # passed to a binary special method (__mul__, etc.) will handle the
149     # operation. In general, the 'call_highest_priority' decorator will choose
150     # the object with the highest _op_priority to handle the call.
151     # Custom subclasses that want to define their own binary special methods
152     # should set an _op_priority value that is higher than the default.
153     #
154     # **NOTE**:
155     # This is a temporary fix, and will eventually be replaced with
156     # something better and more powerful.  See issue 5510.
157     _op_priority = 10.0
158 
159     def __pos__(self):
160         return self
161 
162     def __neg__(self):
163         # Mul has its own __neg__ routine, so we just
164         # create a 2-args Mul with the -1 in the canonical
165         # slot 0.
166         c = self.is_commutative
167         return Mul._from_args((S.NegativeOne, self), c)
168 
169     def __abs__(self):
170         from sympy import Abs
171         return Abs(self)
172 
173     @_sympifyit('other', NotImplemented)
174     @call_highest_priority('__radd__')
175     def __add__(self, other):
176         return Add(self, other)
177 
178     @_sympifyit('other', NotImplemented)
179     @call_highest_priority('__add__')
180     def __radd__(self, other):
181         return Add(other, self)
182 
183     @_sympifyit('other', NotImplemented)
184     @call_highest_priority('__rsub__')
185     def __sub__(self, other):
186         return Add(self, -other)
187 
188     @_sympifyit('other', NotImplemented)
189     @call_highest_priority('__sub__')
190     def __rsub__(self, other):
191         return Add(other, -self)
192 
193     @_sympifyit('other', NotImplemented)
194     @call_highest_priority('__rmul__')
195     def __mul__(self, other):
196         return Mul(self, other)
197 
198     @_sympifyit('other', NotImplemented)
199     @call_highest_priority('__mul__')
200     def __rmul__(self, other):
201         return Mul(other, self)
202 
203     @_sympifyit('other', NotImplemented)
204     @call_highest_priority('__rpow__')
205     def _pow(self, other):
206         return Pow(self, other)
207 
208     def __pow__(self, other, mod=None):
209         if mod is None:
210             return self._pow(other)
211         try:
212             _self, other, mod = as_int(self), as_int(other), as_int(mod)
213             if other >= 0:
214                 return pow(_self, other, mod)
215             else:
216                 from sympy.core.numbers import mod_inverse
217                 return mod_inverse(pow(_self, -other, mod), mod)
218         except ValueError:
219             power = self._pow(other)
220             try:
221                 return power%mod
222             except TypeError:
223                 return NotImplemented
224 
225     @_sympifyit('other', NotImplemented)
226     @call_highest_priority('__pow__')
227     def __rpow__(self, other):
228         return Pow(other, self)
229 
230     @_sympifyit('other', NotImplemented)
231     @call_highest_priority('__rdiv__')
232     def __div__(self, other):
233         return Mul(self, Pow(other, S.NegativeOne))
234 
235     @_sympifyit('other', NotImplemented)
236     @call_highest_priority('__div__')
237     def __rdiv__(self, other):
238         return Mul(other, Pow(self, S.NegativeOne))
239 
240     __truediv__ = __div__
241     __rtruediv__ = __rdiv__
242 
243     @_sympifyit('other', NotImplemented)
244     @call_highest_priority('__rmod__')
245     def __mod__(self, other):
246         return Mod(self, other)
247 
248     @_sympifyit('other', NotImplemented)
249     @call_highest_priority('__mod__')
250     def __rmod__(self, other):
251         return Mod(other, self)
252 
253     @_sympifyit('other', NotImplemented)
254     @call_highest_priority('__rfloordiv__')
255     def __floordiv__(self, other):
256         from sympy.functions.elementary.integers import floor
257         return floor(self / other)
258 
259     @_sympifyit('other', NotImplemented)
260     @call_highest_priority('__floordiv__')
261     def __rfloordiv__(self, other):
262         from sympy.functions.elementary.integers import floor
263         return floor(other / self)
264 
265 
266     @_sympifyit('other', NotImplemented)
267     @call_highest_priority('__rdivmod__')
268     def __divmod__(self, other):
269         from sympy.functions.elementary.integers import floor
270         return floor(self / other), Mod(self, other)
271 
272     @_sympifyit('other', NotImplemented)
273     @call_highest_priority('__divmod__')
274     def __rdivmod__(self, other):
275         from sympy.functions.elementary.integers import floor
276         return floor(other / self), Mod(other, self)
277 
278     def __int__(self):
279         # Although we only need to round to the units position, we'll
280         # get one more digit so the extra testing below can be avoided
281         # unless the rounded value rounded to an integer, e.g. if an
282         # expression were equal to 1.9 and we rounded to the unit position
283         # we would get a 2 and would not know if this rounded up or not
284         # without doing a test (as done below). But if we keep an extra
285         # digit we know that 1.9 is not the same as 1 and there is no
286         # need for further testing: our int value is correct. If the value
287         # were 1.99, however, this would round to 2.0 and our int value is
288         # off by one. So...if our round value is the same as the int value
289         # (regardless of how much extra work we do to calculate extra decimal
290         # places) we need to test whether we are off by one.
291         from sympy import Dummy
292         if not self.is_number:
293             raise TypeError("can't convert symbols to int")
294         r = self.round(2)
295         if not r.is_Number:
296             raise TypeError("can't convert complex to int")
297         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
298             raise TypeError("can't convert %s to int" % r)
299         i = int(r)
300         if not i:
301             return 0
302         # off-by-one check
303         if i == r and not (self - i).equals(0):
304             isign = 1 if i > 0 else -1
305             x = Dummy()
306             # in the following (self - i).evalf(2) will not always work while
307             # (self - r).evalf(2) and the use of subs does; if the test that
308             # was added when this comment was added passes, it might be safe
309             # to simply use sign to compute this rather than doing this by hand:
310             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
311             if diff_sign != isign:
312                 i -= isign
313         return i
314     __long__ = __int__
315 
316     def __float__(self):
317         # Don't bother testing if it's a number; if it's not this is going
318         # to fail, and if it is we still need to check that it evalf'ed to
319         # a number.
320         result = self.evalf()
321         if result.is_Number:
322             return float(result)
323         if result.is_number and result.as_real_imag()[1]:
324             raise TypeError("can't convert complex to float")
325         raise TypeError("can't convert expression to float")
326 
327     def __complex__(self):
328         result = self.evalf()
329         re, im = result.as_real_imag()
330         return complex(float(re), float(im))
331 
332     def _cmp(self, other, op, cls):
333         assert op in ("<", ">", "<=", ">=")
334         try:
335             other = _sympify(other)
336         except SympifyError:
337             raise TypeError("Invalid comparison %s %s %s" % (self, op, other))
338         for me in (self, other):
339             if me.is_extended_real is False:
340                 raise TypeError("Invalid comparison of non-real %s" % me)
341             if me is S.NaN:
342                 raise TypeError("Invalid NaN comparison")
343 
344         n2 = _n2(self, other)
345         if n2 is not None:
346             # use float comparison for infinity.
347             # otherwise get stuck in infinite recursion
348             if n2 in (S.Infinity, S.NegativeInfinity):
349                 n2 = float(n2)
350             if op == "<":
351                 return _sympify(n2 < 0)
352             elif op == ">":
353                 return _sympify(n2 > 0)
354             elif op == "<=":
355                 return _sympify(n2 <= 0)
356             else: # >=
357                 return _sympify(n2 >= 0)
358 
359         if self.is_extended_real and other.is_extended_real:
360             if op in ("<=", ">") \
361                 and ((self.is_infinite and self.is_extended_negative) \
362                      or (other.is_infinite and other.is_extended_positive)):
363                 return S.true if op == "<=" else S.false
364             if op in ("<", ">=") \
365                 and ((self.is_infinite and self.is_extended_positive) \
366                      or (other.is_infinite and other.is_extended_negative)):
367                 return S.true if op == ">=" else S.false
368             diff = self - other
369             if diff is not S.NaN:
370                 if op == "<":
371                     test = diff.is_extended_negative
372                 elif op == ">":
373                     test = diff.is_extended_positive
374                 elif op == "<=":
375                     test = diff.is_extended_nonpositive
376                 else: # >=
377                     test = diff.is_extended_nonnegative
378 
379                 if test is not None:
380                     return S.true if test == True else S.false
381 
382         # return unevaluated comparison object
383         return cls(self, other, evaluate=False)
384 
385     def __ge__(self, other):
386         from sympy import GreaterThan
387         return self._cmp(other, ">=", GreaterThan)
388 
389     def __le__(self, other):
390         from sympy import LessThan
391         return self._cmp(other, "<=", LessThan)
392 
393     def __gt__(self, other):
394         from sympy import StrictGreaterThan
395         return self._cmp(other, ">", StrictGreaterThan)
396 
397     def __lt__(self, other):
398         from sympy import StrictLessThan
399         return self._cmp(other, "<", StrictLessThan)
400 
401     def __trunc__(self):
402         if not self.is_number:
403             raise TypeError("can't truncate symbols and expressions")
404         else:
405             return Integer(self)
406 
407     @staticmethod
408     def _from_mpmath(x, prec):
409         from sympy import Float
410         if hasattr(x, "_mpf_"):
411             return Float._new(x._mpf_, prec)
412         elif hasattr(x, "_mpc_"):
413             re, im = x._mpc_
414             re = Float._new(re, prec)
415             im = Float._new(im, prec)*S.ImaginaryUnit
416             return re + im
417         else:
418             raise TypeError("expected mpmath number (mpf or mpc)")
419 
420     @property
421     def is_number(self):
422         """Returns True if ``self`` has no free symbols and no
423         undefined functions (AppliedUndef, to be precise). It will be
424         faster than ``if not self.free_symbols``, however, since
425         ``is_number`` will fail as soon as it hits a free symbol
426         or undefined function.
427 
428         Examples
429         ========
430 
431         >>> from sympy import log, Integral, cos, sin, pi
432         >>> from sympy.core.function import Function
433         >>> from sympy.abc import x
434         >>> f = Function('f')
435 
436         >>> x.is_number
437         False
438         >>> f(1).is_number
439         False
440         >>> (2*x).is_number
441         False
442         >>> (2 + Integral(2, x)).is_number
443         False
444         >>> (2 + Integral(2, (x, 1, 2))).is_number
445         True
446 
447         Not all numbers are Numbers in the SymPy sense:
448 
449         >>> pi.is_number, pi.is_Number
450         (True, False)
451 
452         If something is a number it should evaluate to a number with
453         real and imaginary parts that are Numbers; the result may not
454         be comparable, however, since the real and/or imaginary part
455         of the result may not have precision.
456 
457         >>> cos(1).is_number and cos(1).is_comparable
458         True
459 
460         >>> z = cos(1)**2 + sin(1)**2 - 1
461         >>> z.is_number
462         True
463         >>> z.is_comparable
464         False
465 
466         See Also
467         ========
468         sympy.core.basic.Basic.is_comparable
469         """
470         return all(obj.is_number for obj in self.args)
471 
472     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
473         """Return self evaluated, if possible, replacing free symbols with
474         random complex values, if necessary.
475 
476         The random complex value for each free symbol is generated
477         by the random_complex_number routine giving real and imaginary
478         parts in the range given by the re_min, re_max, im_min, and im_max
479         values. The returned value is evaluated to a precision of n
480         (if given) else the maximum of 15 and the precision needed
481         to get more than 1 digit of precision. If the expression
482         could not be evaluated to a number, or could not be evaluated
483         to more than 1 digit of precision, then None is returned.
484 
485         Examples
486         ========
487 
488         >>> from sympy import sqrt
489         >>> from sympy.abc import x, y
490         >>> x._random()                         # doctest: +SKIP
491         0.0392918155679172 + 0.916050214307199*I
492         >>> x._random(2)                        # doctest: +SKIP
493         -0.77 - 0.87*I
494         >>> (x + y/2)._random(2)                # doctest: +SKIP
495         -0.57 + 0.16*I
496         >>> sqrt(2)._random(2)
497         1.4
498 
499         See Also
500         ========
501 
502         sympy.utilities.randtest.random_complex_number
503         """
504 
505         free = self.free_symbols
506         prec = 1
507         if free:
508             from sympy.utilities.randtest import random_complex_number
509             a, c, b, d = re_min, re_max, im_min, im_max
510             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
511                            for zi in free])))
512             try:
513                 nmag = abs(self.evalf(2, subs=reps))
514             except (ValueError, TypeError):
515                 # if an out of range value resulted in evalf problems
516                 # then return None -- XXX is there a way to know how to
517                 # select a good random number for a given expression?
518                 # e.g. when calculating n! negative values for n should not
519                 # be used
520                 return None
521         else:
522             reps = {}
523             nmag = abs(self.evalf(2))
524 
525         if not hasattr(nmag, '_prec'):
526             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
527             return None
528 
529         if nmag._prec == 1:
530             # increase the precision up to the default maximum
531             # precision to see if we can get any significance
532 
533             from mpmath.libmp.libintmath import giant_steps
534             from sympy.core.evalf import DEFAULT_MAXPREC as target
535 
536             # evaluate
537             for prec in giant_steps(2, target):
538                 nmag = abs(self.evalf(prec, subs=reps))
539                 if nmag._prec != 1:
540                     break
541 
542         if nmag._prec != 1:
543             if n is None:
544                 n = max(prec, 15)
545             return self.evalf(n, subs=reps)
546 
547         # never got any significance
548         return None
549 
550     def is_constant(self, *wrt, **flags):
551         """Return True if self is constant, False if not, or None if
552         the constancy could not be determined conclusively.
553 
554         If an expression has no free symbols then it is a constant. If
555         there are free symbols it is possible that the expression is a
556         constant, perhaps (but not necessarily) zero. To test such
557         expressions, a few strategies are tried:
558 
559         1) numerical evaluation at two random points. If two such evaluations
560         give two different values and the values have a precision greater than
561         1 then self is not constant. If the evaluations agree or could not be
562         obtained with any precision, no decision is made. The numerical testing
563         is done only if ``wrt`` is different than the free symbols.
564 
565         2) differentiation with respect to variables in 'wrt' (or all free
566         symbols if omitted) to see if the expression is constant or not. This
567         will not always lead to an expression that is zero even though an
568         expression is constant (see added test in test_expr.py). If
569         all derivatives are zero then self is constant with respect to the
570         given symbols.
571 
572         3) finding out zeros of denominator expression with free_symbols.
573         It won't be constant if there are zeros. It gives more negative
574         answers for expression that are not constant.
575 
576         If neither evaluation nor differentiation can prove the expression is
577         constant, None is returned unless two numerical values happened to be
578         the same and the flag ``failing_number`` is True -- in that case the
579         numerical value will be returned.
580 
581         If flag simplify=False is passed, self will not be simplified;
582         the default is True since self should be simplified before testing.
583 
584         Examples
585         ========
586 
587         >>> from sympy import cos, sin, Sum, S, pi
588         >>> from sympy.abc import a, n, x, y
589         >>> x.is_constant()
590         False
591         >>> S(2).is_constant()
592         True
593         >>> Sum(x, (x, 1, 10)).is_constant()
594         True
595         >>> Sum(x, (x, 1, n)).is_constant()
596         False
597         >>> Sum(x, (x, 1, n)).is_constant(y)
598         True
599         >>> Sum(x, (x, 1, n)).is_constant(n)
600         False
601         >>> Sum(x, (x, 1, n)).is_constant(x)
602         True
603         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
604         >>> eq.is_constant()
605         True
606         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
607         True
608 
609         >>> (0**x).is_constant()
610         False
611         >>> x.is_constant()
612         False
613         >>> (x**x).is_constant()
614         False
615         >>> one = cos(x)**2 + sin(x)**2
616         >>> one.is_constant()
617         True
618         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
619         True
620         """
621 
622         def check_denominator_zeros(expression):
623             from sympy.solvers.solvers import denoms
624 
625             retNone = False
626             for den in denoms(expression):
627                 z = den.is_zero
628                 if z is True:
629                     return True
630                 if z is None:
631                     retNone = True
632             if retNone:
633                 return None
634             return False
635 
636         simplify = flags.get('simplify', True)
637 
638         if self.is_number:
639             return True
640         free = self.free_symbols
641         if not free:
642             return True  # assume f(1) is some constant
643 
644         # if we are only interested in some symbols and they are not in the
645         # free symbols then this expression is constant wrt those symbols
646         wrt = set(wrt)
647         if wrt and not wrt & free:
648             return True
649         wrt = wrt or free
650 
651         # simplify unless this has already been done
652         expr = self
653         if simplify:
654             expr = expr.simplify()
655 
656         # is_zero should be a quick assumptions check; it can be wrong for
657         # numbers (see test_is_not_constant test), giving False when it
658         # shouldn't, but hopefully it will never give True unless it is sure.
659         if expr.is_zero:
660             return True
661 
662         # try numerical evaluation to see if we get two different values
663         failing_number = None
664         if wrt == free:
665             # try 0 (for a) and 1 (for b)
666             try:
667                 a = expr.subs(list(zip(free, [0]*len(free))),
668                     simultaneous=True)
669                 if a is S.NaN:
670                     # evaluation may succeed when substitution fails
671                     a = expr._random(None, 0, 0, 0, 0)
672             except ZeroDivisionError:
673                 a = None
674             if a is not None and a is not S.NaN:
675                 try:
676                     b = expr.subs(list(zip(free, [1]*len(free))),
677                         simultaneous=True)
678                     if b is S.NaN:
679                         # evaluation may succeed when substitution fails
680                         b = expr._random(None, 1, 0, 1, 0)
681                 except ZeroDivisionError:
682                     b = None
683                 if b is not None and b is not S.NaN and b.equals(a) is False:
684                     return False
685                 # try random real
686                 b = expr._random(None, -1, 0, 1, 0)
687                 if b is not None and b is not S.NaN and b.equals(a) is False:
688                     return False
689                 # try random complex
690                 b = expr._random()
691                 if b is not None and b is not S.NaN:
692                     if b.equals(a) is False:
693                         return False
694                     failing_number = a if a.is_number else b
695 
696         # now we will test each wrt symbol (or all free symbols) to see if the
697         # expression depends on them or not using differentiation. This is
698         # not sufficient for all expressions, however, so we don't return
699         # False if we get a derivative other than 0 with free symbols.
700         for w in wrt:
701             deriv = expr.diff(w)
702             if simplify:
703                 deriv = deriv.simplify()
704             if deriv != 0:
705                 if not (pure_complex(deriv, or_real=True)):
706                     if flags.get('failing_number', False):
707                         return failing_number
708                     elif deriv.free_symbols:
709                         # dead line provided _random returns None in such cases
710                         return None
711                 return False
712         cd = check_denominator_zeros(self)
713         if cd is True:
714             return False
715         elif cd is None:
716             return None
717         return True
718 
719     def equals(self, other, failing_expression=False):
720         """Return True if self == other, False if it doesn't, or None. If
721         failing_expression is True then the expression which did not simplify
722         to a 0 will be returned instead of None.
723 
724         If ``self`` is a Number (or complex number) that is not zero, then
725         the result is False.
726 
727         If ``self`` is a number and has not evaluated to zero, evalf will be
728         used to test whether the expression evaluates to zero. If it does so
729         and the result has significance (i.e. the precision is either -1, for
730         a Rational result, or is greater than 1) then the evalf value will be
731         used to return True or False.
732 
733         """
734         from sympy.simplify.simplify import nsimplify, simplify
735         from sympy.solvers.solvers import solve
736         from sympy.polys.polyerrors import NotAlgebraic
737         from sympy.polys.numberfields import minimal_polynomial
738 
739         other = sympify(other)
740         if self == other:
741             return True
742 
743         # they aren't the same so see if we can make the difference 0;
744         # don't worry about doing simplification steps one at a time
745         # because if the expression ever goes to 0 then the subsequent
746         # simplification steps that are done will be very fast.
747         diff = factor_terms(simplify(self - other), radical=True)
748 
749         if not diff:
750             return True
751 
752         if not diff.has(Add, Mod):
753             # if there is no expanding to be done after simplifying
754             # then this can't be a zero
755             return False
756 
757         constant = diff.is_constant(simplify=False, failing_number=True)
758 
759         if constant is False:
760             return False
761 
762         if not diff.is_number:
763             if constant is None:
764                 # e.g. unless the right simplification is done, a symbolic
765                 # zero is possible (see expression of issue 6829: without
766                 # simplification constant will be None).
767                 return
768 
769         if constant is True:
770             # this gives a number whether there are free symbols or not
771             ndiff = diff._random()
772             # is_comparable will work whether the result is real
773             # or complex; it could be None, however.
774             if ndiff and ndiff.is_comparable:
775                 return False
776 
777         # sometimes we can use a simplified result to give a clue as to
778         # what the expression should be; if the expression is *not* zero
779         # then we should have been able to compute that and so now
780         # we can just consider the cases where the approximation appears
781         # to be zero -- we try to prove it via minimal_polynomial.
782         #
783         # removed
784         # ns = nsimplify(diff)
785         # if diff.is_number and (not ns or ns == diff):
786         #
787         # The thought was that if it nsimplifies to 0 that's a sure sign
788         # to try the following to prove it; or if it changed but wasn't
789         # zero that might be a sign that it's not going to be easy to
790         # prove. But tests seem to be working without that logic.
791         #
792         if diff.is_number:
793             # try to prove via self-consistency
794             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
795             # it seems to work better to try big ones first
796             surds.sort(key=lambda x: -x.args[0])
797             for s in surds:
798                 try:
799                     # simplify is False here -- this expression has already
800                     # been identified as being hard to identify as zero;
801                     # we will handle the checking ourselves using nsimplify
802                     # to see if we are in the right ballpark or not and if so
803                     # *then* the simplification will be attempted.
804                     sol = solve(diff, s, simplify=False)
805                     if sol:
806                         if s in sol:
807                             # the self-consistent result is present
808                             return True
809                         if all(si.is_Integer for si in sol):
810                             # perfect powers are removed at instantiation
811                             # so surd s cannot be an integer
812                             return False
813                         if all(i.is_algebraic is False for i in sol):
814                             # a surd is algebraic
815                             return False
816                         if any(si in surds for si in sol):
817                             # it wasn't equal to s but it is in surds
818                             # and different surds are not equal
819                             return False
820                         if any(nsimplify(s - si) == 0 and
821                                 simplify(s - si) == 0 for si in sol):
822                             return True
823                         if s.is_real:
824                             if any(nsimplify(si, [s]) == s and simplify(si) == s
825                                     for si in sol):
826                                 return True
827                 except NotImplementedError:
828                     pass
829 
830             # try to prove with minimal_polynomial but know when
831             # *not* to use this or else it can take a long time. e.g. issue 8354
832             if True:  # change True to condition that assures non-hang
833                 try:
834                     mp = minimal_polynomial(diff)
835                     if mp.is_Symbol:
836                         return True
837                     return False
838                 except (NotAlgebraic, NotImplementedError):
839                     pass
840 
841         # diff has not simplified to zero; constant is either None, True
842         # or the number with significance (is_comparable) that was randomly
843         # calculated twice as the same value.
844         if constant not in (True, None) and constant != 0:
845             return False
846 
847         if failing_expression:
848             return diff
849         return None
850 
851     def _eval_is_positive(self):
852         finite = self.is_finite
853         if finite is False:
854             return False
855         extended_positive = self.is_extended_positive
856         if finite is True:
857             return extended_positive
858         if extended_positive is False:
859             return False
860 
861     def _eval_is_negative(self):
862         finite = self.is_finite
863         if finite is False:
864             return False
865         extended_negative = self.is_extended_negative
866         if finite is True:
867             return extended_negative
868         if extended_negative is False:
869             return False
870 
871     def _eval_is_extended_positive_negative(self, positive):
872         from sympy.polys.numberfields import minimal_polynomial
873         from sympy.polys.polyerrors import NotAlgebraic
874         if self.is_number:
875             if self.is_extended_real is False:
876                 return False
877 
878             # check to see that we can get a value
879             try:
880                 n2 = self._eval_evalf(2)
881             # XXX: This shouldn't be caught here
882             # Catches ValueError: hypsum() failed to converge to the requested
883             # 34 bits of accuracy
884             except ValueError:
885                 return None
886             if n2 is None:
887                 return None
888             if getattr(n2, '_prec', 1) == 1:  # no significance
889                 return None
890             if n2 is S.NaN:
891                 return None
892 
893             r, i = self.evalf(2).as_real_imag()
894             if not i.is_Number or not r.is_Number:
895                 return False
896             if r._prec != 1 and i._prec != 1:
897                 return bool(not i and ((r > 0) if positive else (r < 0)))
898             elif r._prec == 1 and (not i or i._prec == 1) and \
899                     self.is_algebraic and not self.has(Function):
900                 try:
901                     if minimal_polynomial(self).is_Symbol:
902                         return False
903                 except (NotAlgebraic, NotImplementedError):
904                     pass
905 
906     def _eval_is_extended_positive(self):
907         return self._eval_is_extended_positive_negative(positive=True)
908 
909     def _eval_is_extended_negative(self):
910         return self._eval_is_extended_positive_negative(positive=False)
911 
912     def _eval_interval(self, x, a, b):
913         """
914         Returns evaluation over an interval.  For most functions this is:
915 
916         self.subs(x, b) - self.subs(x, a),
917 
918         possibly using limit() if NaN is returned from subs, or if
919         singularities are found between a and b.
920 
921         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
922         respectively.
923 
924         """
925         from sympy.series import limit, Limit
926         from sympy.solvers.solveset import solveset
927         from sympy.sets.sets import Interval
928         from sympy.functions.elementary.exponential import log
929         from sympy.calculus.util import AccumBounds
930 
931         if (a is None and b is None):
932             raise ValueError('Both interval ends cannot be None.')
933 
934         def _eval_endpoint(left):
935             c = a if left else b
936             if c is None:
937                 return 0
938             else:
939                 C = self.subs(x, c)
940                 if C.has(S.NaN, S.Infinity, S.NegativeInfinity,
941                          S.ComplexInfinity, AccumBounds):
942                     if (a < b) != False:
943                         C = limit(self, x, c, "+" if left else "-")
944                     else:
945                         C = limit(self, x, c, "-" if left else "+")
946 
947                     if isinstance(C, Limit):
948                         raise NotImplementedError("Could not compute limit")
949             return C
950 
951         if a == b:
952             return 0
953 
954         A = _eval_endpoint(left=True)
955         if A is S.NaN:
956             return A
957 
958         B = _eval_endpoint(left=False)
959 
960         if (a and b) is None:
961             return B - A
962 
963         value = B - A
964 
965         if a.is_comparable and b.is_comparable:
966             if a < b:
967                 domain = Interval(a, b)
968             else:
969                 domain = Interval(b, a)
970             # check the singularities of self within the interval
971             # if singularities is a ConditionSet (not iterable), catch the exception and pass
972             singularities = solveset(self.cancel().as_numer_denom()[1], x,
973                 domain=domain)
974             for logterm in self.atoms(log):
975                 singularities = singularities | solveset(logterm.args[0], x,
976                     domain=domain)
977             try:
978                 for s in singularities:
979                     if value is S.NaN:
980                         # no need to keep adding, it will stay NaN
981                         break
982                     if not s.is_comparable:
983                         continue
984                     if (a < s) == (s < b) == True:
985                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
986                     elif (b < s) == (s < a) == True:
987                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
988             except TypeError:
989                 pass
990 
991         return value
992 
993     def _eval_power(self, other):
994         # subclass to compute self**other for cases when
995         # other is not NaN, 0, or 1
996         return None
997 
998     def _eval_conjugate(self):
999         if self.is_extended_real:
1000             return self
1001         elif self.is_imaginary:
1002             return -self
1003 
1004     def conjugate(self):
1005         from sympy.functions.elementary.complexes import conjugate as c
1006         return c(self)
1007 
1008     def _eval_transpose(self):
1009         from sympy.functions.elementary.complexes import conjugate
1010         if (self.is_complex or self.is_infinite):
1011             return self
1012         elif self.is_hermitian:
1013             return conjugate(self)
1014         elif self.is_antihermitian:
1015             return -conjugate(self)
1016 
1017     def transpose(self):
1018         from sympy.functions.elementary.complexes import transpose
1019         return transpose(self)
1020 
1021     def _eval_adjoint(self):
1022         from sympy.functions.elementary.complexes import conjugate, transpose
1023         if self.is_hermitian:
1024             return self
1025         elif self.is_antihermitian:
1026             return -self
1027         obj = self._eval_conjugate()
1028         if obj is not None:
1029             return transpose(obj)
1030         obj = self._eval_transpose()
1031         if obj is not None:
1032             return conjugate(obj)
1033 
1034     def adjoint(self):
1035         from sympy.functions.elementary.complexes import adjoint
1036         return adjoint(self)
1037 
1038     @classmethod
1039     def _parse_order(cls, order):
1040         """Parse and configure the ordering of terms. """
1041         from sympy.polys.orderings import monomial_key
1042 
1043         startswith = getattr(order, "startswith", None)
1044         if startswith is None:
1045             reverse = False
1046         else:
1047             reverse = startswith('rev-')
1048             if reverse:
1049                 order = order[4:]
1050 
1051         monom_key = monomial_key(order)
1052 
1053         def neg(monom):
1054             result = []
1055 
1056             for m in monom:
1057                 if isinstance(m, tuple):
1058                     result.append(neg(m))
1059                 else:
1060                     result.append(-m)
1061 
1062             return tuple(result)
1063 
1064         def key(term):
1065             _, ((re, im), monom, ncpart) = term
1066 
1067             monom = neg(monom_key(monom))
1068             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1069             coeff = ((bool(im), im), (re, im))
1070 
1071             return monom, ncpart, coeff
1072 
1073         return key, reverse
1074 
1075     def as_ordered_factors(self, order=None):
1076         """Return list of ordered factors (if Mul) else [self]."""
1077         return [self]
1078 
1079     def as_ordered_terms(self, order=None, data=False):
1080         """
1081         Transform an expression to an ordered list of terms.
1082 
1083         Examples
1084         ========
1085 
1086         >>> from sympy import sin, cos
1087         >>> from sympy.abc import x
1088 
1089         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1090         [sin(x)**2*cos(x), sin(x)**2, 1]
1091 
1092         """
1093 
1094         from .numbers import Number, NumberSymbol
1095 
1096         if order is None and self.is_Add:
1097             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1098             # first number positive and thhe second number nagative
1099             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1100             add_args = sorted(Add.make_args(self), key=key)
1101             if (len(add_args) == 2
1102                 and isinstance(add_args[0], (Number, NumberSymbol))
1103                 and isinstance(add_args[1], Mul)):
1104                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1105                 if (len(mul_args) == 2
1106                     and isinstance(mul_args[0], Number)
1107                     and add_args[0].is_positive
1108                     and mul_args[0].is_negative):
1109                     return add_args
1110 
1111         key, reverse = self._parse_order(order)
1112         terms, gens = self.as_terms()
1113 
1114         if not any(term.is_Order for term, _ in terms):
1115             ordered = sorted(terms, key=key, reverse=reverse)
1116         else:
1117             _terms, _order = [], []
1118 
1119             for term, repr in terms:
1120                 if not term.is_Order:
1121                     _terms.append((term, repr))
1122                 else:
1123                     _order.append((term, repr))
1124 
1125             ordered = sorted(_terms, key=key, reverse=True) \
1126                 + sorted(_order, key=key, reverse=True)
1127 
1128         if data:
1129             return ordered, gens
1130         else:
1131             return [term for term, _ in ordered]
1132 
1133     def as_terms(self):
1134         """Transform an expression to a list of terms. """
1135         from .add import Add
1136         from .mul import Mul
1137         from .exprtools import decompose_power
1138 
1139         gens, terms = set([]), []
1140 
1141         for term in Add.make_args(self):
1142             coeff, _term = term.as_coeff_Mul()
1143 
1144             coeff = complex(coeff)
1145             cpart, ncpart = {}, []
1146 
1147             if _term is not S.One:
1148                 for factor in Mul.make_args(_term):
1149                     if factor.is_number:
1150                         try:
1151                             coeff *= complex(factor)
1152                         except (TypeError, ValueError):
1153                             pass
1154                         else:
1155                             continue
1156 
1157                     if factor.is_commutative:
1158                         base, exp = decompose_power(factor)
1159 
1160                         cpart[base] = exp
1161                         gens.add(base)
1162                     else:
1163                         ncpart.append(factor)
1164 
1165             coeff = coeff.real, coeff.imag
1166             ncpart = tuple(ncpart)
1167 
1168             terms.append((term, (coeff, cpart, ncpart)))
1169 
1170         gens = sorted(gens, key=default_sort_key)
1171 
1172         k, indices = len(gens), {}
1173 
1174         for i, g in enumerate(gens):
1175             indices[g] = i
1176 
1177         result = []
1178 
1179         for term, (coeff, cpart, ncpart) in terms:
1180             monom = [0]*k
1181 
1182             for base, exp in cpart.items():
1183                 monom[indices[base]] = exp
1184 
1185             result.append((term, (coeff, tuple(monom), ncpart)))
1186 
1187         return result, gens
1188 
1189     def removeO(self):
1190         """Removes the additive O(..) symbol if there is one"""
1191         return self
1192 
1193     def getO(self):
1194         """Returns the additive O(..) symbol if there is one, else None."""
1195         return None
1196 
1197     def getn(self):
1198         """
1199         Returns the order of the expression.
1200 
1201         The order is determined either from the O(...) term. If there
1202         is no O(...) term, it returns None.
1203 
1204         Examples
1205         ========
1206 
1207         >>> from sympy import O
1208         >>> from sympy.abc import x
1209         >>> (1 + x + O(x**2)).getn()
1210         2
1211         >>> (1 + x).getn()
1212 
1213         """
1214         from sympy import Dummy, Symbol
1215         o = self.getO()
1216         if o is None:
1217             return None
1218         elif o.is_Order:
1219             o = o.expr
1220             if o is S.One:
1221                 return S.Zero
1222             if o.is_Symbol:
1223                 return S.One
1224             if o.is_Pow:
1225                 return o.args[1]
1226             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1227                 for oi in o.args:
1228                     if oi.is_Symbol:
1229                         return S.One
1230                     if oi.is_Pow:
1231                         syms = oi.atoms(Symbol)
1232                         if len(syms) == 1:
1233                             x = syms.pop()
1234                             oi = oi.subs(x, Dummy('x', positive=True))
1235                             if oi.base.is_Symbol and oi.exp.is_Rational:
1236                                 return abs(oi.exp)
1237 
1238         raise NotImplementedError('not sure of order of %s' % o)
1239 
1240     def count_ops(self, visual=None):
1241         """wrapper for count_ops that returns the operation count."""
1242         from .function import count_ops
1243         return count_ops(self, visual)
1244 
1245     def args_cnc(self, cset=False, warn=True, split_1=True):
1246         """Return [commutative factors, non-commutative factors] of self.
1247 
1248         self is treated as a Mul and the ordering of the factors is maintained.
1249         If ``cset`` is True the commutative factors will be returned in a set.
1250         If there were repeated factors (as may happen with an unevaluated Mul)
1251         then an error will be raised unless it is explicitly suppressed by
1252         setting ``warn`` to False.
1253 
1254         Note: -1 is always separated from a Number unless split_1 is False.
1255 
1256         >>> from sympy import symbols, oo
1257         >>> A, B = symbols('A B', commutative=0)
1258         >>> x, y = symbols('x y')
1259         >>> (-2*x*y).args_cnc()
1260         [[-1, 2, x, y], []]
1261         >>> (-2.5*x).args_cnc()
1262         [[-1, 2.5, x], []]
1263         >>> (-2*x*A*B*y).args_cnc()
1264         [[-1, 2, x, y], [A, B]]
1265         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1266         [[-2, x, y], [A, B]]
1267         >>> (-2*x*y).args_cnc(cset=True)
1268         [{-1, 2, x, y}, []]
1269 
1270         The arg is always treated as a Mul:
1271 
1272         >>> (-2 + x + A).args_cnc()
1273         [[], [x - 2 + A]]
1274         >>> (-oo).args_cnc() # -oo is a singleton
1275         [[-1, oo], []]
1276         """
1277 
1278         if self.is_Mul:
1279             args = list(self.args)
1280         else:
1281             args = [self]
1282         for i, mi in enumerate(args):
1283             if not mi.is_commutative:
1284                 c = args[:i]
1285                 nc = args[i:]
1286                 break
1287         else:
1288             c = args
1289             nc = []
1290 
1291         if c and split_1 and (
1292             c[0].is_Number and
1293             c[0].is_extended_negative and
1294                 c[0] is not S.NegativeOne):
1295             c[:1] = [S.NegativeOne, -c[0]]
1296 
1297         if cset:
1298             clen = len(c)
1299             c = set(c)
1300             if clen and warn and len(c) != clen:
1301                 raise ValueError('repeated commutative arguments: %s' %
1302                                  [ci for ci in c if list(self.args).count(ci) > 1])
1303         return [c, nc]
1304 
1305     def coeff(self, x, n=1, right=False):
1306         """
1307         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1308         is zero then all terms independent of ``x`` will be returned.
1309 
1310         When ``x`` is noncommutative, the coefficient to the left (default) or
1311         right of ``x`` can be returned. The keyword 'right' is ignored when
1312         ``x`` is commutative.
1313 
1314         See Also
1315         ========
1316 
1317         as_coefficient: separate the expression into a coefficient and factor
1318         as_coeff_Add: separate the additive constant from an expression
1319         as_coeff_Mul: separate the multiplicative constant from an expression
1320         as_independent: separate x-dependent terms/factors from others
1321         sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1322         sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used
1323 
1324         Examples
1325         ========
1326 
1327         >>> from sympy import symbols
1328         >>> from sympy.abc import x, y, z
1329 
1330         You can select terms that have an explicit negative in front of them:
1331 
1332         >>> (-x + 2*y).coeff(-1)
1333         x
1334         >>> (x - 2*y).coeff(-1)
1335         2*y
1336 
1337         You can select terms with no Rational coefficient:
1338 
1339         >>> (x + 2*y).coeff(1)
1340         x
1341         >>> (3 + 2*x + 4*x**2).coeff(1)
1342         0
1343 
1344         You can select terms independent of x by making n=0; in this case
1345         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1346         of None):
1347 
1348         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1349         3
1350         >>> eq = ((x + 1)**3).expand() + 1
1351         >>> eq
1352         x**3 + 3*x**2 + 3*x + 2
1353         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1354         [1, 3, 3, 2]
1355         >>> eq -= 2
1356         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1357         [1, 3, 3, 0]
1358 
1359         You can select terms that have a numerical term in front of them:
1360 
1361         >>> (-x - 2*y).coeff(2)
1362         -y
1363         >>> from sympy import sqrt
1364         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1365         x
1366 
1367         The matching is exact:
1368 
1369         >>> (3 + 2*x + 4*x**2).coeff(x)
1370         2
1371         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1372         4
1373         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1374         0
1375         >>> (z*(x + y)**2).coeff((x + y)**2)
1376         z
1377         >>> (z*(x + y)**2).coeff(x + y)
1378         0
1379 
1380         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1381         from the following:
1382 
1383         >>> (x + z*(x + x*y)).coeff(x)
1384         1
1385 
1386         If such factoring is desired, factor_terms can be used first:
1387 
1388         >>> from sympy import factor_terms
1389         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1390         z*(y + 1) + 1
1391 
1392         >>> n, m, o = symbols('n m o', commutative=False)
1393         >>> n.coeff(n)
1394         1
1395         >>> (3*n).coeff(n)
1396         3
1397         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1398         1 + m
1399         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1400         m
1401 
1402         If there is more than one possible coefficient 0 is returned:
1403 
1404         >>> (n*m + m*n).coeff(n)
1405         0
1406 
1407         If there is only one possible coefficient, it is returned:
1408 
1409         >>> (n*m + x*m*n).coeff(m*n)
1410         x
1411         >>> (n*m + x*m*n).coeff(m*n, right=1)
1412         1
1413 
1414         """
1415         x = sympify(x)
1416         if not isinstance(x, Basic):
1417             return S.Zero
1418 
1419         n = as_int(n)
1420 
1421         if not x:
1422             return S.Zero
1423 
1424         if x == self:
1425             if n == 1:
1426                 return S.One
1427             return S.Zero
1428 
1429         if x is S.One:
1430             co = [a for a in Add.make_args(self)
1431                   if a.as_coeff_Mul()[0] is S.One]
1432             if not co:
1433                 return S.Zero
1434             return Add(*co)
1435 
1436         if n == 0:
1437             if x.is_Add and self.is_Add:
1438                 c = self.coeff(x, right=right)
1439                 if not c:
1440                     return S.Zero
1441                 if not right:
1442                     return self - Add(*[a*x for a in Add.make_args(c)])
1443                 return self - Add(*[x*a for a in Add.make_args(c)])
1444             return self.as_independent(x, as_Add=True)[0]
1445 
1446         # continue with the full method, looking for this power of x:
1447         x = x**n
1448 
1449         def incommon(l1, l2):
1450             if not l1 or not l2:
1451                 return []
1452             n = min(len(l1), len(l2))
1453             for i in range(n):
1454                 if l1[i] != l2[i]:
1455                     return l1[:i]
1456             return l1[:]
1457 
1458         def find(l, sub, first=True):
1459             """ Find where list sub appears in list l. When ``first`` is True
1460             the first occurrence from the left is returned, else the last
1461             occurrence is returned. Return None if sub is not in l.
1462 
1463             >> l = range(5)*2
1464             >> find(l, [2, 3])
1465             2
1466             >> find(l, [2, 3], first=0)
1467             7
1468             >> find(l, [2, 4])
1469             None
1470 
1471             """
1472             if not sub or not l or len(sub) > len(l):
1473                 return None
1474             n = len(sub)
1475             if not first:
1476                 l.reverse()
1477                 sub.reverse()
1478             for i in range(0, len(l) - n + 1):
1479                 if all(l[i + j] == sub[j] for j in range(n)):
1480                     break
1481             else:
1482                 i = None
1483             if not first:
1484                 l.reverse()
1485                 sub.reverse()
1486             if i is not None and not first:
1487                 i = len(l) - (i + n)
1488             return i
1489 
1490         co = []
1491         args = Add.make_args(self)
1492         self_c = self.is_commutative
1493         x_c = x.is_commutative
1494         if self_c and not x_c:
1495             return S.Zero
1496 
1497         one_c = self_c or x_c
1498         xargs, nx = x.args_cnc(cset=True, warn=bool(not x_c))
1499         # find the parts that pass the commutative terms
1500         for a in args:
1501             margs, nc = a.args_cnc(cset=True, warn=bool(not self_c))
1502             if nc is None:
1503                 nc = []
1504             if len(xargs) > len(margs):
1505                 continue
1506             resid = margs.difference(xargs)
1507             if len(resid) + len(xargs) == len(margs):
1508                 if one_c:
1509                     co.append(Mul(*(list(resid) + nc)))
1510                 else:
1511                     co.append((resid, nc))
1512         if one_c:
1513             if co == []:
1514                 return S.Zero
1515             elif co:
1516                 return Add(*co)
1517         else:  # both nc
1518             # now check the non-comm parts
1519             if not co:
1520                 return S.Zero
1521             if all(n == co[0][1] for r, n in co):
1522                 ii = find(co[0][1], nx, right)
1523                 if ii is not None:
1524                     if not right:
1525                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1526                     else:
1527                         return Mul(*co[0][1][ii + len(nx):])
1528             beg = reduce(incommon, (n[1] for n in co))
1529             if beg:
1530                 ii = find(beg, nx, right)
1531                 if ii is not None:
1532                     if not right:
1533                         gcdc = co[0][0]
1534                         for i in range(1, len(co)):
1535                             gcdc = gcdc.intersection(co[i][0])
1536                             if not gcdc:
1537                                 break
1538                         return Mul(*(list(gcdc) + beg[:ii]))
1539                     else:
1540                         m = ii + len(nx)
1541                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1542             end = list(reversed(
1543                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1544             if end:
1545                 ii = find(end, nx, right)
1546                 if ii is not None:
1547                     if not right:
1548                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1549                     else:
1550                         return Mul(*end[ii + len(nx):])
1551             # look for single match
1552             hit = None
1553             for i, (r, n) in enumerate(co):
1554                 ii = find(n, nx, right)
1555                 if ii is not None:
1556                     if not hit:
1557                         hit = ii, r, n
1558                     else:
1559                         break
1560             else:
1561                 if hit:
1562                     ii, r, n = hit
1563                     if not right:
1564                         return Mul(*(list(r) + n[:ii]))
1565                     else:
1566                         return Mul(*n[ii + len(nx):])
1567 
1568             return S.Zero
1569 
1570     def as_expr(self, *gens):
1571         """
1572         Convert a polynomial to a SymPy expression.
1573 
1574         Examples
1575         ========
1576 
1577         >>> from sympy import sin
1578         >>> from sympy.abc import x, y
1579 
1580         >>> f = (x**2 + x*y).as_poly(x, y)
1581         >>> f.as_expr()
1582         x**2 + x*y
1583 
1584         >>> sin(x).as_expr()
1585         sin(x)
1586 
1587         """
1588         return self
1589 
1590     def as_coefficient(self, expr):
1591         """
1592         Extracts symbolic coefficient at the given expression. In
1593         other words, this functions separates 'self' into the product
1594         of 'expr' and 'expr'-free coefficient. If such separation
1595         is not possible it will return None.
1596 
1597         Examples
1598         ========
1599 
1600         >>> from sympy import E, pi, sin, I, Poly
1601         >>> from sympy.abc import x
1602 
1603         >>> E.as_coefficient(E)
1604         1
1605         >>> (2*E).as_coefficient(E)
1606         2
1607         >>> (2*sin(E)*E).as_coefficient(E)
1608 
1609         Two terms have E in them so a sum is returned. (If one were
1610         desiring the coefficient of the term exactly matching E then
1611         the constant from the returned expression could be selected.
1612         Or, for greater precision, a method of Poly can be used to
1613         indicate the desired term from which the coefficient is
1614         desired.)
1615 
1616         >>> (2*E + x*E).as_coefficient(E)
1617         x + 2
1618         >>> _.args[0]  # just want the exact match
1619         2
1620         >>> p = Poly(2*E + x*E); p
1621         Poly(x*E + 2*E, x, E, domain='ZZ')
1622         >>> p.coeff_monomial(E)
1623         2
1624         >>> p.nth(0, 1)
1625         2
1626 
1627         Since the following cannot be written as a product containing
1628         E as a factor, None is returned. (If the coefficient ``2*x`` is
1629         desired then the ``coeff`` method should be used.)
1630 
1631         >>> (2*E*x + x).as_coefficient(E)
1632         >>> (2*E*x + x).coeff(E)
1633         2*x
1634 
1635         >>> (E*(x + 1) + x).as_coefficient(E)
1636 
1637         >>> (2*pi*I).as_coefficient(pi*I)
1638         2
1639         >>> (2*I).as_coefficient(pi*I)
1640 
1641         See Also
1642         ========
1643 
1644         coeff: return sum of terms have a given factor
1645         as_coeff_Add: separate the additive constant from an expression
1646         as_coeff_Mul: separate the multiplicative constant from an expression
1647         as_independent: separate x-dependent terms/factors from others
1648         sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1649         sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used
1650 
1651 
1652         """
1653 
1654         r = self.extract_multiplicatively(expr)
1655         if r and not r.has(expr):
1656             return r
1657 
1658     def as_independent(self, *deps, **hint):
1659         """
1660         A mostly naive separation of a Mul or Add into arguments that are not
1661         are dependent on deps. To obtain as complete a separation of variables
1662         as possible, use a separation method first, e.g.:
1663 
1664         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1665         * .expand(mul=True) to change Add or Mul into Add
1666         * .expand(log=True) to change log expr into an Add
1667 
1668         The only non-naive thing that is done here is to respect noncommutative
1669         ordering of variables and to always return (0, 0) for `self` of zero
1670         regardless of hints.
1671 
1672         For nonzero `self`, the returned tuple (i, d) has the
1673         following interpretation:
1674 
1675         * i will has no variable that appears in deps
1676         * d will either have terms that contain variables that are in deps, or
1677           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1678         * if self is an Add then self = i + d
1679         * if self is a Mul then self = i*d
1680         * otherwise (self, S.One) or (S.One, self) is returned.
1681 
1682         To force the expression to be treated as an Add, use the hint as_Add=True
1683 
1684         Examples
1685         ========
1686 
1687         -- self is an Add
1688 
1689         >>> from sympy import sin, cos, exp
1690         >>> from sympy.abc import x, y, z
1691 
1692         >>> (x + x*y).as_independent(x)
1693         (0, x*y + x)
1694         >>> (x + x*y).as_independent(y)
1695         (x, x*y)
1696         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1697         (y + z, 2*x*sin(x) + x)
1698         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1699         (z, 2*x*sin(x) + x + y)
1700 
1701         -- self is a Mul
1702 
1703         >>> (x*sin(x)*cos(y)).as_independent(x)
1704         (cos(y), x*sin(x))
1705 
1706         non-commutative terms cannot always be separated out when self is a Mul
1707 
1708         >>> from sympy import symbols
1709         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1710         >>> (n1 + n1*n2).as_independent(n2)
1711         (n1, n1*n2)
1712         >>> (n2*n1 + n1*n2).as_independent(n2)
1713         (0, n1*n2 + n2*n1)
1714         >>> (n1*n2*n3).as_independent(n1)
1715         (1, n1*n2*n3)
1716         >>> (n1*n2*n3).as_independent(n2)
1717         (n1, n2*n3)
1718         >>> ((x-n1)*(x-y)).as_independent(x)
1719         (1, (x - y)*(x - n1))
1720 
1721         -- self is anything else:
1722 
1723         >>> (sin(x)).as_independent(x)
1724         (1, sin(x))
1725         >>> (sin(x)).as_independent(y)
1726         (sin(x), 1)
1727         >>> exp(x+y).as_independent(x)
1728         (1, exp(x + y))
1729 
1730         -- force self to be treated as an Add:
1731 
1732         >>> (3*x).as_independent(x, as_Add=True)
1733         (0, 3*x)
1734 
1735         -- force self to be treated as a Mul:
1736 
1737         >>> (3+x).as_independent(x, as_Add=False)
1738         (1, x + 3)
1739         >>> (-3+x).as_independent(x, as_Add=False)
1740         (1, x - 3)
1741 
1742         Note how the below differs from the above in making the
1743         constant on the dep term positive.
1744 
1745         >>> (y*(-3+x)).as_independent(x)
1746         (y, x - 3)
1747 
1748         -- use .as_independent() for true independence testing instead
1749            of .has(). The former considers only symbols in the free
1750            symbols while the latter considers all symbols
1751 
1752         >>> from sympy import Integral
1753         >>> I = Integral(x, (x, 1, 2))
1754         >>> I.has(x)
1755         True
1756         >>> x in I.free_symbols
1757         False
1758         >>> I.as_independent(x) == (I, 1)
1759         True
1760         >>> (I + x).as_independent(x) == (I, x)
1761         True
1762 
1763         Note: when trying to get independent terms, a separation method
1764         might need to be used first. In this case, it is important to keep
1765         track of what you send to this routine so you know how to interpret
1766         the returned values
1767 
1768         >>> from sympy import separatevars, log
1769         >>> separatevars(exp(x+y)).as_independent(x)
1770         (exp(y), exp(x))
1771         >>> (x + x*y).as_independent(y)
1772         (x, x*y)
1773         >>> separatevars(x + x*y).as_independent(y)
1774         (x, y + 1)
1775         >>> (x*(1 + y)).as_independent(y)
1776         (x, y + 1)
1777         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1778         (x, x*y)
1779         >>> a, b=symbols('a b', positive=True)
1780         >>> (log(a*b).expand(log=True)).as_independent(b)
1781         (log(a), log(b))
1782 
1783         See Also
1784         ========
1785         .separatevars(), .expand(log=True), sympy.core.add.Add.as_two_terms(),
1786         sympy.core.mul.Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1787         """
1788         from .symbol import Symbol
1789         from .add import _unevaluated_Add
1790         from .mul import _unevaluated_Mul
1791         from sympy.utilities.iterables import sift
1792 
1793         if self.is_zero:
1794             return S.Zero, S.Zero
1795 
1796         func = self.func
1797         if hint.get('as_Add', isinstance(self, Add) ):
1798             want = Add
1799         else:
1800             want = Mul
1801 
1802         # sift out deps into symbolic and other and ignore
1803         # all symbols but those that are in the free symbols
1804         sym = set()
1805         other = []
1806         for d in deps:
1807             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1808                 sym.add(d)
1809             else:
1810                 other.append(d)
1811 
1812         def has(e):
1813             """return the standard has() if there are no literal symbols, else
1814             check to see that symbol-deps are in the free symbols."""
1815             has_other = e.has(*other)
1816             if not sym:
1817                 return has_other
1818             return has_other or e.has(*(e.free_symbols & sym))
1819 
1820         if (want is not func or
1821                 func is not Add and func is not Mul):
1822             if has(self):
1823                 return (want.identity, self)
1824             else:
1825                 return (self, want.identity)
1826         else:
1827             if func is Add:
1828                 args = list(self.args)
1829             else:
1830                 args, nc = self.args_cnc()
1831 
1832         d = sift(args, lambda x: has(x))
1833         depend = d[True]
1834         indep = d[False]
1835         if func is Add:  # all terms were treated as commutative
1836             return (Add(*indep), _unevaluated_Add(*depend))
1837         else:  # handle noncommutative by stopping at first dependent term
1838             for i, n in enumerate(nc):
1839                 if has(n):
1840                     depend.extend(nc[i:])
1841                     break
1842                 indep.append(n)
1843             return Mul(*indep), (
1844                 Mul(*depend, evaluate=False) if nc else
1845                 _unevaluated_Mul(*depend))
1846 
1847     def as_real_imag(self, deep=True, **hints):
1848         """Performs complex expansion on 'self' and returns a tuple
1849            containing collected both real and imaginary parts. This
1850            method can't be confused with re() and im() functions,
1851            which does not perform complex expansion at evaluation.
1852 
1853            However it is possible to expand both re() and im()
1854            functions and get exactly the same results as with
1855            a single call to this function.
1856 
1857            >>> from sympy import symbols, I
1858 
1859            >>> x, y = symbols('x,y', real=True)
1860 
1861            >>> (x + y*I).as_real_imag()
1862            (x, y)
1863 
1864            >>> from sympy.abc import z, w
1865 
1866            >>> (z + w*I).as_real_imag()
1867            (re(z) - im(w), re(w) + im(z))
1868 
1869         """
1870         from sympy import im, re
1871         if hints.get('ignore') == self:
1872             return None
1873         else:
1874             return (re(self), im(self))
1875 
1876     def as_powers_dict(self):
1877         """Return self as a dictionary of factors with each factor being
1878         treated as a power. The keys are the bases of the factors and the
1879         values, the corresponding exponents. The resulting dictionary should
1880         be used with caution if the expression is a Mul and contains non-
1881         commutative factors since the order that they appeared will be lost in
1882         the dictionary.
1883 
1884         See Also
1885         ========
1886         as_ordered_factors: An alternative for noncommutative applications,
1887                             returning an ordered list of factors.
1888         args_cnc: Similar to as_ordered_factors, but guarantees separation
1889                   of commutative and noncommutative factors.
1890         """
1891         d = defaultdict(int)
1892         d.update(dict([self.as_base_exp()]))
1893         return d
1894 
1895     def as_coefficients_dict(self):
1896         """Return a dictionary mapping terms to their Rational coefficient.
1897         Since the dictionary is a defaultdict, inquiries about terms which
1898         were not present will return a coefficient of 0. If an expression is
1899         not an Add it is considered to have a single term.
1900 
1901         Examples
1902         ========
1903 
1904         >>> from sympy.abc import a, x
1905         >>> (3*x + a*x + 4).as_coefficients_dict()
1906         {1: 4, x: 3, a*x: 1}
1907         >>> _[a]
1908         0
1909         >>> (3*a*x).as_coefficients_dict()
1910         {a*x: 3}
1911 
1912         """
1913         c, m = self.as_coeff_Mul()
1914         if not c.is_Rational:
1915             c = S.One
1916             m = self
1917         d = defaultdict(int)
1918         d.update({m: c})
1919         return d
1920 
1921     def as_base_exp(self):
1922         # a -> b ** e
1923         return self, S.One
1924 
1925     def as_coeff_mul(self, *deps, **kwargs):
1926         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1927 
1928         c should be a Rational multiplied by any factors of the Mul that are
1929         independent of deps.
1930 
1931         args should be a tuple of all other factors of m; args is empty
1932         if self is a Number or if self is independent of deps (when given).
1933 
1934         This should be used when you don't know if self is a Mul or not but
1935         you want to treat self as a Mul or if you want to process the
1936         individual arguments of the tail of self as a Mul.
1937 
1938         - if you know self is a Mul and want only the head, use self.args[0];
1939         - if you don't want to process the arguments of the tail but need the
1940           tail then use self.as_two_terms() which gives the head and tail;
1941         - if you want to split self into an independent and dependent parts
1942           use ``self.as_independent(*deps)``
1943 
1944         >>> from sympy import S
1945         >>> from sympy.abc import x, y
1946         >>> (S(3)).as_coeff_mul()
1947         (3, ())
1948         >>> (3*x*y).as_coeff_mul()
1949         (3, (x, y))
1950         >>> (3*x*y).as_coeff_mul(x)
1951         (3*y, (x,))
1952         >>> (3*y).as_coeff_mul(x)
1953         (3*y, ())
1954         """
1955         if deps:
1956             if not self.has(*deps):
1957                 return self, tuple()
1958         return S.One, (self,)
1959 
1960     def as_coeff_add(self, *deps):
1961         """Return the tuple (c, args) where self is written as an Add, ``a``.
1962 
1963         c should be a Rational added to any terms of the Add that are
1964         independent of deps.
1965 
1966         args should be a tuple of all other terms of ``a``; args is empty
1967         if self is a Number or if self is independent of deps (when given).
1968 
1969         This should be used when you don't know if self is an Add or not but
1970         you want to treat self as an Add or if you want to process the
1971         individual arguments of the tail of self as an Add.
1972 
1973         - if you know self is an Add and want only the head, use self.args[0];
1974         - if you don't want to process the arguments of the tail but need the
1975           tail then use self.as_two_terms() which gives the head and tail.
1976         - if you want to split self into an independent and dependent parts
1977           use ``self.as_independent(*deps)``
1978 
1979         >>> from sympy import S
1980         >>> from sympy.abc import x, y
1981         >>> (S(3)).as_coeff_add()
1982         (3, ())
1983         >>> (3 + x).as_coeff_add()
1984         (3, (x,))
1985         >>> (3 + x + y).as_coeff_add(x)
1986         (y + 3, (x,))
1987         >>> (3 + y).as_coeff_add(x)
1988         (y + 3, ())
1989 
1990         """
1991         if deps:
1992             if not self.has(*deps):
1993                 return self, tuple()
1994         return S.Zero, (self,)
1995 
1996     def primitive(self):
1997         """Return the positive Rational that can be extracted non-recursively
1998         from every term of self (i.e., self is treated like an Add). This is
1999         like the as_coeff_Mul() method but primitive always extracts a positive
2000         Rational (never a negative or a Float).
2001 
2002         Examples
2003         ========
2004 
2005         >>> from sympy.abc import x
2006         >>> (3*(x + 1)**2).primitive()
2007         (3, (x + 1)**2)
2008         >>> a = (6*x + 2); a.primitive()
2009         (2, 3*x + 1)
2010         >>> b = (x/2 + 3); b.primitive()
2011         (1/2, x + 6)
2012         >>> (a*b).primitive() == (1, a*b)
2013         True
2014         """
2015         if not self:
2016             return S.One, S.Zero
2017         c, r = self.as_coeff_Mul(rational=True)
2018         if c.is_negative:
2019             c, r = -c, -r
2020         return c, r
2021 
2022     def as_content_primitive(self, radical=False, clear=True):
2023         """This method should recursively remove a Rational from all arguments
2024         and return that (content) and the new self (primitive). The content
2025         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2026         The primitive need not be in canonical form and should try to preserve
2027         the underlying structure if possible (i.e. expand_mul should not be
2028         applied to self).
2029 
2030         Examples
2031         ========
2032 
2033         >>> from sympy import sqrt
2034         >>> from sympy.abc import x, y, z
2035 
2036         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2037 
2038         The as_content_primitive function is recursive and retains structure:
2039 
2040         >>> eq.as_content_primitive()
2041         (2, x + 3*y*(y + 1) + 1)
2042 
2043         Integer powers will have Rationals extracted from the base:
2044 
2045         >>> ((2 + 6*x)**2).as_content_primitive()
2046         (4, (3*x + 1)**2)
2047         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2048         (1, (2*(3*x + 1))**(2*y))
2049 
2050         Terms may end up joining once their as_content_primitives are added:
2051 
2052         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2053         (11, x*(y + 1))
2054         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2055         (9, x*(y + 1))
2056         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2057         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2058         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2059         (121, x**2*(y + 1)**2)
2060         >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()
2061         (1, 4.84*x**2*(y + 1)**2)
2062 
2063         Radical content can also be factored out of the primitive:
2064 
2065         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2066         (2, sqrt(2)*(1 + 2*sqrt(5)))
2067 
2068         If clear=False (default is True) then content will not be removed
2069         from an Add if it can be distributed to leave one or more
2070         terms with integer coefficients.
2071 
2072         >>> (x/2 + y).as_content_primitive()
2073         (1/2, x + 2*y)
2074         >>> (x/2 + y).as_content_primitive(clear=False)
2075         (1, x/2 + y)
2076         """
2077         return S.One, self
2078 
2079     def as_numer_denom(self):
2080         """ expression -> a/b -> a, b
2081 
2082         This is just a stub that should be defined by
2083         an object's class methods to get anything else.
2084 
2085         See Also
2086         ========
2087         normal: return a/b instead of a, b
2088         """
2089 
2090         return self, S.One
2091 
2092     def normal(self):
2093         from .mul import _unevaluated_Mul
2094         n, d = self.as_numer_denom()
2095         if d is S.One:
2096             return n
2097         if d.is_Number:
2098             return _unevaluated_Mul(n, 1/d)
2099         else:
2100             return n/d
2101 
2102     def extract_multiplicatively(self, c):
2103         """Return None if it's not possible to make self in the form
2104            c * something in a nice way, i.e. preserving the properties
2105            of arguments of self.
2106 
2107            Examples
2108            ========
2109 
2110            >>> from sympy import symbols, Rational
2111 
2112            >>> x, y = symbols('x,y', real=True)
2113 
2114            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2115            x*y**2
2116 
2117            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2118 
2119            >>> (2*x).extract_multiplicatively(2)
2120            x
2121 
2122            >>> (2*x).extract_multiplicatively(3)
2123 
2124            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2125            x/6
2126 
2127         """
2128         from .add import _unevaluated_Add
2129         c = sympify(c)
2130         if self is S.NaN:
2131             return None
2132         if c is S.One:
2133             return self
2134         elif c == self:
2135             return S.One
2136 
2137         if c.is_Add:
2138             cc, pc = c.primitive()
2139             if cc is not S.One:
2140                 c = Mul(cc, pc, evaluate=False)
2141 
2142         if c.is_Mul:
2143             a, b = c.as_two_terms()
2144             x = self.extract_multiplicatively(a)
2145             if x is not None:
2146                 return x.extract_multiplicatively(b)
2147             else:
2148                 return x
2149 
2150         quotient = self / c
2151         if self.is_Number:
2152             if self is S.Infinity:
2153                 if c.is_positive:
2154                     return S.Infinity
2155             elif self is S.NegativeInfinity:
2156                 if c.is_negative:
2157                     return S.Infinity
2158                 elif c.is_positive:
2159                     return S.NegativeInfinity
2160             elif self is S.ComplexInfinity:
2161                 if not c.is_zero:
2162                     return S.ComplexInfinity
2163             elif self.is_Integer:
2164                 if not quotient.is_Integer:
2165                     return None
2166                 elif self.is_positive and quotient.is_negative:
2167                     return None
2168                 else:
2169                     return quotient
2170             elif self.is_Rational:
2171                 if not quotient.is_Rational:
2172                     return None
2173                 elif self.is_positive and quotient.is_negative:
2174                     return None
2175                 else:
2176                     return quotient
2177             elif self.is_Float:
2178                 if not quotient.is_Float:
2179                     return None
2180                 elif self.is_positive and quotient.is_negative:
2181                     return None
2182                 else:
2183                     return quotient
2184         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2185             if quotient.is_Mul and len(quotient.args) == 2:
2186                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2187                     return quotient
2188             elif quotient.is_Integer and c.is_Number:
2189                 return quotient
2190         elif self.is_Add:
2191             cs, ps = self.primitive()
2192             # assert cs >= 1
2193             if c.is_Number and c is not S.NegativeOne:
2194                 # assert c != 1 (handled at top)
2195                 if cs is not S.One:
2196                     if c.is_negative:
2197                         xc = -(cs.extract_multiplicatively(-c))
2198                     else:
2199                         xc = cs.extract_multiplicatively(c)
2200                     if xc is not None:
2201                         return xc*ps  # rely on 2-arg Mul to restore Add
2202                 return  # |c| != 1 can only be extracted from cs
2203             if c == ps:
2204                 return cs
2205             # check args of ps
2206             newargs = []
2207             for arg in ps.args:
2208                 newarg = arg.extract_multiplicatively(c)
2209                 if newarg is None:
2210                     return  # all or nothing
2211                 newargs.append(newarg)
2212             if cs is not S.One:
2213                 args = [cs*t for t in newargs]
2214                 # args may be in different order
2215                 return _unevaluated_Add(*args)
2216             else:
2217                 return Add._from_args(newargs)
2218         elif self.is_Mul:
2219             args = list(self.args)
2220             for i, arg in enumerate(args):
2221                 newarg = arg.extract_multiplicatively(c)
2222                 if newarg is not None:
2223                     args[i] = newarg
2224                     return Mul(*args)
2225         elif self.is_Pow:
2226             if c.is_Pow and c.base == self.base:
2227                 new_exp = self.exp.extract_additively(c.exp)
2228                 if new_exp is not None:
2229                     return self.base ** (new_exp)
2230             elif c == self.base:
2231                 new_exp = self.exp.extract_additively(1)
2232                 if new_exp is not None:
2233                     return self.base ** (new_exp)
2234 
2235     def extract_additively(self, c):
2236         """Return self - c if it's possible to subtract c from self and
2237         make all matching coefficients move towards zero, else return None.
2238 
2239         Examples
2240         ========
2241 
2242         >>> from sympy.abc import x, y
2243         >>> e = 2*x + 3
2244         >>> e.extract_additively(x + 1)
2245         x + 2
2246         >>> e.extract_additively(3*x)
2247         >>> e.extract_additively(4)
2248         >>> (y*(x + 1)).extract_additively(x + 1)
2249         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2250         (x + 1)*(x + 2*y) + 3
2251 
2252         Sometimes auto-expansion will return a less simplified result
2253         than desired; gcd_terms might be used in such cases:
2254 
2255         >>> from sympy import gcd_terms
2256         >>> (4*x*(y + 1) + y).extract_additively(x)
2257         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2258         >>> gcd_terms(_)
2259         x*(4*y + 3) + y
2260 
2261         See Also
2262         ========
2263         extract_multiplicatively
2264         coeff
2265         as_coefficient
2266 
2267         """
2268 
2269         c = sympify(c)
2270         if self is S.NaN:
2271             return None
2272         if c.is_zero:
2273             return self
2274         elif c == self:
2275             return S.Zero
2276         elif self == S.Zero:
2277             return None
2278 
2279         if self.is_Number:
2280             if not c.is_Number:
2281                 return None
2282             co = self
2283             diff = co - c
2284             # XXX should we match types? i.e should 3 - .1 succeed?
2285             if (co > 0 and diff > 0 and diff < co or
2286                     co < 0 and diff < 0 and diff > co):
2287                 return diff
2288             return None
2289 
2290         if c.is_Number:
2291             co, t = self.as_coeff_Add()
2292             xa = co.extract_additively(c)
2293             if xa is None:
2294                 return None
2295             return xa + t
2296 
2297         # handle the args[0].is_Number case separately
2298         # since we will have trouble looking for the coeff of
2299         # a number.
2300         if c.is_Add and c.args[0].is_Number:
2301             # whole term as a term factor
2302             co = self.coeff(c)
2303             xa0 = (co.extract_additively(1) or 0)*c
2304             if xa0:
2305                 diff = self - co*c
2306                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2307             # term-wise
2308             h, t = c.as_coeff_Add()
2309             sh, st = self.as_coeff_Add()
2310             xa = sh.extract_additively(h)
2311             if xa is None:
2312                 return None
2313             xa2 = st.extract_additively(t)
2314             if xa2 is None:
2315                 return None
2316             return xa + xa2
2317 
2318         # whole term as a term factor
2319         co = self.coeff(c)
2320         xa0 = (co.extract_additively(1) or 0)*c
2321         if xa0:
2322             diff = self - co*c
2323             return (xa0 + (diff.extract_additively(c) or diff)) or None
2324         # term-wise
2325         coeffs = []
2326         for a in Add.make_args(c):
2327             ac, at = a.as_coeff_Mul()
2328             co = self.coeff(at)
2329             if not co:
2330                 return None
2331             coc, cot = co.as_coeff_Add()
2332             xa = coc.extract_additively(ac)
2333             if xa is None:
2334                 return None
2335             self -= co*at
2336             coeffs.append((cot + xa)*at)
2337         coeffs.append(self)
2338         return Add(*coeffs)
2339 
2340     @property
2341     def expr_free_symbols(self):
2342         """
2343         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2344 
2345         Examples
2346         ========
2347 
2348         >>> from sympy.abc import x, y
2349         >>> (x + y).expr_free_symbols
2350         {x, y}
2351 
2352         If the expression is contained in a non-expression object, don't return
2353         the free symbols. Compare:
2354 
2355         >>> from sympy import Tuple
2356         >>> t = Tuple(x + y)
2357         >>> t.expr_free_symbols
2358         set()
2359         >>> t.free_symbols
2360         {x, y}
2361         """
2362         return {j for i in self.args for j in i.expr_free_symbols}
2363 
2364     def could_extract_minus_sign(self):
2365         """Return True if self is not in a canonical form with respect
2366         to its sign.
2367 
2368         For most expressions, e, there will be a difference in e and -e.
2369         When there is, True will be returned for one and False for the
2370         other; False will be returned if there is no difference.
2371 
2372         Examples
2373         ========
2374 
2375         >>> from sympy.abc import x, y
2376         >>> e = x - y
2377         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2378         {False, True}
2379 
2380         """
2381         negative_self = -self
2382         if self == negative_self:
2383             return False  # e.g. zoo*x == -zoo*x
2384         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2385         negative_self_has_minus = (
2386             (negative_self).extract_multiplicatively(-1) is not None)
2387         if self_has_minus != negative_self_has_minus:
2388             return self_has_minus
2389         else:
2390             if self.is_Add:
2391                 # We choose the one with less arguments with minus signs
2392                 all_args = len(self.args)
2393                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2394                 positive_args = all_args - negative_args
2395                 if positive_args > negative_args:
2396                     return False
2397                 elif positive_args < negative_args:
2398                     return True
2399             elif self.is_Mul:
2400                 # We choose the one with an odd number of minus signs
2401                 num, den = self.as_numer_denom()
2402                 args = Mul.make_args(num) + Mul.make_args(den)
2403                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2404                 negative_args = list(filter(None, arg_signs))
2405                 return len(negative_args) % 2 == 1
2406 
2407             # As a last resort, we choose the one with greater value of .sort_key()
2408             return bool(self.sort_key() < negative_self.sort_key())
2409 
2410     def extract_branch_factor(self, allow_half=False):
2411         """
2412         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2413         Return (z, n).
2414 
2415         >>> from sympy import exp_polar, I, pi
2416         >>> from sympy.abc import x, y
2417         >>> exp_polar(I*pi).extract_branch_factor()
2418         (exp_polar(I*pi), 0)
2419         >>> exp_polar(2*I*pi).extract_branch_factor()
2420         (1, 1)
2421         >>> exp_polar(-pi*I).extract_branch_factor()
2422         (exp_polar(I*pi), -1)
2423         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2424         (exp_polar(x + I*pi), 1)
2425         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2426         (y*exp_polar(2*pi*x), -1)
2427         >>> exp_polar(-I*pi/2).extract_branch_factor()
2428         (exp_polar(-I*pi/2), 0)
2429 
2430         If allow_half is True, also extract exp_polar(I*pi):
2431 
2432         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2433         (1, 1/2)
2434         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2435         (1, 1)
2436         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2437         (1, 3/2)
2438         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2439         (1, -1/2)
2440         """
2441         from sympy import exp_polar, pi, I, ceiling, Add
2442         n = S.Zero
2443         res = S.One
2444         args = Mul.make_args(self)
2445         exps = []
2446         for arg in args:
2447             if isinstance(arg, exp_polar):
2448                 exps += [arg.exp]
2449             else:
2450                 res *= arg
2451         piimult = S.Zero
2452         extras = []
2453         while exps:
2454             exp = exps.pop()
2455             if exp.is_Add:
2456                 exps += exp.args
2457                 continue
2458             if exp.is_Mul:
2459                 coeff = exp.as_coefficient(pi*I)
2460                 if coeff is not None:
2461                     piimult += coeff
2462                     continue
2463             extras += [exp]
2464         if piimult.is_number:
2465             coeff = piimult
2466             tail = ()
2467         else:
2468             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2469         # round down to nearest multiple of 2
2470         branchfact = ceiling(coeff/2 - S.Half)*2
2471         n += branchfact/2
2472         c = coeff - branchfact
2473         if allow_half:
2474             nc = c.extract_additively(1)
2475             if nc is not None:
2476                 n += S.Half
2477                 c = nc
2478         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2479         if newexp != 0:
2480             res *= exp_polar(newexp)
2481         return res, n
2482 
2483     def _eval_is_polynomial(self, syms):
2484         if self.free_symbols.intersection(syms) == set([]):
2485             return True
2486         return False
2487 
2488     def is_polynomial(self, *syms):
2489         r"""
2490         Return True if self is a polynomial in syms and False otherwise.
2491 
2492         This checks if self is an exact polynomial in syms.  This function
2493         returns False for expressions that are "polynomials" with symbolic
2494         exponents.  Thus, you should be able to apply polynomial algorithms to
2495         expressions for which this returns True, and Poly(expr, \*syms) should
2496         work if and only if expr.is_polynomial(\*syms) returns True. The
2497         polynomial does not have to be in expanded form.  If no symbols are
2498         given, all free symbols in the expression will be used.
2499 
2500         This is not part of the assumptions system.  You cannot do
2501         Symbol('z', polynomial=True).
2502 
2503         Examples
2504         ========
2505 
2506         >>> from sympy import Symbol
2507         >>> x = Symbol('x')
2508         >>> ((x**2 + 1)**4).is_polynomial(x)
2509         True
2510         >>> ((x**2 + 1)**4).is_polynomial()
2511         True
2512         >>> (2**x + 1).is_polynomial(x)
2513         False
2514 
2515 
2516         >>> n = Symbol('n', nonnegative=True, integer=True)
2517         >>> (x**n + 1).is_polynomial(x)
2518         False
2519 
2520         This function does not attempt any nontrivial simplifications that may
2521         result in an expression that does not appear to be a polynomial to
2522         become one.
2523 
2524         >>> from sympy import sqrt, factor, cancel
2525         >>> y = Symbol('y', positive=True)
2526         >>> a = sqrt(y**2 + 2*y + 1)
2527         >>> a.is_polynomial(y)
2528         False
2529         >>> factor(a)
2530         y + 1
2531         >>> factor(a).is_polynomial(y)
2532         True
2533 
2534         >>> b = (y**2 + 2*y + 1)/(y + 1)
2535         >>> b.is_polynomial(y)
2536         False
2537         >>> cancel(b)
2538         y + 1
2539         >>> cancel(b).is_polynomial(y)
2540         True
2541 
2542         See also .is_rational_function()
2543 
2544         """
2545         if syms:
2546             syms = set(map(sympify, syms))
2547         else:
2548             syms = self.free_symbols
2549 
2550         if syms.intersection(self.free_symbols) == set([]):
2551             # constant polynomial
2552             return True
2553         else:
2554             return self._eval_is_polynomial(syms)
2555 
2556     def _eval_is_rational_function(self, syms):
2557         if self.free_symbols.intersection(syms) == set([]):
2558             return True
2559         return False
2560 
2561     def is_rational_function(self, *syms):
2562         """
2563         Test whether function is a ratio of two polynomials in the given
2564         symbols, syms. When syms is not given, all free symbols will be used.
2565         The rational function does not have to be in expanded or in any kind of
2566         canonical form.
2567 
2568         This function returns False for expressions that are "rational
2569         functions" with symbolic exponents.  Thus, you should be able to call
2570         .as_numer_denom() and apply polynomial algorithms to the result for
2571         expressions for which this returns True.
2572 
2573         This is not part of the assumptions system.  You cannot do
2574         Symbol('z', rational_function=True).
2575 
2576         Examples
2577         ========
2578 
2579         >>> from sympy import Symbol, sin
2580         >>> from sympy.abc import x, y
2581 
2582         >>> (x/y).is_rational_function()
2583         True
2584 
2585         >>> (x**2).is_rational_function()
2586         True
2587 
2588         >>> (x/sin(y)).is_rational_function(y)
2589         False
2590 
2591         >>> n = Symbol('n', integer=True)
2592         >>> (x**n + 1).is_rational_function(x)
2593         False
2594 
2595         This function does not attempt any nontrivial simplifications that may
2596         result in an expression that does not appear to be a rational function
2597         to become one.
2598 
2599         >>> from sympy import sqrt, factor
2600         >>> y = Symbol('y', positive=True)
2601         >>> a = sqrt(y**2 + 2*y + 1)/y
2602         >>> a.is_rational_function(y)
2603         False
2604         >>> factor(a)
2605         (y + 1)/y
2606         >>> factor(a).is_rational_function(y)
2607         True
2608 
2609         See also is_algebraic_expr().
2610 
2611         """
2612         if self in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2613             return False
2614 
2615         if syms:
2616             syms = set(map(sympify, syms))
2617         else:
2618             syms = self.free_symbols
2619 
2620         if syms.intersection(self.free_symbols) == set([]):
2621             # constant rational function
2622             return True
2623         else:
2624             return self._eval_is_rational_function(syms)
2625 
2626     def _eval_is_algebraic_expr(self, syms):
2627         if self.free_symbols.intersection(syms) == set([]):
2628             return True
2629         return False
2630 
2631     def is_algebraic_expr(self, *syms):
2632         """
2633         This tests whether a given expression is algebraic or not, in the
2634         given symbols, syms. When syms is not given, all free symbols
2635         will be used. The rational function does not have to be in expanded
2636         or in any kind of canonical form.
2637 
2638         This function returns False for expressions that are "algebraic
2639         expressions" with symbolic exponents. This is a simple extension to the
2640         is_rational_function, including rational exponentiation.
2641 
2642         Examples
2643         ========
2644 
2645         >>> from sympy import Symbol, sqrt
2646         >>> x = Symbol('x', real=True)
2647         >>> sqrt(1 + x).is_rational_function()
2648         False
2649         >>> sqrt(1 + x).is_algebraic_expr()
2650         True
2651 
2652         This function does not attempt any nontrivial simplifications that may
2653         result in an expression that does not appear to be an algebraic
2654         expression to become one.
2655 
2656         >>> from sympy import exp, factor
2657         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2658         >>> a.is_algebraic_expr(x)
2659         False
2660         >>> factor(a).is_algebraic_expr()
2661         True
2662 
2663         See Also
2664         ========
2665         is_rational_function()
2666 
2667         References
2668         ==========
2669 
2670         - https://en.wikipedia.org/wiki/Algebraic_expression
2671 
2672         """
2673         if syms:
2674             syms = set(map(sympify, syms))
2675         else:
2676             syms = self.free_symbols
2677 
2678         if syms.intersection(self.free_symbols) == set([]):
2679             # constant algebraic expression
2680             return True
2681         else:
2682             return self._eval_is_algebraic_expr(syms)
2683 
2684     ###################################################################################
2685     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2686     ###################################################################################
2687 
2688     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2689         """
2690         Series expansion of "self" around ``x = x0`` yielding either terms of
2691         the series one by one (the lazy series given when n=None), else
2692         all the terms at once when n != None.
2693 
2694         Returns the series expansion of "self" around the point ``x = x0``
2695         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2696 
2697         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2698         be supplied, otherwise an error will be raised.
2699 
2700         Parameters
2701         ==========
2702 
2703         expr : Expression
2704                The expression whose series is to be expanded.
2705 
2706         x : Symbol
2707             It is the variable of the expression to be calculated.
2708 
2709         x0 : Value
2710              The value around which ``x`` is calculated. Can be any value
2711              from ``-oo`` to ``oo``.
2712 
2713         n : Value
2714             The number of terms upto which the series is to be expanded.
2715 
2716         dir : String, optional
2717               The series-expansion can be bi-directional. If ``dir="+"``,
2718               then (x->x0+). If ``dir="-", then (x->x0-). For infinite
2719               ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined
2720               from the direction of the infinity (i.e., ``dir="-"`` for
2721               ``oo``).
2722 
2723         logx : optional
2724                It is used to replace any log(x) in the returned series with a
2725                symbolic value rather than evaluating the actual value.
2726 
2727         Examples
2728         ========
2729 
2730         >>> from sympy import cos, exp, tan, oo, series
2731         >>> from sympy.abc import x, y
2732         >>> cos(x).series()
2733         1 - x**2/2 + x**4/24 + O(x**6)
2734         >>> cos(x).series(n=4)
2735         1 - x**2/2 + O(x**4)
2736         >>> cos(x).series(x, x0=1, n=2)
2737         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2738         >>> e = cos(x + exp(y))
2739         >>> e.series(y, n=2)
2740         cos(x + 1) - y*sin(x + 1) + O(y**2)
2741         >>> e.series(x, n=2)
2742         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2743 
2744         If ``n=None`` then a generator of the series terms will be returned.
2745 
2746         >>> term=cos(x).series(n=None)
2747         >>> [next(term) for i in range(2)]
2748         [1, -x**2/2]
2749 
2750         For ``dir=+`` (default) the series is calculated from the right and
2751         for ``dir=-`` the series from the left. For smooth functions this
2752         flag will not alter the results.
2753 
2754         >>> abs(x).series(dir="+")
2755         x
2756         >>> abs(x).series(dir="-")
2757         -x
2758         >>> f = tan(x)
2759         >>> f.series(x, 2, 6, "+")
2760         tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +
2761         (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +
2762         5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +
2763         2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))
2764 
2765         >>> f.series(x, 2, 3, "-")
2766         tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))
2767         + O((x - 2)**3, (x, 2))
2768 
2769         Returns
2770         =======
2771 
2772         Expr : Expression
2773             Series expansion of the expression about x0
2774 
2775         Raises
2776         ======
2777 
2778         TypeError
2779             If "n" and "x0" are infinity objects
2780 
2781         PoleError
2782             If "x0" is an infinity object
2783 
2784         """
2785         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2786         if x is None:
2787             syms = self.free_symbols
2788             if not syms:
2789                 return self
2790             elif len(syms) > 1:
2791                 raise ValueError('x must be given for multivariate functions.')
2792             x = syms.pop()
2793 
2794         if isinstance(x, Symbol):
2795             dep = x in self.free_symbols
2796         else:
2797             d = Dummy()
2798             dep = d in self.xreplace({x: d}).free_symbols
2799         if not dep:
2800             if n is None:
2801                 return (s for s in [self])
2802             else:
2803                 return self
2804 
2805         if len(dir) != 1 or dir not in '+-':
2806             raise ValueError("Dir must be '+' or '-'")
2807 
2808         if x0 in [S.Infinity, S.NegativeInfinity]:
2809             sgn = 1 if x0 is S.Infinity else -1
2810             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2811             if n is None:
2812                 return (si.subs(x, sgn/x) for si in s)
2813             return s.subs(x, sgn/x)
2814 
2815         # use rep to shift origin to x0 and change sign (if dir is negative)
2816         # and undo the process with rep2
2817         if x0 or dir == '-':
2818             if dir == '-':
2819                 rep = -x + x0
2820                 rep2 = -x
2821                 rep2b = x0
2822             else:
2823                 rep = x + x0
2824                 rep2 = x
2825                 rep2b = -x0
2826             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2827             if n is None:  # lseries...
2828                 return (si.subs(x, rep2 + rep2b) for si in s)
2829             return s.subs(x, rep2 + rep2b)
2830 
2831         # from here on it's x0=0 and dir='+' handling
2832 
2833         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2834             # replace x with an x that has a positive assumption
2835             xpos = Dummy('x', positive=True, finite=True)
2836             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2837             if n is None:
2838                 return (s.subs(xpos, x) for s in rv)
2839             else:
2840                 return rv.subs(xpos, x)
2841 
2842         if n is not None:  # nseries handling
2843             s1 = self._eval_nseries(x, n=n, logx=logx)
2844             o = s1.getO() or S.Zero
2845             if o:
2846                 # make sure the requested order is returned
2847                 ngot = o.getn()
2848                 if ngot > n:
2849                     # leave o in its current form (e.g. with x*log(x)) so
2850                     # it eats terms properly, then replace it below
2851                     if n != 0:
2852                         s1 += o.subs(x, x**Rational(n, ngot))
2853                     else:
2854                         s1 += Order(1, x)
2855                 elif ngot < n:
2856                     # increase the requested number of terms to get the desired
2857                     # number keep increasing (up to 9) until the received order
2858                     # is different than the original order and then predict how
2859                     # many additional terms are needed
2860                     for more in range(1, 9):
2861                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2862                         newn = s1.getn()
2863                         if newn != ngot:
2864                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2865                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2866                             while s1.getn() < n:
2867                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2868                                 ndo += 1
2869                             break
2870                     else:
2871                         raise ValueError('Could not calculate %s terms for %s'
2872                                          % (str(n), self))
2873                     s1 += Order(x**n, x)
2874                 o = s1.getO()
2875                 s1 = s1.removeO()
2876             else:
2877                 o = Order(x**n, x)
2878                 s1done = s1.doit()
2879                 if (s1done + o).removeO() == s1done:
2880                     o = S.Zero
2881 
2882             try:
2883                 return collect(s1, x) + o
2884             except NotImplementedError:
2885                 return s1 + o
2886 
2887         else:  # lseries handling
2888             def yield_lseries(s):
2889                 """Return terms of lseries one at a time."""
2890                 for si in s:
2891                     if not si.is_Add:
2892                         yield si
2893                         continue
2894                     # yield terms 1 at a time if possible
2895                     # by increasing order until all the
2896                     # terms have been returned
2897                     yielded = 0
2898                     o = Order(si, x)*x
2899                     ndid = 0
2900                     ndo = len(si.args)
2901                     while 1:
2902                         do = (si - yielded + o).removeO()
2903                         o *= x
2904                         if not do or do.is_Order:
2905                             continue
2906                         if do.is_Add:
2907                             ndid += len(do.args)
2908                         else:
2909                             ndid += 1
2910                         yield do
2911                         if ndid == ndo:
2912                             break
2913                         yielded += do
2914 
2915             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2916 
2917     def aseries(self, x=None, n=6, bound=0, hir=False):
2918         """Asymptotic Series expansion of self.
2919         This is equivalent to ``self.series(x, oo, n)``.
2920 
2921         Parameters
2922         ==========
2923 
2924         self : Expression
2925                The expression whose series is to be expanded.
2926 
2927         x : Symbol
2928             It is the variable of the expression to be calculated.
2929 
2930         n : Value
2931             The number of terms upto which the series is to be expanded.
2932 
2933         hir : Boolean
2934               Set this parameter to be True to produce hierarchical series.
2935               It stops the recursion at an early level and may provide nicer
2936               and more useful results.
2937 
2938         bound : Value, Integer
2939                 Use the ``bound`` parameter to give limit on rewriting
2940                 coefficients in its normalised form.
2941 
2942         Examples
2943         ========
2944 
2945         >>> from sympy import sin, exp
2946         >>> from sympy.abc import x, y
2947 
2948         >>> e = sin(1/x + exp(-x)) - sin(1/x)
2949 
2950         >>> e.aseries(x)
2951         (1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))*exp(-x)
2952 
2953         >>> e.aseries(x, n=3, hir=True)
2954         -exp(-2*x)*sin(1/x)/2 + exp(-x)*cos(1/x) + O(exp(-3*x), (x, oo))
2955 
2956         >>> e = exp(exp(x)/(1 - 1/x))
2957 
2958         >>> e.aseries(x)
2959         exp(exp(x)/(1 - 1/x))
2960 
2961         >>> e.aseries(x, bound=3)
2962         exp(exp(x)/x**2)*exp(exp(x)/x)*exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x**2)*exp(exp(x))
2963 
2964         Returns
2965         =======
2966 
2967         Expr
2968             Asymptotic series expansion of the expression.
2969 
2970         Notes
2971         =====
2972 
2973         This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
2974         It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
2975         to look for the most rapidly varying subexpression w of a given expression f and then expands f
2976         in a series in w. Then same thing is recursively done on the leading coefficient
2977         till we get constant coefficients.
2978 
2979         If the most rapidly varying subexpression of a given expression f is f itself,
2980         the algorithm tries to find a normalised representation of the mrv set and rewrites f
2981         using this normalised representation.
2982 
2983         If the expansion contains an order term, it will be either ``O(x ** (-n))`` or ``O(w ** (-n))``
2984         where ``w`` belongs to the most rapidly varying expression of ``self``.
2985 
2986         References
2987         ==========
2988 
2989         .. [1] A New Algorithm for Computing Asymptotic Series - Dominik Gruntz
2990         .. [2] Gruntz thesis - p90
2991         .. [3] http://en.wikipedia.org/wiki/Asymptotic_expansion
2992 
2993         See Also
2994         ========
2995 
2996         Expr.aseries: See the docstring of this function for complete details of this wrapper.
2997         """
2998 
2999         from sympy import Order, Dummy
3000         from sympy.functions import exp, log
3001         from sympy.series.gruntz import mrv, rewrite
3002 
3003         if x.is_positive is x.is_negative is None:
3004             xpos = Dummy('x', positive=True)
3005             return self.subs(x, xpos).aseries(xpos, n, bound, hir).subs(xpos, x)
3006 
3007         om, exps = mrv(self, x)
3008 
3009         # We move one level up by replacing `x` by `exp(x)`, and then
3010         # computing the asymptotic series for f(exp(x)). Then asymptotic series
3011         # can be obtained by moving one-step back, by replacing x by ln(x).
3012 
3013         if x in om:
3014             s = self.subs(x, exp(x)).aseries(x, n, bound, hir).subs(x, log(x))
3015             if s.getO():
3016                 return s + Order(1/x**n, (x, S.Infinity))
3017             return s
3018 
3019         k = Dummy('k', positive=True)
3020         # f is rewritten in terms of omega
3021         func, logw = rewrite(exps, om, x, k)
3022 
3023         if self in om:
3024             if bound <= 0:
3025                 return self
3026             s = (self.exp).aseries(x, n, bound=bound)
3027             s = s.func(*[t.removeO() for t in s.args])
3028             res = exp(s.subs(x, 1/x).as_leading_term(x).subs(x, 1/x))
3029 
3030             func = exp(self.args[0] - res.args[0]) / k
3031             logw = log(1/res)
3032 
3033         s = func.series(k, 0, n)
3034 
3035         # Hierarchical series
3036         if hir:
3037             return s.subs(k, exp(logw))
3038 
3039         o = s.getO()
3040         terms = sorted(Add.make_args(s.removeO()), key=lambda i: int(i.as_coeff_exponent(k)[1]))
3041         s = S.Zero
3042         has_ord = False
3043 
3044         # Then we recursively expand these coefficients one by one into
3045         # their asymptotic series in terms of their most rapidly varying subexpressions.
3046         for t in terms:
3047             coeff, expo = t.as_coeff_exponent(k)
3048             if coeff.has(x):
3049                 # Recursive step
3050                 snew = coeff.aseries(x, n, bound=bound-1)
3051                 if has_ord and snew.getO():
3052                     break
3053                 elif snew.getO():
3054                     has_ord = True
3055                 s += (snew * k**expo)
3056             else:
3057                 s += t
3058 
3059         if not o or has_ord:
3060             return s.subs(k, exp(logw))
3061         return (s + o).subs(k, exp(logw))
3062 
3063 
3064     def taylor_term(self, n, x, *previous_terms):
3065         """General method for the taylor term.
3066 
3067         This method is slow, because it differentiates n-times. Subclasses can
3068         redefine it to make it faster by using the "previous_terms".
3069         """
3070         from sympy import Dummy, factorial
3071         x = sympify(x)
3072         _x = Dummy('x')
3073         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
3074 
3075     def lseries(self, x=None, x0=0, dir='+', logx=None):
3076         """
3077         Wrapper for series yielding an iterator of the terms of the series.
3078 
3079         Note: an infinite series will yield an infinite iterator. The following,
3080         for exaxmple, will never terminate. It will just keep printing terms
3081         of the sin(x) series::
3082 
3083           for term in sin(x).lseries(x):
3084               print term
3085 
3086         The advantage of lseries() over nseries() is that many times you are
3087         just interested in the next term in the series (i.e. the first term for
3088         example), but you don't know how many you should ask for in nseries()
3089         using the "n" parameter.
3090 
3091         See also nseries().
3092         """
3093         return self.series(x, x0, n=None, dir=dir, logx=logx)
3094 
3095     def _eval_lseries(self, x, logx=None):
3096         # default implementation of lseries is using nseries(), and adaptively
3097         # increasing the "n". As you can see, it is not very efficient, because
3098         # we are calculating the series over and over again. Subclasses should
3099         # override this method and implement much more efficient yielding of
3100         # terms.
3101         n = 0
3102         series = self._eval_nseries(x, n=n, logx=logx)
3103         if not series.is_Order:
3104             if series.is_Add:
3105                 yield series.removeO()
3106             else:
3107                 yield series
3108             return
3109 
3110         while series.is_Order:
3111             n += 1
3112             series = self._eval_nseries(x, n=n, logx=logx)
3113         e = series.removeO()
3114         yield e
3115         while 1:
3116             while 1:
3117                 n += 1
3118                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
3119                 if e != series:
3120                     break
3121             yield series - e
3122             e = series
3123 
3124     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
3125         """
3126         Wrapper to _eval_nseries if assumptions allow, else to series.
3127 
3128         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
3129         called. This calculates "n" terms in the innermost expressions and
3130         then builds up the final series just by "cross-multiplying" everything
3131         out.
3132 
3133         The optional ``logx`` parameter can be used to replace any log(x) in the
3134         returned series with a symbolic value to avoid evaluating log(x) at 0. A
3135         symbol to use in place of log(x) should be provided.
3136 
3137         Advantage -- it's fast, because we don't have to determine how many
3138         terms we need to calculate in advance.
3139 
3140         Disadvantage -- you may end up with less terms than you may have
3141         expected, but the O(x**n) term appended will always be correct and
3142         so the result, though perhaps shorter, will also be correct.
3143 
3144         If any of those assumptions is not met, this is treated like a
3145         wrapper to series which will try harder to return the correct
3146         number of terms.
3147 
3148         See also lseries().
3149 
3150         Examples
3151         ========
3152 
3153         >>> from sympy import sin, log, Symbol
3154         >>> from sympy.abc import x, y
3155         >>> sin(x).nseries(x, 0, 6)
3156         x - x**3/6 + x**5/120 + O(x**6)
3157         >>> log(x+1).nseries(x, 0, 5)
3158         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
3159 
3160         Handling of the ``logx`` parameter --- in the following example the
3161         expansion fails since ``sin`` does not have an asymptotic expansion
3162         at -oo (the limit of log(x) as x approaches 0):
3163 
3164         >>> e = sin(log(x))
3165         >>> e.nseries(x, 0, 6)
3166         Traceback (most recent call last):
3167         ...
3168         PoleError: ...
3169         ...
3170         >>> logx = Symbol('logx')
3171         >>> e.nseries(x, 0, 6, logx=logx)
3172         sin(logx)
3173 
3174         In the following example, the expansion works but gives only an Order term
3175         unless the ``logx`` parameter is used:
3176 
3177         >>> e = x**y
3178         >>> e.nseries(x, 0, 2)
3179         O(log(x)**2)
3180         >>> e.nseries(x, 0, 2, logx=logx)
3181         exp(logx*y)
3182 
3183         """
3184         if x and not x in self.free_symbols:
3185             return self
3186         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
3187             return self.series(x, x0, n, dir)
3188         else:
3189             return self._eval_nseries(x, n=n, logx=logx)
3190 
3191     def _eval_nseries(self, x, n, logx):
3192         """
3193         Return terms of series for self up to O(x**n) at x=0
3194         from the positive direction.
3195 
3196         This is a method that should be overridden in subclasses. Users should
3197         never call this method directly (use .nseries() instead), so you don't
3198         have to write docstrings for _eval_nseries().
3199         """
3200         from sympy.utilities.misc import filldedent
3201         raise NotImplementedError(filldedent("""
3202                      The _eval_nseries method should be added to
3203                      %s to give terms up to O(x**n) at x=0
3204                      from the positive direction so it is available when
3205                      nseries calls it.""" % self.func)
3206                      )
3207 
3208     def limit(self, x, xlim, dir='+'):
3209         """ Compute limit x->xlim.
3210         """
3211         from sympy.series.limits import limit
3212         return limit(self, x, xlim, dir)
3213 
3214     def compute_leading_term(self, x, logx=None):
3215         """
3216         as_leading_term is only allowed for results of .series()
3217         This is a wrapper to compute a series first.
3218         """
3219         from sympy import Dummy, log, Piecewise, piecewise_fold
3220         from sympy.series.gruntz import calculate_series
3221 
3222         if self.has(Piecewise):
3223             expr = piecewise_fold(self)
3224         else:
3225             expr = self
3226         if self.removeO() == 0:
3227             return self
3228 
3229         if logx is None:
3230             d = Dummy('logx')
3231             s = calculate_series(expr, x, d).subs(d, log(x))
3232         else:
3233             s = calculate_series(expr, x, logx)
3234 
3235         return s.as_leading_term(x)
3236 
3237     @cacheit
3238     def as_leading_term(self, *symbols):
3239         """
3240         Returns the leading (nonzero) term of the series expansion of self.
3241 
3242         The _eval_as_leading_term routines are used to do this, and they must
3243         always return a non-zero value.
3244 
3245         Examples
3246         ========
3247 
3248         >>> from sympy.abc import x
3249         >>> (1 + x + x**2).as_leading_term(x)
3250         1
3251         >>> (1/x**2 + x + x**2).as_leading_term(x)
3252         x**(-2)
3253 
3254         """
3255         from sympy import powsimp
3256         if len(symbols) > 1:
3257             c = self
3258             for x in symbols:
3259                 c = c.as_leading_term(x)
3260             return c
3261         elif not symbols:
3262             return self
3263         x = sympify(symbols[0])
3264         if not x.is_symbol:
3265             raise ValueError('expecting a Symbol but got %s' % x)
3266         if x not in self.free_symbols:
3267             return self
3268         obj = self._eval_as_leading_term(x)
3269         if obj is not None:
3270             return powsimp(obj, deep=True, combine='exp')
3271         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3272 
3273     def _eval_as_leading_term(self, x):
3274         return self
3275 
3276     def as_coeff_exponent(self, x):
3277         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3278         """
3279         from sympy import collect
3280         s = collect(self, x)
3281         c, p = s.as_coeff_mul(x)
3282         if len(p) == 1:
3283             b, e = p[0].as_base_exp()
3284             if b == x:
3285                 return c, e
3286         return s, S.Zero
3287 
3288     def leadterm(self, x):
3289         """
3290         Returns the leading term a*x**b as a tuple (a, b).
3291 
3292         Examples
3293         ========
3294 
3295         >>> from sympy.abc import x
3296         >>> (1+x+x**2).leadterm(x)
3297         (1, 0)
3298         >>> (1/x**2+x+x**2).leadterm(x)
3299         (1, -2)
3300 
3301         """
3302         from sympy import Dummy, log
3303         l = self.as_leading_term(x)
3304         d = Dummy('logx')
3305         if l.has(log(x)):
3306             l = l.subs(log(x), d)
3307         c, e = l.as_coeff_exponent(x)
3308         if x in c.free_symbols:
3309             from sympy.utilities.misc import filldedent
3310             raise ValueError(filldedent("""
3311                 cannot compute leadterm(%s, %s). The coefficient
3312                 should have been free of %s but got %s""" % (self, x, x, c)))
3313         c = c.subs(d, log(x))
3314         return c, e
3315 
3316     def as_coeff_Mul(self, rational=False):
3317         """Efficiently extract the coefficient of a product. """
3318         return S.One, self
3319 
3320     def as_coeff_Add(self, rational=False):
3321         """Efficiently extract the coefficient of a summation. """
3322         return S.Zero, self
3323 
3324     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3325             full=False):
3326         """
3327         Compute formal power power series of self.
3328 
3329         See the docstring of the :func:`fps` function in sympy.series.formal for
3330         more information.
3331         """
3332         from sympy.series.formal import fps
3333 
3334         return fps(self, x, x0, dir, hyper, order, rational, full)
3335 
3336     def fourier_series(self, limits=None):
3337         """Compute fourier sine/cosine series of self.
3338 
3339         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3340         for more information.
3341         """
3342         from sympy.series.fourier import fourier_series
3343 
3344         return fourier_series(self, limits)
3345 
3346     ###################################################################################
3347     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3348     ###################################################################################
3349 
3350     def diff(self, *symbols, **assumptions):
3351         assumptions.setdefault("evaluate", True)
3352         return Derivative(self, *symbols, **assumptions)
3353 
3354     ###########################################################################
3355     ###################### EXPRESSION EXPANSION METHODS #######################
3356     ###########################################################################
3357 
3358     # Relevant subclasses should override _eval_expand_hint() methods.  See
3359     # the docstring of expand() for more info.
3360 
3361     def _eval_expand_complex(self, **hints):
3362         real, imag = self.as_real_imag(**hints)
3363         return real + S.ImaginaryUnit*imag
3364 
3365     @staticmethod
3366     def _expand_hint(expr, hint, deep=True, **hints):
3367         """
3368         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3369 
3370         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3371         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3372         ``False`` otherwise.
3373         """
3374         hit = False
3375         # XXX: Hack to support non-Basic args
3376         #              |
3377         #              V
3378         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3379             sargs = []
3380             for arg in expr.args:
3381                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3382                 hit |= arghit
3383                 sargs.append(arg)
3384 
3385             if hit:
3386                 expr = expr.func(*sargs)
3387 
3388         if hasattr(expr, hint):
3389             newexpr = getattr(expr, hint)(**hints)
3390             if newexpr != expr:
3391                 return (newexpr, True)
3392 
3393         return (expr, hit)
3394 
3395     @cacheit
3396     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3397             mul=True, log=True, multinomial=True, basic=True, **hints):
3398         """
3399         Expand an expression using hints.
3400 
3401         See the docstring of the expand() function in sympy.core.function for
3402         more information.
3403 
3404         """
3405         from sympy.simplify.radsimp import fraction
3406 
3407         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3408            log=log, multinomial=multinomial, basic=basic)
3409 
3410         expr = self
3411         if hints.pop('frac', False):
3412             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3413                     for a in fraction(self)]
3414             return n/d
3415         elif hints.pop('denom', False):
3416             n, d = fraction(self)
3417             return n/d.expand(deep=deep, modulus=modulus, **hints)
3418         elif hints.pop('numer', False):
3419             n, d = fraction(self)
3420             return n.expand(deep=deep, modulus=modulus, **hints)/d
3421 
3422         # Although the hints are sorted here, an earlier hint may get applied
3423         # at a given node in the expression tree before another because of how
3424         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3425         # x*z) because while applying log at the top level, log and mul are
3426         # applied at the deeper level in the tree so that when the log at the
3427         # upper level gets applied, the mul has already been applied at the
3428         # lower level.
3429 
3430         # Additionally, because hints are only applied once, the expression
3431         # may not be expanded all the way.   For example, if mul is applied
3432         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3433         # now, we just use a special case to make multinomial run before mul,
3434         # so that at least polynomials will be expanded all the way.  In the
3435         # future, smarter heuristics should be applied.
3436         # TODO: Smarter heuristics
3437 
3438         def _expand_hint_key(hint):
3439             """Make multinomial come before mul"""
3440             if hint == 'mul':
3441                 return 'mulz'
3442             return hint
3443 
3444         for hint in sorted(hints.keys(), key=_expand_hint_key):
3445             use_hint = hints[hint]
3446             if use_hint:
3447                 hint = '_eval_expand_' + hint
3448                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3449 
3450         while True:
3451             was = expr
3452             if hints.get('multinomial', False):
3453                 expr, _ = Expr._expand_hint(
3454                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3455             if hints.get('mul', False):
3456                 expr, _ = Expr._expand_hint(
3457                     expr, '_eval_expand_mul', deep=deep, **hints)
3458             if hints.get('log', False):
3459                 expr, _ = Expr._expand_hint(
3460                     expr, '_eval_expand_log', deep=deep, **hints)
3461             if expr == was:
3462                 break
3463 
3464         if modulus is not None:
3465             modulus = sympify(modulus)
3466 
3467             if not modulus.is_Integer or modulus <= 0:
3468                 raise ValueError(
3469                     "modulus must be a positive integer, got %s" % modulus)
3470 
3471             terms = []
3472 
3473             for term in Add.make_args(expr):
3474                 coeff, tail = term.as_coeff_Mul(rational=True)
3475 
3476                 coeff %= modulus
3477 
3478                 if coeff:
3479                     terms.append(coeff*tail)
3480 
3481             expr = Add(*terms)
3482 
3483         return expr
3484 
3485     ###########################################################################
3486     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3487     ###########################################################################
3488 
3489     def integrate(self, *args, **kwargs):
3490         """See the integrate function in sympy.integrals"""
3491         from sympy.integrals import integrate
3492         return integrate(self, *args, **kwargs)
3493 
3494     def simplify(self, **kwargs):
3495         """See the simplify function in sympy.simplify"""
3496         from sympy.simplify import simplify
3497         return simplify(self, **kwargs)
3498 
3499     def nsimplify(self, constants=[], tolerance=None, full=False):
3500         """See the nsimplify function in sympy.simplify"""
3501         from sympy.simplify import nsimplify
3502         return nsimplify(self, constants, tolerance, full)
3503 
3504     def separate(self, deep=False, force=False):
3505         """See the separate function in sympy.simplify"""
3506         from sympy.core.function import expand_power_base
3507         return expand_power_base(self, deep=deep, force=force)
3508 
3509     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3510         """See the collect function in sympy.simplify"""
3511         from sympy.simplify import collect
3512         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3513 
3514     def together(self, *args, **kwargs):
3515         """See the together function in sympy.polys"""
3516         from sympy.polys import together
3517         return together(self, *args, **kwargs)
3518 
3519     def apart(self, x=None, **args):
3520         """See the apart function in sympy.polys"""
3521         from sympy.polys import apart
3522         return apart(self, x, **args)
3523 
3524     def ratsimp(self):
3525         """See the ratsimp function in sympy.simplify"""
3526         from sympy.simplify import ratsimp
3527         return ratsimp(self)
3528 
3529     def trigsimp(self, **args):
3530         """See the trigsimp function in sympy.simplify"""
3531         from sympy.simplify import trigsimp
3532         return trigsimp(self, **args)
3533 
3534     def radsimp(self, **kwargs):
3535         """See the radsimp function in sympy.simplify"""
3536         from sympy.simplify import radsimp
3537         return radsimp(self, **kwargs)
3538 
3539     def powsimp(self, *args, **kwargs):
3540         """See the powsimp function in sympy.simplify"""
3541         from sympy.simplify import powsimp
3542         return powsimp(self, *args, **kwargs)
3543 
3544     def combsimp(self):
3545         """See the combsimp function in sympy.simplify"""
3546         from sympy.simplify import combsimp
3547         return combsimp(self)
3548 
3549     def gammasimp(self):
3550         """See the gammasimp function in sympy.simplify"""
3551         from sympy.simplify import gammasimp
3552         return gammasimp(self)
3553 
3554     def factor(self, *gens, **args):
3555         """See the factor() function in sympy.polys.polytools"""
3556         from sympy.polys import factor
3557         return factor(self, *gens, **args)
3558 
3559     def refine(self, assumption=True):
3560         """See the refine function in sympy.assumptions"""
3561         from sympy.assumptions import refine
3562         return refine(self, assumption)
3563 
3564     def cancel(self, *gens, **args):
3565         """See the cancel function in sympy.polys"""
3566         from sympy.polys import cancel
3567         return cancel(self, *gens, **args)
3568 
3569     def invert(self, g, *gens, **args):
3570         """Return the multiplicative inverse of ``self`` mod ``g``
3571         where ``self`` (and ``g``) may be symbolic expressions).
3572 
3573         See Also
3574         ========
3575         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3576         """
3577         from sympy.polys.polytools import invert
3578         from sympy.core.numbers import mod_inverse
3579         if self.is_number and getattr(g, 'is_number', True):
3580             return mod_inverse(self, g)
3581         return invert(self, g, *gens, **args)
3582 
3583     def round(self, n=None):
3584         """Return x rounded to the given decimal place.
3585 
3586         If a complex number would results, apply round to the real
3587         and imaginary components of the number.
3588 
3589         Examples
3590         ========
3591 
3592         >>> from sympy import pi, E, I, S, Add, Mul, Number
3593         >>> pi.round()
3594         3
3595         >>> pi.round(2)
3596         3.14
3597         >>> (2*pi + E*I).round()
3598         6 + 3*I
3599 
3600         The round method has a chopping effect:
3601 
3602         >>> (2*pi + I/10).round()
3603         6
3604         >>> (pi/10 + 2*I).round()
3605         2*I
3606         >>> (pi/10 + E*I).round(2)
3607         0.31 + 2.72*I
3608 
3609         Notes
3610         =====
3611 
3612         The Python builtin function, round, always returns a
3613         float in Python 2 while the SymPy round method (and
3614         round with a Number argument in Python 3) returns a
3615         Number.
3616 
3617         >>> from sympy.core.compatibility import PY3
3618         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3619         True
3620 
3621         For a consistent behavior, and Python 3 rounding
3622         rules, import `round` from sympy.core.compatibility.
3623 
3624         >>> from sympy.core.compatibility import round
3625         >>> isinstance(round(S(123), -2), Number)
3626         True
3627         """
3628         from sympy.core.numbers import Float
3629 
3630         x = self
3631 
3632         if not x.is_number:
3633             raise TypeError("can't round symbolic expression")
3634         if not x.is_Atom:
3635             if not pure_complex(x.n(2), or_real=True):
3636                 raise TypeError(
3637                     'Expected a number but got %s:' % func_name(x))
3638         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3639             return x
3640         if not x.is_extended_real:
3641             i, r = x.as_real_imag()
3642             return i.round(n) + S.ImaginaryUnit*r.round(n)
3643         if not x:
3644             return S.Zero if n is None else x
3645 
3646 
3647         p = as_int(n or 0)
3648 
3649         if x.is_Integer:
3650             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3651             if p >= 0:
3652                 return x
3653             m = 10**-p
3654             i, r = divmod(abs(x), m)
3655             if i%2 and 2*r == m:
3656               i += 1
3657             elif 2*r > m:
3658                 i += 1
3659             if x < 0:
3660                 i *= -1
3661             return i*m
3662 
3663         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3664         allow = digits_to_decimal + p
3665         precs = [f._prec for f in x.atoms(Float)]
3666         dps = prec_to_dps(max(precs)) if precs else None
3667         if dps is None:
3668             # assume everything is exact so use the Python
3669             # float default or whatever was requested
3670             dps = max(15, allow)
3671         else:
3672             allow = min(allow, dps)
3673         # this will shift all digits to right of decimal
3674         # and give us dps to work with as an int
3675         shift = -digits_to_decimal + dps
3676         extra = 1  # how far we look past known digits
3677         # NOTE
3678         # mpmath will calculate the binary representation to
3679         # an arbitrary number of digits but we must base our
3680         # answer on a finite number of those digits, e.g.
3681         # .575 2589569785738035/2**52 in binary.
3682         # mpmath shows us that the first 18 digits are
3683         #     >>> Float(.575).n(18)
3684         #     0.574999999999999956
3685         # The default precision is 15 digits and if we ask
3686         # for 15 we get
3687         #     >>> Float(.575).n(15)
3688         #     0.575000000000000
3689         # mpmath handles rounding at the 15th digit. But we
3690         # need to be careful since the user might be asking
3691         # for rounding at the last digit and our semantics
3692         # are to round toward the even final digit when there
3693         # is a tie. So the extra digit will be used to make
3694         # that decision. In this case, the value is the same
3695         # to 15 digits:
3696         #     >>> Float(.575).n(16)
3697         #     0.5750000000000000
3698         # Now converting this to the 15 known digits gives
3699         #     575000000000000.0
3700         # which rounds to integer
3701         #    5750000000000000
3702         # And now we can round to the desired digt, e.g. at
3703         # the second from the left and we get
3704         #    5800000000000000
3705         # and rescaling that gives
3706         #    0.58
3707         # as the final result.
3708         # If the value is made slightly less than 0.575 we might
3709         # still obtain the same value:
3710         #    >>> Float(.575-1e-16).n(16)*10**15
3711         #    574999999999999.8
3712         # What 15 digits best represents the known digits (which are
3713         # to the left of the decimal? 5750000000000000, the same as
3714         # before. The only way we will round down (in this case) is
3715         # if we declared that we had more than 15 digits of precision.
3716         # For example, if we use 16 digits of precision, the integer
3717         # we deal with is
3718         #    >>> Float(.575-1e-16).n(17)*10**16
3719         #    5749999999999998.4
3720         # and this now rounds to 5749999999999998 and (if we round to
3721         # the 2nd digit from the left) we get 5700000000000000.
3722         #
3723         xf = x.n(dps + extra)*Pow(10, shift)
3724         xi = Integer(xf)
3725         # use the last digit to select the value of xi
3726         # nearest to x before rounding at the desired digit
3727         sign = 1 if x > 0 else -1
3728         dif2 = sign*(xf - xi).n(extra)
3729         if dif2 < 0:
3730             raise NotImplementedError(
3731                 'not expecting int(x) to round away from 0')
3732         if dif2 > .5:
3733             xi += sign  # round away from 0
3734         elif dif2 == .5:
3735             xi += sign if xi%2 else -sign  # round toward even
3736         # shift p to the new position
3737         ip = p - shift
3738         # let Python handle the int rounding then rescale
3739         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3740         # restore scale
3741         rv = Rational(xr, Pow(10, shift))
3742         # return Float or Integer
3743         if rv.is_Integer:
3744             if n is None:  # the single-arg case
3745                 return rv
3746             # use str or else it won't be a float
3747             return Float(str(rv), dps)  # keep same precision
3748         else:
3749             if not allow and rv > self:
3750                 allow += 1
3751             return Float(rv, allow)
3752 
3753     __round__ = round
3754 
3755     def _eval_derivative_matrix_lines(self, x):
3756         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3757         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/sympify.py</file>
<class>None</class>
<method>sympify</method>
<code>
78 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
79         evaluate=None):
80     """Converts an arbitrary expression to a type that can be used inside SymPy.
81 
82     For example, it will convert Python ints into instances of sympy.Integer,
83     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
84     expressions which inherit from Basic. This can be useful in cooperation
85     with SAGE.
86 
87     It currently accepts as arguments:
88        - any object defined in SymPy
89        - standard numeric python types: int, long, float, Decimal
90        - strings (like "0.09" or "2e-19")
91        - booleans, including ``None`` (will leave ``None`` unchanged)
92        - dict, lists, sets or tuples containing any of the above
93 
94     .. warning::
95         Note that this function uses ``eval``, and thus shouldn't be used on
96         unsanitized input.
97 
98     If the argument is already a type that SymPy understands, it will do
99     nothing but return that value. This can be used at the beginning of a
100     function to ensure you are working with the correct type.
101 
102     >>> from sympy import sympify
103 
104     >>> sympify(2).is_integer
105     True
106     >>> sympify(2).is_real
107     True
108 
109     >>> sympify(2.0).is_real
110     True
111     >>> sympify("2.0").is_real
112     True
113     >>> sympify("2e-45").is_real
114     True
115 
116     If the expression could not be converted, a SympifyError is raised.
117 
118     >>> sympify("x***2")
119     Traceback (most recent call last):
120     ...
121     SympifyError: SympifyError: "could not parse u'x***2'"
122 
123     Locals
124     ------
125 
126     The sympification happens with access to everything that is loaded
127     by ``from sympy import *``; anything used in a string that is not
128     defined by that import will be converted to a symbol. In the following,
129     the ``bitcount`` function is treated as a symbol and the ``O`` is
130     interpreted as the Order object (used with series) and it raises
131     an error when used improperly:
132 
133     >>> s = 'bitcount(42)'
134     >>> sympify(s)
135     bitcount(42)
136     >>> sympify("O(x)")
137     O(x)
138     >>> sympify("O + 1")
139     Traceback (most recent call last):
140     ...
141     TypeError: unbound method...
142 
143     In order to have ``bitcount`` be recognized it can be imported into a
144     namespace dictionary and passed as locals:
145 
146     >>> from sympy.core.compatibility import exec_
147     >>> ns = {}
148     >>> exec_('from sympy.core.evalf import bitcount', ns)
149     >>> sympify(s, locals=ns)
150     6
151 
152     In order to have the ``O`` interpreted as a Symbol, identify it as such
153     in the namespace dictionary. This can be done in a variety of ways; all
154     three of the following are possibilities:
155 
156     >>> from sympy import Symbol
157     >>> ns["O"] = Symbol("O")  # method 1
158     >>> exec_('from sympy.abc import O', ns)  # method 2
159     >>> ns.update(dict(O=Symbol("O")))  # method 3
160     >>> sympify("O + 1", locals=ns)
161     O + 1
162 
163     If you want *all* single-letter and Greek-letter variables to be symbols
164     then you can use the clashing-symbols dictionaries that have been defined
165     there as private variables: _clash1 (single-letter variables), _clash2
166     (the multi-letter Greek names) or _clash (both single and multi-letter
167     names that are defined in abc).
168 
169     >>> from sympy.abc import _clash1
170     >>> _clash1
171     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
172     >>> sympify('I & Q', _clash1)
173     I & Q
174 
175     Strict
176     ------
177 
178     If the option ``strict`` is set to ``True``, only the types for which an
179     explicit conversion has been defined are converted. In the other
180     cases, a SympifyError is raised.
181 
182     >>> print(sympify(None))
183     None
184     >>> sympify(None, strict=True)
185     Traceback (most recent call last):
186     ...
187     SympifyError: SympifyError: None
188 
189     Evaluation
190     ----------
191 
192     If the option ``evaluate`` is set to ``False``, then arithmetic and
193     operators will be converted into their SymPy equivalents and the
194     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
195     be denested first. This is done via an AST transformation that replaces
196     operators with their SymPy equivalents, so if an operand redefines any
197     of those operations, the redefined operators will not be used.
198 
199     >>> sympify('2**2 / 3 + 5')
200     19/3
201     >>> sympify('2**2 / 3 + 5', evaluate=False)
202     2**2/3 + 5
203 
204     Extending
205     ---------
206 
207     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
208     just define a ``_sympy_`` method to your class. You can do that even to
209     classes that you do not own by subclassing or adding the method at runtime.
210 
211     >>> from sympy import Matrix
212     >>> class MyList1(object):
213     ...     def __iter__(self):
214     ...         yield 1
215     ...         yield 2
216     ...         return
217     ...     def __getitem__(self, i): return list(self)[i]
218     ...     def _sympy_(self): return Matrix(self)
219     >>> sympify(MyList1())
220     Matrix([
221     [1],
222     [2]])
223 
224     If you do not have control over the class definition you could also use the
225     ``converter`` global dictionary. The key is the class and the value is a
226     function that takes a single argument and returns the desired SymPy
227     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
228 
229     >>> class MyList2(object):   # XXX Do not do this if you control the class!
230     ...     def __iter__(self):  #     Use _sympy_!
231     ...         yield 1
232     ...         yield 2
233     ...         return
234     ...     def __getitem__(self, i): return list(self)[i]
235     >>> from sympy.core.sympify import converter
236     >>> converter[MyList2] = lambda x: Matrix(x)
237     >>> sympify(MyList2())
238     Matrix([
239     [1],
240     [2]])
241 
242     Notes
243     =====
244 
245     The keywords ``rational`` and ``convert_xor`` are only used
246     when the input is a string.
247 
248     Sometimes autosimplification during sympification results in expressions
249     that are very different in structure than what was entered. Until such
250     autosimplification is no longer done, the ``kernS`` function might be of
251     some use. In the example below you can see how an expression reduces to
252     -1 by autosimplification, but does not do so when ``kernS`` is used.
253 
254     >>> from sympy.core.sympify import kernS
255     >>> from sympy.abc import x
256     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
257     -1
258     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
259     >>> sympify(s)
260     -1
261     >>> kernS(s)
262     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
263 
264     """
265     is_sympy = getattr(a, '__sympy__', None)
266     if is_sympy is not None:
267         return a
268 
269     if isinstance(a, CantSympify):
270         raise SympifyError(a)
271     cls = getattr(a, "__class__", None)
272     if cls is None:
273         cls = type(a)  # Probably an old-style class
274     conv = converter.get(cls, None)
275     if conv is not None:
276         return conv(a)
277 
278     for superclass in getmro(cls):
279         try:
280             return converter[superclass](a)
281         except KeyError:
282             continue
283 
284     if cls is type(None):
285         if strict:
286             raise SympifyError(a)
287         else:
288             return a
289 
290     if evaluate is None:
291         if global_evaluate[0] is False:
292             evaluate = global_evaluate[0]
293         else:
294             evaluate = True
295 
296     # Support for basic numpy datatypes
297     # Note that this check exists to avoid importing NumPy when not necessary
298     if type(a).__module__ == 'numpy':
299         import numpy as np
300         if np.isscalar(a):
301             return _convert_numpy_types(a, locals=locals,
302                 convert_xor=convert_xor, strict=strict, rational=rational,
303                 evaluate=evaluate)
304 
305     _sympy_ = getattr(a, "_sympy_", None)
306     if _sympy_ is not None:
307         try:
308             return a._sympy_()
309         # XXX: Catches AttributeError: 'SympyConverter' object has no
310         # attribute 'tuple'
311         # This is probably a bug somewhere but for now we catch it here.
312         except AttributeError:
313             pass
314 
315     if not strict:
316         # Put numpy array conversion _before_ float/int, see
317         # <https://github.com/sympy/sympy/issues/13924>.
318         flat = getattr(a, "flat", None)
319         if flat is not None:
320             shape = getattr(a, "shape", None)
321             if shape is not None:
322                 from ..tensor.array import Array
323                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
324 
325     if not isinstance(a, string_types):
326         for coerce in (float, int):
327             try:
328                 coerced = coerce(a)
329             except (TypeError, ValueError):
330                 continue
331             # XXX: AttributeError only needed here for Py2
332             except AttributeError:
333                 continue
334             try:
335                 return sympify(coerced)
336             except SympifyError:
337                 continue
338 
339     if strict:
340         raise SympifyError(a)
341 
342     if iterable(a):
343         try:
344             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
345                 rational=rational) for x in a])
346         except TypeError:
347             # Not all iterables are rebuildable with their type.
348             pass
349     if isinstance(a, dict):
350         try:
351             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
352                 rational=rational) for x in a.items()])
353         except TypeError:
354             # Not all iterables are rebuildable with their type.
355             pass
356 
357     # At this point we were given an arbitrary expression
358     # which does not inherit from Basic and doesn't implement
359     # _sympy_ (which is a canonical and robust way to convert
360     # anything to SymPy expression).
361     #
362     # As a last chance, we try to take "a"'s normal form via unicode()
363     # and try to parse it. If it fails, then we have no luck and
364     # return an exception
365     try:
366         from .compatibility import unicode
367         a = unicode(a)
368     except Exception as exc:
369         raise SympifyError(a, exc)
370 
371     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
372                                             standard_transformations)
373     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
374     from sympy.parsing.sympy_parser import rationalize as t_rationalize
375 
376     transformations = standard_transformations
377 
378     if rational:
379         transformations += (t_rationalize,)
380     if convert_xor:
381         transformations += (t_convert_xor,)
382 
383     try:
384         a = a.replace('\n', '')
385         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
386     except (TokenError, SyntaxError) as exc:
387         raise SympifyError('could not parse %r' % a, exc)
388 
389     return expr

</code><intended_behavior>Modify the behavior to either securely parse string inputs without using eval or incorporate a more sophisticated method/input validation to ensure that only safe expressions are evaluated. The function should continue to convert a wide range of inputs into SymPy objects but with enhanced safety, explicitly avoiding the evaluation of arbitrary code through string representations.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>eval_expr</method>
<code>
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr

</code><intended_behavior>Revisit the direct use of eval to ensure that it's not exposed to arbitrary code execution risks. This might involve replacing eval with a safer evaluation strategy or enforcing strict validation of the inputs before they reach eval. The function's capacity to convert parsed expressions into SymPy expressions should be maintained while ensuring the security and integrity of the operation.</intended_behavior>]
2025-10-15 14:26:28.322 | INFO     | Search completed. Bug locations: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>__eq__</method>
<code>
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True

</code><intended_behavior>This method should have a mechanism to securely check equality without resorting to sympify for untrusted string representations that might get evaluated. A possible fix is enhancing the safety of sympify itself to prevent evaluation of arbitrary code or adding a preliminary check in __eq__ to avoid calling sympify with potentially dangerous inputs. Preserve equality checking functionality without evaluating repr strings of unknown objects.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     def __hash__(self):
105         # hash cannot be cached using cache_it because infinite recurrence
106         # occurs as hash is needed for setting cache dictionary keys
107         h = self._mhash
108         if h is None:
109             h = hash((type(self).__name__,) + self._hashable_content())
110             self._mhash = h
111         return h
112 
113     def _hashable_content(self):
114         """Return a tuple of information about self that can be used to
115         compute the hash. If a class defines additional attributes,
116         like ``name`` in Symbol, then this method should be updated
117         accordingly to return such relevant attributes.
118         Defining more than _hashable_content is necessary if __eq__ has
119         been defined by a class. See note about this in Basic.__eq__."""
120         return self._args
121 
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True
143 
144     # ***************
145     # * Arithmetics *
146     # ***************
147     # Expr and its sublcasses use _op_priority to determine which object
148     # passed to a binary special method (__mul__, etc.) will handle the
149     # operation. In general, the 'call_highest_priority' decorator will choose
150     # the object with the highest _op_priority to handle the call.
151     # Custom subclasses that want to define their own binary special methods
152     # should set an _op_priority value that is higher than the default.
153     #
154     # **NOTE**:
155     # This is a temporary fix, and will eventually be replaced with
156     # something better and more powerful.  See issue 5510.
157     _op_priority = 10.0
158 
159     def __pos__(self):
160         return self
161 
162     def __neg__(self):
163         # Mul has its own __neg__ routine, so we just
164         # create a 2-args Mul with the -1 in the canonical
165         # slot 0.
166         c = self.is_commutative
167         return Mul._from_args((S.NegativeOne, self), c)
168 
169     def __abs__(self):
170         from sympy import Abs
171         return Abs(self)
172 
173     @_sympifyit('other', NotImplemented)
174     @call_highest_priority('__radd__')
175     def __add__(self, other):
176         return Add(self, other)
177 
178     @_sympifyit('other', NotImplemented)
179     @call_highest_priority('__add__')
180     def __radd__(self, other):
181         return Add(other, self)
182 
183     @_sympifyit('other', NotImplemented)
184     @call_highest_priority('__rsub__')
185     def __sub__(self, other):
186         return Add(self, -other)
187 
188     @_sympifyit('other', NotImplemented)
189     @call_highest_priority('__sub__')
190     def __rsub__(self, other):
191         return Add(other, -self)
192 
193     @_sympifyit('other', NotImplemented)
194     @call_highest_priority('__rmul__')
195     def __mul__(self, other):
196         return Mul(self, other)
197 
198     @_sympifyit('other', NotImplemented)
199     @call_highest_priority('__mul__')
200     def __rmul__(self, other):
201         return Mul(other, self)
202 
203     @_sympifyit('other', NotImplemented)
204     @call_highest_priority('__rpow__')
205     def _pow(self, other):
206         return Pow(self, other)
207 
208     def __pow__(self, other, mod=None):
209         if mod is None:
210             return self._pow(other)
211         try:
212             _self, other, mod = as_int(self), as_int(other), as_int(mod)
213             if other >= 0:
214                 return pow(_self, other, mod)
215             else:
216                 from sympy.core.numbers import mod_inverse
217                 return mod_inverse(pow(_self, -other, mod), mod)
218         except ValueError:
219             power = self._pow(other)
220             try:
221                 return power%mod
222             except TypeError:
223                 return NotImplemented
224 
225     @_sympifyit('other', NotImplemented)
226     @call_highest_priority('__pow__')
227     def __rpow__(self, other):
228         return Pow(other, self)
229 
230     @_sympifyit('other', NotImplemented)
231     @call_highest_priority('__rdiv__')
232     def __div__(self, other):
233         return Mul(self, Pow(other, S.NegativeOne))
234 
235     @_sympifyit('other', NotImplemented)
236     @call_highest_priority('__div__')
237     def __rdiv__(self, other):
238         return Mul(other, Pow(self, S.NegativeOne))
239 
240     __truediv__ = __div__
241     __rtruediv__ = __rdiv__
242 
243     @_sympifyit('other', NotImplemented)
244     @call_highest_priority('__rmod__')
245     def __mod__(self, other):
246         return Mod(self, other)
247 
248     @_sympifyit('other', NotImplemented)
249     @call_highest_priority('__mod__')
250     def __rmod__(self, other):
251         return Mod(other, self)
252 
253     @_sympifyit('other', NotImplemented)
254     @call_highest_priority('__rfloordiv__')
255     def __floordiv__(self, other):
256         from sympy.functions.elementary.integers import floor
257         return floor(self / other)
258 
259     @_sympifyit('other', NotImplemented)
260     @call_highest_priority('__floordiv__')
261     def __rfloordiv__(self, other):
262         from sympy.functions.elementary.integers import floor
263         return floor(other / self)
264 
265 
266     @_sympifyit('other', NotImplemented)
267     @call_highest_priority('__rdivmod__')
268     def __divmod__(self, other):
269         from sympy.functions.elementary.integers import floor
270         return floor(self / other), Mod(self, other)
271 
272     @_sympifyit('other', NotImplemented)
273     @call_highest_priority('__divmod__')
274     def __rdivmod__(self, other):
275         from sympy.functions.elementary.integers import floor
276         return floor(other / self), Mod(other, self)
277 
278     def __int__(self):
279         # Although we only need to round to the units position, we'll
280         # get one more digit so the extra testing below can be avoided
281         # unless the rounded value rounded to an integer, e.g. if an
282         # expression were equal to 1.9 and we rounded to the unit position
283         # we would get a 2 and would not know if this rounded up or not
284         # without doing a test (as done below). But if we keep an extra
285         # digit we know that 1.9 is not the same as 1 and there is no
286         # need for further testing: our int value is correct. If the value
287         # were 1.99, however, this would round to 2.0 and our int value is
288         # off by one. So...if our round value is the same as the int value
289         # (regardless of how much extra work we do to calculate extra decimal
290         # places) we need to test whether we are off by one.
291         from sympy import Dummy
292         if not self.is_number:
293             raise TypeError("can't convert symbols to int")
294         r = self.round(2)
295         if not r.is_Number:
296             raise TypeError("can't convert complex to int")
297         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
298             raise TypeError("can't convert %s to int" % r)
299         i = int(r)
300         if not i:
301             return 0
302         # off-by-one check
303         if i == r and not (self - i).equals(0):
304             isign = 1 if i > 0 else -1
305             x = Dummy()
306             # in the following (self - i).evalf(2) will not always work while
307             # (self - r).evalf(2) and the use of subs does; if the test that
308             # was added when this comment was added passes, it might be safe
309             # to simply use sign to compute this rather than doing this by hand:
310             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
311             if diff_sign != isign:
312                 i -= isign
313         return i
314     __long__ = __int__
315 
316     def __float__(self):
317         # Don't bother testing if it's a number; if it's not this is going
318         # to fail, and if it is we still need to check that it evalf'ed to
319         # a number.
320         result = self.evalf()
321         if result.is_Number:
322             return float(result)
323         if result.is_number and result.as_real_imag()[1]:
324             raise TypeError("can't convert complex to float")
325         raise TypeError("can't convert expression to float")
326 
327     def __complex__(self):
328         result = self.evalf()
329         re, im = result.as_real_imag()
330         return complex(float(re), float(im))
331 
332     def _cmp(self, other, op, cls):
333         assert op in ("<", ">", "<=", ">=")
334         try:
335             other = _sympify(other)
336         except SympifyError:
337             raise TypeError("Invalid comparison %s %s %s" % (self, op, other))
338         for me in (self, other):
339             if me.is_extended_real is False:
340                 raise TypeError("Invalid comparison of non-real %s" % me)
341             if me is S.NaN:
342                 raise TypeError("Invalid NaN comparison")
343 
344         n2 = _n2(self, other)
345         if n2 is not None:
346             # use float comparison for infinity.
347             # otherwise get stuck in infinite recursion
348             if n2 in (S.Infinity, S.NegativeInfinity):
349                 n2 = float(n2)
350             if op == "<":
351                 return _sympify(n2 < 0)
352             elif op == ">":
353                 return _sympify(n2 > 0)
354             elif op == "<=":
355                 return _sympify(n2 <= 0)
356             else: # >=
357                 return _sympify(n2 >= 0)
358 
359         if self.is_extended_real and other.is_extended_real:
360             if op in ("<=", ">") \
361                 and ((self.is_infinite and self.is_extended_negative) \
362                      or (other.is_infinite and other.is_extended_positive)):
363                 return S.true if op == "<=" else S.false
364             if op in ("<", ">=") \
365                 and ((self.is_infinite and self.is_extended_positive) \
366                      or (other.is_infinite and other.is_extended_negative)):
367                 return S.true if op == ">=" else S.false
368             diff = self - other
369             if diff is not S.NaN:
370                 if op == "<":
371                     test = diff.is_extended_negative
372                 elif op == ">":
373                     test = diff.is_extended_positive
374                 elif op == "<=":
375                     test = diff.is_extended_nonpositive
376                 else: # >=
377                     test = diff.is_extended_nonnegative
378 
379                 if test is not None:
380                     return S.true if test == True else S.false
381 
382         # return unevaluated comparison object
383         return cls(self, other, evaluate=False)
384 
385     def __ge__(self, other):
386         from sympy import GreaterThan
387         return self._cmp(other, ">=", GreaterThan)
388 
389     def __le__(self, other):
390         from sympy import LessThan
391         return self._cmp(other, "<=", LessThan)
392 
393     def __gt__(self, other):
394         from sympy import StrictGreaterThan
395         return self._cmp(other, ">", StrictGreaterThan)
396 
397     def __lt__(self, other):
398         from sympy import StrictLessThan
399         return self._cmp(other, "<", StrictLessThan)
400 
401     def __trunc__(self):
402         if not self.is_number:
403             raise TypeError("can't truncate symbols and expressions")
404         else:
405             return Integer(self)
406 
407     @staticmethod
408     def _from_mpmath(x, prec):
409         from sympy import Float
410         if hasattr(x, "_mpf_"):
411             return Float._new(x._mpf_, prec)
412         elif hasattr(x, "_mpc_"):
413             re, im = x._mpc_
414             re = Float._new(re, prec)
415             im = Float._new(im, prec)*S.ImaginaryUnit
416             return re + im
417         else:
418             raise TypeError("expected mpmath number (mpf or mpc)")
419 
420     @property
421     def is_number(self):
422         """Returns True if ``self`` has no free symbols and no
423         undefined functions (AppliedUndef, to be precise). It will be
424         faster than ``if not self.free_symbols``, however, since
425         ``is_number`` will fail as soon as it hits a free symbol
426         or undefined function.
427 
428         Examples
429         ========
430 
431         >>> from sympy import log, Integral, cos, sin, pi
432         >>> from sympy.core.function import Function
433         >>> from sympy.abc import x
434         >>> f = Function('f')
435 
436         >>> x.is_number
437         False
438         >>> f(1).is_number
439         False
440         >>> (2*x).is_number
441         False
442         >>> (2 + Integral(2, x)).is_number
443         False
444         >>> (2 + Integral(2, (x, 1, 2))).is_number
445         True
446 
447         Not all numbers are Numbers in the SymPy sense:
448 
449         >>> pi.is_number, pi.is_Number
450         (True, False)
451 
452         If something is a number it should evaluate to a number with
453         real and imaginary parts that are Numbers; the result may not
454         be comparable, however, since the real and/or imaginary part
455         of the result may not have precision.
456 
457         >>> cos(1).is_number and cos(1).is_comparable
458         True
459 
460         >>> z = cos(1)**2 + sin(1)**2 - 1
461         >>> z.is_number
462         True
463         >>> z.is_comparable
464         False
465 
466         See Also
467         ========
468         sympy.core.basic.Basic.is_comparable
469         """
470         return all(obj.is_number for obj in self.args)
471 
472     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
473         """Return self evaluated, if possible, replacing free symbols with
474         random complex values, if necessary.
475 
476         The random complex value for each free symbol is generated
477         by the random_complex_number routine giving real and imaginary
478         parts in the range given by the re_min, re_max, im_min, and im_max
479         values. The returned value is evaluated to a precision of n
480         (if given) else the maximum of 15 and the precision needed
481         to get more than 1 digit of precision. If the expression
482         could not be evaluated to a number, or could not be evaluated
483         to more than 1 digit of precision, then None is returned.
484 
485         Examples
486         ========
487 
488         >>> from sympy import sqrt
489         >>> from sympy.abc import x, y
490         >>> x._random()                         # doctest: +SKIP
491         0.0392918155679172 + 0.916050214307199*I
492         >>> x._random(2)                        # doctest: +SKIP
493         -0.77 - 0.87*I
494         >>> (x + y/2)._random(2)                # doctest: +SKIP
495         -0.57 + 0.16*I
496         >>> sqrt(2)._random(2)
497         1.4
498 
499         See Also
500         ========
501 
502         sympy.utilities.randtest.random_complex_number
503         """
504 
505         free = self.free_symbols
506         prec = 1
507         if free:
508             from sympy.utilities.randtest import random_complex_number
509             a, c, b, d = re_min, re_max, im_min, im_max
510             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
511                            for zi in free])))
512             try:
513                 nmag = abs(self.evalf(2, subs=reps))
514             except (ValueError, TypeError):
515                 # if an out of range value resulted in evalf problems
516                 # then return None -- XXX is there a way to know how to
517                 # select a good random number for a given expression?
518                 # e.g. when calculating n! negative values for n should not
519                 # be used
520                 return None
521         else:
522             reps = {}
523             nmag = abs(self.evalf(2))
524 
525         if not hasattr(nmag, '_prec'):
526             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
527             return None
528 
529         if nmag._prec == 1:
530             # increase the precision up to the default maximum
531             # precision to see if we can get any significance
532 
533             from mpmath.libmp.libintmath import giant_steps
534             from sympy.core.evalf import DEFAULT_MAXPREC as target
535 
536             # evaluate
537             for prec in giant_steps(2, target):
538                 nmag = abs(self.evalf(prec, subs=reps))
539                 if nmag._prec != 1:
540                     break
541 
542         if nmag._prec != 1:
543             if n is None:
544                 n = max(prec, 15)
545             return self.evalf(n, subs=reps)
546 
547         # never got any significance
548         return None
549 
550     def is_constant(self, *wrt, **flags):
551         """Return True if self is constant, False if not, or None if
552         the constancy could not be determined conclusively.
553 
554         If an expression has no free symbols then it is a constant. If
555         there are free symbols it is possible that the expression is a
556         constant, perhaps (but not necessarily) zero. To test such
557         expressions, a few strategies are tried:
558 
559         1) numerical evaluation at two random points. If two such evaluations
560         give two different values and the values have a precision greater than
561         1 then self is not constant. If the evaluations agree or could not be
562         obtained with any precision, no decision is made. The numerical testing
563         is done only if ``wrt`` is different than the free symbols.
564 
565         2) differentiation with respect to variables in 'wrt' (or all free
566         symbols if omitted) to see if the expression is constant or not. This
567         will not always lead to an expression that is zero even though an
568         expression is constant (see added test in test_expr.py). If
569         all derivatives are zero then self is constant with respect to the
570         given symbols.
571 
572         3) finding out zeros of denominator expression with free_symbols.
573         It won't be constant if there are zeros. It gives more negative
574         answers for expression that are not constant.
575 
576         If neither evaluation nor differentiation can prove the expression is
577         constant, None is returned unless two numerical values happened to be
578         the same and the flag ``failing_number`` is True -- in that case the
579         numerical value will be returned.
580 
581         If flag simplify=False is passed, self will not be simplified;
582         the default is True since self should be simplified before testing.
583 
584         Examples
585         ========
586 
587         >>> from sympy import cos, sin, Sum, S, pi
588         >>> from sympy.abc import a, n, x, y
589         >>> x.is_constant()
590         False
591         >>> S(2).is_constant()
592         True
593         >>> Sum(x, (x, 1, 10)).is_constant()
594         True
595         >>> Sum(x, (x, 1, n)).is_constant()
596         False
597         >>> Sum(x, (x, 1, n)).is_constant(y)
598         True
599         >>> Sum(x, (x, 1, n)).is_constant(n)
600         False
601         >>> Sum(x, (x, 1, n)).is_constant(x)
602         True
603         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
604         >>> eq.is_constant()
605         True
606         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
607         True
608 
609         >>> (0**x).is_constant()
610         False
611         >>> x.is_constant()
612         False
613         >>> (x**x).is_constant()
614         False
615         >>> one = cos(x)**2 + sin(x)**2
616         >>> one.is_constant()
617         True
618         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
619         True
620         """
621 
622         def check_denominator_zeros(expression):
623             from sympy.solvers.solvers import denoms
624 
625             retNone = False
626             for den in denoms(expression):
627                 z = den.is_zero
628                 if z is True:
629                     return True
630                 if z is None:
631                     retNone = True
632             if retNone:
633                 return None
634             return False
635 
636         simplify = flags.get('simplify', True)
637 
638         if self.is_number:
639             return True
640         free = self.free_symbols
641         if not free:
642             return True  # assume f(1) is some constant
643 
644         # if we are only interested in some symbols and they are not in the
645         # free symbols then this expression is constant wrt those symbols
646         wrt = set(wrt)
647         if wrt and not wrt & free:
648             return True
649         wrt = wrt or free
650 
651         # simplify unless this has already been done
652         expr = self
653         if simplify:
654             expr = expr.simplify()
655 
656         # is_zero should be a quick assumptions check; it can be wrong for
657         # numbers (see test_is_not_constant test), giving False when it
658         # shouldn't, but hopefully it will never give True unless it is sure.
659         if expr.is_zero:
660             return True
661 
662         # try numerical evaluation to see if we get two different values
663         failing_number = None
664         if wrt == free:
665             # try 0 (for a) and 1 (for b)
666             try:
667                 a = expr.subs(list(zip(free, [0]*len(free))),
668                     simultaneous=True)
669                 if a is S.NaN:
670                     # evaluation may succeed when substitution fails
671                     a = expr._random(None, 0, 0, 0, 0)
672             except ZeroDivisionError:
673                 a = None
674             if a is not None and a is not S.NaN:
675                 try:
676                     b = expr.subs(list(zip(free, [1]*len(free))),
677                         simultaneous=True)
678                     if b is S.NaN:
679                         # evaluation may succeed when substitution fails
680                         b = expr._random(None, 1, 0, 1, 0)
681                 except ZeroDivisionError:
682                     b = None
683                 if b is not None and b is not S.NaN and b.equals(a) is False:
684                     return False
685                 # try random real
686                 b = expr._random(None, -1, 0, 1, 0)
687                 if b is not None and b is not S.NaN and b.equals(a) is False:
688                     return False
689                 # try random complex
690                 b = expr._random()
691                 if b is not None and b is not S.NaN:
692                     if b.equals(a) is False:
693                         return False
694                     failing_number = a if a.is_number else b
695 
696         # now we will test each wrt symbol (or all free symbols) to see if the
697         # expression depends on them or not using differentiation. This is
698         # not sufficient for all expressions, however, so we don't return
699         # False if we get a derivative other than 0 with free symbols.
700         for w in wrt:
701             deriv = expr.diff(w)
702             if simplify:
703                 deriv = deriv.simplify()
704             if deriv != 0:
705                 if not (pure_complex(deriv, or_real=True)):
706                     if flags.get('failing_number', False):
707                         return failing_number
708                     elif deriv.free_symbols:
709                         # dead line provided _random returns None in such cases
710                         return None
711                 return False
712         cd = check_denominator_zeros(self)
713         if cd is True:
714             return False
715         elif cd is None:
716             return None
717         return True
718 
719     def equals(self, other, failing_expression=False):
720         """Return True if self == other, False if it doesn't, or None. If
721         failing_expression is True then the expression which did not simplify
722         to a 0 will be returned instead of None.
723 
724         If ``self`` is a Number (or complex number) that is not zero, then
725         the result is False.
726 
727         If ``self`` is a number and has not evaluated to zero, evalf will be
728         used to test whether the expression evaluates to zero. If it does so
729         and the result has significance (i.e. the precision is either -1, for
730         a Rational result, or is greater than 1) then the evalf value will be
731         used to return True or False.
732 
733         """
734         from sympy.simplify.simplify import nsimplify, simplify
735         from sympy.solvers.solvers import solve
736         from sympy.polys.polyerrors import NotAlgebraic
737         from sympy.polys.numberfields import minimal_polynomial
738 
739         other = sympify(other)
740         if self == other:
741             return True
742 
743         # they aren't the same so see if we can make the difference 0;
744         # don't worry about doing simplification steps one at a time
745         # because if the expression ever goes to 0 then the subsequent
746         # simplification steps that are done will be very fast.
747         diff = factor_terms(simplify(self - other), radical=True)
748 
749         if not diff:
750             return True
751 
752         if not diff.has(Add, Mod):
753             # if there is no expanding to be done after simplifying
754             # then this can't be a zero
755             return False
756 
757         constant = diff.is_constant(simplify=False, failing_number=True)
758 
759         if constant is False:
760             return False
761 
762         if not diff.is_number:
763             if constant is None:
764                 # e.g. unless the right simplification is done, a symbolic
765                 # zero is possible (see expression of issue 6829: without
766                 # simplification constant will be None).
767                 return
768 
769         if constant is True:
770             # this gives a number whether there are free symbols or not
771             ndiff = diff._random()
772             # is_comparable will work whether the result is real
773             # or complex; it could be None, however.
774             if ndiff and ndiff.is_comparable:
775                 return False
776 
777         # sometimes we can use a simplified result to give a clue as to
778         # what the expression should be; if the expression is *not* zero
779         # then we should have been able to compute that and so now
780         # we can just consider the cases where the approximation appears
781         # to be zero -- we try to prove it via minimal_polynomial.
782         #
783         # removed
784         # ns = nsimplify(diff)
785         # if diff.is_number and (not ns or ns == diff):
786         #
787         # The thought was that if it nsimplifies to 0 that's a sure sign
788         # to try the following to prove it; or if it changed but wasn't
789         # zero that might be a sign that it's not going to be easy to
790         # prove. But tests seem to be working without that logic.
791         #
792         if diff.is_number:
793             # try to prove via self-consistency
794             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
795             # it seems to work better to try big ones first
796             surds.sort(key=lambda x: -x.args[0])
797             for s in surds:
798                 try:
799                     # simplify is False here -- this expression has already
800                     # been identified as being hard to identify as zero;
801                     # we will handle the checking ourselves using nsimplify
802                     # to see if we are in the right ballpark or not and if so
803                     # *then* the simplification will be attempted.
804                     sol = solve(diff, s, simplify=False)
805                     if sol:
806                         if s in sol:
807                             # the self-consistent result is present
808                             return True
809                         if all(si.is_Integer for si in sol):
810                             # perfect powers are removed at instantiation
811                             # so surd s cannot be an integer
812                             return False
813                         if all(i.is_algebraic is False for i in sol):
814                             # a surd is algebraic
815                             return False
816                         if any(si in surds for si in sol):
817                             # it wasn't equal to s but it is in surds
818                             # and different surds are not equal
819                             return False
820                         if any(nsimplify(s - si) == 0 and
821                                 simplify(s - si) == 0 for si in sol):
822                             return True
823                         if s.is_real:
824                             if any(nsimplify(si, [s]) == s and simplify(si) == s
825                                     for si in sol):
826                                 return True
827                 except NotImplementedError:
828                     pass
829 
830             # try to prove with minimal_polynomial but know when
831             # *not* to use this or else it can take a long time. e.g. issue 8354
832             if True:  # change True to condition that assures non-hang
833                 try:
834                     mp = minimal_polynomial(diff)
835                     if mp.is_Symbol:
836                         return True
837                     return False
838                 except (NotAlgebraic, NotImplementedError):
839                     pass
840 
841         # diff has not simplified to zero; constant is either None, True
842         # or the number with significance (is_comparable) that was randomly
843         # calculated twice as the same value.
844         if constant not in (True, None) and constant != 0:
845             return False
846 
847         if failing_expression:
848             return diff
849         return None
850 
851     def _eval_is_positive(self):
852         finite = self.is_finite
853         if finite is False:
854             return False
855         extended_positive = self.is_extended_positive
856         if finite is True:
857             return extended_positive
858         if extended_positive is False:
859             return False
860 
861     def _eval_is_negative(self):
862         finite = self.is_finite
863         if finite is False:
864             return False
865         extended_negative = self.is_extended_negative
866         if finite is True:
867             return extended_negative
868         if extended_negative is False:
869             return False
870 
871     def _eval_is_extended_positive_negative(self, positive):
872         from sympy.polys.numberfields import minimal_polynomial
873         from sympy.polys.polyerrors import NotAlgebraic
874         if self.is_number:
875             if self.is_extended_real is False:
876                 return False
877 
878             # check to see that we can get a value
879             try:
880                 n2 = self._eval_evalf(2)
881             # XXX: This shouldn't be caught here
882             # Catches ValueError: hypsum() failed to converge to the requested
883             # 34 bits of accuracy
884             except ValueError:
885                 return None
886             if n2 is None:
887                 return None
888             if getattr(n2, '_prec', 1) == 1:  # no significance
889                 return None
890             if n2 is S.NaN:
891                 return None
892 
893             r, i = self.evalf(2).as_real_imag()
894             if not i.is_Number or not r.is_Number:
895                 return False
896             if r._prec != 1 and i._prec != 1:
897                 return bool(not i and ((r > 0) if positive else (r < 0)))
898             elif r._prec == 1 and (not i or i._prec == 1) and \
899                     self.is_algebraic and not self.has(Function):
900                 try:
901                     if minimal_polynomial(self).is_Symbol:
902                         return False
903                 except (NotAlgebraic, NotImplementedError):
904                     pass
905 
906     def _eval_is_extended_positive(self):
907         return self._eval_is_extended_positive_negative(positive=True)
908 
909     def _eval_is_extended_negative(self):
910         return self._eval_is_extended_positive_negative(positive=False)
911 
912     def _eval_interval(self, x, a, b):
913         """
914         Returns evaluation over an interval.  For most functions this is:
915 
916         self.subs(x, b) - self.subs(x, a),
917 
918         possibly using limit() if NaN is returned from subs, or if
919         singularities are found between a and b.
920 
921         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
922         respectively.
923 
924         """
925         from sympy.series import limit, Limit
926         from sympy.solvers.solveset import solveset
927         from sympy.sets.sets import Interval
928         from sympy.functions.elementary.exponential import log
929         from sympy.calculus.util import AccumBounds
930 
931         if (a is None and b is None):
932             raise ValueError('Both interval ends cannot be None.')
933 
934         def _eval_endpoint(left):
935             c = a if left else b
936             if c is None:
937                 return 0
938             else:
939                 C = self.subs(x, c)
940                 if C.has(S.NaN, S.Infinity, S.NegativeInfinity,
941                          S.ComplexInfinity, AccumBounds):
942                     if (a < b) != False:
943                         C = limit(self, x, c, "+" if left else "-")
944                     else:
945                         C = limit(self, x, c, "-" if left else "+")
946 
947                     if isinstance(C, Limit):
948                         raise NotImplementedError("Could not compute limit")
949             return C
950 
951         if a == b:
952             return 0
953 
954         A = _eval_endpoint(left=True)
955         if A is S.NaN:
956             return A
957 
958         B = _eval_endpoint(left=False)
959 
960         if (a and b) is None:
961             return B - A
962 
963         value = B - A
964 
965         if a.is_comparable and b.is_comparable:
966             if a < b:
967                 domain = Interval(a, b)
968             else:
969                 domain = Interval(b, a)
970             # check the singularities of self within the interval
971             # if singularities is a ConditionSet (not iterable), catch the exception and pass
972             singularities = solveset(self.cancel().as_numer_denom()[1], x,
973                 domain=domain)
974             for logterm in self.atoms(log):
975                 singularities = singularities | solveset(logterm.args[0], x,
976                     domain=domain)
977             try:
978                 for s in singularities:
979                     if value is S.NaN:
980                         # no need to keep adding, it will stay NaN
981                         break
982                     if not s.is_comparable:
983                         continue
984                     if (a < s) == (s < b) == True:
985                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
986                     elif (b < s) == (s < a) == True:
987                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
988             except TypeError:
989                 pass
990 
991         return value
992 
993     def _eval_power(self, other):
994         # subclass to compute self**other for cases when
995         # other is not NaN, 0, or 1
996         return None
997 
998     def _eval_conjugate(self):
999         if self.is_extended_real:
1000             return self
1001         elif self.is_imaginary:
1002             return -self
1003 
1004     def conjugate(self):
1005         from sympy.functions.elementary.complexes import conjugate as c
1006         return c(self)
1007 
1008     def _eval_transpose(self):
1009         from sympy.functions.elementary.complexes import conjugate
1010         if (self.is_complex or self.is_infinite):
1011             return self
1012         elif self.is_hermitian:
1013             return conjugate(self)
1014         elif self.is_antihermitian:
1015             return -conjugate(self)
1016 
1017     def transpose(self):
1018         from sympy.functions.elementary.complexes import transpose
1019         return transpose(self)
1020 
1021     def _eval_adjoint(self):
1022         from sympy.functions.elementary.complexes import conjugate, transpose
1023         if self.is_hermitian:
1024             return self
1025         elif self.is_antihermitian:
1026             return -self
1027         obj = self._eval_conjugate()
1028         if obj is not None:
1029             return transpose(obj)
1030         obj = self._eval_transpose()
1031         if obj is not None:
1032             return conjugate(obj)
1033 
1034     def adjoint(self):
1035         from sympy.functions.elementary.complexes import adjoint
1036         return adjoint(self)
1037 
1038     @classmethod
1039     def _parse_order(cls, order):
1040         """Parse and configure the ordering of terms. """
1041         from sympy.polys.orderings import monomial_key
1042 
1043         startswith = getattr(order, "startswith", None)
1044         if startswith is None:
1045             reverse = False
1046         else:
1047             reverse = startswith('rev-')
1048             if reverse:
1049                 order = order[4:]
1050 
1051         monom_key = monomial_key(order)
1052 
1053         def neg(monom):
1054             result = []
1055 
1056             for m in monom:
1057                 if isinstance(m, tuple):
1058                     result.append(neg(m))
1059                 else:
1060                     result.append(-m)
1061 
1062             return tuple(result)
1063 
1064         def key(term):
1065             _, ((re, im), monom, ncpart) = term
1066 
1067             monom = neg(monom_key(monom))
1068             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1069             coeff = ((bool(im), im), (re, im))
1070 
1071             return monom, ncpart, coeff
1072 
1073         return key, reverse
1074 
1075     def as_ordered_factors(self, order=None):
1076         """Return list of ordered factors (if Mul) else [self]."""
1077         return [self]
1078 
1079     def as_ordered_terms(self, order=None, data=False):
1080         """
1081         Transform an expression to an ordered list of terms.
1082 
1083         Examples
1084         ========
1085 
1086         >>> from sympy import sin, cos
1087         >>> from sympy.abc import x
1088 
1089         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1090         [sin(x)**2*cos(x), sin(x)**2, 1]
1091 
1092         """
1093 
1094         from .numbers import Number, NumberSymbol
1095 
1096         if order is None and self.is_Add:
1097             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1098             # first number positive and thhe second number nagative
1099             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1100             add_args = sorted(Add.make_args(self), key=key)
1101             if (len(add_args) == 2
1102                 and isinstance(add_args[0], (Number, NumberSymbol))
1103                 and isinstance(add_args[1], Mul)):
1104                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1105                 if (len(mul_args) == 2
1106                     and isinstance(mul_args[0], Number)
1107                     and add_args[0].is_positive
1108                     and mul_args[0].is_negative):
1109                     return add_args
1110 
1111         key, reverse = self._parse_order(order)
1112         terms, gens = self.as_terms()
1113 
1114         if not any(term.is_Order for term, _ in terms):
1115             ordered = sorted(terms, key=key, reverse=reverse)
1116         else:
1117             _terms, _order = [], []
1118 
1119             for term, repr in terms:
1120                 if not term.is_Order:
1121                     _terms.append((term, repr))
1122                 else:
1123                     _order.append((term, repr))
1124 
1125             ordered = sorted(_terms, key=key, reverse=True) \
1126                 + sorted(_order, key=key, reverse=True)
1127 
1128         if data:
1129             return ordered, gens
1130         else:
1131             return [term for term, _ in ordered]
1132 
1133     def as_terms(self):
1134         """Transform an expression to a list of terms. """
1135         from .add import Add
1136         from .mul import Mul
1137         from .exprtools import decompose_power
1138 
1139         gens, terms = set([]), []
1140 
1141         for term in Add.make_args(self):
1142             coeff, _term = term.as_coeff_Mul()
1143 
1144             coeff = complex(coeff)
1145             cpart, ncpart = {}, []
1146 
1147             if _term is not S.One:
1148                 for factor in Mul.make_args(_term):
1149                     if factor.is_number:
1150                         try:
1151                             coeff *= complex(factor)
1152                         except (TypeError, ValueError):
1153                             pass
1154                         else:
1155                             continue
1156 
1157                     if factor.is_commutative:
1158                         base, exp = decompose_power(factor)
1159 
1160                         cpart[base] = exp
1161                         gens.add(base)
1162                     else:
1163                         ncpart.append(factor)
1164 
1165             coeff = coeff.real, coeff.imag
1166             ncpart = tuple(ncpart)
1167 
1168             terms.append((term, (coeff, cpart, ncpart)))
1169 
1170         gens = sorted(gens, key=default_sort_key)
1171 
1172         k, indices = len(gens), {}
1173 
1174         for i, g in enumerate(gens):
1175             indices[g] = i
1176 
1177         result = []
1178 
1179         for term, (coeff, cpart, ncpart) in terms:
1180             monom = [0]*k
1181 
1182             for base, exp in cpart.items():
1183                 monom[indices[base]] = exp
1184 
1185             result.append((term, (coeff, tuple(monom), ncpart)))
1186 
1187         return result, gens
1188 
1189     def removeO(self):
1190         """Removes the additive O(..) symbol if there is one"""
1191         return self
1192 
1193     def getO(self):
1194         """Returns the additive O(..) symbol if there is one, else None."""
1195         return None
1196 
1197     def getn(self):
1198         """
1199         Returns the order of the expression.
1200 
1201         The order is determined either from the O(...) term. If there
1202         is no O(...) term, it returns None.
1203 
1204         Examples
1205         ========
1206 
1207         >>> from sympy import O
1208         >>> from sympy.abc import x
1209         >>> (1 + x + O(x**2)).getn()
1210         2
1211         >>> (1 + x).getn()
1212 
1213         """
1214         from sympy import Dummy, Symbol
1215         o = self.getO()
1216         if o is None:
1217             return None
1218         elif o.is_Order:
1219             o = o.expr
1220             if o is S.One:
1221                 return S.Zero
1222             if o.is_Symbol:
1223                 return S.One
1224             if o.is_Pow:
1225                 return o.args[1]
1226             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1227                 for oi in o.args:
1228                     if oi.is_Symbol:
1229                         return S.One
1230                     if oi.is_Pow:
1231                         syms = oi.atoms(Symbol)
1232                         if len(syms) == 1:
1233                             x = syms.pop()
1234                             oi = oi.subs(x, Dummy('x', positive=True))
1235                             if oi.base.is_Symbol and oi.exp.is_Rational:
1236                                 return abs(oi.exp)
1237 
1238         raise NotImplementedError('not sure of order of %s' % o)
1239 
1240     def count_ops(self, visual=None):
1241         """wrapper for count_ops that returns the operation count."""
1242         from .function import count_ops
1243         return count_ops(self, visual)
1244 
1245     def args_cnc(self, cset=False, warn=True, split_1=True):
1246         """Return [commutative factors, non-commutative factors] of self.
1247 
1248         self is treated as a Mul and the ordering of the factors is maintained.
1249         If ``cset`` is True the commutative factors will be returned in a set.
1250         If there were repeated factors (as may happen with an unevaluated Mul)
1251         then an error will be raised unless it is explicitly suppressed by
1252         setting ``warn`` to False.
1253 
1254         Note: -1 is always separated from a Number unless split_1 is False.
1255 
1256         >>> from sympy import symbols, oo
1257         >>> A, B = symbols('A B', commutative=0)
1258         >>> x, y = symbols('x y')
1259         >>> (-2*x*y).args_cnc()
1260         [[-1, 2, x, y], []]
1261         >>> (-2.5*x).args_cnc()
1262         [[-1, 2.5, x], []]
1263         >>> (-2*x*A*B*y).args_cnc()
1264         [[-1, 2, x, y], [A, B]]
1265         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1266         [[-2, x, y], [A, B]]
1267         >>> (-2*x*y).args_cnc(cset=True)
1268         [{-1, 2, x, y}, []]
1269 
1270         The arg is always treated as a Mul:
1271 
1272         >>> (-2 + x + A).args_cnc()
1273         [[], [x - 2 + A]]
1274         >>> (-oo).args_cnc() # -oo is a singleton
1275         [[-1, oo], []]
1276         """
1277 
1278         if self.is_Mul:
1279             args = list(self.args)
1280         else:
1281             args = [self]
1282         for i, mi in enumerate(args):
1283             if not mi.is_commutative:
1284                 c = args[:i]
1285                 nc = args[i:]
1286                 break
1287         else:
1288             c = args
1289             nc = []
1290 
1291         if c and split_1 and (
1292             c[0].is_Number and
1293             c[0].is_extended_negative and
1294                 c[0] is not S.NegativeOne):
1295             c[:1] = [S.NegativeOne, -c[0]]
1296 
1297         if cset:
1298             clen = len(c)
1299             c = set(c)
1300             if clen and warn and len(c) != clen:
1301                 raise ValueError('repeated commutative arguments: %s' %
1302                                  [ci for ci in c if list(self.args).count(ci) > 1])
1303         return [c, nc]
1304 
1305     def coeff(self, x, n=1, right=False):
1306         """
1307         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1308         is zero then all terms independent of ``x`` will be returned.
1309 
1310         When ``x`` is noncommutative, the coefficient to the left (default) or
1311         right of ``x`` can be returned. The keyword 'right' is ignored when
1312         ``x`` is commutative.
1313 
1314         See Also
1315         ========
1316 
1317         as_coefficient: separate the expression into a coefficient and factor
1318         as_coeff_Add: separate the additive constant from an expression
1319         as_coeff_Mul: separate the multiplicative constant from an expression
1320         as_independent: separate x-dependent terms/factors from others
1321         sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1322         sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used
1323 
1324         Examples
1325         ========
1326 
1327         >>> from sympy import symbols
1328         >>> from sympy.abc import x, y, z
1329 
1330         You can select terms that have an explicit negative in front of them:
1331 
1332         >>> (-x + 2*y).coeff(-1)
1333         x
1334         >>> (x - 2*y).coeff(-1)
1335         2*y
1336 
1337         You can select terms with no Rational coefficient:
1338 
1339         >>> (x + 2*y).coeff(1)
1340         x
1341         >>> (3 + 2*x + 4*x**2).coeff(1)
1342         0
1343 
1344         You can select terms independent of x by making n=0; in this case
1345         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1346         of None):
1347 
1348         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1349         3
1350         >>> eq = ((x + 1)**3).expand() + 1
1351         >>> eq
1352         x**3 + 3*x**2 + 3*x + 2
1353         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1354         [1, 3, 3, 2]
1355         >>> eq -= 2
1356         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1357         [1, 3, 3, 0]
1358 
1359         You can select terms that have a numerical term in front of them:
1360 
1361         >>> (-x - 2*y).coeff(2)
1362         -y
1363         >>> from sympy import sqrt
1364         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1365         x
1366 
1367         The matching is exact:
1368 
1369         >>> (3 + 2*x + 4*x**2).coeff(x)
1370         2
1371         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1372         4
1373         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1374         0
1375         >>> (z*(x + y)**2).coeff((x + y)**2)
1376         z
1377         >>> (z*(x + y)**2).coeff(x + y)
1378         0
1379 
1380         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1381         from the following:
1382 
1383         >>> (x + z*(x + x*y)).coeff(x)
1384         1
1385 
1386         If such factoring is desired, factor_terms can be used first:
1387 
1388         >>> from sympy import factor_terms
1389         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1390         z*(y + 1) + 1
1391 
1392         >>> n, m, o = symbols('n m o', commutative=False)
1393         >>> n.coeff(n)
1394         1
1395         >>> (3*n).coeff(n)
1396         3
1397         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1398         1 + m
1399         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1400         m
1401 
1402         If there is more than one possible coefficient 0 is returned:
1403 
1404         >>> (n*m + m*n).coeff(n)
1405         0
1406 
1407         If there is only one possible coefficient, it is returned:
1408 
1409         >>> (n*m + x*m*n).coeff(m*n)
1410         x
1411         >>> (n*m + x*m*n).coeff(m*n, right=1)
1412         1
1413 
1414         """
1415         x = sympify(x)
1416         if not isinstance(x, Basic):
1417             return S.Zero
1418 
1419         n = as_int(n)
1420 
1421         if not x:
1422             return S.Zero
1423 
1424         if x == self:
1425             if n == 1:
1426                 return S.One
1427             return S.Zero
1428 
1429         if x is S.One:
1430             co = [a for a in Add.make_args(self)
1431                   if a.as_coeff_Mul()[0] is S.One]
1432             if not co:
1433                 return S.Zero
1434             return Add(*co)
1435 
1436         if n == 0:
1437             if x.is_Add and self.is_Add:
1438                 c = self.coeff(x, right=right)
1439                 if not c:
1440                     return S.Zero
1441                 if not right:
1442                     return self - Add(*[a*x for a in Add.make_args(c)])
1443                 return self - Add(*[x*a for a in Add.make_args(c)])
1444             return self.as_independent(x, as_Add=True)[0]
1445 
1446         # continue with the full method, looking for this power of x:
1447         x = x**n
1448 
1449         def incommon(l1, l2):
1450             if not l1 or not l2:
1451                 return []
1452             n = min(len(l1), len(l2))
1453             for i in range(n):
1454                 if l1[i] != l2[i]:
1455                     return l1[:i]
1456             return l1[:]
1457 
1458         def find(l, sub, first=True):
1459             """ Find where list sub appears in list l. When ``first`` is True
1460             the first occurrence from the left is returned, else the last
1461             occurrence is returned. Return None if sub is not in l.
1462 
1463             >> l = range(5)*2
1464             >> find(l, [2, 3])
1465             2
1466             >> find(l, [2, 3], first=0)
1467             7
1468             >> find(l, [2, 4])
1469             None
1470 
1471             """
1472             if not sub or not l or len(sub) > len(l):
1473                 return None
1474             n = len(sub)
1475             if not first:
1476                 l.reverse()
1477                 sub.reverse()
1478             for i in range(0, len(l) - n + 1):
1479                 if all(l[i + j] == sub[j] for j in range(n)):
1480                     break
1481             else:
1482                 i = None
1483             if not first:
1484                 l.reverse()
1485                 sub.reverse()
1486             if i is not None and not first:
1487                 i = len(l) - (i + n)
1488             return i
1489 
1490         co = []
1491         args = Add.make_args(self)
1492         self_c = self.is_commutative
1493         x_c = x.is_commutative
1494         if self_c and not x_c:
1495             return S.Zero
1496 
1497         one_c = self_c or x_c
1498         xargs, nx = x.args_cnc(cset=True, warn=bool(not x_c))
1499         # find the parts that pass the commutative terms
1500         for a in args:
1501             margs, nc = a.args_cnc(cset=True, warn=bool(not self_c))
1502             if nc is None:
1503                 nc = []
1504             if len(xargs) > len(margs):
1505                 continue
1506             resid = margs.difference(xargs)
1507             if len(resid) + len(xargs) == len(margs):
1508                 if one_c:
1509                     co.append(Mul(*(list(resid) + nc)))
1510                 else:
1511                     co.append((resid, nc))
1512         if one_c:
1513             if co == []:
1514                 return S.Zero
1515             elif co:
1516                 return Add(*co)
1517         else:  # both nc
1518             # now check the non-comm parts
1519             if not co:
1520                 return S.Zero
1521             if all(n == co[0][1] for r, n in co):
1522                 ii = find(co[0][1], nx, right)
1523                 if ii is not None:
1524                     if not right:
1525                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1526                     else:
1527                         return Mul(*co[0][1][ii + len(nx):])
1528             beg = reduce(incommon, (n[1] for n in co))
1529             if beg:
1530                 ii = find(beg, nx, right)
1531                 if ii is not None:
1532                     if not right:
1533                         gcdc = co[0][0]
1534                         for i in range(1, len(co)):
1535                             gcdc = gcdc.intersection(co[i][0])
1536                             if not gcdc:
1537                                 break
1538                         return Mul(*(list(gcdc) + beg[:ii]))
1539                     else:
1540                         m = ii + len(nx)
1541                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1542             end = list(reversed(
1543                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1544             if end:
1545                 ii = find(end, nx, right)
1546                 if ii is not None:
1547                     if not right:
1548                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1549                     else:
1550                         return Mul(*end[ii + len(nx):])
1551             # look for single match
1552             hit = None
1553             for i, (r, n) in enumerate(co):
1554                 ii = find(n, nx, right)
1555                 if ii is not None:
1556                     if not hit:
1557                         hit = ii, r, n
1558                     else:
1559                         break
1560             else:
1561                 if hit:
1562                     ii, r, n = hit
1563                     if not right:
1564                         return Mul(*(list(r) + n[:ii]))
1565                     else:
1566                         return Mul(*n[ii + len(nx):])
1567 
1568             return S.Zero
1569 
1570     def as_expr(self, *gens):
1571         """
1572         Convert a polynomial to a SymPy expression.
1573 
1574         Examples
1575         ========
1576 
1577         >>> from sympy import sin
1578         >>> from sympy.abc import x, y
1579 
1580         >>> f = (x**2 + x*y).as_poly(x, y)
1581         >>> f.as_expr()
1582         x**2 + x*y
1583 
1584         >>> sin(x).as_expr()
1585         sin(x)
1586 
1587         """
1588         return self
1589 
1590     def as_coefficient(self, expr):
1591         """
1592         Extracts symbolic coefficient at the given expression. In
1593         other words, this functions separates 'self' into the product
1594         of 'expr' and 'expr'-free coefficient. If such separation
1595         is not possible it will return None.
1596 
1597         Examples
1598         ========
1599 
1600         >>> from sympy import E, pi, sin, I, Poly
1601         >>> from sympy.abc import x
1602 
1603         >>> E.as_coefficient(E)
1604         1
1605         >>> (2*E).as_coefficient(E)
1606         2
1607         >>> (2*sin(E)*E).as_coefficient(E)
1608 
1609         Two terms have E in them so a sum is returned. (If one were
1610         desiring the coefficient of the term exactly matching E then
1611         the constant from the returned expression could be selected.
1612         Or, for greater precision, a method of Poly can be used to
1613         indicate the desired term from which the coefficient is
1614         desired.)
1615 
1616         >>> (2*E + x*E).as_coefficient(E)
1617         x + 2
1618         >>> _.args[0]  # just want the exact match
1619         2
1620         >>> p = Poly(2*E + x*E); p
1621         Poly(x*E + 2*E, x, E, domain='ZZ')
1622         >>> p.coeff_monomial(E)
1623         2
1624         >>> p.nth(0, 1)
1625         2
1626 
1627         Since the following cannot be written as a product containing
1628         E as a factor, None is returned. (If the coefficient ``2*x`` is
1629         desired then the ``coeff`` method should be used.)
1630 
1631         >>> (2*E*x + x).as_coefficient(E)
1632         >>> (2*E*x + x).coeff(E)
1633         2*x
1634 
1635         >>> (E*(x + 1) + x).as_coefficient(E)
1636 
1637         >>> (2*pi*I).as_coefficient(pi*I)
1638         2
1639         >>> (2*I).as_coefficient(pi*I)
1640 
1641         See Also
1642         ========
1643 
1644         coeff: return sum of terms have a given factor
1645         as_coeff_Add: separate the additive constant from an expression
1646         as_coeff_Mul: separate the multiplicative constant from an expression
1647         as_independent: separate x-dependent terms/factors from others
1648         sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1649         sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used
1650 
1651 
1652         """
1653 
1654         r = self.extract_multiplicatively(expr)
1655         if r and not r.has(expr):
1656             return r
1657 
1658     def as_independent(self, *deps, **hint):
1659         """
1660         A mostly naive separation of a Mul or Add into arguments that are not
1661         are dependent on deps. To obtain as complete a separation of variables
1662         as possible, use a separation method first, e.g.:
1663 
1664         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1665         * .expand(mul=True) to change Add or Mul into Add
1666         * .expand(log=True) to change log expr into an Add
1667 
1668         The only non-naive thing that is done here is to respect noncommutative
1669         ordering of variables and to always return (0, 0) for `self` of zero
1670         regardless of hints.
1671 
1672         For nonzero `self`, the returned tuple (i, d) has the
1673         following interpretation:
1674 
1675         * i will has no variable that appears in deps
1676         * d will either have terms that contain variables that are in deps, or
1677           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1678         * if self is an Add then self = i + d
1679         * if self is a Mul then self = i*d
1680         * otherwise (self, S.One) or (S.One, self) is returned.
1681 
1682         To force the expression to be treated as an Add, use the hint as_Add=True
1683 
1684         Examples
1685         ========
1686 
1687         -- self is an Add
1688 
1689         >>> from sympy import sin, cos, exp
1690         >>> from sympy.abc import x, y, z
1691 
1692         >>> (x + x*y).as_independent(x)
1693         (0, x*y + x)
1694         >>> (x + x*y).as_independent(y)
1695         (x, x*y)
1696         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1697         (y + z, 2*x*sin(x) + x)
1698         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1699         (z, 2*x*sin(x) + x + y)
1700 
1701         -- self is a Mul
1702 
1703         >>> (x*sin(x)*cos(y)).as_independent(x)
1704         (cos(y), x*sin(x))
1705 
1706         non-commutative terms cannot always be separated out when self is a Mul
1707 
1708         >>> from sympy import symbols
1709         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1710         >>> (n1 + n1*n2).as_independent(n2)
1711         (n1, n1*n2)
1712         >>> (n2*n1 + n1*n2).as_independent(n2)
1713         (0, n1*n2 + n2*n1)
1714         >>> (n1*n2*n3).as_independent(n1)
1715         (1, n1*n2*n3)
1716         >>> (n1*n2*n3).as_independent(n2)
1717         (n1, n2*n3)
1718         >>> ((x-n1)*(x-y)).as_independent(x)
1719         (1, (x - y)*(x - n1))
1720 
1721         -- self is anything else:
1722 
1723         >>> (sin(x)).as_independent(x)
1724         (1, sin(x))
1725         >>> (sin(x)).as_independent(y)
1726         (sin(x), 1)
1727         >>> exp(x+y).as_independent(x)
1728         (1, exp(x + y))
1729 
1730         -- force self to be treated as an Add:
1731 
1732         >>> (3*x).as_independent(x, as_Add=True)
1733         (0, 3*x)
1734 
1735         -- force self to be treated as a Mul:
1736 
1737         >>> (3+x).as_independent(x, as_Add=False)
1738         (1, x + 3)
1739         >>> (-3+x).as_independent(x, as_Add=False)
1740         (1, x - 3)
1741 
1742         Note how the below differs from the above in making the
1743         constant on the dep term positive.
1744 
1745         >>> (y*(-3+x)).as_independent(x)
1746         (y, x - 3)
1747 
1748         -- use .as_independent() for true independence testing instead
1749            of .has(). The former considers only symbols in the free
1750            symbols while the latter considers all symbols
1751 
1752         >>> from sympy import Integral
1753         >>> I = Integral(x, (x, 1, 2))
1754         >>> I.has(x)
1755         True
1756         >>> x in I.free_symbols
1757         False
1758         >>> I.as_independent(x) == (I, 1)
1759         True
1760         >>> (I + x).as_independent(x) == (I, x)
1761         True
1762 
1763         Note: when trying to get independent terms, a separation method
1764         might need to be used first. In this case, it is important to keep
1765         track of what you send to this routine so you know how to interpret
1766         the returned values
1767 
1768         >>> from sympy import separatevars, log
1769         >>> separatevars(exp(x+y)).as_independent(x)
1770         (exp(y), exp(x))
1771         >>> (x + x*y).as_independent(y)
1772         (x, x*y)
1773         >>> separatevars(x + x*y).as_independent(y)
1774         (x, y + 1)
1775         >>> (x*(1 + y)).as_independent(y)
1776         (x, y + 1)
1777         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1778         (x, x*y)
1779         >>> a, b=symbols('a b', positive=True)
1780         >>> (log(a*b).expand(log=True)).as_independent(b)
1781         (log(a), log(b))
1782 
1783         See Also
1784         ========
1785         .separatevars(), .expand(log=True), sympy.core.add.Add.as_two_terms(),
1786         sympy.core.mul.Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1787         """
1788         from .symbol import Symbol
1789         from .add import _unevaluated_Add
1790         from .mul import _unevaluated_Mul
1791         from sympy.utilities.iterables import sift
1792 
1793         if self.is_zero:
1794             return S.Zero, S.Zero
1795 
1796         func = self.func
1797         if hint.get('as_Add', isinstance(self, Add) ):
1798             want = Add
1799         else:
1800             want = Mul
1801 
1802         # sift out deps into symbolic and other and ignore
1803         # all symbols but those that are in the free symbols
1804         sym = set()
1805         other = []
1806         for d in deps:
1807             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1808                 sym.add(d)
1809             else:
1810                 other.append(d)
1811 
1812         def has(e):
1813             """return the standard has() if there are no literal symbols, else
1814             check to see that symbol-deps are in the free symbols."""
1815             has_other = e.has(*other)
1816             if not sym:
1817                 return has_other
1818             return has_other or e.has(*(e.free_symbols & sym))
1819 
1820         if (want is not func or
1821                 func is not Add and func is not Mul):
1822             if has(self):
1823                 return (want.identity, self)
1824             else:
1825                 return (self, want.identity)
1826         else:
1827             if func is Add:
1828                 args = list(self.args)
1829             else:
1830                 args, nc = self.args_cnc()
1831 
1832         d = sift(args, lambda x: has(x))
1833         depend = d[True]
1834         indep = d[False]
1835         if func is Add:  # all terms were treated as commutative
1836             return (Add(*indep), _unevaluated_Add(*depend))
1837         else:  # handle noncommutative by stopping at first dependent term
1838             for i, n in enumerate(nc):
1839                 if has(n):
1840                     depend.extend(nc[i:])
1841                     break
1842                 indep.append(n)
1843             return Mul(*indep), (
1844                 Mul(*depend, evaluate=False) if nc else
1845                 _unevaluated_Mul(*depend))
1846 
1847     def as_real_imag(self, deep=True, **hints):
1848         """Performs complex expansion on 'self' and returns a tuple
1849            containing collected both real and imaginary parts. This
1850            method can't be confused with re() and im() functions,
1851            which does not perform complex expansion at evaluation.
1852 
1853            However it is possible to expand both re() and im()
1854            functions and get exactly the same results as with
1855            a single call to this function.
1856 
1857            >>> from sympy import symbols, I
1858 
1859            >>> x, y = symbols('x,y', real=True)
1860 
1861            >>> (x + y*I).as_real_imag()
1862            (x, y)
1863 
1864            >>> from sympy.abc import z, w
1865 
1866            >>> (z + w*I).as_real_imag()
1867            (re(z) - im(w), re(w) + im(z))
1868 
1869         """
1870         from sympy import im, re
1871         if hints.get('ignore') == self:
1872             return None
1873         else:
1874             return (re(self), im(self))
1875 
1876     def as_powers_dict(self):
1877         """Return self as a dictionary of factors with each factor being
1878         treated as a power. The keys are the bases of the factors and the
1879         values, the corresponding exponents. The resulting dictionary should
1880         be used with caution if the expression is a Mul and contains non-
1881         commutative factors since the order that they appeared will be lost in
1882         the dictionary.
1883 
1884         See Also
1885         ========
1886         as_ordered_factors: An alternative for noncommutative applications,
1887                             returning an ordered list of factors.
1888         args_cnc: Similar to as_ordered_factors, but guarantees separation
1889                   of commutative and noncommutative factors.
1890         """
1891         d = defaultdict(int)
1892         d.update(dict([self.as_base_exp()]))
1893         return d
1894 
1895     def as_coefficients_dict(self):
1896         """Return a dictionary mapping terms to their Rational coefficient.
1897         Since the dictionary is a defaultdict, inquiries about terms which
1898         were not present will return a coefficient of 0. If an expression is
1899         not an Add it is considered to have a single term.
1900 
1901         Examples
1902         ========
1903 
1904         >>> from sympy.abc import a, x
1905         >>> (3*x + a*x + 4).as_coefficients_dict()
1906         {1: 4, x: 3, a*x: 1}
1907         >>> _[a]
1908         0
1909         >>> (3*a*x).as_coefficients_dict()
1910         {a*x: 3}
1911 
1912         """
1913         c, m = self.as_coeff_Mul()
1914         if not c.is_Rational:
1915             c = S.One
1916             m = self
1917         d = defaultdict(int)
1918         d.update({m: c})
1919         return d
1920 
1921     def as_base_exp(self):
1922         # a -> b ** e
1923         return self, S.One
1924 
1925     def as_coeff_mul(self, *deps, **kwargs):
1926         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1927 
1928         c should be a Rational multiplied by any factors of the Mul that are
1929         independent of deps.
1930 
1931         args should be a tuple of all other factors of m; args is empty
1932         if self is a Number or if self is independent of deps (when given).
1933 
1934         This should be used when you don't know if self is a Mul or not but
1935         you want to treat self as a Mul or if you want to process the
1936         individual arguments of the tail of self as a Mul.
1937 
1938         - if you know self is a Mul and want only the head, use self.args[0];
1939         - if you don't want to process the arguments of the tail but need the
1940           tail then use self.as_two_terms() which gives the head and tail;
1941         - if you want to split self into an independent and dependent parts
1942           use ``self.as_independent(*deps)``
1943 
1944         >>> from sympy import S
1945         >>> from sympy.abc import x, y
1946         >>> (S(3)).as_coeff_mul()
1947         (3, ())
1948         >>> (3*x*y).as_coeff_mul()
1949         (3, (x, y))
1950         >>> (3*x*y).as_coeff_mul(x)
1951         (3*y, (x,))
1952         >>> (3*y).as_coeff_mul(x)
1953         (3*y, ())
1954         """
1955         if deps:
1956             if not self.has(*deps):
1957                 return self, tuple()
1958         return S.One, (self,)
1959 
1960     def as_coeff_add(self, *deps):
1961         """Return the tuple (c, args) where self is written as an Add, ``a``.
1962 
1963         c should be a Rational added to any terms of the Add that are
1964         independent of deps.
1965 
1966         args should be a tuple of all other terms of ``a``; args is empty
1967         if self is a Number or if self is independent of deps (when given).
1968 
1969         This should be used when you don't know if self is an Add or not but
1970         you want to treat self as an Add or if you want to process the
1971         individual arguments of the tail of self as an Add.
1972 
1973         - if you know self is an Add and want only the head, use self.args[0];
1974         - if you don't want to process the arguments of the tail but need the
1975           tail then use self.as_two_terms() which gives the head and tail.
1976         - if you want to split self into an independent and dependent parts
1977           use ``self.as_independent(*deps)``
1978 
1979         >>> from sympy import S
1980         >>> from sympy.abc import x, y
1981         >>> (S(3)).as_coeff_add()
1982         (3, ())
1983         >>> (3 + x).as_coeff_add()
1984         (3, (x,))
1985         >>> (3 + x + y).as_coeff_add(x)
1986         (y + 3, (x,))
1987         >>> (3 + y).as_coeff_add(x)
1988         (y + 3, ())
1989 
1990         """
1991         if deps:
1992             if not self.has(*deps):
1993                 return self, tuple()
1994         return S.Zero, (self,)
1995 
1996     def primitive(self):
1997         """Return the positive Rational that can be extracted non-recursively
1998         from every term of self (i.e., self is treated like an Add). This is
1999         like the as_coeff_Mul() method but primitive always extracts a positive
2000         Rational (never a negative or a Float).
2001 
2002         Examples
2003         ========
2004 
2005         >>> from sympy.abc import x
2006         >>> (3*(x + 1)**2).primitive()
2007         (3, (x + 1)**2)
2008         >>> a = (6*x + 2); a.primitive()
2009         (2, 3*x + 1)
2010         >>> b = (x/2 + 3); b.primitive()
2011         (1/2, x + 6)
2012         >>> (a*b).primitive() == (1, a*b)
2013         True
2014         """
2015         if not self:
2016             return S.One, S.Zero
2017         c, r = self.as_coeff_Mul(rational=True)
2018         if c.is_negative:
2019             c, r = -c, -r
2020         return c, r
2021 
2022     def as_content_primitive(self, radical=False, clear=True):
2023         """This method should recursively remove a Rational from all arguments
2024         and return that (content) and the new self (primitive). The content
2025         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2026         The primitive need not be in canonical form and should try to preserve
2027         the underlying structure if possible (i.e. expand_mul should not be
2028         applied to self).
2029 
2030         Examples
2031         ========
2032 
2033         >>> from sympy import sqrt
2034         >>> from sympy.abc import x, y, z
2035 
2036         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2037 
2038         The as_content_primitive function is recursive and retains structure:
2039 
2040         >>> eq.as_content_primitive()
2041         (2, x + 3*y*(y + 1) + 1)
2042 
2043         Integer powers will have Rationals extracted from the base:
2044 
2045         >>> ((2 + 6*x)**2).as_content_primitive()
2046         (4, (3*x + 1)**2)
2047         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2048         (1, (2*(3*x + 1))**(2*y))
2049 
2050         Terms may end up joining once their as_content_primitives are added:
2051 
2052         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2053         (11, x*(y + 1))
2054         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2055         (9, x*(y + 1))
2056         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2057         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2058         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2059         (121, x**2*(y + 1)**2)
2060         >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()
2061         (1, 4.84*x**2*(y + 1)**2)
2062 
2063         Radical content can also be factored out of the primitive:
2064 
2065         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2066         (2, sqrt(2)*(1 + 2*sqrt(5)))
2067 
2068         If clear=False (default is True) then content will not be removed
2069         from an Add if it can be distributed to leave one or more
2070         terms with integer coefficients.
2071 
2072         >>> (x/2 + y).as_content_primitive()
2073         (1/2, x + 2*y)
2074         >>> (x/2 + y).as_content_primitive(clear=False)
2075         (1, x/2 + y)
2076         """
2077         return S.One, self
2078 
2079     def as_numer_denom(self):
2080         """ expression -> a/b -> a, b
2081 
2082         This is just a stub that should be defined by
2083         an object's class methods to get anything else.
2084 
2085         See Also
2086         ========
2087         normal: return a/b instead of a, b
2088         """
2089 
2090         return self, S.One
2091 
2092     def normal(self):
2093         from .mul import _unevaluated_Mul
2094         n, d = self.as_numer_denom()
2095         if d is S.One:
2096             return n
2097         if d.is_Number:
2098             return _unevaluated_Mul(n, 1/d)
2099         else:
2100             return n/d
2101 
2102     def extract_multiplicatively(self, c):
2103         """Return None if it's not possible to make self in the form
2104            c * something in a nice way, i.e. preserving the properties
2105            of arguments of self.
2106 
2107            Examples
2108            ========
2109 
2110            >>> from sympy import symbols, Rational
2111 
2112            >>> x, y = symbols('x,y', real=True)
2113 
2114            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2115            x*y**2
2116 
2117            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2118 
2119            >>> (2*x).extract_multiplicatively(2)
2120            x
2121 
2122            >>> (2*x).extract_multiplicatively(3)
2123 
2124            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2125            x/6
2126 
2127         """
2128         from .add import _unevaluated_Add
2129         c = sympify(c)
2130         if self is S.NaN:
2131             return None
2132         if c is S.One:
2133             return self
2134         elif c == self:
2135             return S.One
2136 
2137         if c.is_Add:
2138             cc, pc = c.primitive()
2139             if cc is not S.One:
2140                 c = Mul(cc, pc, evaluate=False)
2141 
2142         if c.is_Mul:
2143             a, b = c.as_two_terms()
2144             x = self.extract_multiplicatively(a)
2145             if x is not None:
2146                 return x.extract_multiplicatively(b)
2147             else:
2148                 return x
2149 
2150         quotient = self / c
2151         if self.is_Number:
2152             if self is S.Infinity:
2153                 if c.is_positive:
2154                     return S.Infinity
2155             elif self is S.NegativeInfinity:
2156                 if c.is_negative:
2157                     return S.Infinity
2158                 elif c.is_positive:
2159                     return S.NegativeInfinity
2160             elif self is S.ComplexInfinity:
2161                 if not c.is_zero:
2162                     return S.ComplexInfinity
2163             elif self.is_Integer:
2164                 if not quotient.is_Integer:
2165                     return None
2166                 elif self.is_positive and quotient.is_negative:
2167                     return None
2168                 else:
2169                     return quotient
2170             elif self.is_Rational:
2171                 if not quotient.is_Rational:
2172                     return None
2173                 elif self.is_positive and quotient.is_negative:
2174                     return None
2175                 else:
2176                     return quotient
2177             elif self.is_Float:
2178                 if not quotient.is_Float:
2179                     return None
2180                 elif self.is_positive and quotient.is_negative:
2181                     return None
2182                 else:
2183                     return quotient
2184         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2185             if quotient.is_Mul and len(quotient.args) == 2:
2186                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2187                     return quotient
2188             elif quotient.is_Integer and c.is_Number:
2189                 return quotient
2190         elif self.is_Add:
2191             cs, ps = self.primitive()
2192             # assert cs >= 1
2193             if c.is_Number and c is not S.NegativeOne:
2194                 # assert c != 1 (handled at top)
2195                 if cs is not S.One:
2196                     if c.is_negative:
2197                         xc = -(cs.extract_multiplicatively(-c))
2198                     else:
2199                         xc = cs.extract_multiplicatively(c)
2200                     if xc is not None:
2201                         return xc*ps  # rely on 2-arg Mul to restore Add
2202                 return  # |c| != 1 can only be extracted from cs
2203             if c == ps:
2204                 return cs
2205             # check args of ps
2206             newargs = []
2207             for arg in ps.args:
2208                 newarg = arg.extract_multiplicatively(c)
2209                 if newarg is None:
2210                     return  # all or nothing
2211                 newargs.append(newarg)
2212             if cs is not S.One:
2213                 args = [cs*t for t in newargs]
2214                 # args may be in different order
2215                 return _unevaluated_Add(*args)
2216             else:
2217                 return Add._from_args(newargs)
2218         elif self.is_Mul:
2219             args = list(self.args)
2220             for i, arg in enumerate(args):
2221                 newarg = arg.extract_multiplicatively(c)
2222                 if newarg is not None:
2223                     args[i] = newarg
2224                     return Mul(*args)
2225         elif self.is_Pow:
2226             if c.is_Pow and c.base == self.base:
2227                 new_exp = self.exp.extract_additively(c.exp)
2228                 if new_exp is not None:
2229                     return self.base ** (new_exp)
2230             elif c == self.base:
2231                 new_exp = self.exp.extract_additively(1)
2232                 if new_exp is not None:
2233                     return self.base ** (new_exp)
2234 
2235     def extract_additively(self, c):
2236         """Return self - c if it's possible to subtract c from self and
2237         make all matching coefficients move towards zero, else return None.
2238 
2239         Examples
2240         ========
2241 
2242         >>> from sympy.abc import x, y
2243         >>> e = 2*x + 3
2244         >>> e.extract_additively(x + 1)
2245         x + 2
2246         >>> e.extract_additively(3*x)
2247         >>> e.extract_additively(4)
2248         >>> (y*(x + 1)).extract_additively(x + 1)
2249         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2250         (x + 1)*(x + 2*y) + 3
2251 
2252         Sometimes auto-expansion will return a less simplified result
2253         than desired; gcd_terms might be used in such cases:
2254 
2255         >>> from sympy import gcd_terms
2256         >>> (4*x*(y + 1) + y).extract_additively(x)
2257         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2258         >>> gcd_terms(_)
2259         x*(4*y + 3) + y
2260 
2261         See Also
2262         ========
2263         extract_multiplicatively
2264         coeff
2265         as_coefficient
2266 
2267         """
2268 
2269         c = sympify(c)
2270         if self is S.NaN:
2271             return None
2272         if c.is_zero:
2273             return self
2274         elif c == self:
2275             return S.Zero
2276         elif self == S.Zero:
2277             return None
2278 
2279         if self.is_Number:
2280             if not c.is_Number:
2281                 return None
2282             co = self
2283             diff = co - c
2284             # XXX should we match types? i.e should 3 - .1 succeed?
2285             if (co > 0 and diff > 0 and diff < co or
2286                     co < 0 and diff < 0 and diff > co):
2287                 return diff
2288             return None
2289 
2290         if c.is_Number:
2291             co, t = self.as_coeff_Add()
2292             xa = co.extract_additively(c)
2293             if xa is None:
2294                 return None
2295             return xa + t
2296 
2297         # handle the args[0].is_Number case separately
2298         # since we will have trouble looking for the coeff of
2299         # a number.
2300         if c.is_Add and c.args[0].is_Number:
2301             # whole term as a term factor
2302             co = self.coeff(c)
2303             xa0 = (co.extract_additively(1) or 0)*c
2304             if xa0:
2305                 diff = self - co*c
2306                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2307             # term-wise
2308             h, t = c.as_coeff_Add()
2309             sh, st = self.as_coeff_Add()
2310             xa = sh.extract_additively(h)
2311             if xa is None:
2312                 return None
2313             xa2 = st.extract_additively(t)
2314             if xa2 is None:
2315                 return None
2316             return xa + xa2
2317 
2318         # whole term as a term factor
2319         co = self.coeff(c)
2320         xa0 = (co.extract_additively(1) or 0)*c
2321         if xa0:
2322             diff = self - co*c
2323             return (xa0 + (diff.extract_additively(c) or diff)) or None
2324         # term-wise
2325         coeffs = []
2326         for a in Add.make_args(c):
2327             ac, at = a.as_coeff_Mul()
2328             co = self.coeff(at)
2329             if not co:
2330                 return None
2331             coc, cot = co.as_coeff_Add()
2332             xa = coc.extract_additively(ac)
2333             if xa is None:
2334                 return None
2335             self -= co*at
2336             coeffs.append((cot + xa)*at)
2337         coeffs.append(self)
2338         return Add(*coeffs)
2339 
2340     @property
2341     def expr_free_symbols(self):
2342         """
2343         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2344 
2345         Examples
2346         ========
2347 
2348         >>> from sympy.abc import x, y
2349         >>> (x + y).expr_free_symbols
2350         {x, y}
2351 
2352         If the expression is contained in a non-expression object, don't return
2353         the free symbols. Compare:
2354 
2355         >>> from sympy import Tuple
2356         >>> t = Tuple(x + y)
2357         >>> t.expr_free_symbols
2358         set()
2359         >>> t.free_symbols
2360         {x, y}
2361         """
2362         return {j for i in self.args for j in i.expr_free_symbols}
2363 
2364     def could_extract_minus_sign(self):
2365         """Return True if self is not in a canonical form with respect
2366         to its sign.
2367 
2368         For most expressions, e, there will be a difference in e and -e.
2369         When there is, True will be returned for one and False for the
2370         other; False will be returned if there is no difference.
2371 
2372         Examples
2373         ========
2374 
2375         >>> from sympy.abc import x, y
2376         >>> e = x - y
2377         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2378         {False, True}
2379 
2380         """
2381         negative_self = -self
2382         if self == negative_self:
2383             return False  # e.g. zoo*x == -zoo*x
2384         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2385         negative_self_has_minus = (
2386             (negative_self).extract_multiplicatively(-1) is not None)
2387         if self_has_minus != negative_self_has_minus:
2388             return self_has_minus
2389         else:
2390             if self.is_Add:
2391                 # We choose the one with less arguments with minus signs
2392                 all_args = len(self.args)
2393                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2394                 positive_args = all_args - negative_args
2395                 if positive_args > negative_args:
2396                     return False
2397                 elif positive_args < negative_args:
2398                     return True
2399             elif self.is_Mul:
2400                 # We choose the one with an odd number of minus signs
2401                 num, den = self.as_numer_denom()
2402                 args = Mul.make_args(num) + Mul.make_args(den)
2403                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2404                 negative_args = list(filter(None, arg_signs))
2405                 return len(negative_args) % 2 == 1
2406 
2407             # As a last resort, we choose the one with greater value of .sort_key()
2408             return bool(self.sort_key() < negative_self.sort_key())
2409 
2410     def extract_branch_factor(self, allow_half=False):
2411         """
2412         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2413         Return (z, n).
2414 
2415         >>> from sympy import exp_polar, I, pi
2416         >>> from sympy.abc import x, y
2417         >>> exp_polar(I*pi).extract_branch_factor()
2418         (exp_polar(I*pi), 0)
2419         >>> exp_polar(2*I*pi).extract_branch_factor()
2420         (1, 1)
2421         >>> exp_polar(-pi*I).extract_branch_factor()
2422         (exp_polar(I*pi), -1)
2423         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2424         (exp_polar(x + I*pi), 1)
2425         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2426         (y*exp_polar(2*pi*x), -1)
2427         >>> exp_polar(-I*pi/2).extract_branch_factor()
2428         (exp_polar(-I*pi/2), 0)
2429 
2430         If allow_half is True, also extract exp_polar(I*pi):
2431 
2432         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2433         (1, 1/2)
2434         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2435         (1, 1)
2436         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2437         (1, 3/2)
2438         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2439         (1, -1/2)
2440         """
2441         from sympy import exp_polar, pi, I, ceiling, Add
2442         n = S.Zero
2443         res = S.One
2444         args = Mul.make_args(self)
2445         exps = []
2446         for arg in args:
2447             if isinstance(arg, exp_polar):
2448                 exps += [arg.exp]
2449             else:
2450                 res *= arg
2451         piimult = S.Zero
2452         extras = []
2453         while exps:
2454             exp = exps.pop()
2455             if exp.is_Add:
2456                 exps += exp.args
2457                 continue
2458             if exp.is_Mul:
2459                 coeff = exp.as_coefficient(pi*I)
2460                 if coeff is not None:
2461                     piimult += coeff
2462                     continue
2463             extras += [exp]
2464         if piimult.is_number:
2465             coeff = piimult
2466             tail = ()
2467         else:
2468             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2469         # round down to nearest multiple of 2
2470         branchfact = ceiling(coeff/2 - S.Half)*2
2471         n += branchfact/2
2472         c = coeff - branchfact
2473         if allow_half:
2474             nc = c.extract_additively(1)
2475             if nc is not None:
2476                 n += S.Half
2477                 c = nc
2478         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2479         if newexp != 0:
2480             res *= exp_polar(newexp)
2481         return res, n
2482 
2483     def _eval_is_polynomial(self, syms):
2484         if self.free_symbols.intersection(syms) == set([]):
2485             return True
2486         return False
2487 
2488     def is_polynomial(self, *syms):
2489         r"""
2490         Return True if self is a polynomial in syms and False otherwise.
2491 
2492         This checks if self is an exact polynomial in syms.  This function
2493         returns False for expressions that are "polynomials" with symbolic
2494         exponents.  Thus, you should be able to apply polynomial algorithms to
2495         expressions for which this returns True, and Poly(expr, \*syms) should
2496         work if and only if expr.is_polynomial(\*syms) returns True. The
2497         polynomial does not have to be in expanded form.  If no symbols are
2498         given, all free symbols in the expression will be used.
2499 
2500         This is not part of the assumptions system.  You cannot do
2501         Symbol('z', polynomial=True).
2502 
2503         Examples
2504         ========
2505 
2506         >>> from sympy import Symbol
2507         >>> x = Symbol('x')
2508         >>> ((x**2 + 1)**4).is_polynomial(x)
2509         True
2510         >>> ((x**2 + 1)**4).is_polynomial()
2511         True
2512         >>> (2**x + 1).is_polynomial(x)
2513         False
2514 
2515 
2516         >>> n = Symbol('n', nonnegative=True, integer=True)
2517         >>> (x**n + 1).is_polynomial(x)
2518         False
2519 
2520         This function does not attempt any nontrivial simplifications that may
2521         result in an expression that does not appear to be a polynomial to
2522         become one.
2523 
2524         >>> from sympy import sqrt, factor, cancel
2525         >>> y = Symbol('y', positive=True)
2526         >>> a = sqrt(y**2 + 2*y + 1)
2527         >>> a.is_polynomial(y)
2528         False
2529         >>> factor(a)
2530         y + 1
2531         >>> factor(a).is_polynomial(y)
2532         True
2533 
2534         >>> b = (y**2 + 2*y + 1)/(y + 1)
2535         >>> b.is_polynomial(y)
2536         False
2537         >>> cancel(b)
2538         y + 1
2539         >>> cancel(b).is_polynomial(y)
2540         True
2541 
2542         See also .is_rational_function()
2543 
2544         """
2545         if syms:
2546             syms = set(map(sympify, syms))
2547         else:
2548             syms = self.free_symbols
2549 
2550         if syms.intersection(self.free_symbols) == set([]):
2551             # constant polynomial
2552             return True
2553         else:
2554             return self._eval_is_polynomial(syms)
2555 
2556     def _eval_is_rational_function(self, syms):
2557         if self.free_symbols.intersection(syms) == set([]):
2558             return True
2559         return False
2560 
2561     def is_rational_function(self, *syms):
2562         """
2563         Test whether function is a ratio of two polynomials in the given
2564         symbols, syms. When syms is not given, all free symbols will be used.
2565         The rational function does not have to be in expanded or in any kind of
2566         canonical form.
2567 
2568         This function returns False for expressions that are "rational
2569         functions" with symbolic exponents.  Thus, you should be able to call
2570         .as_numer_denom() and apply polynomial algorithms to the result for
2571         expressions for which this returns True.
2572 
2573         This is not part of the assumptions system.  You cannot do
2574         Symbol('z', rational_function=True).
2575 
2576         Examples
2577         ========
2578 
2579         >>> from sympy import Symbol, sin
2580         >>> from sympy.abc import x, y
2581 
2582         >>> (x/y).is_rational_function()
2583         True
2584 
2585         >>> (x**2).is_rational_function()
2586         True
2587 
2588         >>> (x/sin(y)).is_rational_function(y)
2589         False
2590 
2591         >>> n = Symbol('n', integer=True)
2592         >>> (x**n + 1).is_rational_function(x)
2593         False
2594 
2595         This function does not attempt any nontrivial simplifications that may
2596         result in an expression that does not appear to be a rational function
2597         to become one.
2598 
2599         >>> from sympy import sqrt, factor
2600         >>> y = Symbol('y', positive=True)
2601         >>> a = sqrt(y**2 + 2*y + 1)/y
2602         >>> a.is_rational_function(y)
2603         False
2604         >>> factor(a)
2605         (y + 1)/y
2606         >>> factor(a).is_rational_function(y)
2607         True
2608 
2609         See also is_algebraic_expr().
2610 
2611         """
2612         if self in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2613             return False
2614 
2615         if syms:
2616             syms = set(map(sympify, syms))
2617         else:
2618             syms = self.free_symbols
2619 
2620         if syms.intersection(self.free_symbols) == set([]):
2621             # constant rational function
2622             return True
2623         else:
2624             return self._eval_is_rational_function(syms)
2625 
2626     def _eval_is_algebraic_expr(self, syms):
2627         if self.free_symbols.intersection(syms) == set([]):
2628             return True
2629         return False
2630 
2631     def is_algebraic_expr(self, *syms):
2632         """
2633         This tests whether a given expression is algebraic or not, in the
2634         given symbols, syms. When syms is not given, all free symbols
2635         will be used. The rational function does not have to be in expanded
2636         or in any kind of canonical form.
2637 
2638         This function returns False for expressions that are "algebraic
2639         expressions" with symbolic exponents. This is a simple extension to the
2640         is_rational_function, including rational exponentiation.
2641 
2642         Examples
2643         ========
2644 
2645         >>> from sympy import Symbol, sqrt
2646         >>> x = Symbol('x', real=True)
2647         >>> sqrt(1 + x).is_rational_function()
2648         False
2649         >>> sqrt(1 + x).is_algebraic_expr()
2650         True
2651 
2652         This function does not attempt any nontrivial simplifications that may
2653         result in an expression that does not appear to be an algebraic
2654         expression to become one.
2655 
2656         >>> from sympy import exp, factor
2657         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2658         >>> a.is_algebraic_expr(x)
2659         False
2660         >>> factor(a).is_algebraic_expr()
2661         True
2662 
2663         See Also
2664         ========
2665         is_rational_function()
2666 
2667         References
2668         ==========
2669 
2670         - https://en.wikipedia.org/wiki/Algebraic_expression
2671 
2672         """
2673         if syms:
2674             syms = set(map(sympify, syms))
2675         else:
2676             syms = self.free_symbols
2677 
2678         if syms.intersection(self.free_symbols) == set([]):
2679             # constant algebraic expression
2680             return True
2681         else:
2682             return self._eval_is_algebraic_expr(syms)
2683 
2684     ###################################################################################
2685     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2686     ###################################################################################
2687 
2688     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2689         """
2690         Series expansion of "self" around ``x = x0`` yielding either terms of
2691         the series one by one (the lazy series given when n=None), else
2692         all the terms at once when n != None.
2693 
2694         Returns the series expansion of "self" around the point ``x = x0``
2695         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2696 
2697         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2698         be supplied, otherwise an error will be raised.
2699 
2700         Parameters
2701         ==========
2702 
2703         expr : Expression
2704                The expression whose series is to be expanded.
2705 
2706         x : Symbol
2707             It is the variable of the expression to be calculated.
2708 
2709         x0 : Value
2710              The value around which ``x`` is calculated. Can be any value
2711              from ``-oo`` to ``oo``.
2712 
2713         n : Value
2714             The number of terms upto which the series is to be expanded.
2715 
2716         dir : String, optional
2717               The series-expansion can be bi-directional. If ``dir="+"``,
2718               then (x->x0+). If ``dir="-", then (x->x0-). For infinite
2719               ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined
2720               from the direction of the infinity (i.e., ``dir="-"`` for
2721               ``oo``).
2722 
2723         logx : optional
2724                It is used to replace any log(x) in the returned series with a
2725                symbolic value rather than evaluating the actual value.
2726 
2727         Examples
2728         ========
2729 
2730         >>> from sympy import cos, exp, tan, oo, series
2731         >>> from sympy.abc import x, y
2732         >>> cos(x).series()
2733         1 - x**2/2 + x**4/24 + O(x**6)
2734         >>> cos(x).series(n=4)
2735         1 - x**2/2 + O(x**4)
2736         >>> cos(x).series(x, x0=1, n=2)
2737         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2738         >>> e = cos(x + exp(y))
2739         >>> e.series(y, n=2)
2740         cos(x + 1) - y*sin(x + 1) + O(y**2)
2741         >>> e.series(x, n=2)
2742         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2743 
2744         If ``n=None`` then a generator of the series terms will be returned.
2745 
2746         >>> term=cos(x).series(n=None)
2747         >>> [next(term) for i in range(2)]
2748         [1, -x**2/2]
2749 
2750         For ``dir=+`` (default) the series is calculated from the right and
2751         for ``dir=-`` the series from the left. For smooth functions this
2752         flag will not alter the results.
2753 
2754         >>> abs(x).series(dir="+")
2755         x
2756         >>> abs(x).series(dir="-")
2757         -x
2758         >>> f = tan(x)
2759         >>> f.series(x, 2, 6, "+")
2760         tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +
2761         (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +
2762         5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +
2763         2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))
2764 
2765         >>> f.series(x, 2, 3, "-")
2766         tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))
2767         + O((x - 2)**3, (x, 2))
2768 
2769         Returns
2770         =======
2771 
2772         Expr : Expression
2773             Series expansion of the expression about x0
2774 
2775         Raises
2776         ======
2777 
2778         TypeError
2779             If "n" and "x0" are infinity objects
2780 
2781         PoleError
2782             If "x0" is an infinity object
2783 
2784         """
2785         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2786         if x is None:
2787             syms = self.free_symbols
2788             if not syms:
2789                 return self
2790             elif len(syms) > 1:
2791                 raise ValueError('x must be given for multivariate functions.')
2792             x = syms.pop()
2793 
2794         if isinstance(x, Symbol):
2795             dep = x in self.free_symbols
2796         else:
2797             d = Dummy()
2798             dep = d in self.xreplace({x: d}).free_symbols
2799         if not dep:
2800             if n is None:
2801                 return (s for s in [self])
2802             else:
2803                 return self
2804 
2805         if len(dir) != 1 or dir not in '+-':
2806             raise ValueError("Dir must be '+' or '-'")
2807 
2808         if x0 in [S.Infinity, S.NegativeInfinity]:
2809             sgn = 1 if x0 is S.Infinity else -1
2810             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2811             if n is None:
2812                 return (si.subs(x, sgn/x) for si in s)
2813             return s.subs(x, sgn/x)
2814 
2815         # use rep to shift origin to x0 and change sign (if dir is negative)
2816         # and undo the process with rep2
2817         if x0 or dir == '-':
2818             if dir == '-':
2819                 rep = -x + x0
2820                 rep2 = -x
2821                 rep2b = x0
2822             else:
2823                 rep = x + x0
2824                 rep2 = x
2825                 rep2b = -x0
2826             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2827             if n is None:  # lseries...
2828                 return (si.subs(x, rep2 + rep2b) for si in s)
2829             return s.subs(x, rep2 + rep2b)
2830 
2831         # from here on it's x0=0 and dir='+' handling
2832 
2833         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2834             # replace x with an x that has a positive assumption
2835             xpos = Dummy('x', positive=True, finite=True)
2836             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2837             if n is None:
2838                 return (s.subs(xpos, x) for s in rv)
2839             else:
2840                 return rv.subs(xpos, x)
2841 
2842         if n is not None:  # nseries handling
2843             s1 = self._eval_nseries(x, n=n, logx=logx)
2844             o = s1.getO() or S.Zero
2845             if o:
2846                 # make sure the requested order is returned
2847                 ngot = o.getn()
2848                 if ngot > n:
2849                     # leave o in its current form (e.g. with x*log(x)) so
2850                     # it eats terms properly, then replace it below
2851                     if n != 0:
2852                         s1 += o.subs(x, x**Rational(n, ngot))
2853                     else:
2854                         s1 += Order(1, x)
2855                 elif ngot < n:
2856                     # increase the requested number of terms to get the desired
2857                     # number keep increasing (up to 9) until the received order
2858                     # is different than the original order and then predict how
2859                     # many additional terms are needed
2860                     for more in range(1, 9):
2861                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2862                         newn = s1.getn()
2863                         if newn != ngot:
2864                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2865                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2866                             while s1.getn() < n:
2867                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2868                                 ndo += 1
2869                             break
2870                     else:
2871                         raise ValueError('Could not calculate %s terms for %s'
2872                                          % (str(n), self))
2873                     s1 += Order(x**n, x)
2874                 o = s1.getO()
2875                 s1 = s1.removeO()
2876             else:
2877                 o = Order(x**n, x)
2878                 s1done = s1.doit()
2879                 if (s1done + o).removeO() == s1done:
2880                     o = S.Zero
2881 
2882             try:
2883                 return collect(s1, x) + o
2884             except NotImplementedError:
2885                 return s1 + o
2886 
2887         else:  # lseries handling
2888             def yield_lseries(s):
2889                 """Return terms of lseries one at a time."""
2890                 for si in s:
2891                     if not si.is_Add:
2892                         yield si
2893                         continue
2894                     # yield terms 1 at a time if possible
2895                     # by increasing order until all the
2896                     # terms have been returned
2897                     yielded = 0
2898                     o = Order(si, x)*x
2899                     ndid = 0
2900                     ndo = len(si.args)
2901                     while 1:
2902                         do = (si - yielded + o).removeO()
2903                         o *= x
2904                         if not do or do.is_Order:
2905                             continue
2906                         if do.is_Add:
2907                             ndid += len(do.args)
2908                         else:
2909                             ndid += 1
2910                         yield do
2911                         if ndid == ndo:
2912                             break
2913                         yielded += do
2914 
2915             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2916 
2917     def aseries(self, x=None, n=6, bound=0, hir=False):
2918         """Asymptotic Series expansion of self.
2919         This is equivalent to ``self.series(x, oo, n)``.
2920 
2921         Parameters
2922         ==========
2923 
2924         self : Expression
2925                The expression whose series is to be expanded.
2926 
2927         x : Symbol
2928             It is the variable of the expression to be calculated.
2929 
2930         n : Value
2931             The number of terms upto which the series is to be expanded.
2932 
2933         hir : Boolean
2934               Set this parameter to be True to produce hierarchical series.
2935               It stops the recursion at an early level and may provide nicer
2936               and more useful results.
2937 
2938         bound : Value, Integer
2939                 Use the ``bound`` parameter to give limit on rewriting
2940                 coefficients in its normalised form.
2941 
2942         Examples
2943         ========
2944 
2945         >>> from sympy import sin, exp
2946         >>> from sympy.abc import x, y
2947 
2948         >>> e = sin(1/x + exp(-x)) - sin(1/x)
2949 
2950         >>> e.aseries(x)
2951         (1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))*exp(-x)
2952 
2953         >>> e.aseries(x, n=3, hir=True)
2954         -exp(-2*x)*sin(1/x)/2 + exp(-x)*cos(1/x) + O(exp(-3*x), (x, oo))
2955 
2956         >>> e = exp(exp(x)/(1 - 1/x))
2957 
2958         >>> e.aseries(x)
2959         exp(exp(x)/(1 - 1/x))
2960 
2961         >>> e.aseries(x, bound=3)
2962         exp(exp(x)/x**2)*exp(exp(x)/x)*exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x**2)*exp(exp(x))
2963 
2964         Returns
2965         =======
2966 
2967         Expr
2968             Asymptotic series expansion of the expression.
2969 
2970         Notes
2971         =====
2972 
2973         This algorithm is directly induced from the limit computational algorithm provided by Gruntz.
2974         It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first
2975         to look for the most rapidly varying subexpression w of a given expression f and then expands f
2976         in a series in w. Then same thing is recursively done on the leading coefficient
2977         till we get constant coefficients.
2978 
2979         If the most rapidly varying subexpression of a given expression f is f itself,
2980         the algorithm tries to find a normalised representation of the mrv set and rewrites f
2981         using this normalised representation.
2982 
2983         If the expansion contains an order term, it will be either ``O(x ** (-n))`` or ``O(w ** (-n))``
2984         where ``w`` belongs to the most rapidly varying expression of ``self``.
2985 
2986         References
2987         ==========
2988 
2989         .. [1] A New Algorithm for Computing Asymptotic Series - Dominik Gruntz
2990         .. [2] Gruntz thesis - p90
2991         .. [3] http://en.wikipedia.org/wiki/Asymptotic_expansion
2992 
2993         See Also
2994         ========
2995 
2996         Expr.aseries: See the docstring of this function for complete details of this wrapper.
2997         """
2998 
2999         from sympy import Order, Dummy
3000         from sympy.functions import exp, log
3001         from sympy.series.gruntz import mrv, rewrite
3002 
3003         if x.is_positive is x.is_negative is None:
3004             xpos = Dummy('x', positive=True)
3005             return self.subs(x, xpos).aseries(xpos, n, bound, hir).subs(xpos, x)
3006 
3007         om, exps = mrv(self, x)
3008 
3009         # We move one level up by replacing `x` by `exp(x)`, and then
3010         # computing the asymptotic series for f(exp(x)). Then asymptotic series
3011         # can be obtained by moving one-step back, by replacing x by ln(x).
3012 
3013         if x in om:
3014             s = self.subs(x, exp(x)).aseries(x, n, bound, hir).subs(x, log(x))
3015             if s.getO():
3016                 return s + Order(1/x**n, (x, S.Infinity))
3017             return s
3018 
3019         k = Dummy('k', positive=True)
3020         # f is rewritten in terms of omega
3021         func, logw = rewrite(exps, om, x, k)
3022 
3023         if self in om:
3024             if bound <= 0:
3025                 return self
3026             s = (self.exp).aseries(x, n, bound=bound)
3027             s = s.func(*[t.removeO() for t in s.args])
3028             res = exp(s.subs(x, 1/x).as_leading_term(x).subs(x, 1/x))
3029 
3030             func = exp(self.args[0] - res.args[0]) / k
3031             logw = log(1/res)
3032 
3033         s = func.series(k, 0, n)
3034 
3035         # Hierarchical series
3036         if hir:
3037             return s.subs(k, exp(logw))
3038 
3039         o = s.getO()
3040         terms = sorted(Add.make_args(s.removeO()), key=lambda i: int(i.as_coeff_exponent(k)[1]))
3041         s = S.Zero
3042         has_ord = False
3043 
3044         # Then we recursively expand these coefficients one by one into
3045         # their asymptotic series in terms of their most rapidly varying subexpressions.
3046         for t in terms:
3047             coeff, expo = t.as_coeff_exponent(k)
3048             if coeff.has(x):
3049                 # Recursive step
3050                 snew = coeff.aseries(x, n, bound=bound-1)
3051                 if has_ord and snew.getO():
3052                     break
3053                 elif snew.getO():
3054                     has_ord = True
3055                 s += (snew * k**expo)
3056             else:
3057                 s += t
3058 
3059         if not o or has_ord:
3060             return s.subs(k, exp(logw))
3061         return (s + o).subs(k, exp(logw))
3062 
3063 
3064     def taylor_term(self, n, x, *previous_terms):
3065         """General method for the taylor term.
3066 
3067         This method is slow, because it differentiates n-times. Subclasses can
3068         redefine it to make it faster by using the "previous_terms".
3069         """
3070         from sympy import Dummy, factorial
3071         x = sympify(x)
3072         _x = Dummy('x')
3073         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
3074 
3075     def lseries(self, x=None, x0=0, dir='+', logx=None):
3076         """
3077         Wrapper for series yielding an iterator of the terms of the series.
3078 
3079         Note: an infinite series will yield an infinite iterator. The following,
3080         for exaxmple, will never terminate. It will just keep printing terms
3081         of the sin(x) series::
3082 
3083           for term in sin(x).lseries(x):
3084               print term
3085 
3086         The advantage of lseries() over nseries() is that many times you are
3087         just interested in the next term in the series (i.e. the first term for
3088         example), but you don't know how many you should ask for in nseries()
3089         using the "n" parameter.
3090 
3091         See also nseries().
3092         """
3093         return self.series(x, x0, n=None, dir=dir, logx=logx)
3094 
3095     def _eval_lseries(self, x, logx=None):
3096         # default implementation of lseries is using nseries(), and adaptively
3097         # increasing the "n". As you can see, it is not very efficient, because
3098         # we are calculating the series over and over again. Subclasses should
3099         # override this method and implement much more efficient yielding of
3100         # terms.
3101         n = 0
3102         series = self._eval_nseries(x, n=n, logx=logx)
3103         if not series.is_Order:
3104             if series.is_Add:
3105                 yield series.removeO()
3106             else:
3107                 yield series
3108             return
3109 
3110         while series.is_Order:
3111             n += 1
3112             series = self._eval_nseries(x, n=n, logx=logx)
3113         e = series.removeO()
3114         yield e
3115         while 1:
3116             while 1:
3117                 n += 1
3118                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
3119                 if e != series:
3120                     break
3121             yield series - e
3122             e = series
3123 
3124     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
3125         """
3126         Wrapper to _eval_nseries if assumptions allow, else to series.
3127 
3128         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
3129         called. This calculates "n" terms in the innermost expressions and
3130         then builds up the final series just by "cross-multiplying" everything
3131         out.
3132 
3133         The optional ``logx`` parameter can be used to replace any log(x) in the
3134         returned series with a symbolic value to avoid evaluating log(x) at 0. A
3135         symbol to use in place of log(x) should be provided.
3136 
3137         Advantage -- it's fast, because we don't have to determine how many
3138         terms we need to calculate in advance.
3139 
3140         Disadvantage -- you may end up with less terms than you may have
3141         expected, but the O(x**n) term appended will always be correct and
3142         so the result, though perhaps shorter, will also be correct.
3143 
3144         If any of those assumptions is not met, this is treated like a
3145         wrapper to series which will try harder to return the correct
3146         number of terms.
3147 
3148         See also lseries().
3149 
3150         Examples
3151         ========
3152 
3153         >>> from sympy import sin, log, Symbol
3154         >>> from sympy.abc import x, y
3155         >>> sin(x).nseries(x, 0, 6)
3156         x - x**3/6 + x**5/120 + O(x**6)
3157         >>> log(x+1).nseries(x, 0, 5)
3158         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
3159 
3160         Handling of the ``logx`` parameter --- in the following example the
3161         expansion fails since ``sin`` does not have an asymptotic expansion
3162         at -oo (the limit of log(x) as x approaches 0):
3163 
3164         >>> e = sin(log(x))
3165         >>> e.nseries(x, 0, 6)
3166         Traceback (most recent call last):
3167         ...
3168         PoleError: ...
3169         ...
3170         >>> logx = Symbol('logx')
3171         >>> e.nseries(x, 0, 6, logx=logx)
3172         sin(logx)
3173 
3174         In the following example, the expansion works but gives only an Order term
3175         unless the ``logx`` parameter is used:
3176 
3177         >>> e = x**y
3178         >>> e.nseries(x, 0, 2)
3179         O(log(x)**2)
3180         >>> e.nseries(x, 0, 2, logx=logx)
3181         exp(logx*y)
3182 
3183         """
3184         if x and not x in self.free_symbols:
3185             return self
3186         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
3187             return self.series(x, x0, n, dir)
3188         else:
3189             return self._eval_nseries(x, n=n, logx=logx)
3190 
3191     def _eval_nseries(self, x, n, logx):
3192         """
3193         Return terms of series for self up to O(x**n) at x=0
3194         from the positive direction.
3195 
3196         This is a method that should be overridden in subclasses. Users should
3197         never call this method directly (use .nseries() instead), so you don't
3198         have to write docstrings for _eval_nseries().
3199         """
3200         from sympy.utilities.misc import filldedent
3201         raise NotImplementedError(filldedent("""
3202                      The _eval_nseries method should be added to
3203                      %s to give terms up to O(x**n) at x=0
3204                      from the positive direction so it is available when
3205                      nseries calls it.""" % self.func)
3206                      )
3207 
3208     def limit(self, x, xlim, dir='+'):
3209         """ Compute limit x->xlim.
3210         """
3211         from sympy.series.limits import limit
3212         return limit(self, x, xlim, dir)
3213 
3214     def compute_leading_term(self, x, logx=None):
3215         """
3216         as_leading_term is only allowed for results of .series()
3217         This is a wrapper to compute a series first.
3218         """
3219         from sympy import Dummy, log, Piecewise, piecewise_fold
3220         from sympy.series.gruntz import calculate_series
3221 
3222         if self.has(Piecewise):
3223             expr = piecewise_fold(self)
3224         else:
3225             expr = self
3226         if self.removeO() == 0:
3227             return self
3228 
3229         if logx is None:
3230             d = Dummy('logx')
3231             s = calculate_series(expr, x, d).subs(d, log(x))
3232         else:
3233             s = calculate_series(expr, x, logx)
3234 
3235         return s.as_leading_term(x)
3236 
3237     @cacheit
3238     def as_leading_term(self, *symbols):
3239         """
3240         Returns the leading (nonzero) term of the series expansion of self.
3241 
3242         The _eval_as_leading_term routines are used to do this, and they must
3243         always return a non-zero value.
3244 
3245         Examples
3246         ========
3247 
3248         >>> from sympy.abc import x
3249         >>> (1 + x + x**2).as_leading_term(x)
3250         1
3251         >>> (1/x**2 + x + x**2).as_leading_term(x)
3252         x**(-2)
3253 
3254         """
3255         from sympy import powsimp
3256         if len(symbols) > 1:
3257             c = self
3258             for x in symbols:
3259                 c = c.as_leading_term(x)
3260             return c
3261         elif not symbols:
3262             return self
3263         x = sympify(symbols[0])
3264         if not x.is_symbol:
3265             raise ValueError('expecting a Symbol but got %s' % x)
3266         if x not in self.free_symbols:
3267             return self
3268         obj = self._eval_as_leading_term(x)
3269         if obj is not None:
3270             return powsimp(obj, deep=True, combine='exp')
3271         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3272 
3273     def _eval_as_leading_term(self, x):
3274         return self
3275 
3276     def as_coeff_exponent(self, x):
3277         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3278         """
3279         from sympy import collect
3280         s = collect(self, x)
3281         c, p = s.as_coeff_mul(x)
3282         if len(p) == 1:
3283             b, e = p[0].as_base_exp()
3284             if b == x:
3285                 return c, e
3286         return s, S.Zero
3287 
3288     def leadterm(self, x):
3289         """
3290         Returns the leading term a*x**b as a tuple (a, b).
3291 
3292         Examples
3293         ========
3294 
3295         >>> from sympy.abc import x
3296         >>> (1+x+x**2).leadterm(x)
3297         (1, 0)
3298         >>> (1/x**2+x+x**2).leadterm(x)
3299         (1, -2)
3300 
3301         """
3302         from sympy import Dummy, log
3303         l = self.as_leading_term(x)
3304         d = Dummy('logx')
3305         if l.has(log(x)):
3306             l = l.subs(log(x), d)
3307         c, e = l.as_coeff_exponent(x)
3308         if x in c.free_symbols:
3309             from sympy.utilities.misc import filldedent
3310             raise ValueError(filldedent("""
3311                 cannot compute leadterm(%s, %s). The coefficient
3312                 should have been free of %s but got %s""" % (self, x, x, c)))
3313         c = c.subs(d, log(x))
3314         return c, e
3315 
3316     def as_coeff_Mul(self, rational=False):
3317         """Efficiently extract the coefficient of a product. """
3318         return S.One, self
3319 
3320     def as_coeff_Add(self, rational=False):
3321         """Efficiently extract the coefficient of a summation. """
3322         return S.Zero, self
3323 
3324     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3325             full=False):
3326         """
3327         Compute formal power power series of self.
3328 
3329         See the docstring of the :func:`fps` function in sympy.series.formal for
3330         more information.
3331         """
3332         from sympy.series.formal import fps
3333 
3334         return fps(self, x, x0, dir, hyper, order, rational, full)
3335 
3336     def fourier_series(self, limits=None):
3337         """Compute fourier sine/cosine series of self.
3338 
3339         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3340         for more information.
3341         """
3342         from sympy.series.fourier import fourier_series
3343 
3344         return fourier_series(self, limits)
3345 
3346     ###################################################################################
3347     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3348     ###################################################################################
3349 
3350     def diff(self, *symbols, **assumptions):
3351         assumptions.setdefault("evaluate", True)
3352         return Derivative(self, *symbols, **assumptions)
3353 
3354     ###########################################################################
3355     ###################### EXPRESSION EXPANSION METHODS #######################
3356     ###########################################################################
3357 
3358     # Relevant subclasses should override _eval_expand_hint() methods.  See
3359     # the docstring of expand() for more info.
3360 
3361     def _eval_expand_complex(self, **hints):
3362         real, imag = self.as_real_imag(**hints)
3363         return real + S.ImaginaryUnit*imag
3364 
3365     @staticmethod
3366     def _expand_hint(expr, hint, deep=True, **hints):
3367         """
3368         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3369 
3370         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3371         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3372         ``False`` otherwise.
3373         """
3374         hit = False
3375         # XXX: Hack to support non-Basic args
3376         #              |
3377         #              V
3378         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3379             sargs = []
3380             for arg in expr.args:
3381                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3382                 hit |= arghit
3383                 sargs.append(arg)
3384 
3385             if hit:
3386                 expr = expr.func(*sargs)
3387 
3388         if hasattr(expr, hint):
3389             newexpr = getattr(expr, hint)(**hints)
3390             if newexpr != expr:
3391                 return (newexpr, True)
3392 
3393         return (expr, hit)
3394 
3395     @cacheit
3396     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3397             mul=True, log=True, multinomial=True, basic=True, **hints):
3398         """
3399         Expand an expression using hints.
3400 
3401         See the docstring of the expand() function in sympy.core.function for
3402         more information.
3403 
3404         """
3405         from sympy.simplify.radsimp import fraction
3406 
3407         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3408            log=log, multinomial=multinomial, basic=basic)
3409 
3410         expr = self
3411         if hints.pop('frac', False):
3412             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3413                     for a in fraction(self)]
3414             return n/d
3415         elif hints.pop('denom', False):
3416             n, d = fraction(self)
3417             return n/d.expand(deep=deep, modulus=modulus, **hints)
3418         elif hints.pop('numer', False):
3419             n, d = fraction(self)
3420             return n.expand(deep=deep, modulus=modulus, **hints)/d
3421 
3422         # Although the hints are sorted here, an earlier hint may get applied
3423         # at a given node in the expression tree before another because of how
3424         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3425         # x*z) because while applying log at the top level, log and mul are
3426         # applied at the deeper level in the tree so that when the log at the
3427         # upper level gets applied, the mul has already been applied at the
3428         # lower level.
3429 
3430         # Additionally, because hints are only applied once, the expression
3431         # may not be expanded all the way.   For example, if mul is applied
3432         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3433         # now, we just use a special case to make multinomial run before mul,
3434         # so that at least polynomials will be expanded all the way.  In the
3435         # future, smarter heuristics should be applied.
3436         # TODO: Smarter heuristics
3437 
3438         def _expand_hint_key(hint):
3439             """Make multinomial come before mul"""
3440             if hint == 'mul':
3441                 return 'mulz'
3442             return hint
3443 
3444         for hint in sorted(hints.keys(), key=_expand_hint_key):
3445             use_hint = hints[hint]
3446             if use_hint:
3447                 hint = '_eval_expand_' + hint
3448                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3449 
3450         while True:
3451             was = expr
3452             if hints.get('multinomial', False):
3453                 expr, _ = Expr._expand_hint(
3454                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3455             if hints.get('mul', False):
3456                 expr, _ = Expr._expand_hint(
3457                     expr, '_eval_expand_mul', deep=deep, **hints)
3458             if hints.get('log', False):
3459                 expr, _ = Expr._expand_hint(
3460                     expr, '_eval_expand_log', deep=deep, **hints)
3461             if expr == was:
3462                 break
3463 
3464         if modulus is not None:
3465             modulus = sympify(modulus)
3466 
3467             if not modulus.is_Integer or modulus <= 0:
3468                 raise ValueError(
3469                     "modulus must be a positive integer, got %s" % modulus)
3470 
3471             terms = []
3472 
3473             for term in Add.make_args(expr):
3474                 coeff, tail = term.as_coeff_Mul(rational=True)
3475 
3476                 coeff %= modulus
3477 
3478                 if coeff:
3479                     terms.append(coeff*tail)
3480 
3481             expr = Add(*terms)
3482 
3483         return expr
3484 
3485     ###########################################################################
3486     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3487     ###########################################################################
3488 
3489     def integrate(self, *args, **kwargs):
3490         """See the integrate function in sympy.integrals"""
3491         from sympy.integrals import integrate
3492         return integrate(self, *args, **kwargs)
3493 
3494     def simplify(self, **kwargs):
3495         """See the simplify function in sympy.simplify"""
3496         from sympy.simplify import simplify
3497         return simplify(self, **kwargs)
3498 
3499     def nsimplify(self, constants=[], tolerance=None, full=False):
3500         """See the nsimplify function in sympy.simplify"""
3501         from sympy.simplify import nsimplify
3502         return nsimplify(self, constants, tolerance, full)
3503 
3504     def separate(self, deep=False, force=False):
3505         """See the separate function in sympy.simplify"""
3506         from sympy.core.function import expand_power_base
3507         return expand_power_base(self, deep=deep, force=force)
3508 
3509     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3510         """See the collect function in sympy.simplify"""
3511         from sympy.simplify import collect
3512         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3513 
3514     def together(self, *args, **kwargs):
3515         """See the together function in sympy.polys"""
3516         from sympy.polys import together
3517         return together(self, *args, **kwargs)
3518 
3519     def apart(self, x=None, **args):
3520         """See the apart function in sympy.polys"""
3521         from sympy.polys import apart
3522         return apart(self, x, **args)
3523 
3524     def ratsimp(self):
3525         """See the ratsimp function in sympy.simplify"""
3526         from sympy.simplify import ratsimp
3527         return ratsimp(self)
3528 
3529     def trigsimp(self, **args):
3530         """See the trigsimp function in sympy.simplify"""
3531         from sympy.simplify import trigsimp
3532         return trigsimp(self, **args)
3533 
3534     def radsimp(self, **kwargs):
3535         """See the radsimp function in sympy.simplify"""
3536         from sympy.simplify import radsimp
3537         return radsimp(self, **kwargs)
3538 
3539     def powsimp(self, *args, **kwargs):
3540         """See the powsimp function in sympy.simplify"""
3541         from sympy.simplify import powsimp
3542         return powsimp(self, *args, **kwargs)
3543 
3544     def combsimp(self):
3545         """See the combsimp function in sympy.simplify"""
3546         from sympy.simplify import combsimp
3547         return combsimp(self)
3548 
3549     def gammasimp(self):
3550         """See the gammasimp function in sympy.simplify"""
3551         from sympy.simplify import gammasimp
3552         return gammasimp(self)
3553 
3554     def factor(self, *gens, **args):
3555         """See the factor() function in sympy.polys.polytools"""
3556         from sympy.polys import factor
3557         return factor(self, *gens, **args)
3558 
3559     def refine(self, assumption=True):
3560         """See the refine function in sympy.assumptions"""
3561         from sympy.assumptions import refine
3562         return refine(self, assumption)
3563 
3564     def cancel(self, *gens, **args):
3565         """See the cancel function in sympy.polys"""
3566         from sympy.polys import cancel
3567         return cancel(self, *gens, **args)
3568 
3569     def invert(self, g, *gens, **args):
3570         """Return the multiplicative inverse of ``self`` mod ``g``
3571         where ``self`` (and ``g``) may be symbolic expressions).
3572 
3573         See Also
3574         ========
3575         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3576         """
3577         from sympy.polys.polytools import invert
3578         from sympy.core.numbers import mod_inverse
3579         if self.is_number and getattr(g, 'is_number', True):
3580             return mod_inverse(self, g)
3581         return invert(self, g, *gens, **args)
3582 
3583     def round(self, n=None):
3584         """Return x rounded to the given decimal place.
3585 
3586         If a complex number would results, apply round to the real
3587         and imaginary components of the number.
3588 
3589         Examples
3590         ========
3591 
3592         >>> from sympy import pi, E, I, S, Add, Mul, Number
3593         >>> pi.round()
3594         3
3595         >>> pi.round(2)
3596         3.14
3597         >>> (2*pi + E*I).round()
3598         6 + 3*I
3599 
3600         The round method has a chopping effect:
3601 
3602         >>> (2*pi + I/10).round()
3603         6
3604         >>> (pi/10 + 2*I).round()
3605         2*I
3606         >>> (pi/10 + E*I).round(2)
3607         0.31 + 2.72*I
3608 
3609         Notes
3610         =====
3611 
3612         The Python builtin function, round, always returns a
3613         float in Python 2 while the SymPy round method (and
3614         round with a Number argument in Python 3) returns a
3615         Number.
3616 
3617         >>> from sympy.core.compatibility import PY3
3618         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3619         True
3620 
3621         For a consistent behavior, and Python 3 rounding
3622         rules, import `round` from sympy.core.compatibility.
3623 
3624         >>> from sympy.core.compatibility import round
3625         >>> isinstance(round(S(123), -2), Number)
3626         True
3627         """
3628         from sympy.core.numbers import Float
3629 
3630         x = self
3631 
3632         if not x.is_number:
3633             raise TypeError("can't round symbolic expression")
3634         if not x.is_Atom:
3635             if not pure_complex(x.n(2), or_real=True):
3636                 raise TypeError(
3637                     'Expected a number but got %s:' % func_name(x))
3638         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3639             return x
3640         if not x.is_extended_real:
3641             i, r = x.as_real_imag()
3642             return i.round(n) + S.ImaginaryUnit*r.round(n)
3643         if not x:
3644             return S.Zero if n is None else x
3645 
3646 
3647         p = as_int(n or 0)
3648 
3649         if x.is_Integer:
3650             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3651             if p >= 0:
3652                 return x
3653             m = 10**-p
3654             i, r = divmod(abs(x), m)
3655             if i%2 and 2*r == m:
3656               i += 1
3657             elif 2*r > m:
3658                 i += 1
3659             if x < 0:
3660                 i *= -1
3661             return i*m
3662 
3663         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3664         allow = digits_to_decimal + p
3665         precs = [f._prec for f in x.atoms(Float)]
3666         dps = prec_to_dps(max(precs)) if precs else None
3667         if dps is None:
3668             # assume everything is exact so use the Python
3669             # float default or whatever was requested
3670             dps = max(15, allow)
3671         else:
3672             allow = min(allow, dps)
3673         # this will shift all digits to right of decimal
3674         # and give us dps to work with as an int
3675         shift = -digits_to_decimal + dps
3676         extra = 1  # how far we look past known digits
3677         # NOTE
3678         # mpmath will calculate the binary representation to
3679         # an arbitrary number of digits but we must base our
3680         # answer on a finite number of those digits, e.g.
3681         # .575 2589569785738035/2**52 in binary.
3682         # mpmath shows us that the first 18 digits are
3683         #     >>> Float(.575).n(18)
3684         #     0.574999999999999956
3685         # The default precision is 15 digits and if we ask
3686         # for 15 we get
3687         #     >>> Float(.575).n(15)
3688         #     0.575000000000000
3689         # mpmath handles rounding at the 15th digit. But we
3690         # need to be careful since the user might be asking
3691         # for rounding at the last digit and our semantics
3692         # are to round toward the even final digit when there
3693         # is a tie. So the extra digit will be used to make
3694         # that decision. In this case, the value is the same
3695         # to 15 digits:
3696         #     >>> Float(.575).n(16)
3697         #     0.5750000000000000
3698         # Now converting this to the 15 known digits gives
3699         #     575000000000000.0
3700         # which rounds to integer
3701         #    5750000000000000
3702         # And now we can round to the desired digt, e.g. at
3703         # the second from the left and we get
3704         #    5800000000000000
3705         # and rescaling that gives
3706         #    0.58
3707         # as the final result.
3708         # If the value is made slightly less than 0.575 we might
3709         # still obtain the same value:
3710         #    >>> Float(.575-1e-16).n(16)*10**15
3711         #    574999999999999.8
3712         # What 15 digits best represents the known digits (which are
3713         # to the left of the decimal? 5750000000000000, the same as
3714         # before. The only way we will round down (in this case) is
3715         # if we declared that we had more than 15 digits of precision.
3716         # For example, if we use 16 digits of precision, the integer
3717         # we deal with is
3718         #    >>> Float(.575-1e-16).n(17)*10**16
3719         #    5749999999999998.4
3720         # and this now rounds to 5749999999999998 and (if we round to
3721         # the 2nd digit from the left) we get 5700000000000000.
3722         #
3723         xf = x.n(dps + extra)*Pow(10, shift)
3724         xi = Integer(xf)
3725         # use the last digit to select the value of xi
3726         # nearest to x before rounding at the desired digit
3727         sign = 1 if x > 0 else -1
3728         dif2 = sign*(xf - xi).n(extra)
3729         if dif2 < 0:
3730             raise NotImplementedError(
3731                 'not expecting int(x) to round away from 0')
3732         if dif2 > .5:
3733             xi += sign  # round away from 0
3734         elif dif2 == .5:
3735             xi += sign if xi%2 else -sign  # round toward even
3736         # shift p to the new position
3737         ip = p - shift
3738         # let Python handle the int rounding then rescale
3739         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3740         # restore scale
3741         rv = Rational(xr, Pow(10, shift))
3742         # return Float or Integer
3743         if rv.is_Integer:
3744             if n is None:  # the single-arg case
3745                 return rv
3746             # use str or else it won't be a float
3747             return Float(str(rv), dps)  # keep same precision
3748         else:
3749             if not allow and rv > self:
3750                 allow += 1
3751             return Float(rv, allow)
3752 
3753     __round__ = round
3754 
3755     def _eval_derivative_matrix_lines(self, x):
3756         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3757         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/sympify.py</file>
<class>None</class>
<method>sympify</method>
<code>
78 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
79         evaluate=None):
80     """Converts an arbitrary expression to a type that can be used inside SymPy.
81 
82     For example, it will convert Python ints into instances of sympy.Integer,
83     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
84     expressions which inherit from Basic. This can be useful in cooperation
85     with SAGE.
86 
87     It currently accepts as arguments:
88        - any object defined in SymPy
89        - standard numeric python types: int, long, float, Decimal
90        - strings (like "0.09" or "2e-19")
91        - booleans, including ``None`` (will leave ``None`` unchanged)
92        - dict, lists, sets or tuples containing any of the above
93 
94     .. warning::
95         Note that this function uses ``eval``, and thus shouldn't be used on
96         unsanitized input.
97 
98     If the argument is already a type that SymPy understands, it will do
99     nothing but return that value. This can be used at the beginning of a
100     function to ensure you are working with the correct type.
101 
102     >>> from sympy import sympify
103 
104     >>> sympify(2).is_integer
105     True
106     >>> sympify(2).is_real
107     True
108 
109     >>> sympify(2.0).is_real
110     True
111     >>> sympify("2.0").is_real
112     True
113     >>> sympify("2e-45").is_real
114     True
115 
116     If the expression could not be converted, a SympifyError is raised.
117 
118     >>> sympify("x***2")
119     Traceback (most recent call last):
120     ...
121     SympifyError: SympifyError: "could not parse u'x***2'"
122 
123     Locals
124     ------
125 
126     The sympification happens with access to everything that is loaded
127     by ``from sympy import *``; anything used in a string that is not
128     defined by that import will be converted to a symbol. In the following,
129     the ``bitcount`` function is treated as a symbol and the ``O`` is
130     interpreted as the Order object (used with series) and it raises
131     an error when used improperly:
132 
133     >>> s = 'bitcount(42)'
134     >>> sympify(s)
135     bitcount(42)
136     >>> sympify("O(x)")
137     O(x)
138     >>> sympify("O + 1")
139     Traceback (most recent call last):
140     ...
141     TypeError: unbound method...
142 
143     In order to have ``bitcount`` be recognized it can be imported into a
144     namespace dictionary and passed as locals:
145 
146     >>> from sympy.core.compatibility import exec_
147     >>> ns = {}
148     >>> exec_('from sympy.core.evalf import bitcount', ns)
149     >>> sympify(s, locals=ns)
150     6
151 
152     In order to have the ``O`` interpreted as a Symbol, identify it as such
153     in the namespace dictionary. This can be done in a variety of ways; all
154     three of the following are possibilities:
155 
156     >>> from sympy import Symbol
157     >>> ns["O"] = Symbol("O")  # method 1
158     >>> exec_('from sympy.abc import O', ns)  # method 2
159     >>> ns.update(dict(O=Symbol("O")))  # method 3
160     >>> sympify("O + 1", locals=ns)
161     O + 1
162 
163     If you want *all* single-letter and Greek-letter variables to be symbols
164     then you can use the clashing-symbols dictionaries that have been defined
165     there as private variables: _clash1 (single-letter variables), _clash2
166     (the multi-letter Greek names) or _clash (both single and multi-letter
167     names that are defined in abc).
168 
169     >>> from sympy.abc import _clash1
170     >>> _clash1
171     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
172     >>> sympify('I & Q', _clash1)
173     I & Q
174 
175     Strict
176     ------
177 
178     If the option ``strict`` is set to ``True``, only the types for which an
179     explicit conversion has been defined are converted. In the other
180     cases, a SympifyError is raised.
181 
182     >>> print(sympify(None))
183     None
184     >>> sympify(None, strict=True)
185     Traceback (most recent call last):
186     ...
187     SympifyError: SympifyError: None
188 
189     Evaluation
190     ----------
191 
192     If the option ``evaluate`` is set to ``False``, then arithmetic and
193     operators will be converted into their SymPy equivalents and the
194     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
195     be denested first. This is done via an AST transformation that replaces
196     operators with their SymPy equivalents, so if an operand redefines any
197     of those operations, the redefined operators will not be used.
198 
199     >>> sympify('2**2 / 3 + 5')
200     19/3
201     >>> sympify('2**2 / 3 + 5', evaluate=False)
202     2**2/3 + 5
203 
204     Extending
205     ---------
206 
207     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
208     just define a ``_sympy_`` method to your class. You can do that even to
209     classes that you do not own by subclassing or adding the method at runtime.
210 
211     >>> from sympy import Matrix
212     >>> class MyList1(object):
213     ...     def __iter__(self):
214     ...         yield 1
215     ...         yield 2
216     ...         return
217     ...     def __getitem__(self, i): return list(self)[i]
218     ...     def _sympy_(self): return Matrix(self)
219     >>> sympify(MyList1())
220     Matrix([
221     [1],
222     [2]])
223 
224     If you do not have control over the class definition you could also use the
225     ``converter`` global dictionary. The key is the class and the value is a
226     function that takes a single argument and returns the desired SymPy
227     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
228 
229     >>> class MyList2(object):   # XXX Do not do this if you control the class!
230     ...     def __iter__(self):  #     Use _sympy_!
231     ...         yield 1
232     ...         yield 2
233     ...         return
234     ...     def __getitem__(self, i): return list(self)[i]
235     >>> from sympy.core.sympify import converter
236     >>> converter[MyList2] = lambda x: Matrix(x)
237     >>> sympify(MyList2())
238     Matrix([
239     [1],
240     [2]])
241 
242     Notes
243     =====
244 
245     The keywords ``rational`` and ``convert_xor`` are only used
246     when the input is a string.
247 
248     Sometimes autosimplification during sympification results in expressions
249     that are very different in structure than what was entered. Until such
250     autosimplification is no longer done, the ``kernS`` function might be of
251     some use. In the example below you can see how an expression reduces to
252     -1 by autosimplification, but does not do so when ``kernS`` is used.
253 
254     >>> from sympy.core.sympify import kernS
255     >>> from sympy.abc import x
256     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
257     -1
258     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
259     >>> sympify(s)
260     -1
261     >>> kernS(s)
262     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
263 
264     """
265     is_sympy = getattr(a, '__sympy__', None)
266     if is_sympy is not None:
267         return a
268 
269     if isinstance(a, CantSympify):
270         raise SympifyError(a)
271     cls = getattr(a, "__class__", None)
272     if cls is None:
273         cls = type(a)  # Probably an old-style class
274     conv = converter.get(cls, None)
275     if conv is not None:
276         return conv(a)
277 
278     for superclass in getmro(cls):
279         try:
280             return converter[superclass](a)
281         except KeyError:
282             continue
283 
284     if cls is type(None):
285         if strict:
286             raise SympifyError(a)
287         else:
288             return a
289 
290     if evaluate is None:
291         if global_evaluate[0] is False:
292             evaluate = global_evaluate[0]
293         else:
294             evaluate = True
295 
296     # Support for basic numpy datatypes
297     # Note that this check exists to avoid importing NumPy when not necessary
298     if type(a).__module__ == 'numpy':
299         import numpy as np
300         if np.isscalar(a):
301             return _convert_numpy_types(a, locals=locals,
302                 convert_xor=convert_xor, strict=strict, rational=rational,
303                 evaluate=evaluate)
304 
305     _sympy_ = getattr(a, "_sympy_", None)
306     if _sympy_ is not None:
307         try:
308             return a._sympy_()
309         # XXX: Catches AttributeError: 'SympyConverter' object has no
310         # attribute 'tuple'
311         # This is probably a bug somewhere but for now we catch it here.
312         except AttributeError:
313             pass
314 
315     if not strict:
316         # Put numpy array conversion _before_ float/int, see
317         # <https://github.com/sympy/sympy/issues/13924>.
318         flat = getattr(a, "flat", None)
319         if flat is not None:
320             shape = getattr(a, "shape", None)
321             if shape is not None:
322                 from ..tensor.array import Array
323                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
324 
325     if not isinstance(a, string_types):
326         for coerce in (float, int):
327             try:
328                 coerced = coerce(a)
329             except (TypeError, ValueError):
330                 continue
331             # XXX: AttributeError only needed here for Py2
332             except AttributeError:
333                 continue
334             try:
335                 return sympify(coerced)
336             except SympifyError:
337                 continue
338 
339     if strict:
340         raise SympifyError(a)
341 
342     if iterable(a):
343         try:
344             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
345                 rational=rational) for x in a])
346         except TypeError:
347             # Not all iterables are rebuildable with their type.
348             pass
349     if isinstance(a, dict):
350         try:
351             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
352                 rational=rational) for x in a.items()])
353         except TypeError:
354             # Not all iterables are rebuildable with their type.
355             pass
356 
357     # At this point we were given an arbitrary expression
358     # which does not inherit from Basic and doesn't implement
359     # _sympy_ (which is a canonical and robust way to convert
360     # anything to SymPy expression).
361     #
362     # As a last chance, we try to take "a"'s normal form via unicode()
363     # and try to parse it. If it fails, then we have no luck and
364     # return an exception
365     try:
366         from .compatibility import unicode
367         a = unicode(a)
368     except Exception as exc:
369         raise SympifyError(a, exc)
370 
371     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
372                                             standard_transformations)
373     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
374     from sympy.parsing.sympy_parser import rationalize as t_rationalize
375 
376     transformations = standard_transformations
377 
378     if rational:
379         transformations += (t_rationalize,)
380     if convert_xor:
381         transformations += (t_convert_xor,)
382 
383     try:
384         a = a.replace('\n', '')
385         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
386     except (TokenError, SyntaxError) as exc:
387         raise SympifyError('could not parse %r' % a, exc)
388 
389     return expr

</code><intended_behavior>Modify the behavior to either securely parse string inputs without using eval or incorporate a more sophisticated method/input validation to ensure that only safe expressions are evaluated. The function should continue to convert a wide range of inputs into SymPy objects but with enhanced safety, explicitly avoiding the evaluation of arbitrary code through string representations.</intended_behavior>, <file>sympy/parsing/sympy_parser.py</file>
<class>None</class>
<method>eval_expr</method>
<code>
896 def eval_expr(code, local_dict, global_dict):
897     """
898     Evaluate Python code generated by ``stringify_expr``.
899 
900     Generally, ``parse_expr`` should be used.
901     """
902     expr = eval(
903         code, global_dict, local_dict)  # take local objects in preference
904 
905     return expr

</code><intended_behavior>Revisit the direct use of eval to ensure that it's not exposed to arbitrary code execution risks. This might involve replacing eval with a safer evaluation strategy or enforcing strict validation of the inputs before they reach eval. The function's capacity to convert parsed expressions into SymPy expressions should be maintained while ensuring the security and integrity of the operation.</intended_behavior>]
2025-10-15 14:26:28.322 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 14:26:28.323 | INFO     | Search-only: skipping patch selection
2025-10-15 14:26:28.395 | INFO     | Task sympy__sympy-18057 completed successfully.
2025-10-15 14:26:28.396 | INFO     | No patch generated. You can try running ACR again.
