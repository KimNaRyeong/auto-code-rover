diff --git a/sympy/stats/crv_types.py b/sympy/stats/crv_types.py
--- a/sympy/stats/crv_types.py
+++ b/sympy/stats/crv_types.py
@@ -163,6 +163,9 @@ def rv(symbol, cls, args):
 class ArcsinDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b')
 
+    def set(self):
+        return Interval(self.a, self.b)
+
     def pdf(self, x):
         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
 
@@ -871,6 +874,8 @@ def ChiSquared(name, k):
 class DagumDistribution(SingleContinuousDistribution):
     _argnames = ('p', 'a', 'b')
 
+    set = Interval(0, oo)
+
     @staticmethod
     def check(p, a, b):
         _value_check(p > 0, "Shape parameter p must be positive.")
@@ -1205,6 +1210,13 @@ def FDistribution(name, d1, d2):
 class FisherZDistribution(SingleContinuousDistribution):
     _argnames = ('d1', 'd2')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(d1, d2):
+        _value_check(d1 > 0, "Degree of freedom d1 must be positive.")
+        _value_check(d2 > 0, "Degree of freedom d2 must be positive.")
+
     def pdf(self, x):
         d1, d2 = self.d1, self.d2
         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
@@ -1276,6 +1288,11 @@ class FrechetDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(a, s, m):
+        _value_check(a > 0, "Shape parameter alpha must be positive.")
+        _value_check(s > 0, "Scale parameter s must be positive.")
+
     def __new__(cls, a, s=1, m=0):
         a, s, m = list(map(sympify, (a, s, m)))
         return Basic.__new__(cls, a, s, m)
@@ -1551,6 +1568,10 @@ class GumbelDistribution(SingleContinuousDistribution):
 
     set = Interval(-oo, oo)
 
+    @staticmethod
+    def check(beta, mu):
+        _value_check(beta > 0, "Scale parameter beta must be positive.")
+
     def pdf(self, x):
         beta, mu = self.beta, self.mu
         z = (x - mu)/beta
@@ -1564,7 +1585,7 @@ def _characteristic_function(self, t):
         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
 
     def _moment_generating_function(self, t):
-        return gamma(1 - self.beta*t) * exp(I*self.mu*t)
+        return gamma(1 - self.beta*t) * exp(self.mu*t)
 
 def Gumbel(name, beta, mu):
     r"""
@@ -1765,6 +1786,13 @@ def Kumaraswamy(name, a, b):
 class LaplaceDistribution(SingleContinuousDistribution):
     _argnames = ('mu', 'b')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(mu, b):
+        _value_check(b > 0, "Scale parameter b must be positive.")
+        _value_check(mu.is_real, "Location parameter mu should be real")
+
     def pdf(self, x):
         mu, b = self.mu, self.b
         return 1/(2*b)*exp(-Abs(x - mu)/b)
@@ -1852,6 +1880,12 @@ def Laplace(name, mu, b):
 class LogisticDistribution(SingleContinuousDistribution):
     _argnames = ('mu', 's')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(mu, s):
+        _value_check(s > 0, "Scale parameter s must be positive.")
+
     def pdf(self, x):
         mu, s = self.mu, self.s
         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
@@ -1864,7 +1898,7 @@ def _characteristic_function(self, t):
         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
 
     def _moment_generating_function(self, t):
-        return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
+        return exp(self.mu*t) * beta_fn(1 - self.s*t, 1 + self.s*t)
 
     def _quantile(self, p):
         return self.mu - self.s*log(-S.One + S.One/p)
@@ -2015,6 +2049,10 @@ class MaxwellDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(a):
+        _value_check(a > 0, "Parameter a must be positive.")
+
     def pdf(self, x):
         a = self.a
         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
@@ -2085,6 +2123,11 @@ class NakagamiDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(mu, omega):
+        _value_check(mu >= S.Half, "Shape parameter mu must be greater than equal to 1/2.")
+        _value_check(omega > 0, "Spread parameter omega must be positive.")
+
     def pdf(self, x):
         mu, omega = self.mu, self.omega
         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
@@ -2385,6 +2428,10 @@ class QuadraticUDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(self.a, self.b)
 
+    @staticmethod
+    def check(a, b):
+        _value_check(b > a, "Parameter b must be in range (%s, oo)."%(a))
+
     def pdf(self, x):
         a, b = self.a, self.b
         alpha = 12 / (b-a)**3
@@ -2553,6 +2600,10 @@ class RayleighDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(sigma):
+        _value_check(sigma > 0, "Scale parameter sigma must be positive.")
+
     def pdf(self, x):
         sigma = self.sigma
         return x/sigma**2*exp(-x**2/(2*sigma**2))
@@ -2690,6 +2741,12 @@ def ShiftedGompertz(name, b, eta):
 class StudentTDistribution(SingleContinuousDistribution):
     _argnames = ('nu',)
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(nu):
+        _value_check(nu > 0, "Degrees of freedom nu must be positive.")
+
     def pdf(self, x):
         nu = self.nu
         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
@@ -2770,6 +2827,19 @@ def StudentT(name, nu):
 class TrapezoidalDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b', 'c', 'd')
 
+    @property
+    def set(self):
+        return Interval(self.a, self.d)
+
+    @staticmethod
+    def check(a, b, c, d):
+        _value_check(a < d, "Lower bound parameter a < %s. a = %s"%(d, a))
+        _value_check((a <= b, b < c),
+        "Level start parameter b must be in range [%s, %s). b = %s"%(a, c, b))
+        _value_check((b < c, c <= d),
+        "Level end parameter c must be in range (%s, %s]. c = %s"%(b, d, c))
+        _value_check(d >= c, "Upper bound parameter d > %s. d = %s"%(c, d))
+
     def pdf(self, x):
         a, b, c, d = self.a, self.b, self.c, self.d
         return Piecewise(
@@ -2850,6 +2920,16 @@ def Trapezoidal(name, a, b, c, d):
 class TriangularDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b', 'c')
 
+    @property
+    def set(self):
+        return Interval(self.a, self.b)
+
+    @staticmethod
+    def check(a, b, c):
+        _value_check(b > a, "Parameter b > %s. b = %s"%(a, b))
+        _value_check((a <= c, c <= b),
+        "Parameter c must be in range [%s, %s]. c = %s"%(a, b, c))
+
     def pdf(self, x):
         a, b, c = self.a, self.b, self.c
         return Piecewise(
@@ -2864,7 +2944,7 @@ def _characteristic_function(self, t):
 
     def _moment_generating_function(self, t):
         a, b, c = self.a, self.b, self.c
-        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
+        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c - a) * exp(b * t)) / (
         (b - a) * (c - a) * (b - c) * t ** 2)
 
 
@@ -2940,6 +3020,14 @@ def Triangular(name, a, b, c):
 class UniformDistribution(SingleContinuousDistribution):
     _argnames = ('left', 'right')
 
+    @property
+    def set(self):
+        return Interval(self.left, self.right)
+
+    @staticmethod
+    def check(left, right):
+        _value_check(left < right, "Lower limit should be less than Upper limit.")
+
     def pdf(self, x):
         left, right = self.left, self.right
         return Piecewise(
@@ -3047,6 +3135,11 @@ class UniformSumDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(0, self.n)
 
+    @staticmethod
+    def check(n):
+        _value_check((n > 0, n.is_integer),
+        "Parameter n must be positive integer.")
+
     def pdf(self, x):
         n = self.n
         k = Dummy("k")
@@ -3292,6 +3385,10 @@ class WignerSemicircleDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(-self.R, self.R)
 
+    @staticmethod
+    def check(R):
+        _value_check(R > 0, "Radius R must be positive.")
+
     def pdf(self, x):
         R = self.R
         return 2/(pi*R**2)*sqrt(R**2 - x**2)
diff --git a/sympy/stats/joint_rv_types.py b/sympy/stats/joint_rv_types.py
--- a/sympy/stats/joint_rv_types.py
+++ b/sympy/stats/joint_rv_types.py
@@ -76,7 +76,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma):
+    @staticmethod
+    def check(mu, sigma):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the mean vector and covariance matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -117,7 +118,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma):
+    @staticmethod
+    def check(mu, sigma):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the mean vector and covariance matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -151,7 +153,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma, v):
+    @staticmethod
+    def check(mu, sigma, v):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the location vector and shape matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -196,7 +199,8 @@ class NormalGammaDistribution(JointDistribution):
     _argnames = ['mu', 'lamda', 'alpha', 'beta']
     is_Continuous=True
 
-    def check(self, mu, lamda, alpha, beta):
+    @staticmethod
+    def check(mu, lamda, alpha, beta):
         _value_check(mu.is_real, "Location must be real.")
         _value_check(lamda > 0, "Lambda must be positive")
         _value_check(alpha > 0, "alpha must be positive")
@@ -258,7 +262,8 @@ class MultivariateBetaDistribution(JointDistribution):
     _argnames = ['alpha']
     is_Continuous = True
 
-    def check(self, alpha):
+    @staticmethod
+    def check(alpha):
         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
         for a_k in alpha:
             _value_check((a_k > 0) != False, "Each concentration parameter"
@@ -331,7 +336,8 @@ class MultivariateEwensDistribution(JointDistribution):
     is_Discrete = True
     is_Continuous = False
 
-    def check(self, n, theta):
+    @staticmethod
+    def check(n, theta):
         _value_check(isinstance(n, Integer) and (n > 0) == True,
                         "sample size should be positive integer.")
         _value_check(theta.is_positive, "mutation rate should be positive.")
@@ -403,7 +409,8 @@ class MultinomialDistribution(JointDistribution):
     is_Continuous=False
     is_Discrete = True
 
-    def check(self, n, p):
+    @staticmethod
+    def check(n, p):
         _value_check(n > 0,
                         "number of trials must be a positve integer")
         for p_k in p:
@@ -471,7 +478,8 @@ class NegativeMultinomialDistribution(JointDistribution):
     is_Continuous=False
     is_Discrete = True
 
-    def check(self, k0, p):
+    @staticmethod
+    def check(k0, p):
         _value_check(k0 > 0,
                         "number of failures must be a positve integer")
         for p_k in p:
