2025-10-15 06:06:04.093 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 06:06:07.463 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=283, output_tokens=12, cost=0.003190
2025-10-15 06:06:07.464 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 06:06:07.467 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:06:15.045 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=592, output_tokens=303, cost=0.015010
2025-10-15 06:06:15.053 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:06:17.580 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=657, output_tokens=45, cost=0.007920
2025-10-15 06:06:17.582 | DEBUG    | Extracted a valid json.
2025-10-15 06:06:17.582 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"DjangoTranslation\")",
        "search_method(\"to_locale\")",
        "search_code(\"makemessages\")"
    ],
    "bug_locations": []
}
2025-10-15 06:06:17.643 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 06:06:17.644 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 06:06:38.623 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1561, output_tokens=797, cost=0.039520
2025-10-15 06:06:38.639 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:06:48.849 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2574, output_tokens=367, cost=0.036750
2025-10-15 06:06:48.857 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:06:56.957 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=721, output_tokens=290, cost=0.015910
2025-10-15 06:06:56.958 | DEBUG    | Extracted a valid json.
2025-10-15 06:06:56.958 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/management/commands/makemessages.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code responsible for validating locales in `makemessages.py` needs to be adjusted to correctly handle locale codes that include a variant after the country code, such as `nl-nl-x-informal`. Instead of rejecting these codes with an error suggesting an incorrect format, the code should: Utilize the logic similar to the `to_locale` method, which correctly parses and transforms language codes into locale names, to validate custom locales. Ensure that custom or extended locale strings (with additional descriptors beyond the primary language-sublanguage structure) are accepted and correctly mapped to their corresponding directory structures within the Django project. This adjustment allows for the inclusion of informal or variant language codes and supports the creation and updating of `.po` files in directories named accordingly, such as `nl_NL-x-informal`. The validation logic should be reviewed and possibly refactored to extend the straightforward language-country code parsing to accommodate \"-x-\" tagged variants, ensuring these are correctly interpreted as valid locales. Preserve existing functionality for standard locale codes while extending support for non-standard, project-specific locale variants. This ensures that developers can utilize Django’s internationalization frameworks even with highly customized locale settings."
        }
    ]
}
2025-10-15 06:06:56.964 | DEBUG    | Bug location extracted successfully: [<file>django/core/management/commands/makemessages.py</file>
<class>None</class>
<method>None</method>
<code>
1 import glob
2 import os
3 import re
4 import sys
5 from functools import total_ordering
6 from itertools import dropwhile
7 from pathlib import Path
8 
9 import django
10 from django.conf import settings
11 from django.core.exceptions import ImproperlyConfigured
12 from django.core.files.temp import NamedTemporaryFile
13 from django.core.management.base import BaseCommand, CommandError
14 from django.core.management.utils import (
15     find_command,
16     handle_extensions,
17     is_ignored_path,
18     popen_wrapper,
19 )
20 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
21 from django.utils.functional import cached_property
22 from django.utils.jslex import prepare_js_for_gettext
23 from django.utils.regex_helper import _lazy_re_compile
24 from django.utils.text import get_text_list
25 from django.utils.translation import templatize
26 
27 plural_forms_re = _lazy_re_compile(
28     r'^(?P<value>"Plural-Forms.+?\\n")\s*$', re.MULTILINE | re.DOTALL
29 )
30 STATUS_OK = 0
31 NO_LOCALE_DIR = object()
32 
33 
34 def check_programs(*programs):
35     for program in programs:
36         if find_command(program) is None:
37             raise CommandError(
38                 "Can't find %s. Make sure you have GNU gettext tools 0.15 or "
39                 "newer installed." % program
40             )
41 
42 
43 @total_ordering
44 class TranslatableFile:
45     def __init__(self, dirpath, file_name, locale_dir):
46         self.file = file_name
47         self.dirpath = dirpath
48         self.locale_dir = locale_dir
49 
50     def __repr__(self):
51         return "<%s: %s>" % (
52             self.__class__.__name__,
53             os.sep.join([self.dirpath, self.file]),
54         )
55 
56     def __eq__(self, other):
57         return self.path == other.path
58 
59     def __lt__(self, other):
60         return self.path < other.path
61 
62     @property
63     def path(self):
64         return os.path.join(self.dirpath, self.file)
65 
66 
67 class BuildFile:
68     """
69     Represent the state of a translatable file during the build process.
70     """
71 
72     def __init__(self, command, domain, translatable):
73         self.command = command
74         self.domain = domain
75         self.translatable = translatable
76 
77     @cached_property
78     def is_templatized(self):
79         if self.domain == "djangojs":
80             return self.command.gettext_version < (0, 18, 3)
81         elif self.domain == "django":
82             file_ext = os.path.splitext(self.translatable.file)[1]
83             return file_ext != ".py"
84         return False
85 
86     @cached_property
87     def path(self):
88         return self.translatable.path
89 
90     @cached_property
91     def work_path(self):
92         """
93         Path to a file which is being fed into GNU gettext pipeline. This may
94         be either a translatable or its preprocessed version.
95         """
96         if not self.is_templatized:
97             return self.path
98         extension = {
99             "djangojs": "c",
100             "django": "py",
101         }.get(self.domain)
102         filename = "%s.%s" % (self.translatable.file, extension)
103         return os.path.join(self.translatable.dirpath, filename)
104 
105     def preprocess(self):
106         """
107         Preprocess (if necessary) a translatable file before passing it to
108         xgettext GNU gettext utility.
109         """
110         if not self.is_templatized:
111             return
112 
113         with open(self.path, encoding="utf-8") as fp:
114             src_data = fp.read()
115 
116         if self.domain == "djangojs":
117             content = prepare_js_for_gettext(src_data)
118         elif self.domain == "django":
119             content = templatize(src_data, origin=self.path[2:])
120 
121         with open(self.work_path, "w", encoding="utf-8") as fp:
122             fp.write(content)
123 
124     def postprocess_messages(self, msgs):
125         """
126         Postprocess messages generated by xgettext GNU gettext utility.
127 
128         Transform paths as if these messages were generated from original
129         translatable files rather than from preprocessed versions.
130         """
131         if not self.is_templatized:
132             return msgs
133 
134         # Remove '.py' suffix
135         if os.name == "nt":
136             # Preserve '.\' prefix on Windows to respect gettext behavior
137             old_path = self.work_path
138             new_path = self.path
139         else:
140             old_path = self.work_path[2:]
141             new_path = self.path[2:]
142 
143         return re.sub(
144             r"^(#: .*)(" + re.escape(old_path) + r")",
145             lambda match: match[0].replace(old_path, new_path),
146             msgs,
147             flags=re.MULTILINE,
148         )
149 
150     def cleanup(self):
151         """
152         Remove a preprocessed copy of a translatable file (if any).
153         """
154         if self.is_templatized:
155             # This check is needed for the case of a symlinked file and its
156             # source being processed inside a single group (locale dir);
157             # removing either of those two removes both.
158             if os.path.exists(self.work_path):
159                 os.unlink(self.work_path)
160 
161 
162 def normalize_eols(raw_contents):
163     """
164     Take a block of raw text that will be passed through str.splitlines() to
165     get universal newlines treatment.
166 
167     Return the resulting block of text with normalized `\n` EOL sequences ready
168     to be written to disk using current platform's native EOLs.
169     """
170     lines_list = raw_contents.splitlines()
171     # Ensure last line has its EOL
172     if lines_list and lines_list[-1]:
173         lines_list.append("")
174     return "\n".join(lines_list)
175 
176 
177 def write_pot_file(potfile, msgs):
178     """
179     Write the `potfile` with the `msgs` contents, making sure its format is
180     valid.
181     """
182     pot_lines = msgs.splitlines()
183     if os.path.exists(potfile):
184         # Strip the header
185         lines = dropwhile(len, pot_lines)
186     else:
187         lines = []
188         found, header_read = False, False
189         for line in pot_lines:
190             if not found and not header_read:
191                 if "charset=CHARSET" in line:
192                     found = True
193                     line = line.replace("charset=CHARSET", "charset=UTF-8")
194             if not line and not found:
195                 header_read = True
196             lines.append(line)
197     msgs = "\n".join(lines)
198     # Force newlines of POT files to '\n' to work around
199     # https://savannah.gnu.org/bugs/index.php?52395
200     with open(potfile, "a", encoding="utf-8", newline="\n") as fp:
201         fp.write(msgs)
202 
203 
204 class Command(BaseCommand):
205     help = (
206         "Runs over the entire source tree of the current directory and pulls out all "
207         "strings marked for translation. It creates (or updates) a message file in the "
208         "conf/locale (in the django tree) or locale (for projects and applications) "
209         "directory.\n\nYou must run this command with one of either the --locale, "
210         "--exclude, or --all options."
211     )
212 
213     translatable_file_class = TranslatableFile
214     build_file_class = BuildFile
215 
216     requires_system_checks = []
217 
218     msgmerge_options = ["-q", "--backup=none", "--previous", "--update"]
219     msguniq_options = ["--to-code=utf-8"]
220     msgattrib_options = ["--no-obsolete"]
221     xgettext_options = ["--from-code=UTF-8", "--add-comments=Translators"]
222 
223     def add_arguments(self, parser):
224         parser.add_argument(
225             "--locale",
226             "-l",
227             default=[],
228             action="append",
229             help=(
230                 "Creates or updates the message files for the given locale(s) (e.g. "
231                 "pt_BR). Can be used multiple times."
232             ),
233         )
234         parser.add_argument(
235             "--exclude",
236             "-x",
237             default=[],
238             action="append",
239             help="Locales to exclude. Default is none. Can be used multiple times.",
240         )
241         parser.add_argument(
242             "--domain",
243             "-d",
244             default="django",
245             help='The domain of the message files (default: "django").',
246         )
247         parser.add_argument(
248             "--all",
249             "-a",
250             action="store_true",
251             help="Updates the message files for all existing locales.",
252         )
253         parser.add_argument(
254             "--extension",
255             "-e",
256             dest="extensions",
257             action="append",
258             help='The file extension(s) to examine (default: "html,txt,py", or "js" '
259             'if the domain is "djangojs"). Separate multiple extensions with '
260             "commas, or use -e multiple times.",
261         )
262         parser.add_argument(
263             "--symlinks",
264             "-s",
265             action="store_true",
266             help="Follows symlinks to directories when examining source code "
267             "and templates for translation strings.",
268         )
269         parser.add_argument(
270             "--ignore",
271             "-i",
272             action="append",
273             dest="ignore_patterns",
274             default=[],
275             metavar="PATTERN",
276             help="Ignore files or directories matching this glob-style pattern. "
277             "Use multiple times to ignore more.",
278         )
279         parser.add_argument(
280             "--no-default-ignore",
281             action="store_false",
282             dest="use_default_ignore_patterns",
283             help=(
284                 "Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and "
285                 "'*.pyc'."
286             ),
287         )
288         parser.add_argument(
289             "--no-wrap",
290             action="store_true",
291             help="Don't break long message lines into several lines.",
292         )
293         parser.add_argument(
294             "--no-location",
295             action="store_true",
296             help="Don't write '#: filename:line' lines.",
297         )
298         parser.add_argument(
299             "--add-location",
300             choices=("full", "file", "never"),
301             const="full",
302             nargs="?",
303             help=(
304                 "Controls '#: filename:line' lines. If the option is 'full' "
305                 "(the default if not given), the lines  include both file name "
306                 "and line number. If it's 'file', the line number is omitted. If "
307                 "it's 'never', the lines are suppressed (same as --no-location). "
308                 "--add-location requires gettext 0.19 or newer."
309             ),
310         )
311         parser.add_argument(
312             "--no-obsolete",
313             action="store_true",
314             help="Remove obsolete message strings.",
315         )
316         parser.add_argument(
317             "--keep-pot",
318             action="store_true",
319             help="Keep .pot file after making messages. Useful when debugging.",
320         )
321 
322     def handle(self, *args, **options):
323         locale = options["locale"]
324         exclude = options["exclude"]
325         self.domain = options["domain"]
326         self.verbosity = options["verbosity"]
327         process_all = options["all"]
328         extensions = options["extensions"]
329         self.symlinks = options["symlinks"]
330 
331         ignore_patterns = options["ignore_patterns"]
332         if options["use_default_ignore_patterns"]:
333             ignore_patterns += ["CVS", ".*", "*~", "*.pyc"]
334         self.ignore_patterns = list(set(ignore_patterns))
335 
336         # Avoid messing with mutable class variables
337         if options["no_wrap"]:
338             self.msgmerge_options = self.msgmerge_options[:] + ["--no-wrap"]
339             self.msguniq_options = self.msguniq_options[:] + ["--no-wrap"]
340             self.msgattrib_options = self.msgattrib_options[:] + ["--no-wrap"]
341             self.xgettext_options = self.xgettext_options[:] + ["--no-wrap"]
342         if options["no_location"]:
343             self.msgmerge_options = self.msgmerge_options[:] + ["--no-location"]
344             self.msguniq_options = self.msguniq_options[:] + ["--no-location"]
345             self.msgattrib_options = self.msgattrib_options[:] + ["--no-location"]
346             self.xgettext_options = self.xgettext_options[:] + ["--no-location"]
347         if options["add_location"]:
348             if self.gettext_version < (0, 19):
349                 raise CommandError(
350                     "The --add-location option requires gettext 0.19 or later. "
351                     "You have %s." % ".".join(str(x) for x in self.gettext_version)
352                 )
353             arg_add_location = "--add-location=%s" % options["add_location"]
354             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]
355             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]
356             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]
357             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]
358 
359         self.no_obsolete = options["no_obsolete"]
360         self.keep_pot = options["keep_pot"]
361 
362         if self.domain not in ("django", "djangojs"):
363             raise CommandError(
364                 "currently makemessages only supports domains "
365                 "'django' and 'djangojs'"
366             )
367         if self.domain == "djangojs":
368             exts = extensions or ["js"]
369         else:
370             exts = extensions or ["html", "txt", "py"]
371         self.extensions = handle_extensions(exts)
372 
373         if (not locale and not exclude and not process_all) or self.domain is None:
374             raise CommandError(
375                 "Type '%s help %s' for usage information."
376                 % (os.path.basename(sys.argv[0]), sys.argv[1])
377             )
378 
379         if self.verbosity > 1:
380             self.stdout.write(
381                 "examining files with the extensions: %s"
382                 % get_text_list(list(self.extensions), "and")
383             )
384 
385         self.invoked_for_django = False
386         self.locale_paths = []
387         self.default_locale_path = None
388         if os.path.isdir(os.path.join("conf", "locale")):
389             self.locale_paths = [os.path.abspath(os.path.join("conf", "locale"))]
390             self.default_locale_path = self.locale_paths[0]
391             self.invoked_for_django = True
392         else:
393             if self.settings_available:
394                 self.locale_paths.extend(settings.LOCALE_PATHS)
395             # Allow to run makemessages inside an app dir
396             if os.path.isdir("locale"):
397                 self.locale_paths.append(os.path.abspath("locale"))
398             if self.locale_paths:
399                 self.default_locale_path = self.locale_paths[0]
400                 os.makedirs(self.default_locale_path, exist_ok=True)
401 
402         # Build locale list
403         looks_like_locale = re.compile(r"[a-z]{2}")
404         locale_dirs = filter(
405             os.path.isdir, glob.glob("%s/*" % self.default_locale_path)
406         )
407         all_locales = [
408             lang_code
409             for lang_code in map(os.path.basename, locale_dirs)
410             if looks_like_locale.match(lang_code)
411         ]
412 
413         # Account for excluded locales
414         if process_all:
415             locales = all_locales
416         else:
417             locales = locale or all_locales
418             locales = set(locales).difference(exclude)
419 
420         if locales:
421             check_programs("msguniq", "msgmerge", "msgattrib")
422 
423         check_programs("xgettext")
424 
425         try:
426             potfiles = self.build_potfiles()
427 
428             # Build po files for each selected locale
429             for locale in locales:
430                 if "-" in locale:
431                     self.stdout.write(
432                         "invalid locale %s, did you mean %s?"
433                         % (
434                             locale,
435                             locale.replace("-", "_"),
436                         ),
437                     )
438                     continue
439                 if self.verbosity > 0:
440                     self.stdout.write("processing locale %s" % locale)
441                 for potfile in potfiles:
442                     self.write_po_file(potfile, locale)
443         finally:
444             if not self.keep_pot:
445                 self.remove_potfiles()
446 
447     @cached_property
448     def gettext_version(self):
449         # Gettext tools will output system-encoded bytestrings instead of UTF-8,
450         # when looking up the version. It's especially a problem on Windows.
451         out, err, status = popen_wrapper(
452             ["xgettext", "--version"],
453             stdout_encoding=DEFAULT_LOCALE_ENCODING,
454         )
455         m = re.search(r"(\d+)\.(\d+)\.?(\d+)?", out)
456         if m:
457             return tuple(int(d) for d in m.groups() if d is not None)
458         else:
459             raise CommandError("Unable to get gettext version. Is it installed?")
460 
461     @cached_property
462     def settings_available(self):
463         try:
464             settings.LOCALE_PATHS
465         except ImproperlyConfigured:
466             if self.verbosity > 1:
467                 self.stderr.write("Running without configured settings.")
468             return False
469         return True
470 
471     def build_potfiles(self):
472         """
473         Build pot files and apply msguniq to them.
474         """
475         file_list = self.find_files(".")
476         self.remove_potfiles()
477         self.process_files(file_list)
478         potfiles = []
479         for path in self.locale_paths:
480             potfile = os.path.join(path, "%s.pot" % self.domain)
481             if not os.path.exists(potfile):
482                 continue
483             args = ["msguniq"] + self.msguniq_options + [potfile]
484             msgs, errors, status = popen_wrapper(args)
485             if errors:
486                 if status != STATUS_OK:
487                     raise CommandError(
488                         "errors happened while running msguniq\n%s" % errors
489                     )
490                 elif self.verbosity > 0:
491                     self.stdout.write(errors)
492             msgs = normalize_eols(msgs)
493             with open(potfile, "w", encoding="utf-8") as fp:
494                 fp.write(msgs)
495             potfiles.append(potfile)
496         return potfiles
497 
498     def remove_potfiles(self):
499         for path in self.locale_paths:
500             pot_path = os.path.join(path, "%s.pot" % self.domain)
501             if os.path.exists(pot_path):
502                 os.unlink(pot_path)
503 
504     def find_files(self, root):
505         """
506         Get all files in the given root. Also check that there is a matching
507         locale dir for each file.
508         """
509         all_files = []
510         ignored_roots = []
511         if self.settings_available:
512             ignored_roots = [
513                 os.path.normpath(p)
514                 for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT)
515                 if p
516             ]
517         for dirpath, dirnames, filenames in os.walk(
518             root, topdown=True, followlinks=self.symlinks
519         ):
520             for dirname in dirnames[:]:
521                 if (
522                     is_ignored_path(
523                         os.path.normpath(os.path.join(dirpath, dirname)),
524                         self.ignore_patterns,
525                     )
526                     or os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots
527                 ):
528                     dirnames.remove(dirname)
529                     if self.verbosity > 1:
530                         self.stdout.write("ignoring directory %s" % dirname)
531                 elif dirname == "locale":
532                     dirnames.remove(dirname)
533                     self.locale_paths.insert(
534                         0, os.path.join(os.path.abspath(dirpath), dirname)
535                     )
536             for filename in filenames:
537                 file_path = os.path.normpath(os.path.join(dirpath, filename))
538                 file_ext = os.path.splitext(filename)[1]
539                 if file_ext not in self.extensions or is_ignored_path(
540                     file_path, self.ignore_patterns
541                 ):
542                     if self.verbosity > 1:
543                         self.stdout.write(
544                             "ignoring file %s in %s" % (filename, dirpath)
545                         )
546                 else:
547                     locale_dir = None
548                     for path in self.locale_paths:
549                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
550                             locale_dir = path
551                             break
552                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR
553                     all_files.append(
554                         self.translatable_file_class(dirpath, filename, locale_dir)
555                     )
556         return sorted(all_files)
557 
558     def process_files(self, file_list):
559         """
560         Group translatable files by locale directory and run pot file build
561         process for each group.
562         """
563         file_groups = {}
564         for translatable in file_list:
565             file_group = file_groups.setdefault(translatable.locale_dir, [])
566             file_group.append(translatable)
567         for locale_dir, files in file_groups.items():
568             self.process_locale_dir(locale_dir, files)
569 
570     def process_locale_dir(self, locale_dir, files):
571         """
572         Extract translatable literals from the specified files, creating or
573         updating the POT file for a given locale directory.
574 
575         Use the xgettext GNU gettext utility.
576         """
577         build_files = []
578         for translatable in files:
579             if self.verbosity > 1:
580                 self.stdout.write(
581                     "processing file %s in %s"
582                     % (translatable.file, translatable.dirpath)
583                 )
584             if self.domain not in ("djangojs", "django"):
585                 continue
586             build_file = self.build_file_class(self, self.domain, translatable)
587             try:
588                 build_file.preprocess()
589             except UnicodeDecodeError as e:
590                 self.stdout.write(
591                     "UnicodeDecodeError: skipped file %s in %s (reason: %s)"
592                     % (
593                         translatable.file,
594                         translatable.dirpath,
595                         e,
596                     )
597                 )
598                 continue
599             except BaseException:
600                 # Cleanup before exit.
601                 for build_file in build_files:
602                     build_file.cleanup()
603                 raise
604             build_files.append(build_file)
605 
606         if self.domain == "djangojs":
607             is_templatized = build_file.is_templatized
608             args = [
609                 "xgettext",
610                 "-d",
611                 self.domain,
612                 "--language=%s" % ("C" if is_templatized else "JavaScript",),
613                 "--keyword=gettext_noop",
614                 "--keyword=gettext_lazy",
615                 "--keyword=ngettext_lazy:1,2",
616                 "--keyword=pgettext:1c,2",
617                 "--keyword=npgettext:1c,2,3",
618                 "--output=-",
619             ]
620         elif self.domain == "django":
621             args = [
622                 "xgettext",
623                 "-d",
624                 self.domain,
625                 "--language=Python",
626                 "--keyword=gettext_noop",
627                 "--keyword=gettext_lazy",
628                 "--keyword=ngettext_lazy:1,2",
629                 "--keyword=pgettext:1c,2",
630                 "--keyword=npgettext:1c,2,3",
631                 "--keyword=pgettext_lazy:1c,2",
632                 "--keyword=npgettext_lazy:1c,2,3",
633                 "--output=-",
634             ]
635         else:
636             return
637 
638         input_files = [bf.work_path for bf in build_files]
639         with NamedTemporaryFile(mode="w+") as input_files_list:
640             input_files_list.write("\n".join(input_files))
641             input_files_list.flush()
642             args.extend(["--files-from", input_files_list.name])
643             args.extend(self.xgettext_options)
644             msgs, errors, status = popen_wrapper(args)
645 
646         if errors:
647             if status != STATUS_OK:
648                 for build_file in build_files:
649                     build_file.cleanup()
650                 raise CommandError(
651                     "errors happened while running xgettext on %s\n%s"
652                     % ("\n".join(input_files), errors)
653                 )
654             elif self.verbosity > 0:
655                 # Print warnings
656                 self.stdout.write(errors)
657 
658         if msgs:
659             if locale_dir is NO_LOCALE_DIR:
660                 for build_file in build_files:
661                     build_file.cleanup()
662                 file_path = os.path.normpath(build_files[0].path)
663                 raise CommandError(
664                     "Unable to find a locale path to store translations for "
665                     "file %s. Make sure the 'locale' directory exists in an "
666                     "app or LOCALE_PATHS setting is set." % file_path
667                 )
668             for build_file in build_files:
669                 msgs = build_file.postprocess_messages(msgs)
670             potfile = os.path.join(locale_dir, "%s.pot" % self.domain)
671             write_pot_file(potfile, msgs)
672 
673         for build_file in build_files:
674             build_file.cleanup()
675 
676     def write_po_file(self, potfile, locale):
677         """
678         Create or update the PO file for self.domain and `locale`.
679         Use contents of the existing `potfile`.
680 
681         Use msgmerge and msgattrib GNU gettext utilities.
682         """
683         basedir = os.path.join(os.path.dirname(potfile), locale, "LC_MESSAGES")
684         os.makedirs(basedir, exist_ok=True)
685         pofile = os.path.join(basedir, "%s.po" % self.domain)
686 
687         if os.path.exists(pofile):
688             args = ["msgmerge"] + self.msgmerge_options + [pofile, potfile]
689             _, errors, status = popen_wrapper(args)
690             if errors:
691                 if status != STATUS_OK:
692                     raise CommandError(
693                         "errors happened while running msgmerge\n%s" % errors
694                     )
695                 elif self.verbosity > 0:
696                     self.stdout.write(errors)
697             msgs = Path(pofile).read_text(encoding="utf-8")
698         else:
699             with open(potfile, encoding="utf-8") as fp:
700                 msgs = fp.read()
701             if not self.invoked_for_django:
702                 msgs = self.copy_plural_forms(msgs, locale)
703         msgs = normalize_eols(msgs)
704         msgs = msgs.replace(
705             "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self.domain, ""
706         )
707         with open(pofile, "w", encoding="utf-8") as fp:
708             fp.write(msgs)
709 
710         if self.no_obsolete:
711             args = ["msgattrib"] + self.msgattrib_options + ["-o", pofile, pofile]
712             msgs, errors, status = popen_wrapper(args)
713             if errors:
714                 if status != STATUS_OK:
715                     raise CommandError(
716                         "errors happened while running msgattrib\n%s" % errors
717                     )
718                 elif self.verbosity > 0:
719                     self.stdout.write(errors)
720 
721     def copy_plural_forms(self, msgs, locale):
722         """
723         Copy plural forms header contents from a Django catalog of locale to
724         the msgs string, inserting it at the right place. msgs should be the
725         contents of a newly created .po file.
726         """
727         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))
728         if self.domain == "djangojs":
729             domains = ("djangojs", "django")
730         else:
731             domains = ("django",)
732         for domain in domains:
733             django_po = os.path.join(
734                 django_dir, "conf", "locale", locale, "LC_MESSAGES", "%s.po" % domain
735             )
736             if os.path.exists(django_po):
737                 with open(django_po, encoding="utf-8") as fp:
738                     m = plural_forms_re.search(fp.read())
739                 if m:
740                     plural_form_line = m["value"]
741                     if self.verbosity > 1:
742                         self.stdout.write("copying plural forms: %s" % plural_form_line)
743                     lines = []
744                     found = False
745                     for line in msgs.splitlines():
746                         if not found and (not line or plural_forms_re.search(line)):
747                             line = plural_form_line
748                             found = True
749                         lines.append(line)
750                     msgs = "\n".join(lines)
751                     break
752         return msgs

</code><intended_behavior>The code responsible for validating locales in `makemessages.py` needs to be adjusted to correctly handle locale codes that include a variant after the country code, such as `nl-nl-x-informal`. Instead of rejecting these codes with an error suggesting an incorrect format, the code should: Utilize the logic similar to the `to_locale` method, which correctly parses and transforms language codes into locale names, to validate custom locales. Ensure that custom or extended locale strings (with additional descriptors beyond the primary language-sublanguage structure) are accepted and correctly mapped to their corresponding directory structures within the Django project. This adjustment allows for the inclusion of informal or variant language codes and supports the creation and updating of `.po` files in directories named accordingly, such as `nl_NL-x-informal`. The validation logic should be reviewed and possibly refactored to extend the straightforward language-country code parsing to accommodate "-x-" tagged variants, ensuring these are correctly interpreted as valid locales. Preserve existing functionality for standard locale codes while extending support for non-standard, project-specific locale variants. This ensures that developers can utilize Django’s internationalization frameworks even with highly customized locale settings.</intended_behavior>]
2025-10-15 06:06:56.964 | INFO     | Search completed. Bug locations: [<file>django/core/management/commands/makemessages.py</file>
<class>None</class>
<method>None</method>
<code>
1 import glob
2 import os
3 import re
4 import sys
5 from functools import total_ordering
6 from itertools import dropwhile
7 from pathlib import Path
8 
9 import django
10 from django.conf import settings
11 from django.core.exceptions import ImproperlyConfigured
12 from django.core.files.temp import NamedTemporaryFile
13 from django.core.management.base import BaseCommand, CommandError
14 from django.core.management.utils import (
15     find_command,
16     handle_extensions,
17     is_ignored_path,
18     popen_wrapper,
19 )
20 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
21 from django.utils.functional import cached_property
22 from django.utils.jslex import prepare_js_for_gettext
23 from django.utils.regex_helper import _lazy_re_compile
24 from django.utils.text import get_text_list
25 from django.utils.translation import templatize
26 
27 plural_forms_re = _lazy_re_compile(
28     r'^(?P<value>"Plural-Forms.+?\\n")\s*$', re.MULTILINE | re.DOTALL
29 )
30 STATUS_OK = 0
31 NO_LOCALE_DIR = object()
32 
33 
34 def check_programs(*programs):
35     for program in programs:
36         if find_command(program) is None:
37             raise CommandError(
38                 "Can't find %s. Make sure you have GNU gettext tools 0.15 or "
39                 "newer installed." % program
40             )
41 
42 
43 @total_ordering
44 class TranslatableFile:
45     def __init__(self, dirpath, file_name, locale_dir):
46         self.file = file_name
47         self.dirpath = dirpath
48         self.locale_dir = locale_dir
49 
50     def __repr__(self):
51         return "<%s: %s>" % (
52             self.__class__.__name__,
53             os.sep.join([self.dirpath, self.file]),
54         )
55 
56     def __eq__(self, other):
57         return self.path == other.path
58 
59     def __lt__(self, other):
60         return self.path < other.path
61 
62     @property
63     def path(self):
64         return os.path.join(self.dirpath, self.file)
65 
66 
67 class BuildFile:
68     """
69     Represent the state of a translatable file during the build process.
70     """
71 
72     def __init__(self, command, domain, translatable):
73         self.command = command
74         self.domain = domain
75         self.translatable = translatable
76 
77     @cached_property
78     def is_templatized(self):
79         if self.domain == "djangojs":
80             return self.command.gettext_version < (0, 18, 3)
81         elif self.domain == "django":
82             file_ext = os.path.splitext(self.translatable.file)[1]
83             return file_ext != ".py"
84         return False
85 
86     @cached_property
87     def path(self):
88         return self.translatable.path
89 
90     @cached_property
91     def work_path(self):
92         """
93         Path to a file which is being fed into GNU gettext pipeline. This may
94         be either a translatable or its preprocessed version.
95         """
96         if not self.is_templatized:
97             return self.path
98         extension = {
99             "djangojs": "c",
100             "django": "py",
101         }.get(self.domain)
102         filename = "%s.%s" % (self.translatable.file, extension)
103         return os.path.join(self.translatable.dirpath, filename)
104 
105     def preprocess(self):
106         """
107         Preprocess (if necessary) a translatable file before passing it to
108         xgettext GNU gettext utility.
109         """
110         if not self.is_templatized:
111             return
112 
113         with open(self.path, encoding="utf-8") as fp:
114             src_data = fp.read()
115 
116         if self.domain == "djangojs":
117             content = prepare_js_for_gettext(src_data)
118         elif self.domain == "django":
119             content = templatize(src_data, origin=self.path[2:])
120 
121         with open(self.work_path, "w", encoding="utf-8") as fp:
122             fp.write(content)
123 
124     def postprocess_messages(self, msgs):
125         """
126         Postprocess messages generated by xgettext GNU gettext utility.
127 
128         Transform paths as if these messages were generated from original
129         translatable files rather than from preprocessed versions.
130         """
131         if not self.is_templatized:
132             return msgs
133 
134         # Remove '.py' suffix
135         if os.name == "nt":
136             # Preserve '.\' prefix on Windows to respect gettext behavior
137             old_path = self.work_path
138             new_path = self.path
139         else:
140             old_path = self.work_path[2:]
141             new_path = self.path[2:]
142 
143         return re.sub(
144             r"^(#: .*)(" + re.escape(old_path) + r")",
145             lambda match: match[0].replace(old_path, new_path),
146             msgs,
147             flags=re.MULTILINE,
148         )
149 
150     def cleanup(self):
151         """
152         Remove a preprocessed copy of a translatable file (if any).
153         """
154         if self.is_templatized:
155             # This check is needed for the case of a symlinked file and its
156             # source being processed inside a single group (locale dir);
157             # removing either of those two removes both.
158             if os.path.exists(self.work_path):
159                 os.unlink(self.work_path)
160 
161 
162 def normalize_eols(raw_contents):
163     """
164     Take a block of raw text that will be passed through str.splitlines() to
165     get universal newlines treatment.
166 
167     Return the resulting block of text with normalized `\n` EOL sequences ready
168     to be written to disk using current platform's native EOLs.
169     """
170     lines_list = raw_contents.splitlines()
171     # Ensure last line has its EOL
172     if lines_list and lines_list[-1]:
173         lines_list.append("")
174     return "\n".join(lines_list)
175 
176 
177 def write_pot_file(potfile, msgs):
178     """
179     Write the `potfile` with the `msgs` contents, making sure its format is
180     valid.
181     """
182     pot_lines = msgs.splitlines()
183     if os.path.exists(potfile):
184         # Strip the header
185         lines = dropwhile(len, pot_lines)
186     else:
187         lines = []
188         found, header_read = False, False
189         for line in pot_lines:
190             if not found and not header_read:
191                 if "charset=CHARSET" in line:
192                     found = True
193                     line = line.replace("charset=CHARSET", "charset=UTF-8")
194             if not line and not found:
195                 header_read = True
196             lines.append(line)
197     msgs = "\n".join(lines)
198     # Force newlines of POT files to '\n' to work around
199     # https://savannah.gnu.org/bugs/index.php?52395
200     with open(potfile, "a", encoding="utf-8", newline="\n") as fp:
201         fp.write(msgs)
202 
203 
204 class Command(BaseCommand):
205     help = (
206         "Runs over the entire source tree of the current directory and pulls out all "
207         "strings marked for translation. It creates (or updates) a message file in the "
208         "conf/locale (in the django tree) or locale (for projects and applications) "
209         "directory.\n\nYou must run this command with one of either the --locale, "
210         "--exclude, or --all options."
211     )
212 
213     translatable_file_class = TranslatableFile
214     build_file_class = BuildFile
215 
216     requires_system_checks = []
217 
218     msgmerge_options = ["-q", "--backup=none", "--previous", "--update"]
219     msguniq_options = ["--to-code=utf-8"]
220     msgattrib_options = ["--no-obsolete"]
221     xgettext_options = ["--from-code=UTF-8", "--add-comments=Translators"]
222 
223     def add_arguments(self, parser):
224         parser.add_argument(
225             "--locale",
226             "-l",
227             default=[],
228             action="append",
229             help=(
230                 "Creates or updates the message files for the given locale(s) (e.g. "
231                 "pt_BR). Can be used multiple times."
232             ),
233         )
234         parser.add_argument(
235             "--exclude",
236             "-x",
237             default=[],
238             action="append",
239             help="Locales to exclude. Default is none. Can be used multiple times.",
240         )
241         parser.add_argument(
242             "--domain",
243             "-d",
244             default="django",
245             help='The domain of the message files (default: "django").',
246         )
247         parser.add_argument(
248             "--all",
249             "-a",
250             action="store_true",
251             help="Updates the message files for all existing locales.",
252         )
253         parser.add_argument(
254             "--extension",
255             "-e",
256             dest="extensions",
257             action="append",
258             help='The file extension(s) to examine (default: "html,txt,py", or "js" '
259             'if the domain is "djangojs"). Separate multiple extensions with '
260             "commas, or use -e multiple times.",
261         )
262         parser.add_argument(
263             "--symlinks",
264             "-s",
265             action="store_true",
266             help="Follows symlinks to directories when examining source code "
267             "and templates for translation strings.",
268         )
269         parser.add_argument(
270             "--ignore",
271             "-i",
272             action="append",
273             dest="ignore_patterns",
274             default=[],
275             metavar="PATTERN",
276             help="Ignore files or directories matching this glob-style pattern. "
277             "Use multiple times to ignore more.",
278         )
279         parser.add_argument(
280             "--no-default-ignore",
281             action="store_false",
282             dest="use_default_ignore_patterns",
283             help=(
284                 "Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and "
285                 "'*.pyc'."
286             ),
287         )
288         parser.add_argument(
289             "--no-wrap",
290             action="store_true",
291             help="Don't break long message lines into several lines.",
292         )
293         parser.add_argument(
294             "--no-location",
295             action="store_true",
296             help="Don't write '#: filename:line' lines.",
297         )
298         parser.add_argument(
299             "--add-location",
300             choices=("full", "file", "never"),
301             const="full",
302             nargs="?",
303             help=(
304                 "Controls '#: filename:line' lines. If the option is 'full' "
305                 "(the default if not given), the lines  include both file name "
306                 "and line number. If it's 'file', the line number is omitted. If "
307                 "it's 'never', the lines are suppressed (same as --no-location). "
308                 "--add-location requires gettext 0.19 or newer."
309             ),
310         )
311         parser.add_argument(
312             "--no-obsolete",
313             action="store_true",
314             help="Remove obsolete message strings.",
315         )
316         parser.add_argument(
317             "--keep-pot",
318             action="store_true",
319             help="Keep .pot file after making messages. Useful when debugging.",
320         )
321 
322     def handle(self, *args, **options):
323         locale = options["locale"]
324         exclude = options["exclude"]
325         self.domain = options["domain"]
326         self.verbosity = options["verbosity"]
327         process_all = options["all"]
328         extensions = options["extensions"]
329         self.symlinks = options["symlinks"]
330 
331         ignore_patterns = options["ignore_patterns"]
332         if options["use_default_ignore_patterns"]:
333             ignore_patterns += ["CVS", ".*", "*~", "*.pyc"]
334         self.ignore_patterns = list(set(ignore_patterns))
335 
336         # Avoid messing with mutable class variables
337         if options["no_wrap"]:
338             self.msgmerge_options = self.msgmerge_options[:] + ["--no-wrap"]
339             self.msguniq_options = self.msguniq_options[:] + ["--no-wrap"]
340             self.msgattrib_options = self.msgattrib_options[:] + ["--no-wrap"]
341             self.xgettext_options = self.xgettext_options[:] + ["--no-wrap"]
342         if options["no_location"]:
343             self.msgmerge_options = self.msgmerge_options[:] + ["--no-location"]
344             self.msguniq_options = self.msguniq_options[:] + ["--no-location"]
345             self.msgattrib_options = self.msgattrib_options[:] + ["--no-location"]
346             self.xgettext_options = self.xgettext_options[:] + ["--no-location"]
347         if options["add_location"]:
348             if self.gettext_version < (0, 19):
349                 raise CommandError(
350                     "The --add-location option requires gettext 0.19 or later. "
351                     "You have %s." % ".".join(str(x) for x in self.gettext_version)
352                 )
353             arg_add_location = "--add-location=%s" % options["add_location"]
354             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]
355             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]
356             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]
357             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]
358 
359         self.no_obsolete = options["no_obsolete"]
360         self.keep_pot = options["keep_pot"]
361 
362         if self.domain not in ("django", "djangojs"):
363             raise CommandError(
364                 "currently makemessages only supports domains "
365                 "'django' and 'djangojs'"
366             )
367         if self.domain == "djangojs":
368             exts = extensions or ["js"]
369         else:
370             exts = extensions or ["html", "txt", "py"]
371         self.extensions = handle_extensions(exts)
372 
373         if (not locale and not exclude and not process_all) or self.domain is None:
374             raise CommandError(
375                 "Type '%s help %s' for usage information."
376                 % (os.path.basename(sys.argv[0]), sys.argv[1])
377             )
378 
379         if self.verbosity > 1:
380             self.stdout.write(
381                 "examining files with the extensions: %s"
382                 % get_text_list(list(self.extensions), "and")
383             )
384 
385         self.invoked_for_django = False
386         self.locale_paths = []
387         self.default_locale_path = None
388         if os.path.isdir(os.path.join("conf", "locale")):
389             self.locale_paths = [os.path.abspath(os.path.join("conf", "locale"))]
390             self.default_locale_path = self.locale_paths[0]
391             self.invoked_for_django = True
392         else:
393             if self.settings_available:
394                 self.locale_paths.extend(settings.LOCALE_PATHS)
395             # Allow to run makemessages inside an app dir
396             if os.path.isdir("locale"):
397                 self.locale_paths.append(os.path.abspath("locale"))
398             if self.locale_paths:
399                 self.default_locale_path = self.locale_paths[0]
400                 os.makedirs(self.default_locale_path, exist_ok=True)
401 
402         # Build locale list
403         looks_like_locale = re.compile(r"[a-z]{2}")
404         locale_dirs = filter(
405             os.path.isdir, glob.glob("%s/*" % self.default_locale_path)
406         )
407         all_locales = [
408             lang_code
409             for lang_code in map(os.path.basename, locale_dirs)
410             if looks_like_locale.match(lang_code)
411         ]
412 
413         # Account for excluded locales
414         if process_all:
415             locales = all_locales
416         else:
417             locales = locale or all_locales
418             locales = set(locales).difference(exclude)
419 
420         if locales:
421             check_programs("msguniq", "msgmerge", "msgattrib")
422 
423         check_programs("xgettext")
424 
425         try:
426             potfiles = self.build_potfiles()
427 
428             # Build po files for each selected locale
429             for locale in locales:
430                 if "-" in locale:
431                     self.stdout.write(
432                         "invalid locale %s, did you mean %s?"
433                         % (
434                             locale,
435                             locale.replace("-", "_"),
436                         ),
437                     )
438                     continue
439                 if self.verbosity > 0:
440                     self.stdout.write("processing locale %s" % locale)
441                 for potfile in potfiles:
442                     self.write_po_file(potfile, locale)
443         finally:
444             if not self.keep_pot:
445                 self.remove_potfiles()
446 
447     @cached_property
448     def gettext_version(self):
449         # Gettext tools will output system-encoded bytestrings instead of UTF-8,
450         # when looking up the version. It's especially a problem on Windows.
451         out, err, status = popen_wrapper(
452             ["xgettext", "--version"],
453             stdout_encoding=DEFAULT_LOCALE_ENCODING,
454         )
455         m = re.search(r"(\d+)\.(\d+)\.?(\d+)?", out)
456         if m:
457             return tuple(int(d) for d in m.groups() if d is not None)
458         else:
459             raise CommandError("Unable to get gettext version. Is it installed?")
460 
461     @cached_property
462     def settings_available(self):
463         try:
464             settings.LOCALE_PATHS
465         except ImproperlyConfigured:
466             if self.verbosity > 1:
467                 self.stderr.write("Running without configured settings.")
468             return False
469         return True
470 
471     def build_potfiles(self):
472         """
473         Build pot files and apply msguniq to them.
474         """
475         file_list = self.find_files(".")
476         self.remove_potfiles()
477         self.process_files(file_list)
478         potfiles = []
479         for path in self.locale_paths:
480             potfile = os.path.join(path, "%s.pot" % self.domain)
481             if not os.path.exists(potfile):
482                 continue
483             args = ["msguniq"] + self.msguniq_options + [potfile]
484             msgs, errors, status = popen_wrapper(args)
485             if errors:
486                 if status != STATUS_OK:
487                     raise CommandError(
488                         "errors happened while running msguniq\n%s" % errors
489                     )
490                 elif self.verbosity > 0:
491                     self.stdout.write(errors)
492             msgs = normalize_eols(msgs)
493             with open(potfile, "w", encoding="utf-8") as fp:
494                 fp.write(msgs)
495             potfiles.append(potfile)
496         return potfiles
497 
498     def remove_potfiles(self):
499         for path in self.locale_paths:
500             pot_path = os.path.join(path, "%s.pot" % self.domain)
501             if os.path.exists(pot_path):
502                 os.unlink(pot_path)
503 
504     def find_files(self, root):
505         """
506         Get all files in the given root. Also check that there is a matching
507         locale dir for each file.
508         """
509         all_files = []
510         ignored_roots = []
511         if self.settings_available:
512             ignored_roots = [
513                 os.path.normpath(p)
514                 for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT)
515                 if p
516             ]
517         for dirpath, dirnames, filenames in os.walk(
518             root, topdown=True, followlinks=self.symlinks
519         ):
520             for dirname in dirnames[:]:
521                 if (
522                     is_ignored_path(
523                         os.path.normpath(os.path.join(dirpath, dirname)),
524                         self.ignore_patterns,
525                     )
526                     or os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots
527                 ):
528                     dirnames.remove(dirname)
529                     if self.verbosity > 1:
530                         self.stdout.write("ignoring directory %s" % dirname)
531                 elif dirname == "locale":
532                     dirnames.remove(dirname)
533                     self.locale_paths.insert(
534                         0, os.path.join(os.path.abspath(dirpath), dirname)
535                     )
536             for filename in filenames:
537                 file_path = os.path.normpath(os.path.join(dirpath, filename))
538                 file_ext = os.path.splitext(filename)[1]
539                 if file_ext not in self.extensions or is_ignored_path(
540                     file_path, self.ignore_patterns
541                 ):
542                     if self.verbosity > 1:
543                         self.stdout.write(
544                             "ignoring file %s in %s" % (filename, dirpath)
545                         )
546                 else:
547                     locale_dir = None
548                     for path in self.locale_paths:
549                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
550                             locale_dir = path
551                             break
552                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR
553                     all_files.append(
554                         self.translatable_file_class(dirpath, filename, locale_dir)
555                     )
556         return sorted(all_files)
557 
558     def process_files(self, file_list):
559         """
560         Group translatable files by locale directory and run pot file build
561         process for each group.
562         """
563         file_groups = {}
564         for translatable in file_list:
565             file_group = file_groups.setdefault(translatable.locale_dir, [])
566             file_group.append(translatable)
567         for locale_dir, files in file_groups.items():
568             self.process_locale_dir(locale_dir, files)
569 
570     def process_locale_dir(self, locale_dir, files):
571         """
572         Extract translatable literals from the specified files, creating or
573         updating the POT file for a given locale directory.
574 
575         Use the xgettext GNU gettext utility.
576         """
577         build_files = []
578         for translatable in files:
579             if self.verbosity > 1:
580                 self.stdout.write(
581                     "processing file %s in %s"
582                     % (translatable.file, translatable.dirpath)
583                 )
584             if self.domain not in ("djangojs", "django"):
585                 continue
586             build_file = self.build_file_class(self, self.domain, translatable)
587             try:
588                 build_file.preprocess()
589             except UnicodeDecodeError as e:
590                 self.stdout.write(
591                     "UnicodeDecodeError: skipped file %s in %s (reason: %s)"
592                     % (
593                         translatable.file,
594                         translatable.dirpath,
595                         e,
596                     )
597                 )
598                 continue
599             except BaseException:
600                 # Cleanup before exit.
601                 for build_file in build_files:
602                     build_file.cleanup()
603                 raise
604             build_files.append(build_file)
605 
606         if self.domain == "djangojs":
607             is_templatized = build_file.is_templatized
608             args = [
609                 "xgettext",
610                 "-d",
611                 self.domain,
612                 "--language=%s" % ("C" if is_templatized else "JavaScript",),
613                 "--keyword=gettext_noop",
614                 "--keyword=gettext_lazy",
615                 "--keyword=ngettext_lazy:1,2",
616                 "--keyword=pgettext:1c,2",
617                 "--keyword=npgettext:1c,2,3",
618                 "--output=-",
619             ]
620         elif self.domain == "django":
621             args = [
622                 "xgettext",
623                 "-d",
624                 self.domain,
625                 "--language=Python",
626                 "--keyword=gettext_noop",
627                 "--keyword=gettext_lazy",
628                 "--keyword=ngettext_lazy:1,2",
629                 "--keyword=pgettext:1c,2",
630                 "--keyword=npgettext:1c,2,3",
631                 "--keyword=pgettext_lazy:1c,2",
632                 "--keyword=npgettext_lazy:1c,2,3",
633                 "--output=-",
634             ]
635         else:
636             return
637 
638         input_files = [bf.work_path for bf in build_files]
639         with NamedTemporaryFile(mode="w+") as input_files_list:
640             input_files_list.write("\n".join(input_files))
641             input_files_list.flush()
642             args.extend(["--files-from", input_files_list.name])
643             args.extend(self.xgettext_options)
644             msgs, errors, status = popen_wrapper(args)
645 
646         if errors:
647             if status != STATUS_OK:
648                 for build_file in build_files:
649                     build_file.cleanup()
650                 raise CommandError(
651                     "errors happened while running xgettext on %s\n%s"
652                     % ("\n".join(input_files), errors)
653                 )
654             elif self.verbosity > 0:
655                 # Print warnings
656                 self.stdout.write(errors)
657 
658         if msgs:
659             if locale_dir is NO_LOCALE_DIR:
660                 for build_file in build_files:
661                     build_file.cleanup()
662                 file_path = os.path.normpath(build_files[0].path)
663                 raise CommandError(
664                     "Unable to find a locale path to store translations for "
665                     "file %s. Make sure the 'locale' directory exists in an "
666                     "app or LOCALE_PATHS setting is set." % file_path
667                 )
668             for build_file in build_files:
669                 msgs = build_file.postprocess_messages(msgs)
670             potfile = os.path.join(locale_dir, "%s.pot" % self.domain)
671             write_pot_file(potfile, msgs)
672 
673         for build_file in build_files:
674             build_file.cleanup()
675 
676     def write_po_file(self, potfile, locale):
677         """
678         Create or update the PO file for self.domain and `locale`.
679         Use contents of the existing `potfile`.
680 
681         Use msgmerge and msgattrib GNU gettext utilities.
682         """
683         basedir = os.path.join(os.path.dirname(potfile), locale, "LC_MESSAGES")
684         os.makedirs(basedir, exist_ok=True)
685         pofile = os.path.join(basedir, "%s.po" % self.domain)
686 
687         if os.path.exists(pofile):
688             args = ["msgmerge"] + self.msgmerge_options + [pofile, potfile]
689             _, errors, status = popen_wrapper(args)
690             if errors:
691                 if status != STATUS_OK:
692                     raise CommandError(
693                         "errors happened while running msgmerge\n%s" % errors
694                     )
695                 elif self.verbosity > 0:
696                     self.stdout.write(errors)
697             msgs = Path(pofile).read_text(encoding="utf-8")
698         else:
699             with open(potfile, encoding="utf-8") as fp:
700                 msgs = fp.read()
701             if not self.invoked_for_django:
702                 msgs = self.copy_plural_forms(msgs, locale)
703         msgs = normalize_eols(msgs)
704         msgs = msgs.replace(
705             "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self.domain, ""
706         )
707         with open(pofile, "w", encoding="utf-8") as fp:
708             fp.write(msgs)
709 
710         if self.no_obsolete:
711             args = ["msgattrib"] + self.msgattrib_options + ["-o", pofile, pofile]
712             msgs, errors, status = popen_wrapper(args)
713             if errors:
714                 if status != STATUS_OK:
715                     raise CommandError(
716                         "errors happened while running msgattrib\n%s" % errors
717                     )
718                 elif self.verbosity > 0:
719                     self.stdout.write(errors)
720 
721     def copy_plural_forms(self, msgs, locale):
722         """
723         Copy plural forms header contents from a Django catalog of locale to
724         the msgs string, inserting it at the right place. msgs should be the
725         contents of a newly created .po file.
726         """
727         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))
728         if self.domain == "djangojs":
729             domains = ("djangojs", "django")
730         else:
731             domains = ("django",)
732         for domain in domains:
733             django_po = os.path.join(
734                 django_dir, "conf", "locale", locale, "LC_MESSAGES", "%s.po" % domain
735             )
736             if os.path.exists(django_po):
737                 with open(django_po, encoding="utf-8") as fp:
738                     m = plural_forms_re.search(fp.read())
739                 if m:
740                     plural_form_line = m["value"]
741                     if self.verbosity > 1:
742                         self.stdout.write("copying plural forms: %s" % plural_form_line)
743                     lines = []
744                     found = False
745                     for line in msgs.splitlines():
746                         if not found and (not line or plural_forms_re.search(line)):
747                             line = plural_form_line
748                             found = True
749                         lines.append(line)
750                     msgs = "\n".join(lines)
751                     break
752         return msgs

</code><intended_behavior>The code responsible for validating locales in `makemessages.py` needs to be adjusted to correctly handle locale codes that include a variant after the country code, such as `nl-nl-x-informal`. Instead of rejecting these codes with an error suggesting an incorrect format, the code should: Utilize the logic similar to the `to_locale` method, which correctly parses and transforms language codes into locale names, to validate custom locales. Ensure that custom or extended locale strings (with additional descriptors beyond the primary language-sublanguage structure) are accepted and correctly mapped to their corresponding directory structures within the Django project. This adjustment allows for the inclusion of informal or variant language codes and supports the creation and updating of `.po` files in directories named accordingly, such as `nl_NL-x-informal`. The validation logic should be reviewed and possibly refactored to extend the straightforward language-country code parsing to accommodate "-x-" tagged variants, ensuring these are correctly interpreted as valid locales. Preserve existing functionality for standard locale codes while extending support for non-standard, project-specific locale variants. This ensures that developers can utilize Django’s internationalization frameworks even with highly customized locale settings.</intended_behavior>]
2025-10-15 06:06:56.965 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 06:06:56.965 | INFO     | Search-only: skipping patch selection
2025-10-15 06:06:57.103 | INFO     | Task django__django-15521 completed successfully.
2025-10-15 06:06:57.104 | INFO     | No patch generated. You can try running ACR again.
