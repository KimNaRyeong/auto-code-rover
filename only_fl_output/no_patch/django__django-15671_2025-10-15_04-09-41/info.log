2025-10-15 04:09:41.720 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 04:09:46.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=146, output_tokens=12, cost=0.001820
2025-10-15 04:09:46.577 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 04:09:46.581 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:09:52.839 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=455, output_tokens=223, cost=0.011240
2025-10-15 04:09:52.842 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:09:57.260 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=577, output_tokens=44, cost=0.007090
2025-10-15 04:09:57.262 | DEBUG    | Extracted a valid json.
2025-10-15 04:09:57.262 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"BaseFormSet\")",
        "search_method(\"clean\")",
        "search_code(\"default_error_messages\")"
    ],
    "bug_locations": []
}
2025-10-15 04:09:57.394 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:09:57.395 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:10:12.313 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1852, output_tokens=653, cost=0.038110
2025-10-15 04:10:12.320 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:10:20.099 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2721, output_tokens=307, cost=0.036420
2025-10-15 04:10:20.105 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:10:26.730 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=661, output_tokens=266, cost=0.014590
2025-10-15 04:10:26.731 | DEBUG    | Extracted a valid json.
2025-10-15 04:10:26.731 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/forms/formsets.py",
            "class": "BaseFormSet",
            "method": "",
            "intended_behavior": "Within BaseFormSet, the default_error_messages dictionary should be expanded to include default messages for errors related to the minimum and maximum number of forms allowed in a formset (e.g., 'too few forms' and 'too many forms'). The keys for these messages could be named something like min_num_forms_error and max_num_forms_error. This will allow these messages to be overridden through the error_messages argument upon formset instantiation."
        },
        {
            "file": "django/forms/formsets.py",
            "class": "BaseFormSet",
            "method": "clean",
            "intended_behavior": "The clean method should be modified (or ensured) to use the newly added default error messages from default_error_messages when validation fails due to a number of forms being below the minimum or above the maximum allowed. Specifically, it needs to check if the custom error messages are provided through the error_messages argument and use them; otherwise, fall back to the default messages. This ensures that the functionality for a custom number of forms is preserved while enabling message customization."
        }
    ]
}
2025-10-15 04:10:26.739 | DEBUG    | Bug location extracted successfully: [<file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>Within BaseFormSet, the default_error_messages dictionary should be expanded to include default messages for errors related to the minimum and maximum number of forms allowed in a formset (e.g., 'too few forms' and 'too many forms'). The keys for these messages could be named something like min_num_forms_error and max_num_forms_error. This will allow these messages to be overridden through the error_messages argument upon formset instantiation.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>clean</method>
<code>
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass

</code><intended_behavior>The clean method should be modified (or ensured) to use the newly added default error messages from default_error_messages when validation fails due to a number of forms being below the minimum or above the maximum allowed. Specifically, it needs to check if the custom error messages are provided through the error_messages argument and use them; otherwise, fall back to the default messages. This ensures that the functionality for a custom number of forms is preserved while enabling message customization.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 04:10:26.739 | INFO     | Search completed. Bug locations: [<file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>Within BaseFormSet, the default_error_messages dictionary should be expanded to include default messages for errors related to the minimum and maximum number of forms allowed in a formset (e.g., 'too few forms' and 'too many forms'). The keys for these messages could be named something like min_num_forms_error and max_num_forms_error. This will allow these messages to be overridden through the error_messages argument upon formset instantiation.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>clean</method>
<code>
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass

</code><intended_behavior>The clean method should be modified (or ensured) to use the newly added default error messages from default_error_messages when validation fails due to a number of forms being below the minimum or above the maximum allowed. Specifically, it needs to check if the custom error messages are provided through the error_messages argument and use them; otherwise, fall back to the default messages. This ensures that the functionality for a custom number of forms is preserved while enabling message customization.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 04:10:26.739 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 04:10:26.739 | INFO     | Search-only: skipping patch selection
2025-10-15 04:10:26.894 | INFO     | Task django__django-15671 completed successfully.
2025-10-15 04:10:26.895 | INFO     | No patch generated. You can try running ACR again.
