[
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/fields/__init__.py",
        "start": 1,
        "end": 2773,
        "class_name": null,
        "method_name": null,
        "code": "1 import collections.abc\n2 import copy\n3 import datetime\n4 import decimal\n5 import math\n6 import operator\n7 import uuid\n8 import warnings\n9 from base64 import b64decode, b64encode\n10 from functools import partialmethod, total_ordering\n11 \n12 from django import forms\n13 from django.apps import apps\n14 from django.conf import settings\n15 from django.core import checks, exceptions, validators\n16 from django.db import connection, connections, router\n17 from django.db.models.constants import LOOKUP_SEP\n18 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n19 from django.utils import timezone\n20 from django.utils.datastructures import DictWrapper\n21 from django.utils.dateparse import (\n22     parse_date,\n23     parse_datetime,\n24     parse_duration,\n25     parse_time,\n26 )\n27 from django.utils.duration import duration_microseconds, duration_string\n28 from django.utils.functional import Promise, cached_property\n29 from django.utils.ipv6 import clean_ipv6_address\n30 from django.utils.itercompat import is_iterable\n31 from django.utils.text import capfirst\n32 from django.utils.translation import gettext_lazy as _\n33 \n34 __all__ = [\n35     \"AutoField\",\n36     \"BLANK_CHOICE_DASH\",\n37     \"BigAutoField\",\n38     \"BigIntegerField\",\n39     \"BinaryField\",\n40     \"BooleanField\",\n41     \"CharField\",\n42     \"CommaSeparatedIntegerField\",\n43     \"DateField\",\n44     \"DateTimeField\",\n45     \"DecimalField\",\n46     \"DurationField\",\n47     \"EmailField\",\n48     \"Empty\",\n49     \"Field\",\n50     \"FilePathField\",\n51     \"FloatField\",\n52     \"GenericIPAddressField\",\n53     \"IPAddressField\",\n54     \"IntegerField\",\n55     \"NOT_PROVIDED\",\n56     \"NullBooleanField\",\n57     \"PositiveBigIntegerField\",\n58     \"PositiveIntegerField\",\n59     \"PositiveSmallIntegerField\",\n60     \"SlugField\",\n61     \"SmallAutoField\",\n62     \"SmallIntegerField\",\n63     \"TextField\",\n64     \"TimeField\",\n65     \"URLField\",\n66     \"UUIDField\",\n67 ]\n68 \n69 \n70 class Empty:\n71     pass\n72 \n73 \n74 class NOT_PROVIDED:\n75     pass\n76 \n77 \n78 # The values to use for \"blank\" in SelectFields. Will be appended to the start\n79 # of most \"choices\" lists.\n80 BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n81 \n82 \n83 def _load_field(app_label, model_name, field_name):\n84     return apps.get_model(app_label, model_name)._meta.get_field(field_name)\n85 \n86 \n87 # A guide to Field parameters:\n88 #\n89 #   * name:      The name of the field specified in the model.\n90 #   * attname:   The attribute to use on the model object. This is the same as\n91 #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n92 #                appended.\n93 #   * db_column: The db_column specified in the model (or None).\n94 #   * column:    The database column for this field. This is the same as\n95 #                \"attname\", except if db_column is specified.\n96 #\n97 # Code that introspects values, or does other dynamic things, should use\n98 # attname. For example, this gets the primary key value of object \"obj\":\n99 #\n100 #     getattr(obj, opts.pk.attname)\n101 \n102 \n103 def _empty(of_cls):\n104     new = Empty()\n105     new.__class__ = of_cls\n106     return new\n107 \n108 \n109 def return_None():\n110     return None\n111 \n112 \n113 @total_ordering\n114 class Field(RegisterLookupMixin):\n115     \"\"\"Base class for all field types\"\"\"\n116 \n117     # Designates whether empty strings fundamentally are allowed at the\n118     # database level.\n119     empty_strings_allowed = True\n120     empty_values = list(validators.EMPTY_VALUES)\n121 \n122     # These track each time a Field instance is created. Used to retain order.\n123     # The auto_creation_counter is used for fields that Django implicitly\n124     # creates, creation_counter is used for all user-specified fields.\n125     creation_counter = 0\n126     auto_creation_counter = -1\n127     default_validators = []  # Default set of validators\n128     default_error_messages = {\n129         \"invalid_choice\": _(\"Value %(value)r is not a valid choice.\"),\n130         \"null\": _(\"This field cannot be null.\"),\n131         \"blank\": _(\"This field cannot be blank.\"),\n132         \"unique\": _(\"%(model_name)s with this %(field_label)s already exists.\"),\n133         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n134         # Eg: \"Title must be unique for pub_date year\"\n135         \"unique_for_date\": _(\n136             \"%(field_label)s must be unique for \"\n137             \"%(date_field_label)s %(lookup_type)s.\"\n138         ),\n139     }\n140     system_check_deprecated_details = None\n141     system_check_removed_details = None\n142 \n143     # Attributes that don't affect a column definition.\n144     # These attributes are ignored when altering the field.\n145     non_db_attrs = (\n146         \"blank\",\n147         \"choices\",\n148         \"db_column\",\n149         \"editable\",\n150         \"error_messages\",\n151         \"help_text\",\n152         \"limit_choices_to\",\n153         # Database-level options are not supported, see #21961.\n154         \"on_delete\",\n155         \"related_name\",\n156         \"related_query_name\",\n157         \"validators\",\n158         \"verbose_name\",\n159     )\n160 \n161     # Field flags\n162     hidden = False\n163 \n164     many_to_many = None\n165     many_to_one = None\n166     one_to_many = None\n167     one_to_one = None\n168     related_model = None\n169 \n170     descriptor_class = DeferredAttribute\n171 \n172     # Generic field type description, usually overridden by subclasses\n173     def _description(self):\n174         return _(\"Field of type: %(field_type)s\") % {\n175             \"field_type\": self.__class__.__name__\n176         }\n177 \n178     description = property(_description)\n179 \n180     def __init__(\n181         self,\n182         verbose_name=None,\n183         name=None,\n184         primary_key=False,\n185         max_length=None,\n186         unique=False,\n187         blank=False,\n188         null=False,\n189         db_index=False,\n190         rel=None,\n191         default=NOT_PROVIDED,\n192         editable=True,\n193         serialize=True,\n194         unique_for_date=None,\n195         unique_for_month=None,\n196         unique_for_year=None,\n197         choices=None,\n198         help_text=\"\",\n199         db_column=None,\n200         db_tablespace=None,\n201         auto_created=False,\n202         validators=(),\n203         error_messages=None,\n204     ):\n205         self.name = name\n206         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n207         self._verbose_name = verbose_name  # Store original for deconstruction\n208         self.primary_key = primary_key\n209         self.max_length, self._unique = max_length, unique\n210         self.blank, self.null = blank, null\n211         self.remote_field = rel\n212         self.is_relation = self.remote_field is not None\n213         self.default = default\n214         self.editable = editable\n215         self.serialize = serialize\n216         self.unique_for_date = unique_for_date\n217         self.unique_for_month = unique_for_month\n218         self.unique_for_year = unique_for_year\n219         if isinstance(choices, collections.abc.Iterator):\n220             choices = list(choices)\n221         self.choices = choices\n222         self.help_text = help_text\n223         self.db_index = db_index\n224         self.db_column = db_column\n225         self._db_tablespace = db_tablespace\n226         self.auto_created = auto_created\n227 \n228         # Adjust the appropriate creation counter, and save our local copy.\n229         if auto_created:\n230             self.creation_counter = Field.auto_creation_counter\n231             Field.auto_creation_counter -= 1\n232         else:\n233             self.creation_counter = Field.creation_counter\n234             Field.creation_counter += 1\n235 \n236         self._validators = list(validators)  # Store for deconstruction later\n237 \n238         self._error_messages = error_messages  # Store for deconstruction later\n239 \n240     def __str__(self):\n241         \"\"\"\n242         Return \"app_label.model_label.field_name\" for fields attached to\n243         models.\n244         \"\"\"\n245         if not hasattr(self, \"model\"):\n246             return super().__str__()\n247         model = self.model\n248         return \"%s.%s\" % (model._meta.label, self.name)\n249 \n250     def __repr__(self):\n251         \"\"\"Display the module, class, and name of the field.\"\"\"\n252         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n253         name = getattr(self, \"name\", None)\n254         if name is not None:\n255             return \"<%s: %s>\" % (path, name)\n256         return \"<%s>\" % path\n257 \n258     def check(self, **kwargs):\n259         return [\n260             *self._check_field_name(),\n261             *self._check_choices(),\n262             *self._check_db_index(),\n263             *self._check_null_allowed_for_primary_keys(),\n264             *self._check_backend_specific_checks(**kwargs),\n265             *self._check_validators(),\n266             *self._check_deprecation_details(),\n267         ]\n268 \n269     def _check_field_name(self):\n270         \"\"\"\n271         Check if field name is valid, i.e. 1) does not end with an\n272         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n273         \"\"\"\n274         if self.name.endswith(\"_\"):\n275             return [\n276                 checks.Error(\n277                     \"Field names must not end with an underscore.\",\n278                     obj=self,\n279                     id=\"fields.E001\",\n280                 )\n281             ]\n282         elif LOOKUP_SEP in self.name:\n283             return [\n284                 checks.Error(\n285                     'Field names must not contain \"%s\".' % LOOKUP_SEP,\n286                     obj=self,\n287                     id=\"fields.E002\",\n288                 )\n289             ]\n290         elif self.name == \"pk\":\n291             return [\n292                 checks.Error(\n293                     \"'pk' is a reserved word that cannot be used as a field name.\",\n294                     obj=self,\n295                     id=\"fields.E003\",\n296                 )\n297             ]\n298         else:\n299             return []\n300 \n301     @classmethod\n302     def _choices_is_value(cls, value):\n303         return isinstance(value, (str, Promise)) or not is_iterable(value)\n304 \n305     def _check_choices(self):\n306         if not self.choices:\n307             return []\n308 \n309         if not is_iterable(self.choices) or isinstance(self.choices, str):\n310             return [\n311                 checks.Error(\n312                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n313                     obj=self,\n314                     id=\"fields.E004\",\n315                 )\n316             ]\n317 \n318         choice_max_length = 0\n319         # Expect [group_name, [value, display]]\n320         for choices_group in self.choices:\n321             try:\n322                 group_name, group_choices = choices_group\n323             except (TypeError, ValueError):\n324                 # Containing non-pairs\n325                 break\n326             try:\n327                 if not all(\n328                     self._choices_is_value(value) and self._choices_is_value(human_name)\n329                     for value, human_name in group_choices\n330                 ):\n331                     break\n332                 if self.max_length is not None and group_choices:\n333                     choice_max_length = max(\n334                         [\n335                             choice_max_length,\n336                             *(\n337                                 len(value)\n338                                 for value, _ in group_choices\n339                                 if isinstance(value, str)\n340                             ),\n341                         ]\n342                     )\n343             except (TypeError, ValueError):\n344                 # No groups, choices in the form [value, display]\n345                 value, human_name = group_name, group_choices\n346                 if not self._choices_is_value(value) or not self._choices_is_value(\n347                     human_name\n348                 ):\n349                     break\n350                 if self.max_length is not None and isinstance(value, str):\n351                     choice_max_length = max(choice_max_length, len(value))\n352 \n353             # Special case: choices=['ab']\n354             if isinstance(choices_group, str):\n355                 break\n356         else:\n357             if self.max_length is not None and choice_max_length > self.max_length:\n358                 return [\n359                     checks.Error(\n360                         \"'max_length' is too small to fit the longest value \"\n361                         \"in 'choices' (%d characters).\" % choice_max_length,\n362                         obj=self,\n363                         id=\"fields.E009\",\n364                     ),\n365                 ]\n366             return []\n367 \n368         return [\n369             checks.Error(\n370                 \"'choices' must be an iterable containing \"\n371                 \"(actual value, human readable name) tuples.\",\n372                 obj=self,\n373                 id=\"fields.E005\",\n374             )\n375         ]\n376 \n377     def _check_db_index(self):\n378         if self.db_index not in (None, True, False):\n379             return [\n380                 checks.Error(\n381                     \"'db_index' must be None, True or False.\",\n382                     obj=self,\n383                     id=\"fields.E006\",\n384                 )\n385             ]\n386         else:\n387             return []\n388 \n389     def _check_null_allowed_for_primary_keys(self):\n390         if (\n391             self.primary_key\n392             and self.null\n393             and not connection.features.interprets_empty_strings_as_nulls\n394         ):\n395             # We cannot reliably check this for backends like Oracle which\n396             # consider NULL and '' to be equal (and thus set up\n397             # character-based fields a little differently).\n398             return [\n399                 checks.Error(\n400                     \"Primary keys must not have null=True.\",\n401                     hint=(\n402                         \"Set null=False on the field, or \"\n403                         \"remove primary_key=True argument.\"\n404                     ),\n405                     obj=self,\n406                     id=\"fields.E007\",\n407                 )\n408             ]\n409         else:\n410             return []\n411 \n412     def _check_backend_specific_checks(self, databases=None, **kwargs):\n413         if databases is None:\n414             return []\n415         app_label = self.model._meta.app_label\n416         errors = []\n417         for alias in databases:\n418             if router.allow_migrate(\n419                 alias, app_label, model_name=self.model._meta.model_name\n420             ):\n421                 errors.extend(connections[alias].validation.check_field(self, **kwargs))\n422         return errors\n423 \n424     def _check_validators(self):\n425         errors = []\n426         for i, validator in enumerate(self.validators):\n427             if not callable(validator):\n428                 errors.append(\n429                     checks.Error(\n430                         \"All 'validators' must be callable.\",\n431                         hint=(\n432                             \"validators[{i}] ({repr}) isn't a function or \"\n433                             \"instance of a validator class.\".format(\n434                                 i=i,\n435                                 repr=repr(validator),\n436                             )\n437                         ),\n438                         obj=self,\n439                         id=\"fields.E008\",\n440                     )\n441                 )\n442         return errors\n443 \n444     def _check_deprecation_details(self):\n445         if self.system_check_removed_details is not None:\n446             return [\n447                 checks.Error(\n448                     self.system_check_removed_details.get(\n449                         \"msg\",\n450                         \"%s has been removed except for support in historical \"\n451                         \"migrations.\" % self.__class__.__name__,\n452                     ),\n453                     hint=self.system_check_removed_details.get(\"hint\"),\n454                     obj=self,\n455                     id=self.system_check_removed_details.get(\"id\", \"fields.EXXX\"),\n456                 )\n457             ]\n458         elif self.system_check_deprecated_details is not None:\n459             return [\n460                 checks.Warning(\n461                     self.system_check_deprecated_details.get(\n462                         \"msg\", \"%s has been deprecated.\" % self.__class__.__name__\n463                     ),\n464                     hint=self.system_check_deprecated_details.get(\"hint\"),\n465                     obj=self,\n466                     id=self.system_check_deprecated_details.get(\"id\", \"fields.WXXX\"),\n467                 )\n468             ]\n469         return []\n470 \n471     def get_col(self, alias, output_field=None):\n472         if alias == self.model._meta.db_table and (\n473             output_field is None or output_field == self\n474         ):\n475             return self.cached_col\n476         from django.db.models.expressions import Col\n477 \n478         return Col(alias, self, output_field)\n479 \n480     @cached_property\n481     def cached_col(self):\n482         from django.db.models.expressions import Col\n483 \n484         return Col(self.model._meta.db_table, self)\n485 \n486     def select_format(self, compiler, sql, params):\n487         \"\"\"\n488         Custom format for select clauses. For example, GIS columns need to be\n489         selected as AsText(table.col) on MySQL as the table.col data can't be\n490         used by Django.\n491         \"\"\"\n492         return sql, params\n493 \n494     def deconstruct(self):\n495         \"\"\"\n496         Return enough information to recreate the field as a 4-tuple:\n497 \n498          * The name of the field on the model, if contribute_to_class() has\n499            been run.\n500          * The import path of the field, including the class, e.g.\n501            django.db.models.IntegerField. This should be the most portable\n502            version, so less specific may be better.\n503          * A list of positional arguments.\n504          * A dict of keyword arguments.\n505 \n506         Note that the positional or keyword arguments must contain values of\n507         the following types (including inner values of collection types):\n508 \n509          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n510            dict\n511          * UUID\n512          * datetime.datetime (naive), datetime.date\n513          * top-level classes, top-level functions - will be referenced by their\n514            full import path\n515          * Storage instances - these have their own deconstruct() method\n516 \n517         This is because the values here must be serialized into a text format\n518         (possibly new Python code, possibly JSON) and these are the only types\n519         with encoding handlers defined.\n520 \n521         There's no need to return the exact way the field was instantiated this\n522         time, just ensure that the resulting field is the same - prefer keyword\n523         arguments over positional ones, and omit parameters with their default\n524         values.\n525         \"\"\"\n526         # Short-form way of fetching all the default parameters\n527         keywords = {}\n528         possibles = {\n529             \"verbose_name\": None,\n530             \"primary_key\": False,\n531             \"max_length\": None,\n532             \"unique\": False,\n533             \"blank\": False,\n534             \"null\": False,\n535             \"db_index\": False,\n536             \"default\": NOT_PROVIDED,\n537             \"editable\": True,\n538             \"serialize\": True,\n539             \"unique_for_date\": None,\n540             \"unique_for_month\": None,\n541             \"unique_for_year\": None,\n542             \"choices\": None,\n543             \"help_text\": \"\",\n544             \"db_column\": None,\n545             \"db_tablespace\": None,\n546             \"auto_created\": False,\n547             \"validators\": [],\n548             \"error_messages\": None,\n549         }\n550         attr_overrides = {\n551             \"unique\": \"_unique\",\n552             \"error_messages\": \"_error_messages\",\n553             \"validators\": \"_validators\",\n554             \"verbose_name\": \"_verbose_name\",\n555             \"db_tablespace\": \"_db_tablespace\",\n556         }\n557         equals_comparison = {\"choices\", \"validators\"}\n558         for name, default in possibles.items():\n559             value = getattr(self, attr_overrides.get(name, name))\n560             # Unroll anything iterable for choices into a concrete list\n561             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n562                 value = list(value)\n563             # Do correct kind of comparison\n564             if name in equals_comparison:\n565                 if value != default:\n566                     keywords[name] = value\n567             else:\n568                 if value is not default:\n569                     keywords[name] = value\n570         # Work out path - we shorten it for known Django core fields\n571         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n572         if path.startswith(\"django.db.models.fields.related\"):\n573             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n574         elif path.startswith(\"django.db.models.fields.files\"):\n575             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n576         elif path.startswith(\"django.db.models.fields.json\"):\n577             path = path.replace(\"django.db.models.fields.json\", \"django.db.models\")\n578         elif path.startswith(\"django.db.models.fields.proxy\"):\n579             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n580         elif path.startswith(\"django.db.models.fields\"):\n581             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n582         # Return basic info - other fields should override this.\n583         return (self.name, path, [], keywords)\n584 \n585     def clone(self):\n586         \"\"\"\n587         Uses deconstruct() to clone a new copy of this Field.\n588         Will not preserve any class attachments/attribute names.\n589         \"\"\"\n590         name, path, args, kwargs = self.deconstruct()\n591         return self.__class__(*args, **kwargs)\n592 \n593     def __eq__(self, other):\n594         # Needed for @total_ordering\n595         if isinstance(other, Field):\n596             return self.creation_counter == other.creation_counter and getattr(\n597                 self, \"model\", None\n598             ) == getattr(other, \"model\", None)\n599         return NotImplemented\n600 \n601     def __lt__(self, other):\n602         # This is needed because bisect does not take a comparison function.\n603         # Order by creation_counter first for backward compatibility.\n604         if isinstance(other, Field):\n605             if (\n606                 self.creation_counter != other.creation_counter\n607                 or not hasattr(self, \"model\")\n608                 and not hasattr(other, \"model\")\n609             ):\n610                 return self.creation_counter < other.creation_counter\n611             elif hasattr(self, \"model\") != hasattr(other, \"model\"):\n612                 return not hasattr(self, \"model\")  # Order no-model fields first\n613             else:\n614                 # creation_counter's are equal, compare only models.\n615                 return (self.model._meta.app_label, self.model._meta.model_name) < (\n616                     other.model._meta.app_label,\n617                     other.model._meta.model_name,\n618                 )\n619         return NotImplemented\n620 \n621     def __hash__(self):\n622         return hash(self.creation_counter)\n623 \n624     def __deepcopy__(self, memodict):\n625         # We don't have to deepcopy very much here, since most things are not\n626         # intended to be altered after initial creation.\n627         obj = copy.copy(self)\n628         if self.remote_field:\n629             obj.remote_field = copy.copy(self.remote_field)\n630             if hasattr(self.remote_field, \"field\") and self.remote_field.field is self:\n631                 obj.remote_field.field = obj\n632         memodict[id(self)] = obj\n633         return obj\n634 \n635     def __copy__(self):\n636         # We need to avoid hitting __reduce__, so define this\n637         # slightly weird copy construct.\n638         obj = Empty()\n639         obj.__class__ = self.__class__\n640         obj.__dict__ = self.__dict__.copy()\n641         return obj\n642 \n643     def __reduce__(self):\n644         \"\"\"\n645         Pickling should return the model._meta.fields instance of the field,\n646         not a new copy of that field. So, use the app registry to load the\n647         model and then the field back.\n648         \"\"\"\n649         if not hasattr(self, \"model\"):\n650             # Fields are sometimes used without attaching them to models (for\n651             # example in aggregation). In this case give back a plain field\n652             # instance. The code below will create a new empty instance of\n653             # class self.__class__, then update its dict with self.__dict__\n654             # values - so, this is very close to normal pickle.\n655             state = self.__dict__.copy()\n656             # The _get_default cached_property can't be pickled due to lambda\n657             # usage.\n658             state.pop(\"_get_default\", None)\n659             return _empty, (self.__class__,), state\n660         return _load_field, (\n661             self.model._meta.app_label,\n662             self.model._meta.object_name,\n663             self.name,\n664         )\n665 \n666     def get_pk_value_on_save(self, instance):\n667         \"\"\"\n668         Hook to generate new PK values on save. This method is called when\n669         saving instances with no primary key value set. If this method returns\n670         something else than None, then the returned value is used when saving\n671         the new instance.\n672         \"\"\"\n673         if self.default:\n674             return self.get_default()\n675         return None\n676 \n677     def to_python(self, value):\n678         \"\"\"\n679         Convert the input value into the expected Python data type, raising\n680         django.core.exceptions.ValidationError if the data can't be converted.\n681         Return the converted value. Subclasses should override this.\n682         \"\"\"\n683         return value\n684 \n685     @cached_property\n686     def error_messages(self):\n687         messages = {}\n688         for c in reversed(self.__class__.__mro__):\n689             messages.update(getattr(c, \"default_error_messages\", {}))\n690         messages.update(self._error_messages or {})\n691         return messages\n692 \n693     @cached_property\n694     def validators(self):\n695         \"\"\"\n696         Some validators can't be created at field initialization time.\n697         This method provides a way to delay their creation until required.\n698         \"\"\"\n699         return [*self.default_validators, *self._validators]\n700 \n701     def run_validators(self, value):\n702         if value in self.empty_values:\n703             return\n704 \n705         errors = []\n706         for v in self.validators:\n707             try:\n708                 v(value)\n709             except exceptions.ValidationError as e:\n710                 if hasattr(e, \"code\") and e.code in self.error_messages:\n711                     e.message = self.error_messages[e.code]\n712                 errors.extend(e.error_list)\n713 \n714         if errors:\n715             raise exceptions.ValidationError(errors)\n716 \n717     def validate(self, value, model_instance):\n718         \"\"\"\n719         Validate value and raise ValidationError if necessary. Subclasses\n720         should override this to provide validation logic.\n721         \"\"\"\n722         if not self.editable:\n723             # Skip validation for non-editable fields.\n724             return\n725 \n726         if self.choices is not None and value not in self.empty_values:\n727             for option_key, option_value in self.choices:\n728                 if isinstance(option_value, (list, tuple)):\n729                     # This is an optgroup, so look inside the group for\n730                     # options.\n731                     for optgroup_key, optgroup_value in option_value:\n732                         if value == optgroup_key:\n733                             return\n734                 elif value == option_key:\n735                     return\n736             raise exceptions.ValidationError(\n737                 self.error_messages[\"invalid_choice\"],\n738                 code=\"invalid_choice\",\n739                 params={\"value\": value},\n740             )\n741 \n742         if value is None and not self.null:\n743             raise exceptions.ValidationError(self.error_messages[\"null\"], code=\"null\")\n744 \n745         if not self.blank and value in self.empty_values:\n746             raise exceptions.ValidationError(self.error_messages[\"blank\"], code=\"blank\")\n747 \n748     def clean(self, value, model_instance):\n749         \"\"\"\n750         Convert the value's type and run validation. Validation errors\n751         from to_python() and validate() are propagated. Return the correct\n752         value if no error is raised.\n753         \"\"\"\n754         value = self.to_python(value)\n755         self.validate(value, model_instance)\n756         self.run_validators(value)\n757         return value\n758 \n759     def db_type_parameters(self, connection):\n760         return DictWrapper(self.__dict__, connection.ops.quote_name, \"qn_\")\n761 \n762     def db_check(self, connection):\n763         \"\"\"\n764         Return the database column check constraint for this field, for the\n765         provided connection. Works the same way as db_type() for the case that\n766         get_internal_type() does not map to a preexisting model field.\n767         \"\"\"\n768         data = self.db_type_parameters(connection)\n769         try:\n770             return (\n771                 connection.data_type_check_constraints[self.get_internal_type()] % data\n772             )\n773         except KeyError:\n774             return None\n775 \n776     def db_type(self, connection):\n777         \"\"\"\n778         Return the database column data type for this field, for the provided\n779         connection.\n780         \"\"\"\n781         # The default implementation of this method looks at the\n782         # backend-specific data_types dictionary, looking up the field by its\n783         # \"internal type\".\n784         #\n785         # A Field class can implement the get_internal_type() method to specify\n786         # which *preexisting* Django Field class it's most similar to -- i.e.,\n787         # a custom field might be represented by a TEXT column type, which is\n788         # the same as the TextField Django field type, which means the custom\n789         # field's get_internal_type() returns 'TextField'.\n790         #\n791         # But the limitation of the get_internal_type() / data_types approach\n792         # is that it cannot handle database column types that aren't already\n793         # mapped to one of the built-in Django field types. In this case, you\n794         # can implement db_type() instead of get_internal_type() to specify\n795         # exactly which wacky database column type you want to use.\n796         data = self.db_type_parameters(connection)\n797         try:\n798             return connection.data_types[self.get_internal_type()] % data\n799         except KeyError:\n800             return None\n801 \n802     def rel_db_type(self, connection):\n803         \"\"\"\n804         Return the data type that a related field pointing to this field should\n805         use. For example, this method is called by ForeignKey and OneToOneField\n806         to determine its data type.\n807         \"\"\"\n808         return self.db_type(connection)\n809 \n810     def cast_db_type(self, connection):\n811         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n812         db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n813         if db_type:\n814             return db_type % self.db_type_parameters(connection)\n815         return self.db_type(connection)\n816 \n817     def db_parameters(self, connection):\n818         \"\"\"\n819         Extension of db_type(), providing a range of different return values\n820         (type, checks). This will look at db_type(), allowing custom model\n821         fields to override it.\n822         \"\"\"\n823         type_string = self.db_type(connection)\n824         check_string = self.db_check(connection)\n825         return {\n826             \"type\": type_string,\n827             \"check\": check_string,\n828         }\n829 \n830     def db_type_suffix(self, connection):\n831         return connection.data_types_suffix.get(self.get_internal_type())\n832 \n833     def get_db_converters(self, connection):\n834         if hasattr(self, \"from_db_value\"):\n835             return [self.from_db_value]\n836         return []\n837 \n838     @property\n839     def unique(self):\n840         return self._unique or self.primary_key\n841 \n842     @property\n843     def db_tablespace(self):\n844         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n845 \n846     @property\n847     def db_returning(self):\n848         \"\"\"\n849         Private API intended only to be used by Django itself. Currently only\n850         the PostgreSQL backend supports returning multiple fields on a model.\n851         \"\"\"\n852         return False\n853 \n854     def set_attributes_from_name(self, name):\n855         self.name = self.name or name\n856         self.attname, self.column = self.get_attname_column()\n857         self.concrete = self.column is not None\n858         if self.verbose_name is None and self.name:\n859             self.verbose_name = self.name.replace(\"_\", \" \")\n860 \n861     def contribute_to_class(self, cls, name, private_only=False):\n862         \"\"\"\n863         Register the field with the model class it belongs to.\n864 \n865         If private_only is True, create a separate instance of this field\n866         for every subclass of cls, even if cls is not an abstract model.\n867         \"\"\"\n868         self.set_attributes_from_name(name)\n869         self.model = cls\n870         cls._meta.add_field(self, private=private_only)\n871         if self.column:\n872             setattr(cls, self.attname, self.descriptor_class(self))\n873         if self.choices is not None:\n874             # Don't override a get_FOO_display() method defined explicitly on\n875             # this class, but don't check methods derived from inheritance, to\n876             # allow overriding inherited choices. For more complex inheritance\n877             # structures users should override contribute_to_class().\n878             if \"get_%s_display\" % self.name not in cls.__dict__:\n879                 setattr(\n880                     cls,\n881                     \"get_%s_display\" % self.name,\n882                     partialmethod(cls._get_FIELD_display, field=self),\n883                 )\n884 \n885     def get_filter_kwargs_for_object(self, obj):\n886         \"\"\"\n887         Return a dict that when passed as kwargs to self.model.filter(), would\n888         yield all instances having the same value for this field as obj has.\n889         \"\"\"\n890         return {self.name: getattr(obj, self.attname)}\n891 \n892     def get_attname(self):\n893         return self.name\n894 \n895     def get_attname_column(self):\n896         attname = self.get_attname()\n897         column = self.db_column or attname\n898         return attname, column\n899 \n900     def get_internal_type(self):\n901         return self.__class__.__name__\n902 \n903     def pre_save(self, model_instance, add):\n904         \"\"\"Return field's value just before saving.\"\"\"\n905         return getattr(model_instance, self.attname)\n906 \n907     def get_prep_value(self, value):\n908         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n909         if isinstance(value, Promise):\n910             value = value._proxy____cast()\n911         return value\n912 \n913     def get_db_prep_value(self, value, connection, prepared=False):\n914         \"\"\"\n915         Return field's value prepared for interacting with the database backend.\n916 \n917         Used by the default implementations of get_db_prep_save().\n918         \"\"\"\n919         if not prepared:\n920             value = self.get_prep_value(value)\n921         return value\n922 \n923     def get_db_prep_save(self, value, connection):\n924         \"\"\"Return field's value prepared for saving into a database.\"\"\"\n925         return self.get_db_prep_value(value, connection=connection, prepared=False)\n926 \n927     def has_default(self):\n928         \"\"\"Return a boolean of whether this field has a default value.\"\"\"\n929         return self.default is not NOT_PROVIDED\n930 \n931     def get_default(self):\n932         \"\"\"Return the default value for this field.\"\"\"\n933         return self._get_default()\n934 \n935     @cached_property\n936     def _get_default(self):\n937         if self.has_default():\n938             if callable(self.default):\n939                 return self.default\n940             return lambda: self.default\n941 \n942         if (\n943             not self.empty_strings_allowed\n944             or self.null\n945             and not connection.features.interprets_empty_strings_as_nulls\n946         ):\n947             return return_None\n948         return str  # return empty string\n949 \n950     def get_choices(\n951         self,\n952         include_blank=True,\n953         blank_choice=BLANK_CHOICE_DASH,\n954         limit_choices_to=None,\n955         ordering=(),\n956     ):\n957         \"\"\"\n958         Return choices with a default blank choices included, for use\n959         as <select> choices for this field.\n960         \"\"\"\n961         if self.choices is not None:\n962             choices = list(self.choices)\n963             if include_blank:\n964                 blank_defined = any(\n965                     choice in (\"\", None) for choice, _ in self.flatchoices\n966                 )\n967                 if not blank_defined:\n968                     choices = blank_choice + choices\n969             return choices\n970         rel_model = self.remote_field.model\n971         limit_choices_to = limit_choices_to or self.get_limit_choices_to()\n972         choice_func = operator.attrgetter(\n973             self.remote_field.get_related_field().attname\n974             if hasattr(self.remote_field, \"get_related_field\")\n975             else \"pk\"\n976         )\n977         qs = rel_model._default_manager.complex_filter(limit_choices_to)\n978         if ordering:\n979             qs = qs.order_by(*ordering)\n980         return (blank_choice if include_blank else []) + [\n981             (choice_func(x), str(x)) for x in qs\n982         ]\n983 \n984     def value_to_string(self, obj):\n985         \"\"\"\n986         Return a string value of this field from the passed obj.\n987         This is used by the serialization framework.\n988         \"\"\"\n989         return str(self.value_from_object(obj))\n990 \n991     def _get_flatchoices(self):\n992         \"\"\"Flattened version of choices tuple.\"\"\"\n993         if self.choices is None:\n994             return []\n995         flat = []\n996         for choice, value in self.choices:\n997             if isinstance(value, (list, tuple)):\n998                 flat.extend(value)\n999             else:\n1000                 flat.append((choice, value))\n1001         return flat\n1002 \n1003     flatchoices = property(_get_flatchoices)\n1004 \n1005     def save_form_data(self, instance, data):\n1006         setattr(instance, self.name, data)\n1007 \n1008     def formfield(self, form_class=None, choices_form_class=None, **kwargs):\n1009         \"\"\"Return a django.forms.Field instance for this field.\"\"\"\n1010         defaults = {\n1011             \"required\": not self.blank,\n1012             \"label\": capfirst(self.verbose_name),\n1013             \"help_text\": self.help_text,\n1014         }\n1015         if self.has_default():\n1016             if callable(self.default):\n1017                 defaults[\"initial\"] = self.default\n1018                 defaults[\"show_hidden_initial\"] = True\n1019             else:\n1020                 defaults[\"initial\"] = self.get_default()\n1021         if self.choices is not None:\n1022             # Fields with choices get special treatment.\n1023             include_blank = self.blank or not (\n1024                 self.has_default() or \"initial\" in kwargs\n1025             )\n1026             defaults[\"choices\"] = self.get_choices(include_blank=include_blank)\n1027             defaults[\"coerce\"] = self.to_python\n1028             if self.null:\n1029                 defaults[\"empty_value\"] = None\n1030             if choices_form_class is not None:\n1031                 form_class = choices_form_class\n1032             else:\n1033                 form_class = forms.TypedChoiceField\n1034             # Many of the subclass-specific formfield arguments (min_value,\n1035             # max_value) don't apply for choice fields, so be sure to only pass\n1036             # the values that TypedChoiceField will understand.\n1037             for k in list(kwargs):\n1038                 if k not in (\n1039                     \"coerce\",\n1040                     \"empty_value\",\n1041                     \"choices\",\n1042                     \"required\",\n1043                     \"widget\",\n1044                     \"label\",\n1045                     \"initial\",\n1046                     \"help_text\",\n1047                     \"error_messages\",\n1048                     \"show_hidden_initial\",\n1049                     \"disabled\",\n1050                 ):\n1051                     del kwargs[k]\n1052         defaults.update(kwargs)\n1053         if form_class is None:\n1054             form_class = forms.CharField\n1055         return form_class(**defaults)\n1056 \n1057     def value_from_object(self, obj):\n1058         \"\"\"Return the value of this field in the given model instance.\"\"\"\n1059         return getattr(obj, self.attname)\n1060 \n1061 \n1062 class BooleanField(Field):\n1063     empty_strings_allowed = False\n1064     default_error_messages = {\n1065         \"invalid\": _(\"\u201c%(value)s\u201d value must be either True or False.\"),\n1066         \"invalid_nullable\": _(\"\u201c%(value)s\u201d value must be either True, False, or None.\"),\n1067     }\n1068     description = _(\"Boolean (Either True or False)\")\n1069 \n1070     def get_internal_type(self):\n1071         return \"BooleanField\"\n1072 \n1073     def to_python(self, value):\n1074         if self.null and value in self.empty_values:\n1075             return None\n1076         if value in (True, False):\n1077             # 1/0 are equal to True/False. bool() converts former to latter.\n1078             return bool(value)\n1079         if value in (\"t\", \"True\", \"1\"):\n1080             return True\n1081         if value in (\"f\", \"False\", \"0\"):\n1082             return False\n1083         raise exceptions.ValidationError(\n1084             self.error_messages[\"invalid_nullable\" if self.null else \"invalid\"],\n1085             code=\"invalid\",\n1086             params={\"value\": value},\n1087         )\n1088 \n1089     def get_prep_value(self, value):\n1090         value = super().get_prep_value(value)\n1091         if value is None:\n1092             return None\n1093         return self.to_python(value)\n1094 \n1095     def formfield(self, **kwargs):\n1096         if self.choices is not None:\n1097             include_blank = not (self.has_default() or \"initial\" in kwargs)\n1098             defaults = {\"choices\": self.get_choices(include_blank=include_blank)}\n1099         else:\n1100             form_class = forms.NullBooleanField if self.null else forms.BooleanField\n1101             # In HTML checkboxes, 'required' means \"must be checked\" which is\n1102             # different from the choices case (\"must select some value\").\n1103             # required=False allows unchecked checkboxes.\n1104             defaults = {\"form_class\": form_class, \"required\": False}\n1105         return super().formfield(**{**defaults, **kwargs})\n1106 \n1107     def select_format(self, compiler, sql, params):\n1108         sql, params = super().select_format(compiler, sql, params)\n1109         # Filters that match everything are handled as empty strings in the\n1110         # WHERE clause, but in SELECT or GROUP BY list they must use a\n1111         # predicate that's always True.\n1112         if sql == \"\":\n1113             sql = \"1\"\n1114         return sql, params\n1115 \n1116 \n1117 class CharField(Field):\n1118     description = _(\"String (up to %(max_length)s)\")\n1119 \n1120     def __init__(self, *args, db_collation=None, **kwargs):\n1121         super().__init__(*args, **kwargs)\n1122         self.db_collation = db_collation\n1123         if self.max_length is not None:\n1124             self.validators.append(validators.MaxLengthValidator(self.max_length))\n1125 \n1126     def check(self, **kwargs):\n1127         databases = kwargs.get(\"databases\") or []\n1128         return [\n1129             *super().check(**kwargs),\n1130             *self._check_db_collation(databases),\n1131             *self._check_max_length_attribute(**kwargs),\n1132         ]\n1133 \n1134     def _check_max_length_attribute(self, **kwargs):\n1135         if self.max_length is None:\n1136             return [\n1137                 checks.Error(\n1138                     \"CharFields must define a 'max_length' attribute.\",\n1139                     obj=self,\n1140                     id=\"fields.E120\",\n1141                 )\n1142             ]\n1143         elif (\n1144             not isinstance(self.max_length, int)\n1145             or isinstance(self.max_length, bool)\n1146             or self.max_length <= 0\n1147         ):\n1148             return [\n1149                 checks.Error(\n1150                     \"'max_length' must be a positive integer.\",\n1151                     obj=self,\n1152                     id=\"fields.E121\",\n1153                 )\n1154             ]\n1155         else:\n1156             return []\n1157 \n1158     def _check_db_collation(self, databases):\n1159         errors = []\n1160         for db in databases:\n1161             if not router.allow_migrate_model(db, self.model):\n1162                 continue\n1163             connection = connections[db]\n1164             if not (\n1165                 self.db_collation is None\n1166                 or \"supports_collation_on_charfield\"\n1167                 in self.model._meta.required_db_features\n1168                 or connection.features.supports_collation_on_charfield\n1169             ):\n1170                 errors.append(\n1171                     checks.Error(\n1172                         \"%s does not support a database collation on \"\n1173                         \"CharFields.\" % connection.display_name,\n1174                         obj=self,\n1175                         id=\"fields.E190\",\n1176                     ),\n1177                 )\n1178         return errors\n1179 \n1180     def cast_db_type(self, connection):\n1181         if self.max_length is None:\n1182             return connection.ops.cast_char_field_without_max_length\n1183         return super().cast_db_type(connection)\n1184 \n1185     def db_parameters(self, connection):\n1186         db_params = super().db_parameters(connection)\n1187         db_params[\"collation\"] = self.db_collation\n1188         return db_params\n1189 \n1190     def get_internal_type(self):\n1191         return \"CharField\"\n1192 \n1193     def to_python(self, value):\n1194         if isinstance(value, str) or value is None:\n1195             return value\n1196         return str(value)\n1197 \n1198     def get_prep_value(self, value):\n1199         value = super().get_prep_value(value)\n1200         return self.to_python(value)\n1201 \n1202     def formfield(self, **kwargs):\n1203         # Passing max_length to forms.CharField means that the value's length\n1204         # will be validated twice. This is considered acceptable since we want\n1205         # the value in the form field (to pass into widget for example).\n1206         defaults = {\"max_length\": self.max_length}\n1207         # TODO: Handle multiple backends with different feature flags.\n1208         if self.null and not connection.features.interprets_empty_strings_as_nulls:\n1209             defaults[\"empty_value\"] = None\n1210         defaults.update(kwargs)\n1211         return super().formfield(**defaults)\n1212 \n1213     def deconstruct(self):\n1214         name, path, args, kwargs = super().deconstruct()\n1215         if self.db_collation:\n1216             kwargs[\"db_collation\"] = self.db_collation\n1217         return name, path, args, kwargs\n1218 \n1219 \n1220 class CommaSeparatedIntegerField(CharField):\n1221     default_validators = [validators.validate_comma_separated_integer_list]\n1222     description = _(\"Comma-separated integers\")\n1223     system_check_removed_details = {\n1224         \"msg\": (\n1225             \"CommaSeparatedIntegerField is removed except for support in \"\n1226             \"historical migrations.\"\n1227         ),\n1228         \"hint\": (\n1229             \"Use CharField(validators=[validate_comma_separated_integer_list]) \"\n1230             \"instead.\"\n1231         ),\n1232         \"id\": \"fields.E901\",\n1233     }\n1234 \n1235 \n1236 def _to_naive(value):\n1237     if timezone.is_aware(value):\n1238         value = timezone.make_naive(value, datetime.timezone.utc)\n1239     return value\n1240 \n1241 \n1242 def _get_naive_now():\n1243     return _to_naive(timezone.now())\n1244 \n1245 \n1246 class DateTimeCheckMixin:\n1247     def check(self, **kwargs):\n1248         return [\n1249             *super().check(**kwargs),\n1250             *self._check_mutually_exclusive_options(),\n1251             *self._check_fix_default_value(),\n1252         ]\n1253 \n1254     def _check_mutually_exclusive_options(self):\n1255         # auto_now, auto_now_add, and default are mutually exclusive\n1256         # options. The use of more than one of these options together\n1257         # will trigger an Error\n1258         mutually_exclusive_options = [\n1259             self.auto_now_add,\n1260             self.auto_now,\n1261             self.has_default(),\n1262         ]\n1263         enabled_options = [\n1264             option not in (None, False) for option in mutually_exclusive_options\n1265         ].count(True)\n1266         if enabled_options > 1:\n1267             return [\n1268                 checks.Error(\n1269                     \"The options auto_now, auto_now_add, and default \"\n1270                     \"are mutually exclusive. Only one of these options \"\n1271                     \"may be present.\",\n1272                     obj=self,\n1273                     id=\"fields.E160\",\n1274                 )\n1275             ]\n1276         else:\n1277             return []\n1278 \n1279     def _check_fix_default_value(self):\n1280         return []\n1281 \n1282     # Concrete subclasses use this in their implementations of\n1283     # _check_fix_default_value().\n1284     def _check_if_value_fixed(self, value, now=None):\n1285         \"\"\"\n1286         Check if the given value appears to have been provided as a \"fixed\"\n1287         time value, and include a warning in the returned list if it does. The\n1288         value argument must be a date object or aware/naive datetime object. If\n1289         now is provided, it must be a naive datetime object.\n1290         \"\"\"\n1291         if now is None:\n1292             now = _get_naive_now()\n1293         offset = datetime.timedelta(seconds=10)\n1294         lower = now - offset\n1295         upper = now + offset\n1296         if isinstance(value, datetime.datetime):\n1297             value = _to_naive(value)\n1298         else:\n1299             assert isinstance(value, datetime.date)\n1300             lower = lower.date()\n1301             upper = upper.date()\n1302         if lower <= value <= upper:\n1303             return [\n1304                 checks.Warning(\n1305                     \"Fixed default value provided.\",\n1306                     hint=(\n1307                         \"It seems you set a fixed date / time / datetime \"\n1308                         \"value as default for this field. This may not be \"\n1309                         \"what you want. If you want to have the current date \"\n1310                         \"as default, use `django.utils.timezone.now`\"\n1311                     ),\n1312                     obj=self,\n1313                     id=\"fields.W161\",\n1314                 )\n1315             ]\n1316         return []\n1317 \n1318 \n1319 class DateField(DateTimeCheckMixin, Field):\n1320     empty_strings_allowed = False\n1321     default_error_messages = {\n1322         \"invalid\": _(\n1323             \"\u201c%(value)s\u201d value has an invalid date format. It must be \"\n1324             \"in YYYY-MM-DD format.\"\n1325         ),\n1326         \"invalid_date\": _(\n1327             \"\u201c%(value)s\u201d value has the correct format (YYYY-MM-DD) \"\n1328             \"but it is an invalid date.\"\n1329         ),\n1330     }\n1331     description = _(\"Date (without time)\")\n1332 \n1333     def __init__(\n1334         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs\n1335     ):\n1336         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n1337         if auto_now or auto_now_add:\n1338             kwargs[\"editable\"] = False\n1339             kwargs[\"blank\"] = True\n1340         super().__init__(verbose_name, name, **kwargs)\n1341 \n1342     def _check_fix_default_value(self):\n1343         \"\"\"\n1344         Warn that using an actual date or datetime value is probably wrong;\n1345         it's only evaluated on server startup.\n1346         \"\"\"\n1347         if not self.has_default():\n1348             return []\n1349 \n1350         value = self.default\n1351         if isinstance(value, datetime.datetime):\n1352             value = _to_naive(value).date()\n1353         elif isinstance(value, datetime.date):\n1354             pass\n1355         else:\n1356             # No explicit date / datetime value -- no checks necessary\n1357             return []\n1358         # At this point, value is a date object.\n1359         return self._check_if_value_fixed(value)\n1360 \n1361     def deconstruct(self):\n1362         name, path, args, kwargs = super().deconstruct()\n1363         if self.auto_now:\n1364             kwargs[\"auto_now\"] = True\n1365         if self.auto_now_add:\n1366             kwargs[\"auto_now_add\"] = True\n1367         if self.auto_now or self.auto_now_add:\n1368             del kwargs[\"editable\"]\n1369             del kwargs[\"blank\"]\n1370         return name, path, args, kwargs\n1371 \n1372     def get_internal_type(self):\n1373         return \"DateField\"\n1374 \n1375     def to_python(self, value):\n1376         if value is None:\n1377             return value\n1378         if isinstance(value, datetime.datetime):\n1379             if settings.USE_TZ and timezone.is_aware(value):\n1380                 # Convert aware datetimes to the default time zone\n1381                 # before casting them to dates (#17742).\n1382                 default_timezone = timezone.get_default_timezone()\n1383                 value = timezone.make_naive(value, default_timezone)\n1384             return value.date()\n1385         if isinstance(value, datetime.date):\n1386             return value\n1387 \n1388         try:\n1389             parsed = parse_date(value)\n1390             if parsed is not None:\n1391                 return parsed\n1392         except ValueError:\n1393             raise exceptions.ValidationError(\n1394                 self.error_messages[\"invalid_date\"],\n1395                 code=\"invalid_date\",\n1396                 params={\"value\": value},\n1397             )\n1398 \n1399         raise exceptions.ValidationError(\n1400             self.error_messages[\"invalid\"],\n1401             code=\"invalid\",\n1402             params={\"value\": value},\n1403         )\n1404 \n1405     def pre_save(self, model_instance, add):\n1406         if self.auto_now or (self.auto_now_add and add):\n1407             value = datetime.date.today()\n1408             setattr(model_instance, self.attname, value)\n1409             return value\n1410         else:\n1411             return super().pre_save(model_instance, add)\n1412 \n1413     def contribute_to_class(self, cls, name, **kwargs):\n1414         super().contribute_to_class(cls, name, **kwargs)\n1415         if not self.null:\n1416             setattr(\n1417                 cls,\n1418                 \"get_next_by_%s\" % self.name,\n1419                 partialmethod(\n1420                     cls._get_next_or_previous_by_FIELD, field=self, is_next=True\n1421                 ),\n1422             )\n1423             setattr(\n1424                 cls,\n1425                 \"get_previous_by_%s\" % self.name,\n1426                 partialmethod(\n1427                     cls._get_next_or_previous_by_FIELD, field=self, is_next=False\n1428                 ),\n1429             )\n1430 \n1431     def get_prep_value(self, value):\n1432         value = super().get_prep_value(value)\n1433         return self.to_python(value)\n1434 \n1435     def get_db_prep_value(self, value, connection, prepared=False):\n1436         # Casts dates into the format expected by the backend\n1437         if not prepared:\n1438             value = self.get_prep_value(value)\n1439         return connection.ops.adapt_datefield_value(value)\n1440 \n1441     def value_to_string(self, obj):\n1442         val = self.value_from_object(obj)\n1443         return \"\" if val is None else val.isoformat()\n1444 \n1445     def formfield(self, **kwargs):\n1446         return super().formfield(\n1447             **{\n1448                 \"form_class\": forms.DateField,\n1449                 **kwargs,\n1450             }\n1451         )\n1452 \n1453 \n1454 class DateTimeField(DateField):\n1455     empty_strings_allowed = False\n1456     default_error_messages = {\n1457         \"invalid\": _(\n1458             \"\u201c%(value)s\u201d value has an invalid format. It must be in \"\n1459             \"YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.\"\n1460         ),\n1461         \"invalid_date\": _(\n1462             \"\u201c%(value)s\u201d value has the correct format \"\n1463             \"(YYYY-MM-DD) but it is an invalid date.\"\n1464         ),\n1465         \"invalid_datetime\": _(\n1466             \"\u201c%(value)s\u201d value has the correct format \"\n1467             \"(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) \"\n1468             \"but it is an invalid date/time.\"\n1469         ),\n1470     }\n1471     description = _(\"Date (with time)\")\n1472 \n1473     # __init__ is inherited from DateField\n1474 \n1475     def _check_fix_default_value(self):\n1476         \"\"\"\n1477         Warn that using an actual date or datetime value is probably wrong;\n1478         it's only evaluated on server startup.\n1479         \"\"\"\n1480         if not self.has_default():\n1481             return []\n1482 \n1483         value = self.default\n1484         if isinstance(value, (datetime.datetime, datetime.date)):\n1485             return self._check_if_value_fixed(value)\n1486         # No explicit date / datetime value -- no checks necessary.\n1487         return []\n1488 \n1489     def get_internal_type(self):\n1490         return \"DateTimeField\"\n1491 \n1492     def to_python(self, value):\n1493         if value is None:\n1494             return value\n1495         if isinstance(value, datetime.datetime):\n1496             return value\n1497         if isinstance(value, datetime.date):\n1498             value = datetime.datetime(value.year, value.month, value.day)\n1499             if settings.USE_TZ:\n1500                 # For backwards compatibility, interpret naive datetimes in\n1501                 # local time. This won't work during DST change, but we can't\n1502                 # do much about it, so we let the exceptions percolate up the\n1503                 # call stack.\n1504                 warnings.warn(\n1505                     \"DateTimeField %s.%s received a naive datetime \"\n1506                     \"(%s) while time zone support is active.\"\n1507                     % (self.model.__name__, self.name, value),\n1508                     RuntimeWarning,\n1509                 )\n1510                 default_timezone = timezone.get_default_timezone()\n1511                 value = timezone.make_aware(value, default_timezone)\n1512             return value\n1513 \n1514         try:\n1515             parsed = parse_datetime(value)\n1516             if parsed is not None:\n1517                 return parsed\n1518         except ValueError:\n1519             raise exceptions.ValidationError(\n1520                 self.error_messages[\"invalid_datetime\"],\n1521                 code=\"invalid_datetime\",\n1522                 params={\"value\": value},\n1523             )\n1524 \n1525         try:\n1526             parsed = parse_date(value)\n1527             if parsed is not None:\n1528                 return datetime.datetime(parsed.year, parsed.month, parsed.day)\n1529         except ValueError:\n1530             raise exceptions.ValidationError(\n1531                 self.error_messages[\"invalid_date\"],\n1532                 code=\"invalid_date\",\n1533                 params={\"value\": value},\n1534             )\n1535 \n1536         raise exceptions.ValidationError(\n1537             self.error_messages[\"invalid\"],\n1538             code=\"invalid\",\n1539             params={\"value\": value},\n1540         )\n1541 \n1542     def pre_save(self, model_instance, add):\n1543         if self.auto_now or (self.auto_now_add and add):\n1544             value = timezone.now()\n1545             setattr(model_instance, self.attname, value)\n1546             return value\n1547         else:\n1548             return super().pre_save(model_instance, add)\n1549 \n1550     # contribute_to_class is inherited from DateField, it registers\n1551     # get_next_by_FOO and get_prev_by_FOO\n1552 \n1553     def get_prep_value(self, value):\n1554         value = super().get_prep_value(value)\n1555         value = self.to_python(value)\n1556         if value is not None and settings.USE_TZ and timezone.is_naive(value):\n1557             # For backwards compatibility, interpret naive datetimes in local\n1558             # time. This won't work during DST change, but we can't do much\n1559             # about it, so we let the exceptions percolate up the call stack.\n1560             try:\n1561                 name = \"%s.%s\" % (self.model.__name__, self.name)\n1562             except AttributeError:\n1563                 name = \"(unbound)\"\n1564             warnings.warn(\n1565                 \"DateTimeField %s received a naive datetime (%s)\"\n1566                 \" while time zone support is active.\" % (name, value),\n1567                 RuntimeWarning,\n1568             )\n1569             default_timezone = timezone.get_default_timezone()\n1570             value = timezone.make_aware(value, default_timezone)\n1571         return value\n1572 \n1573     def get_db_prep_value(self, value, connection, prepared=False):\n1574         # Casts datetimes into the format expected by the backend\n1575         if not prepared:\n1576             value = self.get_prep_value(value)\n1577         return connection.ops.adapt_datetimefield_value(value)\n1578 \n1579     def value_to_string(self, obj):\n1580         val = self.value_from_object(obj)\n1581         return \"\" if val is None else val.isoformat()\n1582 \n1583     def formfield(self, **kwargs):\n1584         return super().formfield(\n1585             **{\n1586                 \"form_class\": forms.DateTimeField,\n1587                 **kwargs,\n1588             }\n1589         )\n1590 \n1591 \n1592 class DecimalField(Field):\n1593     empty_strings_allowed = False\n1594     default_error_messages = {\n1595         \"invalid\": _(\"\u201c%(value)s\u201d value must be a decimal number.\"),\n1596     }\n1597     description = _(\"Decimal number\")\n1598 \n1599     def __init__(\n1600         self,\n1601         verbose_name=None,\n1602         name=None,\n1603         max_digits=None,\n1604         decimal_places=None,\n1605         **kwargs,\n1606     ):\n1607         self.max_digits, self.decimal_places = max_digits, decimal_places\n1608         super().__init__(verbose_name, name, **kwargs)\n1609 \n1610     def check(self, **kwargs):\n1611         errors = super().check(**kwargs)\n1612 \n1613         digits_errors = [\n1614             *self._check_decimal_places(),\n1615             *self._check_max_digits(),\n1616         ]\n1617         if not digits_errors:\n1618             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1619         else:\n1620             errors.extend(digits_errors)\n1621         return errors\n1622 \n1623     def _check_decimal_places(self):\n1624         try:\n1625             decimal_places = int(self.decimal_places)\n1626             if decimal_places < 0:\n1627                 raise ValueError()\n1628         except TypeError:\n1629             return [\n1630                 checks.Error(\n1631                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1632                     obj=self,\n1633                     id=\"fields.E130\",\n1634                 )\n1635             ]\n1636         except ValueError:\n1637             return [\n1638                 checks.Error(\n1639                     \"'decimal_places' must be a non-negative integer.\",\n1640                     obj=self,\n1641                     id=\"fields.E131\",\n1642                 )\n1643             ]\n1644         else:\n1645             return []\n1646 \n1647     def _check_max_digits(self):\n1648         try:\n1649             max_digits = int(self.max_digits)\n1650             if max_digits <= 0:\n1651                 raise ValueError()\n1652         except TypeError:\n1653             return [\n1654                 checks.Error(\n1655                     \"DecimalFields must define a 'max_digits' attribute.\",\n1656                     obj=self,\n1657                     id=\"fields.E132\",\n1658                 )\n1659             ]\n1660         except ValueError:\n1661             return [\n1662                 checks.Error(\n1663                     \"'max_digits' must be a positive integer.\",\n1664                     obj=self,\n1665                     id=\"fields.E133\",\n1666                 )\n1667             ]\n1668         else:\n1669             return []\n1670 \n1671     def _check_decimal_places_and_max_digits(self, **kwargs):\n1672         if int(self.decimal_places) > int(self.max_digits):\n1673             return [\n1674                 checks.Error(\n1675                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1676                     obj=self,\n1677                     id=\"fields.E134\",\n1678                 )\n1679             ]\n1680         return []\n1681 \n1682     @cached_property\n1683     def validators(self):\n1684         return super().validators + [\n1685             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1686         ]\n1687 \n1688     @cached_property\n1689     def context(self):\n1690         return decimal.Context(prec=self.max_digits)\n1691 \n1692     def deconstruct(self):\n1693         name, path, args, kwargs = super().deconstruct()\n1694         if self.max_digits is not None:\n1695             kwargs[\"max_digits\"] = self.max_digits\n1696         if self.decimal_places is not None:\n1697             kwargs[\"decimal_places\"] = self.decimal_places\n1698         return name, path, args, kwargs\n1699 \n1700     def get_internal_type(self):\n1701         return \"DecimalField\"\n1702 \n1703     def to_python(self, value):\n1704         if value is None:\n1705             return value\n1706         if isinstance(value, float):\n1707             if math.isnan(value):\n1708                 raise exceptions.ValidationError(\n1709                     self.error_messages[\"invalid\"],\n1710                     code=\"invalid\",\n1711                     params={\"value\": value},\n1712                 )\n1713             return self.context.create_decimal_from_float(value)\n1714         try:\n1715             return decimal.Decimal(value)\n1716         except (decimal.InvalidOperation, TypeError, ValueError):\n1717             raise exceptions.ValidationError(\n1718                 self.error_messages[\"invalid\"],\n1719                 code=\"invalid\",\n1720                 params={\"value\": value},\n1721             )\n1722 \n1723     def get_db_prep_save(self, value, connection):\n1724         return connection.ops.adapt_decimalfield_value(\n1725             self.to_python(value), self.max_digits, self.decimal_places\n1726         )\n1727 \n1728     def get_prep_value(self, value):\n1729         value = super().get_prep_value(value)\n1730         return self.to_python(value)\n1731 \n1732     def formfield(self, **kwargs):\n1733         return super().formfield(\n1734             **{\n1735                 \"max_digits\": self.max_digits,\n1736                 \"decimal_places\": self.decimal_places,\n1737                 \"form_class\": forms.DecimalField,\n1738                 **kwargs,\n1739             }\n1740         )\n1741 \n1742 \n1743 class DurationField(Field):\n1744     \"\"\"\n1745     Store timedelta objects.\n1746 \n1747     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint\n1748     of microseconds on other databases.\n1749     \"\"\"\n1750 \n1751     empty_strings_allowed = False\n1752     default_error_messages = {\n1753         \"invalid\": _(\n1754             \"\u201c%(value)s\u201d value has an invalid format. It must be in \"\n1755             \"[DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n1756         )\n1757     }\n1758     description = _(\"Duration\")\n1759 \n1760     def get_internal_type(self):\n1761         return \"DurationField\"\n1762 \n1763     def to_python(self, value):\n1764         if value is None:\n1765             return value\n1766         if isinstance(value, datetime.timedelta):\n1767             return value\n1768         try:\n1769             parsed = parse_duration(value)\n1770         except ValueError:\n1771             pass\n1772         else:\n1773             if parsed is not None:\n1774                 return parsed\n1775 \n1776         raise exceptions.ValidationError(\n1777             self.error_messages[\"invalid\"],\n1778             code=\"invalid\",\n1779             params={\"value\": value},\n1780         )\n1781 \n1782     def get_db_prep_value(self, value, connection, prepared=False):\n1783         if connection.features.has_native_duration_field:\n1784             return value\n1785         if value is None:\n1786             return None\n1787         return duration_microseconds(value)\n1788 \n1789     def get_db_converters(self, connection):\n1790         converters = []\n1791         if not connection.features.has_native_duration_field:\n1792             converters.append(connection.ops.convert_durationfield_value)\n1793         return converters + super().get_db_converters(connection)\n1794 \n1795     def value_to_string(self, obj):\n1796         val = self.value_from_object(obj)\n1797         return \"\" if val is None else duration_string(val)\n1798 \n1799     def formfield(self, **kwargs):\n1800         return super().formfield(\n1801             **{\n1802                 \"form_class\": forms.DurationField,\n1803                 **kwargs,\n1804             }\n1805         )\n1806 \n1807 \n1808 class EmailField(CharField):\n1809     default_validators = [validators.validate_email]\n1810     description = _(\"Email address\")\n1811 \n1812     def __init__(self, *args, **kwargs):\n1813         # max_length=254 to be compliant with RFCs 3696 and 5321\n1814         kwargs.setdefault(\"max_length\", 254)\n1815         super().__init__(*args, **kwargs)\n1816 \n1817     def deconstruct(self):\n1818         name, path, args, kwargs = super().deconstruct()\n1819         # We do not exclude max_length if it matches default as we want to change\n1820         # the default in future.\n1821         return name, path, args, kwargs\n1822 \n1823     def formfield(self, **kwargs):\n1824         # As with CharField, this will cause email validation to be performed\n1825         # twice.\n1826         return super().formfield(\n1827             **{\n1828                 \"form_class\": forms.EmailField,\n1829                 **kwargs,\n1830             }\n1831         )\n1832 \n1833 \n1834 class FilePathField(Field):\n1835     description = _(\"File path\")\n1836 \n1837     def __init__(\n1838         self,\n1839         verbose_name=None,\n1840         name=None,\n1841         path=\"\",\n1842         match=None,\n1843         recursive=False,\n1844         allow_files=True,\n1845         allow_folders=False,\n1846         **kwargs,\n1847     ):\n1848         self.path, self.match, self.recursive = path, match, recursive\n1849         self.allow_files, self.allow_folders = allow_files, allow_folders\n1850         kwargs.setdefault(\"max_length\", 100)\n1851         super().__init__(verbose_name, name, **kwargs)\n1852 \n1853     def check(self, **kwargs):\n1854         return [\n1855             *super().check(**kwargs),\n1856             *self._check_allowing_files_or_folders(**kwargs),\n1857         ]\n1858 \n1859     def _check_allowing_files_or_folders(self, **kwargs):\n1860         if not self.allow_files and not self.allow_folders:\n1861             return [\n1862                 checks.Error(\n1863                     \"FilePathFields must have either 'allow_files' or 'allow_folders' \"\n1864                     \"set to True.\",\n1865                     obj=self,\n1866                     id=\"fields.E140\",\n1867                 )\n1868             ]\n1869         return []\n1870 \n1871     def deconstruct(self):\n1872         name, path, args, kwargs = super().deconstruct()\n1873         if self.path != \"\":\n1874             kwargs[\"path\"] = self.path\n1875         if self.match is not None:\n1876             kwargs[\"match\"] = self.match\n1877         if self.recursive is not False:\n1878             kwargs[\"recursive\"] = self.recursive\n1879         if self.allow_files is not True:\n1880             kwargs[\"allow_files\"] = self.allow_files\n1881         if self.allow_folders is not False:\n1882             kwargs[\"allow_folders\"] = self.allow_folders\n1883         if kwargs.get(\"max_length\") == 100:\n1884             del kwargs[\"max_length\"]\n1885         return name, path, args, kwargs\n1886 \n1887     def get_prep_value(self, value):\n1888         value = super().get_prep_value(value)\n1889         if value is None:\n1890             return None\n1891         return str(value)\n1892 \n1893     def formfield(self, **kwargs):\n1894         return super().formfield(\n1895             **{\n1896                 \"path\": self.path() if callable(self.path) else self.path,\n1897                 \"match\": self.match,\n1898                 \"recursive\": self.recursive,\n1899                 \"form_class\": forms.FilePathField,\n1900                 \"allow_files\": self.allow_files,\n1901                 \"allow_folders\": self.allow_folders,\n1902                 **kwargs,\n1903             }\n1904         )\n1905 \n1906     def get_internal_type(self):\n1907         return \"FilePathField\"\n1908 \n1909 \n1910 class FloatField(Field):\n1911     empty_strings_allowed = False\n1912     default_error_messages = {\n1913         \"invalid\": _(\"\u201c%(value)s\u201d value must be a float.\"),\n1914     }\n1915     description = _(\"Floating point number\")\n1916 \n1917     def get_prep_value(self, value):\n1918         value = super().get_prep_value(value)\n1919         if value is None:\n1920             return None\n1921         try:\n1922             return float(value)\n1923         except (TypeError, ValueError) as e:\n1924             raise e.__class__(\n1925                 \"Field '%s' expected a number but got %r.\" % (self.name, value),\n1926             ) from e\n1927 \n1928     def get_internal_type(self):\n1929         return \"FloatField\"\n1930 \n1931     def to_python(self, value):\n1932         if value is None:\n1933             return value\n1934         try:\n1935             return float(value)\n1936         except (TypeError, ValueError):\n1937             raise exceptions.ValidationError(\n1938                 self.error_messages[\"invalid\"],\n1939                 code=\"invalid\",\n1940                 params={\"value\": value},\n1941             )\n1942 \n1943     def formfield(self, **kwargs):\n1944         return super().formfield(\n1945             **{\n1946                 \"form_class\": forms.FloatField,\n1947                 **kwargs,\n1948             }\n1949         )\n1950 \n1951 \n1952 class IntegerField(Field):\n1953     empty_strings_allowed = False\n1954     default_error_messages = {\n1955         \"invalid\": _(\"\u201c%(value)s\u201d value must be an integer.\"),\n1956     }\n1957     description = _(\"Integer\")\n1958 \n1959     def check(self, **kwargs):\n1960         return [\n1961             *super().check(**kwargs),\n1962             *self._check_max_length_warning(),\n1963         ]\n1964 \n1965     def _check_max_length_warning(self):\n1966         if self.max_length is not None:\n1967             return [\n1968                 checks.Warning(\n1969                     \"'max_length' is ignored when used with %s.\"\n1970                     % self.__class__.__name__,\n1971                     hint=\"Remove 'max_length' from field\",\n1972                     obj=self,\n1973                     id=\"fields.W122\",\n1974                 )\n1975             ]\n1976         return []\n1977 \n1978     @cached_property\n1979     def validators(self):\n1980         # These validators can't be added at field initialization time since\n1981         # they're based on values retrieved from `connection`.\n1982         validators_ = super().validators\n1983         internal_type = self.get_internal_type()\n1984         min_value, max_value = connection.ops.integer_field_range(internal_type)\n1985         if min_value is not None and not any(\n1986             (\n1987                 isinstance(validator, validators.MinValueValidator)\n1988                 and (\n1989                     validator.limit_value()\n1990                     if callable(validator.limit_value)\n1991                     else validator.limit_value\n1992                 )\n1993                 >= min_value\n1994             )\n1995             for validator in validators_\n1996         ):\n1997             validators_.append(validators.MinValueValidator(min_value))\n1998         if max_value is not None and not any(\n1999             (\n2000                 isinstance(validator, validators.MaxValueValidator)\n2001                 and (\n2002                     validator.limit_value()\n2003                     if callable(validator.limit_value)\n2004                     else validator.limit_value\n2005                 )\n2006                 <= max_value\n2007             )\n2008             for validator in validators_\n2009         ):\n2010             validators_.append(validators.MaxValueValidator(max_value))\n2011         return validators_\n2012 \n2013     def get_prep_value(self, value):\n2014         value = super().get_prep_value(value)\n2015         if value is None:\n2016             return None\n2017         try:\n2018             return int(value)\n2019         except (TypeError, ValueError) as e:\n2020             raise e.__class__(\n2021                 \"Field '%s' expected a number but got %r.\" % (self.name, value),\n2022             ) from e\n2023 \n2024     def get_internal_type(self):\n2025         return \"IntegerField\"\n2026 \n2027     def to_python(self, value):\n2028         if value is None:\n2029             return value\n2030         try:\n2031             return int(value)\n2032         except (TypeError, ValueError):\n2033             raise exceptions.ValidationError(\n2034                 self.error_messages[\"invalid\"],\n2035                 code=\"invalid\",\n2036                 params={\"value\": value},\n2037             )\n2038 \n2039     def formfield(self, **kwargs):\n2040         return super().formfield(\n2041             **{\n2042                 \"form_class\": forms.IntegerField,\n2043                 **kwargs,\n2044             }\n2045         )\n2046 \n2047 \n2048 class BigIntegerField(IntegerField):\n2049     description = _(\"Big (8 byte) integer\")\n2050     MAX_BIGINT = 9223372036854775807\n2051 \n2052     def get_internal_type(self):\n2053         return \"BigIntegerField\"\n2054 \n2055     def formfield(self, **kwargs):\n2056         return super().formfield(\n2057             **{\n2058                 \"min_value\": -BigIntegerField.MAX_BIGINT - 1,\n2059                 \"max_value\": BigIntegerField.MAX_BIGINT,\n2060                 **kwargs,\n2061             }\n2062         )\n2063 \n2064 \n2065 class SmallIntegerField(IntegerField):\n2066     description = _(\"Small integer\")\n2067 \n2068     def get_internal_type(self):\n2069         return \"SmallIntegerField\"\n2070 \n2071 \n2072 class IPAddressField(Field):\n2073     empty_strings_allowed = False\n2074     description = _(\"IPv4 address\")\n2075     system_check_removed_details = {\n2076         \"msg\": (\n2077             \"IPAddressField has been removed except for support in \"\n2078             \"historical migrations.\"\n2079         ),\n2080         \"hint\": \"Use GenericIPAddressField instead.\",\n2081         \"id\": \"fields.E900\",\n2082     }\n2083 \n2084     def __init__(self, *args, **kwargs):\n2085         kwargs[\"max_length\"] = 15\n2086         super().__init__(*args, **kwargs)\n2087 \n2088     def deconstruct(self):\n2089         name, path, args, kwargs = super().deconstruct()\n2090         del kwargs[\"max_length\"]\n2091         return name, path, args, kwargs\n2092 \n2093     def get_prep_value(self, value):\n2094         value = super().get_prep_value(value)\n2095         if value is None:\n2096             return None\n2097         return str(value)\n2098 \n2099     def get_internal_type(self):\n2100         return \"IPAddressField\"\n2101 \n2102 \n2103 class GenericIPAddressField(Field):\n2104     empty_strings_allowed = False\n2105     description = _(\"IP address\")\n2106     default_error_messages = {}\n2107 \n2108     def __init__(\n2109         self,\n2110         verbose_name=None,\n2111         name=None,\n2112         protocol=\"both\",\n2113         unpack_ipv4=False,\n2114         *args,\n2115         **kwargs,\n2116     ):\n2117         self.unpack_ipv4 = unpack_ipv4\n2118         self.protocol = protocol\n2119         (\n2120             self.default_validators,\n2121             invalid_error_message,\n2122         ) = validators.ip_address_validators(protocol, unpack_ipv4)\n2123         self.default_error_messages[\"invalid\"] = invalid_error_message\n2124         kwargs[\"max_length\"] = 39\n2125         super().__init__(verbose_name, name, *args, **kwargs)\n2126 \n2127     def check(self, **kwargs):\n2128         return [\n2129             *super().check(**kwargs),\n2130             *self._check_blank_and_null_values(**kwargs),\n2131         ]\n2132 \n2133     def _check_blank_and_null_values(self, **kwargs):\n2134         if not getattr(self, \"null\", False) and getattr(self, \"blank\", False):\n2135             return [\n2136                 checks.Error(\n2137                     \"GenericIPAddressFields cannot have blank=True if null=False, \"\n2138                     \"as blank values are stored as nulls.\",\n2139                     obj=self,\n2140                     id=\"fields.E150\",\n2141                 )\n2142             ]\n2143         return []\n2144 \n2145     def deconstruct(self):\n2146         name, path, args, kwargs = super().deconstruct()\n2147         if self.unpack_ipv4 is not False:\n2148             kwargs[\"unpack_ipv4\"] = self.unpack_ipv4\n2149         if self.protocol != \"both\":\n2150             kwargs[\"protocol\"] = self.protocol\n2151         if kwargs.get(\"max_length\") == 39:\n2152             del kwargs[\"max_length\"]\n2153         return name, path, args, kwargs\n2154 \n2155     def get_internal_type(self):\n2156         return \"GenericIPAddressField\"\n2157 \n2158     def to_python(self, value):\n2159         if value is None:\n2160             return None\n2161         if not isinstance(value, str):\n2162             value = str(value)\n2163         value = value.strip()\n2164         if \":\" in value:\n2165             return clean_ipv6_address(\n2166                 value, self.unpack_ipv4, self.error_messages[\"invalid\"]\n2167             )\n2168         return value\n2169 \n2170     def get_db_prep_value(self, value, connection, prepared=False):\n2171         if not prepared:\n2172             value = self.get_prep_value(value)\n2173         return connection.ops.adapt_ipaddressfield_value(value)\n2174 \n2175     def get_prep_value(self, value):\n2176         value = super().get_prep_value(value)\n2177         if value is None:\n2178             return None\n2179         if value and \":\" in value:\n2180             try:\n2181                 return clean_ipv6_address(value, self.unpack_ipv4)\n2182             except exceptions.ValidationError:\n2183                 pass\n2184         return str(value)\n2185 \n2186     def formfield(self, **kwargs):\n2187         return super().formfield(\n2188             **{\n2189                 \"protocol\": self.protocol,\n2190                 \"form_class\": forms.GenericIPAddressField,\n2191                 **kwargs,\n2192             }\n2193         )\n2194 \n2195 \n2196 class NullBooleanField(BooleanField):\n2197     default_error_messages = {\n2198         \"invalid\": _(\"\u201c%(value)s\u201d value must be either None, True or False.\"),\n2199         \"invalid_nullable\": _(\"\u201c%(value)s\u201d value must be either None, True or False.\"),\n2200     }\n2201     description = _(\"Boolean (Either True, False or None)\")\n2202     system_check_removed_details = {\n2203         \"msg\": (\n2204             \"NullBooleanField is removed except for support in historical \"\n2205             \"migrations.\"\n2206         ),\n2207         \"hint\": \"Use BooleanField(null=True) instead.\",\n2208         \"id\": \"fields.E903\",\n2209     }\n2210 \n2211     def __init__(self, *args, **kwargs):\n2212         kwargs[\"null\"] = True\n2213         kwargs[\"blank\"] = True\n2214         super().__init__(*args, **kwargs)\n2215 \n2216     def deconstruct(self):\n2217         name, path, args, kwargs = super().deconstruct()\n2218         del kwargs[\"null\"]\n2219         del kwargs[\"blank\"]\n2220         return name, path, args, kwargs\n2221 \n2222 \n2223 class PositiveIntegerRelDbTypeMixin:\n2224     def __init_subclass__(cls, **kwargs):\n2225         super().__init_subclass__(**kwargs)\n2226         if not hasattr(cls, \"integer_field_class\"):\n2227             cls.integer_field_class = next(\n2228                 (\n2229                     parent\n2230                     for parent in cls.__mro__[1:]\n2231                     if issubclass(parent, IntegerField)\n2232                 ),\n2233                 None,\n2234             )\n2235 \n2236     def rel_db_type(self, connection):\n2237         \"\"\"\n2238         Return the data type that a related field pointing to this field should\n2239         use. In most cases, a foreign key pointing to a positive integer\n2240         primary key will have an integer column data type but some databases\n2241         (e.g. MySQL) have an unsigned integer type. In that case\n2242         (related_fields_match_type=True), the primary key should return its\n2243         db_type.\n2244         \"\"\"\n2245         if connection.features.related_fields_match_type:\n2246             return self.db_type(connection)\n2247         else:\n2248             return self.integer_field_class().db_type(connection=connection)\n2249 \n2250 \n2251 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, BigIntegerField):\n2252     description = _(\"Positive big integer\")\n2253 \n2254     def get_internal_type(self):\n2255         return \"PositiveBigIntegerField\"\n2256 \n2257     def formfield(self, **kwargs):\n2258         return super().formfield(\n2259             **{\n2260                 \"min_value\": 0,\n2261                 **kwargs,\n2262             }\n2263         )\n2264 \n2265 \n2266 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n2267     description = _(\"Positive integer\")\n2268 \n2269     def get_internal_type(self):\n2270         return \"PositiveIntegerField\"\n2271 \n2272     def formfield(self, **kwargs):\n2273         return super().formfield(\n2274             **{\n2275                 \"min_value\": 0,\n2276                 **kwargs,\n2277             }\n2278         )\n2279 \n2280 \n2281 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, SmallIntegerField):\n2282     description = _(\"Positive small integer\")\n2283 \n2284     def get_internal_type(self):\n2285         return \"PositiveSmallIntegerField\"\n2286 \n2287     def formfield(self, **kwargs):\n2288         return super().formfield(\n2289             **{\n2290                 \"min_value\": 0,\n2291                 **kwargs,\n2292             }\n2293         )\n2294 \n2295 \n2296 class SlugField(CharField):\n2297     default_validators = [validators.validate_slug]\n2298     description = _(\"Slug (up to %(max_length)s)\")\n2299 \n2300     def __init__(\n2301         self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs\n2302     ):\n2303         self.allow_unicode = allow_unicode\n2304         if self.allow_unicode:\n2305             self.default_validators = [validators.validate_unicode_slug]\n2306         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)\n2307 \n2308     def deconstruct(self):\n2309         name, path, args, kwargs = super().deconstruct()\n2310         if kwargs.get(\"max_length\") == 50:\n2311             del kwargs[\"max_length\"]\n2312         if self.db_index is False:\n2313             kwargs[\"db_index\"] = False\n2314         else:\n2315             del kwargs[\"db_index\"]\n2316         if self.allow_unicode is not False:\n2317             kwargs[\"allow_unicode\"] = self.allow_unicode\n2318         return name, path, args, kwargs\n2319 \n2320     def get_internal_type(self):\n2321         return \"SlugField\"\n2322 \n2323     def formfield(self, **kwargs):\n2324         return super().formfield(\n2325             **{\n2326                 \"form_class\": forms.SlugField,\n2327                 \"allow_unicode\": self.allow_unicode,\n2328                 **kwargs,\n2329             }\n2330         )\n2331 \n2332 \n2333 class TextField(Field):\n2334     description = _(\"Text\")\n2335 \n2336     def __init__(self, *args, db_collation=None, **kwargs):\n2337         super().__init__(*args, **kwargs)\n2338         self.db_collation = db_collation\n2339 \n2340     def check(self, **kwargs):\n2341         databases = kwargs.get(\"databases\") or []\n2342         return [\n2343             *super().check(**kwargs),\n2344             *self._check_db_collation(databases),\n2345         ]\n2346 \n2347     def _check_db_collation(self, databases):\n2348         errors = []\n2349         for db in databases:\n2350             if not router.allow_migrate_model(db, self.model):\n2351                 continue\n2352             connection = connections[db]\n2353             if not (\n2354                 self.db_collation is None\n2355                 or \"supports_collation_on_textfield\"\n2356                 in self.model._meta.required_db_features\n2357                 or connection.features.supports_collation_on_textfield\n2358             ):\n2359                 errors.append(\n2360                     checks.Error(\n2361                         \"%s does not support a database collation on \"\n2362                         \"TextFields.\" % connection.display_name,\n2363                         obj=self,\n2364                         id=\"fields.E190\",\n2365                     ),\n2366                 )\n2367         return errors\n2368 \n2369     def db_parameters(self, connection):\n2370         db_params = super().db_parameters(connection)\n2371         db_params[\"collation\"] = self.db_collation\n2372         return db_params\n2373 \n2374     def get_internal_type(self):\n2375         return \"TextField\"\n2376 \n2377     def to_python(self, value):\n2378         if isinstance(value, str) or value is None:\n2379             return value\n2380         return str(value)\n2381 \n2382     def get_prep_value(self, value):\n2383         value = super().get_prep_value(value)\n2384         return self.to_python(value)\n2385 \n2386     def formfield(self, **kwargs):\n2387         # Passing max_length to forms.CharField means that the value's length\n2388         # will be validated twice. This is considered acceptable since we want\n2389         # the value in the form field (to pass into widget for example).\n2390         return super().formfield(\n2391             **{\n2392                 \"max_length\": self.max_length,\n2393                 **({} if self.choices is not None else {\"widget\": forms.Textarea}),\n2394                 **kwargs,\n2395             }\n2396         )\n2397 \n2398     def deconstruct(self):\n2399         name, path, args, kwargs = super().deconstruct()\n2400         if self.db_collation:\n2401             kwargs[\"db_collation\"] = self.db_collation\n2402         return name, path, args, kwargs\n2403 \n2404 \n2405 class TimeField(DateTimeCheckMixin, Field):\n2406     empty_strings_allowed = False\n2407     default_error_messages = {\n2408         \"invalid\": _(\n2409             \"\u201c%(value)s\u201d value has an invalid format. It must be in \"\n2410             \"HH:MM[:ss[.uuuuuu]] format.\"\n2411         ),\n2412         \"invalid_time\": _(\n2413             \"\u201c%(value)s\u201d value has the correct format \"\n2414             \"(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.\"\n2415         ),\n2416     }\n2417     description = _(\"Time\")\n2418 \n2419     def __init__(\n2420         self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs\n2421     ):\n2422         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n2423         if auto_now or auto_now_add:\n2424             kwargs[\"editable\"] = False\n2425             kwargs[\"blank\"] = True\n2426         super().__init__(verbose_name, name, **kwargs)\n2427 \n2428     def _check_fix_default_value(self):\n2429         \"\"\"\n2430         Warn that using an actual date or datetime value is probably wrong;\n2431         it's only evaluated on server startup.\n2432         \"\"\"\n2433         if not self.has_default():\n2434             return []\n2435 \n2436         value = self.default\n2437         if isinstance(value, datetime.datetime):\n2438             now = None\n2439         elif isinstance(value, datetime.time):\n2440             now = _get_naive_now()\n2441             # This will not use the right date in the race condition where now\n2442             # is just before the date change and value is just past 0:00.\n2443             value = datetime.datetime.combine(now.date(), value)\n2444         else:\n2445             # No explicit time / datetime value -- no checks necessary\n2446             return []\n2447         # At this point, value is a datetime object.\n2448         return self._check_if_value_fixed(value, now=now)\n2449 \n2450     def deconstruct(self):\n2451         name, path, args, kwargs = super().deconstruct()\n2452         if self.auto_now is not False:\n2453             kwargs[\"auto_now\"] = self.auto_now\n2454         if self.auto_now_add is not False:\n2455             kwargs[\"auto_now_add\"] = self.auto_now_add\n2456         if self.auto_now or self.auto_now_add:\n2457             del kwargs[\"blank\"]\n2458             del kwargs[\"editable\"]\n2459         return name, path, args, kwargs\n2460 \n2461     def get_internal_type(self):\n2462         return \"TimeField\"\n2463 \n2464     def to_python(self, value):\n2465         if value is None:\n2466             return None\n2467         if isinstance(value, datetime.time):\n2468             return value\n2469         if isinstance(value, datetime.datetime):\n2470             # Not usually a good idea to pass in a datetime here (it loses\n2471             # information), but this can be a side-effect of interacting with a\n2472             # database backend (e.g. Oracle), so we'll be accommodating.\n2473             return value.time()\n2474 \n2475         try:\n2476             parsed = parse_time(value)\n2477             if parsed is not None:\n2478                 return parsed\n2479         except ValueError:\n2480             raise exceptions.ValidationError(\n2481                 self.error_messages[\"invalid_time\"],\n2482                 code=\"invalid_time\",\n2483                 params={\"value\": value},\n2484             )\n2485 \n2486         raise exceptions.ValidationError(\n2487             self.error_messages[\"invalid\"],\n2488             code=\"invalid\",\n2489             params={\"value\": value},\n2490         )\n2491 \n2492     def pre_save(self, model_instance, add):\n2493         if self.auto_now or (self.auto_now_add and add):\n2494             value = datetime.datetime.now().time()\n2495             setattr(model_instance, self.attname, value)\n2496             return value\n2497         else:\n2498             return super().pre_save(model_instance, add)\n2499 \n2500     def get_prep_value(self, value):\n2501         value = super().get_prep_value(value)\n2502         return self.to_python(value)\n2503 \n2504     def get_db_prep_value(self, value, connection, prepared=False):\n2505         # Casts times into the format expected by the backend\n2506         if not prepared:\n2507             value = self.get_prep_value(value)\n2508         return connection.ops.adapt_timefield_value(value)\n2509 \n2510     def value_to_string(self, obj):\n2511         val = self.value_from_object(obj)\n2512         return \"\" if val is None else val.isoformat()\n2513 \n2514     def formfield(self, **kwargs):\n2515         return super().formfield(\n2516             **{\n2517                 \"form_class\": forms.TimeField,\n2518                 **kwargs,\n2519             }\n2520         )\n2521 \n2522 \n2523 class URLField(CharField):\n2524     default_validators = [validators.URLValidator()]\n2525     description = _(\"URL\")\n2526 \n2527     def __init__(self, verbose_name=None, name=None, **kwargs):\n2528         kwargs.setdefault(\"max_length\", 200)\n2529         super().__init__(verbose_name, name, **kwargs)\n2530 \n2531     def deconstruct(self):\n2532         name, path, args, kwargs = super().deconstruct()\n2533         if kwargs.get(\"max_length\") == 200:\n2534             del kwargs[\"max_length\"]\n2535         return name, path, args, kwargs\n2536 \n2537     def formfield(self, **kwargs):\n2538         # As with CharField, this will cause URL validation to be performed\n2539         # twice.\n2540         return super().formfield(\n2541             **{\n2542                 \"form_class\": forms.URLField,\n2543                 **kwargs,\n2544             }\n2545         )\n2546 \n2547 \n2548 class BinaryField(Field):\n2549     description = _(\"Raw binary data\")\n2550     empty_values = [None, b\"\"]\n2551 \n2552     def __init__(self, *args, **kwargs):\n2553         kwargs.setdefault(\"editable\", False)\n2554         super().__init__(*args, **kwargs)\n2555         if self.max_length is not None:\n2556             self.validators.append(validators.MaxLengthValidator(self.max_length))\n2557 \n2558     def check(self, **kwargs):\n2559         return [*super().check(**kwargs), *self._check_str_default_value()]\n2560 \n2561     def _check_str_default_value(self):\n2562         if self.has_default() and isinstance(self.default, str):\n2563             return [\n2564                 checks.Error(\n2565                     \"BinaryField's default cannot be a string. Use bytes \"\n2566                     \"content instead.\",\n2567                     obj=self,\n2568                     id=\"fields.E170\",\n2569                 )\n2570             ]\n2571         return []\n2572 \n2573     def deconstruct(self):\n2574         name, path, args, kwargs = super().deconstruct()\n2575         if self.editable:\n2576             kwargs[\"editable\"] = True\n2577         else:\n2578             del kwargs[\"editable\"]\n2579         return name, path, args, kwargs\n2580 \n2581     def get_internal_type(self):\n2582         return \"BinaryField\"\n2583 \n2584     def get_placeholder(self, value, compiler, connection):\n2585         return connection.ops.binary_placeholder_sql(value)\n2586 \n2587     def get_default(self):\n2588         if self.has_default() and not callable(self.default):\n2589             return self.default\n2590         default = super().get_default()\n2591         if default == \"\":\n2592             return b\"\"\n2593         return default\n2594 \n2595     def get_db_prep_value(self, value, connection, prepared=False):\n2596         value = super().get_db_prep_value(value, connection, prepared)\n2597         if value is not None:\n2598             return connection.Database.Binary(value)\n2599         return value\n2600 \n2601     def value_to_string(self, obj):\n2602         \"\"\"Binary data is serialized as base64\"\"\"\n2603         return b64encode(self.value_from_object(obj)).decode(\"ascii\")\n2604 \n2605     def to_python(self, value):\n2606         # If it's a string, it should be base64-encoded data\n2607         if isinstance(value, str):\n2608             return memoryview(b64decode(value.encode(\"ascii\")))\n2609         return value\n2610 \n2611 \n2612 class UUIDField(Field):\n2613     default_error_messages = {\n2614         \"invalid\": _(\"\u201c%(value)s\u201d is not a valid UUID.\"),\n2615     }\n2616     description = _(\"Universally unique identifier\")\n2617     empty_strings_allowed = False\n2618 \n2619     def __init__(self, verbose_name=None, **kwargs):\n2620         kwargs[\"max_length\"] = 32\n2621         super().__init__(verbose_name, **kwargs)\n2622 \n2623     def deconstruct(self):\n2624         name, path, args, kwargs = super().deconstruct()\n2625         del kwargs[\"max_length\"]\n2626         return name, path, args, kwargs\n2627 \n2628     def get_internal_type(self):\n2629         return \"UUIDField\"\n2630 \n2631     def get_prep_value(self, value):\n2632         value = super().get_prep_value(value)\n2633         return self.to_python(value)\n2634 \n2635     def get_db_prep_value(self, value, connection, prepared=False):\n2636         if value is None:\n2637             return None\n2638         if not isinstance(value, uuid.UUID):\n2639             value = self.to_python(value)\n2640 \n2641         if connection.features.has_native_uuid_field:\n2642             return value\n2643         return value.hex\n2644 \n2645     def to_python(self, value):\n2646         if value is not None and not isinstance(value, uuid.UUID):\n2647             input_form = \"int\" if isinstance(value, int) else \"hex\"\n2648             try:\n2649                 return uuid.UUID(**{input_form: value})\n2650             except (AttributeError, ValueError):\n2651                 raise exceptions.ValidationError(\n2652                     self.error_messages[\"invalid\"],\n2653                     code=\"invalid\",\n2654                     params={\"value\": value},\n2655                 )\n2656         return value\n2657 \n2658     def formfield(self, **kwargs):\n2659         return super().formfield(\n2660             **{\n2661                 \"form_class\": forms.UUIDField,\n2662                 **kwargs,\n2663             }\n2664         )\n2665 \n2666 \n2667 class AutoFieldMixin:\n2668     db_returning = True\n2669 \n2670     def __init__(self, *args, **kwargs):\n2671         kwargs[\"blank\"] = True\n2672         super().__init__(*args, **kwargs)\n2673 \n2674     def check(self, **kwargs):\n2675         return [\n2676             *super().check(**kwargs),\n2677             *self._check_primary_key(),\n2678         ]\n2679 \n2680     def _check_primary_key(self):\n2681         if not self.primary_key:\n2682             return [\n2683                 checks.Error(\n2684                     \"AutoFields must set primary_key=True.\",\n2685                     obj=self,\n2686                     id=\"fields.E100\",\n2687                 ),\n2688             ]\n2689         else:\n2690             return []\n2691 \n2692     def deconstruct(self):\n2693         name, path, args, kwargs = super().deconstruct()\n2694         del kwargs[\"blank\"]\n2695         kwargs[\"primary_key\"] = True\n2696         return name, path, args, kwargs\n2697 \n2698     def validate(self, value, model_instance):\n2699         pass\n2700 \n2701     def get_db_prep_value(self, value, connection, prepared=False):\n2702         if not prepared:\n2703             value = self.get_prep_value(value)\n2704             value = connection.ops.validate_autopk_value(value)\n2705         return value\n2706 \n2707     def contribute_to_class(self, cls, name, **kwargs):\n2708         if cls._meta.auto_field:\n2709             raise ValueError(\n2710                 \"Model %s can't have more than one auto-generated field.\"\n2711                 % cls._meta.label\n2712             )\n2713         super().contribute_to_class(cls, name, **kwargs)\n2714         cls._meta.auto_field = self\n2715 \n2716     def formfield(self, **kwargs):\n2717         return None\n2718 \n2719 \n2720 class AutoFieldMeta(type):\n2721     \"\"\"\n2722     Metaclass to maintain backward inheritance compatibility for AutoField.\n2723 \n2724     It is intended that AutoFieldMixin become public API when it is possible to\n2725     create a non-integer automatically-generated field using column defaults\n2726     stored in the database.\n2727 \n2728     In many areas Django also relies on using isinstance() to check for an\n2729     automatically-generated field as a subclass of AutoField. A new flag needs\n2730     to be implemented on Field to be used instead.\n2731 \n2732     When these issues have been addressed, this metaclass could be used to\n2733     deprecate inheritance from AutoField and use of isinstance() with AutoField\n2734     for detecting automatically-generated fields.\n2735     \"\"\"\n2736 \n2737     @property\n2738     def _subclasses(self):\n2739         return (BigAutoField, SmallAutoField)\n2740 \n2741     def __instancecheck__(self, instance):\n2742         return isinstance(instance, self._subclasses) or super().__instancecheck__(\n2743             instance\n2744         )\n2745 \n2746     def __subclasscheck__(self, subclass):\n2747         return issubclass(subclass, self._subclasses) or super().__subclasscheck__(\n2748             subclass\n2749         )\n2750 \n2751 \n2752 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n2753     def get_internal_type(self):\n2754         return \"AutoField\"\n2755 \n2756     def rel_db_type(self, connection):\n2757         return IntegerField().db_type(connection=connection)\n2758 \n2759 \n2760 class BigAutoField(AutoFieldMixin, BigIntegerField):\n2761     def get_internal_type(self):\n2762         return \"BigAutoField\"\n2763 \n2764     def rel_db_type(self, connection):\n2765         return BigIntegerField().db_type(connection=connection)\n2766 \n2767 \n2768 class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n2769     def get_internal_type(self):\n2770         return \"SmallAutoField\"\n2771 \n2772     def rel_db_type(self, connection):\n2773         return SmallIntegerField().db_type(connection=connection)\n",
        "intended_behavior": "This file should include logic that not only allows for 'db_collation' to be defined at the field level but also ensures that when such fields are used as primary keys, any foreign keys referencing them in other models inherit or respect this collation setting during migration generation. The current implementation likely allows 'db_collation' to be specified, but may not ensure it is consistently applied across related foreign key references in migrations. The code fix should address this propagation issue without disrupting the existing functionality for non-related fields."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/fields/related.py",
        "start": 1,
        "end": 1987,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute,\n23     ForwardManyToOneDescriptor,\n24     ForwardOneToOneDescriptor,\n25     ManyToManyDescriptor,\n26     ReverseManyToOneDescriptor,\n27     ReverseOneToOneDescriptor,\n28 )\n29 from .related_lookups import (\n30     RelatedExact,\n31     RelatedGreaterThan,\n32     RelatedGreaterThanOrEqual,\n33     RelatedIn,\n34     RelatedIsNull,\n35     RelatedLessThan,\n36     RelatedLessThanOrEqual,\n37 )\n38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel\n39 \n40 RECURSIVE_RELATIONSHIP_CONSTANT = \"self\"\n41 \n42 \n43 def resolve_relation(scope_model, relation):\n44     \"\"\"\n45     Transform relation into a model or fully-qualified model string of the form\n46     \"app_label.ModelName\", relative to scope_model.\n47 \n48     The relation argument can be:\n49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n50         the model argument will be returned.\n51       * A bare model name without an app_label, in which case scope_model's\n52         app_label will be prepended.\n53       * An \"app_label.ModelName\" string.\n54       * A model class, which will be returned unchanged.\n55     \"\"\"\n56     # Check for recursive relations\n57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n58         relation = scope_model\n59 \n60     # Look for an \"app.Model\" relation\n61     if isinstance(relation, str):\n62         if \".\" not in relation:\n63             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n64 \n65     return relation\n66 \n67 \n68 def lazy_related_operation(function, model, *related_models, **kwargs):\n69     \"\"\"\n70     Schedule `function` to be called once `model` and all `related_models`\n71     have been imported and registered with the app registry. `function` will\n72     be called with the newly-loaded model classes as its positional arguments,\n73     plus any optional keyword arguments.\n74 \n75     The `model` argument must be a model class. Each subsequent positional\n76     argument is another model, or a reference to another model - see\n77     `resolve_relation()` for the various forms these may take. Any relative\n78     references will be resolved relative to `model`.\n79 \n80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n81     registry model used is the one found in `model._meta.apps`.\n82     \"\"\"\n83     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n84     model_keys = (make_model_tuple(m) for m in models)\n85     apps = model._meta.apps\n86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n87 \n88 \n89 class RelatedField(FieldCacheMixin, Field):\n90     \"\"\"Base class that all relational fields inherit from.\"\"\"\n91 \n92     # Field flags\n93     one_to_many = False\n94     one_to_one = False\n95     many_to_many = False\n96     many_to_one = False\n97 \n98     def __init__(\n99         self,\n100         related_name=None,\n101         related_query_name=None,\n102         limit_choices_to=None,\n103         **kwargs,\n104     ):\n105         self._related_name = related_name\n106         self._related_query_name = related_query_name\n107         self._limit_choices_to = limit_choices_to\n108         super().__init__(**kwargs)\n109 \n110     @cached_property\n111     def related_model(self):\n112         # Can't cache this property until all the models are loaded.\n113         apps.check_models_ready()\n114         return self.remote_field.model\n115 \n116     def check(self, **kwargs):\n117         return [\n118             *super().check(**kwargs),\n119             *self._check_related_name_is_valid(),\n120             *self._check_related_query_name_is_valid(),\n121             *self._check_relation_model_exists(),\n122             *self._check_referencing_to_swapped_model(),\n123             *self._check_clashes(),\n124         ]\n125 \n126     def _check_related_name_is_valid(self):\n127         import keyword\n128 \n129         related_name = self.remote_field.related_name\n130         if related_name is None:\n131             return []\n132         is_valid_id = (\n133             not keyword.iskeyword(related_name) and related_name.isidentifier()\n134         )\n135         if not (is_valid_id or related_name.endswith(\"+\")):\n136             return [\n137                 checks.Error(\n138                     \"The name '%s' is invalid related_name for field %s.%s\"\n139                     % (\n140                         self.remote_field.related_name,\n141                         self.model._meta.object_name,\n142                         self.name,\n143                     ),\n144                     hint=(\n145                         \"Related name must be a valid Python identifier or end with a \"\n146                         \"'+'\"\n147                     ),\n148                     obj=self,\n149                     id=\"fields.E306\",\n150                 )\n151             ]\n152         return []\n153 \n154     def _check_related_query_name_is_valid(self):\n155         if self.remote_field.is_hidden():\n156             return []\n157         rel_query_name = self.related_query_name()\n158         errors = []\n159         if rel_query_name.endswith(\"_\"):\n160             errors.append(\n161                 checks.Error(\n162                     \"Reverse query name '%s' must not end with an underscore.\"\n163                     % rel_query_name,\n164                     hint=(\n165                         \"Add or change a related_name or related_query_name \"\n166                         \"argument for this field.\"\n167                     ),\n168                     obj=self,\n169                     id=\"fields.E308\",\n170                 )\n171             )\n172         if LOOKUP_SEP in rel_query_name:\n173             errors.append(\n174                 checks.Error(\n175                     \"Reverse query name '%s' must not contain '%s'.\"\n176                     % (rel_query_name, LOOKUP_SEP),\n177                     hint=(\n178                         \"Add or change a related_name or related_query_name \"\n179                         \"argument for this field.\"\n180                     ),\n181                     obj=self,\n182                     id=\"fields.E309\",\n183                 )\n184             )\n185         return errors\n186 \n187     def _check_relation_model_exists(self):\n188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n189         rel_is_string = isinstance(self.remote_field.model, str)\n190         model_name = (\n191             self.remote_field.model\n192             if rel_is_string\n193             else self.remote_field.model._meta.object_name\n194         )\n195         if rel_is_missing and (\n196             rel_is_string or not self.remote_field.model._meta.swapped\n197         ):\n198             return [\n199                 checks.Error(\n200                     \"Field defines a relation with model '%s', which is either \"\n201                     \"not installed, or is abstract.\" % model_name,\n202                     obj=self,\n203                     id=\"fields.E300\",\n204                 )\n205             ]\n206         return []\n207 \n208     def _check_referencing_to_swapped_model(self):\n209         if (\n210             self.remote_field.model not in self.opts.apps.get_models()\n211             and not isinstance(self.remote_field.model, str)\n212             and self.remote_field.model._meta.swapped\n213         ):\n214             return [\n215                 checks.Error(\n216                     \"Field defines a relation with the model '%s', which has \"\n217                     \"been swapped out.\" % self.remote_field.model._meta.label,\n218                     hint=\"Update the relation to point at 'settings.%s'.\"\n219                     % self.remote_field.model._meta.swappable,\n220                     obj=self,\n221                     id=\"fields.E301\",\n222                 )\n223             ]\n224         return []\n225 \n226     def _check_clashes(self):\n227         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n228         from django.db.models.base import ModelBase\n229 \n230         errors = []\n231         opts = self.model._meta\n232 \n233         # f.remote_field.model may be a string instead of a model. Skip if\n234         # model name is not resolved.\n235         if not isinstance(self.remote_field.model, ModelBase):\n236             return []\n237 \n238         # Consider that we are checking field `Model.foreign` and the models\n239         # are:\n240         #\n241         #     class Target(models.Model):\n242         #         model = models.IntegerField()\n243         #         model_set = models.IntegerField()\n244         #\n245         #     class Model(models.Model):\n246         #         foreign = models.ForeignKey(Target)\n247         #         m2m = models.ManyToManyField(Target)\n248 \n249         # rel_opts.object_name == \"Target\"\n250         rel_opts = self.remote_field.model._meta\n251         # If the field doesn't install a backward relation on the target model\n252         # (so `is_hidden` returns True), then there are no clashes to check\n253         # and we can skip these fields.\n254         rel_is_hidden = self.remote_field.is_hidden()\n255         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n256         rel_query_name = self.related_query_name()  # i. e. \"model\"\n257         # i.e. \"app_label.Model.field\".\n258         field_name = \"%s.%s\" % (opts.label, self.name)\n259 \n260         # Check clashes between accessor or reverse query name of `field`\n261         # and any other field name -- i.e. accessor for Model.foreign is\n262         # model_set and it clashes with Target.model_set.\n263         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n264         for clash_field in potential_clashes:\n265             # i.e. \"app_label.Target.model_set\".\n266             clash_name = \"%s.%s\" % (rel_opts.label, clash_field.name)\n267             if not rel_is_hidden and clash_field.name == rel_name:\n268                 errors.append(\n269                     checks.Error(\n270                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n271                         f\"for '{field_name}' clashes with field name \"\n272                         f\"'{clash_name}'.\",\n273                         hint=(\n274                             \"Rename field '%s', or add/change a related_name \"\n275                             \"argument to the definition for field '%s'.\"\n276                         )\n277                         % (clash_name, field_name),\n278                         obj=self,\n279                         id=\"fields.E302\",\n280                     )\n281                 )\n282 \n283             if clash_field.name == rel_query_name:\n284                 errors.append(\n285                     checks.Error(\n286                         \"Reverse query name for '%s' clashes with field name '%s'.\"\n287                         % (field_name, clash_name),\n288                         hint=(\n289                             \"Rename field '%s', or add/change a related_name \"\n290                             \"argument to the definition for field '%s'.\"\n291                         )\n292                         % (clash_name, field_name),\n293                         obj=self,\n294                         id=\"fields.E303\",\n295                     )\n296                 )\n297 \n298         # Check clashes between accessors/reverse query names of `field` and\n299         # any other field accessor -- i. e. Model.foreign accessor clashes with\n300         # Model.m2m accessor.\n301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n302         for clash_field in potential_clashes:\n303             # i.e. \"app_label.Model.m2m\".\n304             clash_name = \"%s.%s\" % (\n305                 clash_field.related_model._meta.label,\n306                 clash_field.field.name,\n307             )\n308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n309                 errors.append(\n310                     checks.Error(\n311                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n312                         f\"for '{field_name}' clashes with reverse accessor for \"\n313                         f\"'{clash_name}'.\",\n314                         hint=(\n315                             \"Add or change a related_name argument \"\n316                             \"to the definition for '%s' or '%s'.\"\n317                         )\n318                         % (field_name, clash_name),\n319                         obj=self,\n320                         id=\"fields.E304\",\n321                     )\n322                 )\n323 \n324             if clash_field.get_accessor_name() == rel_query_name:\n325                 errors.append(\n326                     checks.Error(\n327                         \"Reverse query name for '%s' clashes with reverse query name \"\n328                         \"for '%s'.\" % (field_name, clash_name),\n329                         hint=(\n330                             \"Add or change a related_name argument \"\n331                             \"to the definition for '%s' or '%s'.\"\n332                         )\n333                         % (field_name, clash_name),\n334                         obj=self,\n335                         id=\"fields.E305\",\n336                     )\n337                 )\n338 \n339         return errors\n340 \n341     def db_type(self, connection):\n342         # By default related field will not have a column as it relates to\n343         # columns from another table.\n344         return None\n345 \n346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n347 \n348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n349 \n350         self.opts = cls._meta\n351 \n352         if not cls._meta.abstract:\n353             if self.remote_field.related_name:\n354                 related_name = self.remote_field.related_name\n355             else:\n356                 related_name = self.opts.default_related_name\n357             if related_name:\n358                 related_name = related_name % {\n359                     \"class\": cls.__name__.lower(),\n360                     \"model_name\": cls._meta.model_name.lower(),\n361                     \"app_label\": cls._meta.app_label.lower(),\n362                 }\n363                 self.remote_field.related_name = related_name\n364 \n365             if self.remote_field.related_query_name:\n366                 related_query_name = self.remote_field.related_query_name % {\n367                     \"class\": cls.__name__.lower(),\n368                     \"app_label\": cls._meta.app_label.lower(),\n369                 }\n370                 self.remote_field.related_query_name = related_query_name\n371 \n372             def resolve_related_class(model, related, field):\n373                 field.remote_field.model = related\n374                 field.do_related_class(related, model)\n375 \n376             lazy_related_operation(\n377                 resolve_related_class, cls, self.remote_field.model, field=self\n378             )\n379 \n380     def deconstruct(self):\n381         name, path, args, kwargs = super().deconstruct()\n382         if self._limit_choices_to:\n383             kwargs[\"limit_choices_to\"] = self._limit_choices_to\n384         if self._related_name is not None:\n385             kwargs[\"related_name\"] = self._related_name\n386         if self._related_query_name is not None:\n387             kwargs[\"related_query_name\"] = self._related_query_name\n388         return name, path, args, kwargs\n389 \n390     def get_forward_related_filter(self, obj):\n391         \"\"\"\n392         Return the keyword arguments that when supplied to\n393         self.model.object.filter(), would select all instances related through\n394         this field to the remote obj. This is used to build the querysets\n395         returned by related descriptors. obj is an instance of\n396         self.related_field.model.\n397         \"\"\"\n398         return {\n399             \"%s__%s\" % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n400             for _, rh_field in self.related_fields\n401         }\n402 \n403     def get_reverse_related_filter(self, obj):\n404         \"\"\"\n405         Complement to get_forward_related_filter(). Return the keyword\n406         arguments that when passed to self.related_field.model.object.filter()\n407         select all instances of self.related_field.model related through\n408         this field to obj. obj is an instance of self.model.\n409         \"\"\"\n410         base_filter = (\n411             (rh_field.attname, getattr(obj, lh_field.attname))\n412             for lh_field, rh_field in self.related_fields\n413         )\n414         descriptor_filter = self.get_extra_descriptor_filter(obj)\n415         base_q = Q(*base_filter)\n416         if isinstance(descriptor_filter, dict):\n417             return base_q & Q(**descriptor_filter)\n418         elif descriptor_filter:\n419             return base_q & descriptor_filter\n420         return base_q\n421 \n422     @property\n423     def swappable_setting(self):\n424         \"\"\"\n425         Get the setting that this is powered from for swapping, or None\n426         if it's not swapped in / marked with swappable=False.\n427         \"\"\"\n428         if self.swappable:\n429             # Work out string form of \"to\"\n430             if isinstance(self.remote_field.model, str):\n431                 to_string = self.remote_field.model\n432             else:\n433                 to_string = self.remote_field.model._meta.label\n434             return apps.get_swappable_settings_name(to_string)\n435         return None\n436 \n437     def set_attributes_from_rel(self):\n438         self.name = self.name or (\n439             self.remote_field.model._meta.model_name\n440             + \"_\"\n441             + self.remote_field.model._meta.pk.name\n442         )\n443         if self.verbose_name is None:\n444             self.verbose_name = self.remote_field.model._meta.verbose_name\n445         self.remote_field.set_field_name()\n446 \n447     def do_related_class(self, other, cls):\n448         self.set_attributes_from_rel()\n449         self.contribute_to_related_class(other, self.remote_field)\n450 \n451     def get_limit_choices_to(self):\n452         \"\"\"\n453         Return ``limit_choices_to`` for this model field.\n454 \n455         If it is a callable, it will be invoked and the result will be\n456         returned.\n457         \"\"\"\n458         if callable(self.remote_field.limit_choices_to):\n459             return self.remote_field.limit_choices_to()\n460         return self.remote_field.limit_choices_to\n461 \n462     def formfield(self, **kwargs):\n463         \"\"\"\n464         Pass ``limit_choices_to`` to the field being constructed.\n465 \n466         Only passes it if there is a type that supports related fields.\n467         This is a similar strategy used to pass the ``queryset`` to the field\n468         being constructed.\n469         \"\"\"\n470         defaults = {}\n471         if hasattr(self.remote_field, \"get_related_field\"):\n472             # If this is a callable, do not invoke it here. Just pass\n473             # it in the defaults for when the form class will later be\n474             # instantiated.\n475             limit_choices_to = self.remote_field.limit_choices_to\n476             defaults.update(\n477                 {\n478                     \"limit_choices_to\": limit_choices_to,\n479                 }\n480             )\n481         defaults.update(kwargs)\n482         return super().formfield(**defaults)\n483 \n484     def related_query_name(self):\n485         \"\"\"\n486         Define the name that can be used to identify this related object in a\n487         table-spanning query.\n488         \"\"\"\n489         return (\n490             self.remote_field.related_query_name\n491             or self.remote_field.related_name\n492             or self.opts.model_name\n493         )\n494 \n495     @property\n496     def target_field(self):\n497         \"\"\"\n498         When filtering against this relation, return the field on the remote\n499         model against which the filtering should happen.\n500         \"\"\"\n501         target_fields = self.path_infos[-1].target_fields\n502         if len(target_fields) > 1:\n503             raise exceptions.FieldError(\n504                 \"The relation has multiple target fields, but only single target field \"\n505                 \"was asked for\"\n506             )\n507         return target_fields[0]\n508 \n509     def get_cache_name(self):\n510         return self.name\n511 \n512 \n513 class ForeignObject(RelatedField):\n514     \"\"\"\n515     Abstraction of the ForeignKey relation to support multi-column relations.\n516     \"\"\"\n517 \n518     # Field flags\n519     many_to_many = False\n520     many_to_one = True\n521     one_to_many = False\n522     one_to_one = False\n523 \n524     requires_unique_target = True\n525     related_accessor_class = ReverseManyToOneDescriptor\n526     forward_related_accessor_class = ForwardManyToOneDescriptor\n527     rel_class = ForeignObjectRel\n528 \n529     def __init__(\n530         self,\n531         to,\n532         on_delete,\n533         from_fields,\n534         to_fields,\n535         rel=None,\n536         related_name=None,\n537         related_query_name=None,\n538         limit_choices_to=None,\n539         parent_link=False,\n540         swappable=True,\n541         **kwargs,\n542     ):\n543 \n544         if rel is None:\n545             rel = self.rel_class(\n546                 self,\n547                 to,\n548                 related_name=related_name,\n549                 related_query_name=related_query_name,\n550                 limit_choices_to=limit_choices_to,\n551                 parent_link=parent_link,\n552                 on_delete=on_delete,\n553             )\n554 \n555         super().__init__(\n556             rel=rel,\n557             related_name=related_name,\n558             related_query_name=related_query_name,\n559             limit_choices_to=limit_choices_to,\n560             **kwargs,\n561         )\n562 \n563         self.from_fields = from_fields\n564         self.to_fields = to_fields\n565         self.swappable = swappable\n566 \n567     def __copy__(self):\n568         obj = super().__copy__()\n569         # Remove any cached PathInfo values.\n570         obj.__dict__.pop(\"path_infos\", None)\n571         obj.__dict__.pop(\"reverse_path_infos\", None)\n572         return obj\n573 \n574     def check(self, **kwargs):\n575         return [\n576             *super().check(**kwargs),\n577             *self._check_to_fields_exist(),\n578             *self._check_unique_target(),\n579         ]\n580 \n581     def _check_to_fields_exist(self):\n582         # Skip nonexistent models.\n583         if isinstance(self.remote_field.model, str):\n584             return []\n585 \n586         errors = []\n587         for to_field in self.to_fields:\n588             if to_field:\n589                 try:\n590                     self.remote_field.model._meta.get_field(to_field)\n591                 except exceptions.FieldDoesNotExist:\n592                     errors.append(\n593                         checks.Error(\n594                             \"The to_field '%s' doesn't exist on the related \"\n595                             \"model '%s'.\"\n596                             % (to_field, self.remote_field.model._meta.label),\n597                             obj=self,\n598                             id=\"fields.E312\",\n599                         )\n600                     )\n601         return errors\n602 \n603     def _check_unique_target(self):\n604         rel_is_string = isinstance(self.remote_field.model, str)\n605         if rel_is_string or not self.requires_unique_target:\n606             return []\n607 \n608         try:\n609             self.foreign_related_fields\n610         except exceptions.FieldDoesNotExist:\n611             return []\n612 \n613         if not self.foreign_related_fields:\n614             return []\n615 \n616         unique_foreign_fields = {\n617             frozenset([f.name])\n618             for f in self.remote_field.model._meta.get_fields()\n619             if getattr(f, \"unique\", False)\n620         }\n621         unique_foreign_fields.update(\n622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}\n623         )\n624         unique_foreign_fields.update(\n625             {\n626                 frozenset(uc.fields)\n627                 for uc in self.remote_field.model._meta.total_unique_constraints\n628             }\n629         )\n630         foreign_fields = {f.name for f in self.foreign_related_fields}\n631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n632 \n633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n634             field_combination = \", \".join(\n635                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n636             )\n637             model_name = self.remote_field.model.__name__\n638             return [\n639                 checks.Error(\n640                     \"No subset of the fields %s on model '%s' is unique.\"\n641                     % (field_combination, model_name),\n642                     hint=(\n643                         \"Mark a single field as unique=True or add a set of \"\n644                         \"fields to a unique constraint (via unique_together \"\n645                         \"or a UniqueConstraint (without condition) in the \"\n646                         \"model Meta.constraints).\"\n647                     ),\n648                     obj=self,\n649                     id=\"fields.E310\",\n650                 )\n651             ]\n652         elif not has_unique_constraint:\n653             field_name = self.foreign_related_fields[0].name\n654             model_name = self.remote_field.model.__name__\n655             return [\n656                 checks.Error(\n657                     \"'%s.%s' must be unique because it is referenced by \"\n658                     \"a foreign key.\" % (model_name, field_name),\n659                     hint=(\n660                         \"Add unique=True to this field or add a \"\n661                         \"UniqueConstraint (without condition) in the model \"\n662                         \"Meta.constraints.\"\n663                     ),\n664                     obj=self,\n665                     id=\"fields.E311\",\n666                 )\n667             ]\n668         else:\n669             return []\n670 \n671     def deconstruct(self):\n672         name, path, args, kwargs = super().deconstruct()\n673         kwargs[\"on_delete\"] = self.remote_field.on_delete\n674         kwargs[\"from_fields\"] = self.from_fields\n675         kwargs[\"to_fields\"] = self.to_fields\n676 \n677         if self.remote_field.parent_link:\n678             kwargs[\"parent_link\"] = self.remote_field.parent_link\n679         if isinstance(self.remote_field.model, str):\n680             if \".\" in self.remote_field.model:\n681                 app_label, model_name = self.remote_field.model.split(\".\")\n682                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n683             else:\n684                 kwargs[\"to\"] = self.remote_field.model.lower()\n685         else:\n686             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n687         # If swappable is True, then see if we're actually pointing to the target\n688         # of a swap.\n689         swappable_setting = self.swappable_setting\n690         if swappable_setting is not None:\n691             # If it's already a settings reference, error\n692             if hasattr(kwargs[\"to\"], \"setting_name\"):\n693                 if kwargs[\"to\"].setting_name != swappable_setting:\n694                     raise ValueError(\n695                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n696                         \"that is swapped in place of more than one model (%s and %s)\"\n697                         % (kwargs[\"to\"].setting_name, swappable_setting)\n698                     )\n699             # Set it\n700             kwargs[\"to\"] = SettingsReference(\n701                 kwargs[\"to\"],\n702                 swappable_setting,\n703             )\n704         return name, path, args, kwargs\n705 \n706     def resolve_related_fields(self):\n707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n708             raise ValueError(\n709                 \"Foreign Object from and to fields must be the same non-zero length\"\n710             )\n711         if isinstance(self.remote_field.model, str):\n712             raise ValueError(\n713                 \"Related model %r cannot be resolved\" % self.remote_field.model\n714             )\n715         related_fields = []\n716         for index in range(len(self.from_fields)):\n717             from_field_name = self.from_fields[index]\n718             to_field_name = self.to_fields[index]\n719             from_field = (\n720                 self\n721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n722                 else self.opts.get_field(from_field_name)\n723             )\n724             to_field = (\n725                 self.remote_field.model._meta.pk\n726                 if to_field_name is None\n727                 else self.remote_field.model._meta.get_field(to_field_name)\n728             )\n729             related_fields.append((from_field, to_field))\n730         return related_fields\n731 \n732     @cached_property\n733     def related_fields(self):\n734         return self.resolve_related_fields()\n735 \n736     @cached_property\n737     def reverse_related_fields(self):\n738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n739 \n740     @cached_property\n741     def local_related_fields(self):\n742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n743 \n744     @cached_property\n745     def foreign_related_fields(self):\n746         return tuple(\n747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field\n748         )\n749 \n750     def get_local_related_value(self, instance):\n751         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n752 \n753     def get_foreign_related_value(self, instance):\n754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n755 \n756     @staticmethod\n757     def get_instance_value_for_fields(instance, fields):\n758         ret = []\n759         opts = instance._meta\n760         for field in fields:\n761             # Gotcha: in some cases (like fixture loading) a model can have\n762             # different values in parent_ptr_id and parent's id. So, use\n763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n764             if field.primary_key:\n765                 possible_parent_link = opts.get_ancestor_link(field.model)\n766                 if (\n767                     not possible_parent_link\n768                     or possible_parent_link.primary_key\n769                     or possible_parent_link.model._meta.abstract\n770                 ):\n771                     ret.append(instance.pk)\n772                     continue\n773             ret.append(getattr(instance, field.attname))\n774         return tuple(ret)\n775 \n776     def get_attname_column(self):\n777         attname, column = super().get_attname_column()\n778         return attname, None\n779 \n780     def get_joining_columns(self, reverse_join=False):\n781         source = self.reverse_related_fields if reverse_join else self.related_fields\n782         return tuple(\n783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source\n784         )\n785 \n786     def get_reverse_joining_columns(self):\n787         return self.get_joining_columns(reverse_join=True)\n788 \n789     def get_extra_descriptor_filter(self, instance):\n790         \"\"\"\n791         Return an extra filter condition for related object fetching when\n792         user does 'instance.fieldname', that is the extra filter is used in\n793         the descriptor of the field.\n794 \n795         The filter should be either a dict usable in .filter(**kwargs) call or\n796         a Q-object. The condition will be ANDed together with the relation's\n797         joining columns.\n798 \n799         A parallel method is get_extra_restriction() which is used in\n800         JOIN and subquery conditions.\n801         \"\"\"\n802         return {}\n803 \n804     def get_extra_restriction(self, alias, related_alias):\n805         \"\"\"\n806         Return a pair condition used for joining and subquery pushdown. The\n807         condition is something that responds to as_sql(compiler, connection)\n808         method.\n809 \n810         Note that currently referring both the 'alias' and 'related_alias'\n811         will not work in some conditions, like subquery pushdown.\n812 \n813         A parallel method is get_extra_descriptor_filter() which is used in\n814         instance.fieldname related object fetching.\n815         \"\"\"\n816         return None\n817 \n818     def get_path_info(self, filtered_relation=None):\n819         \"\"\"Get path from this field to the related model.\"\"\"\n820         opts = self.remote_field.model._meta\n821         from_opts = self.model._meta\n822         return [\n823             PathInfo(\n824                 from_opts=from_opts,\n825                 to_opts=opts,\n826                 target_fields=self.foreign_related_fields,\n827                 join_field=self,\n828                 m2m=False,\n829                 direct=True,\n830                 filtered_relation=filtered_relation,\n831             )\n832         ]\n833 \n834     @cached_property\n835     def path_infos(self):\n836         return self.get_path_info()\n837 \n838     def get_reverse_path_info(self, filtered_relation=None):\n839         \"\"\"Get path from the related model to this field's model.\"\"\"\n840         opts = self.model._meta\n841         from_opts = self.remote_field.model._meta\n842         return [\n843             PathInfo(\n844                 from_opts=from_opts,\n845                 to_opts=opts,\n846                 target_fields=(opts.pk,),\n847                 join_field=self.remote_field,\n848                 m2m=not self.unique,\n849                 direct=False,\n850                 filtered_relation=filtered_relation,\n851             )\n852         ]\n853 \n854     @cached_property\n855     def reverse_path_infos(self):\n856         return self.get_reverse_path_info()\n857 \n858     @classmethod\n859     @functools.lru_cache(maxsize=None)\n860     def get_lookups(cls):\n861         bases = inspect.getmro(cls)\n862         bases = bases[: bases.index(ForeignObject) + 1]\n863         class_lookups = [parent.__dict__.get(\"class_lookups\", {}) for parent in bases]\n864         return cls.merge_dicts(class_lookups)\n865 \n866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n868         setattr(cls, self.name, self.forward_related_accessor_class(self))\n869 \n870     def contribute_to_related_class(self, cls, related):\n871         # Internal FK's - i.e., those with a related name ending with '+' -\n872         # and swapped models don't get a related descriptor.\n873         if (\n874             not self.remote_field.is_hidden()\n875             and not related.related_model._meta.swapped\n876         ):\n877             setattr(\n878                 cls._meta.concrete_model,\n879                 related.get_accessor_name(),\n880                 self.related_accessor_class(related),\n881             )\n882             # While 'limit_choices_to' might be a callable, simply pass\n883             # it along for later - this is too early because it's still\n884             # model load time.\n885             if self.remote_field.limit_choices_to:\n886                 cls._meta.related_fkey_lookups.append(\n887                     self.remote_field.limit_choices_to\n888                 )\n889 \n890 \n891 ForeignObject.register_lookup(RelatedIn)\n892 ForeignObject.register_lookup(RelatedExact)\n893 ForeignObject.register_lookup(RelatedLessThan)\n894 ForeignObject.register_lookup(RelatedGreaterThan)\n895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n896 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n897 ForeignObject.register_lookup(RelatedIsNull)\n898 \n899 \n900 class ForeignKey(ForeignObject):\n901     \"\"\"\n902     Provide a many-to-one relation by adding a column to the local model\n903     to hold the remote value.\n904 \n905     By default ForeignKey will target the pk of the remote model but this\n906     behavior can be changed by using the ``to_field`` argument.\n907     \"\"\"\n908 \n909     descriptor_class = ForeignKeyDeferredAttribute\n910     # Field flags\n911     many_to_many = False\n912     many_to_one = True\n913     one_to_many = False\n914     one_to_one = False\n915 \n916     rel_class = ManyToOneRel\n917 \n918     empty_strings_allowed = False\n919     default_error_messages = {\n920         \"invalid\": _(\"%(model)s instance with %(field)s %(value)r does not exist.\")\n921     }\n922     description = _(\"Foreign Key (type determined by related field)\")\n923 \n924     def __init__(\n925         self,\n926         to,\n927         on_delete,\n928         related_name=None,\n929         related_query_name=None,\n930         limit_choices_to=None,\n931         parent_link=False,\n932         to_field=None,\n933         db_constraint=True,\n934         **kwargs,\n935     ):\n936         try:\n937             to._meta.model_name\n938         except AttributeError:\n939             if not isinstance(to, str):\n940                 raise TypeError(\n941                     \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n942                     \"either a model, a model name, or the string %r\"\n943                     % (\n944                         self.__class__.__name__,\n945                         to,\n946                         RECURSIVE_RELATIONSHIP_CONSTANT,\n947                     )\n948                 )\n949         else:\n950             # For backwards compatibility purposes, we need to *try* and set\n951             # the to_field during FK construction. It won't be guaranteed to\n952             # be correct until contribute_to_class is called. Refs #12190.\n953             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n954         if not callable(on_delete):\n955             raise TypeError(\"on_delete must be callable.\")\n956 \n957         kwargs[\"rel\"] = self.rel_class(\n958             self,\n959             to,\n960             to_field,\n961             related_name=related_name,\n962             related_query_name=related_query_name,\n963             limit_choices_to=limit_choices_to,\n964             parent_link=parent_link,\n965             on_delete=on_delete,\n966         )\n967         kwargs.setdefault(\"db_index\", True)\n968 \n969         super().__init__(\n970             to,\n971             on_delete,\n972             related_name=related_name,\n973             related_query_name=related_query_name,\n974             limit_choices_to=limit_choices_to,\n975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n976             to_fields=[to_field],\n977             **kwargs,\n978         )\n979         self.db_constraint = db_constraint\n980 \n981     def __class_getitem__(cls, *args, **kwargs):\n982         return cls\n983 \n984     def check(self, **kwargs):\n985         return [\n986             *super().check(**kwargs),\n987             *self._check_on_delete(),\n988             *self._check_unique(),\n989         ]\n990 \n991     def _check_on_delete(self):\n992         on_delete = getattr(self.remote_field, \"on_delete\", None)\n993         if on_delete == SET_NULL and not self.null:\n994             return [\n995                 checks.Error(\n996                     \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n997                     hint=(\n998                         \"Set null=True argument on the field, or change the on_delete \"\n999                         \"rule.\"\n1000                     ),\n1001                     obj=self,\n1002                     id=\"fields.E320\",\n1003                 )\n1004             ]\n1005         elif on_delete == SET_DEFAULT and not self.has_default():\n1006             return [\n1007                 checks.Error(\n1008                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n1009                     hint=\"Set a default value, or change the on_delete rule.\",\n1010                     obj=self,\n1011                     id=\"fields.E321\",\n1012                 )\n1013             ]\n1014         else:\n1015             return []\n1016 \n1017     def _check_unique(self, **kwargs):\n1018         return (\n1019             [\n1020                 checks.Warning(\n1021                     \"Setting unique=True on a ForeignKey has the same effect as using \"\n1022                     \"a OneToOneField.\",\n1023                     hint=(\n1024                         \"ForeignKey(unique=True) is usually better served by a \"\n1025                         \"OneToOneField.\"\n1026                     ),\n1027                     obj=self,\n1028                     id=\"fields.W342\",\n1029                 )\n1030             ]\n1031             if self.unique\n1032             else []\n1033         )\n1034 \n1035     def deconstruct(self):\n1036         name, path, args, kwargs = super().deconstruct()\n1037         del kwargs[\"to_fields\"]\n1038         del kwargs[\"from_fields\"]\n1039         # Handle the simpler arguments\n1040         if self.db_index:\n1041             del kwargs[\"db_index\"]\n1042         else:\n1043             kwargs[\"db_index\"] = False\n1044         if self.db_constraint is not True:\n1045             kwargs[\"db_constraint\"] = self.db_constraint\n1046         # Rel needs more work.\n1047         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n1048         if self.remote_field.field_name and (\n1049             not to_meta\n1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)\n1051         ):\n1052             kwargs[\"to_field\"] = self.remote_field.field_name\n1053         return name, path, args, kwargs\n1054 \n1055     def to_python(self, value):\n1056         return self.target_field.to_python(value)\n1057 \n1058     @property\n1059     def target_field(self):\n1060         return self.foreign_related_fields[0]\n1061 \n1062     def get_reverse_path_info(self, filtered_relation=None):\n1063         \"\"\"Get path from the related model to this field's model.\"\"\"\n1064         opts = self.model._meta\n1065         from_opts = self.remote_field.model._meta\n1066         return [\n1067             PathInfo(\n1068                 from_opts=from_opts,\n1069                 to_opts=opts,\n1070                 target_fields=(opts.pk,),\n1071                 join_field=self.remote_field,\n1072                 m2m=not self.unique,\n1073                 direct=False,\n1074                 filtered_relation=filtered_relation,\n1075             )\n1076         ]\n1077 \n1078     def validate(self, value, model_instance):\n1079         if self.remote_field.parent_link:\n1080             return\n1081         super().validate(value, model_instance)\n1082         if value is None:\n1083             return\n1084 \n1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n1086         qs = self.remote_field.model._base_manager.using(using).filter(\n1087             **{self.remote_field.field_name: value}\n1088         )\n1089         qs = qs.complex_filter(self.get_limit_choices_to())\n1090         if not qs.exists():\n1091             raise exceptions.ValidationError(\n1092                 self.error_messages[\"invalid\"],\n1093                 code=\"invalid\",\n1094                 params={\n1095                     \"model\": self.remote_field.model._meta.verbose_name,\n1096                     \"pk\": value,\n1097                     \"field\": self.remote_field.field_name,\n1098                     \"value\": value,\n1099                 },  # 'pk' is included for backwards compatibility\n1100             )\n1101 \n1102     def resolve_related_fields(self):\n1103         related_fields = super().resolve_related_fields()\n1104         for from_field, to_field in related_fields:\n1105             if (\n1106                 to_field\n1107                 and to_field.model != self.remote_field.model._meta.concrete_model\n1108             ):\n1109                 raise exceptions.FieldError(\n1110                     \"'%s.%s' refers to field '%s' which is not local to model \"\n1111                     \"'%s'.\"\n1112                     % (\n1113                         self.model._meta.label,\n1114                         self.name,\n1115                         to_field.name,\n1116                         self.remote_field.model._meta.concrete_model._meta.label,\n1117                     )\n1118                 )\n1119         return related_fields\n1120 \n1121     def get_attname(self):\n1122         return \"%s_id\" % self.name\n1123 \n1124     def get_attname_column(self):\n1125         attname = self.get_attname()\n1126         column = self.db_column or attname\n1127         return attname, column\n1128 \n1129     def get_default(self):\n1130         \"\"\"Return the to_field if the default value is an object.\"\"\"\n1131         field_default = super().get_default()\n1132         if isinstance(field_default, self.remote_field.model):\n1133             return getattr(field_default, self.target_field.attname)\n1134         return field_default\n1135 \n1136     def get_db_prep_save(self, value, connection):\n1137         if value is None or (\n1138             value == \"\"\n1139             and (\n1140                 not self.target_field.empty_strings_allowed\n1141                 or connection.features.interprets_empty_strings_as_nulls\n1142             )\n1143         ):\n1144             return None\n1145         else:\n1146             return self.target_field.get_db_prep_save(value, connection=connection)\n1147 \n1148     def get_db_prep_value(self, value, connection, prepared=False):\n1149         return self.target_field.get_db_prep_value(value, connection, prepared)\n1150 \n1151     def get_prep_value(self, value):\n1152         return self.target_field.get_prep_value(value)\n1153 \n1154     def contribute_to_related_class(self, cls, related):\n1155         super().contribute_to_related_class(cls, related)\n1156         if self.remote_field.field_name is None:\n1157             self.remote_field.field_name = cls._meta.pk.name\n1158 \n1159     def formfield(self, *, using=None, **kwargs):\n1160         if isinstance(self.remote_field.model, str):\n1161             raise ValueError(\n1162                 \"Cannot create form field for %r yet, because \"\n1163                 \"its related model %r has not been loaded yet\"\n1164                 % (self.name, self.remote_field.model)\n1165             )\n1166         return super().formfield(\n1167             **{\n1168                 \"form_class\": forms.ModelChoiceField,\n1169                 \"queryset\": self.remote_field.model._default_manager.using(using),\n1170                 \"to_field_name\": self.remote_field.field_name,\n1171                 **kwargs,\n1172                 \"blank\": self.blank,\n1173             }\n1174         )\n1175 \n1176     def db_check(self, connection):\n1177         return None\n1178 \n1179     def db_type(self, connection):\n1180         return self.target_field.rel_db_type(connection=connection)\n1181 \n1182     def db_parameters(self, connection):\n1183         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1184 \n1185     def convert_empty_strings(self, value, expression, connection):\n1186         if (not value) and isinstance(value, str):\n1187             return None\n1188         return value\n1189 \n1190     def get_db_converters(self, connection):\n1191         converters = super().get_db_converters(connection)\n1192         if connection.features.interprets_empty_strings_as_nulls:\n1193             converters += [self.convert_empty_strings]\n1194         return converters\n1195 \n1196     def get_col(self, alias, output_field=None):\n1197         if output_field is None:\n1198             output_field = self.target_field\n1199             while isinstance(output_field, ForeignKey):\n1200                 output_field = output_field.target_field\n1201                 if output_field is self:\n1202                     raise ValueError(\"Cannot resolve output_field.\")\n1203         return super().get_col(alias, output_field)\n1204 \n1205 \n1206 class OneToOneField(ForeignKey):\n1207     \"\"\"\n1208     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1209     that it always carries a \"unique\" constraint with it and the reverse\n1210     relation always returns the object pointed to (since there will only ever\n1211     be one), rather than returning a list.\n1212     \"\"\"\n1213 \n1214     # Field flags\n1215     many_to_many = False\n1216     many_to_one = False\n1217     one_to_many = False\n1218     one_to_one = True\n1219 \n1220     related_accessor_class = ReverseOneToOneDescriptor\n1221     forward_related_accessor_class = ForwardOneToOneDescriptor\n1222     rel_class = OneToOneRel\n1223 \n1224     description = _(\"One-to-one relationship\")\n1225 \n1226     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1227         kwargs[\"unique\"] = True\n1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1229 \n1230     def deconstruct(self):\n1231         name, path, args, kwargs = super().deconstruct()\n1232         if \"unique\" in kwargs:\n1233             del kwargs[\"unique\"]\n1234         return name, path, args, kwargs\n1235 \n1236     def formfield(self, **kwargs):\n1237         if self.remote_field.parent_link:\n1238             return None\n1239         return super().formfield(**kwargs)\n1240 \n1241     def save_form_data(self, instance, data):\n1242         if isinstance(data, self.remote_field.model):\n1243             setattr(instance, self.name, data)\n1244         else:\n1245             setattr(instance, self.attname, data)\n1246             # Remote field object must be cleared otherwise Model.save()\n1247             # will reassign attname using the related object pk.\n1248             if data is None:\n1249                 setattr(instance, self.name, data)\n1250 \n1251     def _check_unique(self, **kwargs):\n1252         # Override ForeignKey since check isn't applicable here.\n1253         return []\n1254 \n1255 \n1256 def create_many_to_many_intermediary_model(field, klass):\n1257     from django.db import models\n1258 \n1259     def set_managed(model, related, through):\n1260         through._meta.managed = model._meta.managed or related._meta.managed\n1261 \n1262     to_model = resolve_relation(klass, field.remote_field.model)\n1263     name = \"%s_%s\" % (klass._meta.object_name, field.name)\n1264     lazy_related_operation(set_managed, klass, to_model, name)\n1265 \n1266     to = make_model_tuple(to_model)[1]\n1267     from_ = klass._meta.model_name\n1268     if to == from_:\n1269         to = \"to_%s\" % to\n1270         from_ = \"from_%s\" % from_\n1271 \n1272     meta = type(\n1273         \"Meta\",\n1274         (),\n1275         {\n1276             \"db_table\": field._get_m2m_db_table(klass._meta),\n1277             \"auto_created\": klass,\n1278             \"app_label\": klass._meta.app_label,\n1279             \"db_tablespace\": klass._meta.db_tablespace,\n1280             \"unique_together\": (from_, to),\n1281             \"verbose_name\": _(\"%(from)s-%(to)s relationship\")\n1282             % {\"from\": from_, \"to\": to},\n1283             \"verbose_name_plural\": _(\"%(from)s-%(to)s relationships\")\n1284             % {\"from\": from_, \"to\": to},\n1285             \"apps\": field.model._meta.apps,\n1286         },\n1287     )\n1288     # Construct and return the new class.\n1289     return type(\n1290         name,\n1291         (models.Model,),\n1292         {\n1293             \"Meta\": meta,\n1294             \"__module__\": klass.__module__,\n1295             from_: models.ForeignKey(\n1296                 klass,\n1297                 related_name=\"%s+\" % name,\n1298                 db_tablespace=field.db_tablespace,\n1299                 db_constraint=field.remote_field.db_constraint,\n1300                 on_delete=CASCADE,\n1301             ),\n1302             to: models.ForeignKey(\n1303                 to_model,\n1304                 related_name=\"%s+\" % name,\n1305                 db_tablespace=field.db_tablespace,\n1306                 db_constraint=field.remote_field.db_constraint,\n1307                 on_delete=CASCADE,\n1308             ),\n1309         },\n1310     )\n1311 \n1312 \n1313 class ManyToManyField(RelatedField):\n1314     \"\"\"\n1315     Provide a many-to-many relation by using an intermediary model that\n1316     holds two ForeignKey fields pointed at the two sides of the relation.\n1317 \n1318     Unless a ``through`` model was provided, ManyToManyField will use the\n1319     create_many_to_many_intermediary_model factory to automatically generate\n1320     the intermediary model.\n1321     \"\"\"\n1322 \n1323     # Field flags\n1324     many_to_many = True\n1325     many_to_one = False\n1326     one_to_many = False\n1327     one_to_one = False\n1328 \n1329     rel_class = ManyToManyRel\n1330 \n1331     description = _(\"Many-to-many relationship\")\n1332 \n1333     def __init__(\n1334         self,\n1335         to,\n1336         related_name=None,\n1337         related_query_name=None,\n1338         limit_choices_to=None,\n1339         symmetrical=None,\n1340         through=None,\n1341         through_fields=None,\n1342         db_constraint=True,\n1343         db_table=None,\n1344         swappable=True,\n1345         **kwargs,\n1346     ):\n1347         try:\n1348             to._meta\n1349         except AttributeError:\n1350             if not isinstance(to, str):\n1351                 raise TypeError(\n1352                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1353                     \"must be either a model, a model name, or the string %r\"\n1354                     % (\n1355                         self.__class__.__name__,\n1356                         to,\n1357                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1358                     )\n1359                 )\n1360 \n1361         if symmetrical is None:\n1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1363 \n1364         if through is not None and db_table is not None:\n1365             raise ValueError(\n1366                 \"Cannot specify a db_table if an intermediary model is used.\"\n1367             )\n1368 \n1369         kwargs[\"rel\"] = self.rel_class(\n1370             self,\n1371             to,\n1372             related_name=related_name,\n1373             related_query_name=related_query_name,\n1374             limit_choices_to=limit_choices_to,\n1375             symmetrical=symmetrical,\n1376             through=through,\n1377             through_fields=through_fields,\n1378             db_constraint=db_constraint,\n1379         )\n1380         self.has_null_arg = \"null\" in kwargs\n1381 \n1382         super().__init__(\n1383             related_name=related_name,\n1384             related_query_name=related_query_name,\n1385             limit_choices_to=limit_choices_to,\n1386             **kwargs,\n1387         )\n1388 \n1389         self.db_table = db_table\n1390         self.swappable = swappable\n1391 \n1392     def check(self, **kwargs):\n1393         return [\n1394             *super().check(**kwargs),\n1395             *self._check_unique(**kwargs),\n1396             *self._check_relationship_model(**kwargs),\n1397             *self._check_ignored_options(**kwargs),\n1398             *self._check_table_uniqueness(**kwargs),\n1399         ]\n1400 \n1401     def _check_unique(self, **kwargs):\n1402         if self.unique:\n1403             return [\n1404                 checks.Error(\n1405                     \"ManyToManyFields cannot be unique.\",\n1406                     obj=self,\n1407                     id=\"fields.E330\",\n1408                 )\n1409             ]\n1410         return []\n1411 \n1412     def _check_ignored_options(self, **kwargs):\n1413         warnings = []\n1414 \n1415         if self.has_null_arg:\n1416             warnings.append(\n1417                 checks.Warning(\n1418                     \"null has no effect on ManyToManyField.\",\n1419                     obj=self,\n1420                     id=\"fields.W340\",\n1421                 )\n1422             )\n1423 \n1424         if self._validators:\n1425             warnings.append(\n1426                 checks.Warning(\n1427                     \"ManyToManyField does not support validators.\",\n1428                     obj=self,\n1429                     id=\"fields.W341\",\n1430                 )\n1431             )\n1432         if self.remote_field.symmetrical and self._related_name:\n1433             warnings.append(\n1434                 checks.Warning(\n1435                     \"related_name has no effect on ManyToManyField \"\n1436                     'with a symmetrical relationship, e.g. to \"self\".',\n1437                     obj=self,\n1438                     id=\"fields.W345\",\n1439                 )\n1440             )\n1441 \n1442         return warnings\n1443 \n1444     def _check_relationship_model(self, from_model=None, **kwargs):\n1445         if hasattr(self.remote_field.through, \"_meta\"):\n1446             qualified_model_name = \"%s.%s\" % (\n1447                 self.remote_field.through._meta.app_label,\n1448                 self.remote_field.through.__name__,\n1449             )\n1450         else:\n1451             qualified_model_name = self.remote_field.through\n1452 \n1453         errors = []\n1454 \n1455         if self.remote_field.through not in self.opts.apps.get_models(\n1456             include_auto_created=True\n1457         ):\n1458             # The relationship model is not installed.\n1459             errors.append(\n1460                 checks.Error(\n1461                     \"Field specifies a many-to-many relation through model \"\n1462                     \"'%s', which has not been installed.\" % qualified_model_name,\n1463                     obj=self,\n1464                     id=\"fields.E331\",\n1465                 )\n1466             )\n1467 \n1468         else:\n1469             assert from_model is not None, (\n1470                 \"ManyToManyField with intermediate \"\n1471                 \"tables cannot be checked if you don't pass the model \"\n1472                 \"where the field is attached to.\"\n1473             )\n1474             # Set some useful local variables\n1475             to_model = resolve_relation(from_model, self.remote_field.model)\n1476             from_model_name = from_model._meta.object_name\n1477             if isinstance(to_model, str):\n1478                 to_model_name = to_model\n1479             else:\n1480                 to_model_name = to_model._meta.object_name\n1481             relationship_model_name = self.remote_field.through._meta.object_name\n1482             self_referential = from_model == to_model\n1483             # Count foreign keys in intermediate model\n1484             if self_referential:\n1485                 seen_self = sum(\n1486                     from_model == getattr(field.remote_field, \"model\", None)\n1487                     for field in self.remote_field.through._meta.fields\n1488                 )\n1489 \n1490                 if seen_self > 2 and not self.remote_field.through_fields:\n1491                     errors.append(\n1492                         checks.Error(\n1493                             \"The model is used as an intermediate model by \"\n1494                             \"'%s', but it has more than two foreign keys \"\n1495                             \"to '%s', which is ambiguous. You must specify \"\n1496                             \"which two foreign keys Django should use via the \"\n1497                             \"through_fields keyword argument.\"\n1498                             % (self, from_model_name),\n1499                             hint=(\n1500                                 \"Use through_fields to specify which two foreign keys \"\n1501                                 \"Django should use.\"\n1502                             ),\n1503                             obj=self.remote_field.through,\n1504                             id=\"fields.E333\",\n1505                         )\n1506                     )\n1507 \n1508             else:\n1509                 # Count foreign keys in relationship model\n1510                 seen_from = sum(\n1511                     from_model == getattr(field.remote_field, \"model\", None)\n1512                     for field in self.remote_field.through._meta.fields\n1513                 )\n1514                 seen_to = sum(\n1515                     to_model == getattr(field.remote_field, \"model\", None)\n1516                     for field in self.remote_field.through._meta.fields\n1517                 )\n1518 \n1519                 if seen_from > 1 and not self.remote_field.through_fields:\n1520                     errors.append(\n1521                         checks.Error(\n1522                             (\n1523                                 \"The model is used as an intermediate model by \"\n1524                                 \"'%s', but it has more than one foreign key \"\n1525                                 \"from '%s', which is ambiguous. You must specify \"\n1526                                 \"which foreign key Django should use via the \"\n1527                                 \"through_fields keyword argument.\"\n1528                             )\n1529                             % (self, from_model_name),\n1530                             hint=(\n1531                                 \"If you want to create a recursive relationship, \"\n1532                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1533                             )\n1534                             % (\n1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1536                                 relationship_model_name,\n1537                             ),\n1538                             obj=self,\n1539                             id=\"fields.E334\",\n1540                         )\n1541                     )\n1542 \n1543                 if seen_to > 1 and not self.remote_field.through_fields:\n1544                     errors.append(\n1545                         checks.Error(\n1546                             \"The model is used as an intermediate model by \"\n1547                             \"'%s', but it has more than one foreign key \"\n1548                             \"to '%s', which is ambiguous. You must specify \"\n1549                             \"which foreign key Django should use via the \"\n1550                             \"through_fields keyword argument.\" % (self, to_model_name),\n1551                             hint=(\n1552                                 \"If you want to create a recursive relationship, \"\n1553                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1554                             )\n1555                             % (\n1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1557                                 relationship_model_name,\n1558                             ),\n1559                             obj=self,\n1560                             id=\"fields.E335\",\n1561                         )\n1562                     )\n1563 \n1564                 if seen_from == 0 or seen_to == 0:\n1565                     errors.append(\n1566                         checks.Error(\n1567                             \"The model is used as an intermediate model by \"\n1568                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1569                             % (self, from_model_name, to_model_name),\n1570                             obj=self.remote_field.through,\n1571                             id=\"fields.E336\",\n1572                         )\n1573                     )\n1574 \n1575         # Validate `through_fields`.\n1576         if self.remote_field.through_fields is not None:\n1577             # Validate that we're given an iterable of at least two items\n1578             # and that none of them is \"falsy\".\n1579             if not (\n1580                 len(self.remote_field.through_fields) >= 2\n1581                 and self.remote_field.through_fields[0]\n1582                 and self.remote_field.through_fields[1]\n1583             ):\n1584                 errors.append(\n1585                     checks.Error(\n1586                         \"Field specifies 'through_fields' but does not provide \"\n1587                         \"the names of the two link fields that should be used \"\n1588                         \"for the relation through model '%s'.\" % qualified_model_name,\n1589                         hint=(\n1590                             \"Make sure you specify 'through_fields' as \"\n1591                             \"through_fields=('field1', 'field2')\"\n1592                         ),\n1593                         obj=self,\n1594                         id=\"fields.E337\",\n1595                     )\n1596                 )\n1597 \n1598             # Validate the given through fields -- they should be actual\n1599             # fields on the through model, and also be foreign keys to the\n1600             # expected models.\n1601             else:\n1602                 assert from_model is not None, (\n1603                     \"ManyToManyField with intermediate \"\n1604                     \"tables cannot be checked if you don't pass the model \"\n1605                     \"where the field is attached to.\"\n1606                 )\n1607 \n1608                 source, through, target = (\n1609                     from_model,\n1610                     self.remote_field.through,\n1611                     self.remote_field.model,\n1612                 )\n1613                 source_field_name, target_field_name = self.remote_field.through_fields[\n1614                     :2\n1615                 ]\n1616 \n1617                 for field_name, related_model in (\n1618                     (source_field_name, source),\n1619                     (target_field_name, target),\n1620                 ):\n1621 \n1622                     possible_field_names = []\n1623                     for f in through._meta.fields:\n1624                         if (\n1625                             hasattr(f, \"remote_field\")\n1626                             and getattr(f.remote_field, \"model\", None) == related_model\n1627                         ):\n1628                             possible_field_names.append(f.name)\n1629                     if possible_field_names:\n1630                         hint = (\n1631                             \"Did you mean one of the following foreign keys to '%s': \"\n1632                             \"%s?\"\n1633                             % (\n1634                                 related_model._meta.object_name,\n1635                                 \", \".join(possible_field_names),\n1636                             )\n1637                         )\n1638                     else:\n1639                         hint = None\n1640 \n1641                     try:\n1642                         field = through._meta.get_field(field_name)\n1643                     except exceptions.FieldDoesNotExist:\n1644                         errors.append(\n1645                             checks.Error(\n1646                                 \"The intermediary model '%s' has no field '%s'.\"\n1647                                 % (qualified_model_name, field_name),\n1648                                 hint=hint,\n1649                                 obj=self,\n1650                                 id=\"fields.E338\",\n1651                             )\n1652                         )\n1653                     else:\n1654                         if not (\n1655                             hasattr(field, \"remote_field\")\n1656                             and getattr(field.remote_field, \"model\", None)\n1657                             == related_model\n1658                         ):\n1659                             errors.append(\n1660                                 checks.Error(\n1661                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1662                                     % (\n1663                                         through._meta.object_name,\n1664                                         field_name,\n1665                                         related_model._meta.object_name,\n1666                                     ),\n1667                                     hint=hint,\n1668                                     obj=self,\n1669                                     id=\"fields.E339\",\n1670                                 )\n1671                             )\n1672 \n1673         return errors\n1674 \n1675     def _check_table_uniqueness(self, **kwargs):\n1676         if (\n1677             isinstance(self.remote_field.through, str)\n1678             or not self.remote_field.through._meta.managed\n1679         ):\n1680             return []\n1681         registered_tables = {\n1682             model._meta.db_table: model\n1683             for model in self.opts.apps.get_models(include_auto_created=True)\n1684             if model != self.remote_field.through and model._meta.managed\n1685         }\n1686         m2m_db_table = self.m2m_db_table()\n1687         model = registered_tables.get(m2m_db_table)\n1688         # The second condition allows multiple m2m relations on a model if\n1689         # some point to a through model that proxies another through model.\n1690         if (\n1691             model\n1692             and model._meta.concrete_model\n1693             != self.remote_field.through._meta.concrete_model\n1694         ):\n1695             if model._meta.auto_created:\n1696 \n1697                 def _get_field_name(model):\n1698                     for field in model._meta.auto_created._meta.many_to_many:\n1699                         if field.remote_field.through is model:\n1700                             return field.name\n1701 \n1702                 opts = model._meta.auto_created._meta\n1703                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1704             else:\n1705                 clashing_obj = model._meta.label\n1706             if settings.DATABASE_ROUTERS:\n1707                 error_class, error_id = checks.Warning, \"fields.W344\"\n1708                 error_hint = (\n1709                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1710                     \"that the table of %r is correctly routed to a separate \"\n1711                     \"database.\" % clashing_obj\n1712                 )\n1713             else:\n1714                 error_class, error_id = checks.Error, \"fields.E340\"\n1715                 error_hint = None\n1716             return [\n1717                 error_class(\n1718                     \"The field's intermediary table '%s' clashes with the \"\n1719                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1720                     obj=self,\n1721                     hint=error_hint,\n1722                     id=error_id,\n1723                 )\n1724             ]\n1725         return []\n1726 \n1727     def deconstruct(self):\n1728         name, path, args, kwargs = super().deconstruct()\n1729         # Handle the simpler arguments.\n1730         if self.db_table is not None:\n1731             kwargs[\"db_table\"] = self.db_table\n1732         if self.remote_field.db_constraint is not True:\n1733             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1734         # Lowercase model names as they should be treated as case-insensitive.\n1735         if isinstance(self.remote_field.model, str):\n1736             if \".\" in self.remote_field.model:\n1737                 app_label, model_name = self.remote_field.model.split(\".\")\n1738                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1739             else:\n1740                 kwargs[\"to\"] = self.remote_field.model.lower()\n1741         else:\n1742             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1743         if getattr(self.remote_field, \"through\", None) is not None:\n1744             if isinstance(self.remote_field.through, str):\n1745                 kwargs[\"through\"] = self.remote_field.through\n1746             elif not self.remote_field.through._meta.auto_created:\n1747                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1748         # If swappable is True, then see if we're actually pointing to the target\n1749         # of a swap.\n1750         swappable_setting = self.swappable_setting\n1751         if swappable_setting is not None:\n1752             # If it's already a settings reference, error.\n1753             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1754                 if kwargs[\"to\"].setting_name != swappable_setting:\n1755                     raise ValueError(\n1756                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1757                         \"model that is swapped in place of more than one model \"\n1758                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1759                     )\n1760 \n1761             kwargs[\"to\"] = SettingsReference(\n1762                 kwargs[\"to\"],\n1763                 swappable_setting,\n1764             )\n1765         return name, path, args, kwargs\n1766 \n1767     def _get_path_info(self, direct=False, filtered_relation=None):\n1768         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1769         int_model = self.remote_field.through\n1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1772         if direct:\n1773             join1infos = linkfield1.reverse_path_infos\n1774             if filtered_relation:\n1775                 join2infos = linkfield2.get_path_info(filtered_relation)\n1776             else:\n1777                 join2infos = linkfield2.path_infos\n1778         else:\n1779             join1infos = linkfield2.reverse_path_infos\n1780             if filtered_relation:\n1781                 join2infos = linkfield1.get_path_info(filtered_relation)\n1782             else:\n1783                 join2infos = linkfield1.path_infos\n1784         # Get join infos between the last model of join 1 and the first model\n1785         # of join 2. Assume the only reason these may differ is due to model\n1786         # inheritance.\n1787         join1_final = join1infos[-1].to_opts\n1788         join2_initial = join2infos[0].from_opts\n1789         if join1_final is join2_initial:\n1790             intermediate_infos = []\n1791         elif issubclass(join1_final.model, join2_initial.model):\n1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1793         else:\n1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1795 \n1796         return [*join1infos, *intermediate_infos, *join2infos]\n1797 \n1798     def get_path_info(self, filtered_relation=None):\n1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1800 \n1801     @cached_property\n1802     def path_infos(self):\n1803         return self.get_path_info()\n1804 \n1805     def get_reverse_path_info(self, filtered_relation=None):\n1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1807 \n1808     @cached_property\n1809     def reverse_path_infos(self):\n1810         return self.get_reverse_path_info()\n1811 \n1812     def _get_m2m_db_table(self, opts):\n1813         \"\"\"\n1814         Function that can be curried to provide the m2m table name for this\n1815         relation.\n1816         \"\"\"\n1817         if self.remote_field.through is not None:\n1818             return self.remote_field.through._meta.db_table\n1819         elif self.db_table:\n1820             return self.db_table\n1821         else:\n1822             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1824 \n1825     def _get_m2m_attr(self, related, attr):\n1826         \"\"\"\n1827         Function that can be curried to provide the source accessor or DB\n1828         column name for the m2m table.\n1829         \"\"\"\n1830         cache_attr = \"_m2m_%s_cache\" % attr\n1831         if hasattr(self, cache_attr):\n1832             return getattr(self, cache_attr)\n1833         if self.remote_field.through_fields is not None:\n1834             link_field_name = self.remote_field.through_fields[0]\n1835         else:\n1836             link_field_name = None\n1837         for f in self.remote_field.through._meta.fields:\n1838             if (\n1839                 f.is_relation\n1840                 and f.remote_field.model == related.related_model\n1841                 and (link_field_name is None or link_field_name == f.name)\n1842             ):\n1843                 setattr(self, cache_attr, getattr(f, attr))\n1844                 return getattr(self, cache_attr)\n1845 \n1846     def _get_m2m_reverse_attr(self, related, attr):\n1847         \"\"\"\n1848         Function that can be curried to provide the related accessor or DB\n1849         column name for the m2m table.\n1850         \"\"\"\n1851         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1852         if hasattr(self, cache_attr):\n1853             return getattr(self, cache_attr)\n1854         found = False\n1855         if self.remote_field.through_fields is not None:\n1856             link_field_name = self.remote_field.through_fields[1]\n1857         else:\n1858             link_field_name = None\n1859         for f in self.remote_field.through._meta.fields:\n1860             if f.is_relation and f.remote_field.model == related.model:\n1861                 if link_field_name is None and related.related_model == related.model:\n1862                     # If this is an m2m-intermediate to self,\n1863                     # the first foreign key you find will be\n1864                     # the source column. Keep searching for\n1865                     # the second foreign key.\n1866                     if found:\n1867                         setattr(self, cache_attr, getattr(f, attr))\n1868                         break\n1869                     else:\n1870                         found = True\n1871                 elif link_field_name is None or link_field_name == f.name:\n1872                     setattr(self, cache_attr, getattr(f, attr))\n1873                     break\n1874         return getattr(self, cache_attr)\n1875 \n1876     def contribute_to_class(self, cls, name, **kwargs):\n1877         # To support multiple relations to self, it's useful to have a non-None\n1878         # related name on symmetrical relations for internal reasons. The\n1879         # concept doesn't make a lot of sense externally (\"you want me to\n1880         # specify *what* on my non-reversible relation?!\"), so we set it up\n1881         # automatically. The funky name reduces the chance of an accidental\n1882         # clash.\n1883         if self.remote_field.symmetrical and (\n1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1885             or self.remote_field.model == cls._meta.object_name\n1886         ):\n1887             self.remote_field.related_name = \"%s_rel_+\" % name\n1888         elif self.remote_field.is_hidden():\n1889             # If the backwards relation is disabled, replace the original\n1890             # related_name with one generated from the m2m field name. Django\n1891             # still uses backwards relations internally and we need to avoid\n1892             # clashes between multiple m2m fields with related_name == '+'.\n1893             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1894                 cls._meta.app_label,\n1895                 cls.__name__.lower(),\n1896                 name,\n1897             )\n1898 \n1899         super().contribute_to_class(cls, name, **kwargs)\n1900 \n1901         # The intermediate m2m model is not auto created if:\n1902         #  1) There is a manually specified intermediate, or\n1903         #  2) The class owning the m2m field is abstract.\n1904         #  3) The class owning the m2m field has been swapped out.\n1905         if not cls._meta.abstract:\n1906             if self.remote_field.through:\n1907 \n1908                 def resolve_through_model(_, model, field):\n1909                     field.remote_field.through = model\n1910 \n1911                 lazy_related_operation(\n1912                     resolve_through_model, cls, self.remote_field.through, field=self\n1913                 )\n1914             elif not cls._meta.swapped:\n1915                 self.remote_field.through = create_many_to_many_intermediary_model(\n1916                     self, cls\n1917                 )\n1918 \n1919         # Add the descriptor for the m2m relation.\n1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1921 \n1922         # Set up the accessor for the m2m table name for the relation.\n1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1924 \n1925     def contribute_to_related_class(self, cls, related):\n1926         # Internal M2Ms (i.e., those with a related name ending with '+')\n1927         # and swapped models don't get a related descriptor.\n1928         if (\n1929             not self.remote_field.is_hidden()\n1930             and not related.related_model._meta.swapped\n1931         ):\n1932             setattr(\n1933                 cls,\n1934                 related.get_accessor_name(),\n1935                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1936             )\n1937 \n1938         # Set up the accessors for the column names on the m2m table.\n1939         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1941 \n1942         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1943         self.m2m_reverse_field_name = partial(\n1944             self._get_m2m_reverse_attr, related, \"name\"\n1945         )\n1946 \n1947         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1949         get_m2m_reverse_rel = partial(\n1950             self._get_m2m_reverse_attr, related, \"remote_field\"\n1951         )\n1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1953 \n1954     def set_attributes_from_rel(self):\n1955         pass\n1956 \n1957     def value_from_object(self, obj):\n1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1959 \n1960     def save_form_data(self, instance, data):\n1961         getattr(instance, self.attname).set(data)\n1962 \n1963     def formfield(self, *, using=None, **kwargs):\n1964         defaults = {\n1965             \"form_class\": forms.ModelMultipleChoiceField,\n1966             \"queryset\": self.remote_field.model._default_manager.using(using),\n1967             **kwargs,\n1968         }\n1969         # If initial is passed in, it's a list of related objects, but the\n1970         # MultipleChoiceField takes a list of IDs.\n1971         if defaults.get(\"initial\") is not None:\n1972             initial = defaults[\"initial\"]\n1973             if callable(initial):\n1974                 initial = initial()\n1975             defaults[\"initial\"] = [i.pk for i in initial]\n1976         return super().formfield(**defaults)\n1977 \n1978     def db_check(self, connection):\n1979         return None\n1980 \n1981     def db_type(self, connection):\n1982         # A ManyToManyField is not represented by a single column,\n1983         # so return None.\n1984         return None\n1985 \n1986     def db_parameters(self, connection):\n1987         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Within this file, particularly in the sections that define or manipulate 'ForeignKey' fields, additional logic is required to check the 'db_collation' of the referenced field (if any) and apply it to the 'ForeignKey' field during migrations. The intention is for foreign keys to maintain database consistency by automatically adopting the 'db_collation' of their referenced primary key fields when migrations are generated, thus preventing collation mismatch errors. This adjustment should ensure that fields referencing custom or altered collation settings adhere to those settings across all related tables, respecting database constraints."
    }
]