[
    {
        "rel_file_path": "django/db/models/fields/files.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/fields/files.py",
        "start": 1,
        "end": 481,
        "class_name": null,
        "method_name": null,
        "code": "1 import datetime\n2 import posixpath\n3 \n4 from django import forms\n5 from django.core import checks\n6 from django.core.files.base import File\n7 from django.core.files.images import ImageFile\n8 from django.core.files.storage import Storage, default_storage\n9 from django.core.files.utils import validate_file_name\n10 from django.db.models import signals\n11 from django.db.models.fields import Field\n12 from django.db.models.query_utils import DeferredAttribute\n13 from django.utils.translation import gettext_lazy as _\n14 \n15 \n16 class FieldFile(File):\n17     def __init__(self, instance, field, name):\n18         super().__init__(None, name)\n19         self.instance = instance\n20         self.field = field\n21         self.storage = field.storage\n22         self._committed = True\n23 \n24     def __eq__(self, other):\n25         # Older code may be expecting FileField values to be simple strings.\n26         # By overriding the == operator, it can remain backwards compatibility.\n27         if hasattr(other, 'name'):\n28             return self.name == other.name\n29         return self.name == other\n30 \n31     def __hash__(self):\n32         return hash(self.name)\n33 \n34     # The standard File contains most of the necessary properties, but\n35     # FieldFiles can be instantiated without a name, so that needs to\n36     # be checked for here.\n37 \n38     def _require_file(self):\n39         if not self:\n40             raise ValueError(\"The '%s' attribute has no file associated with it.\" % self.field.name)\n41 \n42     def _get_file(self):\n43         self._require_file()\n44         if getattr(self, '_file', None) is None:\n45             self._file = self.storage.open(self.name, 'rb')\n46         return self._file\n47 \n48     def _set_file(self, file):\n49         self._file = file\n50 \n51     def _del_file(self):\n52         del self._file\n53 \n54     file = property(_get_file, _set_file, _del_file)\n55 \n56     @property\n57     def path(self):\n58         self._require_file()\n59         return self.storage.path(self.name)\n60 \n61     @property\n62     def url(self):\n63         self._require_file()\n64         return self.storage.url(self.name)\n65 \n66     @property\n67     def size(self):\n68         self._require_file()\n69         if not self._committed:\n70             return self.file.size\n71         return self.storage.size(self.name)\n72 \n73     def open(self, mode='rb'):\n74         self._require_file()\n75         if getattr(self, '_file', None) is None:\n76             self.file = self.storage.open(self.name, mode)\n77         else:\n78             self.file.open(mode)\n79         return self\n80     # open() doesn't alter the file's contents, but it does reset the pointer\n81     open.alters_data = True\n82 \n83     # In addition to the standard File API, FieldFiles have extra methods\n84     # to further manipulate the underlying file, as well as update the\n85     # associated model instance.\n86 \n87     def save(self, name, content, save=True):\n88         name = self.field.generate_filename(self.instance, name)\n89         self.name = self.storage.save(name, content, max_length=self.field.max_length)\n90         setattr(self.instance, self.field.attname, self.name)\n91         self._committed = True\n92 \n93         # Save the object because it has changed, unless save is False\n94         if save:\n95             self.instance.save()\n96     save.alters_data = True\n97 \n98     def delete(self, save=True):\n99         if not self:\n100             return\n101         # Only close the file if it's already open, which we know by the\n102         # presence of self._file\n103         if hasattr(self, '_file'):\n104             self.close()\n105             del self.file\n106 \n107         self.storage.delete(self.name)\n108 \n109         self.name = None\n110         setattr(self.instance, self.field.attname, self.name)\n111         self._committed = False\n112 \n113         if save:\n114             self.instance.save()\n115     delete.alters_data = True\n116 \n117     @property\n118     def closed(self):\n119         file = getattr(self, '_file', None)\n120         return file is None or file.closed\n121 \n122     def close(self):\n123         file = getattr(self, '_file', None)\n124         if file is not None:\n125             file.close()\n126 \n127     def __getstate__(self):\n128         # FieldFile needs access to its associated model field, an instance and\n129         # the file's name. Everything else will be restored later, by\n130         # FileDescriptor below.\n131         return {\n132             'name': self.name,\n133             'closed': False,\n134             '_committed': True,\n135             '_file': None,\n136             'instance': self.instance,\n137             'field': self.field,\n138         }\n139 \n140     def __setstate__(self, state):\n141         self.__dict__.update(state)\n142         self.storage = self.field.storage\n143 \n144 \n145 class FileDescriptor(DeferredAttribute):\n146     \"\"\"\n147     The descriptor for the file attribute on the model instance. Return a\n148     FieldFile when accessed so you can write code like::\n149 \n150         >>> from myapp.models import MyModel\n151         >>> instance = MyModel.objects.get(pk=1)\n152         >>> instance.file.size\n153 \n154     Assign a file object on assignment so you can do::\n155 \n156         >>> with open('/path/to/hello.world') as f:\n157         ...     instance.file = File(f)\n158     \"\"\"\n159     def __get__(self, instance, cls=None):\n160         if instance is None:\n161             return self\n162 \n163         # This is slightly complicated, so worth an explanation.\n164         # instance.file`needs to ultimately return some instance of `File`,\n165         # probably a subclass. Additionally, this returned object needs to have\n166         # the FieldFile API so that users can easily do things like\n167         # instance.file.path and have that delegated to the file storage engine.\n168         # Easy enough if we're strict about assignment in __set__, but if you\n169         # peek below you can see that we're not. So depending on the current\n170         # value of the field we have to dynamically construct some sort of\n171         # \"thing\" to return.\n172 \n173         # The instance dict contains whatever was originally assigned\n174         # in __set__.\n175         file = super().__get__(instance, cls)\n176 \n177         # If this value is a string (instance.file = \"path/to/file\") or None\n178         # then we simply wrap it with the appropriate attribute class according\n179         # to the file field. [This is FieldFile for FileFields and\n180         # ImageFieldFile for ImageFields; it's also conceivable that user\n181         # subclasses might also want to subclass the attribute class]. This\n182         # object understands how to convert a path to a file, and also how to\n183         # handle None.\n184         if isinstance(file, str) or file is None:\n185             attr = self.field.attr_class(instance, self.field, file)\n186             instance.__dict__[self.field.attname] = attr\n187 \n188         # Other types of files may be assigned as well, but they need to have\n189         # the FieldFile interface added to them. Thus, we wrap any other type of\n190         # File inside a FieldFile (well, the field's attr_class, which is\n191         # usually FieldFile).\n192         elif isinstance(file, File) and not isinstance(file, FieldFile):\n193             file_copy = self.field.attr_class(instance, self.field, file.name)\n194             file_copy.file = file\n195             file_copy._committed = False\n196             instance.__dict__[self.field.attname] = file_copy\n197 \n198         # Finally, because of the (some would say boneheaded) way pickle works,\n199         # the underlying FieldFile might not actually itself have an associated\n200         # file. So we need to reset the details of the FieldFile in those cases.\n201         elif isinstance(file, FieldFile) and not hasattr(file, 'field'):\n202             file.instance = instance\n203             file.field = self.field\n204             file.storage = self.field.storage\n205 \n206         # Make sure that the instance is correct.\n207         elif isinstance(file, FieldFile) and instance is not file.instance:\n208             file.instance = instance\n209 \n210         # That was fun, wasn't it?\n211         return instance.__dict__[self.field.attname]\n212 \n213     def __set__(self, instance, value):\n214         instance.__dict__[self.field.attname] = value\n215 \n216 \n217 class FileField(Field):\n218 \n219     # The class to wrap instance attributes in. Accessing the file object off\n220     # the instance will always return an instance of attr_class.\n221     attr_class = FieldFile\n222 \n223     # The descriptor to use for accessing the attribute off of the class.\n224     descriptor_class = FileDescriptor\n225 \n226     description = _(\"File\")\n227 \n228     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):\n229         self._primary_key_set_explicitly = 'primary_key' in kwargs\n230 \n231         self.storage = storage or default_storage\n232         if callable(self.storage):\n233             # Hold a reference to the callable for deconstruct().\n234             self._storage_callable = self.storage\n235             self.storage = self.storage()\n236             if not isinstance(self.storage, Storage):\n237                 raise TypeError(\n238                     \"%s.storage must be a subclass/instance of %s.%s\"\n239                     % (self.__class__.__qualname__, Storage.__module__, Storage.__qualname__)\n240                 )\n241         self.upload_to = upload_to\n242 \n243         kwargs.setdefault('max_length', 100)\n244         super().__init__(verbose_name, name, **kwargs)\n245 \n246     def check(self, **kwargs):\n247         return [\n248             *super().check(**kwargs),\n249             *self._check_primary_key(),\n250             *self._check_upload_to(),\n251         ]\n252 \n253     def _check_primary_key(self):\n254         if self._primary_key_set_explicitly:\n255             return [\n256                 checks.Error(\n257                     \"'primary_key' is not a valid argument for a %s.\" % self.__class__.__name__,\n258                     obj=self,\n259                     id='fields.E201',\n260                 )\n261             ]\n262         else:\n263             return []\n264 \n265     def _check_upload_to(self):\n266         if isinstance(self.upload_to, str) and self.upload_to.startswith('/'):\n267             return [\n268                 checks.Error(\n269                     \"%s's 'upload_to' argument must be a relative path, not an \"\n270                     \"absolute path.\" % self.__class__.__name__,\n271                     obj=self,\n272                     id='fields.E202',\n273                     hint='Remove the leading slash.',\n274                 )\n275             ]\n276         else:\n277             return []\n278 \n279     def deconstruct(self):\n280         name, path, args, kwargs = super().deconstruct()\n281         if kwargs.get(\"max_length\") == 100:\n282             del kwargs[\"max_length\"]\n283         kwargs['upload_to'] = self.upload_to\n284         if self.storage is not default_storage:\n285             kwargs['storage'] = getattr(self, '_storage_callable', self.storage)\n286         return name, path, args, kwargs\n287 \n288     def get_internal_type(self):\n289         return \"FileField\"\n290 \n291     def get_prep_value(self, value):\n292         value = super().get_prep_value(value)\n293         # Need to convert File objects provided via a form to string for database insertion\n294         if value is None:\n295             return None\n296         return str(value)\n297 \n298     def pre_save(self, model_instance, add):\n299         file = super().pre_save(model_instance, add)\n300         if file and not file._committed:\n301             # Commit the file to storage prior to saving the model\n302             file.save(file.name, file.file, save=False)\n303         return file\n304 \n305     def contribute_to_class(self, cls, name, **kwargs):\n306         super().contribute_to_class(cls, name, **kwargs)\n307         setattr(cls, self.attname, self.descriptor_class(self))\n308 \n309     def generate_filename(self, instance, filename):\n310         \"\"\"\n311         Apply (if callable) or prepend (if a string) upload_to to the filename,\n312         then delegate further processing of the name to the storage backend.\n313         Until the storage layer, all file paths are expected to be Unix style\n314         (with forward slashes).\n315         \"\"\"\n316         if callable(self.upload_to):\n317             filename = self.upload_to(instance, filename)\n318         else:\n319             dirname = datetime.datetime.now().strftime(str(self.upload_to))\n320             filename = posixpath.join(dirname, filename)\n321         filename = validate_file_name(filename, allow_relative_path=True)\n322         return self.storage.generate_filename(filename)\n323 \n324     def save_form_data(self, instance, data):\n325         # Important: None means \"no change\", other false value means \"clear\"\n326         # This subtle distinction (rather than a more explicit marker) is\n327         # needed because we need to consume values that are also sane for a\n328         # regular (non Model-) Form to find in its cleaned_data dictionary.\n329         if data is not None:\n330             # This value will be converted to str and stored in the\n331             # database, so leaving False as-is is not acceptable.\n332             setattr(instance, self.name, data or '')\n333 \n334     def formfield(self, **kwargs):\n335         return super().formfield(**{\n336             'form_class': forms.FileField,\n337             'max_length': self.max_length,\n338             **kwargs,\n339         })\n340 \n341 \n342 class ImageFileDescriptor(FileDescriptor):\n343     \"\"\"\n344     Just like the FileDescriptor, but for ImageFields. The only difference is\n345     assigning the width/height to the width_field/height_field, if appropriate.\n346     \"\"\"\n347     def __set__(self, instance, value):\n348         previous_file = instance.__dict__.get(self.field.attname)\n349         super().__set__(instance, value)\n350 \n351         # To prevent recalculating image dimensions when we are instantiating\n352         # an object from the database (bug #11084), only update dimensions if\n353         # the field had a value before this assignment.  Since the default\n354         # value for FileField subclasses is an instance of field.attr_class,\n355         # previous_file will only be None when we are called from\n356         # Model.__init__().  The ImageField.update_dimension_fields method\n357         # hooked up to the post_init signal handles the Model.__init__() cases.\n358         # Assignment happening outside of Model.__init__() will trigger the\n359         # update right here.\n360         if previous_file is not None:\n361             self.field.update_dimension_fields(instance, force=True)\n362 \n363 \n364 class ImageFieldFile(ImageFile, FieldFile):\n365     def delete(self, save=True):\n366         # Clear the image dimensions cache\n367         if hasattr(self, '_dimensions_cache'):\n368             del self._dimensions_cache\n369         super().delete(save)\n370 \n371 \n372 class ImageField(FileField):\n373     attr_class = ImageFieldFile\n374     descriptor_class = ImageFileDescriptor\n375     description = _(\"Image\")\n376 \n377     def __init__(self, verbose_name=None, name=None, width_field=None, height_field=None, **kwargs):\n378         self.width_field, self.height_field = width_field, height_field\n379         super().__init__(verbose_name, name, **kwargs)\n380 \n381     def check(self, **kwargs):\n382         return [\n383             *super().check(**kwargs),\n384             *self._check_image_library_installed(),\n385         ]\n386 \n387     def _check_image_library_installed(self):\n388         try:\n389             from PIL import Image  # NOQA\n390         except ImportError:\n391             return [\n392                 checks.Error(\n393                     'Cannot use ImageField because Pillow is not installed.',\n394                     hint=('Get Pillow at https://pypi.org/project/Pillow/ '\n395                           'or run command \"python -m pip install Pillow\".'),\n396                     obj=self,\n397                     id='fields.E210',\n398                 )\n399             ]\n400         else:\n401             return []\n402 \n403     def deconstruct(self):\n404         name, path, args, kwargs = super().deconstruct()\n405         if self.width_field:\n406             kwargs['width_field'] = self.width_field\n407         if self.height_field:\n408             kwargs['height_field'] = self.height_field\n409         return name, path, args, kwargs\n410 \n411     def contribute_to_class(self, cls, name, **kwargs):\n412         super().contribute_to_class(cls, name, **kwargs)\n413         # Attach update_dimension_fields so that dimension fields declared\n414         # after their corresponding image field don't stay cleared by\n415         # Model.__init__, see bug #11196.\n416         # Only run post-initialization dimension update on non-abstract models\n417         if not cls._meta.abstract:\n418             signals.post_init.connect(self.update_dimension_fields, sender=cls)\n419 \n420     def update_dimension_fields(self, instance, force=False, *args, **kwargs):\n421         \"\"\"\n422         Update field's width and height fields, if defined.\n423 \n424         This method is hooked up to model's post_init signal to update\n425         dimensions after instantiating a model instance.  However, dimensions\n426         won't be updated if the dimensions fields are already populated.  This\n427         avoids unnecessary recalculation when loading an object from the\n428         database.\n429 \n430         Dimensions can be forced to update with force=True, which is how\n431         ImageFileDescriptor.__set__ calls this method.\n432         \"\"\"\n433         # Nothing to update if the field doesn't have dimension fields or if\n434         # the field is deferred.\n435         has_dimension_fields = self.width_field or self.height_field\n436         if not has_dimension_fields or self.attname not in instance.__dict__:\n437             return\n438 \n439         # getattr will call the ImageFileDescriptor's __get__ method, which\n440         # coerces the assigned value into an instance of self.attr_class\n441         # (ImageFieldFile in this case).\n442         file = getattr(instance, self.attname)\n443 \n444         # Nothing to update if we have no file and not being forced to update.\n445         if not file and not force:\n446             return\n447 \n448         dimension_fields_filled = not(\n449             (self.width_field and not getattr(instance, self.width_field)) or\n450             (self.height_field and not getattr(instance, self.height_field))\n451         )\n452         # When both dimension fields have values, we are most likely loading\n453         # data from the database or updating an image field that already had\n454         # an image stored.  In the first case, we don't want to update the\n455         # dimension fields because we are already getting their values from the\n456         # database.  In the second case, we do want to update the dimensions\n457         # fields and will skip this return because force will be True since we\n458         # were called from ImageFileDescriptor.__set__.\n459         if dimension_fields_filled and not force:\n460             return\n461 \n462         # file should be an instance of ImageFieldFile or should be None.\n463         if file:\n464             width = file.width\n465             height = file.height\n466         else:\n467             # No file, so clear dimensions fields.\n468             width = None\n469             height = None\n470 \n471         # Update the width and height fields.\n472         if self.width_field:\n473             setattr(instance, self.width_field, width)\n474         if self.height_field:\n475             setattr(instance, self.height_field, height)\n476 \n477     def formfield(self, **kwargs):\n478         return super().formfield(**{\n479             'form_class': forms.ImageField,\n480             **kwargs,\n481         })\n",
        "intended_behavior": "Enhance the FileField processing logic to include validation for file names, specifically checking for and rejecting null bytes. This could be implemented as a method override in FileField or in any method responsible for handling the file name before it's used to create temporary files. The validation should throw a clear validation error if a null byte is detected, preventing the upload process from proceeding to the point where a temporary file is attempted to be created with a null byte in its name."
    },
    {
        "rel_file_path": "django/core/files/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/files/utils.py",
        "start": 1,
        "end": 78,
        "class_name": null,
        "method_name": null,
        "code": "1 import os\n2 import pathlib\n3 \n4 from django.core.exceptions import SuspiciousFileOperation\n5 \n6 \n7 def validate_file_name(name, allow_relative_path=False):\n8     # Remove potentially dangerous names\n9     if os.path.basename(name) in {'', '.', '..'}:\n10         raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)\n11 \n12     if allow_relative_path:\n13         # Use PurePosixPath() because this branch is checked only in\n14         # FileField.generate_filename() where all file paths are expected to be\n15         # Unix style (with forward slashes).\n16         path = pathlib.PurePosixPath(name)\n17         if path.is_absolute() or '..' in path.parts:\n18             raise SuspiciousFileOperation(\n19                 \"Detected path traversal attempt in '%s'\" % name\n20             )\n21     elif name != os.path.basename(name):\n22         raise SuspiciousFileOperation(\"File name '%s' includes path elements\" % name)\n23 \n24     return name\n25 \n26 \n27 class FileProxyMixin:\n28     \"\"\"\n29     A mixin class used to forward file methods to an underlaying file\n30     object.  The internal file object has to be called \"file\"::\n31 \n32         class FileProxy(FileProxyMixin):\n33             def __init__(self, file):\n34                 self.file = file\n35     \"\"\"\n36 \n37     encoding = property(lambda self: self.file.encoding)\n38     fileno = property(lambda self: self.file.fileno)\n39     flush = property(lambda self: self.file.flush)\n40     isatty = property(lambda self: self.file.isatty)\n41     newlines = property(lambda self: self.file.newlines)\n42     read = property(lambda self: self.file.read)\n43     readinto = property(lambda self: self.file.readinto)\n44     readline = property(lambda self: self.file.readline)\n45     readlines = property(lambda self: self.file.readlines)\n46     seek = property(lambda self: self.file.seek)\n47     tell = property(lambda self: self.file.tell)\n48     truncate = property(lambda self: self.file.truncate)\n49     write = property(lambda self: self.file.write)\n50     writelines = property(lambda self: self.file.writelines)\n51 \n52     @property\n53     def closed(self):\n54         return not self.file or self.file.closed\n55 \n56     def readable(self):\n57         if self.closed:\n58             return False\n59         if hasattr(self.file, 'readable'):\n60             return self.file.readable()\n61         return True\n62 \n63     def writable(self):\n64         if self.closed:\n65             return False\n66         if hasattr(self.file, 'writable'):\n67             return self.file.writable()\n68         return 'w' in getattr(self.file, 'mode', '')\n69 \n70     def seekable(self):\n71         if self.closed:\n72             return False\n73         if hasattr(self.file, 'seekable'):\n74             return self.file.seekable()\n75         return True\n76 \n77     def __iter__(self):\n78         return iter(self.file)\n",
        "intended_behavior": "Add or modify a utility function to sanitize file names by removing or replacing null bytes when file names are processed during the upload. This utility function should be called wherever file names are handled or stored, especially before creating temporary files, ensuring that no part of the system attempts to handle file names that contain null bytes."
    }
]