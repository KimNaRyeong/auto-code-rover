[
    {
        "rel_file_path": "sphinx/ext/inheritance_diagram.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__7.2/sphinx/ext/inheritance_diagram.py",
        "start": 1,
        "end": 480,
        "class_name": null,
        "method_name": null,
        "code": "1 r\"\"\"Defines a docutils directive for inserting inheritance diagrams.\n2 \n3 Provide the directive with one or more classes or modules (separated\n4 by whitespace).  For modules, all of the classes in that module will\n5 be used.\n6 \n7 Example::\n8 \n9    Given the following classes:\n10 \n11    class A: pass\n12    class B(A): pass\n13    class C(A): pass\n14    class D(B, C): pass\n15    class E(B): pass\n16 \n17    .. inheritance-diagram: D E\n18 \n19    Produces a graph like the following:\n20 \n21                A\n22               / \\\n23              B   C\n24             / \\ /\n25            E   D\n26 \n27 The graph is inserted as a PNG+image map into HTML and a PDF in\n28 LaTeX.\n29 \"\"\"\n30 \n31 from __future__ import annotations\n32 \n33 import builtins\n34 import hashlib\n35 import inspect\n36 import re\n37 from collections.abc import Iterable\n38 from importlib import import_module\n39 from typing import Any, cast\n40 \n41 from docutils import nodes\n42 from docutils.nodes import Node\n43 from docutils.parsers.rst import directives\n44 \n45 import sphinx\n46 from sphinx import addnodes\n47 from sphinx.application import Sphinx\n48 from sphinx.environment import BuildEnvironment\n49 from sphinx.ext.graphviz import (\n50     figure_wrapper,\n51     graphviz,\n52     render_dot_html,\n53     render_dot_latex,\n54     render_dot_texinfo,\n55 )\n56 from sphinx.util.docutils import SphinxDirective\n57 from sphinx.util.typing import OptionSpec\n58 from sphinx.writers.html import HTML5Translator\n59 from sphinx.writers.latex import LaTeXTranslator\n60 from sphinx.writers.texinfo import TexinfoTranslator\n61 \n62 module_sig_re = re.compile(r'''^(?:([\\w.]*)\\.)?  # module names\n63                            (\\w+)  \\s* $          # class/final module name\n64                            ''', re.VERBOSE)\n65 \n66 \n67 py_builtins = [obj for obj in vars(builtins).values()\n68                if inspect.isclass(obj)]\n69 \n70 \n71 def try_import(objname: str) -> Any:\n72     \"\"\"Import a object or module using *name* and *currentmodule*.\n73     *name* should be a relative name from *currentmodule* or\n74     a fully-qualified name.\n75 \n76     Returns imported object or module.  If failed, returns None value.\n77     \"\"\"\n78     try:\n79         return import_module(objname)\n80     except TypeError:\n81         # Relative import\n82         return None\n83     except ImportError:\n84         matched = module_sig_re.match(objname)\n85 \n86         if not matched:\n87             return None\n88 \n89         modname, attrname = matched.groups()\n90 \n91         if modname is None:\n92             return None\n93         try:\n94             module = import_module(modname)\n95             return getattr(module, attrname, None)\n96         except ImportError:\n97             return None\n98 \n99 \n100 def import_classes(name: str, currmodule: str) -> Any:\n101     \"\"\"Import a class using its fully-qualified *name*.\"\"\"\n102     target = None\n103 \n104     # import class or module using currmodule\n105     if currmodule:\n106         target = try_import(currmodule + '.' + name)\n107 \n108     # import class or module without currmodule\n109     if target is None:\n110         target = try_import(name)\n111 \n112     if target is None:\n113         raise InheritanceException(\n114             'Could not import class or module %r specified for '\n115             'inheritance diagram' % name)\n116 \n117     if inspect.isclass(target):\n118         # If imported object is a class, just return it\n119         return [target]\n120     elif inspect.ismodule(target):\n121         # If imported object is a module, return classes defined on it\n122         classes = []\n123         for cls in target.__dict__.values():\n124             if inspect.isclass(cls) and cls.__module__ == target.__name__:\n125                 classes.append(cls)\n126         return classes\n127     raise InheritanceException('%r specified for inheritance diagram is '\n128                                'not a class or module' % name)\n129 \n130 \n131 class InheritanceException(Exception):\n132     pass\n133 \n134 \n135 class InheritanceGraph:\n136     \"\"\"\n137     Given a list of classes, determines the set of classes that they inherit\n138     from all the way to the root \"object\", and then is able to generate a\n139     graphviz dot graph from them.\n140     \"\"\"\n141     def __init__(self, class_names: list[str], currmodule: str, show_builtins: bool = False,\n142                  private_bases: bool = False, parts: int = 0,\n143                  aliases: dict[str, str] | None = None, top_classes: list[Any] = [],\n144                  ) -> None:\n145         \"\"\"*class_names* is a list of child classes to show bases from.\n146 \n147         If *show_builtins* is True, then Python builtins will be shown\n148         in the graph.\n149         \"\"\"\n150         self.class_names = class_names\n151         classes = self._import_classes(class_names, currmodule)\n152         self.class_info = self._class_info(classes, show_builtins,\n153                                            private_bases, parts, aliases, top_classes)\n154         if not self.class_info:\n155             raise InheritanceException('No classes found for '\n156                                        'inheritance diagram')\n157 \n158     def _import_classes(self, class_names: list[str], currmodule: str) -> list[Any]:\n159         \"\"\"Import a list of classes.\"\"\"\n160         classes: list[Any] = []\n161         for name in class_names:\n162             classes.extend(import_classes(name, currmodule))\n163         return classes\n164 \n165     def _class_info(self, classes: list[Any], show_builtins: bool, private_bases: bool,\n166                     parts: int, aliases: dict[str, str] | None, top_classes: list[Any],\n167                     ) -> list[tuple[str, str, list[str], str]]:\n168         \"\"\"Return name and bases for all classes that are ancestors of\n169         *classes*.\n170 \n171         *parts* gives the number of dotted name parts to include in the\n172         displayed node names, from right to left. If given as a negative, the\n173         number of parts to drop from the left. A value of 0 displays the full\n174         dotted name. E.g. ``sphinx.ext.inheritance_diagram.InheritanceGraph``\n175         with ``parts=2`` or ``parts=-2`` gets displayed as\n176         ``inheritance_diagram.InheritanceGraph``, and as\n177         ``ext.inheritance_diagram.InheritanceGraph`` with ``parts=3`` or\n178         ``parts=-1``.\n179 \n180         *top_classes* gives the name(s) of the top most ancestor class to\n181         traverse to. Multiple names can be specified separated by comma.\n182         \"\"\"\n183         all_classes = {}\n184 \n185         def recurse(cls: Any) -> None:\n186             if not show_builtins and cls in py_builtins:\n187                 return\n188             if not private_bases and cls.__name__.startswith('_'):\n189                 return\n190 \n191             nodename = self.class_name(cls, parts, aliases)\n192             fullname = self.class_name(cls, 0, aliases)\n193 \n194             # Use first line of docstring as tooltip, if available\n195             tooltip = None\n196             try:\n197                 if cls.__doc__:\n198                     doc = cls.__doc__.strip().split(\"\\n\")[0]\n199                     if doc:\n200                         tooltip = '\"%s\"' % doc.replace('\"', '\\\\\"')\n201             except Exception:  # might raise AttributeError for strange classes\n202                 pass\n203 \n204             baselist: list[str] = []\n205             all_classes[cls] = (nodename, fullname, baselist, tooltip)\n206 \n207             if fullname in top_classes:\n208                 return\n209 \n210             for base in cls.__bases__:\n211                 if not show_builtins and base in py_builtins:\n212                     continue\n213                 if not private_bases and base.__name__.startswith('_'):\n214                     continue\n215                 baselist.append(self.class_name(base, parts, aliases))\n216                 if base not in all_classes:\n217                     recurse(base)\n218 \n219         for cls in classes:\n220             recurse(cls)\n221 \n222         return list(all_classes.values())  # type: ignore[arg-type]\n223 \n224     def class_name(\n225         self, cls: Any, parts: int = 0, aliases: dict[str, str] | None = None,\n226     ) -> str:\n227         \"\"\"Given a class object, return a fully-qualified name.\n228 \n229         This works for things I've tested in matplotlib so far, but may not be\n230         completely general.\n231         \"\"\"\n232         module = cls.__module__\n233         if module in ('__builtin__', 'builtins'):\n234             fullname = cls.__name__\n235         else:\n236             fullname = f'{module}.{cls.__qualname__}'\n237         if parts == 0:\n238             result = fullname\n239         else:\n240             name_parts = fullname.split('.')\n241             result = '.'.join(name_parts[-parts:])\n242         if aliases is not None and result in aliases:\n243             return aliases[result]\n244         return result\n245 \n246     def get_all_class_names(self) -> list[str]:\n247         \"\"\"Get all of the class names involved in the graph.\"\"\"\n248         return [fullname for (_, fullname, _, _) in self.class_info]\n249 \n250     # These are the default attrs for graphviz\n251     default_graph_attrs = {\n252         'rankdir': 'LR',\n253         'size': '\"8.0, 12.0\"',\n254         'bgcolor': 'transparent',\n255     }\n256     default_node_attrs = {\n257         'shape': 'box',\n258         'fontsize': 10,\n259         'height': 0.25,\n260         'fontname': '\"Vera Sans, DejaVu Sans, Liberation Sans, '\n261                     'Arial, Helvetica, sans\"',\n262         'style': '\"setlinewidth(0.5),filled\"',\n263         'fillcolor': 'white',\n264     }\n265     default_edge_attrs = {\n266         'arrowsize': 0.5,\n267         'style': '\"setlinewidth(0.5)\"',\n268     }\n269 \n270     def _format_node_attrs(self, attrs: dict[str, Any]) -> str:\n271         return ','.join(['%s=%s' % x for x in sorted(attrs.items())])\n272 \n273     def _format_graph_attrs(self, attrs: dict[str, Any]) -> str:\n274         return ''.join(['%s=%s;\\n' % x for x in sorted(attrs.items())])\n275 \n276     def generate_dot(self, name: str, urls: dict[str, str] = {},\n277                      env: BuildEnvironment | None = None,\n278                      graph_attrs: dict = {}, node_attrs: dict = {}, edge_attrs: dict = {},\n279                      ) -> str:\n280         \"\"\"Generate a graphviz dot graph from the classes that were passed in\n281         to __init__.\n282 \n283         *name* is the name of the graph.\n284 \n285         *urls* is a dictionary mapping class names to HTTP URLs.\n286 \n287         *graph_attrs*, *node_attrs*, *edge_attrs* are dictionaries containing\n288         key/value pairs to pass on as graphviz properties.\n289         \"\"\"\n290         g_attrs = self.default_graph_attrs.copy()\n291         n_attrs = self.default_node_attrs.copy()\n292         e_attrs = self.default_edge_attrs.copy()\n293         g_attrs.update(graph_attrs)\n294         n_attrs.update(node_attrs)\n295         e_attrs.update(edge_attrs)\n296         if env:\n297             g_attrs.update(env.config.inheritance_graph_attrs)\n298             n_attrs.update(env.config.inheritance_node_attrs)\n299             e_attrs.update(env.config.inheritance_edge_attrs)\n300 \n301         res: list[str] = []\n302         res.append('digraph %s {\\n' % name)\n303         res.append(self._format_graph_attrs(g_attrs))\n304 \n305         for name, fullname, bases, tooltip in sorted(self.class_info):\n306             # Write the node\n307             this_node_attrs = n_attrs.copy()\n308             if fullname in urls:\n309                 this_node_attrs['URL'] = '\"%s\"' % urls[fullname]\n310                 this_node_attrs['target'] = '\"_top\"'\n311             if tooltip:\n312                 this_node_attrs['tooltip'] = tooltip\n313             res.append('  \"%s\" [%s];\\n' %\n314                        (name, self._format_node_attrs(this_node_attrs)))\n315 \n316             # Write the edges\n317             for base_name in bases:\n318                 res.append('  \"%s\" -> \"%s\" [%s];\\n' %\n319                            (base_name, name,\n320                             self._format_node_attrs(e_attrs)))\n321         res.append('}\\n')\n322         return ''.join(res)\n323 \n324 \n325 class inheritance_diagram(graphviz):\n326     \"\"\"\n327     A docutils node to use as a placeholder for the inheritance diagram.\n328     \"\"\"\n329     pass\n330 \n331 \n332 class InheritanceDiagram(SphinxDirective):\n333     \"\"\"\n334     Run when the inheritance_diagram directive is first encountered.\n335     \"\"\"\n336     has_content = False\n337     required_arguments = 1\n338     optional_arguments = 0\n339     final_argument_whitespace = True\n340     option_spec: OptionSpec = {\n341         'parts': int,\n342         'private-bases': directives.flag,\n343         'caption': directives.unchanged,\n344         'top-classes': directives.unchanged_required,\n345     }\n346 \n347     def run(self) -> list[Node]:\n348         node = inheritance_diagram()\n349         node.document = self.state.document\n350         class_names = self.arguments[0].split()\n351         class_role = self.env.get_domain('py').role('class')\n352         # Store the original content for use as a hash\n353         node['parts'] = self.options.get('parts', 0)\n354         node['content'] = ', '.join(class_names)\n355         node['top-classes'] = []\n356         for cls in self.options.get('top-classes', '').split(','):\n357             cls = cls.strip()\n358             if cls:\n359                 node['top-classes'].append(cls)\n360 \n361         # Create a graph starting with the list of classes\n362         try:\n363             graph = InheritanceGraph(\n364                 class_names, self.env.ref_context.get('py:module'),  # type: ignore[arg-type]\n365                 parts=node['parts'],\n366                 private_bases='private-bases' in self.options,\n367                 aliases=self.config.inheritance_alias,\n368                 top_classes=node['top-classes'])\n369         except InheritanceException as err:\n370             return [node.document.reporter.warning(err, line=self.lineno)]\n371 \n372         # Create xref nodes for each target of the graph's image map and\n373         # add them to the doc tree so that Sphinx can resolve the\n374         # references to real URLs later.  These nodes will eventually be\n375         # removed from the doctree after we're done with them.\n376         for name in graph.get_all_class_names():\n377             refnodes, x = class_role(  # type: ignore\n378                 'class', ':class:`%s`' % name, name, 0, self.state)  # type: ignore\n379             node.extend(refnodes)\n380         # Store the graph object so we can use it to generate the\n381         # dot file later\n382         node['graph'] = graph\n383 \n384         if 'caption' not in self.options:\n385             self.add_name(node)\n386             return [node]\n387         else:\n388             figure = figure_wrapper(self, node, self.options['caption'])\n389             self.add_name(figure)\n390             return [figure]\n391 \n392 \n393 def get_graph_hash(node: inheritance_diagram) -> str:\n394     encoded = (node['content'] + str(node['parts'])).encode()\n395     return hashlib.md5(encoded, usedforsecurity=False).hexdigest()[-10:]\n396 \n397 \n398 def html_visit_inheritance_diagram(self: HTML5Translator, node: inheritance_diagram) -> None:\n399     \"\"\"\n400     Output the graph for HTML.  This will insert a PNG with clickable\n401     image map.\n402     \"\"\"\n403     graph = node['graph']\n404 \n405     graph_hash = get_graph_hash(node)\n406     name = 'inheritance%s' % graph_hash\n407 \n408     # Create a mapping from fully-qualified class names to URLs.\n409     graphviz_output_format = self.builder.env.config.graphviz_output_format.upper()\n410     current_filename = self.builder.current_docname + self.builder.out_suffix\n411     urls = {}\n412     pending_xrefs = cast(Iterable[addnodes.pending_xref], node)\n413     for child in pending_xrefs:\n414         if child.get('refuri') is not None:\n415             if graphviz_output_format == 'SVG':\n416                 urls[child['reftitle']] = \"../\" + child.get('refuri')\n417             else:\n418                 urls[child['reftitle']] = child.get('refuri')\n419         elif child.get('refid') is not None:\n420             if graphviz_output_format == 'SVG':\n421                 urls[child['reftitle']] = '../' + current_filename + '#' + child.get('refid')\n422             else:\n423                 urls[child['reftitle']] = '#' + child.get('refid')\n424 \n425     dotcode = graph.generate_dot(name, urls, env=self.builder.env)\n426     render_dot_html(self, node, dotcode, {}, 'inheritance', 'inheritance',\n427                     alt='Inheritance diagram of ' + node['content'])\n428     raise nodes.SkipNode\n429 \n430 \n431 def latex_visit_inheritance_diagram(self: LaTeXTranslator, node: inheritance_diagram) -> None:\n432     \"\"\"\n433     Output the graph for LaTeX.  This will insert a PDF.\n434     \"\"\"\n435     graph = node['graph']\n436 \n437     graph_hash = get_graph_hash(node)\n438     name = 'inheritance%s' % graph_hash\n439 \n440     dotcode = graph.generate_dot(name, env=self.builder.env,\n441                                  graph_attrs={'size': '\"6.0,6.0\"'})\n442     render_dot_latex(self, node, dotcode, {}, 'inheritance')\n443     raise nodes.SkipNode\n444 \n445 \n446 def texinfo_visit_inheritance_diagram(self: TexinfoTranslator, node: inheritance_diagram,\n447                                       ) -> None:\n448     \"\"\"\n449     Output the graph for Texinfo.  This will insert a PNG.\n450     \"\"\"\n451     graph = node['graph']\n452 \n453     graph_hash = get_graph_hash(node)\n454     name = 'inheritance%s' % graph_hash\n455 \n456     dotcode = graph.generate_dot(name, env=self.builder.env,\n457                                  graph_attrs={'size': '\"6.0,6.0\"'})\n458     render_dot_texinfo(self, node, dotcode, {}, 'inheritance')\n459     raise nodes.SkipNode\n460 \n461 \n462 def skip(self: nodes.NodeVisitor, node: inheritance_diagram) -> None:\n463     raise nodes.SkipNode\n464 \n465 \n466 def setup(app: Sphinx) -> dict[str, Any]:\n467     app.setup_extension('sphinx.ext.graphviz')\n468     app.add_node(\n469         inheritance_diagram,\n470         latex=(latex_visit_inheritance_diagram, None),\n471         html=(html_visit_inheritance_diagram, None),\n472         text=(skip, None),\n473         man=(skip, None),\n474         texinfo=(texinfo_visit_inheritance_diagram, None))\n475     app.add_directive('inheritance-diagram', InheritanceDiagram)\n476     app.add_config_value('inheritance_graph_attrs', {}, False)\n477     app.add_config_value('inheritance_node_attrs', {}, False)\n478     app.add_config_value('inheritance_edge_attrs', {}, False)\n479     app.add_config_value('inheritance_alias', {}, False)\n480     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "The code modifications should ensure that URLs within SVG diagrams are correctly computed relative to the HTML document they are embedded in, not merely relative to the SVG file itself. This involves potentially adjusting the URL generation mechanism to account for the document's path within the project structure, ensuring links are accessible and direct to the correct targets when viewed in the built documentation."
    }
]