2025-10-15 03:35:19.828 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 03:35:23.142 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=251, output_tokens=12, cost=0.002870
2025-10-15 03:35:23.143 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 03:35:23.147 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:35:31.378 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=560, output_tokens=334, cost=0.015620
2025-10-15 03:35:31.429 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:35:33.670 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=688, output_tokens=48, cost=0.008320
2025-10-15 03:35:33.671 | DEBUG    | Extracted a valid json.
2025-10-15 03:35:33.671 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MigrationAutodetector\")",
        "search_method(\"makemigrations\")",
        "search_method(\"generate_migration_name\")"
    ],
    "bug_locations": []
}
2025-10-15 03:35:33.701 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 03:35:33.702 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 03:35:49.014 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1571, output_tokens=651, cost=0.035240
2025-10-15 03:35:49.029 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:36:00.338 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2438, output_tokens=418, cost=0.036920
2025-10-15 03:36:00.348 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:36:10.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=772, output_tokens=316, cost=0.017200
2025-10-15 03:36:10.277 | DEBUG    | Extracted a valid json.
2025-10-15 03:36:10.278 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MigrationWriter\")",
        "search_method_in_file(\"arrange_for_graph\", \"django/db/migrations/autodetector.py\")"
    ],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "MigrationAutodetector",
            "method": "arrange_for_graph",
            "intended_behavior": "This method should ensure that when determining the graph arrangement for new migrations, it accurately accounts for squashed migrations. Specifically, it should always sequence new migrations by considering the highest numbered migration as the starting point, including both squashed and non-squashed migrations. This would mean enhancing the logic to recognize when a squashed migration encompasses other migrations and ensuring the numbering of subsequent migrations reflects the true latest point in the migration graph."
        },
        {
            "file": "hypothetically `django/db/migrations/writer.py` or similar",
            "class": "MigrationWriter",
            "method": "",
            "intended_behavior": "If this class or its equivalent exists, and is responsible for naming and writing the migration file to disk, it should implement logic that correctly identifies the next sequential migration number in the context of existing and squashed migrations. This means either augmenting how migration names are generated to ensure they follow sequentially after the highest numbered migration (accounting for squashes), or ensuring that the interpretation of the current migration environment accurately reflects the squashed migrations."
        }
    ]
}
2025-10-15 03:36:10.315 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 03:36:10.316 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 03:36:29.659 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4314, output_tokens=698, cost=0.064080
2025-10-15 03:36:29.673 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:36:38.166 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5228, output_tokens=332, cost=0.062240
2025-10-15 03:36:38.173 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:36:43.454 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=686, output_tokens=188, cost=0.012500
2025-10-15 03:36:43.455 | DEBUG    | Extracted a valid json.
2025-10-15 03:36:43.456 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "MigrationAutodetector",
            "method": "arrange_for_graph",
            "intended_behavior": "The method should be refined to ensure it accurately accounts for both squashed and non-squashed migrations when calculating the sequence number for new migrations. Specifically, in the logic that determines the next number in the sequence, there should be an explicit check or consideration for squashed migrations. The method must ensure that the sequence number of a new migration reflects the total count of existing migrations, including those squashed, to avoid numbering collisions or sequencing errors. This might involve an enhancement in how the current leaf node (or nodes, in the case of squashed migrations) is determined and how the sequence numbers are incremented from there."
        }
    ]
}
2025-10-15 03:36:43.468 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>arrange_for_graph</method>
<code>
1253     def arrange_for_graph(self, changes, graph, migration_name=None):
1254         """
1255         Take a result from changes() and a MigrationGraph, and fix the names
1256         and dependencies of the changes so they extend the graph from the leaf
1257         nodes for each app.
1258         """
1259         leaves = graph.leaf_nodes()
1260         name_map = {}
1261         for app_label, migrations in list(changes.items()):
1262             if not migrations:
1263                 continue
1264             # Find the app label's current leaf node
1265             app_leaf = None
1266             for leaf in leaves:
1267                 if leaf[0] == app_label:
1268                     app_leaf = leaf
1269                     break
1270             # Do they want an initial migration for this app?
1271             if app_leaf is None and not self.questioner.ask_initial(app_label):
1272                 # They don't.
1273                 for migration in migrations:
1274                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1275                 del changes[app_label]
1276                 continue
1277             # Work out the next number in the sequence
1278             if app_leaf is None:
1279                 next_number = 1
1280             else:
1281                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1282             # Name each migration
1283             for i, migration in enumerate(migrations):
1284                 if i == 0 and app_leaf:
1285                     migration.dependencies.append(app_leaf)
1286                 new_name_parts = ['%04i' % next_number]
1287                 if migration_name:
1288                     new_name_parts.append(migration_name)
1289                 elif i == 0 and not app_leaf:
1290                     new_name_parts.append('initial')
1291                 else:
1292                     new_name_parts.append(migration.suggest_name()[:100])
1293                 new_name = '_'.join(new_name_parts)
1294                 name_map[(app_label, migration.name)] = (app_label, new_name)
1295                 next_number += 1
1296                 migration.name = new_name
1297         # Now fix dependencies
1298         for migrations in changes.values():
1299             for migration in migrations:
1300                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1301         return changes

</code><intended_behavior>The method should be refined to ensure it accurately accounts for both squashed and non-squashed migrations when calculating the sequence number for new migrations. Specifically, in the logic that determines the next number in the sequence, there should be an explicit check or consideration for squashed migrations. The method must ensure that the sequence number of a new migration reflects the total count of existing migrations, including those squashed, to avoid numbering collisions or sequencing errors. This might involve an enhancement in how the current leaf node (or nodes, in the case of squashed migrations) is determined and how the sequence numbers are incremented from there.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>None</method>
<code>
18 class MigrationAutodetector:
19     """
20     Take a pair of ProjectStates and compare them to see what the first would
21     need doing to make it match the second (the second usually being the
22     project's current state).
23 
24     Note that this naturally operates on entire projects at a time,
25     as it's likely that changes interact (for example, you can't
26     add a ForeignKey without having a migration to add the table it
27     depends on first). A user interface may offer single-app usage
28     if it wishes, with the caveat that it may not always be possible.
29     """
30 
31     def __init__(self, from_state, to_state, questioner=None):
32         self.from_state = from_state
33         self.to_state = to_state
34         self.questioner = questioner or MigrationQuestioner()
35         self.existing_apps = {app for app, model in from_state.models}
36 
37     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
38         """
39         Main entry point to produce a list of applicable changes.
40         Take a graph to base names on and an optional set of apps
41         to try and restrict to (restriction is not guaranteed)
42         """
43         changes = self._detect_changes(convert_apps, graph)
44         changes = self.arrange_for_graph(changes, graph, migration_name)
45         if trim_to_apps:
46             changes = self._trim_to_apps(changes, trim_to_apps)
47         return changes
48 
49     def deep_deconstruct(self, obj):
50         """
51         Recursive deconstruction for a field and its arguments.
52         Used for full comparison for rename/alter; sometimes a single-level
53         deconstruction will not compare correctly.
54         """
55         if isinstance(obj, list):
56             return [self.deep_deconstruct(value) for value in obj]
57         elif isinstance(obj, tuple):
58             return tuple(self.deep_deconstruct(value) for value in obj)
59         elif isinstance(obj, dict):
60             return {
61                 key: self.deep_deconstruct(value)
62                 for key, value in obj.items()
63             }
64         elif isinstance(obj, functools.partial):
65             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
66         elif isinstance(obj, COMPILED_REGEX_TYPE):
67             return RegexObject(obj)
68         elif isinstance(obj, type):
69             # If this is a type that implements 'deconstruct' as an instance method,
70             # avoid treating this as being deconstructible itself - see #22951
71             return obj
72         elif hasattr(obj, 'deconstruct'):
73             deconstructed = obj.deconstruct()
74             if isinstance(obj, models.Field):
75                 # we have a field which also returns a name
76                 deconstructed = deconstructed[1:]
77             path, args, kwargs = deconstructed
78             return (
79                 path,
80                 [self.deep_deconstruct(value) for value in args],
81                 {
82                     key: self.deep_deconstruct(value)
83                     for key, value in kwargs.items()
84                 },
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as
93         the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields.items()):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 del deconstruction[2]['to']
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for (app_label, model_name), model_state in self.from_state.models.items():
135             if not model_state.options.get('managed', True):
136                 self.old_unmanaged_keys.add((app_label, model_name))
137             elif app_label not in self.from_state.real_apps:
138                 if model_state.options.get('proxy'):
139                     self.old_proxy_keys.add((app_label, model_name))
140                 else:
141                     self.old_model_keys.add((app_label, model_name))
142 
143         for (app_label, model_name), model_state in self.to_state.models.items():
144             if not model_state.options.get('managed', True):
145                 self.new_unmanaged_keys.add((app_label, model_name))
146             elif (
147                 app_label not in self.from_state.real_apps or
148                 (convert_apps and app_label in convert_apps)
149             ):
150                 if model_state.options.get('proxy'):
151                     self.new_proxy_keys.add((app_label, model_name))
152                 else:
153                     self.new_model_keys.add((app_label, model_name))
154 
155         self.from_state.resolve_fields_and_relations()
156         self.to_state.resolve_fields_and_relations()
157 
158         # Renames have to come first
159         self.generate_renamed_models()
160 
161         # Prepare lists of fields and generate through model map
162         self._prepare_field_lists()
163         self._generate_through_model_map()
164 
165         # Generate non-rename model operations
166         self.generate_deleted_models()
167         self.generate_created_models()
168         self.generate_deleted_proxies()
169         self.generate_created_proxies()
170         self.generate_altered_options()
171         self.generate_altered_managers()
172 
173         # Create the altered indexes and store them in self.altered_indexes.
174         # This avoids the same computation in generate_removed_indexes()
175         # and generate_added_indexes().
176         self.create_altered_indexes()
177         self.create_altered_constraints()
178         # Generate index removal operations before field is removed
179         self.generate_removed_constraints()
180         self.generate_removed_indexes()
181         # Generate field operations
182         self.generate_renamed_fields()
183         self.generate_removed_fields()
184         self.generate_added_fields()
185         self.generate_altered_fields()
186         self.generate_altered_order_with_respect_to()
187         self.generate_altered_unique_together()
188         self.generate_altered_index_together()
189         self.generate_added_indexes()
190         self.generate_added_constraints()
191         self.generate_altered_db_table()
192 
193         self._sort_migrations()
194         self._build_migration_list(graph)
195         self._optimize_migrations()
196 
197         return self.migrations
198 
199     def _prepare_field_lists(self):
200         """
201         Prepare field lists and a list of the fields that used through models
202         in the old state so dependencies can be made from the through model
203         deletion to the field that uses it.
204         """
205         self.kept_model_keys = self.old_model_keys & self.new_model_keys
206         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
207         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
208         self.through_users = {}
209         self.old_field_keys = {
210             (app_label, model_name, field_name)
211             for app_label, model_name in self.kept_model_keys
212             for field_name in self.from_state.models[
213                 app_label,
214                 self.renamed_models.get((app_label, model_name), model_name)
215             ].fields
216         }
217         self.new_field_keys = {
218             (app_label, model_name, field_name)
219             for app_label, model_name in self.kept_model_keys
220             for field_name in self.to_state.models[app_label, model_name].fields
221         }
222 
223     def _generate_through_model_map(self):
224         """Through model map generation."""
225         for app_label, model_name in sorted(self.old_model_keys):
226             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
227             old_model_state = self.from_state.models[app_label, old_model_name]
228             for field_name, field in old_model_state.fields.items():
229                 if hasattr(field, 'remote_field') and getattr(field.remote_field, 'through', None):
230                     through_key = resolve_relation(field.remote_field.through, app_label, model_name)
231                     self.through_users[through_key] = (app_label, old_model_name, field_name)
232 
233     @staticmethod
234     def _resolve_dependency(dependency):
235         """
236         Return the resolved dependency and a boolean denoting whether or not
237         it was swappable.
238         """
239         if dependency[0] != '__setting__':
240             return dependency, False
241         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
242         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
243 
244     def _build_migration_list(self, graph=None):
245         """
246         Chop the lists of operations up into migrations with dependencies on
247         each other. Do this by going through an app's list of operations until
248         one is found that has an outgoing dependency that isn't in another
249         app's migration yet (hasn't been chopped off its list). Then chop off
250         the operations before it into a migration and move onto the next app.
251         If the loops completes without doing anything, there's a circular
252         dependency (which _should_ be impossible as the operations are
253         all split at this point so they can't depend and be depended on).
254         """
255         self.migrations = {}
256         num_ops = sum(len(x) for x in self.generated_operations.values())
257         chop_mode = False
258         while num_ops:
259             # On every iteration, we step through all the apps and see if there
260             # is a completed set of operations.
261             # If we find that a subset of the operations are complete we can
262             # try to chop it off from the rest and continue, but we only
263             # do this if we've already been through the list once before
264             # without any chopping and nothing has changed.
265             for app_label in sorted(self.generated_operations):
266                 chopped = []
267                 dependencies = set()
268                 for operation in list(self.generated_operations[app_label]):
269                     deps_satisfied = True
270                     operation_dependencies = set()
271                     for dep in operation._auto_deps:
272                         # Temporarily resolve the swappable dependency to
273                         # prevent circular references. While keeping the
274                         # dependency checks on the resolved model, add the
275                         # swappable dependencies.
276                         original_dep = dep
277                         dep, is_swappable_dep = self._resolve_dependency(dep)
278                         if dep[0] != app_label:
279                             # External app dependency. See if it's not yet
280                             # satisfied.
281                             for other_operation in self.generated_operations.get(dep[0], []):
282                                 if self.check_dependency(other_operation, dep):
283                                     deps_satisfied = False
284                                     break
285                             if not deps_satisfied:
286                                 break
287                             else:
288                                 if is_swappable_dep:
289                                     operation_dependencies.add((original_dep[0], original_dep[1]))
290                                 elif dep[0] in self.migrations:
291                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
292                                 else:
293                                     # If we can't find the other app, we add a first/last dependency,
294                                     # but only if we've already been through once and checked everything
295                                     if chop_mode:
296                                         # If the app already exists, we add a dependency on the last migration,
297                                         # as we don't know which migration contains the target field.
298                                         # If it's not yet migrated or has no migrations, we use __first__
299                                         if graph and graph.leaf_nodes(dep[0]):
300                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
301                                         else:
302                                             operation_dependencies.add((dep[0], "__first__"))
303                                     else:
304                                         deps_satisfied = False
305                     if deps_satisfied:
306                         chopped.append(operation)
307                         dependencies.update(operation_dependencies)
308                         del self.generated_operations[app_label][0]
309                     else:
310                         break
311                 # Make a migration! Well, only if there's stuff to put in it
312                 if dependencies or chopped:
313                     if not self.generated_operations[app_label] or chop_mode:
314                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
315                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
316                         instance.dependencies = list(dependencies)
317                         instance.operations = chopped
318                         instance.initial = app_label not in self.existing_apps
319                         self.migrations.setdefault(app_label, []).append(instance)
320                         chop_mode = False
321                     else:
322                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
323             new_num_ops = sum(len(x) for x in self.generated_operations.values())
324             if new_num_ops == num_ops:
325                 if not chop_mode:
326                     chop_mode = True
327                 else:
328                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
329             num_ops = new_num_ops
330 
331     def _sort_migrations(self):
332         """
333         Reorder to make things possible. Reordering may be needed so FKs work
334         nicely inside the same app.
335         """
336         for app_label, ops in sorted(self.generated_operations.items()):
337             # construct a dependency graph for intra-app dependencies
338             dependency_graph = {op: set() for op in ops}
339             for op in ops:
340                 for dep in op._auto_deps:
341                     # Resolve intra-app dependencies to handle circular
342                     # references involving a swappable model.
343                     dep = self._resolve_dependency(dep)[0]
344                     if dep[0] == app_label:
345                         for op2 in ops:
346                             if self.check_dependency(op2, dep):
347                                 dependency_graph[op].add(op2)
348 
349             # we use a stable sort for deterministic tests & general behavior
350             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
351 
352     def _optimize_migrations(self):
353         # Add in internal dependencies among the migrations
354         for app_label, migrations in self.migrations.items():
355             for m1, m2 in zip(migrations, migrations[1:]):
356                 m2.dependencies.append((app_label, m1.name))
357 
358         # De-dupe dependencies
359         for migrations in self.migrations.values():
360             for migration in migrations:
361                 migration.dependencies = list(set(migration.dependencies))
362 
363         # Optimize migrations
364         for app_label, migrations in self.migrations.items():
365             for migration in migrations:
366                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
367 
368     def check_dependency(self, operation, dependency):
369         """
370         Return True if the given operation depends on the given dependency,
371         False otherwise.
372         """
373         # Created model
374         if dependency[2] is None and dependency[3] is True:
375             return (
376                 isinstance(operation, operations.CreateModel) and
377                 operation.name_lower == dependency[1].lower()
378             )
379         # Created field
380         elif dependency[2] is not None and dependency[3] is True:
381             return (
382                 (
383                     isinstance(operation, operations.CreateModel) and
384                     operation.name_lower == dependency[1].lower() and
385                     any(dependency[2] == x for x, y in operation.fields)
386                 ) or
387                 (
388                     isinstance(operation, operations.AddField) and
389                     operation.model_name_lower == dependency[1].lower() and
390                     operation.name_lower == dependency[2].lower()
391                 )
392             )
393         # Removed field
394         elif dependency[2] is not None and dependency[3] is False:
395             return (
396                 isinstance(operation, operations.RemoveField) and
397                 operation.model_name_lower == dependency[1].lower() and
398                 operation.name_lower == dependency[2].lower()
399             )
400         # Removed model
401         elif dependency[2] is None and dependency[3] is False:
402             return (
403                 isinstance(operation, operations.DeleteModel) and
404                 operation.name_lower == dependency[1].lower()
405             )
406         # Field being altered
407         elif dependency[2] is not None and dependency[3] == "alter":
408             return (
409                 isinstance(operation, operations.AlterField) and
410                 operation.model_name_lower == dependency[1].lower() and
411                 operation.name_lower == dependency[2].lower()
412             )
413         # order_with_respect_to being unset for a field
414         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
415             return (
416                 isinstance(operation, operations.AlterOrderWithRespectTo) and
417                 operation.name_lower == dependency[1].lower() and
418                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
419             )
420         # Field is removed and part of an index/unique_together
421         elif dependency[2] is not None and dependency[3] == "foo_together_change":
422             return (
423                 isinstance(operation, (operations.AlterUniqueTogether,
424                                        operations.AlterIndexTogether)) and
425                 operation.name_lower == dependency[1].lower()
426             )
427         # Unknown dependency. Raise an error.
428         else:
429             raise ValueError("Can't handle dependency %r" % (dependency,))
430 
431     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
432         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
433         operation._auto_deps = dependencies or []
434         if beginning:
435             self.generated_operations.setdefault(app_label, []).insert(0, operation)
436         else:
437             self.generated_operations.setdefault(app_label, []).append(operation)
438 
439     def swappable_first_key(self, item):
440         """
441         Place potential swappable models first in lists of created models (only
442         real way to solve #22783).
443         """
444         try:
445             model_state = self.to_state.models[item]
446             base_names = {
447                 base if isinstance(base, str) else base.__name__
448                 for base in model_state.bases
449             }
450             string_version = "%s.%s" % (item[0], item[1])
451             if (
452                 model_state.options.get('swappable') or
453                 "AbstractUser" in base_names or
454                 "AbstractBaseUser" in base_names or
455                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
456             ):
457                 return ("___" + item[0], "___" + item[1])
458         except LookupError:
459             pass
460         return item
461 
462     def generate_renamed_models(self):
463         """
464         Find any renamed models, generate the operations for them, and remove
465         the old entry from the model lists. Must be run before other
466         model-level generation.
467         """
468         self.renamed_models = {}
469         self.renamed_models_rel = {}
470         added_models = self.new_model_keys - self.old_model_keys
471         for app_label, model_name in sorted(added_models):
472             model_state = self.to_state.models[app_label, model_name]
473             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
474 
475             removed_models = self.old_model_keys - self.new_model_keys
476             for rem_app_label, rem_model_name in removed_models:
477                 if rem_app_label == app_label:
478                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
479                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
480                     if model_fields_def == rem_model_fields_def:
481                         if self.questioner.ask_rename_model(rem_model_state, model_state):
482                             dependencies = []
483                             fields = list(model_state.fields.values()) + [
484                                 field.remote_field
485                                 for relations in self.to_state.relations[app_label, model_name].values()
486                                 for field in relations.values()
487                             ]
488                             for field in fields:
489                                 if field.is_relation:
490                                     dependencies.extend(
491                                         self._get_dependencies_for_foreign_key(
492                                             app_label, model_name, field, self.to_state,
493                                         )
494                                     )
495                             self.add_operation(
496                                 app_label,
497                                 operations.RenameModel(
498                                     old_name=rem_model_state.name,
499                                     new_name=model_state.name,
500                                 ),
501                                 dependencies=dependencies,
502                             )
503                             self.renamed_models[app_label, model_name] = rem_model_name
504                             renamed_models_rel_key = '%s.%s' % (
505                                 rem_model_state.app_label,
506                                 rem_model_state.name_lower,
507                             )
508                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
509                                 model_state.app_label,
510                                 model_state.name_lower,
511                             )
512                             self.old_model_keys.remove((rem_app_label, rem_model_name))
513                             self.old_model_keys.add((app_label, model_name))
514                             break
515 
516     def generate_created_models(self):
517         """
518         Find all new models (both managed and unmanaged) and make create
519         operations for them as well as separate operations to create any
520         foreign key or M2M relationships (these are optimized later, if
521         possible).
522 
523         Defer any model options that refer to collections of fields that might
524         be deferred (e.g. unique_together, index_together).
525         """
526         old_keys = self.old_model_keys | self.old_unmanaged_keys
527         added_models = self.new_model_keys - old_keys
528         added_unmanaged_models = self.new_unmanaged_keys - old_keys
529         all_added_models = chain(
530             sorted(added_models, key=self.swappable_first_key, reverse=True),
531             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
532         )
533         for app_label, model_name in all_added_models:
534             model_state = self.to_state.models[app_label, model_name]
535             # Gather related fields
536             related_fields = {}
537             primary_key_rel = None
538             for field_name, field in model_state.fields.items():
539                 if field.remote_field:
540                     if field.remote_field.model:
541                         if field.primary_key:
542                             primary_key_rel = field.remote_field.model
543                         elif not field.remote_field.parent_link:
544                             related_fields[field_name] = field
545                     if getattr(field.remote_field, 'through', None):
546                         related_fields[field_name] = field
547 
548             # Are there indexes/unique|index_together to defer?
549             indexes = model_state.options.pop('indexes')
550             constraints = model_state.options.pop('constraints')
551             unique_together = model_state.options.pop('unique_together', None)
552             index_together = model_state.options.pop('index_together', None)
553             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
554             # Depend on the deletion of any possible proxy version of us
555             dependencies = [
556                 (app_label, model_name, None, False),
557             ]
558             # Depend on all bases
559             for base in model_state.bases:
560                 if isinstance(base, str) and "." in base:
561                     base_app_label, base_name = base.split(".", 1)
562                     dependencies.append((base_app_label, base_name, None, True))
563                     # Depend on the removal of base fields if the new model has
564                     # a field with the same name.
565                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
566                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
567                     if old_base_model_state and new_base_model_state:
568                         removed_base_fields = set(old_base_model_state.fields).difference(
569                             new_base_model_state.fields,
570                         ).intersection(model_state.fields)
571                         for removed_base_field in removed_base_fields:
572                             dependencies.append((base_app_label, base_name, removed_base_field, False))
573             # Depend on the other end of the primary key if it's a relation
574             if primary_key_rel:
575                 dependencies.append(
576                     resolve_relation(
577                         primary_key_rel, app_label, model_name,
578                     ) + (None, True)
579                 )
580             # Generate creation operation
581             self.add_operation(
582                 app_label,
583                 operations.CreateModel(
584                     name=model_state.name,
585                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
586                     options=model_state.options,
587                     bases=model_state.bases,
588                     managers=model_state.managers,
589                 ),
590                 dependencies=dependencies,
591                 beginning=True,
592             )
593 
594             # Don't add operations which modify the database for unmanaged models
595             if not model_state.options.get('managed', True):
596                 continue
597 
598             # Generate operations for each related field
599             for name, field in sorted(related_fields.items()):
600                 dependencies = self._get_dependencies_for_foreign_key(
601                     app_label, model_name, field, self.to_state,
602                 )
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             relations = self.to_state.relations
672             if (app_label, model_name) in self.old_proxy_keys:
673                 for related_model_key, related_fields in relations[app_label, model_name].items():
674                     related_model_state = self.to_state.models[related_model_key]
675                     for related_field_name, related_field in related_fields.items():
676                         self.add_operation(
677                             related_model_state.app_label,
678                             operations.AlterField(
679                                 model_name=related_model_state.name,
680                                 name=related_field_name,
681                                 field=related_field,
682                             ),
683                             dependencies=[(app_label, model_name, None, True)],
684                         )
685 
686     def generate_created_proxies(self):
687         """
688         Make CreateModel statements for proxy models. Use the same statements
689         as that way there's less code duplication, but for proxy models it's
690         safe to skip all the pointless field stuff and chuck out an operation.
691         """
692         added = self.new_proxy_keys - self.old_proxy_keys
693         for app_label, model_name in sorted(added):
694             model_state = self.to_state.models[app_label, model_name]
695             assert model_state.options.get("proxy")
696             # Depend on the deletion of any possible non-proxy version of us
697             dependencies = [
698                 (app_label, model_name, None, False),
699             ]
700             # Depend on all bases
701             for base in model_state.bases:
702                 if isinstance(base, str) and "." in base:
703                     base_app_label, base_name = base.split(".", 1)
704                     dependencies.append((base_app_label, base_name, None, True))
705             # Generate creation operation
706             self.add_operation(
707                 app_label,
708                 operations.CreateModel(
709                     name=model_state.name,
710                     fields=[],
711                     options=model_state.options,
712                     bases=model_state.bases,
713                     managers=model_state.managers,
714                 ),
715                 # Depend on the deletion of any possible non-proxy version of us
716                 dependencies=dependencies,
717             )
718 
719     def generate_deleted_models(self):
720         """
721         Find all deleted models (managed and unmanaged) and make delete
722         operations for them as well as separate operations to delete any
723         foreign key or M2M relationships (these are optimized later, if
724         possible).
725 
726         Also bring forward removal of any model options that refer to
727         collections of fields - the inverse of generate_created_models().
728         """
729         new_keys = self.new_model_keys | self.new_unmanaged_keys
730         deleted_models = self.old_model_keys - new_keys
731         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
732         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
733         for app_label, model_name in all_deleted_models:
734             model_state = self.from_state.models[app_label, model_name]
735             # Gather related fields
736             related_fields = {}
737             for field_name, field in model_state.fields.items():
738                 if field.remote_field:
739                     if field.remote_field.model:
740                         related_fields[field_name] = field
741                     if getattr(field.remote_field, 'through', None):
742                         related_fields[field_name] = field
743             # Generate option removal first
744             unique_together = model_state.options.pop('unique_together', None)
745             index_together = model_state.options.pop('index_together', None)
746             if unique_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterUniqueTogether(
750                         name=model_name,
751                         unique_together=None,
752                     )
753                 )
754             if index_together:
755                 self.add_operation(
756                     app_label,
757                     operations.AlterIndexTogether(
758                         name=model_name,
759                         index_together=None,
760                     )
761                 )
762             # Then remove each related field
763             for name in sorted(related_fields):
764                 self.add_operation(
765                     app_label,
766                     operations.RemoveField(
767                         model_name=model_name,
768                         name=name,
769                     )
770                 )
771             # Finally, remove the model.
772             # This depends on both the removal/alteration of all incoming fields
773             # and the removal of all its own related fields, and if it's
774             # a through model the field that references it.
775             dependencies = []
776             relations = self.from_state.relations
777             for (related_object_app_label, object_name), relation_related_fields in (
778                 relations[app_label, model_name].items()
779             ):
780                 for field_name, field in relation_related_fields.items():
781                     dependencies.append(
782                         (related_object_app_label, object_name, field_name, False),
783                     )
784                     if not field.many_to_many:
785                         dependencies.append(
786                             (related_object_app_label, object_name, field_name, 'alter'),
787                         )
788 
789             for name in sorted(related_fields):
790                 dependencies.append((app_label, model_name, name, False))
791             # We're referenced in another field's through=
792             through_user = self.through_users.get((app_label, model_state.name_lower))
793             if through_user:
794                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
795             # Finally, make the operation, deduping any dependencies
796             self.add_operation(
797                 app_label,
798                 operations.DeleteModel(
799                     name=model_state.name,
800                 ),
801                 dependencies=list(set(dependencies)),
802             )
803 
804     def generate_deleted_proxies(self):
805         """Make DeleteModel options for proxy models."""
806         deleted = self.old_proxy_keys - self.new_proxy_keys
807         for app_label, model_name in sorted(deleted):
808             model_state = self.from_state.models[app_label, model_name]
809             assert model_state.options.get("proxy")
810             self.add_operation(
811                 app_label,
812                 operations.DeleteModel(
813                     name=model_state.name,
814                 ),
815             )
816 
817     def generate_renamed_fields(self):
818         """Work out renamed fields."""
819         self.renamed_fields = {}
820         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
821             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
822             old_model_state = self.from_state.models[app_label, old_model_name]
823             new_model_state = self.to_state.models[app_label, old_model_name]
824             field = new_model_state.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.get_field(rem_field_name)
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.to_state.models[app_label, model_name].get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(
867                 app_label, model_name, field, self.to_state,
868             ))
869         # You can't just add NOT NULL fields with no default or fields
870         # which don't allow empty strings as default.
871         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
872         preserve_default = (
873             field.null or field.has_default() or field.many_to_many or
874             (field.blank and field.empty_strings_allowed) or
875             (isinstance(field, time_fields) and field.auto_now)
876         )
877         if not preserve_default:
878             field = field.clone()
879             if isinstance(field, time_fields) and field.auto_now_add:
880                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
881             else:
882                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
883         if (
884             field.unique and
885             field.default is not models.NOT_PROVIDED and
886             callable(field.default)
887         ):
888             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
889         self.add_operation(
890             app_label,
891             operations.AddField(
892                 model_name=model_name,
893                 name=field_name,
894                 field=field,
895                 preserve_default=preserve_default,
896             ),
897             dependencies=dependencies,
898         )
899 
900     def generate_removed_fields(self):
901         """Make RemoveField operations."""
902         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
903             self._generate_removed_field(app_label, model_name, field_name)
904 
905     def _generate_removed_field(self, app_label, model_name, field_name):
906         self.add_operation(
907             app_label,
908             operations.RemoveField(
909                 model_name=model_name,
910                 name=field_name,
911             ),
912             # We might need to depend on the removal of an
913             # order_with_respect_to or index/unique_together operation;
914             # this is safely ignored if there isn't one
915             dependencies=[
916                 (app_label, model_name, field_name, "order_wrt_unset"),
917                 (app_label, model_name, field_name, "foo_together_change"),
918             ],
919         )
920 
921     def generate_altered_fields(self):
922         """
923         Make AlterField operations, or possibly RemovedField/AddField if alter
924         isn't possible.
925         """
926         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
927             # Did the field change?
928             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
929             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
930             old_field = self.from_state.models[app_label, old_model_name].get_field(old_field_name)
931             new_field = self.to_state.models[app_label, model_name].get_field(field_name)
932             dependencies = []
933             # Implement any model renames on relations; these are handled by RenameModel
934             # so we need to exclude them from the comparison
935             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
936                 rename_key = resolve_relation(new_field.remote_field.model, app_label, model_name)
937                 if rename_key in self.renamed_models:
938                     new_field.remote_field.model = old_field.remote_field.model
939                 # Handle ForeignKey which can only have a single to_field.
940                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
941                 if remote_field_name:
942                     to_field_rename_key = rename_key + (remote_field_name,)
943                     if to_field_rename_key in self.renamed_fields:
944                         # Repoint both model and field name because to_field
945                         # inclusion in ForeignKey.deconstruct() is based on
946                         # both.
947                         new_field.remote_field.model = old_field.remote_field.model
948                         new_field.remote_field.field_name = old_field.remote_field.field_name
949                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
950                 from_fields = getattr(new_field, 'from_fields', None)
951                 if from_fields:
952                     from_rename_key = (app_label, model_name)
953                     new_field.from_fields = tuple([
954                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
955                         for from_field in from_fields
956                     ])
957                     new_field.to_fields = tuple([
958                         self.renamed_fields.get(rename_key + (to_field,), to_field)
959                         for to_field in new_field.to_fields
960                     ])
961                 dependencies.extend(self._get_dependencies_for_foreign_key(
962                     app_label, model_name, new_field, self.to_state,
963                 ))
964             if (
965                 hasattr(new_field, 'remote_field') and
966                 getattr(new_field.remote_field, 'through', None)
967             ):
968                 rename_key = resolve_relation(new_field.remote_field.through, app_label, model_name)
969                 if rename_key in self.renamed_models:
970                     new_field.remote_field.through = old_field.remote_field.through
971             old_field_dec = self.deep_deconstruct(old_field)
972             new_field_dec = self.deep_deconstruct(new_field)
973             if old_field_dec != new_field_dec:
974                 both_m2m = old_field.many_to_many and new_field.many_to_many
975                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
976                 if both_m2m or neither_m2m:
977                     # Either both fields are m2m or neither is
978                     preserve_default = True
979                     if (old_field.null and not new_field.null and not new_field.has_default() and
980                             not new_field.many_to_many):
981                         field = new_field.clone()
982                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
983                         if new_default is not models.NOT_PROVIDED:
984                             field.default = new_default
985                             preserve_default = False
986                     else:
987                         field = new_field
988                     self.add_operation(
989                         app_label,
990                         operations.AlterField(
991                             model_name=model_name,
992                             name=field_name,
993                             field=field,
994                             preserve_default=preserve_default,
995                         ),
996                         dependencies=dependencies,
997                     )
998                 else:
999                     # We cannot alter between m2m and concrete fields
1000                     self._generate_removed_field(app_label, model_name, field_name)
1001                     self._generate_added_field(app_label, model_name, field_name)
1002 
1003     def create_altered_indexes(self):
1004         option_name = operations.AddIndex.option_name
1005         for app_label, model_name in sorted(self.kept_model_keys):
1006             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1007             old_model_state = self.from_state.models[app_label, old_model_name]
1008             new_model_state = self.to_state.models[app_label, model_name]
1009 
1010             old_indexes = old_model_state.options[option_name]
1011             new_indexes = new_model_state.options[option_name]
1012             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1013             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1014 
1015             self.altered_indexes.update({
1016                 (app_label, model_name): {
1017                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1018                 }
1019             })
1020 
1021     def generate_added_indexes(self):
1022         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1023             for index in alt_indexes['added_indexes']:
1024                 self.add_operation(
1025                     app_label,
1026                     operations.AddIndex(
1027                         model_name=model_name,
1028                         index=index,
1029                     )
1030                 )
1031 
1032     def generate_removed_indexes(self):
1033         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1034             for index in alt_indexes['removed_indexes']:
1035                 self.add_operation(
1036                     app_label,
1037                     operations.RemoveIndex(
1038                         model_name=model_name,
1039                         name=index.name,
1040                     )
1041                 )
1042 
1043     def create_altered_constraints(self):
1044         option_name = operations.AddConstraint.option_name
1045         for app_label, model_name in sorted(self.kept_model_keys):
1046             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1047             old_model_state = self.from_state.models[app_label, old_model_name]
1048             new_model_state = self.to_state.models[app_label, model_name]
1049 
1050             old_constraints = old_model_state.options[option_name]
1051             new_constraints = new_model_state.options[option_name]
1052             add_constraints = [c for c in new_constraints if c not in old_constraints]
1053             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1054 
1055             self.altered_constraints.update({
1056                 (app_label, model_name): {
1057                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1058                 }
1059             })
1060 
1061     def generate_added_constraints(self):
1062         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1063             for constraint in alt_constraints['added_constraints']:
1064                 self.add_operation(
1065                     app_label,
1066                     operations.AddConstraint(
1067                         model_name=model_name,
1068                         constraint=constraint,
1069                     )
1070                 )
1071 
1072     def generate_removed_constraints(self):
1073         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1074             for constraint in alt_constraints['removed_constraints']:
1075                 self.add_operation(
1076                     app_label,
1077                     operations.RemoveConstraint(
1078                         model_name=model_name,
1079                         name=constraint.name,
1080                     )
1081                 )
1082 
1083     @staticmethod
1084     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1085         remote_field_model = None
1086         if hasattr(field.remote_field, 'model'):
1087             remote_field_model = field.remote_field.model
1088         else:
1089             relations = project_state.relations[app_label, model_name]
1090             for (remote_app_label, remote_model_name), fields in relations.items():
1091                 if any(
1092                     field == related_field.remote_field
1093                     for related_field in fields.values()
1094                 ):
1095                     remote_field_model = f'{remote_app_label}.{remote_model_name}'
1096                     break
1097         # Account for FKs to swappable models
1098         swappable_setting = getattr(field, 'swappable_setting', None)
1099         if swappable_setting is not None:
1100             dep_app_label = "__setting__"
1101             dep_object_name = swappable_setting
1102         else:
1103             dep_app_label, dep_object_name = resolve_relation(
1104                 remote_field_model, app_label, model_name,
1105             )
1106         dependencies = [(dep_app_label, dep_object_name, None, True)]
1107         if getattr(field.remote_field, 'through', None):
1108             through_app_label, through_object_name = resolve_relation(
1109                 remote_field_model, app_label, model_name,
1110             )
1111             dependencies.append((through_app_label, through_object_name, None, True))
1112         return dependencies
1113 
1114     def _generate_altered_foo_together(self, operation):
1115         option_name = operation.option_name
1116         for app_label, model_name in sorted(self.kept_model_keys):
1117             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1118             old_model_state = self.from_state.models[app_label, old_model_name]
1119             new_model_state = self.to_state.models[app_label, model_name]
1120 
1121             # We run the old version through the field renames to account for those
1122             old_value = old_model_state.options.get(option_name)
1123             old_value = {
1124                 tuple(
1125                     self.renamed_fields.get((app_label, model_name, n), n)
1126                     for n in unique
1127                 )
1128                 for unique in old_value
1129             } if old_value else set()
1130 
1131             new_value = new_model_state.options.get(option_name)
1132             new_value = set(new_value) if new_value else set()
1133 
1134             if old_value != new_value:
1135                 dependencies = []
1136                 for foo_togethers in new_value:
1137                     for field_name in foo_togethers:
1138                         field = new_model_state.get_field(field_name)
1139                         if field.remote_field and field.remote_field.model:
1140                             dependencies.extend(self._get_dependencies_for_foreign_key(
1141                                 app_label, model_name, field, self.to_state,
1142                             ))
1143 
1144                 self.add_operation(
1145                     app_label,
1146                     operation(
1147                         name=model_name,
1148                         **{option_name: new_value}
1149                     ),
1150                     dependencies=dependencies,
1151                 )
1152 
1153     def generate_altered_unique_together(self):
1154         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1155 
1156     def generate_altered_index_together(self):
1157         self._generate_altered_foo_together(operations.AlterIndexTogether)
1158 
1159     def generate_altered_db_table(self):
1160         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1161         for app_label, model_name in sorted(models_to_check):
1162             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1163             old_model_state = self.from_state.models[app_label, old_model_name]
1164             new_model_state = self.to_state.models[app_label, model_name]
1165             old_db_table_name = old_model_state.options.get('db_table')
1166             new_db_table_name = new_model_state.options.get('db_table')
1167             if old_db_table_name != new_db_table_name:
1168                 self.add_operation(
1169                     app_label,
1170                     operations.AlterModelTable(
1171                         name=model_name,
1172                         table=new_db_table_name,
1173                     )
1174                 )
1175 
1176     def generate_altered_options(self):
1177         """
1178         Work out if any non-schema-affecting options have changed and make an
1179         operation to represent them in state changes (in case Python code in
1180         migrations needs them).
1181         """
1182         models_to_check = self.kept_model_keys.union(
1183             self.kept_proxy_keys,
1184             self.kept_unmanaged_keys,
1185             # unmanaged converted to managed
1186             self.old_unmanaged_keys & self.new_model_keys,
1187             # managed converted to unmanaged
1188             self.old_model_keys & self.new_unmanaged_keys,
1189         )
1190 
1191         for app_label, model_name in sorted(models_to_check):
1192             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1193             old_model_state = self.from_state.models[app_label, old_model_name]
1194             new_model_state = self.to_state.models[app_label, model_name]
1195             old_options = {
1196                 key: value for key, value in old_model_state.options.items()
1197                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1198             }
1199             new_options = {
1200                 key: value for key, value in new_model_state.options.items()
1201                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1202             }
1203             if old_options != new_options:
1204                 self.add_operation(
1205                     app_label,
1206                     operations.AlterModelOptions(
1207                         name=model_name,
1208                         options=new_options,
1209                     )
1210                 )
1211 
1212     def generate_altered_order_with_respect_to(self):
1213         for app_label, model_name in sorted(self.kept_model_keys):
1214             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1215             old_model_state = self.from_state.models[app_label, old_model_name]
1216             new_model_state = self.to_state.models[app_label, model_name]
1217             if (old_model_state.options.get("order_with_respect_to") !=
1218                     new_model_state.options.get("order_with_respect_to")):
1219                 # Make sure it comes second if we're adding
1220                 # (removal dependency is part of RemoveField)
1221                 dependencies = []
1222                 if new_model_state.options.get("order_with_respect_to"):
1223                     dependencies.append((
1224                         app_label,
1225                         model_name,
1226                         new_model_state.options["order_with_respect_to"],
1227                         True,
1228                     ))
1229                 # Actually generate the operation
1230                 self.add_operation(
1231                     app_label,
1232                     operations.AlterOrderWithRespectTo(
1233                         name=model_name,
1234                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1235                     ),
1236                     dependencies=dependencies,
1237                 )
1238 
1239     def generate_altered_managers(self):
1240         for app_label, model_name in sorted(self.kept_model_keys):
1241             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1242             old_model_state = self.from_state.models[app_label, old_model_name]
1243             new_model_state = self.to_state.models[app_label, model_name]
1244             if old_model_state.managers != new_model_state.managers:
1245                 self.add_operation(
1246                     app_label,
1247                     operations.AlterModelManagers(
1248                         name=model_name,
1249                         managers=new_model_state.managers,
1250                     )
1251                 )
1252 
1253     def arrange_for_graph(self, changes, graph, migration_name=None):
1254         """
1255         Take a result from changes() and a MigrationGraph, and fix the names
1256         and dependencies of the changes so they extend the graph from the leaf
1257         nodes for each app.
1258         """
1259         leaves = graph.leaf_nodes()
1260         name_map = {}
1261         for app_label, migrations in list(changes.items()):
1262             if not migrations:
1263                 continue
1264             # Find the app label's current leaf node
1265             app_leaf = None
1266             for leaf in leaves:
1267                 if leaf[0] == app_label:
1268                     app_leaf = leaf
1269                     break
1270             # Do they want an initial migration for this app?
1271             if app_leaf is None and not self.questioner.ask_initial(app_label):
1272                 # They don't.
1273                 for migration in migrations:
1274                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1275                 del changes[app_label]
1276                 continue
1277             # Work out the next number in the sequence
1278             if app_leaf is None:
1279                 next_number = 1
1280             else:
1281                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1282             # Name each migration
1283             for i, migration in enumerate(migrations):
1284                 if i == 0 and app_leaf:
1285                     migration.dependencies.append(app_leaf)
1286                 new_name_parts = ['%04i' % next_number]
1287                 if migration_name:
1288                     new_name_parts.append(migration_name)
1289                 elif i == 0 and not app_leaf:
1290                     new_name_parts.append('initial')
1291                 else:
1292                     new_name_parts.append(migration.suggest_name()[:100])
1293                 new_name = '_'.join(new_name_parts)
1294                 name_map[(app_label, migration.name)] = (app_label, new_name)
1295                 next_number += 1
1296                 migration.name = new_name
1297         # Now fix dependencies
1298         for migrations in changes.values():
1299             for migration in migrations:
1300                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1301         return changes
1302 
1303     def _trim_to_apps(self, changes, app_labels):
1304         """
1305         Take changes from arrange_for_graph() and set of app labels, and return
1306         a modified set of changes which trims out as many migrations that are
1307         not in app_labels as possible. Note that some other migrations may
1308         still be present as they may be required dependencies.
1309         """
1310         # Gather other app dependencies in a first pass
1311         app_dependencies = {}
1312         for app_label, migrations in changes.items():
1313             for migration in migrations:
1314                 for dep_app_label, name in migration.dependencies:
1315                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1316         required_apps = set(app_labels)
1317         # Keep resolving till there's no change
1318         old_required_apps = None
1319         while old_required_apps != required_apps:
1320             old_required_apps = set(required_apps)
1321             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1322         # Remove all migrations that aren't needed
1323         for app_label in list(changes):
1324             if app_label not in required_apps:
1325                 del changes[app_label]
1326         return changes
1327 
1328     @classmethod
1329     def parse_number(cls, name):
1330         """
1331         Given a migration name, try to extract a number from the beginning of
1332         it. If no number is found, return None.
1333         """
1334         match = re.match(r'^\d+', name)
1335         if match:
1336             return int(match[0])
1337         return None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 03:36:43.468 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>arrange_for_graph</method>
<code>
1253     def arrange_for_graph(self, changes, graph, migration_name=None):
1254         """
1255         Take a result from changes() and a MigrationGraph, and fix the names
1256         and dependencies of the changes so they extend the graph from the leaf
1257         nodes for each app.
1258         """
1259         leaves = graph.leaf_nodes()
1260         name_map = {}
1261         for app_label, migrations in list(changes.items()):
1262             if not migrations:
1263                 continue
1264             # Find the app label's current leaf node
1265             app_leaf = None
1266             for leaf in leaves:
1267                 if leaf[0] == app_label:
1268                     app_leaf = leaf
1269                     break
1270             # Do they want an initial migration for this app?
1271             if app_leaf is None and not self.questioner.ask_initial(app_label):
1272                 # They don't.
1273                 for migration in migrations:
1274                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1275                 del changes[app_label]
1276                 continue
1277             # Work out the next number in the sequence
1278             if app_leaf is None:
1279                 next_number = 1
1280             else:
1281                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1282             # Name each migration
1283             for i, migration in enumerate(migrations):
1284                 if i == 0 and app_leaf:
1285                     migration.dependencies.append(app_leaf)
1286                 new_name_parts = ['%04i' % next_number]
1287                 if migration_name:
1288                     new_name_parts.append(migration_name)
1289                 elif i == 0 and not app_leaf:
1290                     new_name_parts.append('initial')
1291                 else:
1292                     new_name_parts.append(migration.suggest_name()[:100])
1293                 new_name = '_'.join(new_name_parts)
1294                 name_map[(app_label, migration.name)] = (app_label, new_name)
1295                 next_number += 1
1296                 migration.name = new_name
1297         # Now fix dependencies
1298         for migrations in changes.values():
1299             for migration in migrations:
1300                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1301         return changes

</code><intended_behavior>The method should be refined to ensure it accurately accounts for both squashed and non-squashed migrations when calculating the sequence number for new migrations. Specifically, in the logic that determines the next number in the sequence, there should be an explicit check or consideration for squashed migrations. The method must ensure that the sequence number of a new migration reflects the total count of existing migrations, including those squashed, to avoid numbering collisions or sequencing errors. This might involve an enhancement in how the current leaf node (or nodes, in the case of squashed migrations) is determined and how the sequence numbers are incremented from there.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>None</method>
<code>
18 class MigrationAutodetector:
19     """
20     Take a pair of ProjectStates and compare them to see what the first would
21     need doing to make it match the second (the second usually being the
22     project's current state).
23 
24     Note that this naturally operates on entire projects at a time,
25     as it's likely that changes interact (for example, you can't
26     add a ForeignKey without having a migration to add the table it
27     depends on first). A user interface may offer single-app usage
28     if it wishes, with the caveat that it may not always be possible.
29     """
30 
31     def __init__(self, from_state, to_state, questioner=None):
32         self.from_state = from_state
33         self.to_state = to_state
34         self.questioner = questioner or MigrationQuestioner()
35         self.existing_apps = {app for app, model in from_state.models}
36 
37     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
38         """
39         Main entry point to produce a list of applicable changes.
40         Take a graph to base names on and an optional set of apps
41         to try and restrict to (restriction is not guaranteed)
42         """
43         changes = self._detect_changes(convert_apps, graph)
44         changes = self.arrange_for_graph(changes, graph, migration_name)
45         if trim_to_apps:
46             changes = self._trim_to_apps(changes, trim_to_apps)
47         return changes
48 
49     def deep_deconstruct(self, obj):
50         """
51         Recursive deconstruction for a field and its arguments.
52         Used for full comparison for rename/alter; sometimes a single-level
53         deconstruction will not compare correctly.
54         """
55         if isinstance(obj, list):
56             return [self.deep_deconstruct(value) for value in obj]
57         elif isinstance(obj, tuple):
58             return tuple(self.deep_deconstruct(value) for value in obj)
59         elif isinstance(obj, dict):
60             return {
61                 key: self.deep_deconstruct(value)
62                 for key, value in obj.items()
63             }
64         elif isinstance(obj, functools.partial):
65             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
66         elif isinstance(obj, COMPILED_REGEX_TYPE):
67             return RegexObject(obj)
68         elif isinstance(obj, type):
69             # If this is a type that implements 'deconstruct' as an instance method,
70             # avoid treating this as being deconstructible itself - see #22951
71             return obj
72         elif hasattr(obj, 'deconstruct'):
73             deconstructed = obj.deconstruct()
74             if isinstance(obj, models.Field):
75                 # we have a field which also returns a name
76                 deconstructed = deconstructed[1:]
77             path, args, kwargs = deconstructed
78             return (
79                 path,
80                 [self.deep_deconstruct(value) for value in args],
81                 {
82                     key: self.deep_deconstruct(value)
83                     for key, value in kwargs.items()
84                 },
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as
93         the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields.items()):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 del deconstruction[2]['to']
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for (app_label, model_name), model_state in self.from_state.models.items():
135             if not model_state.options.get('managed', True):
136                 self.old_unmanaged_keys.add((app_label, model_name))
137             elif app_label not in self.from_state.real_apps:
138                 if model_state.options.get('proxy'):
139                     self.old_proxy_keys.add((app_label, model_name))
140                 else:
141                     self.old_model_keys.add((app_label, model_name))
142 
143         for (app_label, model_name), model_state in self.to_state.models.items():
144             if not model_state.options.get('managed', True):
145                 self.new_unmanaged_keys.add((app_label, model_name))
146             elif (
147                 app_label not in self.from_state.real_apps or
148                 (convert_apps and app_label in convert_apps)
149             ):
150                 if model_state.options.get('proxy'):
151                     self.new_proxy_keys.add((app_label, model_name))
152                 else:
153                     self.new_model_keys.add((app_label, model_name))
154 
155         self.from_state.resolve_fields_and_relations()
156         self.to_state.resolve_fields_and_relations()
157 
158         # Renames have to come first
159         self.generate_renamed_models()
160 
161         # Prepare lists of fields and generate through model map
162         self._prepare_field_lists()
163         self._generate_through_model_map()
164 
165         # Generate non-rename model operations
166         self.generate_deleted_models()
167         self.generate_created_models()
168         self.generate_deleted_proxies()
169         self.generate_created_proxies()
170         self.generate_altered_options()
171         self.generate_altered_managers()
172 
173         # Create the altered indexes and store them in self.altered_indexes.
174         # This avoids the same computation in generate_removed_indexes()
175         # and generate_added_indexes().
176         self.create_altered_indexes()
177         self.create_altered_constraints()
178         # Generate index removal operations before field is removed
179         self.generate_removed_constraints()
180         self.generate_removed_indexes()
181         # Generate field operations
182         self.generate_renamed_fields()
183         self.generate_removed_fields()
184         self.generate_added_fields()
185         self.generate_altered_fields()
186         self.generate_altered_order_with_respect_to()
187         self.generate_altered_unique_together()
188         self.generate_altered_index_together()
189         self.generate_added_indexes()
190         self.generate_added_constraints()
191         self.generate_altered_db_table()
192 
193         self._sort_migrations()
194         self._build_migration_list(graph)
195         self._optimize_migrations()
196 
197         return self.migrations
198 
199     def _prepare_field_lists(self):
200         """
201         Prepare field lists and a list of the fields that used through models
202         in the old state so dependencies can be made from the through model
203         deletion to the field that uses it.
204         """
205         self.kept_model_keys = self.old_model_keys & self.new_model_keys
206         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
207         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
208         self.through_users = {}
209         self.old_field_keys = {
210             (app_label, model_name, field_name)
211             for app_label, model_name in self.kept_model_keys
212             for field_name in self.from_state.models[
213                 app_label,
214                 self.renamed_models.get((app_label, model_name), model_name)
215             ].fields
216         }
217         self.new_field_keys = {
218             (app_label, model_name, field_name)
219             for app_label, model_name in self.kept_model_keys
220             for field_name in self.to_state.models[app_label, model_name].fields
221         }
222 
223     def _generate_through_model_map(self):
224         """Through model map generation."""
225         for app_label, model_name in sorted(self.old_model_keys):
226             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
227             old_model_state = self.from_state.models[app_label, old_model_name]
228             for field_name, field in old_model_state.fields.items():
229                 if hasattr(field, 'remote_field') and getattr(field.remote_field, 'through', None):
230                     through_key = resolve_relation(field.remote_field.through, app_label, model_name)
231                     self.through_users[through_key] = (app_label, old_model_name, field_name)
232 
233     @staticmethod
234     def _resolve_dependency(dependency):
235         """
236         Return the resolved dependency and a boolean denoting whether or not
237         it was swappable.
238         """
239         if dependency[0] != '__setting__':
240             return dependency, False
241         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
242         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
243 
244     def _build_migration_list(self, graph=None):
245         """
246         Chop the lists of operations up into migrations with dependencies on
247         each other. Do this by going through an app's list of operations until
248         one is found that has an outgoing dependency that isn't in another
249         app's migration yet (hasn't been chopped off its list). Then chop off
250         the operations before it into a migration and move onto the next app.
251         If the loops completes without doing anything, there's a circular
252         dependency (which _should_ be impossible as the operations are
253         all split at this point so they can't depend and be depended on).
254         """
255         self.migrations = {}
256         num_ops = sum(len(x) for x in self.generated_operations.values())
257         chop_mode = False
258         while num_ops:
259             # On every iteration, we step through all the apps and see if there
260             # is a completed set of operations.
261             # If we find that a subset of the operations are complete we can
262             # try to chop it off from the rest and continue, but we only
263             # do this if we've already been through the list once before
264             # without any chopping and nothing has changed.
265             for app_label in sorted(self.generated_operations):
266                 chopped = []
267                 dependencies = set()
268                 for operation in list(self.generated_operations[app_label]):
269                     deps_satisfied = True
270                     operation_dependencies = set()
271                     for dep in operation._auto_deps:
272                         # Temporarily resolve the swappable dependency to
273                         # prevent circular references. While keeping the
274                         # dependency checks on the resolved model, add the
275                         # swappable dependencies.
276                         original_dep = dep
277                         dep, is_swappable_dep = self._resolve_dependency(dep)
278                         if dep[0] != app_label:
279                             # External app dependency. See if it's not yet
280                             # satisfied.
281                             for other_operation in self.generated_operations.get(dep[0], []):
282                                 if self.check_dependency(other_operation, dep):
283                                     deps_satisfied = False
284                                     break
285                             if not deps_satisfied:
286                                 break
287                             else:
288                                 if is_swappable_dep:
289                                     operation_dependencies.add((original_dep[0], original_dep[1]))
290                                 elif dep[0] in self.migrations:
291                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
292                                 else:
293                                     # If we can't find the other app, we add a first/last dependency,
294                                     # but only if we've already been through once and checked everything
295                                     if chop_mode:
296                                         # If the app already exists, we add a dependency on the last migration,
297                                         # as we don't know which migration contains the target field.
298                                         # If it's not yet migrated or has no migrations, we use __first__
299                                         if graph and graph.leaf_nodes(dep[0]):
300                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
301                                         else:
302                                             operation_dependencies.add((dep[0], "__first__"))
303                                     else:
304                                         deps_satisfied = False
305                     if deps_satisfied:
306                         chopped.append(operation)
307                         dependencies.update(operation_dependencies)
308                         del self.generated_operations[app_label][0]
309                     else:
310                         break
311                 # Make a migration! Well, only if there's stuff to put in it
312                 if dependencies or chopped:
313                     if not self.generated_operations[app_label] or chop_mode:
314                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
315                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
316                         instance.dependencies = list(dependencies)
317                         instance.operations = chopped
318                         instance.initial = app_label not in self.existing_apps
319                         self.migrations.setdefault(app_label, []).append(instance)
320                         chop_mode = False
321                     else:
322                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
323             new_num_ops = sum(len(x) for x in self.generated_operations.values())
324             if new_num_ops == num_ops:
325                 if not chop_mode:
326                     chop_mode = True
327                 else:
328                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
329             num_ops = new_num_ops
330 
331     def _sort_migrations(self):
332         """
333         Reorder to make things possible. Reordering may be needed so FKs work
334         nicely inside the same app.
335         """
336         for app_label, ops in sorted(self.generated_operations.items()):
337             # construct a dependency graph for intra-app dependencies
338             dependency_graph = {op: set() for op in ops}
339             for op in ops:
340                 for dep in op._auto_deps:
341                     # Resolve intra-app dependencies to handle circular
342                     # references involving a swappable model.
343                     dep = self._resolve_dependency(dep)[0]
344                     if dep[0] == app_label:
345                         for op2 in ops:
346                             if self.check_dependency(op2, dep):
347                                 dependency_graph[op].add(op2)
348 
349             # we use a stable sort for deterministic tests & general behavior
350             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
351 
352     def _optimize_migrations(self):
353         # Add in internal dependencies among the migrations
354         for app_label, migrations in self.migrations.items():
355             for m1, m2 in zip(migrations, migrations[1:]):
356                 m2.dependencies.append((app_label, m1.name))
357 
358         # De-dupe dependencies
359         for migrations in self.migrations.values():
360             for migration in migrations:
361                 migration.dependencies = list(set(migration.dependencies))
362 
363         # Optimize migrations
364         for app_label, migrations in self.migrations.items():
365             for migration in migrations:
366                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
367 
368     def check_dependency(self, operation, dependency):
369         """
370         Return True if the given operation depends on the given dependency,
371         False otherwise.
372         """
373         # Created model
374         if dependency[2] is None and dependency[3] is True:
375             return (
376                 isinstance(operation, operations.CreateModel) and
377                 operation.name_lower == dependency[1].lower()
378             )
379         # Created field
380         elif dependency[2] is not None and dependency[3] is True:
381             return (
382                 (
383                     isinstance(operation, operations.CreateModel) and
384                     operation.name_lower == dependency[1].lower() and
385                     any(dependency[2] == x for x, y in operation.fields)
386                 ) or
387                 (
388                     isinstance(operation, operations.AddField) and
389                     operation.model_name_lower == dependency[1].lower() and
390                     operation.name_lower == dependency[2].lower()
391                 )
392             )
393         # Removed field
394         elif dependency[2] is not None and dependency[3] is False:
395             return (
396                 isinstance(operation, operations.RemoveField) and
397                 operation.model_name_lower == dependency[1].lower() and
398                 operation.name_lower == dependency[2].lower()
399             )
400         # Removed model
401         elif dependency[2] is None and dependency[3] is False:
402             return (
403                 isinstance(operation, operations.DeleteModel) and
404                 operation.name_lower == dependency[1].lower()
405             )
406         # Field being altered
407         elif dependency[2] is not None and dependency[3] == "alter":
408             return (
409                 isinstance(operation, operations.AlterField) and
410                 operation.model_name_lower == dependency[1].lower() and
411                 operation.name_lower == dependency[2].lower()
412             )
413         # order_with_respect_to being unset for a field
414         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
415             return (
416                 isinstance(operation, operations.AlterOrderWithRespectTo) and
417                 operation.name_lower == dependency[1].lower() and
418                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
419             )
420         # Field is removed and part of an index/unique_together
421         elif dependency[2] is not None and dependency[3] == "foo_together_change":
422             return (
423                 isinstance(operation, (operations.AlterUniqueTogether,
424                                        operations.AlterIndexTogether)) and
425                 operation.name_lower == dependency[1].lower()
426             )
427         # Unknown dependency. Raise an error.
428         else:
429             raise ValueError("Can't handle dependency %r" % (dependency,))
430 
431     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
432         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
433         operation._auto_deps = dependencies or []
434         if beginning:
435             self.generated_operations.setdefault(app_label, []).insert(0, operation)
436         else:
437             self.generated_operations.setdefault(app_label, []).append(operation)
438 
439     def swappable_first_key(self, item):
440         """
441         Place potential swappable models first in lists of created models (only
442         real way to solve #22783).
443         """
444         try:
445             model_state = self.to_state.models[item]
446             base_names = {
447                 base if isinstance(base, str) else base.__name__
448                 for base in model_state.bases
449             }
450             string_version = "%s.%s" % (item[0], item[1])
451             if (
452                 model_state.options.get('swappable') or
453                 "AbstractUser" in base_names or
454                 "AbstractBaseUser" in base_names or
455                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
456             ):
457                 return ("___" + item[0], "___" + item[1])
458         except LookupError:
459             pass
460         return item
461 
462     def generate_renamed_models(self):
463         """
464         Find any renamed models, generate the operations for them, and remove
465         the old entry from the model lists. Must be run before other
466         model-level generation.
467         """
468         self.renamed_models = {}
469         self.renamed_models_rel = {}
470         added_models = self.new_model_keys - self.old_model_keys
471         for app_label, model_name in sorted(added_models):
472             model_state = self.to_state.models[app_label, model_name]
473             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
474 
475             removed_models = self.old_model_keys - self.new_model_keys
476             for rem_app_label, rem_model_name in removed_models:
477                 if rem_app_label == app_label:
478                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
479                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
480                     if model_fields_def == rem_model_fields_def:
481                         if self.questioner.ask_rename_model(rem_model_state, model_state):
482                             dependencies = []
483                             fields = list(model_state.fields.values()) + [
484                                 field.remote_field
485                                 for relations in self.to_state.relations[app_label, model_name].values()
486                                 for field in relations.values()
487                             ]
488                             for field in fields:
489                                 if field.is_relation:
490                                     dependencies.extend(
491                                         self._get_dependencies_for_foreign_key(
492                                             app_label, model_name, field, self.to_state,
493                                         )
494                                     )
495                             self.add_operation(
496                                 app_label,
497                                 operations.RenameModel(
498                                     old_name=rem_model_state.name,
499                                     new_name=model_state.name,
500                                 ),
501                                 dependencies=dependencies,
502                             )
503                             self.renamed_models[app_label, model_name] = rem_model_name
504                             renamed_models_rel_key = '%s.%s' % (
505                                 rem_model_state.app_label,
506                                 rem_model_state.name_lower,
507                             )
508                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
509                                 model_state.app_label,
510                                 model_state.name_lower,
511                             )
512                             self.old_model_keys.remove((rem_app_label, rem_model_name))
513                             self.old_model_keys.add((app_label, model_name))
514                             break
515 
516     def generate_created_models(self):
517         """
518         Find all new models (both managed and unmanaged) and make create
519         operations for them as well as separate operations to create any
520         foreign key or M2M relationships (these are optimized later, if
521         possible).
522 
523         Defer any model options that refer to collections of fields that might
524         be deferred (e.g. unique_together, index_together).
525         """
526         old_keys = self.old_model_keys | self.old_unmanaged_keys
527         added_models = self.new_model_keys - old_keys
528         added_unmanaged_models = self.new_unmanaged_keys - old_keys
529         all_added_models = chain(
530             sorted(added_models, key=self.swappable_first_key, reverse=True),
531             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
532         )
533         for app_label, model_name in all_added_models:
534             model_state = self.to_state.models[app_label, model_name]
535             # Gather related fields
536             related_fields = {}
537             primary_key_rel = None
538             for field_name, field in model_state.fields.items():
539                 if field.remote_field:
540                     if field.remote_field.model:
541                         if field.primary_key:
542                             primary_key_rel = field.remote_field.model
543                         elif not field.remote_field.parent_link:
544                             related_fields[field_name] = field
545                     if getattr(field.remote_field, 'through', None):
546                         related_fields[field_name] = field
547 
548             # Are there indexes/unique|index_together to defer?
549             indexes = model_state.options.pop('indexes')
550             constraints = model_state.options.pop('constraints')
551             unique_together = model_state.options.pop('unique_together', None)
552             index_together = model_state.options.pop('index_together', None)
553             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
554             # Depend on the deletion of any possible proxy version of us
555             dependencies = [
556                 (app_label, model_name, None, False),
557             ]
558             # Depend on all bases
559             for base in model_state.bases:
560                 if isinstance(base, str) and "." in base:
561                     base_app_label, base_name = base.split(".", 1)
562                     dependencies.append((base_app_label, base_name, None, True))
563                     # Depend on the removal of base fields if the new model has
564                     # a field with the same name.
565                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
566                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
567                     if old_base_model_state and new_base_model_state:
568                         removed_base_fields = set(old_base_model_state.fields).difference(
569                             new_base_model_state.fields,
570                         ).intersection(model_state.fields)
571                         for removed_base_field in removed_base_fields:
572                             dependencies.append((base_app_label, base_name, removed_base_field, False))
573             # Depend on the other end of the primary key if it's a relation
574             if primary_key_rel:
575                 dependencies.append(
576                     resolve_relation(
577                         primary_key_rel, app_label, model_name,
578                     ) + (None, True)
579                 )
580             # Generate creation operation
581             self.add_operation(
582                 app_label,
583                 operations.CreateModel(
584                     name=model_state.name,
585                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
586                     options=model_state.options,
587                     bases=model_state.bases,
588                     managers=model_state.managers,
589                 ),
590                 dependencies=dependencies,
591                 beginning=True,
592             )
593 
594             # Don't add operations which modify the database for unmanaged models
595             if not model_state.options.get('managed', True):
596                 continue
597 
598             # Generate operations for each related field
599             for name, field in sorted(related_fields.items()):
600                 dependencies = self._get_dependencies_for_foreign_key(
601                     app_label, model_name, field, self.to_state,
602                 )
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             relations = self.to_state.relations
672             if (app_label, model_name) in self.old_proxy_keys:
673                 for related_model_key, related_fields in relations[app_label, model_name].items():
674                     related_model_state = self.to_state.models[related_model_key]
675                     for related_field_name, related_field in related_fields.items():
676                         self.add_operation(
677                             related_model_state.app_label,
678                             operations.AlterField(
679                                 model_name=related_model_state.name,
680                                 name=related_field_name,
681                                 field=related_field,
682                             ),
683                             dependencies=[(app_label, model_name, None, True)],
684                         )
685 
686     def generate_created_proxies(self):
687         """
688         Make CreateModel statements for proxy models. Use the same statements
689         as that way there's less code duplication, but for proxy models it's
690         safe to skip all the pointless field stuff and chuck out an operation.
691         """
692         added = self.new_proxy_keys - self.old_proxy_keys
693         for app_label, model_name in sorted(added):
694             model_state = self.to_state.models[app_label, model_name]
695             assert model_state.options.get("proxy")
696             # Depend on the deletion of any possible non-proxy version of us
697             dependencies = [
698                 (app_label, model_name, None, False),
699             ]
700             # Depend on all bases
701             for base in model_state.bases:
702                 if isinstance(base, str) and "." in base:
703                     base_app_label, base_name = base.split(".", 1)
704                     dependencies.append((base_app_label, base_name, None, True))
705             # Generate creation operation
706             self.add_operation(
707                 app_label,
708                 operations.CreateModel(
709                     name=model_state.name,
710                     fields=[],
711                     options=model_state.options,
712                     bases=model_state.bases,
713                     managers=model_state.managers,
714                 ),
715                 # Depend on the deletion of any possible non-proxy version of us
716                 dependencies=dependencies,
717             )
718 
719     def generate_deleted_models(self):
720         """
721         Find all deleted models (managed and unmanaged) and make delete
722         operations for them as well as separate operations to delete any
723         foreign key or M2M relationships (these are optimized later, if
724         possible).
725 
726         Also bring forward removal of any model options that refer to
727         collections of fields - the inverse of generate_created_models().
728         """
729         new_keys = self.new_model_keys | self.new_unmanaged_keys
730         deleted_models = self.old_model_keys - new_keys
731         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
732         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
733         for app_label, model_name in all_deleted_models:
734             model_state = self.from_state.models[app_label, model_name]
735             # Gather related fields
736             related_fields = {}
737             for field_name, field in model_state.fields.items():
738                 if field.remote_field:
739                     if field.remote_field.model:
740                         related_fields[field_name] = field
741                     if getattr(field.remote_field, 'through', None):
742                         related_fields[field_name] = field
743             # Generate option removal first
744             unique_together = model_state.options.pop('unique_together', None)
745             index_together = model_state.options.pop('index_together', None)
746             if unique_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterUniqueTogether(
750                         name=model_name,
751                         unique_together=None,
752                     )
753                 )
754             if index_together:
755                 self.add_operation(
756                     app_label,
757                     operations.AlterIndexTogether(
758                         name=model_name,
759                         index_together=None,
760                     )
761                 )
762             # Then remove each related field
763             for name in sorted(related_fields):
764                 self.add_operation(
765                     app_label,
766                     operations.RemoveField(
767                         model_name=model_name,
768                         name=name,
769                     )
770                 )
771             # Finally, remove the model.
772             # This depends on both the removal/alteration of all incoming fields
773             # and the removal of all its own related fields, and if it's
774             # a through model the field that references it.
775             dependencies = []
776             relations = self.from_state.relations
777             for (related_object_app_label, object_name), relation_related_fields in (
778                 relations[app_label, model_name].items()
779             ):
780                 for field_name, field in relation_related_fields.items():
781                     dependencies.append(
782                         (related_object_app_label, object_name, field_name, False),
783                     )
784                     if not field.many_to_many:
785                         dependencies.append(
786                             (related_object_app_label, object_name, field_name, 'alter'),
787                         )
788 
789             for name in sorted(related_fields):
790                 dependencies.append((app_label, model_name, name, False))
791             # We're referenced in another field's through=
792             through_user = self.through_users.get((app_label, model_state.name_lower))
793             if through_user:
794                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
795             # Finally, make the operation, deduping any dependencies
796             self.add_operation(
797                 app_label,
798                 operations.DeleteModel(
799                     name=model_state.name,
800                 ),
801                 dependencies=list(set(dependencies)),
802             )
803 
804     def generate_deleted_proxies(self):
805         """Make DeleteModel options for proxy models."""
806         deleted = self.old_proxy_keys - self.new_proxy_keys
807         for app_label, model_name in sorted(deleted):
808             model_state = self.from_state.models[app_label, model_name]
809             assert model_state.options.get("proxy")
810             self.add_operation(
811                 app_label,
812                 operations.DeleteModel(
813                     name=model_state.name,
814                 ),
815             )
816 
817     def generate_renamed_fields(self):
818         """Work out renamed fields."""
819         self.renamed_fields = {}
820         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
821             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
822             old_model_state = self.from_state.models[app_label, old_model_name]
823             new_model_state = self.to_state.models[app_label, old_model_name]
824             field = new_model_state.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.get_field(rem_field_name)
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.to_state.models[app_label, model_name].get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(
867                 app_label, model_name, field, self.to_state,
868             ))
869         # You can't just add NOT NULL fields with no default or fields
870         # which don't allow empty strings as default.
871         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
872         preserve_default = (
873             field.null or field.has_default() or field.many_to_many or
874             (field.blank and field.empty_strings_allowed) or
875             (isinstance(field, time_fields) and field.auto_now)
876         )
877         if not preserve_default:
878             field = field.clone()
879             if isinstance(field, time_fields) and field.auto_now_add:
880                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
881             else:
882                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
883         if (
884             field.unique and
885             field.default is not models.NOT_PROVIDED and
886             callable(field.default)
887         ):
888             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
889         self.add_operation(
890             app_label,
891             operations.AddField(
892                 model_name=model_name,
893                 name=field_name,
894                 field=field,
895                 preserve_default=preserve_default,
896             ),
897             dependencies=dependencies,
898         )
899 
900     def generate_removed_fields(self):
901         """Make RemoveField operations."""
902         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
903             self._generate_removed_field(app_label, model_name, field_name)
904 
905     def _generate_removed_field(self, app_label, model_name, field_name):
906         self.add_operation(
907             app_label,
908             operations.RemoveField(
909                 model_name=model_name,
910                 name=field_name,
911             ),
912             # We might need to depend on the removal of an
913             # order_with_respect_to or index/unique_together operation;
914             # this is safely ignored if there isn't one
915             dependencies=[
916                 (app_label, model_name, field_name, "order_wrt_unset"),
917                 (app_label, model_name, field_name, "foo_together_change"),
918             ],
919         )
920 
921     def generate_altered_fields(self):
922         """
923         Make AlterField operations, or possibly RemovedField/AddField if alter
924         isn't possible.
925         """
926         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
927             # Did the field change?
928             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
929             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
930             old_field = self.from_state.models[app_label, old_model_name].get_field(old_field_name)
931             new_field = self.to_state.models[app_label, model_name].get_field(field_name)
932             dependencies = []
933             # Implement any model renames on relations; these are handled by RenameModel
934             # so we need to exclude them from the comparison
935             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
936                 rename_key = resolve_relation(new_field.remote_field.model, app_label, model_name)
937                 if rename_key in self.renamed_models:
938                     new_field.remote_field.model = old_field.remote_field.model
939                 # Handle ForeignKey which can only have a single to_field.
940                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
941                 if remote_field_name:
942                     to_field_rename_key = rename_key + (remote_field_name,)
943                     if to_field_rename_key in self.renamed_fields:
944                         # Repoint both model and field name because to_field
945                         # inclusion in ForeignKey.deconstruct() is based on
946                         # both.
947                         new_field.remote_field.model = old_field.remote_field.model
948                         new_field.remote_field.field_name = old_field.remote_field.field_name
949                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
950                 from_fields = getattr(new_field, 'from_fields', None)
951                 if from_fields:
952                     from_rename_key = (app_label, model_name)
953                     new_field.from_fields = tuple([
954                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
955                         for from_field in from_fields
956                     ])
957                     new_field.to_fields = tuple([
958                         self.renamed_fields.get(rename_key + (to_field,), to_field)
959                         for to_field in new_field.to_fields
960                     ])
961                 dependencies.extend(self._get_dependencies_for_foreign_key(
962                     app_label, model_name, new_field, self.to_state,
963                 ))
964             if (
965                 hasattr(new_field, 'remote_field') and
966                 getattr(new_field.remote_field, 'through', None)
967             ):
968                 rename_key = resolve_relation(new_field.remote_field.through, app_label, model_name)
969                 if rename_key in self.renamed_models:
970                     new_field.remote_field.through = old_field.remote_field.through
971             old_field_dec = self.deep_deconstruct(old_field)
972             new_field_dec = self.deep_deconstruct(new_field)
973             if old_field_dec != new_field_dec:
974                 both_m2m = old_field.many_to_many and new_field.many_to_many
975                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
976                 if both_m2m or neither_m2m:
977                     # Either both fields are m2m or neither is
978                     preserve_default = True
979                     if (old_field.null and not new_field.null and not new_field.has_default() and
980                             not new_field.many_to_many):
981                         field = new_field.clone()
982                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
983                         if new_default is not models.NOT_PROVIDED:
984                             field.default = new_default
985                             preserve_default = False
986                     else:
987                         field = new_field
988                     self.add_operation(
989                         app_label,
990                         operations.AlterField(
991                             model_name=model_name,
992                             name=field_name,
993                             field=field,
994                             preserve_default=preserve_default,
995                         ),
996                         dependencies=dependencies,
997                     )
998                 else:
999                     # We cannot alter between m2m and concrete fields
1000                     self._generate_removed_field(app_label, model_name, field_name)
1001                     self._generate_added_field(app_label, model_name, field_name)
1002 
1003     def create_altered_indexes(self):
1004         option_name = operations.AddIndex.option_name
1005         for app_label, model_name in sorted(self.kept_model_keys):
1006             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1007             old_model_state = self.from_state.models[app_label, old_model_name]
1008             new_model_state = self.to_state.models[app_label, model_name]
1009 
1010             old_indexes = old_model_state.options[option_name]
1011             new_indexes = new_model_state.options[option_name]
1012             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1013             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1014 
1015             self.altered_indexes.update({
1016                 (app_label, model_name): {
1017                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1018                 }
1019             })
1020 
1021     def generate_added_indexes(self):
1022         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1023             for index in alt_indexes['added_indexes']:
1024                 self.add_operation(
1025                     app_label,
1026                     operations.AddIndex(
1027                         model_name=model_name,
1028                         index=index,
1029                     )
1030                 )
1031 
1032     def generate_removed_indexes(self):
1033         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1034             for index in alt_indexes['removed_indexes']:
1035                 self.add_operation(
1036                     app_label,
1037                     operations.RemoveIndex(
1038                         model_name=model_name,
1039                         name=index.name,
1040                     )
1041                 )
1042 
1043     def create_altered_constraints(self):
1044         option_name = operations.AddConstraint.option_name
1045         for app_label, model_name in sorted(self.kept_model_keys):
1046             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1047             old_model_state = self.from_state.models[app_label, old_model_name]
1048             new_model_state = self.to_state.models[app_label, model_name]
1049 
1050             old_constraints = old_model_state.options[option_name]
1051             new_constraints = new_model_state.options[option_name]
1052             add_constraints = [c for c in new_constraints if c not in old_constraints]
1053             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1054 
1055             self.altered_constraints.update({
1056                 (app_label, model_name): {
1057                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1058                 }
1059             })
1060 
1061     def generate_added_constraints(self):
1062         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1063             for constraint in alt_constraints['added_constraints']:
1064                 self.add_operation(
1065                     app_label,
1066                     operations.AddConstraint(
1067                         model_name=model_name,
1068                         constraint=constraint,
1069                     )
1070                 )
1071 
1072     def generate_removed_constraints(self):
1073         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1074             for constraint in alt_constraints['removed_constraints']:
1075                 self.add_operation(
1076                     app_label,
1077                     operations.RemoveConstraint(
1078                         model_name=model_name,
1079                         name=constraint.name,
1080                     )
1081                 )
1082 
1083     @staticmethod
1084     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1085         remote_field_model = None
1086         if hasattr(field.remote_field, 'model'):
1087             remote_field_model = field.remote_field.model
1088         else:
1089             relations = project_state.relations[app_label, model_name]
1090             for (remote_app_label, remote_model_name), fields in relations.items():
1091                 if any(
1092                     field == related_field.remote_field
1093                     for related_field in fields.values()
1094                 ):
1095                     remote_field_model = f'{remote_app_label}.{remote_model_name}'
1096                     break
1097         # Account for FKs to swappable models
1098         swappable_setting = getattr(field, 'swappable_setting', None)
1099         if swappable_setting is not None:
1100             dep_app_label = "__setting__"
1101             dep_object_name = swappable_setting
1102         else:
1103             dep_app_label, dep_object_name = resolve_relation(
1104                 remote_field_model, app_label, model_name,
1105             )
1106         dependencies = [(dep_app_label, dep_object_name, None, True)]
1107         if getattr(field.remote_field, 'through', None):
1108             through_app_label, through_object_name = resolve_relation(
1109                 remote_field_model, app_label, model_name,
1110             )
1111             dependencies.append((through_app_label, through_object_name, None, True))
1112         return dependencies
1113 
1114     def _generate_altered_foo_together(self, operation):
1115         option_name = operation.option_name
1116         for app_label, model_name in sorted(self.kept_model_keys):
1117             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1118             old_model_state = self.from_state.models[app_label, old_model_name]
1119             new_model_state = self.to_state.models[app_label, model_name]
1120 
1121             # We run the old version through the field renames to account for those
1122             old_value = old_model_state.options.get(option_name)
1123             old_value = {
1124                 tuple(
1125                     self.renamed_fields.get((app_label, model_name, n), n)
1126                     for n in unique
1127                 )
1128                 for unique in old_value
1129             } if old_value else set()
1130 
1131             new_value = new_model_state.options.get(option_name)
1132             new_value = set(new_value) if new_value else set()
1133 
1134             if old_value != new_value:
1135                 dependencies = []
1136                 for foo_togethers in new_value:
1137                     for field_name in foo_togethers:
1138                         field = new_model_state.get_field(field_name)
1139                         if field.remote_field and field.remote_field.model:
1140                             dependencies.extend(self._get_dependencies_for_foreign_key(
1141                                 app_label, model_name, field, self.to_state,
1142                             ))
1143 
1144                 self.add_operation(
1145                     app_label,
1146                     operation(
1147                         name=model_name,
1148                         **{option_name: new_value}
1149                     ),
1150                     dependencies=dependencies,
1151                 )
1152 
1153     def generate_altered_unique_together(self):
1154         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1155 
1156     def generate_altered_index_together(self):
1157         self._generate_altered_foo_together(operations.AlterIndexTogether)
1158 
1159     def generate_altered_db_table(self):
1160         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1161         for app_label, model_name in sorted(models_to_check):
1162             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1163             old_model_state = self.from_state.models[app_label, old_model_name]
1164             new_model_state = self.to_state.models[app_label, model_name]
1165             old_db_table_name = old_model_state.options.get('db_table')
1166             new_db_table_name = new_model_state.options.get('db_table')
1167             if old_db_table_name != new_db_table_name:
1168                 self.add_operation(
1169                     app_label,
1170                     operations.AlterModelTable(
1171                         name=model_name,
1172                         table=new_db_table_name,
1173                     )
1174                 )
1175 
1176     def generate_altered_options(self):
1177         """
1178         Work out if any non-schema-affecting options have changed and make an
1179         operation to represent them in state changes (in case Python code in
1180         migrations needs them).
1181         """
1182         models_to_check = self.kept_model_keys.union(
1183             self.kept_proxy_keys,
1184             self.kept_unmanaged_keys,
1185             # unmanaged converted to managed
1186             self.old_unmanaged_keys & self.new_model_keys,
1187             # managed converted to unmanaged
1188             self.old_model_keys & self.new_unmanaged_keys,
1189         )
1190 
1191         for app_label, model_name in sorted(models_to_check):
1192             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1193             old_model_state = self.from_state.models[app_label, old_model_name]
1194             new_model_state = self.to_state.models[app_label, model_name]
1195             old_options = {
1196                 key: value for key, value in old_model_state.options.items()
1197                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1198             }
1199             new_options = {
1200                 key: value for key, value in new_model_state.options.items()
1201                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1202             }
1203             if old_options != new_options:
1204                 self.add_operation(
1205                     app_label,
1206                     operations.AlterModelOptions(
1207                         name=model_name,
1208                         options=new_options,
1209                     )
1210                 )
1211 
1212     def generate_altered_order_with_respect_to(self):
1213         for app_label, model_name in sorted(self.kept_model_keys):
1214             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1215             old_model_state = self.from_state.models[app_label, old_model_name]
1216             new_model_state = self.to_state.models[app_label, model_name]
1217             if (old_model_state.options.get("order_with_respect_to") !=
1218                     new_model_state.options.get("order_with_respect_to")):
1219                 # Make sure it comes second if we're adding
1220                 # (removal dependency is part of RemoveField)
1221                 dependencies = []
1222                 if new_model_state.options.get("order_with_respect_to"):
1223                     dependencies.append((
1224                         app_label,
1225                         model_name,
1226                         new_model_state.options["order_with_respect_to"],
1227                         True,
1228                     ))
1229                 # Actually generate the operation
1230                 self.add_operation(
1231                     app_label,
1232                     operations.AlterOrderWithRespectTo(
1233                         name=model_name,
1234                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1235                     ),
1236                     dependencies=dependencies,
1237                 )
1238 
1239     def generate_altered_managers(self):
1240         for app_label, model_name in sorted(self.kept_model_keys):
1241             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1242             old_model_state = self.from_state.models[app_label, old_model_name]
1243             new_model_state = self.to_state.models[app_label, model_name]
1244             if old_model_state.managers != new_model_state.managers:
1245                 self.add_operation(
1246                     app_label,
1247                     operations.AlterModelManagers(
1248                         name=model_name,
1249                         managers=new_model_state.managers,
1250                     )
1251                 )
1252 
1253     def arrange_for_graph(self, changes, graph, migration_name=None):
1254         """
1255         Take a result from changes() and a MigrationGraph, and fix the names
1256         and dependencies of the changes so they extend the graph from the leaf
1257         nodes for each app.
1258         """
1259         leaves = graph.leaf_nodes()
1260         name_map = {}
1261         for app_label, migrations in list(changes.items()):
1262             if not migrations:
1263                 continue
1264             # Find the app label's current leaf node
1265             app_leaf = None
1266             for leaf in leaves:
1267                 if leaf[0] == app_label:
1268                     app_leaf = leaf
1269                     break
1270             # Do they want an initial migration for this app?
1271             if app_leaf is None and not self.questioner.ask_initial(app_label):
1272                 # They don't.
1273                 for migration in migrations:
1274                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1275                 del changes[app_label]
1276                 continue
1277             # Work out the next number in the sequence
1278             if app_leaf is None:
1279                 next_number = 1
1280             else:
1281                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1282             # Name each migration
1283             for i, migration in enumerate(migrations):
1284                 if i == 0 and app_leaf:
1285                     migration.dependencies.append(app_leaf)
1286                 new_name_parts = ['%04i' % next_number]
1287                 if migration_name:
1288                     new_name_parts.append(migration_name)
1289                 elif i == 0 and not app_leaf:
1290                     new_name_parts.append('initial')
1291                 else:
1292                     new_name_parts.append(migration.suggest_name()[:100])
1293                 new_name = '_'.join(new_name_parts)
1294                 name_map[(app_label, migration.name)] = (app_label, new_name)
1295                 next_number += 1
1296                 migration.name = new_name
1297         # Now fix dependencies
1298         for migrations in changes.values():
1299             for migration in migrations:
1300                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1301         return changes
1302 
1303     def _trim_to_apps(self, changes, app_labels):
1304         """
1305         Take changes from arrange_for_graph() and set of app labels, and return
1306         a modified set of changes which trims out as many migrations that are
1307         not in app_labels as possible. Note that some other migrations may
1308         still be present as they may be required dependencies.
1309         """
1310         # Gather other app dependencies in a first pass
1311         app_dependencies = {}
1312         for app_label, migrations in changes.items():
1313             for migration in migrations:
1314                 for dep_app_label, name in migration.dependencies:
1315                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1316         required_apps = set(app_labels)
1317         # Keep resolving till there's no change
1318         old_required_apps = None
1319         while old_required_apps != required_apps:
1320             old_required_apps = set(required_apps)
1321             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1322         # Remove all migrations that aren't needed
1323         for app_label in list(changes):
1324             if app_label not in required_apps:
1325                 del changes[app_label]
1326         return changes
1327 
1328     @classmethod
1329     def parse_number(cls, name):
1330         """
1331         Given a migration name, try to extract a number from the beginning of
1332         it. If no number is found, return None.
1333         """
1334         match = re.match(r'^\d+', name)
1335         if match:
1336             return int(match[0])
1337         return None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 03:36:43.469 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 03:36:43.469 | INFO     | Search-only: skipping patch selection
2025-10-15 03:36:43.607 | INFO     | Task django__django-14983 completed successfully.
2025-10-15 03:36:43.608 | INFO     | No patch generated. You can try running ACR again.
