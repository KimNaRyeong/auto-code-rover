[
    {
        "rel_file_path": "lib/matplotlib/figure.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/figure.py",
        "start": 3480,
        "end": 3518,
        "class_name": "Figure",
        "method_name": "tight_layout",
        "code": "3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):\n3481         \"\"\"\n3482         Adjust the padding between and around subplots.\n3483 \n3484         To exclude an artist on the Axes from the bounding box calculation\n3485         that determines the subplot parameters (i.e. legend, or annotation),\n3486         set ``a.set_in_layout(False)`` for that artist.\n3487 \n3488         Parameters\n3489         ----------\n3490         pad : float, default: 1.08\n3491             Padding between the figure edge and the edges of subplots,\n3492             as a fraction of the font size.\n3493         h_pad, w_pad : float, default: *pad*\n3494             Padding (height/width) between edges of adjacent subplots,\n3495             as a fraction of the font size.\n3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)\n3497             A rectangle in normalized figure coordinates into which the whole\n3498             subplots area (including labels) will fit.\n3499 \n3500         See Also\n3501         --------\n3502         .Figure.set_layout_engine\n3503         .pyplot.tight_layout\n3504         \"\"\"\n3505         # note that here we do not permanently set the figures engine to\n3506         # tight_layout but rather just perform the layout in place and remove\n3507         # any previous engines.\n3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,\n3509                                    rect=rect)\n3510         try:\n3511             previous_engine = self.get_layout_engine()\n3512             self.set_layout_engine(engine)\n3513             engine.execute(self)\n3514             if not isinstance(previous_engine, TightLayoutEngine) \\\n3515                     and previous_engine is not None:\n3516                 _api.warn_external('The figure layout has changed to tight')\n3517         finally:\n3518             self.set_layout_engine(None)\n",
        "intended_behavior": "This method should be modified to check if `figure.autolayout` is set to `True` and either incorporate the `kwargs` from `tight_layout` into the automatic layout calculations or provide a clear warning to the user that `tight_layout` parameters will be ignored due to `figure.autolayout` being enabled. This adjustment ensures that there is no silent failure or unexpected behavior when users attempt to use `tight_layout` with `figure.autolayout` set to `True`. The existing functionality of automatically adjusting the layout when `autolayout` is enabled should be preserved, but an additional check or mechanism should be added to respect or acknowledge `tight_layout` kwargs when also used."
    },
    {
        "rel_file_path": "lib/matplotlib/figure.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/figure.py",
        "start": 2329,
        "end": 3518,
        "class_name": "Figure",
        "method_name": null,
        "code": "2329 class Figure(FigureBase):\n2330     \"\"\"\n2331     The top level container for all the plot elements.\n2332 \n2333     Attributes\n2334     ----------\n2335     patch\n2336         The `.Rectangle` instance representing the figure background patch.\n2337 \n2338     suppressComposite\n2339         For multiple images, the figure will make composite images\n2340         depending on the renderer option_image_nocomposite function.  If\n2341         *suppressComposite* is a boolean, this will override the renderer.\n2342     \"\"\"\n2343     # Remove the self._fig_callbacks properties on figure and subfigure\n2344     # after the deprecation expires.\n2345     callbacks = _api.deprecated(\n2346         \"3.6\", alternative=(\"the 'resize_event' signal in \"\n2347                             \"Figure.canvas.callbacks\")\n2348         )(property(lambda self: self._fig_callbacks))\n2349 \n2350     def __str__(self):\n2351         return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n2352 \n2353     def __repr__(self):\n2354         return \"<{clsname} size {h:g}x{w:g} with {naxes} Axes>\".format(\n2355             clsname=self.__class__.__name__,\n2356             h=self.bbox.size[0], w=self.bbox.size[1],\n2357             naxes=len(self.axes),\n2358         )\n2359 \n2360     def __init__(self,\n2361                  figsize=None,\n2362                  dpi=None,\n2363                  *,\n2364                  facecolor=None,\n2365                  edgecolor=None,\n2366                  linewidth=0.0,\n2367                  frameon=None,\n2368                  subplotpars=None,  # rc figure.subplot.*\n2369                  tight_layout=None,  # rc figure.autolayout\n2370                  constrained_layout=None,  # rc figure.constrained_layout.use\n2371                  layout=None,\n2372                  **kwargs\n2373                  ):\n2374         \"\"\"\n2375         Parameters\n2376         ----------\n2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`\n2378             Figure dimension ``(width, height)`` in inches.\n2379 \n2380         dpi : float, default: :rc:`figure.dpi`\n2381             Dots per inch.\n2382 \n2383         facecolor : default: :rc:`figure.facecolor`\n2384             The figure patch facecolor.\n2385 \n2386         edgecolor : default: :rc:`figure.edgecolor`\n2387             The figure patch edge color.\n2388 \n2389         linewidth : float\n2390             The linewidth of the frame (i.e. the edge linewidth of the figure\n2391             patch).\n2392 \n2393         frameon : bool, default: :rc:`figure.frameon`\n2394             If ``False``, suppress drawing the figure background patch.\n2395 \n2396         subplotpars : `SubplotParams`\n2397             Subplot parameters. If not given, the default subplot\n2398             parameters :rc:`figure.subplot.*` are used.\n2399 \n2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`\n2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.\n2402 \n2403             .. admonition:: Discouraged\n2404 \n2405                 The use of this parameter is discouraged. Please use\n2406                 ``layout='tight'`` instead for the common case of\n2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.\n2408 \n2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`\n2410             This is equal to ``layout='constrained'``.\n2411 \n2412             .. admonition:: Discouraged\n2413 \n2414                 The use of this parameter is discouraged. Please use\n2415                 ``layout='constrained'`` instead.\n2416 \n2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \\\n2418 None}, default: None\n2419             The layout mechanism for positioning of plot elements to avoid\n2420             overlapping Axes decorations (labels, ticks, etc). Note that\n2421             layout managers can have significant performance penalties.\n2422 \n2423             - 'constrained': The constrained layout solver adjusts axes sizes\n2424               to avoid overlapping axes decorations.  Can handle complex plot\n2425               layouts and colorbars, and is thus recommended.\n2426 \n2427               See :ref:`constrainedlayout_guide`\n2428               for examples.\n2429 \n2430             - 'compressed': uses the same algorithm as 'constrained', but\n2431               removes extra space between fixed-aspect-ratio Axes.  Best for\n2432               simple grids of axes.\n2433 \n2434             - 'tight': Use the tight layout mechanism. This is a relatively\n2435               simple algorithm that adjusts the subplot parameters so that\n2436               decorations do not overlap. See `.Figure.set_tight_layout` for\n2437               further details.\n2438 \n2439             - 'none': Do not use a layout engine.\n2440 \n2441             - A `.LayoutEngine` instance. Builtin layout classes are\n2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily\n2443               accessible by 'constrained' and 'tight'.  Passing an instance\n2444               allows third parties to provide their own layout engine.\n2445 \n2446             If not given, fall back to using the parameters *tight_layout* and\n2447             *constrained_layout*, including their config defaults\n2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.\n2449 \n2450         Other Parameters\n2451         ----------------\n2452         **kwargs : `.Figure` properties, optional\n2453 \n2454             %(Figure:kwdoc)s\n2455         \"\"\"\n2456         super().__init__(**kwargs)\n2457         self._layout_engine = None\n2458 \n2459         if layout is not None:\n2460             if (tight_layout is not None):\n2461                 _api.warn_external(\n2462                     \"The Figure parameters 'layout' and 'tight_layout' cannot \"\n2463                     \"be used together. Please use 'layout' only.\")\n2464             if (constrained_layout is not None):\n2465                 _api.warn_external(\n2466                     \"The Figure parameters 'layout' and 'constrained_layout' \"\n2467                     \"cannot be used together. Please use 'layout' only.\")\n2468             self.set_layout_engine(layout=layout)\n2469         elif tight_layout is not None:\n2470             if constrained_layout is not None:\n2471                 _api.warn_external(\n2472                     \"The Figure parameters 'tight_layout' and \"\n2473                     \"'constrained_layout' cannot be used together. Please use \"\n2474                     \"'layout' parameter\")\n2475             self.set_layout_engine(layout='tight')\n2476             if isinstance(tight_layout, dict):\n2477                 self.get_layout_engine().set(**tight_layout)\n2478         elif constrained_layout is not None:\n2479             if isinstance(constrained_layout, dict):\n2480                 self.set_layout_engine(layout='constrained')\n2481                 self.get_layout_engine().set(**constrained_layout)\n2482             elif constrained_layout:\n2483                 self.set_layout_engine(layout='constrained')\n2484 \n2485         else:\n2486             # everything is None, so use default:\n2487             self.set_layout_engine(layout=layout)\n2488 \n2489         self._fig_callbacks = cbook.CallbackRegistry(signals=[\"dpi_changed\"])\n2490         # Callbacks traditionally associated with the canvas (and exposed with\n2491         # a proxy property), but that actually need to be on the figure for\n2492         # pickling.\n2493         self._canvas_callbacks = cbook.CallbackRegistry(\n2494             signals=FigureCanvasBase.events)\n2495         connect = self._canvas_callbacks._connect_picklable\n2496         self._mouse_key_ids = [\n2497             connect('key_press_event', backend_bases._key_handler),\n2498             connect('key_release_event', backend_bases._key_handler),\n2499             connect('key_release_event', backend_bases._key_handler),\n2500             connect('button_press_event', backend_bases._mouse_handler),\n2501             connect('button_release_event', backend_bases._mouse_handler),\n2502             connect('scroll_event', backend_bases._mouse_handler),\n2503             connect('motion_notify_event', backend_bases._mouse_handler),\n2504         ]\n2505         self._button_pick_id = connect('button_press_event', self.pick)\n2506         self._scroll_pick_id = connect('scroll_event', self.pick)\n2507 \n2508         if figsize is None:\n2509             figsize = mpl.rcParams['figure.figsize']\n2510         if dpi is None:\n2511             dpi = mpl.rcParams['figure.dpi']\n2512         if facecolor is None:\n2513             facecolor = mpl.rcParams['figure.facecolor']\n2514         if edgecolor is None:\n2515             edgecolor = mpl.rcParams['figure.edgecolor']\n2516         if frameon is None:\n2517             frameon = mpl.rcParams['figure.frameon']\n2518 \n2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():\n2520             raise ValueError('figure size must be positive finite not '\n2521                              f'{figsize}')\n2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n2523 \n2524         self.dpi_scale_trans = Affine2D().scale(dpi)\n2525         # do not use property as it will trigger\n2526         self._dpi = dpi\n2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n2528         self.figbbox = self.bbox\n2529         self.transFigure = BboxTransformTo(self.bbox)\n2530         self.transSubfigure = self.transFigure\n2531 \n2532         self.patch = Rectangle(\n2533             xy=(0, 0), width=1, height=1, visible=frameon,\n2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n2535             # Don't let the figure patch influence bbox calculation.\n2536             in_layout=False)\n2537         self._set_artist_props(self.patch)\n2538         self.patch.set_antialiased(False)\n2539 \n2540         FigureCanvasBase(self)  # Set self.canvas.\n2541 \n2542         if subplotpars is None:\n2543             subplotpars = SubplotParams()\n2544 \n2545         self.subplotpars = subplotpars\n2546 \n2547         self._axstack = _AxesStack()  # track all figure axes and current axes\n2548         self.clear()\n2549 \n2550     def pick(self, mouseevent):\n2551         if not self.canvas.widgetlock.locked():\n2552             super().pick(mouseevent)\n2553 \n2554     def _check_layout_engines_compat(self, old, new):\n2555         \"\"\"\n2556         Helper for set_layout engine\n2557 \n2558         If the figure has used the old engine and added a colorbar then the\n2559         value of colorbar_gridspec must be the same on the new engine.\n2560         \"\"\"\n2561         if old is None or new is None:\n2562             return True\n2563         if old.colorbar_gridspec == new.colorbar_gridspec:\n2564             return True\n2565         # colorbar layout different, so check if any colorbars are on the\n2566         # figure...\n2567         for ax in self.axes:\n2568             if hasattr(ax, '_colorbar'):\n2569                 # colorbars list themselves as a colorbar.\n2570                 return False\n2571         return True\n2572 \n2573     def set_layout_engine(self, layout=None, **kwargs):\n2574         \"\"\"\n2575         Set the layout engine for this figure.\n2576 \n2577         Parameters\n2578         ----------\n2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \\\n2580 `LayoutEngine` or None\n2581 \n2582             - 'constrained' will use `~.ConstrainedLayoutEngine`\n2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with\n2584               a correction that attempts to make a good layout for fixed-aspect\n2585               ratio Axes.\n2586             - 'tight' uses `~.TightLayoutEngine`\n2587             - 'none' removes layout engine.\n2588 \n2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`\n2590             (which if `True` behaves as if 'tight' was passed) and\n2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if\n2592             'constrained' was passed).  If both are `True`,\n2593             :rc:`figure.autolayout` takes priority.\n2594 \n2595             Users and libraries can define their own layout engines and pass\n2596             the instance directly as well.\n2597 \n2598         kwargs: dict\n2599             The keyword arguments are passed to the layout engine to set things\n2600             like padding and margin sizes.  Only used if *layout* is a string.\n2601 \n2602         \"\"\"\n2603         if layout is None:\n2604             if mpl.rcParams['figure.autolayout']:\n2605                 layout = 'tight'\n2606             elif mpl.rcParams['figure.constrained_layout.use']:\n2607                 layout = 'constrained'\n2608             else:\n2609                 self._layout_engine = None\n2610                 return\n2611         if layout == 'tight':\n2612             new_layout_engine = TightLayoutEngine(**kwargs)\n2613         elif layout == 'constrained':\n2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n2615         elif layout == 'compressed':\n2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n2617                                                         **kwargs)\n2618         elif layout == 'none':\n2619             if self._layout_engine is not None:\n2620                 new_layout_engine = PlaceHolderLayoutEngine(\n2621                     self._layout_engine.adjust_compatible,\n2622                     self._layout_engine.colorbar_gridspec\n2623                 )\n2624             else:\n2625                 new_layout_engine = None\n2626         elif isinstance(layout, LayoutEngine):\n2627             new_layout_engine = layout\n2628         else:\n2629             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n2630 \n2631         if self._check_layout_engines_compat(self._layout_engine,\n2632                                              new_layout_engine):\n2633             self._layout_engine = new_layout_engine\n2634         else:\n2635             raise RuntimeError('Colorbar layout of new layout engine not '\n2636                                'compatible with old engine, and a colorbar '\n2637                                'has been created.  Engine not changed.')\n2638 \n2639     def get_layout_engine(self):\n2640         return self._layout_engine\n2641 \n2642     # TODO: I'd like to dynamically add the _repr_html_ method\n2643     # to the figure in the right context, but then IPython doesn't\n2644     # use it, for some reason.\n2645 \n2646     def _repr_html_(self):\n2647         # We can't use \"isinstance\" here, because then we'd end up importing\n2648         # webagg unconditionally.\n2649         if 'WebAgg' in type(self.canvas).__name__:\n2650             from matplotlib.backends import backend_webagg\n2651             return backend_webagg.ipython_inline_display(self)\n2652 \n2653     def show(self, warn=True):\n2654         \"\"\"\n2655         If using a GUI backend with pyplot, display the figure window.\n2656 \n2657         If the figure was not created using `~.pyplot.figure`, it will lack\n2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an\n2659         AttributeError.\n2660 \n2661         .. warning::\n2662 \n2663             This does not manage an GUI event loop. Consequently, the figure\n2664             may only be shown briefly or not shown at all if you or your\n2665             environment are not managing an event loop.\n2666 \n2667             Use cases for `.Figure.show` include running this from a GUI\n2668             application (where there is persistently an event loop running) or\n2669             from a shell, like IPython, that install an input hook to allow the\n2670             interactive shell to accept input while the figure is also being\n2671             shown and interactive.  Some, but not all, GUI toolkits will\n2672             register an input hook on import.  See :ref:`cp_integration` for\n2673             more details.\n2674 \n2675             If you're in a shell without input hook integration or executing a\n2676             python script, you should use `matplotlib.pyplot.show` with\n2677             ``block=True`` instead, which takes care of starting and running\n2678             the event loop for you.\n2679 \n2680         Parameters\n2681         ----------\n2682         warn : bool, default: True\n2683             If ``True`` and we are not running headless (i.e. on Linux with an\n2684             unset DISPLAY), issue warning when called on a non-GUI backend.\n2685 \n2686         \"\"\"\n2687         if self.canvas.manager is None:\n2688             raise AttributeError(\n2689                 \"Figure.show works only for figures managed by pyplot, \"\n2690                 \"normally created by pyplot.figure()\")\n2691         try:\n2692             self.canvas.manager.show()\n2693         except NonGuiException as exc:\n2694             if warn:\n2695                 _api.warn_external(str(exc))\n2696 \n2697     @property\n2698     def axes(self):\n2699         \"\"\"\n2700         List of Axes in the Figure. You can access and modify the Axes in the\n2701         Figure through this list.\n2702 \n2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,\n2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.\n2705 \n2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are\n2707         equivalent.\n2708         \"\"\"\n2709         return self._axstack.as_list()\n2710 \n2711     get_axes = axes.fget\n2712 \n2713     def _get_renderer(self):\n2714         if hasattr(self.canvas, 'get_renderer'):\n2715             return self.canvas.get_renderer()\n2716         else:\n2717             return _get_renderer(self)\n2718 \n2719     def _get_dpi(self):\n2720         return self._dpi\n2721 \n2722     def _set_dpi(self, dpi, forward=True):\n2723         \"\"\"\n2724         Parameters\n2725         ----------\n2726         dpi : float\n2727 \n2728         forward : bool\n2729             Passed on to `~.Figure.set_size_inches`\n2730         \"\"\"\n2731         if dpi == self._dpi:\n2732             # We don't want to cause undue events in backends.\n2733             return\n2734         self._dpi = dpi\n2735         self.dpi_scale_trans.clear().scale(dpi)\n2736         w, h = self.get_size_inches()\n2737         self.set_size_inches(w, h, forward=forward)\n2738         self._fig_callbacks.process('dpi_changed', self)\n2739 \n2740     dpi = property(_get_dpi, _set_dpi, doc=\"The resolution in dots per inch.\")\n2741 \n2742     def get_tight_layout(self):\n2743         \"\"\"Return whether `.tight_layout` is called when drawing.\"\"\"\n2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)\n2745 \n2746     @_api.deprecated(\"3.6\", alternative=\"set_layout_engine\",\n2747                      pending=True)\n2748     def set_tight_layout(self, tight):\n2749         \"\"\"\n2750         [*Discouraged*] Set whether and how `.tight_layout` is called when\n2751         drawing.\n2752 \n2753         .. admonition:: Discouraged\n2754 \n2755             This method is discouraged in favor of `~.set_layout_engine`.\n2756 \n2757         Parameters\n2758         ----------\n2759         tight : bool or dict with keys \"pad\", \"w_pad\", \"h_pad\", \"rect\" or None\n2760             If a bool, sets whether to call `.tight_layout` upon drawing.\n2761             If ``None``, use :rc:`figure.autolayout` instead.\n2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the\n2763             default paddings.\n2764         \"\"\"\n2765         if tight is None:\n2766             tight = mpl.rcParams['figure.autolayout']\n2767         _tight = 'tight' if bool(tight) else 'none'\n2768         _tight_parameters = tight if isinstance(tight, dict) else {}\n2769         self.set_layout_engine(_tight, **_tight_parameters)\n2770         self.stale = True\n2771 \n2772     def get_constrained_layout(self):\n2773         \"\"\"\n2774         Return whether constrained layout is being used.\n2775 \n2776         See :ref:`constrainedlayout_guide`.\n2777         \"\"\"\n2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)\n2779 \n2780     @_api.deprecated(\"3.6\", alternative=\"set_layout_engine('constrained')\",\n2781                      pending=True)\n2782     def set_constrained_layout(self, constrained):\n2783         \"\"\"\n2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon\n2785         drawing.\n2786 \n2787         If None, :rc:`figure.constrained_layout.use` value will be used.\n2788 \n2789         When providing a dict containing the keys ``w_pad``, ``h_pad``\n2790         the default ``constrained_layout`` paddings will be\n2791         overridden.  These pads are in inches and default to 3.0/72.0.\n2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.\n2793 \n2794         .. admonition:: Discouraged\n2795 \n2796             This method is discouraged in favor of `~.set_layout_engine`.\n2797 \n2798         Parameters\n2799         ----------\n2800         constrained : bool or dict or None\n2801         \"\"\"\n2802         if constrained is None:\n2803             constrained = mpl.rcParams['figure.constrained_layout.use']\n2804         _constrained = 'constrained' if bool(constrained) else 'none'\n2805         _parameters = constrained if isinstance(constrained, dict) else {}\n2806         self.set_layout_engine(_constrained, **_parameters)\n2807         self.stale = True\n2808 \n2809     @_api.deprecated(\n2810          \"3.6\", alternative=\"figure.get_layout_engine().set()\",\n2811          pending=True)\n2812     def set_constrained_layout_pads(self, **kwargs):\n2813         \"\"\"\n2814         Set padding for ``constrained_layout``.\n2815 \n2816         Tip: The parameters can be passed from a dictionary by using\n2817         ``fig.set_constrained_layout(**pad_dict)``.\n2818 \n2819         See :ref:`constrainedlayout_guide`.\n2820 \n2821         Parameters\n2822         ----------\n2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`\n2824             Width padding in inches.  This is the pad around Axes\n2825             and is meant to make sure there is enough room for fonts to\n2826             look good.  Defaults to 3 pts = 0.04167 inches\n2827 \n2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`\n2829             Height padding in inches. Defaults to 3 pts.\n2830 \n2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`\n2832             Width padding between subplots, expressed as a fraction of the\n2833             subplot width.  The total padding ends up being w_pad + wspace.\n2834 \n2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`\n2836             Height padding between subplots, expressed as a fraction of the\n2837             subplot width. The total padding ends up being h_pad + hspace.\n2838 \n2839         \"\"\"\n2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):\n2841             self.get_layout_engine().set(**kwargs)\n2842 \n2843     @_api.deprecated(\"3.6\", alternative=\"fig.get_layout_engine().get()\",\n2844                      pending=True)\n2845     def get_constrained_layout_pads(self, relative=False):\n2846         \"\"\"\n2847         Get padding for ``constrained_layout``.\n2848 \n2849         Returns a list of ``w_pad, h_pad`` in inches and\n2850         ``wspace`` and ``hspace`` as fractions of the subplot.\n2851         All values are None if ``constrained_layout`` is not used.\n2852 \n2853         See :ref:`constrainedlayout_guide`.\n2854 \n2855         Parameters\n2856         ----------\n2857         relative : bool\n2858             If `True`, then convert from inches to figure relative.\n2859         \"\"\"\n2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):\n2861             return None, None, None, None\n2862         info = self.get_layout_engine().get_info()\n2863         w_pad = info['w_pad']\n2864         h_pad = info['h_pad']\n2865         wspace = info['wspace']\n2866         hspace = info['hspace']\n2867 \n2868         if relative and (w_pad is not None or h_pad is not None):\n2869             renderer = self._get_renderer()\n2870             dpi = renderer.dpi\n2871             w_pad = w_pad * dpi / renderer.width\n2872             h_pad = h_pad * dpi / renderer.height\n2873 \n2874         return w_pad, h_pad, wspace, hspace\n2875 \n2876     def set_canvas(self, canvas):\n2877         \"\"\"\n2878         Set the canvas that contains the figure\n2879 \n2880         Parameters\n2881         ----------\n2882         canvas : FigureCanvas\n2883         \"\"\"\n2884         self.canvas = canvas\n2885 \n2886     @_docstring.interpd\n2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,\n2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):\n2889         \"\"\"\n2890         Add a non-resampled image to the figure.\n2891 \n2892         The image is attached to the lower or upper left corner depending on\n2893         *origin*.\n2894 \n2895         Parameters\n2896         ----------\n2897         X\n2898             The image data. This is an array of one of the following shapes:\n2899 \n2900             - (M, N): an image with scalar data.  Color-mapping is controlled\n2901               by *cmap*, *norm*, *vmin*, and *vmax*.\n2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n2904               i.e. including transparency.\n2905 \n2906         xo, yo : int\n2907             The *x*/*y* image offset in pixels.\n2908 \n2909         alpha : None or float\n2910             The alpha blending value.\n2911 \n2912         %(cmap_doc)s\n2913 \n2914             This parameter is ignored if *X* is RGB(A).\n2915 \n2916         %(norm_doc)s\n2917 \n2918             This parameter is ignored if *X* is RGB(A).\n2919 \n2920         %(vmin_vmax_doc)s\n2921 \n2922             This parameter is ignored if *X* is RGB(A).\n2923 \n2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`\n2925             Indicates where the [0, 0] index of the array is in the upper left\n2926             or lower left corner of the axes.\n2927 \n2928         resize : bool\n2929             If *True*, resize the figure to match the given image size.\n2930 \n2931         Returns\n2932         -------\n2933         `matplotlib.image.FigureImage`\n2934 \n2935         Other Parameters\n2936         ----------------\n2937         **kwargs\n2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.\n2939 \n2940         Notes\n2941         -----\n2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)\n2943         which will be resampled to fit the current Axes.  If you want\n2944         a resampled image to fill the entire figure, you can define an\n2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].\n2946 \n2947         Examples\n2948         --------\n2949         ::\n2950 \n2951             f = plt.figure()\n2952             nx = int(f.get_figwidth() * f.dpi)\n2953             ny = int(f.get_figheight() * f.dpi)\n2954             data = np.random.random((ny, nx))\n2955             f.figimage(data)\n2956             plt.show()\n2957         \"\"\"\n2958         if resize:\n2959             dpi = self.get_dpi()\n2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]\n2961             self.set_size_inches(figsize, forward=True)\n2962 \n2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,\n2964                                 offsetx=xo, offsety=yo,\n2965                                 origin=origin, **kwargs)\n2966         im.stale_callback = _stale_figure_callback\n2967 \n2968         im.set_array(X)\n2969         im.set_alpha(alpha)\n2970         if norm is None:\n2971             im.set_clim(vmin, vmax)\n2972         self.images.append(im)\n2973         im._remove_method = self.images.remove\n2974         self.stale = True\n2975         return im\n2976 \n2977     def set_size_inches(self, w, h=None, forward=True):\n2978         \"\"\"\n2979         Set the figure size in inches.\n2980 \n2981         Call signatures::\n2982 \n2983              fig.set_size_inches(w, h)  # OR\n2984              fig.set_size_inches((w, h))\n2985 \n2986         Parameters\n2987         ----------\n2988         w : (float, float) or float\n2989             Width and height in inches (if height not specified as a separate\n2990             argument) or width.\n2991         h : float\n2992             Height in inches.\n2993         forward : bool, default: True\n2994             If ``True``, the canvas size is automatically updated, e.g.,\n2995             you can resize the figure window from the shell.\n2996 \n2997         See Also\n2998         --------\n2999         matplotlib.figure.Figure.get_size_inches\n3000         matplotlib.figure.Figure.set_figwidth\n3001         matplotlib.figure.Figure.set_figheight\n3002 \n3003         Notes\n3004         -----\n3005         To transform from pixels to inches divide by `Figure.dpi`.\n3006         \"\"\"\n3007         if h is None:  # Got called with a single pair as argument.\n3008             w, h = w\n3009         size = np.array([w, h])\n3010         if not np.isfinite(size).all() or (size < 0).any():\n3011             raise ValueError(f'figure size must be positive finite not {size}')\n3012         self.bbox_inches.p1 = size\n3013         if forward:\n3014             manager = self.canvas.manager\n3015             if manager is not None:\n3016                 manager.resize(*(size * self.dpi).astype(int))\n3017         self.stale = True\n3018 \n3019     def get_size_inches(self):\n3020         \"\"\"\n3021         Return the current size of the figure in inches.\n3022 \n3023         Returns\n3024         -------\n3025         ndarray\n3026            The size (width, height) of the figure in inches.\n3027 \n3028         See Also\n3029         --------\n3030         matplotlib.figure.Figure.set_size_inches\n3031         matplotlib.figure.Figure.get_figwidth\n3032         matplotlib.figure.Figure.get_figheight\n3033 \n3034         Notes\n3035         -----\n3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.\n3037         \"\"\"\n3038         return np.array(self.bbox_inches.p1)\n3039 \n3040     def get_figwidth(self):\n3041         \"\"\"Return the figure width in inches.\"\"\"\n3042         return self.bbox_inches.width\n3043 \n3044     def get_figheight(self):\n3045         \"\"\"Return the figure height in inches.\"\"\"\n3046         return self.bbox_inches.height\n3047 \n3048     def get_dpi(self):\n3049         \"\"\"Return the resolution in dots per inch as a float.\"\"\"\n3050         return self.dpi\n3051 \n3052     def set_dpi(self, val):\n3053         \"\"\"\n3054         Set the resolution of the figure in dots-per-inch.\n3055 \n3056         Parameters\n3057         ----------\n3058         val : float\n3059         \"\"\"\n3060         self.dpi = val\n3061         self.stale = True\n3062 \n3063     def set_figwidth(self, val, forward=True):\n3064         \"\"\"\n3065         Set the width of the figure in inches.\n3066 \n3067         Parameters\n3068         ----------\n3069         val : float\n3070         forward : bool\n3071             See `set_size_inches`.\n3072 \n3073         See Also\n3074         --------\n3075         matplotlib.figure.Figure.set_figheight\n3076         matplotlib.figure.Figure.set_size_inches\n3077         \"\"\"\n3078         self.set_size_inches(val, self.get_figheight(), forward=forward)\n3079 \n3080     def set_figheight(self, val, forward=True):\n3081         \"\"\"\n3082         Set the height of the figure in inches.\n3083 \n3084         Parameters\n3085         ----------\n3086         val : float\n3087         forward : bool\n3088             See `set_size_inches`.\n3089 \n3090         See Also\n3091         --------\n3092         matplotlib.figure.Figure.set_figwidth\n3093         matplotlib.figure.Figure.set_size_inches\n3094         \"\"\"\n3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)\n3096 \n3097     def clear(self, keep_observers=False):\n3098         # docstring inherited\n3099         super().clear(keep_observers=keep_observers)\n3100         # FigureBase.clear does not clear toolbars, as\n3101         # only Figure can have toolbars\n3102         toolbar = self.canvas.toolbar\n3103         if toolbar is not None:\n3104             toolbar.update()\n3105 \n3106     @_finalize_rasterization\n3107     @allow_rasterization\n3108     def draw(self, renderer):\n3109         # docstring inherited\n3110 \n3111         # draw the figure bounding box, perhaps none for white figure\n3112         if not self.get_visible():\n3113             return\n3114 \n3115         artists = self._get_draw_artists(renderer)\n3116         try:\n3117             renderer.open_group('figure', gid=self.get_gid())\n3118             if self.axes and self.get_layout_engine() is not None:\n3119                 try:\n3120                     self.get_layout_engine().execute(self)\n3121                 except ValueError:\n3122                     pass\n3123                     # ValueError can occur when resizing a window.\n3124 \n3125             self.patch.draw(renderer)\n3126             mimage._draw_list_compositing_images(\n3127                 renderer, self, artists, self.suppressComposite)\n3128 \n3129             for sfig in self.subfigs:\n3130                 sfig.draw(renderer)\n3131 \n3132             renderer.close_group('figure')\n3133         finally:\n3134             self.stale = False\n3135 \n3136         DrawEvent(\"draw_event\", self.canvas, renderer)._process()\n3137 \n3138     def draw_without_rendering(self):\n3139         \"\"\"\n3140         Draw the figure with no output.  Useful to get the final size of\n3141         artists that require a draw before their size is known (e.g. text).\n3142         \"\"\"\n3143         renderer = _get_renderer(self)\n3144         with renderer._draw_disabled():\n3145             self.draw(renderer)\n3146 \n3147     def draw_artist(self, a):\n3148         \"\"\"\n3149         Draw `.Artist` *a* only.\n3150         \"\"\"\n3151         a.draw(self.canvas.get_renderer())\n3152 \n3153     def __getstate__(self):\n3154         state = super().__getstate__()\n3155 \n3156         # The canvas cannot currently be pickled, but this has the benefit\n3157         # of meaning that a figure can be detached from one canvas, and\n3158         # re-attached to another.\n3159         state.pop(\"canvas\")\n3160 \n3161         # discard any changes to the dpi due to pixel ratio changes\n3162         state[\"_dpi\"] = state.get('_original_dpi', state['_dpi'])\n3163 \n3164         # add version information to the state\n3165         state['__mpl_version__'] = mpl.__version__\n3166 \n3167         # check whether the figure manager (if any) is registered with pyplot\n3168         from matplotlib import _pylab_helpers\n3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n3170             state['_restore_to_pylab'] = True\n3171         return state\n3172 \n3173     def __setstate__(self, state):\n3174         version = state.pop('__mpl_version__')\n3175         restore_to_pylab = state.pop('_restore_to_pylab', False)\n3176 \n3177         if version != mpl.__version__:\n3178             _api.warn_external(\n3179                 f\"This figure was saved with matplotlib version {version} and \"\n3180                 f\"is unlikely to function correctly.\")\n3181 \n3182         self.__dict__ = state\n3183 \n3184         # re-initialise some of the unstored state information\n3185         FigureCanvasBase(self)  # Set self.canvas.\n3186 \n3187         if restore_to_pylab:\n3188             # lazy import to avoid circularity\n3189             import matplotlib.pyplot as plt\n3190             import matplotlib._pylab_helpers as pylab_helpers\n3191             allnums = plt.get_fignums()\n3192             num = max(allnums) + 1 if allnums else 1\n3193             backend = plt._get_backend_mod()\n3194             mgr = backend.new_figure_manager_given_figure(num, self)\n3195             pylab_helpers.Gcf._set_new_active_manager(mgr)\n3196             plt.draw_if_interactive()\n3197 \n3198         self.stale = True\n3199 \n3200     def add_axobserver(self, func):\n3201         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n3202         # Connect a wrapper lambda and not func itself, to avoid it being\n3203         # weakref-collected.\n3204         self._axobservers.connect(\"_axes_change_event\", lambda arg: func(arg))\n3205 \n3206     def savefig(self, fname, *, transparent=None, **kwargs):\n3207         \"\"\"\n3208         Save the current figure.\n3209 \n3210         Call signature::\n3211 \n3212           savefig(fname, *, dpi='figure', format=None, metadata=None,\n3213                   bbox_inches=None, pad_inches=0.1,\n3214                   facecolor='auto', edgecolor='auto',\n3215                   backend=None, **kwargs\n3216                  )\n3217 \n3218         The available output formats depend on the backend being used.\n3219 \n3220         Parameters\n3221         ----------\n3222         fname : str or path-like or binary file-like\n3223             A path, or a Python file-like object, or\n3224             possibly some backend-dependent object such as\n3225             `matplotlib.backends.backend_pdf.PdfPages`.\n3226 \n3227             If *format* is set, it determines the output format, and the file\n3228             is saved as *fname*.  Note that *fname* is used verbatim, and there\n3229             is no attempt to make the extension, if any, of *fname* match\n3230             *format*, and no extension is appended.\n3231 \n3232             If *format* is not set, then the format is inferred from the\n3233             extension of *fname*, if there is one.  If *format* is not\n3234             set and *fname* has no extension, then the file is saved with\n3235             :rc:`savefig.format` and the appropriate extension is appended to\n3236             *fname*.\n3237 \n3238         Other Parameters\n3239         ----------------\n3240         dpi : float or 'figure', default: :rc:`savefig.dpi`\n3241             The resolution in dots per inch.  If 'figure', use the figure's\n3242             dpi value.\n3243 \n3244         format : str\n3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n3246             this is unset is documented under *fname*.\n3247 \n3248         metadata : dict, optional\n3249             Key/value pairs to store in the image metadata. The supported keys\n3250             and defaults depend on the image format and backend:\n3251 \n3252             - 'png' with Agg backend: See the parameter ``metadata`` of\n3253               `~.FigureCanvasAgg.print_png`.\n3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of\n3255               `~.backend_pdf.PdfPages`.\n3256             - 'svg' with svg backend: See the parameter ``metadata`` of\n3257               `~.FigureCanvasSVG.print_svg`.\n3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n3259 \n3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support\n3261             embedding metadata.\n3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include\n3263             embedding EXIF metadata in the future.\n3264 \n3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n3266             Bounding box in inches: only the given portion of the figure is\n3267             saved.  If 'tight', try to figure out the tight bbox of the figure.\n3268 \n3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n3270             Amount of padding in inches around the figure when bbox_inches is\n3271             'tight'. If 'layout' use the padding from the constrained or\n3272             compressed layout engine; ignored if one of those engines is not in\n3273             use.\n3274 \n3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`\n3276             The facecolor of the figure.  If 'auto', use the current figure\n3277             facecolor.\n3278 \n3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`\n3280             The edgecolor of the figure.  If 'auto', use the current figure\n3281             edgecolor.\n3282 \n3283         backend : str, optional\n3284             Use a non-default backend to render the file, e.g. to render a\n3285             png file with the \"cairo\" backend rather than the default \"agg\",\n3286             or a pdf file with the \"pgf\" backend rather than the default\n3287             \"pdf\".  Note that the default backend is normally sufficient.  See\n3288             :ref:`the-builtin-backends` for a list of valid backends for each\n3289             file format.  Custom backends can be referenced as \"module://...\".\n3290 \n3291         orientation : {'landscape', 'portrait'}\n3292             Currently only supported by the postscript backend.\n3293 \n3294         papertype : str\n3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n3296             'a10', 'b0' through 'b10'. Only supported for postscript\n3297             output.\n3298 \n3299         transparent : bool\n3300             If *True*, the Axes patches will all be transparent; the\n3301             Figure patch will also be transparent unless *facecolor*\n3302             and/or *edgecolor* are specified via kwargs.\n3303 \n3304             If *False* has no effect and the color of the Axes and\n3305             Figure patches are unchanged (unless the Figure patch\n3306             is specified via the *facecolor* and/or *edgecolor* keyword\n3307             arguments in which case those colors are used).\n3308 \n3309             The transparency of these patches will be restored to their\n3310             original values upon exit of this function.\n3311 \n3312             This is useful, for example, for displaying\n3313             a plot on top of a colored background on a web page.\n3314 \n3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n3316             A list of extra artists that will be considered when the\n3317             tight bbox is calculated.\n3318 \n3319         pil_kwargs : dict, optional\n3320             Additional keyword arguments that are passed to\n3321             `PIL.Image.Image.save` when saving the figure.\n3322 \n3323         \"\"\"\n3324 \n3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])\n3326         if transparent is None:\n3327             transparent = mpl.rcParams['savefig.transparent']\n3328 \n3329         with ExitStack() as stack:\n3330             if transparent:\n3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):\n3332                     exit_stack.enter_context(\n3333                         subfig.patch._cm_set(\n3334                             facecolor=\"none\", edgecolor=\"none\"))\n3335                     for ax in subfig.axes:\n3336                         exit_stack.enter_context(\n3337                             ax.patch._cm_set(\n3338                                 facecolor=\"none\", edgecolor=\"none\"))\n3339                     for sub_subfig in subfig.subfigs:\n3340                         _recursively_make_subfig_transparent(\n3341                             exit_stack, sub_subfig)\n3342 \n3343                 def _recursively_make_axes_transparent(exit_stack, ax):\n3344                     exit_stack.enter_context(\n3345                         ax.patch._cm_set(facecolor=\"none\", edgecolor=\"none\"))\n3346                     for child_ax in ax.child_axes:\n3347                         exit_stack.enter_context(\n3348                             child_ax.patch._cm_set(\n3349                                 facecolor=\"none\", edgecolor=\"none\"))\n3350                     for child_childax in ax.child_axes:\n3351                         _recursively_make_axes_transparent(\n3352                             exit_stack, child_childax)\n3353 \n3354                 kwargs.setdefault('facecolor', 'none')\n3355                 kwargs.setdefault('edgecolor', 'none')\n3356                 # set subfigure to appear transparent in printed image\n3357                 for subfig in self.subfigs:\n3358                     _recursively_make_subfig_transparent(stack, subfig)\n3359                 # set axes to be transparent\n3360                 for ax in self.axes:\n3361                     _recursively_make_axes_transparent(stack, ax)\n3362             self.canvas.print_figure(fname, **kwargs)\n3363 \n3364     def ginput(self, n=1, timeout=30, show_clicks=True,\n3365                mouse_add=MouseButton.LEFT,\n3366                mouse_pop=MouseButton.RIGHT,\n3367                mouse_stop=MouseButton.MIDDLE):\n3368         \"\"\"\n3369         Blocking call to interact with a figure.\n3370 \n3371         Wait until the user clicks *n* times on the figure, and return the\n3372         coordinates of each click in a list.\n3373 \n3374         There are three possible interactions:\n3375 \n3376         - Add a point.\n3377         - Remove the most recently added point.\n3378         - Stop the interaction and return the points added so far.\n3379 \n3380         The actions are assigned to mouse buttons via the arguments\n3381         *mouse_add*, *mouse_pop* and *mouse_stop*.\n3382 \n3383         Parameters\n3384         ----------\n3385         n : int, default: 1\n3386             Number of mouse clicks to accumulate. If negative, accumulate\n3387             clicks until the input is terminated manually.\n3388         timeout : float, default: 30 seconds\n3389             Number of seconds to wait before timing out. If zero or negative\n3390             will never time out.\n3391         show_clicks : bool, default: True\n3392             If True, show a red cross at the location of each click.\n3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`\n3394             Mouse button used to add points.\n3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`\n3396             Mouse button used to remove the most recently added point.\n3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`\n3398             Mouse button used to stop input.\n3399 \n3400         Returns\n3401         -------\n3402         list of tuples\n3403             A list of the clicked (x, y) coordinates.\n3404 \n3405         Notes\n3406         -----\n3407         The keyboard can also be used to select points in case your mouse\n3408         does not have one or more of the buttons.  The delete and backspace\n3409         keys act like right-clicking (i.e., remove last point), the enter key\n3410         terminates input and any other key (not already used by the window\n3411         manager) selects a point.\n3412         \"\"\"\n3413         clicks = []\n3414         marks = []\n3415 \n3416         def handler(event):\n3417             is_button = event.name == \"button_press_event\"\n3418             is_key = event.name == \"key_press_event\"\n3419             # Quit (even if not in infinite mode; this is consistent with\n3420             # MATLAB and sometimes quite useful, but will require the user to\n3421             # test how many points were actually returned before using data).\n3422             if (is_button and event.button == mouse_stop\n3423                     or is_key and event.key in [\"escape\", \"enter\"]):\n3424                 self.canvas.stop_event_loop()\n3425             # Pop last click.\n3426             elif (is_button and event.button == mouse_pop\n3427                   or is_key and event.key in [\"backspace\", \"delete\"]):\n3428                 if clicks:\n3429                     clicks.pop()\n3430                     if show_clicks:\n3431                         marks.pop().remove()\n3432                         self.canvas.draw()\n3433             # Add new click.\n3434             elif (is_button and event.button == mouse_add\n3435                   # On macOS/gtk, some keys return None.\n3436                   or is_key and event.key is not None):\n3437                 if event.inaxes:\n3438                     clicks.append((event.xdata, event.ydata))\n3439                     _log.info(\"input %i: %f, %f\",\n3440                               len(clicks), event.xdata, event.ydata)\n3441                     if show_clicks:\n3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],\n3443                                                 marker=\"+\", color=\"r\")\n3444                         event.inaxes.add_line(line)\n3445                         marks.append(line)\n3446                         self.canvas.draw()\n3447             if len(clicks) == n and n > 0:\n3448                 self.canvas.stop_event_loop()\n3449 \n3450         _blocking_input.blocking_input_loop(\n3451             self, [\"button_press_event\", \"key_press_event\"], timeout, handler)\n3452 \n3453         # Cleanup.\n3454         for mark in marks:\n3455             mark.remove()\n3456         self.canvas.draw()\n3457 \n3458         return clicks\n3459 \n3460     def waitforbuttonpress(self, timeout=-1):\n3461         \"\"\"\n3462         Blocking call to interact with the figure.\n3463 \n3464         Wait for user input and return True if a key was pressed, False if a\n3465         mouse button was pressed and None if no input was given within\n3466         *timeout* seconds.  Negative values deactivate *timeout*.\n3467         \"\"\"\n3468         event = None\n3469 \n3470         def handler(ev):\n3471             nonlocal event\n3472             event = ev\n3473             self.canvas.stop_event_loop()\n3474 \n3475         _blocking_input.blocking_input_loop(\n3476             self, [\"button_press_event\", \"key_press_event\"], timeout, handler)\n3477 \n3478         return None if event is None else event.name == \"key_press_event\"\n3479 \n3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):\n3481         \"\"\"\n3482         Adjust the padding between and around subplots.\n3483 \n3484         To exclude an artist on the Axes from the bounding box calculation\n3485         that determines the subplot parameters (i.e. legend, or annotation),\n3486         set ``a.set_in_layout(False)`` for that artist.\n3487 \n3488         Parameters\n3489         ----------\n3490         pad : float, default: 1.08\n3491             Padding between the figure edge and the edges of subplots,\n3492             as a fraction of the font size.\n3493         h_pad, w_pad : float, default: *pad*\n3494             Padding (height/width) between edges of adjacent subplots,\n3495             as a fraction of the font size.\n3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)\n3497             A rectangle in normalized figure coordinates into which the whole\n3498             subplots area (including labels) will fit.\n3499 \n3500         See Also\n3501         --------\n3502         .Figure.set_layout_engine\n3503         .pyplot.tight_layout\n3504         \"\"\"\n3505         # note that here we do not permanently set the figures engine to\n3506         # tight_layout but rather just perform the layout in place and remove\n3507         # any previous engines.\n3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,\n3509                                    rect=rect)\n3510         try:\n3511             previous_engine = self.get_layout_engine()\n3512             self.set_layout_engine(engine)\n3513             engine.execute(self)\n3514             if not isinstance(previous_engine, TightLayoutEngine) \\\n3515                     and previous_engine is not None:\n3516                 _api.warn_external('The figure layout has changed to tight')\n3517         finally:\n3518             self.set_layout_engine(None)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "lib/matplotlib/figure.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/figure.py",
        "start": 1,
        "end": 3598,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 `matplotlib.figure` implements the following classes:\n3 \n4 `Figure`\n5     Top level `~matplotlib.artist.Artist`, which holds all plot elements.\n6     Many methods are implemented in `FigureBase`.\n7 \n8 `SubFigure`\n9     A logical figure inside a figure, usually added to a figure (or parent\n10     `SubFigure`) with `Figure.add_subfigure` or `Figure.subfigures` methods\n11     (provisional API v3.4).\n12 \n13 `SubplotParams`\n14     Control the default spacing between subplots.\n15 \n16 Figures are typically created using pyplot methods `~.pyplot.figure`,\n17 `~.pyplot.subplots`, and `~.pyplot.subplot_mosaic`.\n18 \n19 .. plot::\n20     :include-source:\n21 \n22     fig, ax = plt.subplots(figsize=(2, 2), facecolor='lightskyblue',\n23                            layout='constrained')\n24     fig.suptitle('Figure')\n25     ax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n26 \n27 Some situations call for directly instantiating a `~.figure.Figure` class,\n28 usually inside an application of some sort (see :ref:`user_interfaces` for a\n29 list of examples) .  More information about Figures can be found at\n30 :ref:`figure_explanation`.\n31 \"\"\"\n32 \n33 from contextlib import ExitStack\n34 import inspect\n35 import itertools\n36 import logging\n37 from numbers import Integral\n38 \n39 import numpy as np\n40 \n41 import matplotlib as mpl\n42 from matplotlib import _blocking_input, backend_bases, _docstring, projections\n43 from matplotlib.artist import (\n44     Artist, allow_rasterization, _finalize_rasterization)\n45 from matplotlib.backend_bases import (\n46     DrawEvent, FigureCanvasBase, NonGuiException, MouseButton, _get_renderer)\n47 import matplotlib._api as _api\n48 import matplotlib.cbook as cbook\n49 import matplotlib.colorbar as cbar\n50 import matplotlib.image as mimage\n51 \n52 from matplotlib.axes import Axes\n53 from matplotlib.gridspec import GridSpec\n54 from matplotlib.layout_engine import (\n55     ConstrainedLayoutEngine, TightLayoutEngine, LayoutEngine,\n56     PlaceHolderLayoutEngine\n57 )\n58 import matplotlib.legend as mlegend\n59 from matplotlib.patches import Rectangle\n60 from matplotlib.text import Text\n61 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n62                                    TransformedBbox)\n63 \n64 _log = logging.getLogger(__name__)\n65 \n66 \n67 def _stale_figure_callback(self, val):\n68     if self.figure:\n69         self.figure.stale = val\n70 \n71 \n72 class _AxesStack:\n73     \"\"\"\n74     Helper class to track axes in a figure.\n75 \n76     Axes are tracked both in the order in which they have been added\n77     (``self._axes`` insertion/iteration order) and in the separate \"gca\" stack\n78     (which is the index to which they map in the ``self._axes`` dict).\n79     \"\"\"\n80 \n81     def __init__(self):\n82         self._axes = {}  # Mapping of axes to \"gca\" order.\n83         self._counter = itertools.count()\n84 \n85     def as_list(self):\n86         \"\"\"List the axes that have been added to the figure.\"\"\"\n87         return [*self._axes]  # This relies on dict preserving order.\n88 \n89     def remove(self, a):\n90         \"\"\"Remove the axes from the stack.\"\"\"\n91         self._axes.pop(a)\n92 \n93     def bubble(self, a):\n94         \"\"\"Move an axes, which must already exist in the stack, to the top.\"\"\"\n95         if a not in self._axes:\n96             raise ValueError(\"Axes has not been added yet\")\n97         self._axes[a] = next(self._counter)\n98 \n99     def add(self, a):\n100         \"\"\"Add an axes to the stack, ignoring it if already present.\"\"\"\n101         if a not in self._axes:\n102             self._axes[a] = next(self._counter)\n103 \n104     def current(self):\n105         \"\"\"Return the active axes, or None if the stack is empty.\"\"\"\n106         return max(self._axes, key=self._axes.__getitem__, default=None)\n107 \n108 \n109 class SubplotParams:\n110     \"\"\"\n111     A class to hold the parameters for a subplot.\n112     \"\"\"\n113 \n114     def __init__(self, left=None, bottom=None, right=None, top=None,\n115                  wspace=None, hspace=None):\n116         \"\"\"\n117         Defaults are given by :rc:`figure.subplot.[name]`.\n118 \n119         Parameters\n120         ----------\n121         left : float\n122             The position of the left edge of the subplots,\n123             as a fraction of the figure width.\n124         right : float\n125             The position of the right edge of the subplots,\n126             as a fraction of the figure width.\n127         bottom : float\n128             The position of the bottom edge of the subplots,\n129             as a fraction of the figure height.\n130         top : float\n131             The position of the top edge of the subplots,\n132             as a fraction of the figure height.\n133         wspace : float\n134             The width of the padding between subplots,\n135             as a fraction of the average Axes width.\n136         hspace : float\n137             The height of the padding between subplots,\n138             as a fraction of the average Axes height.\n139         \"\"\"\n140         for key in [\"left\", \"bottom\", \"right\", \"top\", \"wspace\", \"hspace\"]:\n141             setattr(self, key, mpl.rcParams[f\"figure.subplot.{key}\"])\n142         self.update(left, bottom, right, top, wspace, hspace)\n143 \n144     def update(self, left=None, bottom=None, right=None, top=None,\n145                wspace=None, hspace=None):\n146         \"\"\"\n147         Update the dimensions of the passed parameters. *None* means unchanged.\n148         \"\"\"\n149         if ((left if left is not None else self.left)\n150                 >= (right if right is not None else self.right)):\n151             raise ValueError('left cannot be >= right')\n152         if ((bottom if bottom is not None else self.bottom)\n153                 >= (top if top is not None else self.top)):\n154             raise ValueError('bottom cannot be >= top')\n155         if left is not None:\n156             self.left = left\n157         if right is not None:\n158             self.right = right\n159         if bottom is not None:\n160             self.bottom = bottom\n161         if top is not None:\n162             self.top = top\n163         if wspace is not None:\n164             self.wspace = wspace\n165         if hspace is not None:\n166             self.hspace = hspace\n167 \n168 \n169 class FigureBase(Artist):\n170     \"\"\"\n171     Base class for `.Figure` and `.SubFigure` containing the methods that add\n172     artists to the figure or subfigure, create Axes, etc.\n173     \"\"\"\n174     def __init__(self, **kwargs):\n175         super().__init__()\n176         # remove the non-figure artist _axes property\n177         # as it makes no sense for a figure to be _in_ an Axes\n178         # this is used by the property methods in the artist base class\n179         # which are over-ridden in this class\n180         del self._axes\n181 \n182         self._suptitle = None\n183         self._supxlabel = None\n184         self._supylabel = None\n185 \n186         # groupers to keep track of x and y labels we want to align.\n187         # see self.align_xlabels and self.align_ylabels and\n188         # axis._get_tick_boxes_siblings\n189         self._align_label_groups = {\"x\": cbook.Grouper(), \"y\": cbook.Grouper()}\n190 \n191         self.figure = self\n192         self._localaxes = []  # track all axes\n193         self.artists = []\n194         self.lines = []\n195         self.patches = []\n196         self.texts = []\n197         self.images = []\n198         self.legends = []\n199         self.subfigs = []\n200         self.stale = True\n201         self.suppressComposite = None\n202         self.set(**kwargs)\n203 \n204     def _get_draw_artists(self, renderer):\n205         \"\"\"Also runs apply_aspect\"\"\"\n206         artists = self.get_children()\n207         for sfig in self.subfigs:\n208             artists.remove(sfig)\n209             childa = sfig.get_children()\n210             for child in childa:\n211                 if child in artists:\n212                     artists.remove(child)\n213 \n214         artists.remove(self.patch)\n215         artists = sorted(\n216             (artist for artist in artists if not artist.get_animated()),\n217             key=lambda artist: artist.get_zorder())\n218         for ax in self._localaxes:\n219             locator = ax.get_axes_locator()\n220             ax.apply_aspect(locator(ax, renderer) if locator else None)\n221 \n222             for child in ax.get_children():\n223                 if hasattr(child, 'apply_aspect'):\n224                     locator = child.get_axes_locator()\n225                     child.apply_aspect(\n226                         locator(child, renderer) if locator else None)\n227         return artists\n228 \n229     def autofmt_xdate(\n230             self, bottom=0.2, rotation=30, ha='right', which='major'):\n231         \"\"\"\n232         Date ticklabels often overlap, so it is useful to rotate them\n233         and right align them.  Also, a common use case is a number of\n234         subplots with shared x-axis where the x-axis is date data.  The\n235         ticklabels are often long, and it helps to rotate them on the\n236         bottom subplot and turn them off on other subplots, as well as\n237         turn off xlabels.\n238 \n239         Parameters\n240         ----------\n241         bottom : float, default: 0.2\n242             The bottom of the subplots for `subplots_adjust`.\n243         rotation : float, default: 30 degrees\n244             The rotation angle of the xtick labels in degrees.\n245         ha : {'left', 'center', 'right'}, default: 'right'\n246             The horizontal alignment of the xticklabels.\n247         which : {'major', 'minor', 'both'}, default: 'major'\n248             Selects which ticklabels to rotate.\n249         \"\"\"\n250         _api.check_in_list(['major', 'minor', 'both'], which=which)\n251         allsubplots = all(ax.get_subplotspec() for ax in self.axes)\n252         if len(self.axes) == 1:\n253             for label in self.axes[0].get_xticklabels(which=which):\n254                 label.set_ha(ha)\n255                 label.set_rotation(rotation)\n256         else:\n257             if allsubplots:\n258                 for ax in self.get_axes():\n259                     if ax.get_subplotspec().is_last_row():\n260                         for label in ax.get_xticklabels(which=which):\n261                             label.set_ha(ha)\n262                             label.set_rotation(rotation)\n263                     else:\n264                         for label in ax.get_xticklabels(which=which):\n265                             label.set_visible(False)\n266                         ax.set_xlabel('')\n267 \n268         if allsubplots:\n269             self.subplots_adjust(bottom=bottom)\n270         self.stale = True\n271 \n272     def get_children(self):\n273         \"\"\"Get a list of artists contained in the figure.\"\"\"\n274         return [self.patch,\n275                 *self.artists,\n276                 *self._localaxes,\n277                 *self.lines,\n278                 *self.patches,\n279                 *self.texts,\n280                 *self.images,\n281                 *self.legends,\n282                 *self.subfigs]\n283 \n284     def contains(self, mouseevent):\n285         \"\"\"\n286         Test whether the mouse event occurred on the figure.\n287 \n288         Returns\n289         -------\n290             bool, {}\n291         \"\"\"\n292         if self._different_canvas(mouseevent):\n293             return False, {}\n294         inside = self.bbox.contains(mouseevent.x, mouseevent.y)\n295         return inside, {}\n296 \n297     def get_window_extent(self, renderer=None):\n298         # docstring inherited\n299         return self.bbox\n300 \n301     def _suplabels(self, t, info, **kwargs):\n302         \"\"\"\n303         Add a centered %(name)s to the figure.\n304 \n305         Parameters\n306         ----------\n307         t : str\n308             The %(name)s text.\n309         x : float, default: %(x0)s\n310             The x location of the text in figure coordinates.\n311         y : float, default: %(y0)s\n312             The y location of the text in figure coordinates.\n313         horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s\n314             The horizontal alignment of the text relative to (*x*, *y*).\n315         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \\\n316 default: %(va)s\n317             The vertical alignment of the text relative to (*x*, *y*).\n318         fontsize, size : default: :rc:`figure.%(rc)ssize`\n319             The font size of the text. See `.Text.set_size` for possible\n320             values.\n321         fontweight, weight : default: :rc:`figure.%(rc)sweight`\n322             The font weight of the text. See `.Text.set_weight` for possible\n323             values.\n324 \n325         Returns\n326         -------\n327         text\n328             The `.Text` instance of the %(name)s.\n329 \n330         Other Parameters\n331         ----------------\n332         fontproperties : None or dict, optional\n333             A dict of font properties. If *fontproperties* is given the\n334             default values for font size and weight are taken from the\n335             `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and\n336             :rc:`figure.%(rc)sweight` are ignored in this case.\n337 \n338         **kwargs\n339             Additional kwargs are `matplotlib.text.Text` properties.\n340         \"\"\"\n341 \n342         suplab = getattr(self, info['name'])\n343 \n344         x = kwargs.pop('x', None)\n345         y = kwargs.pop('y', None)\n346         if info['name'] in ['_supxlabel', '_suptitle']:\n347             autopos = y is None\n348         elif info['name'] == '_supylabel':\n349             autopos = x is None\n350         if x is None:\n351             x = info['x0']\n352         if y is None:\n353             y = info['y0']\n354 \n355         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:\n356             kwargs['horizontalalignment'] = info['ha']\n357         if 'verticalalignment' not in kwargs and 'va' not in kwargs:\n358             kwargs['verticalalignment'] = info['va']\n359         if 'rotation' not in kwargs:\n360             kwargs['rotation'] = info['rotation']\n361 \n362         if 'fontproperties' not in kwargs:\n363             if 'fontsize' not in kwargs and 'size' not in kwargs:\n364                 kwargs['size'] = mpl.rcParams[info['size']]\n365             if 'fontweight' not in kwargs and 'weight' not in kwargs:\n366                 kwargs['weight'] = mpl.rcParams[info['weight']]\n367 \n368         sup = self.text(x, y, t, **kwargs)\n369         if suplab is not None:\n370             suplab.set_text(t)\n371             suplab.set_position((x, y))\n372             suplab.update_from(sup)\n373             sup.remove()\n374         else:\n375             suplab = sup\n376         suplab._autopos = autopos\n377         setattr(self, info['name'], suplab)\n378         self.stale = True\n379         return suplab\n380 \n381     @_docstring.Substitution(x0=0.5, y0=0.98, name='suptitle', ha='center',\n382                              va='top', rc='title')\n383     @_docstring.copy(_suplabels)\n384     def suptitle(self, t, **kwargs):\n385         # docstring from _suplabels...\n386         info = {'name': '_suptitle', 'x0': 0.5, 'y0': 0.98,\n387                 'ha': 'center', 'va': 'top', 'rotation': 0,\n388                 'size': 'figure.titlesize', 'weight': 'figure.titleweight'}\n389         return self._suplabels(t, info, **kwargs)\n390 \n391     @_docstring.Substitution(x0=0.5, y0=0.01, name='supxlabel', ha='center',\n392                              va='bottom', rc='label')\n393     @_docstring.copy(_suplabels)\n394     def supxlabel(self, t, **kwargs):\n395         # docstring from _suplabels...\n396         info = {'name': '_supxlabel', 'x0': 0.5, 'y0': 0.01,\n397                 'ha': 'center', 'va': 'bottom', 'rotation': 0,\n398                 'size': 'figure.labelsize', 'weight': 'figure.labelweight'}\n399         return self._suplabels(t, info, **kwargs)\n400 \n401     @_docstring.Substitution(x0=0.02, y0=0.5, name='supylabel', ha='left',\n402                              va='center', rc='label')\n403     @_docstring.copy(_suplabels)\n404     def supylabel(self, t, **kwargs):\n405         # docstring from _suplabels...\n406         info = {'name': '_supylabel', 'x0': 0.02, 'y0': 0.5,\n407                 'ha': 'left', 'va': 'center', 'rotation': 'vertical',\n408                 'rotation_mode': 'anchor', 'size': 'figure.labelsize',\n409                 'weight': 'figure.labelweight'}\n410         return self._suplabels(t, info, **kwargs)\n411 \n412     def get_edgecolor(self):\n413         \"\"\"Get the edge color of the Figure rectangle.\"\"\"\n414         return self.patch.get_edgecolor()\n415 \n416     def get_facecolor(self):\n417         \"\"\"Get the face color of the Figure rectangle.\"\"\"\n418         return self.patch.get_facecolor()\n419 \n420     def get_frameon(self):\n421         \"\"\"\n422         Return the figure's background patch visibility, i.e.\n423         whether the figure background will be drawn. Equivalent to\n424         ``Figure.patch.get_visible()``.\n425         \"\"\"\n426         return self.patch.get_visible()\n427 \n428     def set_linewidth(self, linewidth):\n429         \"\"\"\n430         Set the line width of the Figure rectangle.\n431 \n432         Parameters\n433         ----------\n434         linewidth : number\n435         \"\"\"\n436         self.patch.set_linewidth(linewidth)\n437 \n438     def get_linewidth(self):\n439         \"\"\"\n440         Get the line width of the Figure rectangle.\n441         \"\"\"\n442         return self.patch.get_linewidth()\n443 \n444     def set_edgecolor(self, color):\n445         \"\"\"\n446         Set the edge color of the Figure rectangle.\n447 \n448         Parameters\n449         ----------\n450         color : color\n451         \"\"\"\n452         self.patch.set_edgecolor(color)\n453 \n454     def set_facecolor(self, color):\n455         \"\"\"\n456         Set the face color of the Figure rectangle.\n457 \n458         Parameters\n459         ----------\n460         color : color\n461         \"\"\"\n462         self.patch.set_facecolor(color)\n463 \n464     def set_frameon(self, b):\n465         \"\"\"\n466         Set the figure's background patch visibility, i.e.\n467         whether the figure background will be drawn. Equivalent to\n468         ``Figure.patch.set_visible()``.\n469 \n470         Parameters\n471         ----------\n472         b : bool\n473         \"\"\"\n474         self.patch.set_visible(b)\n475         self.stale = True\n476 \n477     frameon = property(get_frameon, set_frameon)\n478 \n479     def add_artist(self, artist, clip=False):\n480         \"\"\"\n481         Add an `.Artist` to the figure.\n482 \n483         Usually artists are added to `~.axes.Axes` objects using\n484         `.Axes.add_artist`; this method can be used in the rare cases where\n485         one needs to add artists directly to the figure instead.\n486 \n487         Parameters\n488         ----------\n489         artist : `~matplotlib.artist.Artist`\n490             The artist to add to the figure. If the added artist has no\n491             transform previously set, its transform will be set to\n492             ``figure.transSubfigure``.\n493         clip : bool, default: False\n494             Whether the added artist should be clipped by the figure patch.\n495 \n496         Returns\n497         -------\n498         `~matplotlib.artist.Artist`\n499             The added artist.\n500         \"\"\"\n501         artist.set_figure(self)\n502         self.artists.append(artist)\n503         artist._remove_method = self.artists.remove\n504 \n505         if not artist.is_transform_set():\n506             artist.set_transform(self.transSubfigure)\n507 \n508         if clip and artist.get_clip_path() is None:\n509             artist.set_clip_path(self.patch)\n510 \n511         self.stale = True\n512         return artist\n513 \n514     @_docstring.dedent_interpd\n515     def add_axes(self, *args, **kwargs):\n516         \"\"\"\n517         Add an `~.axes.Axes` to the figure.\n518 \n519         Call signatures::\n520 \n521             add_axes(rect, projection=None, polar=False, **kwargs)\n522             add_axes(ax)\n523 \n524         Parameters\n525         ----------\n526         rect : tuple (left, bottom, width, height)\n527             The dimensions (left, bottom, width, height) of the new\n528             `~.axes.Axes`. All quantities are in fractions of figure width and\n529             height.\n530 \n531         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n532 'polar', 'rectilinear', str}, optional\n533             The projection type of the `~.axes.Axes`. *str* is the name of\n534             a custom projection, see `~matplotlib.projections`. The default\n535             None results in a 'rectilinear' projection.\n536 \n537         polar : bool, default: False\n538             If True, equivalent to projection='polar'.\n539 \n540         axes_class : subclass type of `~.axes.Axes`, optional\n541             The `.axes.Axes` subclass that is instantiated.  This parameter\n542             is incompatible with *projection* and *polar*.  See\n543             :ref:`axisartist_users-guide-index` for examples.\n544 \n545         sharex, sharey : `~.axes.Axes`, optional\n546             Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n547             The axis will have the same limits, ticks, and scale as the axis\n548             of the shared axes.\n549 \n550         label : str\n551             A label for the returned Axes.\n552 \n553         Returns\n554         -------\n555         `~.axes.Axes`, or a subclass of `~.axes.Axes`\n556             The returned axes class depends on the projection used. It is\n557             `~.axes.Axes` if rectilinear projection is used and\n558             `.projections.polar.PolarAxes` if polar projection is used.\n559 \n560         Other Parameters\n561         ----------------\n562         **kwargs\n563             This method also takes the keyword arguments for\n564             the returned Axes class. The keyword arguments for the\n565             rectilinear Axes class `~.axes.Axes` can be found in\n566             the following table but there might also be other keyword\n567             arguments if another projection is used, see the actual Axes\n568             class.\n569 \n570             %(Axes:kwdoc)s\n571 \n572         Notes\n573         -----\n574         In rare circumstances, `.add_axes` may be called with a single\n575         argument, an Axes instance already created in the present figure but\n576         not in the figure's list of Axes.\n577 \n578         See Also\n579         --------\n580         .Figure.add_subplot\n581         .pyplot.subplot\n582         .pyplot.axes\n583         .Figure.subplots\n584         .pyplot.subplots\n585 \n586         Examples\n587         --------\n588         Some simple examples::\n589 \n590             rect = l, b, w, h\n591             fig = plt.figure()\n592             fig.add_axes(rect)\n593             fig.add_axes(rect, frameon=False, facecolor='g')\n594             fig.add_axes(rect, polar=True)\n595             ax = fig.add_axes(rect, projection='polar')\n596             fig.delaxes(ax)\n597             fig.add_axes(ax)\n598         \"\"\"\n599 \n600         if not len(args) and 'rect' not in kwargs:\n601             raise TypeError(\n602                 \"add_axes() missing 1 required positional argument: 'rect'\")\n603         elif 'rect' in kwargs:\n604             if len(args):\n605                 raise TypeError(\n606                     \"add_axes() got multiple values for argument 'rect'\")\n607             args = (kwargs.pop('rect'), )\n608 \n609         if isinstance(args[0], Axes):\n610             a = args[0]\n611             key = a._projection_init\n612             if a.get_figure() is not self:\n613                 raise ValueError(\n614                     \"The Axes must have been created in the present figure\")\n615         else:\n616             rect = args[0]\n617             if not np.isfinite(rect).all():\n618                 raise ValueError('all entries in rect must be finite '\n619                                  f'not {rect}')\n620             projection_class, pkw = self._process_projection_requirements(\n621                 *args, **kwargs)\n622 \n623             # create the new axes using the axes class given\n624             a = projection_class(self, rect, **pkw)\n625             key = (projection_class, pkw)\n626         return self._add_axes_internal(a, key)\n627 \n628     @_docstring.dedent_interpd\n629     def add_subplot(self, *args, **kwargs):\n630         \"\"\"\n631         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n632 \n633         Call signatures::\n634 \n635            add_subplot(nrows, ncols, index, **kwargs)\n636            add_subplot(pos, **kwargs)\n637            add_subplot(ax)\n638            add_subplot()\n639 \n640         Parameters\n641         ----------\n642         *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n643             The position of the subplot described by one of\n644 \n645             - Three integers (*nrows*, *ncols*, *index*). The subplot will\n646               take the *index* position on a grid with *nrows* rows and\n647               *ncols* columns. *index* starts at 1 in the upper left corner\n648               and increases to the right.  *index* can also be a two-tuple\n649               specifying the (*first*, *last*) indices (1-based, and including\n650               *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``\n651               makes a subplot that spans the upper 2/3 of the figure.\n652             - A 3-digit integer. The digits are interpreted as if given\n653               separately as three single-digit integers, i.e.\n654               ``fig.add_subplot(235)`` is the same as\n655               ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n656               if there are no more than 9 subplots.\n657             - A `.SubplotSpec`.\n658 \n659             In rare circumstances, `.add_subplot` may be called with a single\n660             argument, a subplot Axes instance already created in the\n661             present figure but not in the figure's list of Axes.\n662 \n663         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n664 'polar', 'rectilinear', str}, optional\n665             The projection type of the subplot (`~.axes.Axes`). *str* is the\n666             name of a custom projection, see `~matplotlib.projections`. The\n667             default None results in a 'rectilinear' projection.\n668 \n669         polar : bool, default: False\n670             If True, equivalent to projection='polar'.\n671 \n672         axes_class : subclass type of `~.axes.Axes`, optional\n673             The `.axes.Axes` subclass that is instantiated.  This parameter\n674             is incompatible with *projection* and *polar*.  See\n675             :ref:`axisartist_users-guide-index` for examples.\n676 \n677         sharex, sharey : `~.axes.Axes`, optional\n678             Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n679             The axis will have the same limits, ticks, and scale as the axis\n680             of the shared axes.\n681 \n682         label : str\n683             A label for the returned Axes.\n684 \n685         Returns\n686         -------\n687         `~.axes.Axes`\n688 \n689             The Axes of the subplot. The returned Axes can actually be an\n690             instance of a subclass, such as `.projections.polar.PolarAxes` for\n691             polar projections.\n692 \n693         Other Parameters\n694         ----------------\n695         **kwargs\n696             This method also takes the keyword arguments for the returned Axes\n697             base class; except for the *figure* argument. The keyword arguments\n698             for the rectilinear base class `~.axes.Axes` can be found in\n699             the following table but there might also be other keyword\n700             arguments if another projection is used.\n701 \n702             %(Axes:kwdoc)s\n703 \n704         See Also\n705         --------\n706         .Figure.add_axes\n707         .pyplot.subplot\n708         .pyplot.axes\n709         .Figure.subplots\n710         .pyplot.subplots\n711 \n712         Examples\n713         --------\n714         ::\n715 \n716             fig = plt.figure()\n717 \n718             fig.add_subplot(231)\n719             ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general\n720 \n721             fig.add_subplot(232, frameon=False)  # subplot with no frame\n722             fig.add_subplot(233, projection='polar')  # polar subplot\n723             fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1\n724             fig.add_subplot(235, facecolor=\"red\")  # red subplot\n725 \n726             ax1.remove()  # delete ax1 from the figure\n727             fig.add_subplot(ax1)  # add ax1 back to the figure\n728         \"\"\"\n729         if 'figure' in kwargs:\n730             # Axes itself allows for a 'figure' kwarg, but since we want to\n731             # bind the created Axes to self, it is not allowed here.\n732             raise _api.kwarg_error(\"add_subplot\", \"figure\")\n733 \n734         if (len(args) == 1\n735                 and isinstance(args[0], mpl.axes._base._AxesBase)\n736                 and args[0].get_subplotspec()):\n737             ax = args[0]\n738             key = ax._projection_init\n739             if ax.get_figure() is not self:\n740                 raise ValueError(\"The Axes must have been created in \"\n741                                  \"the present figure\")\n742         else:\n743             if not args:\n744                 args = (1, 1, 1)\n745             # Normalize correct ijk values to (i, j, k) here so that\n746             # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will\n747             # trigger errors later (via SubplotSpec._from_subplot_args).\n748             if (len(args) == 1 and isinstance(args[0], Integral)\n749                     and 100 <= args[0] <= 999):\n750                 args = tuple(map(int, str(args[0])))\n751             projection_class, pkw = self._process_projection_requirements(\n752                 *args, **kwargs)\n753             ax = projection_class(self, *args, **pkw)\n754             key = (projection_class, pkw)\n755         return self._add_axes_internal(ax, key)\n756 \n757     def _add_axes_internal(self, ax, key):\n758         \"\"\"Private helper for `add_axes` and `add_subplot`.\"\"\"\n759         self._axstack.add(ax)\n760         if ax not in self._localaxes:\n761             self._localaxes.append(ax)\n762         self.sca(ax)\n763         ax._remove_method = self.delaxes\n764         # this is to support plt.subplot's re-selection logic\n765         ax._projection_init = key\n766         self.stale = True\n767         ax.stale_callback = _stale_figure_callback\n768         return ax\n769 \n770     def subplots(self, nrows=1, ncols=1, *, sharex=False, sharey=False,\n771                  squeeze=True, width_ratios=None, height_ratios=None,\n772                  subplot_kw=None, gridspec_kw=None):\n773         \"\"\"\n774         Add a set of subplots to this figure.\n775 \n776         This utility wrapper makes it convenient to create common layouts of\n777         subplots in a single call.\n778 \n779         Parameters\n780         ----------\n781         nrows, ncols : int, default: 1\n782             Number of rows/columns of the subplot grid.\n783 \n784         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n785             Controls sharing of x-axis (*sharex*) or y-axis (*sharey*):\n786 \n787             - True or 'all': x- or y-axis will be shared among all subplots.\n788             - False or 'none': each subplot x- or y-axis will be independent.\n789             - 'row': each subplot row will share an x- or y-axis.\n790             - 'col': each subplot column will share an x- or y-axis.\n791 \n792             When subplots have a shared x-axis along a column, only the x tick\n793             labels of the bottom subplot are created. Similarly, when subplots\n794             have a shared y-axis along a row, only the y tick labels of the\n795             first column subplot are created. To later turn other subplots'\n796             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.\n797 \n798             When subplots have a shared axis that has units, calling\n799             `.Axis.set_units` will update each axis with the new units.\n800 \n801         squeeze : bool, default: True\n802             - If True, extra dimensions are squeezed out from the returned\n803               array of Axes:\n804 \n805               - if only one subplot is constructed (nrows=ncols=1), the\n806                 resulting single Axes object is returned as a scalar.\n807               - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n808                 object array of Axes objects.\n809               - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n810 \n811             - If False, no squeezing at all is done: the returned Axes object\n812               is always a 2D array containing Axes instances, even if it ends\n813               up being 1x1.\n814 \n815         width_ratios : array-like of length *ncols*, optional\n816             Defines the relative widths of the columns. Each column gets a\n817             relative width of ``width_ratios[i] / sum(width_ratios)``.\n818             If not given, all columns will have the same width.  Equivalent\n819             to ``gridspec_kw={'width_ratios': [...]}``.\n820 \n821         height_ratios : array-like of length *nrows*, optional\n822             Defines the relative heights of the rows. Each row gets a\n823             relative height of ``height_ratios[i] / sum(height_ratios)``.\n824             If not given, all rows will have the same height. Equivalent\n825             to ``gridspec_kw={'height_ratios': [...]}``.\n826 \n827         subplot_kw : dict, optional\n828             Dict with keywords passed to the `.Figure.add_subplot` call used to\n829             create each subplot.\n830 \n831         gridspec_kw : dict, optional\n832             Dict with keywords passed to the\n833             `~matplotlib.gridspec.GridSpec` constructor used to create\n834             the grid the subplots are placed on.\n835 \n836         Returns\n837         -------\n838         `~.axes.Axes` or array of Axes\n839             Either a single `~matplotlib.axes.Axes` object or an array of Axes\n840             objects if more than one subplot was created. The dimensions of the\n841             resulting array can be controlled with the *squeeze* keyword, see\n842             above.\n843 \n844         See Also\n845         --------\n846         .pyplot.subplots\n847         .Figure.add_subplot\n848         .pyplot.subplot\n849 \n850         Examples\n851         --------\n852         ::\n853 \n854             # First create some toy data:\n855             x = np.linspace(0, 2*np.pi, 400)\n856             y = np.sin(x**2)\n857 \n858             # Create a figure\n859             plt.figure()\n860 \n861             # Create a subplot\n862             ax = fig.subplots()\n863             ax.plot(x, y)\n864             ax.set_title('Simple plot')\n865 \n866             # Create two subplots and unpack the output array immediately\n867             ax1, ax2 = fig.subplots(1, 2, sharey=True)\n868             ax1.plot(x, y)\n869             ax1.set_title('Sharing Y axis')\n870             ax2.scatter(x, y)\n871 \n872             # Create four polar Axes and access them through the returned array\n873             axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar'))\n874             axes[0, 0].plot(x, y)\n875             axes[1, 1].scatter(x, y)\n876 \n877             # Share an X-axis with each column of subplots\n878             fig.subplots(2, 2, sharex='col')\n879 \n880             # Share a Y-axis with each row of subplots\n881             fig.subplots(2, 2, sharey='row')\n882 \n883             # Share both X- and Y-axes with all subplots\n884             fig.subplots(2, 2, sharex='all', sharey='all')\n885 \n886             # Note that this is the same as\n887             fig.subplots(2, 2, sharex=True, sharey=True)\n888         \"\"\"\n889         gridspec_kw = dict(gridspec_kw or {})\n890         if height_ratios is not None:\n891             if 'height_ratios' in gridspec_kw:\n892                 raise ValueError(\"'height_ratios' must not be defined both as \"\n893                                  \"parameter and as key in 'gridspec_kw'\")\n894             gridspec_kw['height_ratios'] = height_ratios\n895         if width_ratios is not None:\n896             if 'width_ratios' in gridspec_kw:\n897                 raise ValueError(\"'width_ratios' must not be defined both as \"\n898                                  \"parameter and as key in 'gridspec_kw'\")\n899             gridspec_kw['width_ratios'] = width_ratios\n900 \n901         gs = self.add_gridspec(nrows, ncols, figure=self, **gridspec_kw)\n902         axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,\n903                           subplot_kw=subplot_kw)\n904         return axs\n905 \n906     def delaxes(self, ax):\n907         \"\"\"\n908         Remove the `~.axes.Axes` *ax* from the figure; update the current Axes.\n909         \"\"\"\n910 \n911         def _reset_locators_and_formatters(axis):\n912             # Set the formatters and locators to be associated with axis\n913             # (where previously they may have been associated with another\n914             # Axis instance)\n915             axis.get_major_formatter().set_axis(axis)\n916             axis.get_major_locator().set_axis(axis)\n917             axis.get_minor_formatter().set_axis(axis)\n918             axis.get_minor_locator().set_axis(axis)\n919 \n920         def _break_share_link(ax, grouper):\n921             siblings = grouper.get_siblings(ax)\n922             if len(siblings) > 1:\n923                 grouper.remove(ax)\n924                 for last_ax in siblings:\n925                     if ax is not last_ax:\n926                         return last_ax\n927             return None\n928 \n929         self._axstack.remove(ax)\n930         self._axobservers.process(\"_axes_change_event\", self)\n931         self.stale = True\n932         self._localaxes.remove(ax)\n933         self.canvas.release_mouse(ax)\n934 \n935         # Break link between any shared axes\n936         for name in ax._axis_names:\n937             last_ax = _break_share_link(ax, ax._shared_axes[name])\n938             if last_ax is not None:\n939                 _reset_locators_and_formatters(last_ax._axis_map[name])\n940 \n941         # Break link between any twinned axes\n942         _break_share_link(ax, ax._twinned_axes)\n943 \n944     def clear(self, keep_observers=False):\n945         \"\"\"\n946         Clear the figure.\n947 \n948         Parameters\n949         ----------\n950         keep_observers : bool, default: False\n951             Set *keep_observers* to True if, for example,\n952             a gui widget is tracking the Axes in the figure.\n953         \"\"\"\n954         self.suppressComposite = None\n955 \n956         # first clear the axes in any subfigures\n957         for subfig in self.subfigs:\n958             subfig.clear(keep_observers=keep_observers)\n959         self.subfigs = []\n960 \n961         for ax in tuple(self.axes):  # Iterate over the copy.\n962             ax.clear()\n963             self.delaxes(ax)  # Remove ax from self._axstack.\n964 \n965         self.artists = []\n966         self.lines = []\n967         self.patches = []\n968         self.texts = []\n969         self.images = []\n970         self.legends = []\n971         if not keep_observers:\n972             self._axobservers = cbook.CallbackRegistry()\n973         self._suptitle = None\n974         self._supxlabel = None\n975         self._supylabel = None\n976 \n977         self.stale = True\n978 \n979     # synonym for `clear`.\n980     def clf(self, keep_observers=False):\n981         \"\"\"\n982         [*Discouraged*] Alias for the `clear()` method.\n983 \n984         .. admonition:: Discouraged\n985 \n986             The use of ``clf()`` is discouraged. Use ``clear()`` instead.\n987 \n988         Parameters\n989         ----------\n990         keep_observers : bool, default: False\n991             Set *keep_observers* to True if, for example,\n992             a gui widget is tracking the Axes in the figure.\n993         \"\"\"\n994         return self.clear(keep_observers=keep_observers)\n995 \n996     # Note: the docstring below is modified with replace for the pyplot\n997     # version of this function because the method name differs (plt.figlegend)\n998     # the replacements are:\n999     #    \" legend(\" -> \" figlegend(\" for the signatures\n1000     #    \"fig.legend(\" -> \"plt.figlegend\" for the code examples\n1001     #    \"ax.plot\" -> \"plt.plot\" for consistency in using pyplot when able\n1002     @_docstring.dedent_interpd\n1003     def legend(self, *args, **kwargs):\n1004         \"\"\"\n1005         Place a legend on the figure.\n1006 \n1007         Call signatures::\n1008 \n1009             legend()\n1010             legend(handles, labels)\n1011             legend(handles=handles)\n1012             legend(labels)\n1013 \n1014         The call signatures correspond to the following different ways to use\n1015         this method:\n1016 \n1017         **1. Automatic detection of elements to be shown in the legend**\n1018 \n1019         The elements to be added to the legend are automatically determined,\n1020         when you do not pass in any extra arguments.\n1021 \n1022         In this case, the labels are taken from the artist. You can specify\n1023         them either at artist creation or by calling the\n1024         :meth:`~.Artist.set_label` method on the artist::\n1025 \n1026             ax.plot([1, 2, 3], label='Inline label')\n1027             fig.legend()\n1028 \n1029         or::\n1030 \n1031             line, = ax.plot([1, 2, 3])\n1032             line.set_label('Label via method')\n1033             fig.legend()\n1034 \n1035         Specific lines can be excluded from the automatic legend element\n1036         selection by defining a label starting with an underscore.\n1037         This is default for all artists, so calling `.Figure.legend` without\n1038         any arguments and without setting the labels manually will result in\n1039         no legend being drawn.\n1040 \n1041 \n1042         **2. Explicitly listing the artists and labels in the legend**\n1043 \n1044         For full control of which artists have a legend entry, it is possible\n1045         to pass an iterable of legend artists followed by an iterable of\n1046         legend labels respectively::\n1047 \n1048             fig.legend([line1, line2, line3], ['label1', 'label2', 'label3'])\n1049 \n1050 \n1051         **3. Explicitly listing the artists in the legend**\n1052 \n1053         This is similar to 2, but the labels are taken from the artists'\n1054         label properties. Example::\n1055 \n1056             line1, = ax1.plot([1, 2, 3], label='label1')\n1057             line2, = ax2.plot([1, 2, 3], label='label2')\n1058             fig.legend(handles=[line1, line2])\n1059 \n1060 \n1061         **4. Labeling existing plot elements**\n1062 \n1063         .. admonition:: Discouraged\n1064 \n1065             This call signature is discouraged, because the relation between\n1066             plot elements and labels is only implicit by their order and can\n1067             easily be mixed up.\n1068 \n1069         To make a legend for all artists on all Axes, call this function with\n1070         an iterable of strings, one for each legend item. For example::\n1071 \n1072             fig, (ax1, ax2) = plt.subplots(1, 2)\n1073             ax1.plot([1, 3, 5], color='blue')\n1074             ax2.plot([2, 4, 6], color='red')\n1075             fig.legend(['the blues', 'the reds'])\n1076 \n1077 \n1078         Parameters\n1079         ----------\n1080         handles : list of `.Artist`, optional\n1081             A list of Artists (lines, patches) to be added to the legend.\n1082             Use this together with *labels*, if you need full control on what\n1083             is shown in the legend and the automatic mechanism described above\n1084             is not sufficient.\n1085 \n1086             The length of handles and labels should be the same in this\n1087             case. If they are not, they are truncated to the smaller length.\n1088 \n1089         labels : list of str, optional\n1090             A list of labels to show next to the artists.\n1091             Use this together with *handles*, if you need full control on what\n1092             is shown in the legend and the automatic mechanism described above\n1093             is not sufficient.\n1094 \n1095         Returns\n1096         -------\n1097         `~matplotlib.legend.Legend`\n1098 \n1099         Other Parameters\n1100         ----------------\n1101         %(_legend_kw_figure)s\n1102 \n1103         See Also\n1104         --------\n1105         .Axes.legend\n1106 \n1107         Notes\n1108         -----\n1109         Some artists are not supported by this function.  See\n1110         :ref:`legend_guide` for details.\n1111         \"\"\"\n1112 \n1113         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n1114                 self.axes,\n1115                 *args,\n1116                 **kwargs)\n1117         # check for third arg\n1118         if len(extra_args):\n1119             # _api.warn_deprecated(\n1120             #     \"2.1\",\n1121             #     message=\"Figure.legend will accept no more than two \"\n1122             #     \"positional arguments in the future.  Use \"\n1123             #     \"'fig.legend(handles, labels, loc=location)' \"\n1124             #     \"instead.\")\n1125             # kwargs['loc'] = extra_args[0]\n1126             # extra_args = extra_args[1:]\n1127             pass\n1128         transform = kwargs.pop('bbox_transform', self.transSubfigure)\n1129         # explicitly set the bbox transform if the user hasn't.\n1130         l = mlegend.Legend(self, handles, labels, *extra_args,\n1131                            bbox_transform=transform, **kwargs)\n1132         self.legends.append(l)\n1133         l._remove_method = self.legends.remove\n1134         self.stale = True\n1135         return l\n1136 \n1137     @_docstring.dedent_interpd\n1138     def text(self, x, y, s, fontdict=None, **kwargs):\n1139         \"\"\"\n1140         Add text to figure.\n1141 \n1142         Parameters\n1143         ----------\n1144         x, y : float\n1145             The position to place the text. By default, this is in figure\n1146             coordinates, floats in [0, 1]. The coordinate system can be changed\n1147             using the *transform* keyword.\n1148 \n1149         s : str\n1150             The text string.\n1151 \n1152         fontdict : dict, optional\n1153             A dictionary to override the default text properties. If not given,\n1154             the defaults are determined by :rc:`font.*`. Properties passed as\n1155             *kwargs* override the corresponding ones given in *fontdict*.\n1156 \n1157         Returns\n1158         -------\n1159         `~.text.Text`\n1160 \n1161         Other Parameters\n1162         ----------------\n1163         **kwargs : `~matplotlib.text.Text` properties\n1164             Other miscellaneous text parameters.\n1165 \n1166             %(Text:kwdoc)s\n1167 \n1168         See Also\n1169         --------\n1170         .Axes.text\n1171         .pyplot.text\n1172         \"\"\"\n1173         effective_kwargs = {\n1174             'transform': self.transSubfigure,\n1175             **(fontdict if fontdict is not None else {}),\n1176             **kwargs,\n1177         }\n1178         text = Text(x=x, y=y, text=s, **effective_kwargs)\n1179         text.set_figure(self)\n1180         text.stale_callback = _stale_figure_callback\n1181 \n1182         self.texts.append(text)\n1183         text._remove_method = self.texts.remove\n1184         self.stale = True\n1185         return text\n1186 \n1187     @_docstring.dedent_interpd\n1188     def colorbar(\n1189             self, mappable, cax=None, ax=None, use_gridspec=True, **kwargs):\n1190         \"\"\"\n1191         Add a colorbar to a plot.\n1192 \n1193         Parameters\n1194         ----------\n1195         mappable\n1196             The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`,\n1197             `.ContourSet`, etc.) described by this colorbar.  This argument is\n1198             mandatory for the `.Figure.colorbar` method but optional for the\n1199             `.pyplot.colorbar` function, which sets the default to the current\n1200             image.\n1201 \n1202             Note that one can create a `.ScalarMappable` \"on-the-fly\" to\n1203             generate colorbars not attached to a previously drawn artist, e.g.\n1204             ::\n1205 \n1206                 fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)\n1207 \n1208         cax : `~matplotlib.axes.Axes`, optional\n1209             Axes into which the colorbar will be drawn.\n1210 \n1211         ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional\n1212             One or more parent axes from which space for a new colorbar axes\n1213             will be stolen, if *cax* is None.  This has no effect if *cax* is\n1214             set.\n1215 \n1216         use_gridspec : bool, optional\n1217             If *cax* is ``None``, a new *cax* is created as an instance of\n1218             Axes.  If *ax* is positioned with a subplotspec and *use_gridspec*\n1219             is ``True``, then *cax* is also positioned with a subplotspec.\n1220 \n1221         Returns\n1222         -------\n1223         colorbar : `~matplotlib.colorbar.Colorbar`\n1224 \n1225         Other Parameters\n1226         ----------------\n1227         %(_make_axes_kw_doc)s\n1228         %(_colormap_kw_doc)s\n1229 \n1230         Notes\n1231         -----\n1232         If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is\n1233         included automatically.\n1234 \n1235         The *shrink* kwarg provides a simple way to scale the colorbar with\n1236         respect to the axes. Note that if *cax* is specified, it determines the\n1237         size of the colorbar, and *shrink* and *aspect* are ignored.\n1238 \n1239         For more precise control, you can manually specify the positions of the\n1240         axes objects in which the mappable and the colorbar are drawn.  In this\n1241         case, do not use any of the axes properties kwargs.\n1242 \n1243         It is known that some vector graphics viewers (svg and pdf) render\n1244         white gaps between segments of the colorbar.  This is due to bugs in\n1245         the viewers, not Matplotlib.  As a workaround, the colorbar can be\n1246         rendered with overlapping segments::\n1247 \n1248             cbar = colorbar()\n1249             cbar.solids.set_edgecolor(\"face\")\n1250             draw()\n1251 \n1252         However, this has negative consequences in other circumstances, e.g.\n1253         with semi-transparent images (alpha < 1) and colorbar extensions;\n1254         therefore, this workaround is not used by default (see issue #1188).\n1255         \"\"\"\n1256 \n1257         if ax is None:\n1258             ax = getattr(mappable, \"axes\", None)\n1259 \n1260         if (self.get_layout_engine() is not None and\n1261                 not self.get_layout_engine().colorbar_gridspec):\n1262             use_gridspec = False\n1263         if cax is None:\n1264             if ax is None:\n1265                 raise ValueError(\n1266                     'Unable to determine Axes to steal space for Colorbar. '\n1267                     'Either provide the *cax* argument to use as the Axes for '\n1268                     'the Colorbar, provide the *ax* argument to steal space '\n1269                     'from it, or add *mappable* to an Axes.')\n1270             current_ax = self.gca()\n1271             if (use_gridspec\n1272                     and isinstance(ax, mpl.axes._base._AxesBase)\n1273                     and ax.get_subplotspec()):\n1274                 cax, kwargs = cbar.make_axes_gridspec(ax, **kwargs)\n1275             else:\n1276                 cax, kwargs = cbar.make_axes(ax, **kwargs)\n1277             # make_axes calls add_{axes,subplot} which changes gca; undo that.\n1278             self.sca(current_ax)\n1279             cax.grid(visible=False, which='both', axis='both')\n1280 \n1281         NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar\n1282             'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']\n1283         cb = cbar.Colorbar(cax, mappable, **{\n1284             k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})\n1285         self.stale = True\n1286         return cb\n1287 \n1288     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n1289                         wspace=None, hspace=None):\n1290         \"\"\"\n1291         Adjust the subplot layout parameters.\n1292 \n1293         Unset parameters are left unmodified; initial values are given by\n1294         :rc:`figure.subplot.[name]`.\n1295 \n1296         Parameters\n1297         ----------\n1298         left : float, optional\n1299             The position of the left edge of the subplots,\n1300             as a fraction of the figure width.\n1301         right : float, optional\n1302             The position of the right edge of the subplots,\n1303             as a fraction of the figure width.\n1304         bottom : float, optional\n1305             The position of the bottom edge of the subplots,\n1306             as a fraction of the figure height.\n1307         top : float, optional\n1308             The position of the top edge of the subplots,\n1309             as a fraction of the figure height.\n1310         wspace : float, optional\n1311             The width of the padding between subplots,\n1312             as a fraction of the average Axes width.\n1313         hspace : float, optional\n1314             The height of the padding between subplots,\n1315             as a fraction of the average Axes height.\n1316         \"\"\"\n1317         if (self.get_layout_engine() is not None and\n1318                 not self.get_layout_engine().adjust_compatible):\n1319             _api.warn_external(\n1320                 \"This figure was using a layout engine that is \"\n1321                 \"incompatible with subplots_adjust and/or tight_layout; \"\n1322                 \"not calling subplots_adjust.\")\n1323             return\n1324         self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n1325         for ax in self.axes:\n1326             if ax.get_subplotspec() is not None:\n1327                 ax._set_position(ax.get_subplotspec().get_position(self))\n1328         self.stale = True\n1329 \n1330     def align_xlabels(self, axs=None):\n1331         \"\"\"\n1332         Align the xlabels of subplots in the same subplot column if label\n1333         alignment is being done automatically (i.e. the label position is\n1334         not manually set).\n1335 \n1336         Alignment persists for draw events after this is called.\n1337 \n1338         If a label is on the bottom, it is aligned with labels on Axes that\n1339         also have their label on the bottom and that have the same\n1340         bottom-most subplot row.  If the label is on the top,\n1341         it is aligned with labels on Axes with the same top-most row.\n1342 \n1343         Parameters\n1344         ----------\n1345         axs : list of `~matplotlib.axes.Axes`\n1346             Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes`\n1347             to align the xlabels.\n1348             Default is to align all Axes on the figure.\n1349 \n1350         See Also\n1351         --------\n1352         matplotlib.figure.Figure.align_ylabels\n1353         matplotlib.figure.Figure.align_labels\n1354 \n1355         Notes\n1356         -----\n1357         This assumes that ``axs`` are from the same `.GridSpec`, so that\n1358         their `.SubplotSpec` positions correspond to figure positions.\n1359 \n1360         Examples\n1361         --------\n1362         Example with rotated xtick labels::\n1363 \n1364             fig, axs = plt.subplots(1, 2)\n1365             for tick in axs[0].get_xticklabels():\n1366                 tick.set_rotation(55)\n1367             axs[0].set_xlabel('XLabel 0')\n1368             axs[1].set_xlabel('XLabel 1')\n1369             fig.align_xlabels()\n1370         \"\"\"\n1371         if axs is None:\n1372             axs = self.axes\n1373         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n1374         for ax in axs:\n1375             _log.debug(' Working on: %s', ax.get_xlabel())\n1376             rowspan = ax.get_subplotspec().rowspan\n1377             pos = ax.xaxis.get_label_position()  # top or bottom\n1378             # Search through other axes for label positions that are same as\n1379             # this one and that share the appropriate row number.\n1380             # Add to a grouper associated with each axes of siblings.\n1381             # This list is inspected in `axis.draw` by\n1382             # `axis._update_label_position`.\n1383             for axc in axs:\n1384                 if axc.xaxis.get_label_position() == pos:\n1385                     rowspanc = axc.get_subplotspec().rowspan\n1386                     if (pos == 'top' and rowspan.start == rowspanc.start or\n1387                             pos == 'bottom' and rowspan.stop == rowspanc.stop):\n1388                         # grouper for groups of xlabels to align\n1389                         self._align_label_groups['x'].join(ax, axc)\n1390 \n1391     def align_ylabels(self, axs=None):\n1392         \"\"\"\n1393         Align the ylabels of subplots in the same subplot column if label\n1394         alignment is being done automatically (i.e. the label position is\n1395         not manually set).\n1396 \n1397         Alignment persists for draw events after this is called.\n1398 \n1399         If a label is on the left, it is aligned with labels on Axes that\n1400         also have their label on the left and that have the same\n1401         left-most subplot column.  If the label is on the right,\n1402         it is aligned with labels on Axes with the same right-most column.\n1403 \n1404         Parameters\n1405         ----------\n1406         axs : list of `~matplotlib.axes.Axes`\n1407             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n1408             to align the ylabels.\n1409             Default is to align all Axes on the figure.\n1410 \n1411         See Also\n1412         --------\n1413         matplotlib.figure.Figure.align_xlabels\n1414         matplotlib.figure.Figure.align_labels\n1415 \n1416         Notes\n1417         -----\n1418         This assumes that ``axs`` are from the same `.GridSpec`, so that\n1419         their `.SubplotSpec` positions correspond to figure positions.\n1420 \n1421         Examples\n1422         --------\n1423         Example with large yticks labels::\n1424 \n1425             fig, axs = plt.subplots(2, 1)\n1426             axs[0].plot(np.arange(0, 1000, 50))\n1427             axs[0].set_ylabel('YLabel 0')\n1428             axs[1].set_ylabel('YLabel 1')\n1429             fig.align_ylabels()\n1430         \"\"\"\n1431         if axs is None:\n1432             axs = self.axes\n1433         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]\n1434         for ax in axs:\n1435             _log.debug(' Working on: %s', ax.get_ylabel())\n1436             colspan = ax.get_subplotspec().colspan\n1437             pos = ax.yaxis.get_label_position()  # left or right\n1438             # Search through other axes for label positions that are same as\n1439             # this one and that share the appropriate column number.\n1440             # Add to a list associated with each axes of siblings.\n1441             # This list is inspected in `axis.draw` by\n1442             # `axis._update_label_position`.\n1443             for axc in axs:\n1444                 if axc.yaxis.get_label_position() == pos:\n1445                     colspanc = axc.get_subplotspec().colspan\n1446                     if (pos == 'left' and colspan.start == colspanc.start or\n1447                             pos == 'right' and colspan.stop == colspanc.stop):\n1448                         # grouper for groups of ylabels to align\n1449                         self._align_label_groups['y'].join(ax, axc)\n1450 \n1451     def align_labels(self, axs=None):\n1452         \"\"\"\n1453         Align the xlabels and ylabels of subplots with the same subplots\n1454         row or column (respectively) if label alignment is being\n1455         done automatically (i.e. the label position is not manually set).\n1456 \n1457         Alignment persists for draw events after this is called.\n1458 \n1459         Parameters\n1460         ----------\n1461         axs : list of `~matplotlib.axes.Axes`\n1462             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n1463             to align the labels.\n1464             Default is to align all Axes on the figure.\n1465 \n1466         See Also\n1467         --------\n1468         matplotlib.figure.Figure.align_xlabels\n1469 \n1470         matplotlib.figure.Figure.align_ylabels\n1471         \"\"\"\n1472         self.align_xlabels(axs=axs)\n1473         self.align_ylabels(axs=axs)\n1474 \n1475     def add_gridspec(self, nrows=1, ncols=1, **kwargs):\n1476         \"\"\"\n1477         Return a `.GridSpec` that has this figure as a parent.  This allows\n1478         complex layout of Axes in the figure.\n1479 \n1480         Parameters\n1481         ----------\n1482         nrows : int, default: 1\n1483             Number of rows in grid.\n1484 \n1485         ncols : int, default: 1\n1486             Number of columns in grid.\n1487 \n1488         Returns\n1489         -------\n1490         `.GridSpec`\n1491 \n1492         Other Parameters\n1493         ----------------\n1494         **kwargs\n1495             Keyword arguments are passed to `.GridSpec`.\n1496 \n1497         See Also\n1498         --------\n1499         matplotlib.pyplot.subplots\n1500 \n1501         Examples\n1502         --------\n1503         Adding a subplot that spans two rows::\n1504 \n1505             fig = plt.figure()\n1506             gs = fig.add_gridspec(2, 2)\n1507             ax1 = fig.add_subplot(gs[0, 0])\n1508             ax2 = fig.add_subplot(gs[1, 0])\n1509             # spans two rows:\n1510             ax3 = fig.add_subplot(gs[:, 1])\n1511 \n1512         \"\"\"\n1513 \n1514         _ = kwargs.pop('figure', None)  # pop in case user has added this...\n1515         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)\n1516         return gs\n1517 \n1518     def subfigures(self, nrows=1, ncols=1, squeeze=True,\n1519                    wspace=None, hspace=None,\n1520                    width_ratios=None, height_ratios=None,\n1521                    **kwargs):\n1522         \"\"\"\n1523         Add a set of subfigures to this figure or subfigure.\n1524 \n1525         A subfigure has the same artist methods as a figure, and is logically\n1526         the same as a figure, but cannot print itself.\n1527         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.\n1528 \n1529         Parameters\n1530         ----------\n1531         nrows, ncols : int, default: 1\n1532             Number of rows/columns of the subfigure grid.\n1533 \n1534         squeeze : bool, default: True\n1535             If True, extra dimensions are squeezed out from the returned\n1536             array of subfigures.\n1537 \n1538         wspace, hspace : float, default: None\n1539             The amount of width/height reserved for space between subfigures,\n1540             expressed as a fraction of the average subfigure width/height.\n1541             If not given, the values will be inferred from a figure or\n1542             rcParams when necessary.\n1543 \n1544         width_ratios : array-like of length *ncols*, optional\n1545             Defines the relative widths of the columns. Each column gets a\n1546             relative width of ``width_ratios[i] / sum(width_ratios)``.\n1547             If not given, all columns will have the same width.\n1548 \n1549         height_ratios : array-like of length *nrows*, optional\n1550             Defines the relative heights of the rows. Each row gets a\n1551             relative height of ``height_ratios[i] / sum(height_ratios)``.\n1552             If not given, all rows will have the same height.\n1553         \"\"\"\n1554         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,\n1555                       wspace=wspace, hspace=hspace,\n1556                       width_ratios=width_ratios,\n1557                       height_ratios=height_ratios)\n1558 \n1559         sfarr = np.empty((nrows, ncols), dtype=object)\n1560         for i in range(ncols):\n1561             for j in range(nrows):\n1562                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)\n1563 \n1564         if squeeze:\n1565             # Discarding unneeded dimensions that equal 1.  If we only have one\n1566             # subfigure, just return it instead of a 1-element array.\n1567             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()\n1568         else:\n1569             # Returned axis array will be always 2-d, even if nrows=ncols=1.\n1570             return sfarr\n1571 \n1572     def add_subfigure(self, subplotspec, **kwargs):\n1573         \"\"\"\n1574         Add a `.SubFigure` to the figure as part of a subplot arrangement.\n1575 \n1576         Parameters\n1577         ----------\n1578         subplotspec : `.gridspec.SubplotSpec`\n1579             Defines the region in a parent gridspec where the subfigure will\n1580             be placed.\n1581 \n1582         Returns\n1583         -------\n1584         `.SubFigure`\n1585 \n1586         Other Parameters\n1587         ----------------\n1588         **kwargs\n1589             Are passed to the `.SubFigure` object.\n1590 \n1591         See Also\n1592         --------\n1593         .Figure.subfigures\n1594         \"\"\"\n1595         sf = SubFigure(self, subplotspec, **kwargs)\n1596         self.subfigs += [sf]\n1597         return sf\n1598 \n1599     def sca(self, a):\n1600         \"\"\"Set the current Axes to be *a* and return *a*.\"\"\"\n1601         self._axstack.bubble(a)\n1602         self._axobservers.process(\"_axes_change_event\", self)\n1603         return a\n1604 \n1605     def gca(self):\n1606         \"\"\"\n1607         Get the current Axes.\n1608 \n1609         If there is currently no Axes on this Figure, a new one is created\n1610         using `.Figure.add_subplot`.  (To test whether there is currently an\n1611         Axes on a Figure, check whether ``figure.axes`` is empty.  To test\n1612         whether there is currently a Figure on the pyplot figure stack, check\n1613         whether `.pyplot.get_fignums()` is empty.)\n1614         \"\"\"\n1615         ax = self._axstack.current()\n1616         return ax if ax is not None else self.add_subplot()\n1617 \n1618     def _gci(self):\n1619         # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.\n1620         \"\"\"\n1621         Get the current colorable artist.\n1622 \n1623         Specifically, returns the current `.ScalarMappable` instance (`.Image`\n1624         created by `imshow` or `figimage`, `.Collection` created by `pcolor` or\n1625         `scatter`, etc.), or *None* if no such instance has been defined.\n1626 \n1627         The current image is an attribute of the current Axes, or the nearest\n1628         earlier Axes in the current figure that contains an image.\n1629 \n1630         Notes\n1631         -----\n1632         Historically, the only colorable artists were images; hence the name\n1633         ``gci`` (get current image).\n1634         \"\"\"\n1635         # Look first for an image in the current Axes.\n1636         ax = self._axstack.current()\n1637         if ax is None:\n1638             return None\n1639         im = ax._gci()\n1640         if im is not None:\n1641             return im\n1642         # If there is no image in the current Axes, search for\n1643         # one in a previously created Axes.  Whether this makes\n1644         # sense is debatable, but it is the documented behavior.\n1645         for ax in reversed(self.axes):\n1646             im = ax._gci()\n1647             if im is not None:\n1648                 return im\n1649         return None\n1650 \n1651     def _process_projection_requirements(\n1652             self, *args, axes_class=None, polar=False, projection=None,\n1653             **kwargs):\n1654         \"\"\"\n1655         Handle the args/kwargs to add_axes/add_subplot/gca, returning::\n1656 \n1657             (axes_proj_class, proj_class_kwargs)\n1658 \n1659         which can be used for new Axes initialization/identification.\n1660         \"\"\"\n1661         if axes_class is not None:\n1662             if polar or projection is not None:\n1663                 raise ValueError(\n1664                     \"Cannot combine 'axes_class' and 'projection' or 'polar'\")\n1665             projection_class = axes_class\n1666         else:\n1667 \n1668             if polar:\n1669                 if projection is not None and projection != 'polar':\n1670                     raise ValueError(\n1671                         f\"polar={polar}, yet projection={projection!r}. \"\n1672                         \"Only one of these arguments should be supplied.\"\n1673                     )\n1674                 projection = 'polar'\n1675 \n1676             if isinstance(projection, str) or projection is None:\n1677                 projection_class = projections.get_projection_class(projection)\n1678             elif hasattr(projection, '_as_mpl_axes'):\n1679                 projection_class, extra_kwargs = projection._as_mpl_axes()\n1680                 kwargs.update(**extra_kwargs)\n1681             else:\n1682                 raise TypeError(\n1683                     f\"projection must be a string, None or implement a \"\n1684                     f\"_as_mpl_axes method, not {projection!r}\")\n1685         return projection_class, kwargs\n1686 \n1687     def get_default_bbox_extra_artists(self):\n1688         bbox_artists = [artist for artist in self.get_children()\n1689                         if (artist.get_visible() and artist.get_in_layout())]\n1690         for ax in self.axes:\n1691             if ax.get_visible():\n1692                 bbox_artists.extend(ax.get_default_bbox_extra_artists())\n1693         return bbox_artists\n1694 \n1695     @_api.make_keyword_only(\"3.8\", \"bbox_extra_artists\")\n1696     def get_tightbbox(self, renderer=None, bbox_extra_artists=None):\n1697         \"\"\"\n1698         Return a (tight) bounding box of the figure *in inches*.\n1699 \n1700         Note that `.FigureBase` differs from all other artists, which return\n1701         their `.Bbox` in pixels.\n1702 \n1703         Artists that have ``artist.set_in_layout(False)`` are not included\n1704         in the bbox.\n1705 \n1706         Parameters\n1707         ----------\n1708         renderer : `.RendererBase` subclass\n1709             Renderer that will be used to draw the figures (i.e.\n1710             ``fig.canvas.get_renderer()``)\n1711 \n1712         bbox_extra_artists : list of `.Artist` or ``None``\n1713             List of artists to include in the tight bounding box.  If\n1714             ``None`` (default), then all artist children of each Axes are\n1715             included in the tight bounding box.\n1716 \n1717         Returns\n1718         -------\n1719         `.BboxBase`\n1720             containing the bounding box (in figure inches).\n1721         \"\"\"\n1722 \n1723         if renderer is None:\n1724             renderer = self.figure._get_renderer()\n1725 \n1726         bb = []\n1727         if bbox_extra_artists is None:\n1728             artists = self.get_default_bbox_extra_artists()\n1729         else:\n1730             artists = bbox_extra_artists\n1731 \n1732         for a in artists:\n1733             bbox = a.get_tightbbox(renderer)\n1734             if bbox is not None:\n1735                 bb.append(bbox)\n1736 \n1737         for ax in self.axes:\n1738             if ax.get_visible():\n1739                 # some axes don't take the bbox_extra_artists kwarg so we\n1740                 # need this conditional....\n1741                 try:\n1742                     bbox = ax.get_tightbbox(\n1743                         renderer, bbox_extra_artists=bbox_extra_artists)\n1744                 except TypeError:\n1745                     bbox = ax.get_tightbbox(renderer)\n1746                 bb.append(bbox)\n1747         bb = [b for b in bb\n1748               if (np.isfinite(b.width) and np.isfinite(b.height)\n1749                   and (b.width != 0 or b.height != 0))]\n1750 \n1751         isfigure = hasattr(self, 'bbox_inches')\n1752         if len(bb) == 0:\n1753             if isfigure:\n1754                 return self.bbox_inches\n1755             else:\n1756                 # subfigures do not have bbox_inches, but do have a bbox\n1757                 bb = [self.bbox]\n1758 \n1759         _bbox = Bbox.union(bb)\n1760 \n1761         if isfigure:\n1762             # transform from pixels to inches...\n1763             _bbox = TransformedBbox(_bbox, self.dpi_scale_trans.inverted())\n1764 \n1765         return _bbox\n1766 \n1767     @staticmethod\n1768     def _norm_per_subplot_kw(per_subplot_kw):\n1769         expanded = {}\n1770         for k, v in per_subplot_kw.items():\n1771             if isinstance(k, tuple):\n1772                 for sub_key in k:\n1773                     if sub_key in expanded:\n1774                         raise ValueError(\n1775                             f'The key {sub_key!r} appears multiple times.'\n1776                             )\n1777                     expanded[sub_key] = v\n1778             else:\n1779                 if k in expanded:\n1780                     raise ValueError(\n1781                         f'The key {k!r} appears multiple times.'\n1782                     )\n1783                 expanded[k] = v\n1784         return expanded\n1785 \n1786     @staticmethod\n1787     def _normalize_grid_string(layout):\n1788         if '\\n' not in layout:\n1789             # single-line string\n1790             return [list(ln) for ln in layout.split(';')]\n1791         else:\n1792             # multi-line string\n1793             layout = inspect.cleandoc(layout)\n1794             return [list(ln) for ln in layout.strip('\\n').split('\\n')]\n1795 \n1796     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,\n1797                        width_ratios=None, height_ratios=None,\n1798                        empty_sentinel='.',\n1799                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):\n1800         \"\"\"\n1801         Build a layout of Axes based on ASCII art or nested lists.\n1802 \n1803         This is a helper function to build complex GridSpec layouts visually.\n1804 \n1805         See :ref:`mosaic`\n1806         for an example and full API documentation\n1807 \n1808         Parameters\n1809         ----------\n1810         mosaic : list of list of {hashable or nested} or str\n1811 \n1812             A visual layout of how you want your Axes to be arranged\n1813             labeled as strings.  For example ::\n1814 \n1815                x = [['A panel', 'A panel', 'edge'],\n1816                     ['C panel', '.',       'edge']]\n1817 \n1818             produces 4 Axes:\n1819 \n1820             - 'A panel' which is 1 row high and spans the first two columns\n1821             - 'edge' which is 2 rows high and is on the right edge\n1822             - 'C panel' which in 1 row and 1 column wide in the bottom left\n1823             - a blank space 1 row and 1 column wide in the bottom center\n1824 \n1825             Any of the entries in the layout can be a list of lists\n1826             of the same form to create nested layouts.\n1827 \n1828             If input is a str, then it can either be a multi-line string of\n1829             the form ::\n1830 \n1831               '''\n1832               AAE\n1833               C.E\n1834               '''\n1835 \n1836             where each character is a column and each line is a row. Or it\n1837             can be a single-line string where rows are separated by ``;``::\n1838 \n1839               'AB;CC'\n1840 \n1841             The string notation allows only single character Axes labels and\n1842             does not support nesting but is very terse.\n1843 \n1844             The Axes identifiers may be `str` or a non-iterable hashable\n1845             object (e.g. `tuple` s may not be used).\n1846 \n1847         sharex, sharey : bool, default: False\n1848             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1849             among all subplots.  In that case, tick label visibility and axis\n1850             units behave as for `subplots`.  If False, each subplot's x- or\n1851             y-axis will be independent.\n1852 \n1853         width_ratios : array-like of length *ncols*, optional\n1854             Defines the relative widths of the columns. Each column gets a\n1855             relative width of ``width_ratios[i] / sum(width_ratios)``.\n1856             If not given, all columns will have the same width.  Equivalent\n1857             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested\n1858             layouts, this argument applies only to the outer layout.\n1859 \n1860         height_ratios : array-like of length *nrows*, optional\n1861             Defines the relative heights of the rows. Each row gets a\n1862             relative height of ``height_ratios[i] / sum(height_ratios)``.\n1863             If not given, all rows will have the same height. Equivalent\n1864             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested\n1865             layouts, this argument applies only to the outer layout.\n1866 \n1867         subplot_kw : dict, optional\n1868             Dictionary with keywords passed to the `.Figure.add_subplot` call\n1869             used to create each subplot.  These values may be overridden by\n1870             values in *per_subplot_kw*.\n1871 \n1872         per_subplot_kw : dict, optional\n1873             A dictionary mapping the Axes identifiers or tuples of identifiers\n1874             to a dictionary of keyword arguments to be passed to the\n1875             `.Figure.add_subplot` call used to create each subplot.  The values\n1876             in these dictionaries have precedence over the values in\n1877             *subplot_kw*.\n1878 \n1879             If *mosaic* is a string, and thus all keys are single characters,\n1880             it is possible to use a single string instead of a tuple as keys;\n1881             i.e. ``\"AB\"`` is equivalent to ``(\"A\", \"B\")``.\n1882 \n1883             .. versionadded:: 3.7\n1884 \n1885         gridspec_kw : dict, optional\n1886             Dictionary with keywords passed to the `.GridSpec` constructor used\n1887             to create the grid the subplots are placed on. In the case of\n1888             nested layouts, this argument applies only to the outer layout.\n1889             For more complex layouts, users should use `.Figure.subfigures`\n1890             to create the nesting.\n1891 \n1892         empty_sentinel : object, optional\n1893             Entry in the layout to mean \"leave this space empty\".  Defaults\n1894             to ``'.'``. Note, if *layout* is a string, it is processed via\n1895             `inspect.cleandoc` to remove leading white space, which may\n1896             interfere with using white-space as the empty sentinel.\n1897 \n1898         Returns\n1899         -------\n1900         dict[label, Axes]\n1901            A dictionary mapping the labels to the Axes objects.  The order of\n1902            the axes is left-to-right and top-to-bottom of their position in the\n1903            total layout.\n1904 \n1905         \"\"\"\n1906         subplot_kw = subplot_kw or {}\n1907         gridspec_kw = dict(gridspec_kw or {})\n1908         per_subplot_kw = per_subplot_kw or {}\n1909 \n1910         if height_ratios is not None:\n1911             if 'height_ratios' in gridspec_kw:\n1912                 raise ValueError(\"'height_ratios' must not be defined both as \"\n1913                                  \"parameter and as key in 'gridspec_kw'\")\n1914             gridspec_kw['height_ratios'] = height_ratios\n1915         if width_ratios is not None:\n1916             if 'width_ratios' in gridspec_kw:\n1917                 raise ValueError(\"'width_ratios' must not be defined both as \"\n1918                                  \"parameter and as key in 'gridspec_kw'\")\n1919             gridspec_kw['width_ratios'] = width_ratios\n1920 \n1921         # special-case string input\n1922         if isinstance(mosaic, str):\n1923             mosaic = self._normalize_grid_string(mosaic)\n1924             per_subplot_kw = {\n1925                 tuple(k): v for k, v in per_subplot_kw.items()\n1926             }\n1927 \n1928         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)\n1929 \n1930         # Only accept strict bools to allow a possible future API expansion.\n1931         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)\n1932 \n1933         def _make_array(inp):\n1934             \"\"\"\n1935             Convert input into 2D array\n1936 \n1937             We need to have this internal function rather than\n1938             ``np.asarray(..., dtype=object)`` so that a list of lists\n1939             of lists does not get converted to an array of dimension > 2.\n1940 \n1941             Returns\n1942             -------\n1943             2D object array\n1944             \"\"\"\n1945             r0, *rest = inp\n1946             if isinstance(r0, str):\n1947                 raise ValueError('List mosaic specification must be 2D')\n1948             for j, r in enumerate(rest, start=1):\n1949                 if isinstance(r, str):\n1950                     raise ValueError('List mosaic specification must be 2D')\n1951                 if len(r0) != len(r):\n1952                     raise ValueError(\n1953                         \"All of the rows must be the same length, however \"\n1954                         f\"the first row ({r0!r}) has length {len(r0)} \"\n1955                         f\"and row {j} ({r!r}) has length {len(r)}.\"\n1956                     )\n1957             out = np.zeros((len(inp), len(r0)), dtype=object)\n1958             for j, r in enumerate(inp):\n1959                 for k, v in enumerate(r):\n1960                     out[j, k] = v\n1961             return out\n1962 \n1963         def _identify_keys_and_nested(mosaic):\n1964             \"\"\"\n1965             Given a 2D object array, identify unique IDs and nested mosaics\n1966 \n1967             Parameters\n1968             ----------\n1969             mosaic : 2D object array\n1970 \n1971             Returns\n1972             -------\n1973             unique_ids : tuple\n1974                 The unique non-sub mosaic entries in this mosaic\n1975             nested : dict[tuple[int, int], 2D object array]\n1976             \"\"\"\n1977             # make sure we preserve the user supplied order\n1978             unique_ids = cbook._OrderedSet()\n1979             nested = {}\n1980             for j, row in enumerate(mosaic):\n1981                 for k, v in enumerate(row):\n1982                     if v == empty_sentinel:\n1983                         continue\n1984                     elif not cbook.is_scalar_or_string(v):\n1985                         nested[(j, k)] = _make_array(v)\n1986                     else:\n1987                         unique_ids.add(v)\n1988 \n1989             return tuple(unique_ids), nested\n1990 \n1991         def _do_layout(gs, mosaic, unique_ids, nested):\n1992             \"\"\"\n1993             Recursively do the mosaic.\n1994 \n1995             Parameters\n1996             ----------\n1997             gs : GridSpec\n1998             mosaic : 2D object array\n1999                 The input converted to a 2D array for this level.\n2000             unique_ids : tuple\n2001                 The identified scalar labels at this level of nesting.\n2002             nested : dict[tuple[int, int]], 2D object array\n2003                 The identified nested mosaics, if any.\n2004 \n2005             Returns\n2006             -------\n2007             dict[label, Axes]\n2008                 A flat dict of all of the Axes created.\n2009             \"\"\"\n2010             output = dict()\n2011 \n2012             # we need to merge together the Axes at this level and the axes\n2013             # in the (recursively) nested sub-mosaics so that we can add\n2014             # them to the figure in the \"natural\" order if you were to\n2015             # ravel in c-order all of the Axes that will be created\n2016             #\n2017             # This will stash the upper left index of each object (axes or\n2018             # nested mosaic) at this level\n2019             this_level = dict()\n2020 \n2021             # go through the unique keys,\n2022             for name in unique_ids:\n2023                 # sort out where each axes starts/ends\n2024                 indx = np.argwhere(mosaic == name)\n2025                 start_row, start_col = np.min(indx, axis=0)\n2026                 end_row, end_col = np.max(indx, axis=0) + 1\n2027                 # and construct the slice object\n2028                 slc = (slice(start_row, end_row), slice(start_col, end_col))\n2029                 # some light error checking\n2030                 if (mosaic[slc] != name).any():\n2031                     raise ValueError(\n2032                         f\"While trying to layout\\n{mosaic!r}\\n\"\n2033                         f\"we found that the label {name!r} specifies a \"\n2034                         \"non-rectangular or non-contiguous area.\")\n2035                 # and stash this slice for later\n2036                 this_level[(start_row, start_col)] = (name, slc, 'axes')\n2037 \n2038             # do the same thing for the nested mosaics (simpler because these\n2039             # can not be spans yet!)\n2040             for (j, k), nested_mosaic in nested.items():\n2041                 this_level[(j, k)] = (None, nested_mosaic, 'nested')\n2042 \n2043             # now go through the things in this level and add them\n2044             # in order left-to-right top-to-bottom\n2045             for key in sorted(this_level):\n2046                 name, arg, method = this_level[key]\n2047                 # we are doing some hokey function dispatch here based\n2048                 # on the 'method' string stashed above to sort out if this\n2049                 # element is an Axes or a nested mosaic.\n2050                 if method == 'axes':\n2051                     slc = arg\n2052                     # add a single axes\n2053                     if name in output:\n2054                         raise ValueError(f\"There are duplicate keys {name} \"\n2055                                          f\"in the layout\\n{mosaic!r}\")\n2056                     ax = self.add_subplot(\n2057                         gs[slc], **{\n2058                             'label': str(name),\n2059                             **subplot_kw,\n2060                             **per_subplot_kw.get(name, {})\n2061                         }\n2062                     )\n2063                     output[name] = ax\n2064                 elif method == 'nested':\n2065                     nested_mosaic = arg\n2066                     j, k = key\n2067                     # recursively add the nested mosaic\n2068                     rows, cols = nested_mosaic.shape\n2069                     nested_output = _do_layout(\n2070                         gs[j, k].subgridspec(rows, cols),\n2071                         nested_mosaic,\n2072                         *_identify_keys_and_nested(nested_mosaic)\n2073                     )\n2074                     overlap = set(output) & set(nested_output)\n2075                     if overlap:\n2076                         raise ValueError(\n2077                             f\"There are duplicate keys {overlap} \"\n2078                             f\"between the outer layout\\n{mosaic!r}\\n\"\n2079                             f\"and the nested layout\\n{nested_mosaic}\"\n2080                         )\n2081                     output.update(nested_output)\n2082                 else:\n2083                     raise RuntimeError(\"This should never happen\")\n2084             return output\n2085 \n2086         mosaic = _make_array(mosaic)\n2087         rows, cols = mosaic.shape\n2088         gs = self.add_gridspec(rows, cols, **gridspec_kw)\n2089         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n2090         ax0 = next(iter(ret.values()))\n2091         for ax in ret.values():\n2092             if sharex:\n2093                 ax.sharex(ax0)\n2094                 ax._label_outer_xaxis(check_patch=True)\n2095             if sharey:\n2096                 ax.sharey(ax0)\n2097                 ax._label_outer_yaxis(check_patch=True)\n2098         if extra := set(per_subplot_kw) - set(ret):\n2099             raise ValueError(\n2100                 f\"The keys {extra} are in *per_subplot_kw* \"\n2101                 \"but not in the mosaic.\"\n2102             )\n2103         return ret\n2104 \n2105     def _set_artist_props(self, a):\n2106         if a != self:\n2107             a.set_figure(self)\n2108         a.stale_callback = _stale_figure_callback\n2109         a.set_transform(self.transSubfigure)\n2110 \n2111 \n2112 @_docstring.interpd\n2113 class SubFigure(FigureBase):\n2114     \"\"\"\n2115     Logical figure that can be placed inside a figure.\n2116 \n2117     Typically instantiated using `.Figure.add_subfigure` or\n2118     `.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has\n2119     the same methods as a figure except for those particularly tied to the size\n2120     or dpi of the figure, and is confined to a prescribed region of the figure.\n2121     For example the following puts two subfigures side-by-side::\n2122 \n2123         fig = plt.figure()\n2124         sfigs = fig.subfigures(1, 2)\n2125         axsL = sfigs[0].subplots(1, 2)\n2126         axsR = sfigs[1].subplots(2, 1)\n2127 \n2128     See :doc:`/gallery/subplots_axes_and_figures/subfigures`\n2129     \"\"\"\n2130     callbacks = _api.deprecated(\n2131             \"3.6\", alternative=(\"the 'resize_event' signal in \"\n2132                                 \"Figure.canvas.callbacks\")\n2133             )(property(lambda self: self._fig_callbacks))\n2134 \n2135     def __init__(self, parent, subplotspec, *,\n2136                  facecolor=None,\n2137                  edgecolor=None,\n2138                  linewidth=0.0,\n2139                  frameon=None,\n2140                  **kwargs):\n2141         \"\"\"\n2142         Parameters\n2143         ----------\n2144         parent : `.Figure` or `.SubFigure`\n2145             Figure or subfigure that contains the SubFigure.  SubFigures\n2146             can be nested.\n2147 \n2148         subplotspec : `.gridspec.SubplotSpec`\n2149             Defines the region in a parent gridspec where the subfigure will\n2150             be placed.\n2151 \n2152         facecolor : default: ``\"none\"``\n2153             The figure patch face color; transparent by default.\n2154 \n2155         edgecolor : default: :rc:`figure.edgecolor`\n2156             The figure patch edge color.\n2157 \n2158         linewidth : float\n2159             The linewidth of the frame (i.e. the edge linewidth of the figure\n2160             patch).\n2161 \n2162         frameon : bool, default: :rc:`figure.frameon`\n2163             If ``False``, suppress drawing the figure background patch.\n2164 \n2165         Other Parameters\n2166         ----------------\n2167         **kwargs : `.SubFigure` properties, optional\n2168 \n2169             %(SubFigure:kwdoc)s\n2170         \"\"\"\n2171         super().__init__(**kwargs)\n2172         if facecolor is None:\n2173             facecolor = \"none\"\n2174         if edgecolor is None:\n2175             edgecolor = mpl.rcParams['figure.edgecolor']\n2176         if frameon is None:\n2177             frameon = mpl.rcParams['figure.frameon']\n2178 \n2179         self._subplotspec = subplotspec\n2180         self._parent = parent\n2181         self.figure = parent.figure\n2182         self._fig_callbacks = parent._fig_callbacks\n2183 \n2184         # subfigures use the parent axstack\n2185         self._axstack = parent._axstack\n2186         self.subplotpars = parent.subplotpars\n2187         self.dpi_scale_trans = parent.dpi_scale_trans\n2188         self._axobservers = parent._axobservers\n2189         self.canvas = parent.canvas\n2190         self.transFigure = parent.transFigure\n2191         self.bbox_relative = None\n2192         self._redo_transform_rel_fig()\n2193         self.figbbox = self._parent.figbbox\n2194         self.bbox = TransformedBbox(self.bbox_relative,\n2195                                     self._parent.transSubfigure)\n2196         self.transSubfigure = BboxTransformTo(self.bbox)\n2197 \n2198         self.patch = Rectangle(\n2199             xy=(0, 0), width=1, height=1, visible=frameon,\n2200             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n2201             # Don't let the figure patch influence bbox calculation.\n2202             in_layout=False, transform=self.transSubfigure)\n2203         self._set_artist_props(self.patch)\n2204         self.patch.set_antialiased(False)\n2205 \n2206     @property\n2207     def dpi(self):\n2208         return self._parent.dpi\n2209 \n2210     @dpi.setter\n2211     def dpi(self, value):\n2212         self._parent.dpi = value\n2213 \n2214     def get_dpi(self):\n2215         \"\"\"\n2216         Return the resolution of the parent figure in dots-per-inch as a float.\n2217         \"\"\"\n2218         return self._parent.dpi\n2219 \n2220     def set_dpi(self, val):\n2221         \"\"\"\n2222         Set the resolution of parent figure in dots-per-inch.\n2223 \n2224         Parameters\n2225         ----------\n2226         val : float\n2227         \"\"\"\n2228         self._parent.dpi = val\n2229         self.stale = True\n2230 \n2231     def _get_renderer(self):\n2232         return self._parent._get_renderer()\n2233 \n2234     def _redo_transform_rel_fig(self, bbox=None):\n2235         \"\"\"\n2236         Make the transSubfigure bbox relative to Figure transform.\n2237 \n2238         Parameters\n2239         ----------\n2240         bbox : bbox or None\n2241             If not None, then the bbox is used for relative bounding box.\n2242             Otherwise, it is calculated from the subplotspec.\n2243         \"\"\"\n2244         if bbox is not None:\n2245             self.bbox_relative.p0 = bbox.p0\n2246             self.bbox_relative.p1 = bbox.p1\n2247             return\n2248         # need to figure out *where* this subplotspec is.\n2249         gs = self._subplotspec.get_gridspec()\n2250         wr = np.asarray(gs.get_width_ratios())\n2251         hr = np.asarray(gs.get_height_ratios())\n2252         dx = wr[self._subplotspec.colspan].sum() / wr.sum()\n2253         dy = hr[self._subplotspec.rowspan].sum() / hr.sum()\n2254         x0 = wr[:self._subplotspec.colspan.start].sum() / wr.sum()\n2255         y0 = 1 - hr[:self._subplotspec.rowspan.stop].sum() / hr.sum()\n2256         if self.bbox_relative is None:\n2257             self.bbox_relative = Bbox.from_bounds(x0, y0, dx, dy)\n2258         else:\n2259             self.bbox_relative.p0 = (x0, y0)\n2260             self.bbox_relative.p1 = (x0 + dx, y0 + dy)\n2261 \n2262     def get_constrained_layout(self):\n2263         \"\"\"\n2264         Return whether constrained layout is being used.\n2265 \n2266         See :ref:`constrainedlayout_guide`.\n2267         \"\"\"\n2268         return self._parent.get_constrained_layout()\n2269 \n2270     def get_constrained_layout_pads(self, relative=False):\n2271         \"\"\"\n2272         Get padding for ``constrained_layout``.\n2273 \n2274         Returns a list of ``w_pad, h_pad`` in inches and\n2275         ``wspace`` and ``hspace`` as fractions of the subplot.\n2276 \n2277         See :ref:`constrainedlayout_guide`.\n2278 \n2279         Parameters\n2280         ----------\n2281         relative : bool\n2282             If `True`, then convert from inches to figure relative.\n2283         \"\"\"\n2284         return self._parent.get_constrained_layout_pads(relative=relative)\n2285 \n2286     def get_layout_engine(self):\n2287         return self._parent.get_layout_engine()\n2288 \n2289     @property\n2290     def axes(self):\n2291         \"\"\"\n2292         List of Axes in the SubFigure.  You can access and modify the Axes\n2293         in the SubFigure through this list.\n2294 \n2295         Modifying this list has no effect. Instead, use `~.SubFigure.add_axes`,\n2296         `~.SubFigure.add_subplot` or `~.SubFigure.delaxes` to add or remove an\n2297         Axes.\n2298 \n2299         Note: The `.SubFigure.axes` property and `~.SubFigure.get_axes` method\n2300         are equivalent.\n2301         \"\"\"\n2302         return self._localaxes[:]\n2303 \n2304     get_axes = axes.fget\n2305 \n2306     def draw(self, renderer):\n2307         # docstring inherited\n2308 \n2309         # draw the figure bounding box, perhaps none for white figure\n2310         if not self.get_visible():\n2311             return\n2312 \n2313         artists = self._get_draw_artists(renderer)\n2314 \n2315         try:\n2316             renderer.open_group('subfigure', gid=self.get_gid())\n2317             self.patch.draw(renderer)\n2318             mimage._draw_list_compositing_images(\n2319                 renderer, self, artists, self.figure.suppressComposite)\n2320             for sfig in self.subfigs:\n2321                 sfig.draw(renderer)\n2322             renderer.close_group('subfigure')\n2323 \n2324         finally:\n2325             self.stale = False\n2326 \n2327 \n2328 @_docstring.interpd\n2329 class Figure(FigureBase):\n2330     \"\"\"\n2331     The top level container for all the plot elements.\n2332 \n2333     Attributes\n2334     ----------\n2335     patch\n2336         The `.Rectangle` instance representing the figure background patch.\n2337 \n2338     suppressComposite\n2339         For multiple images, the figure will make composite images\n2340         depending on the renderer option_image_nocomposite function.  If\n2341         *suppressComposite* is a boolean, this will override the renderer.\n2342     \"\"\"\n2343     # Remove the self._fig_callbacks properties on figure and subfigure\n2344     # after the deprecation expires.\n2345     callbacks = _api.deprecated(\n2346         \"3.6\", alternative=(\"the 'resize_event' signal in \"\n2347                             \"Figure.canvas.callbacks\")\n2348         )(property(lambda self: self._fig_callbacks))\n2349 \n2350     def __str__(self):\n2351         return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n2352 \n2353     def __repr__(self):\n2354         return \"<{clsname} size {h:g}x{w:g} with {naxes} Axes>\".format(\n2355             clsname=self.__class__.__name__,\n2356             h=self.bbox.size[0], w=self.bbox.size[1],\n2357             naxes=len(self.axes),\n2358         )\n2359 \n2360     def __init__(self,\n2361                  figsize=None,\n2362                  dpi=None,\n2363                  *,\n2364                  facecolor=None,\n2365                  edgecolor=None,\n2366                  linewidth=0.0,\n2367                  frameon=None,\n2368                  subplotpars=None,  # rc figure.subplot.*\n2369                  tight_layout=None,  # rc figure.autolayout\n2370                  constrained_layout=None,  # rc figure.constrained_layout.use\n2371                  layout=None,\n2372                  **kwargs\n2373                  ):\n2374         \"\"\"\n2375         Parameters\n2376         ----------\n2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`\n2378             Figure dimension ``(width, height)`` in inches.\n2379 \n2380         dpi : float, default: :rc:`figure.dpi`\n2381             Dots per inch.\n2382 \n2383         facecolor : default: :rc:`figure.facecolor`\n2384             The figure patch facecolor.\n2385 \n2386         edgecolor : default: :rc:`figure.edgecolor`\n2387             The figure patch edge color.\n2388 \n2389         linewidth : float\n2390             The linewidth of the frame (i.e. the edge linewidth of the figure\n2391             patch).\n2392 \n2393         frameon : bool, default: :rc:`figure.frameon`\n2394             If ``False``, suppress drawing the figure background patch.\n2395 \n2396         subplotpars : `SubplotParams`\n2397             Subplot parameters. If not given, the default subplot\n2398             parameters :rc:`figure.subplot.*` are used.\n2399 \n2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`\n2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.\n2402 \n2403             .. admonition:: Discouraged\n2404 \n2405                 The use of this parameter is discouraged. Please use\n2406                 ``layout='tight'`` instead for the common case of\n2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.\n2408 \n2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`\n2410             This is equal to ``layout='constrained'``.\n2411 \n2412             .. admonition:: Discouraged\n2413 \n2414                 The use of this parameter is discouraged. Please use\n2415                 ``layout='constrained'`` instead.\n2416 \n2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \\\n2418 None}, default: None\n2419             The layout mechanism for positioning of plot elements to avoid\n2420             overlapping Axes decorations (labels, ticks, etc). Note that\n2421             layout managers can have significant performance penalties.\n2422 \n2423             - 'constrained': The constrained layout solver adjusts axes sizes\n2424               to avoid overlapping axes decorations.  Can handle complex plot\n2425               layouts and colorbars, and is thus recommended.\n2426 \n2427               See :ref:`constrainedlayout_guide`\n2428               for examples.\n2429 \n2430             - 'compressed': uses the same algorithm as 'constrained', but\n2431               removes extra space between fixed-aspect-ratio Axes.  Best for\n2432               simple grids of axes.\n2433 \n2434             - 'tight': Use the tight layout mechanism. This is a relatively\n2435               simple algorithm that adjusts the subplot parameters so that\n2436               decorations do not overlap. See `.Figure.set_tight_layout` for\n2437               further details.\n2438 \n2439             - 'none': Do not use a layout engine.\n2440 \n2441             - A `.LayoutEngine` instance. Builtin layout classes are\n2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily\n2443               accessible by 'constrained' and 'tight'.  Passing an instance\n2444               allows third parties to provide their own layout engine.\n2445 \n2446             If not given, fall back to using the parameters *tight_layout* and\n2447             *constrained_layout*, including their config defaults\n2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.\n2449 \n2450         Other Parameters\n2451         ----------------\n2452         **kwargs : `.Figure` properties, optional\n2453 \n2454             %(Figure:kwdoc)s\n2455         \"\"\"\n2456         super().__init__(**kwargs)\n2457         self._layout_engine = None\n2458 \n2459         if layout is not None:\n2460             if (tight_layout is not None):\n2461                 _api.warn_external(\n2462                     \"The Figure parameters 'layout' and 'tight_layout' cannot \"\n2463                     \"be used together. Please use 'layout' only.\")\n2464             if (constrained_layout is not None):\n2465                 _api.warn_external(\n2466                     \"The Figure parameters 'layout' and 'constrained_layout' \"\n2467                     \"cannot be used together. Please use 'layout' only.\")\n2468             self.set_layout_engine(layout=layout)\n2469         elif tight_layout is not None:\n2470             if constrained_layout is not None:\n2471                 _api.warn_external(\n2472                     \"The Figure parameters 'tight_layout' and \"\n2473                     \"'constrained_layout' cannot be used together. Please use \"\n2474                     \"'layout' parameter\")\n2475             self.set_layout_engine(layout='tight')\n2476             if isinstance(tight_layout, dict):\n2477                 self.get_layout_engine().set(**tight_layout)\n2478         elif constrained_layout is not None:\n2479             if isinstance(constrained_layout, dict):\n2480                 self.set_layout_engine(layout='constrained')\n2481                 self.get_layout_engine().set(**constrained_layout)\n2482             elif constrained_layout:\n2483                 self.set_layout_engine(layout='constrained')\n2484 \n2485         else:\n2486             # everything is None, so use default:\n2487             self.set_layout_engine(layout=layout)\n2488 \n2489         self._fig_callbacks = cbook.CallbackRegistry(signals=[\"dpi_changed\"])\n2490         # Callbacks traditionally associated with the canvas (and exposed with\n2491         # a proxy property), but that actually need to be on the figure for\n2492         # pickling.\n2493         self._canvas_callbacks = cbook.CallbackRegistry(\n2494             signals=FigureCanvasBase.events)\n2495         connect = self._canvas_callbacks._connect_picklable\n2496         self._mouse_key_ids = [\n2497             connect('key_press_event', backend_bases._key_handler),\n2498             connect('key_release_event', backend_bases._key_handler),\n2499             connect('key_release_event', backend_bases._key_handler),\n2500             connect('button_press_event', backend_bases._mouse_handler),\n2501             connect('button_release_event', backend_bases._mouse_handler),\n2502             connect('scroll_event', backend_bases._mouse_handler),\n2503             connect('motion_notify_event', backend_bases._mouse_handler),\n2504         ]\n2505         self._button_pick_id = connect('button_press_event', self.pick)\n2506         self._scroll_pick_id = connect('scroll_event', self.pick)\n2507 \n2508         if figsize is None:\n2509             figsize = mpl.rcParams['figure.figsize']\n2510         if dpi is None:\n2511             dpi = mpl.rcParams['figure.dpi']\n2512         if facecolor is None:\n2513             facecolor = mpl.rcParams['figure.facecolor']\n2514         if edgecolor is None:\n2515             edgecolor = mpl.rcParams['figure.edgecolor']\n2516         if frameon is None:\n2517             frameon = mpl.rcParams['figure.frameon']\n2518 \n2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():\n2520             raise ValueError('figure size must be positive finite not '\n2521                              f'{figsize}')\n2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n2523 \n2524         self.dpi_scale_trans = Affine2D().scale(dpi)\n2525         # do not use property as it will trigger\n2526         self._dpi = dpi\n2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n2528         self.figbbox = self.bbox\n2529         self.transFigure = BboxTransformTo(self.bbox)\n2530         self.transSubfigure = self.transFigure\n2531 \n2532         self.patch = Rectangle(\n2533             xy=(0, 0), width=1, height=1, visible=frameon,\n2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n2535             # Don't let the figure patch influence bbox calculation.\n2536             in_layout=False)\n2537         self._set_artist_props(self.patch)\n2538         self.patch.set_antialiased(False)\n2539 \n2540         FigureCanvasBase(self)  # Set self.canvas.\n2541 \n2542         if subplotpars is None:\n2543             subplotpars = SubplotParams()\n2544 \n2545         self.subplotpars = subplotpars\n2546 \n2547         self._axstack = _AxesStack()  # track all figure axes and current axes\n2548         self.clear()\n2549 \n2550     def pick(self, mouseevent):\n2551         if not self.canvas.widgetlock.locked():\n2552             super().pick(mouseevent)\n2553 \n2554     def _check_layout_engines_compat(self, old, new):\n2555         \"\"\"\n2556         Helper for set_layout engine\n2557 \n2558         If the figure has used the old engine and added a colorbar then the\n2559         value of colorbar_gridspec must be the same on the new engine.\n2560         \"\"\"\n2561         if old is None or new is None:\n2562             return True\n2563         if old.colorbar_gridspec == new.colorbar_gridspec:\n2564             return True\n2565         # colorbar layout different, so check if any colorbars are on the\n2566         # figure...\n2567         for ax in self.axes:\n2568             if hasattr(ax, '_colorbar'):\n2569                 # colorbars list themselves as a colorbar.\n2570                 return False\n2571         return True\n2572 \n2573     def set_layout_engine(self, layout=None, **kwargs):\n2574         \"\"\"\n2575         Set the layout engine for this figure.\n2576 \n2577         Parameters\n2578         ----------\n2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \\\n2580 `LayoutEngine` or None\n2581 \n2582             - 'constrained' will use `~.ConstrainedLayoutEngine`\n2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with\n2584               a correction that attempts to make a good layout for fixed-aspect\n2585               ratio Axes.\n2586             - 'tight' uses `~.TightLayoutEngine`\n2587             - 'none' removes layout engine.\n2588 \n2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`\n2590             (which if `True` behaves as if 'tight' was passed) and\n2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if\n2592             'constrained' was passed).  If both are `True`,\n2593             :rc:`figure.autolayout` takes priority.\n2594 \n2595             Users and libraries can define their own layout engines and pass\n2596             the instance directly as well.\n2597 \n2598         kwargs: dict\n2599             The keyword arguments are passed to the layout engine to set things\n2600             like padding and margin sizes.  Only used if *layout* is a string.\n2601 \n2602         \"\"\"\n2603         if layout is None:\n2604             if mpl.rcParams['figure.autolayout']:\n2605                 layout = 'tight'\n2606             elif mpl.rcParams['figure.constrained_layout.use']:\n2607                 layout = 'constrained'\n2608             else:\n2609                 self._layout_engine = None\n2610                 return\n2611         if layout == 'tight':\n2612             new_layout_engine = TightLayoutEngine(**kwargs)\n2613         elif layout == 'constrained':\n2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n2615         elif layout == 'compressed':\n2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n2617                                                         **kwargs)\n2618         elif layout == 'none':\n2619             if self._layout_engine is not None:\n2620                 new_layout_engine = PlaceHolderLayoutEngine(\n2621                     self._layout_engine.adjust_compatible,\n2622                     self._layout_engine.colorbar_gridspec\n2623                 )\n2624             else:\n2625                 new_layout_engine = None\n2626         elif isinstance(layout, LayoutEngine):\n2627             new_layout_engine = layout\n2628         else:\n2629             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n2630 \n2631         if self._check_layout_engines_compat(self._layout_engine,\n2632                                              new_layout_engine):\n2633             self._layout_engine = new_layout_engine\n2634         else:\n2635             raise RuntimeError('Colorbar layout of new layout engine not '\n2636                                'compatible with old engine, and a colorbar '\n2637                                'has been created.  Engine not changed.')\n2638 \n2639     def get_layout_engine(self):\n2640         return self._layout_engine\n2641 \n2642     # TODO: I'd like to dynamically add the _repr_html_ method\n2643     # to the figure in the right context, but then IPython doesn't\n2644     # use it, for some reason.\n2645 \n2646     def _repr_html_(self):\n2647         # We can't use \"isinstance\" here, because then we'd end up importing\n2648         # webagg unconditionally.\n2649         if 'WebAgg' in type(self.canvas).__name__:\n2650             from matplotlib.backends import backend_webagg\n2651             return backend_webagg.ipython_inline_display(self)\n2652 \n2653     def show(self, warn=True):\n2654         \"\"\"\n2655         If using a GUI backend with pyplot, display the figure window.\n2656 \n2657         If the figure was not created using `~.pyplot.figure`, it will lack\n2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an\n2659         AttributeError.\n2660 \n2661         .. warning::\n2662 \n2663             This does not manage an GUI event loop. Consequently, the figure\n2664             may only be shown briefly or not shown at all if you or your\n2665             environment are not managing an event loop.\n2666 \n2667             Use cases for `.Figure.show` include running this from a GUI\n2668             application (where there is persistently an event loop running) or\n2669             from a shell, like IPython, that install an input hook to allow the\n2670             interactive shell to accept input while the figure is also being\n2671             shown and interactive.  Some, but not all, GUI toolkits will\n2672             register an input hook on import.  See :ref:`cp_integration` for\n2673             more details.\n2674 \n2675             If you're in a shell without input hook integration or executing a\n2676             python script, you should use `matplotlib.pyplot.show` with\n2677             ``block=True`` instead, which takes care of starting and running\n2678             the event loop for you.\n2679 \n2680         Parameters\n2681         ----------\n2682         warn : bool, default: True\n2683             If ``True`` and we are not running headless (i.e. on Linux with an\n2684             unset DISPLAY), issue warning when called on a non-GUI backend.\n2685 \n2686         \"\"\"\n2687         if self.canvas.manager is None:\n2688             raise AttributeError(\n2689                 \"Figure.show works only for figures managed by pyplot, \"\n2690                 \"normally created by pyplot.figure()\")\n2691         try:\n2692             self.canvas.manager.show()\n2693         except NonGuiException as exc:\n2694             if warn:\n2695                 _api.warn_external(str(exc))\n2696 \n2697     @property\n2698     def axes(self):\n2699         \"\"\"\n2700         List of Axes in the Figure. You can access and modify the Axes in the\n2701         Figure through this list.\n2702 \n2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,\n2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.\n2705 \n2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are\n2707         equivalent.\n2708         \"\"\"\n2709         return self._axstack.as_list()\n2710 \n2711     get_axes = axes.fget\n2712 \n2713     def _get_renderer(self):\n2714         if hasattr(self.canvas, 'get_renderer'):\n2715             return self.canvas.get_renderer()\n2716         else:\n2717             return _get_renderer(self)\n2718 \n2719     def _get_dpi(self):\n2720         return self._dpi\n2721 \n2722     def _set_dpi(self, dpi, forward=True):\n2723         \"\"\"\n2724         Parameters\n2725         ----------\n2726         dpi : float\n2727 \n2728         forward : bool\n2729             Passed on to `~.Figure.set_size_inches`\n2730         \"\"\"\n2731         if dpi == self._dpi:\n2732             # We don't want to cause undue events in backends.\n2733             return\n2734         self._dpi = dpi\n2735         self.dpi_scale_trans.clear().scale(dpi)\n2736         w, h = self.get_size_inches()\n2737         self.set_size_inches(w, h, forward=forward)\n2738         self._fig_callbacks.process('dpi_changed', self)\n2739 \n2740     dpi = property(_get_dpi, _set_dpi, doc=\"The resolution in dots per inch.\")\n2741 \n2742     def get_tight_layout(self):\n2743         \"\"\"Return whether `.tight_layout` is called when drawing.\"\"\"\n2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)\n2745 \n2746     @_api.deprecated(\"3.6\", alternative=\"set_layout_engine\",\n2747                      pending=True)\n2748     def set_tight_layout(self, tight):\n2749         \"\"\"\n2750         [*Discouraged*] Set whether and how `.tight_layout` is called when\n2751         drawing.\n2752 \n2753         .. admonition:: Discouraged\n2754 \n2755             This method is discouraged in favor of `~.set_layout_engine`.\n2756 \n2757         Parameters\n2758         ----------\n2759         tight : bool or dict with keys \"pad\", \"w_pad\", \"h_pad\", \"rect\" or None\n2760             If a bool, sets whether to call `.tight_layout` upon drawing.\n2761             If ``None``, use :rc:`figure.autolayout` instead.\n2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the\n2763             default paddings.\n2764         \"\"\"\n2765         if tight is None:\n2766             tight = mpl.rcParams['figure.autolayout']\n2767         _tight = 'tight' if bool(tight) else 'none'\n2768         _tight_parameters = tight if isinstance(tight, dict) else {}\n2769         self.set_layout_engine(_tight, **_tight_parameters)\n2770         self.stale = True\n2771 \n2772     def get_constrained_layout(self):\n2773         \"\"\"\n2774         Return whether constrained layout is being used.\n2775 \n2776         See :ref:`constrainedlayout_guide`.\n2777         \"\"\"\n2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)\n2779 \n2780     @_api.deprecated(\"3.6\", alternative=\"set_layout_engine('constrained')\",\n2781                      pending=True)\n2782     def set_constrained_layout(self, constrained):\n2783         \"\"\"\n2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon\n2785         drawing.\n2786 \n2787         If None, :rc:`figure.constrained_layout.use` value will be used.\n2788 \n2789         When providing a dict containing the keys ``w_pad``, ``h_pad``\n2790         the default ``constrained_layout`` paddings will be\n2791         overridden.  These pads are in inches and default to 3.0/72.0.\n2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.\n2793 \n2794         .. admonition:: Discouraged\n2795 \n2796             This method is discouraged in favor of `~.set_layout_engine`.\n2797 \n2798         Parameters\n2799         ----------\n2800         constrained : bool or dict or None\n2801         \"\"\"\n2802         if constrained is None:\n2803             constrained = mpl.rcParams['figure.constrained_layout.use']\n2804         _constrained = 'constrained' if bool(constrained) else 'none'\n2805         _parameters = constrained if isinstance(constrained, dict) else {}\n2806         self.set_layout_engine(_constrained, **_parameters)\n2807         self.stale = True\n2808 \n2809     @_api.deprecated(\n2810          \"3.6\", alternative=\"figure.get_layout_engine().set()\",\n2811          pending=True)\n2812     def set_constrained_layout_pads(self, **kwargs):\n2813         \"\"\"\n2814         Set padding for ``constrained_layout``.\n2815 \n2816         Tip: The parameters can be passed from a dictionary by using\n2817         ``fig.set_constrained_layout(**pad_dict)``.\n2818 \n2819         See :ref:`constrainedlayout_guide`.\n2820 \n2821         Parameters\n2822         ----------\n2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`\n2824             Width padding in inches.  This is the pad around Axes\n2825             and is meant to make sure there is enough room for fonts to\n2826             look good.  Defaults to 3 pts = 0.04167 inches\n2827 \n2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`\n2829             Height padding in inches. Defaults to 3 pts.\n2830 \n2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`\n2832             Width padding between subplots, expressed as a fraction of the\n2833             subplot width.  The total padding ends up being w_pad + wspace.\n2834 \n2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`\n2836             Height padding between subplots, expressed as a fraction of the\n2837             subplot width. The total padding ends up being h_pad + hspace.\n2838 \n2839         \"\"\"\n2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):\n2841             self.get_layout_engine().set(**kwargs)\n2842 \n2843     @_api.deprecated(\"3.6\", alternative=\"fig.get_layout_engine().get()\",\n2844                      pending=True)\n2845     def get_constrained_layout_pads(self, relative=False):\n2846         \"\"\"\n2847         Get padding for ``constrained_layout``.\n2848 \n2849         Returns a list of ``w_pad, h_pad`` in inches and\n2850         ``wspace`` and ``hspace`` as fractions of the subplot.\n2851         All values are None if ``constrained_layout`` is not used.\n2852 \n2853         See :ref:`constrainedlayout_guide`.\n2854 \n2855         Parameters\n2856         ----------\n2857         relative : bool\n2858             If `True`, then convert from inches to figure relative.\n2859         \"\"\"\n2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):\n2861             return None, None, None, None\n2862         info = self.get_layout_engine().get_info()\n2863         w_pad = info['w_pad']\n2864         h_pad = info['h_pad']\n2865         wspace = info['wspace']\n2866         hspace = info['hspace']\n2867 \n2868         if relative and (w_pad is not None or h_pad is not None):\n2869             renderer = self._get_renderer()\n2870             dpi = renderer.dpi\n2871             w_pad = w_pad * dpi / renderer.width\n2872             h_pad = h_pad * dpi / renderer.height\n2873 \n2874         return w_pad, h_pad, wspace, hspace\n2875 \n2876     def set_canvas(self, canvas):\n2877         \"\"\"\n2878         Set the canvas that contains the figure\n2879 \n2880         Parameters\n2881         ----------\n2882         canvas : FigureCanvas\n2883         \"\"\"\n2884         self.canvas = canvas\n2885 \n2886     @_docstring.interpd\n2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,\n2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):\n2889         \"\"\"\n2890         Add a non-resampled image to the figure.\n2891 \n2892         The image is attached to the lower or upper left corner depending on\n2893         *origin*.\n2894 \n2895         Parameters\n2896         ----------\n2897         X\n2898             The image data. This is an array of one of the following shapes:\n2899 \n2900             - (M, N): an image with scalar data.  Color-mapping is controlled\n2901               by *cmap*, *norm*, *vmin*, and *vmax*.\n2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).\n2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),\n2904               i.e. including transparency.\n2905 \n2906         xo, yo : int\n2907             The *x*/*y* image offset in pixels.\n2908 \n2909         alpha : None or float\n2910             The alpha blending value.\n2911 \n2912         %(cmap_doc)s\n2913 \n2914             This parameter is ignored if *X* is RGB(A).\n2915 \n2916         %(norm_doc)s\n2917 \n2918             This parameter is ignored if *X* is RGB(A).\n2919 \n2920         %(vmin_vmax_doc)s\n2921 \n2922             This parameter is ignored if *X* is RGB(A).\n2923 \n2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`\n2925             Indicates where the [0, 0] index of the array is in the upper left\n2926             or lower left corner of the axes.\n2927 \n2928         resize : bool\n2929             If *True*, resize the figure to match the given image size.\n2930 \n2931         Returns\n2932         -------\n2933         `matplotlib.image.FigureImage`\n2934 \n2935         Other Parameters\n2936         ----------------\n2937         **kwargs\n2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.\n2939 \n2940         Notes\n2941         -----\n2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)\n2943         which will be resampled to fit the current Axes.  If you want\n2944         a resampled image to fill the entire figure, you can define an\n2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].\n2946 \n2947         Examples\n2948         --------\n2949         ::\n2950 \n2951             f = plt.figure()\n2952             nx = int(f.get_figwidth() * f.dpi)\n2953             ny = int(f.get_figheight() * f.dpi)\n2954             data = np.random.random((ny, nx))\n2955             f.figimage(data)\n2956             plt.show()\n2957         \"\"\"\n2958         if resize:\n2959             dpi = self.get_dpi()\n2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]\n2961             self.set_size_inches(figsize, forward=True)\n2962 \n2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,\n2964                                 offsetx=xo, offsety=yo,\n2965                                 origin=origin, **kwargs)\n2966         im.stale_callback = _stale_figure_callback\n2967 \n2968         im.set_array(X)\n2969         im.set_alpha(alpha)\n2970         if norm is None:\n2971             im.set_clim(vmin, vmax)\n2972         self.images.append(im)\n2973         im._remove_method = self.images.remove\n2974         self.stale = True\n2975         return im\n2976 \n2977     def set_size_inches(self, w, h=None, forward=True):\n2978         \"\"\"\n2979         Set the figure size in inches.\n2980 \n2981         Call signatures::\n2982 \n2983              fig.set_size_inches(w, h)  # OR\n2984              fig.set_size_inches((w, h))\n2985 \n2986         Parameters\n2987         ----------\n2988         w : (float, float) or float\n2989             Width and height in inches (if height not specified as a separate\n2990             argument) or width.\n2991         h : float\n2992             Height in inches.\n2993         forward : bool, default: True\n2994             If ``True``, the canvas size is automatically updated, e.g.,\n2995             you can resize the figure window from the shell.\n2996 \n2997         See Also\n2998         --------\n2999         matplotlib.figure.Figure.get_size_inches\n3000         matplotlib.figure.Figure.set_figwidth\n3001         matplotlib.figure.Figure.set_figheight\n3002 \n3003         Notes\n3004         -----\n3005         To transform from pixels to inches divide by `Figure.dpi`.\n3006         \"\"\"\n3007         if h is None:  # Got called with a single pair as argument.\n3008             w, h = w\n3009         size = np.array([w, h])\n3010         if not np.isfinite(size).all() or (size < 0).any():\n3011             raise ValueError(f'figure size must be positive finite not {size}')\n3012         self.bbox_inches.p1 = size\n3013         if forward:\n3014             manager = self.canvas.manager\n3015             if manager is not None:\n3016                 manager.resize(*(size * self.dpi).astype(int))\n3017         self.stale = True\n3018 \n3019     def get_size_inches(self):\n3020         \"\"\"\n3021         Return the current size of the figure in inches.\n3022 \n3023         Returns\n3024         -------\n3025         ndarray\n3026            The size (width, height) of the figure in inches.\n3027 \n3028         See Also\n3029         --------\n3030         matplotlib.figure.Figure.set_size_inches\n3031         matplotlib.figure.Figure.get_figwidth\n3032         matplotlib.figure.Figure.get_figheight\n3033 \n3034         Notes\n3035         -----\n3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.\n3037         \"\"\"\n3038         return np.array(self.bbox_inches.p1)\n3039 \n3040     def get_figwidth(self):\n3041         \"\"\"Return the figure width in inches.\"\"\"\n3042         return self.bbox_inches.width\n3043 \n3044     def get_figheight(self):\n3045         \"\"\"Return the figure height in inches.\"\"\"\n3046         return self.bbox_inches.height\n3047 \n3048     def get_dpi(self):\n3049         \"\"\"Return the resolution in dots per inch as a float.\"\"\"\n3050         return self.dpi\n3051 \n3052     def set_dpi(self, val):\n3053         \"\"\"\n3054         Set the resolution of the figure in dots-per-inch.\n3055 \n3056         Parameters\n3057         ----------\n3058         val : float\n3059         \"\"\"\n3060         self.dpi = val\n3061         self.stale = True\n3062 \n3063     def set_figwidth(self, val, forward=True):\n3064         \"\"\"\n3065         Set the width of the figure in inches.\n3066 \n3067         Parameters\n3068         ----------\n3069         val : float\n3070         forward : bool\n3071             See `set_size_inches`.\n3072 \n3073         See Also\n3074         --------\n3075         matplotlib.figure.Figure.set_figheight\n3076         matplotlib.figure.Figure.set_size_inches\n3077         \"\"\"\n3078         self.set_size_inches(val, self.get_figheight(), forward=forward)\n3079 \n3080     def set_figheight(self, val, forward=True):\n3081         \"\"\"\n3082         Set the height of the figure in inches.\n3083 \n3084         Parameters\n3085         ----------\n3086         val : float\n3087         forward : bool\n3088             See `set_size_inches`.\n3089 \n3090         See Also\n3091         --------\n3092         matplotlib.figure.Figure.set_figwidth\n3093         matplotlib.figure.Figure.set_size_inches\n3094         \"\"\"\n3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)\n3096 \n3097     def clear(self, keep_observers=False):\n3098         # docstring inherited\n3099         super().clear(keep_observers=keep_observers)\n3100         # FigureBase.clear does not clear toolbars, as\n3101         # only Figure can have toolbars\n3102         toolbar = self.canvas.toolbar\n3103         if toolbar is not None:\n3104             toolbar.update()\n3105 \n3106     @_finalize_rasterization\n3107     @allow_rasterization\n3108     def draw(self, renderer):\n3109         # docstring inherited\n3110 \n3111         # draw the figure bounding box, perhaps none for white figure\n3112         if not self.get_visible():\n3113             return\n3114 \n3115         artists = self._get_draw_artists(renderer)\n3116         try:\n3117             renderer.open_group('figure', gid=self.get_gid())\n3118             if self.axes and self.get_layout_engine() is not None:\n3119                 try:\n3120                     self.get_layout_engine().execute(self)\n3121                 except ValueError:\n3122                     pass\n3123                     # ValueError can occur when resizing a window.\n3124 \n3125             self.patch.draw(renderer)\n3126             mimage._draw_list_compositing_images(\n3127                 renderer, self, artists, self.suppressComposite)\n3128 \n3129             for sfig in self.subfigs:\n3130                 sfig.draw(renderer)\n3131 \n3132             renderer.close_group('figure')\n3133         finally:\n3134             self.stale = False\n3135 \n3136         DrawEvent(\"draw_event\", self.canvas, renderer)._process()\n3137 \n3138     def draw_without_rendering(self):\n3139         \"\"\"\n3140         Draw the figure with no output.  Useful to get the final size of\n3141         artists that require a draw before their size is known (e.g. text).\n3142         \"\"\"\n3143         renderer = _get_renderer(self)\n3144         with renderer._draw_disabled():\n3145             self.draw(renderer)\n3146 \n3147     def draw_artist(self, a):\n3148         \"\"\"\n3149         Draw `.Artist` *a* only.\n3150         \"\"\"\n3151         a.draw(self.canvas.get_renderer())\n3152 \n3153     def __getstate__(self):\n3154         state = super().__getstate__()\n3155 \n3156         # The canvas cannot currently be pickled, but this has the benefit\n3157         # of meaning that a figure can be detached from one canvas, and\n3158         # re-attached to another.\n3159         state.pop(\"canvas\")\n3160 \n3161         # discard any changes to the dpi due to pixel ratio changes\n3162         state[\"_dpi\"] = state.get('_original_dpi', state['_dpi'])\n3163 \n3164         # add version information to the state\n3165         state['__mpl_version__'] = mpl.__version__\n3166 \n3167         # check whether the figure manager (if any) is registered with pyplot\n3168         from matplotlib import _pylab_helpers\n3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n3170             state['_restore_to_pylab'] = True\n3171         return state\n3172 \n3173     def __setstate__(self, state):\n3174         version = state.pop('__mpl_version__')\n3175         restore_to_pylab = state.pop('_restore_to_pylab', False)\n3176 \n3177         if version != mpl.__version__:\n3178             _api.warn_external(\n3179                 f\"This figure was saved with matplotlib version {version} and \"\n3180                 f\"is unlikely to function correctly.\")\n3181 \n3182         self.__dict__ = state\n3183 \n3184         # re-initialise some of the unstored state information\n3185         FigureCanvasBase(self)  # Set self.canvas.\n3186 \n3187         if restore_to_pylab:\n3188             # lazy import to avoid circularity\n3189             import matplotlib.pyplot as plt\n3190             import matplotlib._pylab_helpers as pylab_helpers\n3191             allnums = plt.get_fignums()\n3192             num = max(allnums) + 1 if allnums else 1\n3193             backend = plt._get_backend_mod()\n3194             mgr = backend.new_figure_manager_given_figure(num, self)\n3195             pylab_helpers.Gcf._set_new_active_manager(mgr)\n3196             plt.draw_if_interactive()\n3197 \n3198         self.stale = True\n3199 \n3200     def add_axobserver(self, func):\n3201         \"\"\"Whenever the Axes state change, ``func(self)`` will be called.\"\"\"\n3202         # Connect a wrapper lambda and not func itself, to avoid it being\n3203         # weakref-collected.\n3204         self._axobservers.connect(\"_axes_change_event\", lambda arg: func(arg))\n3205 \n3206     def savefig(self, fname, *, transparent=None, **kwargs):\n3207         \"\"\"\n3208         Save the current figure.\n3209 \n3210         Call signature::\n3211 \n3212           savefig(fname, *, dpi='figure', format=None, metadata=None,\n3213                   bbox_inches=None, pad_inches=0.1,\n3214                   facecolor='auto', edgecolor='auto',\n3215                   backend=None, **kwargs\n3216                  )\n3217 \n3218         The available output formats depend on the backend being used.\n3219 \n3220         Parameters\n3221         ----------\n3222         fname : str or path-like or binary file-like\n3223             A path, or a Python file-like object, or\n3224             possibly some backend-dependent object such as\n3225             `matplotlib.backends.backend_pdf.PdfPages`.\n3226 \n3227             If *format* is set, it determines the output format, and the file\n3228             is saved as *fname*.  Note that *fname* is used verbatim, and there\n3229             is no attempt to make the extension, if any, of *fname* match\n3230             *format*, and no extension is appended.\n3231 \n3232             If *format* is not set, then the format is inferred from the\n3233             extension of *fname*, if there is one.  If *format* is not\n3234             set and *fname* has no extension, then the file is saved with\n3235             :rc:`savefig.format` and the appropriate extension is appended to\n3236             *fname*.\n3237 \n3238         Other Parameters\n3239         ----------------\n3240         dpi : float or 'figure', default: :rc:`savefig.dpi`\n3241             The resolution in dots per inch.  If 'figure', use the figure's\n3242             dpi value.\n3243 \n3244         format : str\n3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n3246             this is unset is documented under *fname*.\n3247 \n3248         metadata : dict, optional\n3249             Key/value pairs to store in the image metadata. The supported keys\n3250             and defaults depend on the image format and backend:\n3251 \n3252             - 'png' with Agg backend: See the parameter ``metadata`` of\n3253               `~.FigureCanvasAgg.print_png`.\n3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of\n3255               `~.backend_pdf.PdfPages`.\n3256             - 'svg' with svg backend: See the parameter ``metadata`` of\n3257               `~.FigureCanvasSVG.print_svg`.\n3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n3259 \n3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support\n3261             embedding metadata.\n3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include\n3263             embedding EXIF metadata in the future.\n3264 \n3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`\n3266             Bounding box in inches: only the given portion of the figure is\n3267             saved.  If 'tight', try to figure out the tight bbox of the figure.\n3268 \n3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`\n3270             Amount of padding in inches around the figure when bbox_inches is\n3271             'tight'. If 'layout' use the padding from the constrained or\n3272             compressed layout engine; ignored if one of those engines is not in\n3273             use.\n3274 \n3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`\n3276             The facecolor of the figure.  If 'auto', use the current figure\n3277             facecolor.\n3278 \n3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`\n3280             The edgecolor of the figure.  If 'auto', use the current figure\n3281             edgecolor.\n3282 \n3283         backend : str, optional\n3284             Use a non-default backend to render the file, e.g. to render a\n3285             png file with the \"cairo\" backend rather than the default \"agg\",\n3286             or a pdf file with the \"pgf\" backend rather than the default\n3287             \"pdf\".  Note that the default backend is normally sufficient.  See\n3288             :ref:`the-builtin-backends` for a list of valid backends for each\n3289             file format.  Custom backends can be referenced as \"module://...\".\n3290 \n3291         orientation : {'landscape', 'portrait'}\n3292             Currently only supported by the postscript backend.\n3293 \n3294         papertype : str\n3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n3296             'a10', 'b0' through 'b10'. Only supported for postscript\n3297             output.\n3298 \n3299         transparent : bool\n3300             If *True*, the Axes patches will all be transparent; the\n3301             Figure patch will also be transparent unless *facecolor*\n3302             and/or *edgecolor* are specified via kwargs.\n3303 \n3304             If *False* has no effect and the color of the Axes and\n3305             Figure patches are unchanged (unless the Figure patch\n3306             is specified via the *facecolor* and/or *edgecolor* keyword\n3307             arguments in which case those colors are used).\n3308 \n3309             The transparency of these patches will be restored to their\n3310             original values upon exit of this function.\n3311 \n3312             This is useful, for example, for displaying\n3313             a plot on top of a colored background on a web page.\n3314 \n3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n3316             A list of extra artists that will be considered when the\n3317             tight bbox is calculated.\n3318 \n3319         pil_kwargs : dict, optional\n3320             Additional keyword arguments that are passed to\n3321             `PIL.Image.Image.save` when saving the figure.\n3322 \n3323         \"\"\"\n3324 \n3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])\n3326         if transparent is None:\n3327             transparent = mpl.rcParams['savefig.transparent']\n3328 \n3329         with ExitStack() as stack:\n3330             if transparent:\n3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):\n3332                     exit_stack.enter_context(\n3333                         subfig.patch._cm_set(\n3334                             facecolor=\"none\", edgecolor=\"none\"))\n3335                     for ax in subfig.axes:\n3336                         exit_stack.enter_context(\n3337                             ax.patch._cm_set(\n3338                                 facecolor=\"none\", edgecolor=\"none\"))\n3339                     for sub_subfig in subfig.subfigs:\n3340                         _recursively_make_subfig_transparent(\n3341                             exit_stack, sub_subfig)\n3342 \n3343                 def _recursively_make_axes_transparent(exit_stack, ax):\n3344                     exit_stack.enter_context(\n3345                         ax.patch._cm_set(facecolor=\"none\", edgecolor=\"none\"))\n3346                     for child_ax in ax.child_axes:\n3347                         exit_stack.enter_context(\n3348                             child_ax.patch._cm_set(\n3349                                 facecolor=\"none\", edgecolor=\"none\"))\n3350                     for child_childax in ax.child_axes:\n3351                         _recursively_make_axes_transparent(\n3352                             exit_stack, child_childax)\n3353 \n3354                 kwargs.setdefault('facecolor', 'none')\n3355                 kwargs.setdefault('edgecolor', 'none')\n3356                 # set subfigure to appear transparent in printed image\n3357                 for subfig in self.subfigs:\n3358                     _recursively_make_subfig_transparent(stack, subfig)\n3359                 # set axes to be transparent\n3360                 for ax in self.axes:\n3361                     _recursively_make_axes_transparent(stack, ax)\n3362             self.canvas.print_figure(fname, **kwargs)\n3363 \n3364     def ginput(self, n=1, timeout=30, show_clicks=True,\n3365                mouse_add=MouseButton.LEFT,\n3366                mouse_pop=MouseButton.RIGHT,\n3367                mouse_stop=MouseButton.MIDDLE):\n3368         \"\"\"\n3369         Blocking call to interact with a figure.\n3370 \n3371         Wait until the user clicks *n* times on the figure, and return the\n3372         coordinates of each click in a list.\n3373 \n3374         There are three possible interactions:\n3375 \n3376         - Add a point.\n3377         - Remove the most recently added point.\n3378         - Stop the interaction and return the points added so far.\n3379 \n3380         The actions are assigned to mouse buttons via the arguments\n3381         *mouse_add*, *mouse_pop* and *mouse_stop*.\n3382 \n3383         Parameters\n3384         ----------\n3385         n : int, default: 1\n3386             Number of mouse clicks to accumulate. If negative, accumulate\n3387             clicks until the input is terminated manually.\n3388         timeout : float, default: 30 seconds\n3389             Number of seconds to wait before timing out. If zero or negative\n3390             will never time out.\n3391         show_clicks : bool, default: True\n3392             If True, show a red cross at the location of each click.\n3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`\n3394             Mouse button used to add points.\n3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`\n3396             Mouse button used to remove the most recently added point.\n3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`\n3398             Mouse button used to stop input.\n3399 \n3400         Returns\n3401         -------\n3402         list of tuples\n3403             A list of the clicked (x, y) coordinates.\n3404 \n3405         Notes\n3406         -----\n3407         The keyboard can also be used to select points in case your mouse\n3408         does not have one or more of the buttons.  The delete and backspace\n3409         keys act like right-clicking (i.e., remove last point), the enter key\n3410         terminates input and any other key (not already used by the window\n3411         manager) selects a point.\n3412         \"\"\"\n3413         clicks = []\n3414         marks = []\n3415 \n3416         def handler(event):\n3417             is_button = event.name == \"button_press_event\"\n3418             is_key = event.name == \"key_press_event\"\n3419             # Quit (even if not in infinite mode; this is consistent with\n3420             # MATLAB and sometimes quite useful, but will require the user to\n3421             # test how many points were actually returned before using data).\n3422             if (is_button and event.button == mouse_stop\n3423                     or is_key and event.key in [\"escape\", \"enter\"]):\n3424                 self.canvas.stop_event_loop()\n3425             # Pop last click.\n3426             elif (is_button and event.button == mouse_pop\n3427                   or is_key and event.key in [\"backspace\", \"delete\"]):\n3428                 if clicks:\n3429                     clicks.pop()\n3430                     if show_clicks:\n3431                         marks.pop().remove()\n3432                         self.canvas.draw()\n3433             # Add new click.\n3434             elif (is_button and event.button == mouse_add\n3435                   # On macOS/gtk, some keys return None.\n3436                   or is_key and event.key is not None):\n3437                 if event.inaxes:\n3438                     clicks.append((event.xdata, event.ydata))\n3439                     _log.info(\"input %i: %f, %f\",\n3440                               len(clicks), event.xdata, event.ydata)\n3441                     if show_clicks:\n3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],\n3443                                                 marker=\"+\", color=\"r\")\n3444                         event.inaxes.add_line(line)\n3445                         marks.append(line)\n3446                         self.canvas.draw()\n3447             if len(clicks) == n and n > 0:\n3448                 self.canvas.stop_event_loop()\n3449 \n3450         _blocking_input.blocking_input_loop(\n3451             self, [\"button_press_event\", \"key_press_event\"], timeout, handler)\n3452 \n3453         # Cleanup.\n3454         for mark in marks:\n3455             mark.remove()\n3456         self.canvas.draw()\n3457 \n3458         return clicks\n3459 \n3460     def waitforbuttonpress(self, timeout=-1):\n3461         \"\"\"\n3462         Blocking call to interact with the figure.\n3463 \n3464         Wait for user input and return True if a key was pressed, False if a\n3465         mouse button was pressed and None if no input was given within\n3466         *timeout* seconds.  Negative values deactivate *timeout*.\n3467         \"\"\"\n3468         event = None\n3469 \n3470         def handler(ev):\n3471             nonlocal event\n3472             event = ev\n3473             self.canvas.stop_event_loop()\n3474 \n3475         _blocking_input.blocking_input_loop(\n3476             self, [\"button_press_event\", \"key_press_event\"], timeout, handler)\n3477 \n3478         return None if event is None else event.name == \"key_press_event\"\n3479 \n3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):\n3481         \"\"\"\n3482         Adjust the padding between and around subplots.\n3483 \n3484         To exclude an artist on the Axes from the bounding box calculation\n3485         that determines the subplot parameters (i.e. legend, or annotation),\n3486         set ``a.set_in_layout(False)`` for that artist.\n3487 \n3488         Parameters\n3489         ----------\n3490         pad : float, default: 1.08\n3491             Padding between the figure edge and the edges of subplots,\n3492             as a fraction of the font size.\n3493         h_pad, w_pad : float, default: *pad*\n3494             Padding (height/width) between edges of adjacent subplots,\n3495             as a fraction of the font size.\n3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)\n3497             A rectangle in normalized figure coordinates into which the whole\n3498             subplots area (including labels) will fit.\n3499 \n3500         See Also\n3501         --------\n3502         .Figure.set_layout_engine\n3503         .pyplot.tight_layout\n3504         \"\"\"\n3505         # note that here we do not permanently set the figures engine to\n3506         # tight_layout but rather just perform the layout in place and remove\n3507         # any previous engines.\n3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,\n3509                                    rect=rect)\n3510         try:\n3511             previous_engine = self.get_layout_engine()\n3512             self.set_layout_engine(engine)\n3513             engine.execute(self)\n3514             if not isinstance(previous_engine, TightLayoutEngine) \\\n3515                     and previous_engine is not None:\n3516                 _api.warn_external('The figure layout has changed to tight')\n3517         finally:\n3518             self.set_layout_engine(None)\n3519 \n3520 \n3521 def figaspect(arg):\n3522     \"\"\"\n3523     Calculate the width and height for a figure with a specified aspect ratio.\n3524 \n3525     While the height is taken from :rc:`figure.figsize`, the width is\n3526     adjusted to match the desired aspect ratio. Additionally, it is ensured\n3527     that the width is in the range [4., 16.] and the height is in the range\n3528     [2., 16.]. If necessary, the default height is adjusted to ensure this.\n3529 \n3530     Parameters\n3531     ----------\n3532     arg : float or 2D array\n3533         If a float, this defines the aspect ratio (i.e. the ratio height /\n3534         width).\n3535         In case of an array the aspect ratio is number of rows / number of\n3536         columns, so that the array could be fitted in the figure undistorted.\n3537 \n3538     Returns\n3539     -------\n3540     width, height : float\n3541         The figure size in inches.\n3542 \n3543     Notes\n3544     -----\n3545     If you want to create an Axes within the figure, that still preserves the\n3546     aspect ratio, be sure to create it with equal width and height. See\n3547     examples below.\n3548 \n3549     Thanks to Fernando Perez for this function.\n3550 \n3551     Examples\n3552     --------\n3553     Make a figure twice as tall as it is wide::\n3554 \n3555         w, h = figaspect(2.)\n3556         fig = Figure(figsize=(w, h))\n3557         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n3558         ax.imshow(A, **kwargs)\n3559 \n3560     Make a figure with the proper aspect for an array::\n3561 \n3562         A = rand(5, 3)\n3563         w, h = figaspect(A)\n3564         fig = Figure(figsize=(w, h))\n3565         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n3566         ax.imshow(A, **kwargs)\n3567     \"\"\"\n3568 \n3569     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)\n3570 \n3571     # min/max sizes to respect when autoscaling.  If John likes the idea, they\n3572     # could become rc parameters, for now they're hardwired.\n3573     figsize_min = np.array((4.0, 2.0))  # min length for width/height\n3574     figsize_max = np.array((16.0, 16.0))  # max length for width/height\n3575 \n3576     # Extract the aspect ratio of the array\n3577     if isarray:\n3578         nr, nc = arg.shape[:2]\n3579         arr_ratio = nr / nc\n3580     else:\n3581         arr_ratio = arg\n3582 \n3583     # Height of user figure defaults\n3584     fig_height = mpl.rcParams['figure.figsize'][1]\n3585 \n3586     # New size for the figure, keeping the aspect ratio of the caller\n3587     newsize = np.array((fig_height / arr_ratio, fig_height))\n3588 \n3589     # Sanity checks, don't drop either dimension below figsize_min\n3590     newsize /= min(1.0, *(newsize / figsize_min))\n3591 \n3592     # Avoid humongous windows as well\n3593     newsize /= max(1.0, *(newsize / figsize_max))\n3594 \n3595     # Finally, if we have a really funky aspect ratio, break it but respect\n3596     # the min/max dimensions (we don't want figures 10 feet tall!)\n3597     newsize = np.clip(newsize, figsize_min, figsize_max)\n3598     return newsize\n",
        "intended_behavior": "Any method or function within this file that reads or modifies the `figure.autolayout` setting needs to be reviewed to ensure it correctly handles situations where both `autolayout` and `tight_layout` are used. If `tight_layout` is called, the code should respect the explicit user request to adjust layout parameters manually, which may involve temporarily disabling `autolayout` or merging the settings with `tight_layout` kwargs. The balance between automatic and manual layout adjustments needs to be clear to users, either through documentation or runtime messages."
    }
]