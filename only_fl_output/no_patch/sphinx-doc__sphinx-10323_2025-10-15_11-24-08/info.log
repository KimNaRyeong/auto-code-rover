2025-10-15 11:24:08.773 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 11:24:11.599 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=866, output_tokens=12, cost=0.009020
2025-10-15 11:24:31.042 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1046, output_tokens=908, cost=0.037700
2025-10-15 11:24:32.042 | INFO     | registered non reproducing test 0
2025-10-15 11:24:54.760 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2471, output_tokens=978, cost=0.054050
2025-10-15 11:24:55.747 | INFO     | registered non reproducing test 1
2025-10-15 11:25:11.006 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2423, output_tokens=732, cost=0.046190
2025-10-15 11:25:11.977 | INFO     | registered non reproducing test 2
2025-10-15 11:25:11.978 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 11:25:11.984 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:25:20.340 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1120, output_tokens=361, cost=0.022030
2025-10-15 11:25:20.348 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:25:23.156 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=715, output_tokens=52, cost=0.008710
2025-10-15 11:25:23.158 | DEBUG    | Extracted a valid json.
2025-10-15 11:25:23.158 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"literalinclude\")",
        "search_code(\"literalinclude directive\")",
        "search_code(\"prepend\")",
        "search_code(\"dedent\")"
    ],
    "bug_locations": []
}
2025-10-15 11:25:23.231 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 11:25:23.231 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 11:25:39.862 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1908, output_tokens=732, cost=0.041040
2025-10-15 11:25:39.877 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:25:47.803 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2856, output_tokens=337, cost=0.038670
2025-10-15 11:25:47.811 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:26:00.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=315, cost=0.016360
2025-10-15 11:26:00.546 | DEBUG    | Extracted a valid json.
2025-10-15 11:26:00.546 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/directives/code.py",
            "class": "",
            "method": "",
            "intended_behavior": "The handling of the `:prepend:` option within code directives, likely around functions processing the `literalinclude` and similar directives, should be augmented to preserve leading whitespace of the `prepend` content. This would entail ensuring that any application of `dedent` or similar transformations to the included content does not strip leading whitespace from the `prepend` string. The intended behavior should allow the `prepend` content to maintain its specified formatting, including indentation, when inserted before the included code segment. This preservation would enable users to match the indentation of the included content with the surrounding documentation correctly."
        },
        {
            "file": "sphinx/directives/code.py",
            "class": "",
            "method": "",
            "intended_behavior": "The logic for `:dedent:` option processing needs to be refined to ensure it does not apply to `prepend` or `append` content. The dedentation should strictly affect the content being included via the `literalinclude` directive and not the manually specified `prepend` or `append` strings. Implementing a conditional application of `dedent` or modifying how dedentation is calculated can achieve this. This ensures that users have control over the indentation of the content they are adding explicitly, separate from the automated adjustment of the included content's indentation level."
        }
    ]
}
2025-10-15 11:26:00.552 | DEBUG    | Bug location extracted successfully: [<file>sphinx/directives/code.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 import textwrap
3 from difflib import unified_diff
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple
5 
6 from docutils import nodes
7 from docutils.nodes import Element, Node
8 from docutils.parsers.rst import directives
9 from docutils.statemachine import StringList
10 
11 from sphinx import addnodes
12 from sphinx.config import Config
13 from sphinx.directives import optional_int
14 from sphinx.locale import __
15 from sphinx.util import logging, parselinenos
16 from sphinx.util.docutils import SphinxDirective
17 from sphinx.util.typing import OptionSpec
18 
19 if TYPE_CHECKING:
20     from sphinx.application import Sphinx
21 
22 logger = logging.getLogger(__name__)
23 
24 
25 class Highlight(SphinxDirective):
26     """
27     Directive to set the highlighting language for code blocks, as well
28     as the threshold for line numbers.
29     """
30 
31     has_content = False
32     required_arguments = 1
33     optional_arguments = 0
34     final_argument_whitespace = False
35     option_spec: OptionSpec = {
36         'force': directives.flag,
37         'linenothreshold': directives.positive_int,
38     }
39 
40     def run(self) -> List[Node]:
41         language = self.arguments[0].strip()
42         linenothreshold = self.options.get('linenothreshold', sys.maxsize)
43         force = 'force' in self.options
44 
45         self.env.temp_data['highlight_language'] = language
46         return [addnodes.highlightlang(lang=language,
47                                        force=force,
48                                        linenothreshold=linenothreshold)]
49 
50 
51 def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:
52     if dedent is None:
53         return textwrap.dedent(''.join(lines)).splitlines(True)
54 
55     if any(s[:dedent].strip() for s in lines):
56         logger.warning(__('non-whitespace stripped by dedent'), location=location)
57 
58     new_lines = []
59     for line in lines:
60         new_line = line[dedent:]
61         if line.endswith('\n') and not new_line:
62             new_line = '\n'  # keep CRLF
63         new_lines.append(new_line)
64 
65     return new_lines
66 
67 
68 def container_wrapper(directive: SphinxDirective, literal_node: Node, caption: str) -> nodes.container:  # NOQA
69     container_node = nodes.container('', literal_block=True,
70                                      classes=['literal-block-wrapper'])
71     parsed = nodes.Element()
72     directive.state.nested_parse(StringList([caption], source=''),
73                                  directive.content_offset, parsed)
74     if isinstance(parsed[0], nodes.system_message):
75         msg = __('Invalid caption: %s' % parsed[0].astext())
76         raise ValueError(msg)
77     elif isinstance(parsed[0], nodes.Element):
78         caption_node = nodes.caption(parsed[0].rawsource, '',
79                                      *parsed[0].children)
80         caption_node.source = literal_node.source
81         caption_node.line = literal_node.line
82         container_node += caption_node
83         container_node += literal_node
84         return container_node
85     else:
86         raise RuntimeError  # never reached
87 
88 
89 class CodeBlock(SphinxDirective):
90     """
91     Directive for a code block with special highlighting or line numbering
92     settings.
93     """
94 
95     has_content = True
96     required_arguments = 0
97     optional_arguments = 1
98     final_argument_whitespace = False
99     option_spec: OptionSpec = {
100         'force': directives.flag,
101         'linenos': directives.flag,
102         'dedent': optional_int,
103         'lineno-start': int,
104         'emphasize-lines': directives.unchanged_required,
105         'caption': directives.unchanged_required,
106         'class': directives.class_option,
107         'name': directives.unchanged,
108     }
109 
110     def run(self) -> List[Node]:
111         document = self.state.document
112         code = '\n'.join(self.content)
113         location = self.state_machine.get_source_and_line(self.lineno)
114 
115         linespec = self.options.get('emphasize-lines')
116         if linespec:
117             try:
118                 nlines = len(self.content)
119                 hl_lines = parselinenos(linespec, nlines)
120                 if any(i >= nlines for i in hl_lines):
121                     logger.warning(__('line number spec is out of range(1-%d): %r') %
122                                    (nlines, self.options['emphasize-lines']),
123                                    location=location)
124 
125                 hl_lines = [x + 1 for x in hl_lines if x < nlines]
126             except ValueError as err:
127                 return [document.reporter.warning(err, line=self.lineno)]
128         else:
129             hl_lines = None
130 
131         if 'dedent' in self.options:
132             location = self.state_machine.get_source_and_line(self.lineno)
133             lines = code.splitlines(True)
134             lines = dedent_lines(lines, self.options['dedent'], location=location)
135             code = ''.join(lines)
136 
137         literal: Element = nodes.literal_block(code, code)
138         if 'linenos' in self.options or 'lineno-start' in self.options:
139             literal['linenos'] = True
140         literal['classes'] += self.options.get('class', [])
141         literal['force'] = 'force' in self.options
142         if self.arguments:
143             # highlight language specified
144             literal['language'] = self.arguments[0]
145         else:
146             # no highlight language specified.  Then this directive refers the current
147             # highlight setting via ``highlight`` directive or ``highlight_language``
148             # configuration.
149             literal['language'] = self.env.temp_data.get('highlight_language',
150                                                          self.config.highlight_language)
151         extra_args = literal['highlight_args'] = {}
152         if hl_lines is not None:
153             extra_args['hl_lines'] = hl_lines
154         if 'lineno-start' in self.options:
155             extra_args['linenostart'] = self.options['lineno-start']
156         self.set_source_info(literal)
157 
158         caption = self.options.get('caption')
159         if caption:
160             try:
161                 literal = container_wrapper(self, literal, caption)
162             except ValueError as exc:
163                 return [document.reporter.warning(exc, line=self.lineno)]
164 
165         # literal will be note_implicit_target that is linked from caption and numref.
166         # when options['name'] is provided, it should be primary ID.
167         self.add_name(literal)
168 
169         return [literal]
170 
171 
172 class LiteralIncludeReader:
173     INVALID_OPTIONS_PAIR = [
174         ('lineno-match', 'lineno-start'),
175         ('lineno-match', 'append'),
176         ('lineno-match', 'prepend'),
177         ('start-after', 'start-at'),
178         ('end-before', 'end-at'),
179         ('diff', 'pyobject'),
180         ('diff', 'lineno-start'),
181         ('diff', 'lineno-match'),
182         ('diff', 'lines'),
183         ('diff', 'start-after'),
184         ('diff', 'end-before'),
185         ('diff', 'start-at'),
186         ('diff', 'end-at'),
187     ]
188 
189     def __init__(self, filename: str, options: Dict, config: Config) -> None:
190         self.filename = filename
191         self.options = options
192         self.encoding = options.get('encoding', config.source_encoding)
193         self.lineno_start = self.options.get('lineno-start', 1)
194 
195         self.parse_options()
196 
197     def parse_options(self) -> None:
198         for option1, option2 in self.INVALID_OPTIONS_PAIR:
199             if option1 in self.options and option2 in self.options:
200                 raise ValueError(__('Cannot use both "%s" and "%s" options') %
201                                  (option1, option2))
202 
203     def read_file(self, filename: str, location: Tuple[str, int] = None) -> List[str]:
204         try:
205             with open(filename, encoding=self.encoding, errors='strict') as f:
206                 text = f.read()
207                 if 'tab-width' in self.options:
208                     text = text.expandtabs(self.options['tab-width'])
209 
210                 return text.splitlines(True)
211         except OSError as exc:
212             raise OSError(__('Include file %r not found or reading it failed') %
213                           filename) from exc
214         except UnicodeError as exc:
215             raise UnicodeError(__('Encoding %r used for reading included file %r seems to '
216                                   'be wrong, try giving an :encoding: option') %
217                                (self.encoding, filename)) from exc
218 
219     def read(self, location: Tuple[str, int] = None) -> Tuple[str, int]:
220         if 'diff' in self.options:
221             lines = self.show_diff()
222         else:
223             filters = [self.pyobject_filter,
224                        self.start_filter,
225                        self.end_filter,
226                        self.lines_filter,
227                        self.prepend_filter,
228                        self.append_filter,
229                        self.dedent_filter]
230             lines = self.read_file(self.filename, location=location)
231             for func in filters:
232                 lines = func(lines, location=location)
233 
234         return ''.join(lines), len(lines)
235 
236     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:
237         new_lines = self.read_file(self.filename)
238         old_filename = self.options.get('diff')
239         old_lines = self.read_file(old_filename)
240         diff = unified_diff(old_lines, new_lines, old_filename, self.filename)
241         return list(diff)
242 
243     def pyobject_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
244         pyobject = self.options.get('pyobject')
245         if pyobject:
246             from sphinx.pycode import ModuleAnalyzer
247             analyzer = ModuleAnalyzer.for_file(self.filename, '')
248             tags = analyzer.find_tags()
249             if pyobject not in tags:
250                 raise ValueError(__('Object named %r not found in include file %r') %
251                                  (pyobject, self.filename))
252             else:
253                 start = tags[pyobject][1]
254                 end = tags[pyobject][2]
255                 lines = lines[start - 1:end]
256                 if 'lineno-match' in self.options:
257                     self.lineno_start = start
258 
259         return lines
260 
261     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
262         linespec = self.options.get('lines')
263         if linespec:
264             linelist = parselinenos(linespec, len(lines))
265             if any(i >= len(lines) for i in linelist):
266                 logger.warning(__('line number spec is out of range(1-%d): %r') %
267                                (len(lines), linespec), location=location)
268 
269             if 'lineno-match' in self.options:
270                 # make sure the line list is not "disjoint".
271                 first = linelist[0]
272                 if all(first + i == n for i, n in enumerate(linelist)):
273                     self.lineno_start += linelist[0]
274                 else:
275                     raise ValueError(__('Cannot use "lineno-match" with a disjoint '
276                                         'set of "lines"'))
277 
278             lines = [lines[n] for n in linelist if n < len(lines)]
279             if lines == []:
280                 raise ValueError(__('Line spec %r: no lines pulled from include file %r') %
281                                  (linespec, self.filename))
282 
283         return lines
284 
285     def start_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
286         if 'start-at' in self.options:
287             start = self.options.get('start-at')
288             inclusive = False
289         elif 'start-after' in self.options:
290             start = self.options.get('start-after')
291             inclusive = True
292         else:
293             start = None
294 
295         if start:
296             for lineno, line in enumerate(lines):
297                 if start in line:
298                     if inclusive:
299                         if 'lineno-match' in self.options:
300                             self.lineno_start += lineno + 1
301 
302                         return lines[lineno + 1:]
303                     else:
304                         if 'lineno-match' in self.options:
305                             self.lineno_start += lineno
306 
307                         return lines[lineno:]
308 
309             if inclusive is True:
310                 raise ValueError('start-after pattern not found: %s' % start)
311             else:
312                 raise ValueError('start-at pattern not found: %s' % start)
313 
314         return lines
315 
316     def end_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
317         if 'end-at' in self.options:
318             end = self.options.get('end-at')
319             inclusive = True
320         elif 'end-before' in self.options:
321             end = self.options.get('end-before')
322             inclusive = False
323         else:
324             end = None
325 
326         if end:
327             for lineno, line in enumerate(lines):
328                 if end in line:
329                     if inclusive:
330                         return lines[:lineno + 1]
331                     else:
332                         if lineno == 0:
333                             pass  # end-before ignores first line
334                         else:
335                             return lines[:lineno]
336             if inclusive is True:
337                 raise ValueError('end-at pattern not found: %s' % end)
338             else:
339                 raise ValueError('end-before pattern not found: %s' % end)
340 
341         return lines
342 
343     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
344         prepend = self.options.get('prepend')
345         if prepend:
346             lines.insert(0, prepend + '\n')
347 
348         return lines
349 
350     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
351         append = self.options.get('append')
352         if append:
353             lines.append(append + '\n')
354 
355         return lines
356 
357     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
358         if 'dedent' in self.options:
359             return dedent_lines(lines, self.options.get('dedent'), location=location)
360         else:
361             return lines
362 
363 
364 class LiteralInclude(SphinxDirective):
365     """
366     Like ``.. include:: :literal:``, but only warns if the include file is
367     not found, and does not raise errors.  Also has several options for
368     selecting what to include.
369     """
370 
371     has_content = False
372     required_arguments = 1
373     optional_arguments = 0
374     final_argument_whitespace = True
375     option_spec: OptionSpec = {
376         'dedent': optional_int,
377         'linenos': directives.flag,
378         'lineno-start': int,
379         'lineno-match': directives.flag,
380         'tab-width': int,
381         'language': directives.unchanged_required,
382         'force': directives.flag,
383         'encoding': directives.encoding,
384         'pyobject': directives.unchanged_required,
385         'lines': directives.unchanged_required,
386         'start-after': directives.unchanged_required,
387         'end-before': directives.unchanged_required,
388         'start-at': directives.unchanged_required,
389         'end-at': directives.unchanged_required,
390         'prepend': directives.unchanged_required,
391         'append': directives.unchanged_required,
392         'emphasize-lines': directives.unchanged_required,
393         'caption': directives.unchanged,
394         'class': directives.class_option,
395         'name': directives.unchanged,
396         'diff': directives.unchanged_required,
397     }
398 
399     def run(self) -> List[Node]:
400         document = self.state.document
401         if not document.settings.file_insertion_enabled:
402             return [document.reporter.warning('File insertion disabled',
403                                               line=self.lineno)]
404         # convert options['diff'] to absolute path
405         if 'diff' in self.options:
406             _, path = self.env.relfn2path(self.options['diff'])
407             self.options['diff'] = path
408 
409         try:
410             location = self.state_machine.get_source_and_line(self.lineno)
411             rel_filename, filename = self.env.relfn2path(self.arguments[0])
412             self.env.note_dependency(rel_filename)
413 
414             reader = LiteralIncludeReader(filename, self.options, self.config)
415             text, lines = reader.read(location=location)
416 
417             retnode: Element = nodes.literal_block(text, text, source=filename)
418             retnode['force'] = 'force' in self.options
419             self.set_source_info(retnode)
420             if self.options.get('diff'):  # if diff is set, set udiff
421                 retnode['language'] = 'udiff'
422             elif 'language' in self.options:
423                 retnode['language'] = self.options['language']
424             if ('linenos' in self.options or 'lineno-start' in self.options or
425                     'lineno-match' in self.options):
426                 retnode['linenos'] = True
427             retnode['classes'] += self.options.get('class', [])
428             extra_args = retnode['highlight_args'] = {}
429             if 'emphasize-lines' in self.options:
430                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)
431                 if any(i >= lines for i in hl_lines):
432                     logger.warning(__('line number spec is out of range(1-%d): %r') %
433                                    (lines, self.options['emphasize-lines']),
434                                    location=location)
435                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]
436             extra_args['linenostart'] = reader.lineno_start
437 
438             if 'caption' in self.options:
439                 caption = self.options['caption'] or self.arguments[0]
440                 retnode = container_wrapper(self, retnode, caption)
441 
442             # retnode will be note_implicit_target that is linked from caption and numref.
443             # when options['name'] is provided, it should be primary ID.
444             self.add_name(retnode)
445 
446             return [retnode]
447         except Exception as exc:
448             return [document.reporter.warning(exc, line=self.lineno)]
449 
450 
451 def setup(app: "Sphinx") -> Dict[str, Any]:
452     directives.register_directive('highlight', Highlight)
453     directives.register_directive('code-block', CodeBlock)
454     directives.register_directive('sourcecode', CodeBlock)
455     directives.register_directive('literalinclude', LiteralInclude)
456 
457     return {
458         'version': 'builtin',
459         'parallel_read_safe': True,
460         'parallel_write_safe': True,
461     }

</code><intended_behavior>The handling of the `:prepend:` option within code directives, likely around functions processing the `literalinclude` and similar directives, should be augmented to preserve leading whitespace of the `prepend` content. This would entail ensuring that any application of `dedent` or similar transformations to the included content does not strip leading whitespace from the `prepend` string. The intended behavior should allow the `prepend` content to maintain its specified formatting, including indentation, when inserted before the included code segment. This preservation would enable users to match the indentation of the included content with the surrounding documentation correctly.</intended_behavior>, <file>sphinx/directives/code.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 import textwrap
3 from difflib import unified_diff
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple
5 
6 from docutils import nodes
7 from docutils.nodes import Element, Node
8 from docutils.parsers.rst import directives
9 from docutils.statemachine import StringList
10 
11 from sphinx import addnodes
12 from sphinx.config import Config
13 from sphinx.directives import optional_int
14 from sphinx.locale import __
15 from sphinx.util import logging, parselinenos
16 from sphinx.util.docutils import SphinxDirective
17 from sphinx.util.typing import OptionSpec
18 
19 if TYPE_CHECKING:
20     from sphinx.application import Sphinx
21 
22 logger = logging.getLogger(__name__)
23 
24 
25 class Highlight(SphinxDirective):
26     """
27     Directive to set the highlighting language for code blocks, as well
28     as the threshold for line numbers.
29     """
30 
31     has_content = False
32     required_arguments = 1
33     optional_arguments = 0
34     final_argument_whitespace = False
35     option_spec: OptionSpec = {
36         'force': directives.flag,
37         'linenothreshold': directives.positive_int,
38     }
39 
40     def run(self) -> List[Node]:
41         language = self.arguments[0].strip()
42         linenothreshold = self.options.get('linenothreshold', sys.maxsize)
43         force = 'force' in self.options
44 
45         self.env.temp_data['highlight_language'] = language
46         return [addnodes.highlightlang(lang=language,
47                                        force=force,
48                                        linenothreshold=linenothreshold)]
49 
50 
51 def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:
52     if dedent is None:
53         return textwrap.dedent(''.join(lines)).splitlines(True)
54 
55     if any(s[:dedent].strip() for s in lines):
56         logger.warning(__('non-whitespace stripped by dedent'), location=location)
57 
58     new_lines = []
59     for line in lines:
60         new_line = line[dedent:]
61         if line.endswith('\n') and not new_line:
62             new_line = '\n'  # keep CRLF
63         new_lines.append(new_line)
64 
65     return new_lines
66 
67 
68 def container_wrapper(directive: SphinxDirective, literal_node: Node, caption: str) -> nodes.container:  # NOQA
69     container_node = nodes.container('', literal_block=True,
70                                      classes=['literal-block-wrapper'])
71     parsed = nodes.Element()
72     directive.state.nested_parse(StringList([caption], source=''),
73                                  directive.content_offset, parsed)
74     if isinstance(parsed[0], nodes.system_message):
75         msg = __('Invalid caption: %s' % parsed[0].astext())
76         raise ValueError(msg)
77     elif isinstance(parsed[0], nodes.Element):
78         caption_node = nodes.caption(parsed[0].rawsource, '',
79                                      *parsed[0].children)
80         caption_node.source = literal_node.source
81         caption_node.line = literal_node.line
82         container_node += caption_node
83         container_node += literal_node
84         return container_node
85     else:
86         raise RuntimeError  # never reached
87 
88 
89 class CodeBlock(SphinxDirective):
90     """
91     Directive for a code block with special highlighting or line numbering
92     settings.
93     """
94 
95     has_content = True
96     required_arguments = 0
97     optional_arguments = 1
98     final_argument_whitespace = False
99     option_spec: OptionSpec = {
100         'force': directives.flag,
101         'linenos': directives.flag,
102         'dedent': optional_int,
103         'lineno-start': int,
104         'emphasize-lines': directives.unchanged_required,
105         'caption': directives.unchanged_required,
106         'class': directives.class_option,
107         'name': directives.unchanged,
108     }
109 
110     def run(self) -> List[Node]:
111         document = self.state.document
112         code = '\n'.join(self.content)
113         location = self.state_machine.get_source_and_line(self.lineno)
114 
115         linespec = self.options.get('emphasize-lines')
116         if linespec:
117             try:
118                 nlines = len(self.content)
119                 hl_lines = parselinenos(linespec, nlines)
120                 if any(i >= nlines for i in hl_lines):
121                     logger.warning(__('line number spec is out of range(1-%d): %r') %
122                                    (nlines, self.options['emphasize-lines']),
123                                    location=location)
124 
125                 hl_lines = [x + 1 for x in hl_lines if x < nlines]
126             except ValueError as err:
127                 return [document.reporter.warning(err, line=self.lineno)]
128         else:
129             hl_lines = None
130 
131         if 'dedent' in self.options:
132             location = self.state_machine.get_source_and_line(self.lineno)
133             lines = code.splitlines(True)
134             lines = dedent_lines(lines, self.options['dedent'], location=location)
135             code = ''.join(lines)
136 
137         literal: Element = nodes.literal_block(code, code)
138         if 'linenos' in self.options or 'lineno-start' in self.options:
139             literal['linenos'] = True
140         literal['classes'] += self.options.get('class', [])
141         literal['force'] = 'force' in self.options
142         if self.arguments:
143             # highlight language specified
144             literal['language'] = self.arguments[0]
145         else:
146             # no highlight language specified.  Then this directive refers the current
147             # highlight setting via ``highlight`` directive or ``highlight_language``
148             # configuration.
149             literal['language'] = self.env.temp_data.get('highlight_language',
150                                                          self.config.highlight_language)
151         extra_args = literal['highlight_args'] = {}
152         if hl_lines is not None:
153             extra_args['hl_lines'] = hl_lines
154         if 'lineno-start' in self.options:
155             extra_args['linenostart'] = self.options['lineno-start']
156         self.set_source_info(literal)
157 
158         caption = self.options.get('caption')
159         if caption:
160             try:
161                 literal = container_wrapper(self, literal, caption)
162             except ValueError as exc:
163                 return [document.reporter.warning(exc, line=self.lineno)]
164 
165         # literal will be note_implicit_target that is linked from caption and numref.
166         # when options['name'] is provided, it should be primary ID.
167         self.add_name(literal)
168 
169         return [literal]
170 
171 
172 class LiteralIncludeReader:
173     INVALID_OPTIONS_PAIR = [
174         ('lineno-match', 'lineno-start'),
175         ('lineno-match', 'append'),
176         ('lineno-match', 'prepend'),
177         ('start-after', 'start-at'),
178         ('end-before', 'end-at'),
179         ('diff', 'pyobject'),
180         ('diff', 'lineno-start'),
181         ('diff', 'lineno-match'),
182         ('diff', 'lines'),
183         ('diff', 'start-after'),
184         ('diff', 'end-before'),
185         ('diff', 'start-at'),
186         ('diff', 'end-at'),
187     ]
188 
189     def __init__(self, filename: str, options: Dict, config: Config) -> None:
190         self.filename = filename
191         self.options = options
192         self.encoding = options.get('encoding', config.source_encoding)
193         self.lineno_start = self.options.get('lineno-start', 1)
194 
195         self.parse_options()
196 
197     def parse_options(self) -> None:
198         for option1, option2 in self.INVALID_OPTIONS_PAIR:
199             if option1 in self.options and option2 in self.options:
200                 raise ValueError(__('Cannot use both "%s" and "%s" options') %
201                                  (option1, option2))
202 
203     def read_file(self, filename: str, location: Tuple[str, int] = None) -> List[str]:
204         try:
205             with open(filename, encoding=self.encoding, errors='strict') as f:
206                 text = f.read()
207                 if 'tab-width' in self.options:
208                     text = text.expandtabs(self.options['tab-width'])
209 
210                 return text.splitlines(True)
211         except OSError as exc:
212             raise OSError(__('Include file %r not found or reading it failed') %
213                           filename) from exc
214         except UnicodeError as exc:
215             raise UnicodeError(__('Encoding %r used for reading included file %r seems to '
216                                   'be wrong, try giving an :encoding: option') %
217                                (self.encoding, filename)) from exc
218 
219     def read(self, location: Tuple[str, int] = None) -> Tuple[str, int]:
220         if 'diff' in self.options:
221             lines = self.show_diff()
222         else:
223             filters = [self.pyobject_filter,
224                        self.start_filter,
225                        self.end_filter,
226                        self.lines_filter,
227                        self.prepend_filter,
228                        self.append_filter,
229                        self.dedent_filter]
230             lines = self.read_file(self.filename, location=location)
231             for func in filters:
232                 lines = func(lines, location=location)
233 
234         return ''.join(lines), len(lines)
235 
236     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:
237         new_lines = self.read_file(self.filename)
238         old_filename = self.options.get('diff')
239         old_lines = self.read_file(old_filename)
240         diff = unified_diff(old_lines, new_lines, old_filename, self.filename)
241         return list(diff)
242 
243     def pyobject_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
244         pyobject = self.options.get('pyobject')
245         if pyobject:
246             from sphinx.pycode import ModuleAnalyzer
247             analyzer = ModuleAnalyzer.for_file(self.filename, '')
248             tags = analyzer.find_tags()
249             if pyobject not in tags:
250                 raise ValueError(__('Object named %r not found in include file %r') %
251                                  (pyobject, self.filename))
252             else:
253                 start = tags[pyobject][1]
254                 end = tags[pyobject][2]
255                 lines = lines[start - 1:end]
256                 if 'lineno-match' in self.options:
257                     self.lineno_start = start
258 
259         return lines
260 
261     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
262         linespec = self.options.get('lines')
263         if linespec:
264             linelist = parselinenos(linespec, len(lines))
265             if any(i >= len(lines) for i in linelist):
266                 logger.warning(__('line number spec is out of range(1-%d): %r') %
267                                (len(lines), linespec), location=location)
268 
269             if 'lineno-match' in self.options:
270                 # make sure the line list is not "disjoint".
271                 first = linelist[0]
272                 if all(first + i == n for i, n in enumerate(linelist)):
273                     self.lineno_start += linelist[0]
274                 else:
275                     raise ValueError(__('Cannot use "lineno-match" with a disjoint '
276                                         'set of "lines"'))
277 
278             lines = [lines[n] for n in linelist if n < len(lines)]
279             if lines == []:
280                 raise ValueError(__('Line spec %r: no lines pulled from include file %r') %
281                                  (linespec, self.filename))
282 
283         return lines
284 
285     def start_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
286         if 'start-at' in self.options:
287             start = self.options.get('start-at')
288             inclusive = False
289         elif 'start-after' in self.options:
290             start = self.options.get('start-after')
291             inclusive = True
292         else:
293             start = None
294 
295         if start:
296             for lineno, line in enumerate(lines):
297                 if start in line:
298                     if inclusive:
299                         if 'lineno-match' in self.options:
300                             self.lineno_start += lineno + 1
301 
302                         return lines[lineno + 1:]
303                     else:
304                         if 'lineno-match' in self.options:
305                             self.lineno_start += lineno
306 
307                         return lines[lineno:]
308 
309             if inclusive is True:
310                 raise ValueError('start-after pattern not found: %s' % start)
311             else:
312                 raise ValueError('start-at pattern not found: %s' % start)
313 
314         return lines
315 
316     def end_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
317         if 'end-at' in self.options:
318             end = self.options.get('end-at')
319             inclusive = True
320         elif 'end-before' in self.options:
321             end = self.options.get('end-before')
322             inclusive = False
323         else:
324             end = None
325 
326         if end:
327             for lineno, line in enumerate(lines):
328                 if end in line:
329                     if inclusive:
330                         return lines[:lineno + 1]
331                     else:
332                         if lineno == 0:
333                             pass  # end-before ignores first line
334                         else:
335                             return lines[:lineno]
336             if inclusive is True:
337                 raise ValueError('end-at pattern not found: %s' % end)
338             else:
339                 raise ValueError('end-before pattern not found: %s' % end)
340 
341         return lines
342 
343     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
344         prepend = self.options.get('prepend')
345         if prepend:
346             lines.insert(0, prepend + '\n')
347 
348         return lines
349 
350     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
351         append = self.options.get('append')
352         if append:
353             lines.append(append + '\n')
354 
355         return lines
356 
357     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
358         if 'dedent' in self.options:
359             return dedent_lines(lines, self.options.get('dedent'), location=location)
360         else:
361             return lines
362 
363 
364 class LiteralInclude(SphinxDirective):
365     """
366     Like ``.. include:: :literal:``, but only warns if the include file is
367     not found, and does not raise errors.  Also has several options for
368     selecting what to include.
369     """
370 
371     has_content = False
372     required_arguments = 1
373     optional_arguments = 0
374     final_argument_whitespace = True
375     option_spec: OptionSpec = {
376         'dedent': optional_int,
377         'linenos': directives.flag,
378         'lineno-start': int,
379         'lineno-match': directives.flag,
380         'tab-width': int,
381         'language': directives.unchanged_required,
382         'force': directives.flag,
383         'encoding': directives.encoding,
384         'pyobject': directives.unchanged_required,
385         'lines': directives.unchanged_required,
386         'start-after': directives.unchanged_required,
387         'end-before': directives.unchanged_required,
388         'start-at': directives.unchanged_required,
389         'end-at': directives.unchanged_required,
390         'prepend': directives.unchanged_required,
391         'append': directives.unchanged_required,
392         'emphasize-lines': directives.unchanged_required,
393         'caption': directives.unchanged,
394         'class': directives.class_option,
395         'name': directives.unchanged,
396         'diff': directives.unchanged_required,
397     }
398 
399     def run(self) -> List[Node]:
400         document = self.state.document
401         if not document.settings.file_insertion_enabled:
402             return [document.reporter.warning('File insertion disabled',
403                                               line=self.lineno)]
404         # convert options['diff'] to absolute path
405         if 'diff' in self.options:
406             _, path = self.env.relfn2path(self.options['diff'])
407             self.options['diff'] = path
408 
409         try:
410             location = self.state_machine.get_source_and_line(self.lineno)
411             rel_filename, filename = self.env.relfn2path(self.arguments[0])
412             self.env.note_dependency(rel_filename)
413 
414             reader = LiteralIncludeReader(filename, self.options, self.config)
415             text, lines = reader.read(location=location)
416 
417             retnode: Element = nodes.literal_block(text, text, source=filename)
418             retnode['force'] = 'force' in self.options
419             self.set_source_info(retnode)
420             if self.options.get('diff'):  # if diff is set, set udiff
421                 retnode['language'] = 'udiff'
422             elif 'language' in self.options:
423                 retnode['language'] = self.options['language']
424             if ('linenos' in self.options or 'lineno-start' in self.options or
425                     'lineno-match' in self.options):
426                 retnode['linenos'] = True
427             retnode['classes'] += self.options.get('class', [])
428             extra_args = retnode['highlight_args'] = {}
429             if 'emphasize-lines' in self.options:
430                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)
431                 if any(i >= lines for i in hl_lines):
432                     logger.warning(__('line number spec is out of range(1-%d): %r') %
433                                    (lines, self.options['emphasize-lines']),
434                                    location=location)
435                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]
436             extra_args['linenostart'] = reader.lineno_start
437 
438             if 'caption' in self.options:
439                 caption = self.options['caption'] or self.arguments[0]
440                 retnode = container_wrapper(self, retnode, caption)
441 
442             # retnode will be note_implicit_target that is linked from caption and numref.
443             # when options['name'] is provided, it should be primary ID.
444             self.add_name(retnode)
445 
446             return [retnode]
447         except Exception as exc:
448             return [document.reporter.warning(exc, line=self.lineno)]
449 
450 
451 def setup(app: "Sphinx") -> Dict[str, Any]:
452     directives.register_directive('highlight', Highlight)
453     directives.register_directive('code-block', CodeBlock)
454     directives.register_directive('sourcecode', CodeBlock)
455     directives.register_directive('literalinclude', LiteralInclude)
456 
457     return {
458         'version': 'builtin',
459         'parallel_read_safe': True,
460         'parallel_write_safe': True,
461     }

</code><intended_behavior>The logic for `:dedent:` option processing needs to be refined to ensure it does not apply to `prepend` or `append` content. The dedentation should strictly affect the content being included via the `literalinclude` directive and not the manually specified `prepend` or `append` strings. Implementing a conditional application of `dedent` or modifying how dedentation is calculated can achieve this. This ensures that users have control over the indentation of the content they are adding explicitly, separate from the automated adjustment of the included content's indentation level.</intended_behavior>]
2025-10-15 11:26:00.553 | INFO     | Search completed. Bug locations: [<file>sphinx/directives/code.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 import textwrap
3 from difflib import unified_diff
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple
5 
6 from docutils import nodes
7 from docutils.nodes import Element, Node
8 from docutils.parsers.rst import directives
9 from docutils.statemachine import StringList
10 
11 from sphinx import addnodes
12 from sphinx.config import Config
13 from sphinx.directives import optional_int
14 from sphinx.locale import __
15 from sphinx.util import logging, parselinenos
16 from sphinx.util.docutils import SphinxDirective
17 from sphinx.util.typing import OptionSpec
18 
19 if TYPE_CHECKING:
20     from sphinx.application import Sphinx
21 
22 logger = logging.getLogger(__name__)
23 
24 
25 class Highlight(SphinxDirective):
26     """
27     Directive to set the highlighting language for code blocks, as well
28     as the threshold for line numbers.
29     """
30 
31     has_content = False
32     required_arguments = 1
33     optional_arguments = 0
34     final_argument_whitespace = False
35     option_spec: OptionSpec = {
36         'force': directives.flag,
37         'linenothreshold': directives.positive_int,
38     }
39 
40     def run(self) -> List[Node]:
41         language = self.arguments[0].strip()
42         linenothreshold = self.options.get('linenothreshold', sys.maxsize)
43         force = 'force' in self.options
44 
45         self.env.temp_data['highlight_language'] = language
46         return [addnodes.highlightlang(lang=language,
47                                        force=force,
48                                        linenothreshold=linenothreshold)]
49 
50 
51 def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:
52     if dedent is None:
53         return textwrap.dedent(''.join(lines)).splitlines(True)
54 
55     if any(s[:dedent].strip() for s in lines):
56         logger.warning(__('non-whitespace stripped by dedent'), location=location)
57 
58     new_lines = []
59     for line in lines:
60         new_line = line[dedent:]
61         if line.endswith('\n') and not new_line:
62             new_line = '\n'  # keep CRLF
63         new_lines.append(new_line)
64 
65     return new_lines
66 
67 
68 def container_wrapper(directive: SphinxDirective, literal_node: Node, caption: str) -> nodes.container:  # NOQA
69     container_node = nodes.container('', literal_block=True,
70                                      classes=['literal-block-wrapper'])
71     parsed = nodes.Element()
72     directive.state.nested_parse(StringList([caption], source=''),
73                                  directive.content_offset, parsed)
74     if isinstance(parsed[0], nodes.system_message):
75         msg = __('Invalid caption: %s' % parsed[0].astext())
76         raise ValueError(msg)
77     elif isinstance(parsed[0], nodes.Element):
78         caption_node = nodes.caption(parsed[0].rawsource, '',
79                                      *parsed[0].children)
80         caption_node.source = literal_node.source
81         caption_node.line = literal_node.line
82         container_node += caption_node
83         container_node += literal_node
84         return container_node
85     else:
86         raise RuntimeError  # never reached
87 
88 
89 class CodeBlock(SphinxDirective):
90     """
91     Directive for a code block with special highlighting or line numbering
92     settings.
93     """
94 
95     has_content = True
96     required_arguments = 0
97     optional_arguments = 1
98     final_argument_whitespace = False
99     option_spec: OptionSpec = {
100         'force': directives.flag,
101         'linenos': directives.flag,
102         'dedent': optional_int,
103         'lineno-start': int,
104         'emphasize-lines': directives.unchanged_required,
105         'caption': directives.unchanged_required,
106         'class': directives.class_option,
107         'name': directives.unchanged,
108     }
109 
110     def run(self) -> List[Node]:
111         document = self.state.document
112         code = '\n'.join(self.content)
113         location = self.state_machine.get_source_and_line(self.lineno)
114 
115         linespec = self.options.get('emphasize-lines')
116         if linespec:
117             try:
118                 nlines = len(self.content)
119                 hl_lines = parselinenos(linespec, nlines)
120                 if any(i >= nlines for i in hl_lines):
121                     logger.warning(__('line number spec is out of range(1-%d): %r') %
122                                    (nlines, self.options['emphasize-lines']),
123                                    location=location)
124 
125                 hl_lines = [x + 1 for x in hl_lines if x < nlines]
126             except ValueError as err:
127                 return [document.reporter.warning(err, line=self.lineno)]
128         else:
129             hl_lines = None
130 
131         if 'dedent' in self.options:
132             location = self.state_machine.get_source_and_line(self.lineno)
133             lines = code.splitlines(True)
134             lines = dedent_lines(lines, self.options['dedent'], location=location)
135             code = ''.join(lines)
136 
137         literal: Element = nodes.literal_block(code, code)
138         if 'linenos' in self.options or 'lineno-start' in self.options:
139             literal['linenos'] = True
140         literal['classes'] += self.options.get('class', [])
141         literal['force'] = 'force' in self.options
142         if self.arguments:
143             # highlight language specified
144             literal['language'] = self.arguments[0]
145         else:
146             # no highlight language specified.  Then this directive refers the current
147             # highlight setting via ``highlight`` directive or ``highlight_language``
148             # configuration.
149             literal['language'] = self.env.temp_data.get('highlight_language',
150                                                          self.config.highlight_language)
151         extra_args = literal['highlight_args'] = {}
152         if hl_lines is not None:
153             extra_args['hl_lines'] = hl_lines
154         if 'lineno-start' in self.options:
155             extra_args['linenostart'] = self.options['lineno-start']
156         self.set_source_info(literal)
157 
158         caption = self.options.get('caption')
159         if caption:
160             try:
161                 literal = container_wrapper(self, literal, caption)
162             except ValueError as exc:
163                 return [document.reporter.warning(exc, line=self.lineno)]
164 
165         # literal will be note_implicit_target that is linked from caption and numref.
166         # when options['name'] is provided, it should be primary ID.
167         self.add_name(literal)
168 
169         return [literal]
170 
171 
172 class LiteralIncludeReader:
173     INVALID_OPTIONS_PAIR = [
174         ('lineno-match', 'lineno-start'),
175         ('lineno-match', 'append'),
176         ('lineno-match', 'prepend'),
177         ('start-after', 'start-at'),
178         ('end-before', 'end-at'),
179         ('diff', 'pyobject'),
180         ('diff', 'lineno-start'),
181         ('diff', 'lineno-match'),
182         ('diff', 'lines'),
183         ('diff', 'start-after'),
184         ('diff', 'end-before'),
185         ('diff', 'start-at'),
186         ('diff', 'end-at'),
187     ]
188 
189     def __init__(self, filename: str, options: Dict, config: Config) -> None:
190         self.filename = filename
191         self.options = options
192         self.encoding = options.get('encoding', config.source_encoding)
193         self.lineno_start = self.options.get('lineno-start', 1)
194 
195         self.parse_options()
196 
197     def parse_options(self) -> None:
198         for option1, option2 in self.INVALID_OPTIONS_PAIR:
199             if option1 in self.options and option2 in self.options:
200                 raise ValueError(__('Cannot use both "%s" and "%s" options') %
201                                  (option1, option2))
202 
203     def read_file(self, filename: str, location: Tuple[str, int] = None) -> List[str]:
204         try:
205             with open(filename, encoding=self.encoding, errors='strict') as f:
206                 text = f.read()
207                 if 'tab-width' in self.options:
208                     text = text.expandtabs(self.options['tab-width'])
209 
210                 return text.splitlines(True)
211         except OSError as exc:
212             raise OSError(__('Include file %r not found or reading it failed') %
213                           filename) from exc
214         except UnicodeError as exc:
215             raise UnicodeError(__('Encoding %r used for reading included file %r seems to '
216                                   'be wrong, try giving an :encoding: option') %
217                                (self.encoding, filename)) from exc
218 
219     def read(self, location: Tuple[str, int] = None) -> Tuple[str, int]:
220         if 'diff' in self.options:
221             lines = self.show_diff()
222         else:
223             filters = [self.pyobject_filter,
224                        self.start_filter,
225                        self.end_filter,
226                        self.lines_filter,
227                        self.prepend_filter,
228                        self.append_filter,
229                        self.dedent_filter]
230             lines = self.read_file(self.filename, location=location)
231             for func in filters:
232                 lines = func(lines, location=location)
233 
234         return ''.join(lines), len(lines)
235 
236     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:
237         new_lines = self.read_file(self.filename)
238         old_filename = self.options.get('diff')
239         old_lines = self.read_file(old_filename)
240         diff = unified_diff(old_lines, new_lines, old_filename, self.filename)
241         return list(diff)
242 
243     def pyobject_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
244         pyobject = self.options.get('pyobject')
245         if pyobject:
246             from sphinx.pycode import ModuleAnalyzer
247             analyzer = ModuleAnalyzer.for_file(self.filename, '')
248             tags = analyzer.find_tags()
249             if pyobject not in tags:
250                 raise ValueError(__('Object named %r not found in include file %r') %
251                                  (pyobject, self.filename))
252             else:
253                 start = tags[pyobject][1]
254                 end = tags[pyobject][2]
255                 lines = lines[start - 1:end]
256                 if 'lineno-match' in self.options:
257                     self.lineno_start = start
258 
259         return lines
260 
261     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
262         linespec = self.options.get('lines')
263         if linespec:
264             linelist = parselinenos(linespec, len(lines))
265             if any(i >= len(lines) for i in linelist):
266                 logger.warning(__('line number spec is out of range(1-%d): %r') %
267                                (len(lines), linespec), location=location)
268 
269             if 'lineno-match' in self.options:
270                 # make sure the line list is not "disjoint".
271                 first = linelist[0]
272                 if all(first + i == n for i, n in enumerate(linelist)):
273                     self.lineno_start += linelist[0]
274                 else:
275                     raise ValueError(__('Cannot use "lineno-match" with a disjoint '
276                                         'set of "lines"'))
277 
278             lines = [lines[n] for n in linelist if n < len(lines)]
279             if lines == []:
280                 raise ValueError(__('Line spec %r: no lines pulled from include file %r') %
281                                  (linespec, self.filename))
282 
283         return lines
284 
285     def start_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
286         if 'start-at' in self.options:
287             start = self.options.get('start-at')
288             inclusive = False
289         elif 'start-after' in self.options:
290             start = self.options.get('start-after')
291             inclusive = True
292         else:
293             start = None
294 
295         if start:
296             for lineno, line in enumerate(lines):
297                 if start in line:
298                     if inclusive:
299                         if 'lineno-match' in self.options:
300                             self.lineno_start += lineno + 1
301 
302                         return lines[lineno + 1:]
303                     else:
304                         if 'lineno-match' in self.options:
305                             self.lineno_start += lineno
306 
307                         return lines[lineno:]
308 
309             if inclusive is True:
310                 raise ValueError('start-after pattern not found: %s' % start)
311             else:
312                 raise ValueError('start-at pattern not found: %s' % start)
313 
314         return lines
315 
316     def end_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
317         if 'end-at' in self.options:
318             end = self.options.get('end-at')
319             inclusive = True
320         elif 'end-before' in self.options:
321             end = self.options.get('end-before')
322             inclusive = False
323         else:
324             end = None
325 
326         if end:
327             for lineno, line in enumerate(lines):
328                 if end in line:
329                     if inclusive:
330                         return lines[:lineno + 1]
331                     else:
332                         if lineno == 0:
333                             pass  # end-before ignores first line
334                         else:
335                             return lines[:lineno]
336             if inclusive is True:
337                 raise ValueError('end-at pattern not found: %s' % end)
338             else:
339                 raise ValueError('end-before pattern not found: %s' % end)
340 
341         return lines
342 
343     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
344         prepend = self.options.get('prepend')
345         if prepend:
346             lines.insert(0, prepend + '\n')
347 
348         return lines
349 
350     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
351         append = self.options.get('append')
352         if append:
353             lines.append(append + '\n')
354 
355         return lines
356 
357     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
358         if 'dedent' in self.options:
359             return dedent_lines(lines, self.options.get('dedent'), location=location)
360         else:
361             return lines
362 
363 
364 class LiteralInclude(SphinxDirective):
365     """
366     Like ``.. include:: :literal:``, but only warns if the include file is
367     not found, and does not raise errors.  Also has several options for
368     selecting what to include.
369     """
370 
371     has_content = False
372     required_arguments = 1
373     optional_arguments = 0
374     final_argument_whitespace = True
375     option_spec: OptionSpec = {
376         'dedent': optional_int,
377         'linenos': directives.flag,
378         'lineno-start': int,
379         'lineno-match': directives.flag,
380         'tab-width': int,
381         'language': directives.unchanged_required,
382         'force': directives.flag,
383         'encoding': directives.encoding,
384         'pyobject': directives.unchanged_required,
385         'lines': directives.unchanged_required,
386         'start-after': directives.unchanged_required,
387         'end-before': directives.unchanged_required,
388         'start-at': directives.unchanged_required,
389         'end-at': directives.unchanged_required,
390         'prepend': directives.unchanged_required,
391         'append': directives.unchanged_required,
392         'emphasize-lines': directives.unchanged_required,
393         'caption': directives.unchanged,
394         'class': directives.class_option,
395         'name': directives.unchanged,
396         'diff': directives.unchanged_required,
397     }
398 
399     def run(self) -> List[Node]:
400         document = self.state.document
401         if not document.settings.file_insertion_enabled:
402             return [document.reporter.warning('File insertion disabled',
403                                               line=self.lineno)]
404         # convert options['diff'] to absolute path
405         if 'diff' in self.options:
406             _, path = self.env.relfn2path(self.options['diff'])
407             self.options['diff'] = path
408 
409         try:
410             location = self.state_machine.get_source_and_line(self.lineno)
411             rel_filename, filename = self.env.relfn2path(self.arguments[0])
412             self.env.note_dependency(rel_filename)
413 
414             reader = LiteralIncludeReader(filename, self.options, self.config)
415             text, lines = reader.read(location=location)
416 
417             retnode: Element = nodes.literal_block(text, text, source=filename)
418             retnode['force'] = 'force' in self.options
419             self.set_source_info(retnode)
420             if self.options.get('diff'):  # if diff is set, set udiff
421                 retnode['language'] = 'udiff'
422             elif 'language' in self.options:
423                 retnode['language'] = self.options['language']
424             if ('linenos' in self.options or 'lineno-start' in self.options or
425                     'lineno-match' in self.options):
426                 retnode['linenos'] = True
427             retnode['classes'] += self.options.get('class', [])
428             extra_args = retnode['highlight_args'] = {}
429             if 'emphasize-lines' in self.options:
430                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)
431                 if any(i >= lines for i in hl_lines):
432                     logger.warning(__('line number spec is out of range(1-%d): %r') %
433                                    (lines, self.options['emphasize-lines']),
434                                    location=location)
435                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]
436             extra_args['linenostart'] = reader.lineno_start
437 
438             if 'caption' in self.options:
439                 caption = self.options['caption'] or self.arguments[0]
440                 retnode = container_wrapper(self, retnode, caption)
441 
442             # retnode will be note_implicit_target that is linked from caption and numref.
443             # when options['name'] is provided, it should be primary ID.
444             self.add_name(retnode)
445 
446             return [retnode]
447         except Exception as exc:
448             return [document.reporter.warning(exc, line=self.lineno)]
449 
450 
451 def setup(app: "Sphinx") -> Dict[str, Any]:
452     directives.register_directive('highlight', Highlight)
453     directives.register_directive('code-block', CodeBlock)
454     directives.register_directive('sourcecode', CodeBlock)
455     directives.register_directive('literalinclude', LiteralInclude)
456 
457     return {
458         'version': 'builtin',
459         'parallel_read_safe': True,
460         'parallel_write_safe': True,
461     }

</code><intended_behavior>The handling of the `:prepend:` option within code directives, likely around functions processing the `literalinclude` and similar directives, should be augmented to preserve leading whitespace of the `prepend` content. This would entail ensuring that any application of `dedent` or similar transformations to the included content does not strip leading whitespace from the `prepend` string. The intended behavior should allow the `prepend` content to maintain its specified formatting, including indentation, when inserted before the included code segment. This preservation would enable users to match the indentation of the included content with the surrounding documentation correctly.</intended_behavior>, <file>sphinx/directives/code.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 import textwrap
3 from difflib import unified_diff
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple
5 
6 from docutils import nodes
7 from docutils.nodes import Element, Node
8 from docutils.parsers.rst import directives
9 from docutils.statemachine import StringList
10 
11 from sphinx import addnodes
12 from sphinx.config import Config
13 from sphinx.directives import optional_int
14 from sphinx.locale import __
15 from sphinx.util import logging, parselinenos
16 from sphinx.util.docutils import SphinxDirective
17 from sphinx.util.typing import OptionSpec
18 
19 if TYPE_CHECKING:
20     from sphinx.application import Sphinx
21 
22 logger = logging.getLogger(__name__)
23 
24 
25 class Highlight(SphinxDirective):
26     """
27     Directive to set the highlighting language for code blocks, as well
28     as the threshold for line numbers.
29     """
30 
31     has_content = False
32     required_arguments = 1
33     optional_arguments = 0
34     final_argument_whitespace = False
35     option_spec: OptionSpec = {
36         'force': directives.flag,
37         'linenothreshold': directives.positive_int,
38     }
39 
40     def run(self) -> List[Node]:
41         language = self.arguments[0].strip()
42         linenothreshold = self.options.get('linenothreshold', sys.maxsize)
43         force = 'force' in self.options
44 
45         self.env.temp_data['highlight_language'] = language
46         return [addnodes.highlightlang(lang=language,
47                                        force=force,
48                                        linenothreshold=linenothreshold)]
49 
50 
51 def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:
52     if dedent is None:
53         return textwrap.dedent(''.join(lines)).splitlines(True)
54 
55     if any(s[:dedent].strip() for s in lines):
56         logger.warning(__('non-whitespace stripped by dedent'), location=location)
57 
58     new_lines = []
59     for line in lines:
60         new_line = line[dedent:]
61         if line.endswith('\n') and not new_line:
62             new_line = '\n'  # keep CRLF
63         new_lines.append(new_line)
64 
65     return new_lines
66 
67 
68 def container_wrapper(directive: SphinxDirective, literal_node: Node, caption: str) -> nodes.container:  # NOQA
69     container_node = nodes.container('', literal_block=True,
70                                      classes=['literal-block-wrapper'])
71     parsed = nodes.Element()
72     directive.state.nested_parse(StringList([caption], source=''),
73                                  directive.content_offset, parsed)
74     if isinstance(parsed[0], nodes.system_message):
75         msg = __('Invalid caption: %s' % parsed[0].astext())
76         raise ValueError(msg)
77     elif isinstance(parsed[0], nodes.Element):
78         caption_node = nodes.caption(parsed[0].rawsource, '',
79                                      *parsed[0].children)
80         caption_node.source = literal_node.source
81         caption_node.line = literal_node.line
82         container_node += caption_node
83         container_node += literal_node
84         return container_node
85     else:
86         raise RuntimeError  # never reached
87 
88 
89 class CodeBlock(SphinxDirective):
90     """
91     Directive for a code block with special highlighting or line numbering
92     settings.
93     """
94 
95     has_content = True
96     required_arguments = 0
97     optional_arguments = 1
98     final_argument_whitespace = False
99     option_spec: OptionSpec = {
100         'force': directives.flag,
101         'linenos': directives.flag,
102         'dedent': optional_int,
103         'lineno-start': int,
104         'emphasize-lines': directives.unchanged_required,
105         'caption': directives.unchanged_required,
106         'class': directives.class_option,
107         'name': directives.unchanged,
108     }
109 
110     def run(self) -> List[Node]:
111         document = self.state.document
112         code = '\n'.join(self.content)
113         location = self.state_machine.get_source_and_line(self.lineno)
114 
115         linespec = self.options.get('emphasize-lines')
116         if linespec:
117             try:
118                 nlines = len(self.content)
119                 hl_lines = parselinenos(linespec, nlines)
120                 if any(i >= nlines for i in hl_lines):
121                     logger.warning(__('line number spec is out of range(1-%d): %r') %
122                                    (nlines, self.options['emphasize-lines']),
123                                    location=location)
124 
125                 hl_lines = [x + 1 for x in hl_lines if x < nlines]
126             except ValueError as err:
127                 return [document.reporter.warning(err, line=self.lineno)]
128         else:
129             hl_lines = None
130 
131         if 'dedent' in self.options:
132             location = self.state_machine.get_source_and_line(self.lineno)
133             lines = code.splitlines(True)
134             lines = dedent_lines(lines, self.options['dedent'], location=location)
135             code = ''.join(lines)
136 
137         literal: Element = nodes.literal_block(code, code)
138         if 'linenos' in self.options or 'lineno-start' in self.options:
139             literal['linenos'] = True
140         literal['classes'] += self.options.get('class', [])
141         literal['force'] = 'force' in self.options
142         if self.arguments:
143             # highlight language specified
144             literal['language'] = self.arguments[0]
145         else:
146             # no highlight language specified.  Then this directive refers the current
147             # highlight setting via ``highlight`` directive or ``highlight_language``
148             # configuration.
149             literal['language'] = self.env.temp_data.get('highlight_language',
150                                                          self.config.highlight_language)
151         extra_args = literal['highlight_args'] = {}
152         if hl_lines is not None:
153             extra_args['hl_lines'] = hl_lines
154         if 'lineno-start' in self.options:
155             extra_args['linenostart'] = self.options['lineno-start']
156         self.set_source_info(literal)
157 
158         caption = self.options.get('caption')
159         if caption:
160             try:
161                 literal = container_wrapper(self, literal, caption)
162             except ValueError as exc:
163                 return [document.reporter.warning(exc, line=self.lineno)]
164 
165         # literal will be note_implicit_target that is linked from caption and numref.
166         # when options['name'] is provided, it should be primary ID.
167         self.add_name(literal)
168 
169         return [literal]
170 
171 
172 class LiteralIncludeReader:
173     INVALID_OPTIONS_PAIR = [
174         ('lineno-match', 'lineno-start'),
175         ('lineno-match', 'append'),
176         ('lineno-match', 'prepend'),
177         ('start-after', 'start-at'),
178         ('end-before', 'end-at'),
179         ('diff', 'pyobject'),
180         ('diff', 'lineno-start'),
181         ('diff', 'lineno-match'),
182         ('diff', 'lines'),
183         ('diff', 'start-after'),
184         ('diff', 'end-before'),
185         ('diff', 'start-at'),
186         ('diff', 'end-at'),
187     ]
188 
189     def __init__(self, filename: str, options: Dict, config: Config) -> None:
190         self.filename = filename
191         self.options = options
192         self.encoding = options.get('encoding', config.source_encoding)
193         self.lineno_start = self.options.get('lineno-start', 1)
194 
195         self.parse_options()
196 
197     def parse_options(self) -> None:
198         for option1, option2 in self.INVALID_OPTIONS_PAIR:
199             if option1 in self.options and option2 in self.options:
200                 raise ValueError(__('Cannot use both "%s" and "%s" options') %
201                                  (option1, option2))
202 
203     def read_file(self, filename: str, location: Tuple[str, int] = None) -> List[str]:
204         try:
205             with open(filename, encoding=self.encoding, errors='strict') as f:
206                 text = f.read()
207                 if 'tab-width' in self.options:
208                     text = text.expandtabs(self.options['tab-width'])
209 
210                 return text.splitlines(True)
211         except OSError as exc:
212             raise OSError(__('Include file %r not found or reading it failed') %
213                           filename) from exc
214         except UnicodeError as exc:
215             raise UnicodeError(__('Encoding %r used for reading included file %r seems to '
216                                   'be wrong, try giving an :encoding: option') %
217                                (self.encoding, filename)) from exc
218 
219     def read(self, location: Tuple[str, int] = None) -> Tuple[str, int]:
220         if 'diff' in self.options:
221             lines = self.show_diff()
222         else:
223             filters = [self.pyobject_filter,
224                        self.start_filter,
225                        self.end_filter,
226                        self.lines_filter,
227                        self.prepend_filter,
228                        self.append_filter,
229                        self.dedent_filter]
230             lines = self.read_file(self.filename, location=location)
231             for func in filters:
232                 lines = func(lines, location=location)
233 
234         return ''.join(lines), len(lines)
235 
236     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:
237         new_lines = self.read_file(self.filename)
238         old_filename = self.options.get('diff')
239         old_lines = self.read_file(old_filename)
240         diff = unified_diff(old_lines, new_lines, old_filename, self.filename)
241         return list(diff)
242 
243     def pyobject_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
244         pyobject = self.options.get('pyobject')
245         if pyobject:
246             from sphinx.pycode import ModuleAnalyzer
247             analyzer = ModuleAnalyzer.for_file(self.filename, '')
248             tags = analyzer.find_tags()
249             if pyobject not in tags:
250                 raise ValueError(__('Object named %r not found in include file %r') %
251                                  (pyobject, self.filename))
252             else:
253                 start = tags[pyobject][1]
254                 end = tags[pyobject][2]
255                 lines = lines[start - 1:end]
256                 if 'lineno-match' in self.options:
257                     self.lineno_start = start
258 
259         return lines
260 
261     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
262         linespec = self.options.get('lines')
263         if linespec:
264             linelist = parselinenos(linespec, len(lines))
265             if any(i >= len(lines) for i in linelist):
266                 logger.warning(__('line number spec is out of range(1-%d): %r') %
267                                (len(lines), linespec), location=location)
268 
269             if 'lineno-match' in self.options:
270                 # make sure the line list is not "disjoint".
271                 first = linelist[0]
272                 if all(first + i == n for i, n in enumerate(linelist)):
273                     self.lineno_start += linelist[0]
274                 else:
275                     raise ValueError(__('Cannot use "lineno-match" with a disjoint '
276                                         'set of "lines"'))
277 
278             lines = [lines[n] for n in linelist if n < len(lines)]
279             if lines == []:
280                 raise ValueError(__('Line spec %r: no lines pulled from include file %r') %
281                                  (linespec, self.filename))
282 
283         return lines
284 
285     def start_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
286         if 'start-at' in self.options:
287             start = self.options.get('start-at')
288             inclusive = False
289         elif 'start-after' in self.options:
290             start = self.options.get('start-after')
291             inclusive = True
292         else:
293             start = None
294 
295         if start:
296             for lineno, line in enumerate(lines):
297                 if start in line:
298                     if inclusive:
299                         if 'lineno-match' in self.options:
300                             self.lineno_start += lineno + 1
301 
302                         return lines[lineno + 1:]
303                     else:
304                         if 'lineno-match' in self.options:
305                             self.lineno_start += lineno
306 
307                         return lines[lineno:]
308 
309             if inclusive is True:
310                 raise ValueError('start-after pattern not found: %s' % start)
311             else:
312                 raise ValueError('start-at pattern not found: %s' % start)
313 
314         return lines
315 
316     def end_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
317         if 'end-at' in self.options:
318             end = self.options.get('end-at')
319             inclusive = True
320         elif 'end-before' in self.options:
321             end = self.options.get('end-before')
322             inclusive = False
323         else:
324             end = None
325 
326         if end:
327             for lineno, line in enumerate(lines):
328                 if end in line:
329                     if inclusive:
330                         return lines[:lineno + 1]
331                     else:
332                         if lineno == 0:
333                             pass  # end-before ignores first line
334                         else:
335                             return lines[:lineno]
336             if inclusive is True:
337                 raise ValueError('end-at pattern not found: %s' % end)
338             else:
339                 raise ValueError('end-before pattern not found: %s' % end)
340 
341         return lines
342 
343     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
344         prepend = self.options.get('prepend')
345         if prepend:
346             lines.insert(0, prepend + '\n')
347 
348         return lines
349 
350     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
351         append = self.options.get('append')
352         if append:
353             lines.append(append + '\n')
354 
355         return lines
356 
357     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:
358         if 'dedent' in self.options:
359             return dedent_lines(lines, self.options.get('dedent'), location=location)
360         else:
361             return lines
362 
363 
364 class LiteralInclude(SphinxDirective):
365     """
366     Like ``.. include:: :literal:``, but only warns if the include file is
367     not found, and does not raise errors.  Also has several options for
368     selecting what to include.
369     """
370 
371     has_content = False
372     required_arguments = 1
373     optional_arguments = 0
374     final_argument_whitespace = True
375     option_spec: OptionSpec = {
376         'dedent': optional_int,
377         'linenos': directives.flag,
378         'lineno-start': int,
379         'lineno-match': directives.flag,
380         'tab-width': int,
381         'language': directives.unchanged_required,
382         'force': directives.flag,
383         'encoding': directives.encoding,
384         'pyobject': directives.unchanged_required,
385         'lines': directives.unchanged_required,
386         'start-after': directives.unchanged_required,
387         'end-before': directives.unchanged_required,
388         'start-at': directives.unchanged_required,
389         'end-at': directives.unchanged_required,
390         'prepend': directives.unchanged_required,
391         'append': directives.unchanged_required,
392         'emphasize-lines': directives.unchanged_required,
393         'caption': directives.unchanged,
394         'class': directives.class_option,
395         'name': directives.unchanged,
396         'diff': directives.unchanged_required,
397     }
398 
399     def run(self) -> List[Node]:
400         document = self.state.document
401         if not document.settings.file_insertion_enabled:
402             return [document.reporter.warning('File insertion disabled',
403                                               line=self.lineno)]
404         # convert options['diff'] to absolute path
405         if 'diff' in self.options:
406             _, path = self.env.relfn2path(self.options['diff'])
407             self.options['diff'] = path
408 
409         try:
410             location = self.state_machine.get_source_and_line(self.lineno)
411             rel_filename, filename = self.env.relfn2path(self.arguments[0])
412             self.env.note_dependency(rel_filename)
413 
414             reader = LiteralIncludeReader(filename, self.options, self.config)
415             text, lines = reader.read(location=location)
416 
417             retnode: Element = nodes.literal_block(text, text, source=filename)
418             retnode['force'] = 'force' in self.options
419             self.set_source_info(retnode)
420             if self.options.get('diff'):  # if diff is set, set udiff
421                 retnode['language'] = 'udiff'
422             elif 'language' in self.options:
423                 retnode['language'] = self.options['language']
424             if ('linenos' in self.options or 'lineno-start' in self.options or
425                     'lineno-match' in self.options):
426                 retnode['linenos'] = True
427             retnode['classes'] += self.options.get('class', [])
428             extra_args = retnode['highlight_args'] = {}
429             if 'emphasize-lines' in self.options:
430                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)
431                 if any(i >= lines for i in hl_lines):
432                     logger.warning(__('line number spec is out of range(1-%d): %r') %
433                                    (lines, self.options['emphasize-lines']),
434                                    location=location)
435                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]
436             extra_args['linenostart'] = reader.lineno_start
437 
438             if 'caption' in self.options:
439                 caption = self.options['caption'] or self.arguments[0]
440                 retnode = container_wrapper(self, retnode, caption)
441 
442             # retnode will be note_implicit_target that is linked from caption and numref.
443             # when options['name'] is provided, it should be primary ID.
444             self.add_name(retnode)
445 
446             return [retnode]
447         except Exception as exc:
448             return [document.reporter.warning(exc, line=self.lineno)]
449 
450 
451 def setup(app: "Sphinx") -> Dict[str, Any]:
452     directives.register_directive('highlight', Highlight)
453     directives.register_directive('code-block', CodeBlock)
454     directives.register_directive('sourcecode', CodeBlock)
455     directives.register_directive('literalinclude', LiteralInclude)
456 
457     return {
458         'version': 'builtin',
459         'parallel_read_safe': True,
460         'parallel_write_safe': True,
461     }

</code><intended_behavior>The logic for `:dedent:` option processing needs to be refined to ensure it does not apply to `prepend` or `append` content. The dedentation should strictly affect the content being included via the `literalinclude` directive and not the manually specified `prepend` or `append` strings. Implementing a conditional application of `dedent` or modifying how dedentation is calculated can achieve this. This ensures that users have control over the indentation of the content they are adding explicitly, separate from the automated adjustment of the included content's indentation level.</intended_behavior>]
2025-10-15 11:26:00.553 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 11:26:00.553 | INFO     | Search-only: skipping patch selection
2025-10-15 11:26:00.671 | INFO     | Task sphinx-doc__sphinx-10323 completed successfully.
2025-10-15 11:26:00.672 | INFO     | No patch generated. You can try running ACR again.
