[
    {
        "rel_file_path": "sphinx/builders/gettext.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/builders/gettext.py",
        "start": 1,
        "end": 331,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.builders.gettext\n3     ~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     The MessageCatalogBuilder class.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from codecs import open\n12 from collections import defaultdict, OrderedDict\n13 from datetime import datetime, tzinfo, timedelta\n14 from os import path, walk, getenv\n15 from time import time\n16 from typing import Any, Dict, Iterable, Generator, List, Set, Tuple, Union\n17 from uuid import uuid4\n18 \n19 from docutils import nodes\n20 from docutils.nodes import Element\n21 \n22 from sphinx import addnodes\n23 from sphinx import package_dir\n24 from sphinx.application import Sphinx\n25 from sphinx.builders import Builder\n26 from sphinx.domains.python import pairindextypes\n27 from sphinx.errors import ThemeError\n28 from sphinx.locale import __\n29 from sphinx.util import split_index_msg, logging, status_iterator\n30 from sphinx.util.console import bold  # type: ignore\n31 from sphinx.util.i18n import CatalogInfo, docname_to_domain\n32 from sphinx.util.nodes import extract_messages, traverse_translatable_index\n33 from sphinx.util.osutil import ensuredir, canon_path, relpath\n34 from sphinx.util.tags import Tags\n35 from sphinx.util.template import SphinxRenderer\n36 \n37 if False:\n38     # For type annotation\n39     from typing import DefaultDict  # for python3.5.1\n40 \n41 logger = logging.getLogger(__name__)\n42 \n43 POHEADER = r\"\"\"\n44 # SOME DESCRIPTIVE TITLE.\n45 # Copyright (C) %(copyright)s\n46 # This file is distributed under the same license as the %(project)s package.\n47 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n48 #\n49 #, fuzzy\n50 msgid \"\"\n51 msgstr \"\"\n52 \"Project-Id-Version: %(project)s %(version)s\\n\"\n53 \"Report-Msgid-Bugs-To: \\n\"\n54 \"POT-Creation-Date: %(ctime)s\\n\"\n55 \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n56 \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n57 \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n58 \"MIME-Version: 1.0\\n\"\n59 \"Content-Type: text/plain; charset=UTF-8\\n\"\n60 \"Content-Transfer-Encoding: 8bit\\n\"\n61 \n62 \"\"\"[1:]  # RemovedInSphinx40Warning\n63 \n64 \n65 class Message:\n66     \"\"\"An entry of translatable message.\"\"\"\n67     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n68         self.text = text\n69         self.locations = locations\n70         self.uuids = uuids\n71 \n72 \n73 class Catalog:\n74     \"\"\"Catalog of translatable messages.\"\"\"\n75 \n76     def __init__(self) -> None:\n77         self.messages = []  # type: List[str]\n78                             # retain insertion order, a la OrderedDict\n79         self.metadata = OrderedDict()   # type: Dict[str, List[Tuple[str, int, str]]]\n80                                         # msgid -> file, line, uid\n81 \n82     def add(self, msg: str, origin: Union[Element, \"MsgOrigin\"]) -> None:\n83         if not hasattr(origin, 'uid'):\n84             # Nodes that are replicated like todo don't have a uid,\n85             # however i18n is also unnecessary.\n86             return\n87         if msg not in self.metadata:  # faster lookup in hash\n88             self.messages.append(msg)\n89             self.metadata[msg] = []\n90         self.metadata[msg].append((origin.source, origin.line, origin.uid))  # type: ignore\n91 \n92     def __iter__(self) -> Generator[Message, None, None]:\n93         for message in self.messages:\n94             positions = [(source, line) for source, line, uuid in self.metadata[message]]\n95             uuids = [uuid for source, line, uuid in self.metadata[message]]\n96             yield Message(message, positions, uuids)\n97 \n98 \n99 class MsgOrigin:\n100     \"\"\"\n101     Origin holder for Catalog message origin.\n102     \"\"\"\n103 \n104     def __init__(self, source: str, line: int) -> None:\n105         self.source = source\n106         self.line = line\n107         self.uid = uuid4().hex\n108 \n109 \n110 class GettextRenderer(SphinxRenderer):\n111     def __init__(self, template_path: str = None, outdir: str = None) -> None:\n112         self.outdir = outdir\n113         if template_path is None:\n114             template_path = path.join(package_dir, 'templates', 'gettext')\n115         super().__init__(template_path)\n116 \n117         def escape(s: str) -> str:\n118             s = s.replace('\\\\', r'\\\\')\n119             s = s.replace('\"', r'\\\"')\n120             return s.replace('\\n', '\\\\n\"\\n\"')\n121 \n122         # use texescape as escape filter\n123         self.env.filters['e'] = escape\n124         self.env.filters['escape'] = escape\n125 \n126     def render(self, filename: str, context: Dict) -> str:\n127         def _relpath(s: str) -> str:\n128             return canon_path(relpath(s, self.outdir))\n129 \n130         context['relpath'] = _relpath\n131         return super().render(filename, context)\n132 \n133 \n134 class I18nTags(Tags):\n135     \"\"\"Dummy tags module for I18nBuilder.\n136 \n137     To translate all text inside of only nodes, this class\n138     always returns True value even if no tags are defined.\n139     \"\"\"\n140     def eval_condition(self, condition: Any) -> bool:\n141         return True\n142 \n143 \n144 class I18nBuilder(Builder):\n145     \"\"\"\n146     General i18n builder.\n147     \"\"\"\n148     name = 'i18n'\n149     versioning_method = 'text'\n150     versioning_compare = None   # type: bool\n151                                 # be set by `gettext_uuid`\n152     use_message_catalog = False\n153 \n154     def init(self) -> None:\n155         super().init()\n156         self.env.set_versioning_method(self.versioning_method,\n157                                        self.env.config.gettext_uuid)\n158         self.tags = I18nTags()\n159         self.catalogs = defaultdict(Catalog)  # type: DefaultDict[str, Catalog]\n160 \n161     def get_target_uri(self, docname: str, typ: str = None) -> str:\n162         return ''\n163 \n164     def get_outdated_docs(self) -> Set[str]:\n165         return self.env.found_docs\n166 \n167     def prepare_writing(self, docnames: Set[str]) -> None:\n168         return\n169 \n170     def compile_catalogs(self, catalogs: Set[CatalogInfo], message: str) -> None:\n171         return\n172 \n173     def write_doc(self, docname: str, doctree: nodes.document) -> None:\n174         catalog = self.catalogs[docname_to_domain(docname, self.config.gettext_compact)]\n175 \n176         for toctree in self.env.tocs[docname].traverse(addnodes.toctree):\n177             for node, msg in extract_messages(toctree):\n178                 node.uid = ''  # type: ignore  # Hack UUID model\n179                 catalog.add(msg, node)\n180 \n181         for node, msg in extract_messages(doctree):\n182             catalog.add(msg, node)\n183 \n184         if 'index' in self.env.config.gettext_additional_targets:\n185             # Extract translatable messages from index entries.\n186             for node, entries in traverse_translatable_index(doctree):\n187                 for typ, msg, tid, main, key_ in entries:\n188                     for m in split_index_msg(typ, msg):\n189                         if typ == 'pair' and m in pairindextypes.values():\n190                             # avoid built-in translated message was incorporated\n191                             # in 'sphinx.util.nodes.process_index_entry'\n192                             continue\n193                         catalog.add(m, node)\n194 \n195 \n196 # determine tzoffset once to remain unaffected by DST change during build\n197 timestamp = time()\n198 tzdelta = datetime.fromtimestamp(timestamp) - \\\n199     datetime.utcfromtimestamp(timestamp)\n200 # set timestamp from SOURCE_DATE_EPOCH if set\n201 # see https://reproducible-builds.org/specs/source-date-epoch/\n202 source_date_epoch = getenv('SOURCE_DATE_EPOCH')\n203 if source_date_epoch is not None:\n204     timestamp = float(source_date_epoch)\n205     tzdelta = timedelta(0)\n206 \n207 \n208 class LocalTimeZone(tzinfo):\n209     def __init__(self, *args: Any, **kwargs: Any) -> None:\n210         super().__init__(*args, **kwargs)  # type: ignore\n211         self.tzdelta = tzdelta\n212 \n213     def utcoffset(self, dt: datetime) -> timedelta:\n214         return self.tzdelta\n215 \n216     def dst(self, dt: datetime) -> timedelta:\n217         return timedelta(0)\n218 \n219 \n220 ltz = LocalTimeZone()\n221 \n222 \n223 def should_write(filepath: str, new_content: str) -> bool:\n224     if not path.exists(filepath):\n225         return True\n226     try:\n227         with open(filepath, encoding='utf-8') as oldpot:\n228             old_content = oldpot.read()\n229             old_header_index = old_content.index('\"POT-Creation-Date:')\n230             new_header_index = new_content.index('\"POT-Creation-Date:')\n231             old_body_index = old_content.index('\"PO-Revision-Date:')\n232             new_body_index = new_content.index('\"PO-Revision-Date:')\n233             return ((old_content[:old_header_index] != new_content[:new_header_index]) or\n234                     (new_content[new_body_index:] != old_content[old_body_index:]))\n235     except ValueError:\n236         pass\n237 \n238     return True\n239 \n240 \n241 class MessageCatalogBuilder(I18nBuilder):\n242     \"\"\"\n243     Builds gettext-style message catalogs (.pot files).\n244     \"\"\"\n245     name = 'gettext'\n246     epilog = __('The message catalogs are in %(outdir)s.')\n247 \n248     def init(self) -> None:\n249         super().init()\n250         self.create_template_bridge()\n251         self.templates.init(self)\n252 \n253     def _collect_templates(self) -> Set[str]:\n254         template_files = set()\n255         for template_path in self.config.templates_path:\n256             tmpl_abs_path = path.join(self.app.srcdir, template_path)\n257             for dirpath, dirs, files in walk(tmpl_abs_path):\n258                 for fn in files:\n259                     if fn.endswith('.html'):\n260                         filename = canon_path(path.join(dirpath, fn))\n261                         template_files.add(filename)\n262         return template_files\n263 \n264     def _extract_from_template(self) -> None:\n265         files = list(self._collect_templates())\n266         files.sort()\n267         logger.info(bold(__('building [%s]: ') % self.name), nonl=True)\n268         logger.info(__('targets for %d template files'), len(files))\n269 \n270         extract_translations = self.templates.environment.extract_translations\n271 \n272         for template in status_iterator(files, __('reading templates... '), \"purple\",\n273                                         len(files), self.app.verbosity):\n274             try:\n275                 with open(template, encoding='utf-8') as f:\n276                     context = f.read()\n277                 for line, meth, msg in extract_translations(context):\n278                     origin = MsgOrigin(template, line)\n279                     self.catalogs['sphinx'].add(msg, origin)\n280             except Exception as exc:\n281                 raise ThemeError('%s: %r' % (template, exc)) from exc\n282 \n283     def build(self, docnames: Iterable[str], summary: str = None, method: str = 'update') -> None:  # NOQA\n284         self._extract_from_template()\n285         super().build(docnames, summary, method)\n286 \n287     def finish(self) -> None:\n288         super().finish()\n289         context = {\n290             'version': self.config.version,\n291             'copyright': self.config.copyright,\n292             'project': self.config.project,\n293             'last_translator': self.config.gettext_last_translator,\n294             'language_team': self.config.gettext_language_team,\n295             'ctime': datetime.fromtimestamp(timestamp, ltz).strftime('%Y-%m-%d %H:%M%z'),\n296             'display_location': self.config.gettext_location,\n297             'display_uuid': self.config.gettext_uuid,\n298         }\n299         for textdomain, catalog in status_iterator(self.catalogs.items(),\n300                                                    __(\"writing message catalogs... \"),\n301                                                    \"darkgreen\", len(self.catalogs),\n302                                                    self.app.verbosity,\n303                                                    lambda textdomain__: textdomain__[0]):\n304             # noop if config.gettext_compact is set\n305             ensuredir(path.join(self.outdir, path.dirname(textdomain)))\n306 \n307             context['messages'] = list(catalog)\n308             content = GettextRenderer(outdir=self.outdir).render('message.pot_t', context)\n309 \n310             pofn = path.join(self.outdir, textdomain + '.pot')\n311             if should_write(pofn, content):\n312                 with open(pofn, 'w', encoding='utf-8') as pofile:\n313                     pofile.write(content)\n314 \n315 \n316 def setup(app: Sphinx) -> Dict[str, Any]:\n317     app.add_builder(MessageCatalogBuilder)\n318 \n319     app.add_config_value('gettext_compact', True, 'gettext')\n320     app.add_config_value('gettext_location', True, 'gettext')\n321     app.add_config_value('gettext_uuid', False, 'gettext')\n322     app.add_config_value('gettext_auto_build', True, 'env')\n323     app.add_config_value('gettext_additional_targets', [], 'env')\n324     app.add_config_value('gettext_last_translator', 'FULL NAME <EMAIL@ADDRESS>', 'gettext')\n325     app.add_config_value('gettext_language_team', 'LANGUAGE <LL@li.org>', 'gettext')\n326 \n327     return {\n328         'version': 'builtin',\n329         'parallel_read_safe': True,\n330         'parallel_write_safe': True,\n331     }\n",
        "intended_behavior": "The code at this location must be enhanced to allow the `gettext_compact` option not just to influence the granularity of compaction but also to enable a mode where all generated message catalogs can be merged into a single file. This single file would then be used for upload or further processing in a more streamlined manner. This enhancement would cater to uses cases like that of the OKFN people, who currently have to manually perform this step as per their `Makefile`. The intended behavior should preserve the existing functionality of the `gettext_compact` option. Introduce an additional value for `gettext_compact` or a separate configuration option that, when set, triggers the compacting of all message catalogs into a single file."
    }
]