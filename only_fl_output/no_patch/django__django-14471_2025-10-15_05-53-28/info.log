2025-10-15 05:53:28.358 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:53:32.526 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=544, output_tokens=12, cost=0.005800
2025-10-15 05:53:32.527 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 05:53:32.530 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:53:40.543 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=849, output_tokens=307, cost=0.017700
2025-10-15 05:53:40.587 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:53:44.572 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=661, output_tokens=102, cost=0.009670
2025-10-15 05:53:44.573 | DEBUG    | Extracted a valid json.
2025-10-15 05:53:44.573 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"CsrfViewMiddleware\")",
        "search_method_in_class(\"_get_token\", \"CsrfViewMiddleware\")",
        "search_method_in_class(\"process_view\", \"CsrfViewMiddleware\")",
        "search_method_in_class(\"process_request\", \"CsrfViewMiddleware\")",
        "search_method(\"InvalidTokenFormat\")",
        "search_method(\"_get_new_csrf_token\")"
    ],
    "bug_locations": []
}
2025-10-15 05:53:44.620 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:53:44.621 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:54:03.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3071, output_tokens=837, cost=0.055820
2025-10-15 05:54:03.322 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:54:12.836 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4124, output_tokens=391, cost=0.052970
2025-10-15 05:54:12.845 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:54:21.932 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=745, output_tokens=398, cost=0.019390
2025-10-15 05:54:21.933 | DEBUG    | Extracted a valid json.
2025-10-15 05:54:21.933 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "_get_token",
            "intended_behavior": "To resolve the issue, inside the `_get_token` method, when an `InvalidTokenFormat` exception is encountered, instead of generating a new CSRF token immediately, the method should allow this exception to propagate upwards. This change will avoid unnecessary generation of a new CSRF token that would be wasted effort since the request is going to be rejected due to the invalid format of the CSRF cookie. This behavior would be more efficient and aligns with the suggestion to let `InvalidTokenFormat` bubble up so it can be handled more appropriately, especially in contexts where an early rejection of the request is feasible and preferred. By avoiding the preemptive creation of a new token, the middleware will not only perform fewer operations but also make the flow of logic simpler and clearer. Thus, preserving the efficiency and clarity of CSRF token handling in requests."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "CsrfViewMiddleware",
            "method": "process_view",
            "intended_behavior": "The intended behavior in the `process_view` method is to adjust its handling of CSRF tokens with the wrong format by incorporating an early rejection of such requests. Following the adjustment in `_get_token` to allow `InvalidTokenFormat` to propagate, `process_view` should catch this exception and reject the request immediately using the available rejection methods, using the reason provided by the exception. This direct rejection in `process_view` will address the reported issue effectively by preventing unnecessary processing for requests that are inevitably going to fail CSRF validation. It makes the CSRF protection more efficient by cutting down on redundant operations and helps in clearly indicating the nature of the failure to the developers or system administrators."
        }
    ]
}
2025-10-15 05:54:21.942 | DEBUG    | Bug location extracted successfully: [<file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>_get_token</method>
<code>
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token

</code><intended_behavior>To resolve the issue, inside the `_get_token` method, when an `InvalidTokenFormat` exception is encountered, instead of generating a new CSRF token immediately, the method should allow this exception to propagate upwards. This change will avoid unnecessary generation of a new CSRF token that would be wasted effort since the request is going to be rejected due to the invalid format of the CSRF cookie. This behavior would be more efficient and aligns with the suggestion to let `InvalidTokenFormat` bubble up so it can be handled more appropriately, especially in contexts where an early rejection of the request is feasible and preferred. By avoiding the preemptive creation of a new token, the middleware will not only perform fewer operations but also make the flow of logic simpler and clearer. Thus, preserving the efficiency and clarity of CSRF token handling in requests.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>process_view</method>
<code>
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)

</code><intended_behavior>The intended behavior in the `process_view` method is to adjust its handling of CSRF tokens with the wrong format by incorporating an early rejection of such requests. Following the adjustment in `_get_token` to allow `InvalidTokenFormat` to propagate, `process_view` should catch this exception and reject the request immediately using the available rejection methods, using the reason provided by the exception. This direct rejection in `process_view` will address the reported issue effectively by preventing unnecessary processing for requests that are inevitably going to fail CSRF validation. It makes the CSRF protection more efficient by cutting down on redundant operations and helps in clearly indicating the nature of the failure to the developers or system administrators.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 05:54:21.942 | INFO     | Search completed. Bug locations: [<file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>_get_token</method>
<code>
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token

</code><intended_behavior>To resolve the issue, inside the `_get_token` method, when an `InvalidTokenFormat` exception is encountered, instead of generating a new CSRF token immediately, the method should allow this exception to propagate upwards. This change will avoid unnecessary generation of a new CSRF token that would be wasted effort since the request is going to be rejected due to the invalid format of the CSRF cookie. This behavior would be more efficient and aligns with the suggestion to let `InvalidTokenFormat` bubble up so it can be handled more appropriately, especially in contexts where an early rejection of the request is feasible and preferred. By avoiding the preemptive creation of a new token, the middleware will not only perform fewer operations but also make the flow of logic simpler and clearer. Thus, preserving the efficiency and clarity of CSRF token handling in requests.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>process_view</method>
<code>
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)

</code><intended_behavior>The intended behavior in the `process_view` method is to adjust its handling of CSRF tokens with the wrong format by incorporating an early rejection of such requests. Following the adjustment in `_get_token` to allow `InvalidTokenFormat` to propagate, `process_view` should catch this exception and reject the request immediately using the available rejection methods, using the reason provided by the exception. This direct rejection in `process_view` will address the reported issue effectively by preventing unnecessary processing for requests that are inevitably going to fail CSRF validation. It makes the CSRF protection more efficient by cutting down on redundant operations and helps in clearly indicating the nature of the failure to the developers or system administrators.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>CsrfViewMiddleware</class>
<method>None</method>
<code>
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             try:
221                 csrf_token = _sanitize_token(cookie_token)
222             except InvalidTokenFormat:
223                 csrf_token = _get_new_csrf_token()
224 
225             if csrf_token != cookie_token:
226                 # Cookie token needed to be replaced;
227                 # the cookie needs to be reset.
228                 request.csrf_cookie_needs_reset = True
229             return csrf_token
230 
231     def _set_token(self, request, response):
232         if settings.CSRF_USE_SESSIONS:
233             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
234                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
235         else:
236             response.set_cookie(
237                 settings.CSRF_COOKIE_NAME,
238                 request.META['CSRF_COOKIE'],
239                 max_age=settings.CSRF_COOKIE_AGE,
240                 domain=settings.CSRF_COOKIE_DOMAIN,
241                 path=settings.CSRF_COOKIE_PATH,
242                 secure=settings.CSRF_COOKIE_SECURE,
243                 httponly=settings.CSRF_COOKIE_HTTPONLY,
244                 samesite=settings.CSRF_COOKIE_SAMESITE,
245             )
246             # Set the Vary header since content varies with the CSRF cookie.
247             patch_vary_headers(response, ('Cookie',))
248 
249     def _origin_verified(self, request):
250         request_origin = request.META['HTTP_ORIGIN']
251         try:
252             good_host = request.get_host()
253         except DisallowedHost:
254             pass
255         else:
256             good_origin = '%s://%s' % (
257                 'https' if request.is_secure() else 'http',
258                 good_host,
259             )
260             if request_origin == good_origin:
261                 return True
262         if request_origin in self.allowed_origins_exact:
263             return True
264         try:
265             parsed_origin = urlparse(request_origin)
266         except ValueError:
267             return False
268         request_scheme = parsed_origin.scheme
269         request_netloc = parsed_origin.netloc
270         return any(
271             is_same_domain(request_netloc, host)
272             for host in self.allowed_origin_subdomains.get(request_scheme, ())
273         )
274 
275     def _check_referer(self, request):
276         referer = request.META.get('HTTP_REFERER')
277         if referer is None:
278             raise RejectRequest(REASON_NO_REFERER)
279 
280         try:
281             referer = urlparse(referer)
282         except ValueError:
283             raise RejectRequest(REASON_MALFORMED_REFERER)
284 
285         # Make sure we have a valid URL for Referer.
286         if '' in (referer.scheme, referer.netloc):
287             raise RejectRequest(REASON_MALFORMED_REFERER)
288 
289         # Ensure that our Referer is also secure.
290         if referer.scheme != 'https':
291             raise RejectRequest(REASON_INSECURE_REFERER)
292 
293         if any(
294             is_same_domain(referer.netloc, host)
295             for host in self.csrf_trusted_origins_hosts
296         ):
297             return
298         # Allow matching the configured cookie domain.
299         good_referer = (
300             settings.SESSION_COOKIE_DOMAIN
301             if settings.CSRF_USE_SESSIONS
302             else settings.CSRF_COOKIE_DOMAIN
303         )
304         if good_referer is None:
305             # If no cookie domain is configured, allow matching the current
306             # host:port exactly if it's permitted by ALLOWED_HOSTS.
307             try:
308                 # request.get_host() includes the port.
309                 good_referer = request.get_host()
310             except DisallowedHost:
311                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
312         else:
313             server_port = request.get_port()
314             if server_port not in ('443', '80'):
315                 good_referer = '%s:%s' % (good_referer, server_port)
316 
317         if not is_same_domain(referer.netloc, good_referer):
318             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
319 
320     def process_request(self, request):
321         csrf_token = self._get_token(request)
322         if csrf_token is not None:
323             # Use same token next time.
324             request.META['CSRF_COOKIE'] = csrf_token
325 
326     def process_view(self, request, callback, callback_args, callback_kwargs):
327         if getattr(request, 'csrf_processing_done', False):
328             return None
329 
330         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
331         # bailing out, so that get_token still works
332         if getattr(callback, 'csrf_exempt', False):
333             return None
334 
335         # Assume that anything not defined as 'safe' by RFC7231 needs protection
336         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
337             return self._accept(request)
338 
339         if getattr(request, '_dont_enforce_csrf_checks', False):
340             # Mechanism to turn off CSRF checks for test suite. It comes after
341             # the creation of CSRF cookies, so that everything else continues
342             # to work exactly the same (e.g. cookies are sent, etc.), but
343             # before any branches that call reject().
344             return self._accept(request)
345 
346         # Reject the request if the Origin header doesn't match an allowed
347         # value.
348         if 'HTTP_ORIGIN' in request.META:
349             if not self._origin_verified(request):
350                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
351         elif request.is_secure():
352             # If the Origin header wasn't provided, reject HTTPS requests if
353             # the Referer header doesn't match an allowed value.
354             #
355             # Suppose user visits http://example.com/
356             # An active network attacker (man-in-the-middle, MITM) sends a
357             # POST form that targets https://example.com/detonate-bomb/ and
358             # submits it via JavaScript.
359             #
360             # The attacker will need to provide a CSRF cookie and token, but
361             # that's no problem for a MITM and the session-independent secret
362             # we're using. So the MITM can circumvent the CSRF protection. This
363             # is true for any HTTP connection, but anyone using HTTPS expects
364             # better! For this reason, for https://example.com/ we need
365             # additional protection that treats http://example.com/ as
366             # completely untrusted. Under HTTPS, Barth et al. found that the
367             # Referer header is missing for same-domain requests in only about
368             # 0.2% of cases or less, so we can use strict Referer checking.
369             try:
370                 self._check_referer(request)
371             except RejectRequest as exc:
372                 return self._reject(request, exc.reason)
373 
374         # Access csrf_token via self._get_token() as rotate_token() may have
375         # been called by an authentication middleware during the
376         # process_request() phase.
377         csrf_token = self._get_token(request)
378         if csrf_token is None:
379             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
380             # and in this way we can avoid all CSRF attacks, including login
381             # CSRF.
382             return self._reject(request, REASON_NO_CSRF_COOKIE)
383 
384         # Check non-cookie token for match.
385         request_csrf_token = ''
386         if request.method == 'POST':
387             try:
388                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
389             except OSError:
390                 # Handle a broken connection before we've completed reading the
391                 # POST data. process_view shouldn't raise any exceptions, so
392                 # we'll ignore and serve the user a 403 (assuming they're still
393                 # listening, which they probably aren't because of the error).
394                 pass
395 
396         if request_csrf_token == '':
397             # Fall back to X-CSRFToken, to make things easier for AJAX, and
398             # possible for PUT/DELETE.
399             try:
400                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
401             except KeyError:
402                 return self._reject(request, REASON_CSRF_TOKEN_MISSING)
403 
404         try:
405             request_csrf_token = _sanitize_token(request_csrf_token)
406         except InvalidTokenFormat as exc:
407             return self._reject(request, f'CSRF token {exc.reason}.')
408 
409         if not _compare_masked_tokens(request_csrf_token, csrf_token):
410             return self._reject(request, REASON_CSRF_TOKEN_INCORRECT)
411 
412         return self._accept(request)
413 
414     def process_response(self, request, response):
415         if not getattr(request, 'csrf_cookie_needs_reset', False):
416             if getattr(response, 'csrf_cookie_set', False):
417                 return response
418 
419         if not request.META.get("CSRF_COOKIE_USED", False):
420             return response
421 
422         # Set the CSRF cookie even if it's already set, so we renew
423         # the expiry timer.
424         self._set_token(request, response)
425         response.csrf_cookie_set = True
426         return response

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 05:54:21.943 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:54:21.943 | INFO     | Search-only: skipping patch selection
2025-10-15 05:54:22.083 | INFO     | Task django__django-14471 completed successfully.
2025-10-15 05:54:22.084 | INFO     | No patch generated. You can try running ACR again.
