2025-10-15 03:00:24.669 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 03:00:28.171 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=194, output_tokens=12, cost=0.002300
2025-10-15 03:00:28.172 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 03:00:28.176 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:00:36.161 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=503, output_tokens=286, cost=0.013610
2025-10-15 03:00:36.168 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:00:39.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=640, output_tokens=63, cost=0.008290
2025-10-15 03:00:39.312 | DEBUG    | Extracted a valid json.
2025-10-15 03:00:39.312 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"log_change\")",
        "search_method(\"save_history\")",
        "search_method(\"log_history\")",
        "search_code(\"get_verbose_name\")",
        "search_code(\"Changed pub_date\")"
    ],
    "bug_locations": []
}
2025-10-15 03:00:39.374 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 03:00:39.374 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 03:00:52.500 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1323, output_tokens=535, cost=0.029280
2025-10-15 03:00:52.510 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:01:01.326 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2074, output_tokens=333, cost=0.030730
2025-10-15 03:01:01.333 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:01:04.803 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=687, output_tokens=104, cost=0.009990
2025-10-15 03:01:04.804 | DEBUG    | Extracted a valid json.
2025-10-15 03:01:04.804 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "log_change",
            "intended_behavior": "The method log_change should ideally format the message parameter to include verbose field names instead of raw field identifiers. This might entail creating a utility function within options.py or a related admin module that fetches verbose names and applies them to the change messages."
        }
    ]
}
2025-10-15 03:01:04.817 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>log_change</method>
<code>
812     def log_change(self, request, object, message):
813         """
814         Log that an object has been successfully changed.
815 
816         The default implementation creates an admin LogEntry object.
817         """
818         from django.contrib.admin.models import LogEntry, CHANGE
819         return LogEntry.objects.log_action(
820             user_id=request.user.pk,
821             content_type_id=get_content_type_for_model(object).pk,
822             object_id=object.pk,
823             object_repr=str(object),
824             action_flag=CHANGE,
825             change_message=message,
826         )

</code><intended_behavior>The method log_change should ideally format the message parameter to include verbose field names instead of raw field identifiers. This might entail creating a utility function within options.py or a related admin module that fetches verbose names and applies them to the change messages.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
542 class ModelAdmin(BaseModelAdmin):
543     """Encapsulate all admin options and functionality for a given model."""
544 
545     list_display = ('__str__',)
546     list_display_links = ()
547     list_filter = ()
548     list_select_related = False
549     list_per_page = 100
550     list_max_show_all = 200
551     list_editable = ()
552     search_fields = ()
553     date_hierarchy = None
554     save_as = False
555     save_as_continue = True
556     save_on_top = False
557     paginator = Paginator
558     preserve_filters = True
559     inlines = []
560 
561     # Custom templates (designed to be over-ridden in subclasses)
562     add_form_template = None
563     change_form_template = None
564     change_list_template = None
565     delete_confirmation_template = None
566     delete_selected_confirmation_template = None
567     object_history_template = None
568     popup_response_template = None
569 
570     # Actions
571     actions = []
572     action_form = helpers.ActionForm
573     actions_on_top = True
574     actions_on_bottom = False
575     actions_selection_counter = True
576     checks_class = ModelAdminChecks
577 
578     def __init__(self, model, admin_site):
579         self.model = model
580         self.opts = model._meta
581         self.admin_site = admin_site
582         super().__init__()
583 
584     def __str__(self):
585         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
586 
587     def get_inline_instances(self, request, obj=None):
588         inline_instances = []
589         for inline_class in self.get_inlines(request, obj):
590             inline = inline_class(self.model, self.admin_site)
591             if request:
592                 if not (inline.has_view_or_change_permission(request, obj) or
593                         inline.has_add_permission(request, obj) or
594                         inline.has_delete_permission(request, obj)):
595                     continue
596                 if not inline.has_add_permission(request, obj):
597                     inline.max_num = 0
598             inline_instances.append(inline)
599 
600         return inline_instances
601 
602     def get_urls(self):
603         from django.urls import path
604 
605         def wrap(view):
606             def wrapper(*args, **kwargs):
607                 return self.admin_site.admin_view(view)(*args, **kwargs)
608             wrapper.model_admin = self
609             return update_wrapper(wrapper, view)
610 
611         info = self.model._meta.app_label, self.model._meta.model_name
612 
613         return [
614             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
615             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
616             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
617             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
618             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
619             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
620             # For backwards compatibility (was the change url before 1.9)
621             path('<path:object_id>/', wrap(RedirectView.as_view(
622                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
623             ))),
624         ]
625 
626     @property
627     def urls(self):
628         return self.get_urls()
629 
630     @property
631     def media(self):
632         extra = '' if settings.DEBUG else '.min'
633         js = [
634             'vendor/jquery/jquery%s.js' % extra,
635             'jquery.init.js',
636             'core.js',
637             'admin/RelatedObjectLookups.js',
638             'actions%s.js' % extra,
639             'urlify.js',
640             'prepopulate%s.js' % extra,
641             'vendor/xregexp/xregexp%s.js' % extra,
642         ]
643         return forms.Media(js=['admin/js/%s' % url for url in js])
644 
645     def get_model_perms(self, request):
646         """
647         Return a dict of all perms for this model. This dict has the keys
648         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
649         for each of those actions.
650         """
651         return {
652             'add': self.has_add_permission(request),
653             'change': self.has_change_permission(request),
654             'delete': self.has_delete_permission(request),
655             'view': self.has_view_permission(request),
656         }
657 
658     def _get_form_for_get_fields(self, request, obj):
659         return self.get_form(request, obj, fields=None)
660 
661     def get_form(self, request, obj=None, change=False, **kwargs):
662         """
663         Return a Form class for use in the admin add view. This is used by
664         add_view and change_view.
665         """
666         if 'fields' in kwargs:
667             fields = kwargs.pop('fields')
668         else:
669             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
670         excluded = self.get_exclude(request, obj)
671         exclude = [] if excluded is None else list(excluded)
672         readonly_fields = self.get_readonly_fields(request, obj)
673         exclude.extend(readonly_fields)
674         # Exclude all fields if it's a change form and the user doesn't have
675         # the change permission.
676         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
677             exclude.extend(fields)
678         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
679             # Take the custom ModelForm's Meta.exclude into account only if the
680             # ModelAdmin doesn't define its own.
681             exclude.extend(self.form._meta.exclude)
682         # if exclude is an empty list we pass None to be consistent with the
683         # default on modelform_factory
684         exclude = exclude or None
685 
686         # Remove declared form fields which are in readonly_fields.
687         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
688         form = type(self.form.__name__, (self.form,), new_attrs)
689 
690         defaults = {
691             'form': form,
692             'fields': fields,
693             'exclude': exclude,
694             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
695             **kwargs,
696         }
697 
698         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
699             defaults['fields'] = forms.ALL_FIELDS
700 
701         try:
702             return modelform_factory(self.model, **defaults)
703         except FieldError as e:
704             raise FieldError(
705                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
706                 % (e, self.__class__.__name__)
707             )
708 
709     def get_changelist(self, request, **kwargs):
710         """
711         Return the ChangeList class for use on the changelist page.
712         """
713         from django.contrib.admin.views.main import ChangeList
714         return ChangeList
715 
716     def get_changelist_instance(self, request):
717         """
718         Return a `ChangeList` instance based on `request`. May raise
719         `IncorrectLookupParameters`.
720         """
721         list_display = self.get_list_display(request)
722         list_display_links = self.get_list_display_links(request, list_display)
723         # Add the action checkboxes if any actions are available.
724         if self.get_actions(request):
725             list_display = ['action_checkbox', *list_display]
726         sortable_by = self.get_sortable_by(request)
727         ChangeList = self.get_changelist(request)
728         return ChangeList(
729             request,
730             self.model,
731             list_display,
732             list_display_links,
733             self.get_list_filter(request),
734             self.date_hierarchy,
735             self.get_search_fields(request),
736             self.get_list_select_related(request),
737             self.list_per_page,
738             self.list_max_show_all,
739             self.list_editable,
740             self,
741             sortable_by,
742         )
743 
744     def get_object(self, request, object_id, from_field=None):
745         """
746         Return an instance matching the field and value provided, the primary
747         key is used if no field is provided. Return ``None`` if no match is
748         found or the object_id fails validation.
749         """
750         queryset = self.get_queryset(request)
751         model = queryset.model
752         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
753         try:
754             object_id = field.to_python(object_id)
755             return queryset.get(**{field.name: object_id})
756         except (model.DoesNotExist, ValidationError, ValueError):
757             return None
758 
759     def get_changelist_form(self, request, **kwargs):
760         """
761         Return a Form class for use in the Formset on the changelist page.
762         """
763         defaults = {
764             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
765             **kwargs,
766         }
767         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
768             defaults['fields'] = forms.ALL_FIELDS
769 
770         return modelform_factory(self.model, **defaults)
771 
772     def get_changelist_formset(self, request, **kwargs):
773         """
774         Return a FormSet class for use on the changelist page if list_editable
775         is used.
776         """
777         defaults = {
778             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
779             **kwargs,
780         }
781         return modelformset_factory(
782             self.model, self.get_changelist_form(request), extra=0,
783             fields=self.list_editable, **defaults
784         )
785 
786     def get_formsets_with_inlines(self, request, obj=None):
787         """
788         Yield formsets and the corresponding inlines.
789         """
790         for inline in self.get_inline_instances(request, obj):
791             yield inline.get_formset(request, obj), inline
792 
793     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
794         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
795 
796     def log_addition(self, request, object, message):
797         """
798         Log that an object has been successfully added.
799 
800         The default implementation creates an admin LogEntry object.
801         """
802         from django.contrib.admin.models import LogEntry, ADDITION
803         return LogEntry.objects.log_action(
804             user_id=request.user.pk,
805             content_type_id=get_content_type_for_model(object).pk,
806             object_id=object.pk,
807             object_repr=str(object),
808             action_flag=ADDITION,
809             change_message=message,
810         )
811 
812     def log_change(self, request, object, message):
813         """
814         Log that an object has been successfully changed.
815 
816         The default implementation creates an admin LogEntry object.
817         """
818         from django.contrib.admin.models import LogEntry, CHANGE
819         return LogEntry.objects.log_action(
820             user_id=request.user.pk,
821             content_type_id=get_content_type_for_model(object).pk,
822             object_id=object.pk,
823             object_repr=str(object),
824             action_flag=CHANGE,
825             change_message=message,
826         )
827 
828     def log_deletion(self, request, object, object_repr):
829         """
830         Log that an object will be deleted. Note that this method must be
831         called before the deletion.
832 
833         The default implementation creates an admin LogEntry object.
834         """
835         from django.contrib.admin.models import LogEntry, DELETION
836         return LogEntry.objects.log_action(
837             user_id=request.user.pk,
838             content_type_id=get_content_type_for_model(object).pk,
839             object_id=object.pk,
840             object_repr=object_repr,
841             action_flag=DELETION,
842         )
843 
844     def action_checkbox(self, obj):
845         """
846         A list_display column containing a checkbox widget.
847         """
848         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
849     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
850 
851     def _get_base_actions(self):
852         """Return the list of actions, prior to any request-based filtering."""
853         actions = []
854 
855         # Gather actions from the admin site first
856         for (name, func) in self.admin_site.actions:
857             description = getattr(func, 'short_description', name.replace('_', ' '))
858             actions.append((func, name, description))
859         # Add actions from this ModelAdmin.
860         actions.extend(self.get_action(action) for action in self.actions or [])
861         # get_action might have returned None, so filter any of those out.
862         return filter(None, actions)
863 
864     def _filter_actions_by_permissions(self, request, actions):
865         """Filter out any actions that the user doesn't have access to."""
866         filtered_actions = []
867         for action in actions:
868             callable = action[0]
869             if not hasattr(callable, 'allowed_permissions'):
870                 filtered_actions.append(action)
871                 continue
872             permission_checks = (
873                 getattr(self, 'has_%s_permission' % permission)
874                 for permission in callable.allowed_permissions
875             )
876             if any(has_permission(request) for has_permission in permission_checks):
877                 filtered_actions.append(action)
878         return filtered_actions
879 
880     def get_actions(self, request):
881         """
882         Return a dictionary mapping the names of all actions for this
883         ModelAdmin to a tuple of (callable, name, description) for each action.
884         """
885         # If self.actions is set to None that means actions are disabled on
886         # this page.
887         if self.actions is None or IS_POPUP_VAR in request.GET:
888             return {}
889         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
890         return {name: (func, name, desc) for func, name, desc in actions}
891 
892     def get_action_choices(self, request, default_choices=BLANK_CHOICE_DASH):
893         """
894         Return a list of choices for use in a form object.  Each choice is a
895         tuple (name, description).
896         """
897         choices = [] + default_choices
898         for func, name, description in self.get_actions(request).values():
899             choice = (name, description % model_format_dict(self.opts))
900             choices.append(choice)
901         return choices
902 
903     def get_action(self, action):
904         """
905         Return a given action from a parameter, which can either be a callable,
906         or the name of a method on the ModelAdmin.  Return is a tuple of
907         (callable, name, description).
908         """
909         # If the action is a callable, just use it.
910         if callable(action):
911             func = action
912             action = action.__name__
913 
914         # Next, look for a method. Grab it off self.__class__ to get an unbound
915         # method instead of a bound one; this ensures that the calling
916         # conventions are the same for functions and methods.
917         elif hasattr(self.__class__, action):
918             func = getattr(self.__class__, action)
919 
920         # Finally, look for a named method on the admin site
921         else:
922             try:
923                 func = self.admin_site.get_action(action)
924             except KeyError:
925                 return None
926 
927         if hasattr(func, 'short_description'):
928             description = func.short_description
929         else:
930             description = capfirst(action.replace('_', ' '))
931         return func, action, description
932 
933     def get_list_display(self, request):
934         """
935         Return a sequence containing the fields to be displayed on the
936         changelist.
937         """
938         return self.list_display
939 
940     def get_list_display_links(self, request, list_display):
941         """
942         Return a sequence containing the fields to be displayed as links
943         on the changelist. The list_display parameter is the list of fields
944         returned by get_list_display().
945         """
946         if self.list_display_links or self.list_display_links is None or not list_display:
947             return self.list_display_links
948         else:
949             # Use only the first item in list_display as link
950             return list(list_display)[:1]
951 
952     def get_list_filter(self, request):
953         """
954         Return a sequence containing the fields to be displayed as filters in
955         the right sidebar of the changelist page.
956         """
957         return self.list_filter
958 
959     def get_list_select_related(self, request):
960         """
961         Return a list of fields to add to the select_related() part of the
962         changelist items query.
963         """
964         return self.list_select_related
965 
966     def get_search_fields(self, request):
967         """
968         Return a sequence containing the fields to be searched whenever
969         somebody submits a search query.
970         """
971         return self.search_fields
972 
973     def get_search_results(self, request, queryset, search_term):
974         """
975         Return a tuple containing a queryset to implement the search
976         and a boolean indicating if the results may contain duplicates.
977         """
978         # Apply keyword searches.
979         def construct_search(field_name):
980             if field_name.startswith('^'):
981                 return "%s__istartswith" % field_name[1:]
982             elif field_name.startswith('='):
983                 return "%s__iexact" % field_name[1:]
984             elif field_name.startswith('@'):
985                 return "%s__search" % field_name[1:]
986             # Use field_name if it includes a lookup.
987             opts = queryset.model._meta
988             lookup_fields = field_name.split(LOOKUP_SEP)
989             # Go through the fields, following all relations.
990             prev_field = None
991             for path_part in lookup_fields:
992                 if path_part == 'pk':
993                     path_part = opts.pk.name
994                 try:
995                     field = opts.get_field(path_part)
996                 except FieldDoesNotExist:
997                     # Use valid query lookups.
998                     if prev_field and prev_field.get_lookup(path_part):
999                         return field_name
1000                 else:
1001                     prev_field = field
1002                     if hasattr(field, 'get_path_info'):
1003                         # Update opts to follow the relation.
1004                         opts = field.get_path_info()[-1].to_opts
1005             # Otherwise, use the field with icontains.
1006             return "%s__icontains" % field_name
1007 
1008         use_distinct = False
1009         search_fields = self.get_search_fields(request)
1010         if search_fields and search_term:
1011             orm_lookups = [construct_search(str(search_field))
1012                            for search_field in search_fields]
1013             for bit in search_term.split():
1014                 or_queries = [models.Q(**{orm_lookup: bit})
1015                               for orm_lookup in orm_lookups]
1016                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1017             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1018 
1019         return queryset, use_distinct
1020 
1021     def get_preserved_filters(self, request):
1022         """
1023         Return the preserved filters querystring.
1024         """
1025         match = request.resolver_match
1026         if self.preserve_filters and match:
1027             opts = self.model._meta
1028             current_url = '%s:%s' % (match.app_name, match.url_name)
1029             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1030             if current_url == changelist_url:
1031                 preserved_filters = request.GET.urlencode()
1032             else:
1033                 preserved_filters = request.GET.get('_changelist_filters')
1034 
1035             if preserved_filters:
1036                 return urlencode({'_changelist_filters': preserved_filters})
1037         return ''
1038 
1039     def construct_change_message(self, request, form, formsets, add=False):
1040         """
1041         Construct a JSON structure describing changes from a changed object.
1042         """
1043         return construct_change_message(form, formsets, add)
1044 
1045     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1046                      fail_silently=False):
1047         """
1048         Send a message to the user. The default implementation
1049         posts a message using the django.contrib.messages backend.
1050 
1051         Exposes almost the same API as messages.add_message(), but accepts the
1052         positional arguments in a different order to maintain backwards
1053         compatibility. For convenience, it accepts the `level` argument as
1054         a string rather than the usual level number.
1055         """
1056         if not isinstance(level, int):
1057             # attempt to get the level if passed a string
1058             try:
1059                 level = getattr(messages.constants, level.upper())
1060             except AttributeError:
1061                 levels = messages.constants.DEFAULT_TAGS.values()
1062                 levels_repr = ', '.join('`%s`' % l for l in levels)
1063                 raise ValueError(
1064                     'Bad message level string: `%s`. Possible values are: %s'
1065                     % (level, levels_repr)
1066                 )
1067 
1068         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1069 
1070     def save_form(self, request, form, change):
1071         """
1072         Given a ModelForm return an unsaved instance. ``change`` is True if
1073         the object is being changed, and False if it's being added.
1074         """
1075         return form.save(commit=False)
1076 
1077     def save_model(self, request, obj, form, change):
1078         """
1079         Given a model instance save it to the database.
1080         """
1081         obj.save()
1082 
1083     def delete_model(self, request, obj):
1084         """
1085         Given a model instance delete it from the database.
1086         """
1087         obj.delete()
1088 
1089     def delete_queryset(self, request, queryset):
1090         """Given a queryset, delete it from the database."""
1091         queryset.delete()
1092 
1093     def save_formset(self, request, form, formset, change):
1094         """
1095         Given an inline formset save it to the database.
1096         """
1097         formset.save()
1098 
1099     def save_related(self, request, form, formsets, change):
1100         """
1101         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1102         list of inline formsets and a boolean value based on whether the
1103         parent is being added or changed, save the related objects to the
1104         database. Note that at this point save_form() and save_model() have
1105         already been called.
1106         """
1107         form.save_m2m()
1108         for formset in formsets:
1109             self.save_formset(request, form, formset, change=change)
1110 
1111     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1112         opts = self.model._meta
1113         app_label = opts.app_label
1114         preserved_filters = self.get_preserved_filters(request)
1115         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1116         view_on_site_url = self.get_view_on_site_url(obj)
1117         has_editable_inline_admin_formsets = False
1118         for inline in context['inline_admin_formsets']:
1119             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1120                 has_editable_inline_admin_formsets = True
1121                 break
1122         context.update({
1123             'add': add,
1124             'change': change,
1125             'has_view_permission': self.has_view_permission(request, obj),
1126             'has_add_permission': self.has_add_permission(request),
1127             'has_change_permission': self.has_change_permission(request, obj),
1128             'has_delete_permission': self.has_delete_permission(request, obj),
1129             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1130             'has_file_field': context['adminform'].form.is_multipart() or any(
1131                 admin_formset.formset.is_multipart()
1132                 for admin_formset in context['inline_admin_formsets']
1133             ),
1134             'has_absolute_url': view_on_site_url is not None,
1135             'absolute_url': view_on_site_url,
1136             'form_url': form_url,
1137             'opts': opts,
1138             'content_type_id': get_content_type_for_model(self.model).pk,
1139             'save_as': self.save_as,
1140             'save_on_top': self.save_on_top,
1141             'to_field_var': TO_FIELD_VAR,
1142             'is_popup_var': IS_POPUP_VAR,
1143             'app_label': app_label,
1144         })
1145         if add and self.add_form_template is not None:
1146             form_template = self.add_form_template
1147         else:
1148             form_template = self.change_form_template
1149 
1150         request.current_app = self.admin_site.name
1151 
1152         return TemplateResponse(request, form_template or [
1153             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1154             "admin/%s/change_form.html" % app_label,
1155             "admin/change_form.html"
1156         ], context)
1157 
1158     def response_add(self, request, obj, post_url_continue=None):
1159         """
1160         Determine the HttpResponse for the add_view stage.
1161         """
1162         opts = obj._meta
1163         preserved_filters = self.get_preserved_filters(request)
1164         obj_url = reverse(
1165             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1166             args=(quote(obj.pk),),
1167             current_app=self.admin_site.name,
1168         )
1169         # Add a link to the object's change form if the user can edit the obj.
1170         if self.has_change_permission(request, obj):
1171             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1172         else:
1173             obj_repr = str(obj)
1174         msg_dict = {
1175             'name': opts.verbose_name,
1176             'obj': obj_repr,
1177         }
1178         # Here, we distinguish between different save types by checking for
1179         # the presence of keys in request.POST.
1180 
1181         if IS_POPUP_VAR in request.POST:
1182             to_field = request.POST.get(TO_FIELD_VAR)
1183             if to_field:
1184                 attr = str(to_field)
1185             else:
1186                 attr = obj._meta.pk.attname
1187             value = obj.serializable_value(attr)
1188             popup_response_data = json.dumps({
1189                 'value': str(value),
1190                 'obj': str(obj),
1191             })
1192             return TemplateResponse(request, self.popup_response_template or [
1193                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1194                 'admin/%s/popup_response.html' % opts.app_label,
1195                 'admin/popup_response.html',
1196             ], {
1197                 'popup_response_data': popup_response_data,
1198             })
1199 
1200         elif "_continue" in request.POST or (
1201                 # Redirecting after "Save as new".
1202                 "_saveasnew" in request.POST and self.save_as_continue and
1203                 self.has_change_permission(request, obj)
1204         ):
1205             msg = _('The {name} "{obj}" was added successfully.')
1206             if self.has_change_permission(request, obj):
1207                 msg += ' ' + _('You may edit it again below.')
1208             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1209             if post_url_continue is None:
1210                 post_url_continue = obj_url
1211             post_url_continue = add_preserved_filters(
1212                 {'preserved_filters': preserved_filters, 'opts': opts},
1213                 post_url_continue
1214             )
1215             return HttpResponseRedirect(post_url_continue)
1216 
1217         elif "_addanother" in request.POST:
1218             msg = format_html(
1219                 _('The {name} "{obj}" was added successfully. You may add another {name} below.'),
1220                 **msg_dict
1221             )
1222             self.message_user(request, msg, messages.SUCCESS)
1223             redirect_url = request.path
1224             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1225             return HttpResponseRedirect(redirect_url)
1226 
1227         else:
1228             msg = format_html(
1229                 _('The {name} "{obj}" was added successfully.'),
1230                 **msg_dict
1231             )
1232             self.message_user(request, msg, messages.SUCCESS)
1233             return self.response_post_save_add(request, obj)
1234 
1235     def response_change(self, request, obj):
1236         """
1237         Determine the HttpResponse for the change_view stage.
1238         """
1239 
1240         if IS_POPUP_VAR in request.POST:
1241             opts = obj._meta
1242             to_field = request.POST.get(TO_FIELD_VAR)
1243             attr = str(to_field) if to_field else opts.pk.attname
1244             value = request.resolver_match.kwargs['object_id']
1245             new_value = obj.serializable_value(attr)
1246             popup_response_data = json.dumps({
1247                 'action': 'change',
1248                 'value': str(value),
1249                 'obj': str(obj),
1250                 'new_value': str(new_value),
1251             })
1252             return TemplateResponse(request, self.popup_response_template or [
1253                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1254                 'admin/%s/popup_response.html' % opts.app_label,
1255                 'admin/popup_response.html',
1256             ], {
1257                 'popup_response_data': popup_response_data,
1258             })
1259 
1260         opts = self.model._meta
1261         preserved_filters = self.get_preserved_filters(request)
1262 
1263         msg_dict = {
1264             'name': opts.verbose_name,
1265             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1266         }
1267         if "_continue" in request.POST:
1268             msg = format_html(
1269                 _('The {name} "{obj}" was changed successfully. You may edit it again below.'),
1270                 **msg_dict
1271             )
1272             self.message_user(request, msg, messages.SUCCESS)
1273             redirect_url = request.path
1274             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1275             return HttpResponseRedirect(redirect_url)
1276 
1277         elif "_saveasnew" in request.POST:
1278             msg = format_html(
1279                 _('The {name} "{obj}" was added successfully. You may edit it again below.'),
1280                 **msg_dict
1281             )
1282             self.message_user(request, msg, messages.SUCCESS)
1283             redirect_url = reverse('admin:%s_%s_change' %
1284                                    (opts.app_label, opts.model_name),
1285                                    args=(obj.pk,),
1286                                    current_app=self.admin_site.name)
1287             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1288             return HttpResponseRedirect(redirect_url)
1289 
1290         elif "_addanother" in request.POST:
1291             msg = format_html(
1292                 _('The {name} "{obj}" was changed successfully. You may add another {name} below.'),
1293                 **msg_dict
1294             )
1295             self.message_user(request, msg, messages.SUCCESS)
1296             redirect_url = reverse('admin:%s_%s_add' %
1297                                    (opts.app_label, opts.model_name),
1298                                    current_app=self.admin_site.name)
1299             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1300             return HttpResponseRedirect(redirect_url)
1301 
1302         else:
1303             msg = format_html(
1304                 _('The {name} "{obj}" was changed successfully.'),
1305                 **msg_dict
1306             )
1307             self.message_user(request, msg, messages.SUCCESS)
1308             return self.response_post_save_change(request, obj)
1309 
1310     def _response_post_save(self, request, obj):
1311         opts = self.model._meta
1312         if self.has_view_or_change_permission(request):
1313             post_url = reverse('admin:%s_%s_changelist' %
1314                                (opts.app_label, opts.model_name),
1315                                current_app=self.admin_site.name)
1316             preserved_filters = self.get_preserved_filters(request)
1317             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1318         else:
1319             post_url = reverse('admin:index',
1320                                current_app=self.admin_site.name)
1321         return HttpResponseRedirect(post_url)
1322 
1323     def response_post_save_add(self, request, obj):
1324         """
1325         Figure out where to redirect after the 'Save' button has been pressed
1326         when adding a new object.
1327         """
1328         return self._response_post_save(request, obj)
1329 
1330     def response_post_save_change(self, request, obj):
1331         """
1332         Figure out where to redirect after the 'Save' button has been pressed
1333         when editing an existing object.
1334         """
1335         return self._response_post_save(request, obj)
1336 
1337     def response_action(self, request, queryset):
1338         """
1339         Handle an admin action. This is called if a request is POSTed to the
1340         changelist; it returns an HttpResponse if the action was handled, and
1341         None otherwise.
1342         """
1343 
1344         # There can be multiple action forms on the page (at the top
1345         # and bottom of the change list, for example). Get the action
1346         # whose button was pushed.
1347         try:
1348             action_index = int(request.POST.get('index', 0))
1349         except ValueError:
1350             action_index = 0
1351 
1352         # Construct the action form.
1353         data = request.POST.copy()
1354         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1355         data.pop("index", None)
1356 
1357         # Use the action whose button was pushed
1358         try:
1359             data.update({'action': data.getlist('action')[action_index]})
1360         except IndexError:
1361             # If we didn't get an action from the chosen form that's invalid
1362             # POST data, so by deleting action it'll fail the validation check
1363             # below. So no need to do anything here
1364             pass
1365 
1366         action_form = self.action_form(data, auto_id=None)
1367         action_form.fields['action'].choices = self.get_action_choices(request)
1368 
1369         # If the form's valid we can handle the action.
1370         if action_form.is_valid():
1371             action = action_form.cleaned_data['action']
1372             select_across = action_form.cleaned_data['select_across']
1373             func = self.get_actions(request)[action][0]
1374 
1375             # Get the list of selected PKs. If nothing's selected, we can't
1376             # perform an action on it, so bail. Except we want to perform
1377             # the action explicitly on all objects.
1378             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1379             if not selected and not select_across:
1380                 # Reminder that something needs to be selected or nothing will happen
1381                 msg = _("Items must be selected in order to perform "
1382                         "actions on them. No items have been changed.")
1383                 self.message_user(request, msg, messages.WARNING)
1384                 return None
1385 
1386             if not select_across:
1387                 # Perform the action only on the selected objects
1388                 queryset = queryset.filter(pk__in=selected)
1389 
1390             response = func(self, request, queryset)
1391 
1392             # Actions may return an HttpResponse-like object, which will be
1393             # used as the response from the POST. If not, we'll be a good
1394             # little HTTP citizen and redirect back to the changelist page.
1395             if isinstance(response, HttpResponseBase):
1396                 return response
1397             else:
1398                 return HttpResponseRedirect(request.get_full_path())
1399         else:
1400             msg = _("No action selected.")
1401             self.message_user(request, msg, messages.WARNING)
1402             return None
1403 
1404     def response_delete(self, request, obj_display, obj_id):
1405         """
1406         Determine the HttpResponse for the delete_view stage.
1407         """
1408         opts = self.model._meta
1409 
1410         if IS_POPUP_VAR in request.POST:
1411             popup_response_data = json.dumps({
1412                 'action': 'delete',
1413                 'value': str(obj_id),
1414             })
1415             return TemplateResponse(request, self.popup_response_template or [
1416                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1417                 'admin/%s/popup_response.html' % opts.app_label,
1418                 'admin/popup_response.html',
1419             ], {
1420                 'popup_response_data': popup_response_data,
1421             })
1422 
1423         self.message_user(
1424             request,
1425             _('The %(name)s "%(obj)s" was deleted successfully.') % {
1426                 'name': opts.verbose_name,
1427                 'obj': obj_display,
1428             },
1429             messages.SUCCESS,
1430         )
1431 
1432         if self.has_change_permission(request, None):
1433             post_url = reverse(
1434                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1435                 current_app=self.admin_site.name,
1436             )
1437             preserved_filters = self.get_preserved_filters(request)
1438             post_url = add_preserved_filters(
1439                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1440             )
1441         else:
1442             post_url = reverse('admin:index', current_app=self.admin_site.name)
1443         return HttpResponseRedirect(post_url)
1444 
1445     def render_delete_form(self, request, context):
1446         opts = self.model._meta
1447         app_label = opts.app_label
1448 
1449         request.current_app = self.admin_site.name
1450         context.update(
1451             to_field_var=TO_FIELD_VAR,
1452             is_popup_var=IS_POPUP_VAR,
1453             media=self.media,
1454         )
1455 
1456         return TemplateResponse(
1457             request,
1458             self.delete_confirmation_template or [
1459                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1460                 "admin/{}/delete_confirmation.html".format(app_label),
1461                 "admin/delete_confirmation.html",
1462             ],
1463             context,
1464         )
1465 
1466     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1467         inline_admin_formsets = []
1468         for inline, formset in zip(inline_instances, formsets):
1469             fieldsets = list(inline.get_fieldsets(request, obj))
1470             readonly = list(inline.get_readonly_fields(request, obj))
1471             has_add_permission = inline.has_add_permission(request, obj)
1472             has_change_permission = inline.has_change_permission(request, obj)
1473             has_delete_permission = inline.has_delete_permission(request, obj)
1474             has_view_permission = inline.has_view_permission(request, obj)
1475             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1476             inline_admin_formset = helpers.InlineAdminFormSet(
1477                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1478                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1479                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1480             )
1481             inline_admin_formsets.append(inline_admin_formset)
1482         return inline_admin_formsets
1483 
1484     def get_changeform_initial_data(self, request):
1485         """
1486         Get the initial form data from the request's GET params.
1487         """
1488         initial = dict(request.GET.items())
1489         for k in initial:
1490             try:
1491                 f = self.model._meta.get_field(k)
1492             except FieldDoesNotExist:
1493                 continue
1494             # We have to special-case M2Ms as a list of comma-separated PKs.
1495             if isinstance(f, models.ManyToManyField):
1496                 initial[k] = initial[k].split(",")
1497         return initial
1498 
1499     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1500         """
1501         Create a message informing the user that the object doesn't exist
1502         and return a redirect to the admin index page.
1503         """
1504         msg = _("""%(name)s with ID "%(key)s" doesn't exist. Perhaps it was deleted?""") % {
1505             'name': opts.verbose_name,
1506             'key': unquote(object_id),
1507         }
1508         self.message_user(request, msg, messages.WARNING)
1509         url = reverse('admin:index', current_app=self.admin_site.name)
1510         return HttpResponseRedirect(url)
1511 
1512     @csrf_protect_m
1513     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1514         with transaction.atomic(using=router.db_for_write(self.model)):
1515             return self._changeform_view(request, object_id, form_url, extra_context)
1516 
1517     def _changeform_view(self, request, object_id, form_url, extra_context):
1518         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1519         if to_field and not self.to_field_allowed(request, to_field):
1520             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1521 
1522         model = self.model
1523         opts = model._meta
1524 
1525         if request.method == 'POST' and '_saveasnew' in request.POST:
1526             object_id = None
1527 
1528         add = object_id is None
1529 
1530         if add:
1531             if not self.has_add_permission(request):
1532                 raise PermissionDenied
1533             obj = None
1534 
1535         else:
1536             obj = self.get_object(request, unquote(object_id), to_field)
1537 
1538             if not self.has_view_or_change_permission(request, obj):
1539                 raise PermissionDenied
1540 
1541             if obj is None:
1542                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1543 
1544         ModelForm = self.get_form(request, obj, change=not add)
1545         if request.method == 'POST':
1546             form = ModelForm(request.POST, request.FILES, instance=obj)
1547             form_validated = form.is_valid()
1548             if form_validated:
1549                 new_object = self.save_form(request, form, change=not add)
1550             else:
1551                 new_object = form.instance
1552             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1553             if all_valid(formsets) and form_validated:
1554                 self.save_model(request, new_object, form, not add)
1555                 self.save_related(request, form, formsets, not add)
1556                 change_message = self.construct_change_message(request, form, formsets, add)
1557                 if add:
1558                     self.log_addition(request, new_object, change_message)
1559                     return self.response_add(request, new_object)
1560                 else:
1561                     self.log_change(request, new_object, change_message)
1562                     return self.response_change(request, new_object)
1563             else:
1564                 form_validated = False
1565         else:
1566             if add:
1567                 initial = self.get_changeform_initial_data(request)
1568                 form = ModelForm(initial=initial)
1569                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1570             else:
1571                 form = ModelForm(instance=obj)
1572                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1573 
1574         if not add and not self.has_change_permission(request, obj):
1575             readonly_fields = flatten_fieldsets(self.get_fieldsets(request, obj))
1576         else:
1577             readonly_fields = self.get_readonly_fields(request, obj)
1578         adminForm = helpers.AdminForm(
1579             form,
1580             list(self.get_fieldsets(request, obj)),
1581             # Clear prepopulated fields on a view-only form to avoid a crash.
1582             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1583             readonly_fields,
1584             model_admin=self)
1585         media = self.media + adminForm.media
1586 
1587         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1588         for inline_formset in inline_formsets:
1589             media = media + inline_formset.media
1590 
1591         if add:
1592             title = _('Add %s')
1593         elif self.has_change_permission(request, obj):
1594             title = _('Change %s')
1595         else:
1596             title = _('View %s')
1597         context = {
1598             **self.admin_site.each_context(request),
1599             'title': title % opts.verbose_name,
1600             'adminform': adminForm,
1601             'object_id': object_id,
1602             'original': obj,
1603             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1604             'to_field': to_field,
1605             'media': media,
1606             'inline_admin_formsets': inline_formsets,
1607             'errors': helpers.AdminErrorList(form, formsets),
1608             'preserved_filters': self.get_preserved_filters(request),
1609         }
1610 
1611         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1612         # previously chosen to prevent the interface from getting confusing.
1613         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1614             context['show_save'] = False
1615             context['show_save_and_continue'] = False
1616             # Use the change template instead of the add template.
1617             add = False
1618 
1619         context.update(extra_context or {})
1620 
1621         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1622 
1623     def autocomplete_view(self, request):
1624         return AutocompleteJsonView.as_view(model_admin=self)(request)
1625 
1626     def add_view(self, request, form_url='', extra_context=None):
1627         return self.changeform_view(request, None, form_url, extra_context)
1628 
1629     def change_view(self, request, object_id, form_url='', extra_context=None):
1630         return self.changeform_view(request, object_id, form_url, extra_context)
1631 
1632     def _get_edited_object_pks(self, request, prefix):
1633         """Return POST data values of list_editable primary keys."""
1634         pk_pattern = re.compile(r'{}-\d+-{}$'.format(prefix, self.model._meta.pk.name))
1635         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1636 
1637     def _get_list_editable_queryset(self, request, prefix):
1638         """
1639         Based on POST data, return a queryset of the objects that were edited
1640         via list_editable.
1641         """
1642         object_pks = self._get_edited_object_pks(request, prefix)
1643         queryset = self.get_queryset(request)
1644         validate = queryset.model._meta.pk.to_python
1645         try:
1646             for pk in object_pks:
1647                 validate(pk)
1648         except ValidationError:
1649             # Disable the optimization if the POST data was tampered with.
1650             return queryset
1651         return queryset.filter(pk__in=object_pks)
1652 
1653     @csrf_protect_m
1654     def changelist_view(self, request, extra_context=None):
1655         """
1656         The 'change list' admin view for this model.
1657         """
1658         from django.contrib.admin.views.main import ERROR_FLAG
1659         opts = self.model._meta
1660         app_label = opts.app_label
1661         if not self.has_view_or_change_permission(request):
1662             raise PermissionDenied
1663 
1664         try:
1665             cl = self.get_changelist_instance(request)
1666         except IncorrectLookupParameters:
1667             # Wacky lookup parameters were given, so redirect to the main
1668             # changelist page, without parameters, and pass an 'invalid=1'
1669             # parameter via the query string. If wacky parameters were given
1670             # and the 'invalid=1' parameter was already in the query string,
1671             # something is screwed up with the database, so display an error
1672             # page.
1673             if ERROR_FLAG in request.GET:
1674                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1675                     'title': _('Database error'),
1676                 })
1677             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1678 
1679         # If the request was POSTed, this might be a bulk action or a bulk
1680         # edit. Try to look up an action or confirmation first, but if this
1681         # isn't an action the POST will fall through to the bulk edit check,
1682         # below.
1683         action_failed = False
1684         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1685 
1686         actions = self.get_actions(request)
1687         # Actions with no confirmation
1688         if (actions and request.method == 'POST' and
1689                 'index' in request.POST and '_save' not in request.POST):
1690             if selected:
1691                 response = self.response_action(request, queryset=cl.get_queryset(request))
1692                 if response:
1693                     return response
1694                 else:
1695                     action_failed = True
1696             else:
1697                 msg = _("Items must be selected in order to perform "
1698                         "actions on them. No items have been changed.")
1699                 self.message_user(request, msg, messages.WARNING)
1700                 action_failed = True
1701 
1702         # Actions with confirmation
1703         if (actions and request.method == 'POST' and
1704                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1705                 'index' not in request.POST and '_save' not in request.POST):
1706             if selected:
1707                 response = self.response_action(request, queryset=cl.get_queryset(request))
1708                 if response:
1709                     return response
1710                 else:
1711                     action_failed = True
1712 
1713         if action_failed:
1714             # Redirect back to the changelist page to avoid resubmitting the
1715             # form if the user refreshes the browser or uses the "No, take
1716             # me back" button on the action confirmation page.
1717             return HttpResponseRedirect(request.get_full_path())
1718 
1719         # If we're allowing changelist editing, we need to construct a formset
1720         # for the changelist given all the fields to be edited. Then we'll
1721         # use the formset to validate/process POSTed data.
1722         formset = cl.formset = None
1723 
1724         # Handle POSTed bulk-edit data.
1725         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1726             if not self.has_change_permission(request):
1727                 raise PermissionDenied
1728             FormSet = self.get_changelist_formset(request)
1729             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1730             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1731             if formset.is_valid():
1732                 changecount = 0
1733                 for form in formset.forms:
1734                     if form.has_changed():
1735                         obj = self.save_form(request, form, change=True)
1736                         self.save_model(request, obj, form, change=True)
1737                         self.save_related(request, form, formsets=[], change=True)
1738                         change_msg = self.construct_change_message(request, form, None)
1739                         self.log_change(request, obj, change_msg)
1740                         changecount += 1
1741 
1742                 if changecount:
1743                     msg = ngettext(
1744                         "%(count)s %(name)s was changed successfully.",
1745                         "%(count)s %(name)s were changed successfully.",
1746                         changecount
1747                     ) % {
1748                         'count': changecount,
1749                         'name': model_ngettext(opts, changecount),
1750                     }
1751                     self.message_user(request, msg, messages.SUCCESS)
1752 
1753                 return HttpResponseRedirect(request.get_full_path())
1754 
1755         # Handle GET -- construct a formset for display.
1756         elif cl.list_editable and self.has_change_permission(request):
1757             FormSet = self.get_changelist_formset(request)
1758             formset = cl.formset = FormSet(queryset=cl.result_list)
1759 
1760         # Build the list of media to be used by the formset.
1761         if formset:
1762             media = self.media + formset.media
1763         else:
1764             media = self.media
1765 
1766         # Build the action form and populate it with available actions.
1767         if actions:
1768             action_form = self.action_form(auto_id=None)
1769             action_form.fields['action'].choices = self.get_action_choices(request)
1770             media += action_form.media
1771         else:
1772             action_form = None
1773 
1774         selection_note_all = ngettext(
1775             '%(total_count)s selected',
1776             'All %(total_count)s selected',
1777             cl.result_count
1778         )
1779 
1780         context = {
1781             **self.admin_site.each_context(request),
1782             'module_name': str(opts.verbose_name_plural),
1783             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1784             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1785             'title': cl.title,
1786             'is_popup': cl.is_popup,
1787             'to_field': cl.to_field,
1788             'cl': cl,
1789             'media': media,
1790             'has_add_permission': self.has_add_permission(request),
1791             'opts': cl.opts,
1792             'action_form': action_form,
1793             'actions_on_top': self.actions_on_top,
1794             'actions_on_bottom': self.actions_on_bottom,
1795             'actions_selection_counter': self.actions_selection_counter,
1796             'preserved_filters': self.get_preserved_filters(request),
1797             **(extra_context or {}),
1798         }
1799 
1800         request.current_app = self.admin_site.name
1801 
1802         return TemplateResponse(request, self.change_list_template or [
1803             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1804             'admin/%s/change_list.html' % app_label,
1805             'admin/change_list.html'
1806         ], context)
1807 
1808     def get_deleted_objects(self, objs, request):
1809         """
1810         Hook for customizing the delete process for the delete view and the
1811         "delete selected" action.
1812         """
1813         return get_deleted_objects(objs, request, self.admin_site)
1814 
1815     @csrf_protect_m
1816     def delete_view(self, request, object_id, extra_context=None):
1817         with transaction.atomic(using=router.db_for_write(self.model)):
1818             return self._delete_view(request, object_id, extra_context)
1819 
1820     def _delete_view(self, request, object_id, extra_context):
1821         "The 'delete' admin view for this model."
1822         opts = self.model._meta
1823         app_label = opts.app_label
1824 
1825         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1826         if to_field and not self.to_field_allowed(request, to_field):
1827             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1828 
1829         obj = self.get_object(request, unquote(object_id), to_field)
1830 
1831         if not self.has_delete_permission(request, obj):
1832             raise PermissionDenied
1833 
1834         if obj is None:
1835             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1836 
1837         # Populate deleted_objects, a data structure of all related objects that
1838         # will also be deleted.
1839         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1840 
1841         if request.POST and not protected:  # The user has confirmed the deletion.
1842             if perms_needed:
1843                 raise PermissionDenied
1844             obj_display = str(obj)
1845             attr = str(to_field) if to_field else opts.pk.attname
1846             obj_id = obj.serializable_value(attr)
1847             self.log_deletion(request, obj, obj_display)
1848             self.delete_model(request, obj)
1849 
1850             return self.response_delete(request, obj_display, obj_id)
1851 
1852         object_name = str(opts.verbose_name)
1853 
1854         if perms_needed or protected:
1855             title = _("Cannot delete %(name)s") % {"name": object_name}
1856         else:
1857             title = _("Are you sure?")
1858 
1859         context = {
1860             **self.admin_site.each_context(request),
1861             'title': title,
1862             'object_name': object_name,
1863             'object': obj,
1864             'deleted_objects': deleted_objects,
1865             'model_count': dict(model_count).items(),
1866             'perms_lacking': perms_needed,
1867             'protected': protected,
1868             'opts': opts,
1869             'app_label': app_label,
1870             'preserved_filters': self.get_preserved_filters(request),
1871             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1872             'to_field': to_field,
1873             **(extra_context or {}),
1874         }
1875 
1876         return self.render_delete_form(request, context)
1877 
1878     def history_view(self, request, object_id, extra_context=None):
1879         "The 'history' admin view for this model."
1880         from django.contrib.admin.models import LogEntry
1881         # First check if the user can see this history.
1882         model = self.model
1883         obj = self.get_object(request, unquote(object_id))
1884         if obj is None:
1885             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1886 
1887         if not self.has_view_or_change_permission(request, obj):
1888             raise PermissionDenied
1889 
1890         # Then get the history for this object.
1891         opts = model._meta
1892         app_label = opts.app_label
1893         action_list = LogEntry.objects.filter(
1894             object_id=unquote(object_id),
1895             content_type=get_content_type_for_model(model)
1896         ).select_related().order_by('action_time')
1897 
1898         context = {
1899             **self.admin_site.each_context(request),
1900             'title': _('Change history: %s') % obj,
1901             'action_list': action_list,
1902             'module_name': str(capfirst(opts.verbose_name_plural)),
1903             'object': obj,
1904             'opts': opts,
1905             'preserved_filters': self.get_preserved_filters(request),
1906             **(extra_context or {}),
1907         }
1908 
1909         request.current_app = self.admin_site.name
1910 
1911         return TemplateResponse(request, self.object_history_template or [
1912             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1913             "admin/%s/object_history.html" % app_label,
1914             "admin/object_history.html"
1915         ], context)
1916 
1917     def _create_formsets(self, request, obj, change):
1918         "Helper function to generate formsets for add/change_view."
1919         formsets = []
1920         inline_instances = []
1921         prefixes = {}
1922         get_formsets_args = [request]
1923         if change:
1924             get_formsets_args.append(obj)
1925         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1926             prefix = FormSet.get_default_prefix()
1927             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1928             if prefixes[prefix] != 1 or not prefix:
1929                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1930             formset_params = {
1931                 'instance': obj,
1932                 'prefix': prefix,
1933                 'queryset': inline.get_queryset(request),
1934             }
1935             if request.method == 'POST':
1936                 formset_params.update({
1937                     'data': request.POST.copy(),
1938                     'files': request.FILES,
1939                     'save_as_new': '_saveasnew' in request.POST
1940                 })
1941             formset = FormSet(**formset_params)
1942 
1943             def user_deleted_form(request, obj, formset, index):
1944                 """Return whether or not the user deleted the form."""
1945                 return (
1946                     inline.has_delete_permission(request, obj) and
1947                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1948                 )
1949 
1950             # Bypass validation of each view-only inline form (since the form's
1951             # data won't be in request.POST), unless the form was deleted.
1952             if not inline.has_change_permission(request, obj if change else None):
1953                 for index, form in enumerate(formset.initial_forms):
1954                     if user_deleted_form(request, obj, formset, index):
1955                         continue
1956                     form._errors = {}
1957                     form.cleaned_data = form.initial
1958             formsets.append(formset)
1959             inline_instances.append(inline)
1960         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 03:01:04.818 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>log_change</method>
<code>
812     def log_change(self, request, object, message):
813         """
814         Log that an object has been successfully changed.
815 
816         The default implementation creates an admin LogEntry object.
817         """
818         from django.contrib.admin.models import LogEntry, CHANGE
819         return LogEntry.objects.log_action(
820             user_id=request.user.pk,
821             content_type_id=get_content_type_for_model(object).pk,
822             object_id=object.pk,
823             object_repr=str(object),
824             action_flag=CHANGE,
825             change_message=message,
826         )

</code><intended_behavior>The method log_change should ideally format the message parameter to include verbose field names instead of raw field identifiers. This might entail creating a utility function within options.py or a related admin module that fetches verbose names and applies them to the change messages.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
542 class ModelAdmin(BaseModelAdmin):
543     """Encapsulate all admin options and functionality for a given model."""
544 
545     list_display = ('__str__',)
546     list_display_links = ()
547     list_filter = ()
548     list_select_related = False
549     list_per_page = 100
550     list_max_show_all = 200
551     list_editable = ()
552     search_fields = ()
553     date_hierarchy = None
554     save_as = False
555     save_as_continue = True
556     save_on_top = False
557     paginator = Paginator
558     preserve_filters = True
559     inlines = []
560 
561     # Custom templates (designed to be over-ridden in subclasses)
562     add_form_template = None
563     change_form_template = None
564     change_list_template = None
565     delete_confirmation_template = None
566     delete_selected_confirmation_template = None
567     object_history_template = None
568     popup_response_template = None
569 
570     # Actions
571     actions = []
572     action_form = helpers.ActionForm
573     actions_on_top = True
574     actions_on_bottom = False
575     actions_selection_counter = True
576     checks_class = ModelAdminChecks
577 
578     def __init__(self, model, admin_site):
579         self.model = model
580         self.opts = model._meta
581         self.admin_site = admin_site
582         super().__init__()
583 
584     def __str__(self):
585         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
586 
587     def get_inline_instances(self, request, obj=None):
588         inline_instances = []
589         for inline_class in self.get_inlines(request, obj):
590             inline = inline_class(self.model, self.admin_site)
591             if request:
592                 if not (inline.has_view_or_change_permission(request, obj) or
593                         inline.has_add_permission(request, obj) or
594                         inline.has_delete_permission(request, obj)):
595                     continue
596                 if not inline.has_add_permission(request, obj):
597                     inline.max_num = 0
598             inline_instances.append(inline)
599 
600         return inline_instances
601 
602     def get_urls(self):
603         from django.urls import path
604 
605         def wrap(view):
606             def wrapper(*args, **kwargs):
607                 return self.admin_site.admin_view(view)(*args, **kwargs)
608             wrapper.model_admin = self
609             return update_wrapper(wrapper, view)
610 
611         info = self.model._meta.app_label, self.model._meta.model_name
612 
613         return [
614             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
615             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
616             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
617             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
618             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
619             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
620             # For backwards compatibility (was the change url before 1.9)
621             path('<path:object_id>/', wrap(RedirectView.as_view(
622                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
623             ))),
624         ]
625 
626     @property
627     def urls(self):
628         return self.get_urls()
629 
630     @property
631     def media(self):
632         extra = '' if settings.DEBUG else '.min'
633         js = [
634             'vendor/jquery/jquery%s.js' % extra,
635             'jquery.init.js',
636             'core.js',
637             'admin/RelatedObjectLookups.js',
638             'actions%s.js' % extra,
639             'urlify.js',
640             'prepopulate%s.js' % extra,
641             'vendor/xregexp/xregexp%s.js' % extra,
642         ]
643         return forms.Media(js=['admin/js/%s' % url for url in js])
644 
645     def get_model_perms(self, request):
646         """
647         Return a dict of all perms for this model. This dict has the keys
648         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
649         for each of those actions.
650         """
651         return {
652             'add': self.has_add_permission(request),
653             'change': self.has_change_permission(request),
654             'delete': self.has_delete_permission(request),
655             'view': self.has_view_permission(request),
656         }
657 
658     def _get_form_for_get_fields(self, request, obj):
659         return self.get_form(request, obj, fields=None)
660 
661     def get_form(self, request, obj=None, change=False, **kwargs):
662         """
663         Return a Form class for use in the admin add view. This is used by
664         add_view and change_view.
665         """
666         if 'fields' in kwargs:
667             fields = kwargs.pop('fields')
668         else:
669             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
670         excluded = self.get_exclude(request, obj)
671         exclude = [] if excluded is None else list(excluded)
672         readonly_fields = self.get_readonly_fields(request, obj)
673         exclude.extend(readonly_fields)
674         # Exclude all fields if it's a change form and the user doesn't have
675         # the change permission.
676         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
677             exclude.extend(fields)
678         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
679             # Take the custom ModelForm's Meta.exclude into account only if the
680             # ModelAdmin doesn't define its own.
681             exclude.extend(self.form._meta.exclude)
682         # if exclude is an empty list we pass None to be consistent with the
683         # default on modelform_factory
684         exclude = exclude or None
685 
686         # Remove declared form fields which are in readonly_fields.
687         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
688         form = type(self.form.__name__, (self.form,), new_attrs)
689 
690         defaults = {
691             'form': form,
692             'fields': fields,
693             'exclude': exclude,
694             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
695             **kwargs,
696         }
697 
698         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
699             defaults['fields'] = forms.ALL_FIELDS
700 
701         try:
702             return modelform_factory(self.model, **defaults)
703         except FieldError as e:
704             raise FieldError(
705                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
706                 % (e, self.__class__.__name__)
707             )
708 
709     def get_changelist(self, request, **kwargs):
710         """
711         Return the ChangeList class for use on the changelist page.
712         """
713         from django.contrib.admin.views.main import ChangeList
714         return ChangeList
715 
716     def get_changelist_instance(self, request):
717         """
718         Return a `ChangeList` instance based on `request`. May raise
719         `IncorrectLookupParameters`.
720         """
721         list_display = self.get_list_display(request)
722         list_display_links = self.get_list_display_links(request, list_display)
723         # Add the action checkboxes if any actions are available.
724         if self.get_actions(request):
725             list_display = ['action_checkbox', *list_display]
726         sortable_by = self.get_sortable_by(request)
727         ChangeList = self.get_changelist(request)
728         return ChangeList(
729             request,
730             self.model,
731             list_display,
732             list_display_links,
733             self.get_list_filter(request),
734             self.date_hierarchy,
735             self.get_search_fields(request),
736             self.get_list_select_related(request),
737             self.list_per_page,
738             self.list_max_show_all,
739             self.list_editable,
740             self,
741             sortable_by,
742         )
743 
744     def get_object(self, request, object_id, from_field=None):
745         """
746         Return an instance matching the field and value provided, the primary
747         key is used if no field is provided. Return ``None`` if no match is
748         found or the object_id fails validation.
749         """
750         queryset = self.get_queryset(request)
751         model = queryset.model
752         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
753         try:
754             object_id = field.to_python(object_id)
755             return queryset.get(**{field.name: object_id})
756         except (model.DoesNotExist, ValidationError, ValueError):
757             return None
758 
759     def get_changelist_form(self, request, **kwargs):
760         """
761         Return a Form class for use in the Formset on the changelist page.
762         """
763         defaults = {
764             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
765             **kwargs,
766         }
767         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
768             defaults['fields'] = forms.ALL_FIELDS
769 
770         return modelform_factory(self.model, **defaults)
771 
772     def get_changelist_formset(self, request, **kwargs):
773         """
774         Return a FormSet class for use on the changelist page if list_editable
775         is used.
776         """
777         defaults = {
778             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
779             **kwargs,
780         }
781         return modelformset_factory(
782             self.model, self.get_changelist_form(request), extra=0,
783             fields=self.list_editable, **defaults
784         )
785 
786     def get_formsets_with_inlines(self, request, obj=None):
787         """
788         Yield formsets and the corresponding inlines.
789         """
790         for inline in self.get_inline_instances(request, obj):
791             yield inline.get_formset(request, obj), inline
792 
793     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
794         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
795 
796     def log_addition(self, request, object, message):
797         """
798         Log that an object has been successfully added.
799 
800         The default implementation creates an admin LogEntry object.
801         """
802         from django.contrib.admin.models import LogEntry, ADDITION
803         return LogEntry.objects.log_action(
804             user_id=request.user.pk,
805             content_type_id=get_content_type_for_model(object).pk,
806             object_id=object.pk,
807             object_repr=str(object),
808             action_flag=ADDITION,
809             change_message=message,
810         )
811 
812     def log_change(self, request, object, message):
813         """
814         Log that an object has been successfully changed.
815 
816         The default implementation creates an admin LogEntry object.
817         """
818         from django.contrib.admin.models import LogEntry, CHANGE
819         return LogEntry.objects.log_action(
820             user_id=request.user.pk,
821             content_type_id=get_content_type_for_model(object).pk,
822             object_id=object.pk,
823             object_repr=str(object),
824             action_flag=CHANGE,
825             change_message=message,
826         )
827 
828     def log_deletion(self, request, object, object_repr):
829         """
830         Log that an object will be deleted. Note that this method must be
831         called before the deletion.
832 
833         The default implementation creates an admin LogEntry object.
834         """
835         from django.contrib.admin.models import LogEntry, DELETION
836         return LogEntry.objects.log_action(
837             user_id=request.user.pk,
838             content_type_id=get_content_type_for_model(object).pk,
839             object_id=object.pk,
840             object_repr=object_repr,
841             action_flag=DELETION,
842         )
843 
844     def action_checkbox(self, obj):
845         """
846         A list_display column containing a checkbox widget.
847         """
848         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
849     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
850 
851     def _get_base_actions(self):
852         """Return the list of actions, prior to any request-based filtering."""
853         actions = []
854 
855         # Gather actions from the admin site first
856         for (name, func) in self.admin_site.actions:
857             description = getattr(func, 'short_description', name.replace('_', ' '))
858             actions.append((func, name, description))
859         # Add actions from this ModelAdmin.
860         actions.extend(self.get_action(action) for action in self.actions or [])
861         # get_action might have returned None, so filter any of those out.
862         return filter(None, actions)
863 
864     def _filter_actions_by_permissions(self, request, actions):
865         """Filter out any actions that the user doesn't have access to."""
866         filtered_actions = []
867         for action in actions:
868             callable = action[0]
869             if not hasattr(callable, 'allowed_permissions'):
870                 filtered_actions.append(action)
871                 continue
872             permission_checks = (
873                 getattr(self, 'has_%s_permission' % permission)
874                 for permission in callable.allowed_permissions
875             )
876             if any(has_permission(request) for has_permission in permission_checks):
877                 filtered_actions.append(action)
878         return filtered_actions
879 
880     def get_actions(self, request):
881         """
882         Return a dictionary mapping the names of all actions for this
883         ModelAdmin to a tuple of (callable, name, description) for each action.
884         """
885         # If self.actions is set to None that means actions are disabled on
886         # this page.
887         if self.actions is None or IS_POPUP_VAR in request.GET:
888             return {}
889         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
890         return {name: (func, name, desc) for func, name, desc in actions}
891 
892     def get_action_choices(self, request, default_choices=BLANK_CHOICE_DASH):
893         """
894         Return a list of choices for use in a form object.  Each choice is a
895         tuple (name, description).
896         """
897         choices = [] + default_choices
898         for func, name, description in self.get_actions(request).values():
899             choice = (name, description % model_format_dict(self.opts))
900             choices.append(choice)
901         return choices
902 
903     def get_action(self, action):
904         """
905         Return a given action from a parameter, which can either be a callable,
906         or the name of a method on the ModelAdmin.  Return is a tuple of
907         (callable, name, description).
908         """
909         # If the action is a callable, just use it.
910         if callable(action):
911             func = action
912             action = action.__name__
913 
914         # Next, look for a method. Grab it off self.__class__ to get an unbound
915         # method instead of a bound one; this ensures that the calling
916         # conventions are the same for functions and methods.
917         elif hasattr(self.__class__, action):
918             func = getattr(self.__class__, action)
919 
920         # Finally, look for a named method on the admin site
921         else:
922             try:
923                 func = self.admin_site.get_action(action)
924             except KeyError:
925                 return None
926 
927         if hasattr(func, 'short_description'):
928             description = func.short_description
929         else:
930             description = capfirst(action.replace('_', ' '))
931         return func, action, description
932 
933     def get_list_display(self, request):
934         """
935         Return a sequence containing the fields to be displayed on the
936         changelist.
937         """
938         return self.list_display
939 
940     def get_list_display_links(self, request, list_display):
941         """
942         Return a sequence containing the fields to be displayed as links
943         on the changelist. The list_display parameter is the list of fields
944         returned by get_list_display().
945         """
946         if self.list_display_links or self.list_display_links is None or not list_display:
947             return self.list_display_links
948         else:
949             # Use only the first item in list_display as link
950             return list(list_display)[:1]
951 
952     def get_list_filter(self, request):
953         """
954         Return a sequence containing the fields to be displayed as filters in
955         the right sidebar of the changelist page.
956         """
957         return self.list_filter
958 
959     def get_list_select_related(self, request):
960         """
961         Return a list of fields to add to the select_related() part of the
962         changelist items query.
963         """
964         return self.list_select_related
965 
966     def get_search_fields(self, request):
967         """
968         Return a sequence containing the fields to be searched whenever
969         somebody submits a search query.
970         """
971         return self.search_fields
972 
973     def get_search_results(self, request, queryset, search_term):
974         """
975         Return a tuple containing a queryset to implement the search
976         and a boolean indicating if the results may contain duplicates.
977         """
978         # Apply keyword searches.
979         def construct_search(field_name):
980             if field_name.startswith('^'):
981                 return "%s__istartswith" % field_name[1:]
982             elif field_name.startswith('='):
983                 return "%s__iexact" % field_name[1:]
984             elif field_name.startswith('@'):
985                 return "%s__search" % field_name[1:]
986             # Use field_name if it includes a lookup.
987             opts = queryset.model._meta
988             lookup_fields = field_name.split(LOOKUP_SEP)
989             # Go through the fields, following all relations.
990             prev_field = None
991             for path_part in lookup_fields:
992                 if path_part == 'pk':
993                     path_part = opts.pk.name
994                 try:
995                     field = opts.get_field(path_part)
996                 except FieldDoesNotExist:
997                     # Use valid query lookups.
998                     if prev_field and prev_field.get_lookup(path_part):
999                         return field_name
1000                 else:
1001                     prev_field = field
1002                     if hasattr(field, 'get_path_info'):
1003                         # Update opts to follow the relation.
1004                         opts = field.get_path_info()[-1].to_opts
1005             # Otherwise, use the field with icontains.
1006             return "%s__icontains" % field_name
1007 
1008         use_distinct = False
1009         search_fields = self.get_search_fields(request)
1010         if search_fields and search_term:
1011             orm_lookups = [construct_search(str(search_field))
1012                            for search_field in search_fields]
1013             for bit in search_term.split():
1014                 or_queries = [models.Q(**{orm_lookup: bit})
1015                               for orm_lookup in orm_lookups]
1016                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1017             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1018 
1019         return queryset, use_distinct
1020 
1021     def get_preserved_filters(self, request):
1022         """
1023         Return the preserved filters querystring.
1024         """
1025         match = request.resolver_match
1026         if self.preserve_filters and match:
1027             opts = self.model._meta
1028             current_url = '%s:%s' % (match.app_name, match.url_name)
1029             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1030             if current_url == changelist_url:
1031                 preserved_filters = request.GET.urlencode()
1032             else:
1033                 preserved_filters = request.GET.get('_changelist_filters')
1034 
1035             if preserved_filters:
1036                 return urlencode({'_changelist_filters': preserved_filters})
1037         return ''
1038 
1039     def construct_change_message(self, request, form, formsets, add=False):
1040         """
1041         Construct a JSON structure describing changes from a changed object.
1042         """
1043         return construct_change_message(form, formsets, add)
1044 
1045     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1046                      fail_silently=False):
1047         """
1048         Send a message to the user. The default implementation
1049         posts a message using the django.contrib.messages backend.
1050 
1051         Exposes almost the same API as messages.add_message(), but accepts the
1052         positional arguments in a different order to maintain backwards
1053         compatibility. For convenience, it accepts the `level` argument as
1054         a string rather than the usual level number.
1055         """
1056         if not isinstance(level, int):
1057             # attempt to get the level if passed a string
1058             try:
1059                 level = getattr(messages.constants, level.upper())
1060             except AttributeError:
1061                 levels = messages.constants.DEFAULT_TAGS.values()
1062                 levels_repr = ', '.join('`%s`' % l for l in levels)
1063                 raise ValueError(
1064                     'Bad message level string: `%s`. Possible values are: %s'
1065                     % (level, levels_repr)
1066                 )
1067 
1068         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1069 
1070     def save_form(self, request, form, change):
1071         """
1072         Given a ModelForm return an unsaved instance. ``change`` is True if
1073         the object is being changed, and False if it's being added.
1074         """
1075         return form.save(commit=False)
1076 
1077     def save_model(self, request, obj, form, change):
1078         """
1079         Given a model instance save it to the database.
1080         """
1081         obj.save()
1082 
1083     def delete_model(self, request, obj):
1084         """
1085         Given a model instance delete it from the database.
1086         """
1087         obj.delete()
1088 
1089     def delete_queryset(self, request, queryset):
1090         """Given a queryset, delete it from the database."""
1091         queryset.delete()
1092 
1093     def save_formset(self, request, form, formset, change):
1094         """
1095         Given an inline formset save it to the database.
1096         """
1097         formset.save()
1098 
1099     def save_related(self, request, form, formsets, change):
1100         """
1101         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1102         list of inline formsets and a boolean value based on whether the
1103         parent is being added or changed, save the related objects to the
1104         database. Note that at this point save_form() and save_model() have
1105         already been called.
1106         """
1107         form.save_m2m()
1108         for formset in formsets:
1109             self.save_formset(request, form, formset, change=change)
1110 
1111     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1112         opts = self.model._meta
1113         app_label = opts.app_label
1114         preserved_filters = self.get_preserved_filters(request)
1115         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1116         view_on_site_url = self.get_view_on_site_url(obj)
1117         has_editable_inline_admin_formsets = False
1118         for inline in context['inline_admin_formsets']:
1119             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1120                 has_editable_inline_admin_formsets = True
1121                 break
1122         context.update({
1123             'add': add,
1124             'change': change,
1125             'has_view_permission': self.has_view_permission(request, obj),
1126             'has_add_permission': self.has_add_permission(request),
1127             'has_change_permission': self.has_change_permission(request, obj),
1128             'has_delete_permission': self.has_delete_permission(request, obj),
1129             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1130             'has_file_field': context['adminform'].form.is_multipart() or any(
1131                 admin_formset.formset.is_multipart()
1132                 for admin_formset in context['inline_admin_formsets']
1133             ),
1134             'has_absolute_url': view_on_site_url is not None,
1135             'absolute_url': view_on_site_url,
1136             'form_url': form_url,
1137             'opts': opts,
1138             'content_type_id': get_content_type_for_model(self.model).pk,
1139             'save_as': self.save_as,
1140             'save_on_top': self.save_on_top,
1141             'to_field_var': TO_FIELD_VAR,
1142             'is_popup_var': IS_POPUP_VAR,
1143             'app_label': app_label,
1144         })
1145         if add and self.add_form_template is not None:
1146             form_template = self.add_form_template
1147         else:
1148             form_template = self.change_form_template
1149 
1150         request.current_app = self.admin_site.name
1151 
1152         return TemplateResponse(request, form_template or [
1153             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1154             "admin/%s/change_form.html" % app_label,
1155             "admin/change_form.html"
1156         ], context)
1157 
1158     def response_add(self, request, obj, post_url_continue=None):
1159         """
1160         Determine the HttpResponse for the add_view stage.
1161         """
1162         opts = obj._meta
1163         preserved_filters = self.get_preserved_filters(request)
1164         obj_url = reverse(
1165             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1166             args=(quote(obj.pk),),
1167             current_app=self.admin_site.name,
1168         )
1169         # Add a link to the object's change form if the user can edit the obj.
1170         if self.has_change_permission(request, obj):
1171             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1172         else:
1173             obj_repr = str(obj)
1174         msg_dict = {
1175             'name': opts.verbose_name,
1176             'obj': obj_repr,
1177         }
1178         # Here, we distinguish between different save types by checking for
1179         # the presence of keys in request.POST.
1180 
1181         if IS_POPUP_VAR in request.POST:
1182             to_field = request.POST.get(TO_FIELD_VAR)
1183             if to_field:
1184                 attr = str(to_field)
1185             else:
1186                 attr = obj._meta.pk.attname
1187             value = obj.serializable_value(attr)
1188             popup_response_data = json.dumps({
1189                 'value': str(value),
1190                 'obj': str(obj),
1191             })
1192             return TemplateResponse(request, self.popup_response_template or [
1193                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1194                 'admin/%s/popup_response.html' % opts.app_label,
1195                 'admin/popup_response.html',
1196             ], {
1197                 'popup_response_data': popup_response_data,
1198             })
1199 
1200         elif "_continue" in request.POST or (
1201                 # Redirecting after "Save as new".
1202                 "_saveasnew" in request.POST and self.save_as_continue and
1203                 self.has_change_permission(request, obj)
1204         ):
1205             msg = _('The {name} "{obj}" was added successfully.')
1206             if self.has_change_permission(request, obj):
1207                 msg += ' ' + _('You may edit it again below.')
1208             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1209             if post_url_continue is None:
1210                 post_url_continue = obj_url
1211             post_url_continue = add_preserved_filters(
1212                 {'preserved_filters': preserved_filters, 'opts': opts},
1213                 post_url_continue
1214             )
1215             return HttpResponseRedirect(post_url_continue)
1216 
1217         elif "_addanother" in request.POST:
1218             msg = format_html(
1219                 _('The {name} "{obj}" was added successfully. You may add another {name} below.'),
1220                 **msg_dict
1221             )
1222             self.message_user(request, msg, messages.SUCCESS)
1223             redirect_url = request.path
1224             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1225             return HttpResponseRedirect(redirect_url)
1226 
1227         else:
1228             msg = format_html(
1229                 _('The {name} "{obj}" was added successfully.'),
1230                 **msg_dict
1231             )
1232             self.message_user(request, msg, messages.SUCCESS)
1233             return self.response_post_save_add(request, obj)
1234 
1235     def response_change(self, request, obj):
1236         """
1237         Determine the HttpResponse for the change_view stage.
1238         """
1239 
1240         if IS_POPUP_VAR in request.POST:
1241             opts = obj._meta
1242             to_field = request.POST.get(TO_FIELD_VAR)
1243             attr = str(to_field) if to_field else opts.pk.attname
1244             value = request.resolver_match.kwargs['object_id']
1245             new_value = obj.serializable_value(attr)
1246             popup_response_data = json.dumps({
1247                 'action': 'change',
1248                 'value': str(value),
1249                 'obj': str(obj),
1250                 'new_value': str(new_value),
1251             })
1252             return TemplateResponse(request, self.popup_response_template or [
1253                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1254                 'admin/%s/popup_response.html' % opts.app_label,
1255                 'admin/popup_response.html',
1256             ], {
1257                 'popup_response_data': popup_response_data,
1258             })
1259 
1260         opts = self.model._meta
1261         preserved_filters = self.get_preserved_filters(request)
1262 
1263         msg_dict = {
1264             'name': opts.verbose_name,
1265             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1266         }
1267         if "_continue" in request.POST:
1268             msg = format_html(
1269                 _('The {name} "{obj}" was changed successfully. You may edit it again below.'),
1270                 **msg_dict
1271             )
1272             self.message_user(request, msg, messages.SUCCESS)
1273             redirect_url = request.path
1274             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1275             return HttpResponseRedirect(redirect_url)
1276 
1277         elif "_saveasnew" in request.POST:
1278             msg = format_html(
1279                 _('The {name} "{obj}" was added successfully. You may edit it again below.'),
1280                 **msg_dict
1281             )
1282             self.message_user(request, msg, messages.SUCCESS)
1283             redirect_url = reverse('admin:%s_%s_change' %
1284                                    (opts.app_label, opts.model_name),
1285                                    args=(obj.pk,),
1286                                    current_app=self.admin_site.name)
1287             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1288             return HttpResponseRedirect(redirect_url)
1289 
1290         elif "_addanother" in request.POST:
1291             msg = format_html(
1292                 _('The {name} "{obj}" was changed successfully. You may add another {name} below.'),
1293                 **msg_dict
1294             )
1295             self.message_user(request, msg, messages.SUCCESS)
1296             redirect_url = reverse('admin:%s_%s_add' %
1297                                    (opts.app_label, opts.model_name),
1298                                    current_app=self.admin_site.name)
1299             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1300             return HttpResponseRedirect(redirect_url)
1301 
1302         else:
1303             msg = format_html(
1304                 _('The {name} "{obj}" was changed successfully.'),
1305                 **msg_dict
1306             )
1307             self.message_user(request, msg, messages.SUCCESS)
1308             return self.response_post_save_change(request, obj)
1309 
1310     def _response_post_save(self, request, obj):
1311         opts = self.model._meta
1312         if self.has_view_or_change_permission(request):
1313             post_url = reverse('admin:%s_%s_changelist' %
1314                                (opts.app_label, opts.model_name),
1315                                current_app=self.admin_site.name)
1316             preserved_filters = self.get_preserved_filters(request)
1317             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1318         else:
1319             post_url = reverse('admin:index',
1320                                current_app=self.admin_site.name)
1321         return HttpResponseRedirect(post_url)
1322 
1323     def response_post_save_add(self, request, obj):
1324         """
1325         Figure out where to redirect after the 'Save' button has been pressed
1326         when adding a new object.
1327         """
1328         return self._response_post_save(request, obj)
1329 
1330     def response_post_save_change(self, request, obj):
1331         """
1332         Figure out where to redirect after the 'Save' button has been pressed
1333         when editing an existing object.
1334         """
1335         return self._response_post_save(request, obj)
1336 
1337     def response_action(self, request, queryset):
1338         """
1339         Handle an admin action. This is called if a request is POSTed to the
1340         changelist; it returns an HttpResponse if the action was handled, and
1341         None otherwise.
1342         """
1343 
1344         # There can be multiple action forms on the page (at the top
1345         # and bottom of the change list, for example). Get the action
1346         # whose button was pushed.
1347         try:
1348             action_index = int(request.POST.get('index', 0))
1349         except ValueError:
1350             action_index = 0
1351 
1352         # Construct the action form.
1353         data = request.POST.copy()
1354         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1355         data.pop("index", None)
1356 
1357         # Use the action whose button was pushed
1358         try:
1359             data.update({'action': data.getlist('action')[action_index]})
1360         except IndexError:
1361             # If we didn't get an action from the chosen form that's invalid
1362             # POST data, so by deleting action it'll fail the validation check
1363             # below. So no need to do anything here
1364             pass
1365 
1366         action_form = self.action_form(data, auto_id=None)
1367         action_form.fields['action'].choices = self.get_action_choices(request)
1368 
1369         # If the form's valid we can handle the action.
1370         if action_form.is_valid():
1371             action = action_form.cleaned_data['action']
1372             select_across = action_form.cleaned_data['select_across']
1373             func = self.get_actions(request)[action][0]
1374 
1375             # Get the list of selected PKs. If nothing's selected, we can't
1376             # perform an action on it, so bail. Except we want to perform
1377             # the action explicitly on all objects.
1378             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1379             if not selected and not select_across:
1380                 # Reminder that something needs to be selected or nothing will happen
1381                 msg = _("Items must be selected in order to perform "
1382                         "actions on them. No items have been changed.")
1383                 self.message_user(request, msg, messages.WARNING)
1384                 return None
1385 
1386             if not select_across:
1387                 # Perform the action only on the selected objects
1388                 queryset = queryset.filter(pk__in=selected)
1389 
1390             response = func(self, request, queryset)
1391 
1392             # Actions may return an HttpResponse-like object, which will be
1393             # used as the response from the POST. If not, we'll be a good
1394             # little HTTP citizen and redirect back to the changelist page.
1395             if isinstance(response, HttpResponseBase):
1396                 return response
1397             else:
1398                 return HttpResponseRedirect(request.get_full_path())
1399         else:
1400             msg = _("No action selected.")
1401             self.message_user(request, msg, messages.WARNING)
1402             return None
1403 
1404     def response_delete(self, request, obj_display, obj_id):
1405         """
1406         Determine the HttpResponse for the delete_view stage.
1407         """
1408         opts = self.model._meta
1409 
1410         if IS_POPUP_VAR in request.POST:
1411             popup_response_data = json.dumps({
1412                 'action': 'delete',
1413                 'value': str(obj_id),
1414             })
1415             return TemplateResponse(request, self.popup_response_template or [
1416                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1417                 'admin/%s/popup_response.html' % opts.app_label,
1418                 'admin/popup_response.html',
1419             ], {
1420                 'popup_response_data': popup_response_data,
1421             })
1422 
1423         self.message_user(
1424             request,
1425             _('The %(name)s "%(obj)s" was deleted successfully.') % {
1426                 'name': opts.verbose_name,
1427                 'obj': obj_display,
1428             },
1429             messages.SUCCESS,
1430         )
1431 
1432         if self.has_change_permission(request, None):
1433             post_url = reverse(
1434                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1435                 current_app=self.admin_site.name,
1436             )
1437             preserved_filters = self.get_preserved_filters(request)
1438             post_url = add_preserved_filters(
1439                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1440             )
1441         else:
1442             post_url = reverse('admin:index', current_app=self.admin_site.name)
1443         return HttpResponseRedirect(post_url)
1444 
1445     def render_delete_form(self, request, context):
1446         opts = self.model._meta
1447         app_label = opts.app_label
1448 
1449         request.current_app = self.admin_site.name
1450         context.update(
1451             to_field_var=TO_FIELD_VAR,
1452             is_popup_var=IS_POPUP_VAR,
1453             media=self.media,
1454         )
1455 
1456         return TemplateResponse(
1457             request,
1458             self.delete_confirmation_template or [
1459                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1460                 "admin/{}/delete_confirmation.html".format(app_label),
1461                 "admin/delete_confirmation.html",
1462             ],
1463             context,
1464         )
1465 
1466     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1467         inline_admin_formsets = []
1468         for inline, formset in zip(inline_instances, formsets):
1469             fieldsets = list(inline.get_fieldsets(request, obj))
1470             readonly = list(inline.get_readonly_fields(request, obj))
1471             has_add_permission = inline.has_add_permission(request, obj)
1472             has_change_permission = inline.has_change_permission(request, obj)
1473             has_delete_permission = inline.has_delete_permission(request, obj)
1474             has_view_permission = inline.has_view_permission(request, obj)
1475             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1476             inline_admin_formset = helpers.InlineAdminFormSet(
1477                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1478                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1479                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1480             )
1481             inline_admin_formsets.append(inline_admin_formset)
1482         return inline_admin_formsets
1483 
1484     def get_changeform_initial_data(self, request):
1485         """
1486         Get the initial form data from the request's GET params.
1487         """
1488         initial = dict(request.GET.items())
1489         for k in initial:
1490             try:
1491                 f = self.model._meta.get_field(k)
1492             except FieldDoesNotExist:
1493                 continue
1494             # We have to special-case M2Ms as a list of comma-separated PKs.
1495             if isinstance(f, models.ManyToManyField):
1496                 initial[k] = initial[k].split(",")
1497         return initial
1498 
1499     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1500         """
1501         Create a message informing the user that the object doesn't exist
1502         and return a redirect to the admin index page.
1503         """
1504         msg = _("""%(name)s with ID "%(key)s" doesn't exist. Perhaps it was deleted?""") % {
1505             'name': opts.verbose_name,
1506             'key': unquote(object_id),
1507         }
1508         self.message_user(request, msg, messages.WARNING)
1509         url = reverse('admin:index', current_app=self.admin_site.name)
1510         return HttpResponseRedirect(url)
1511 
1512     @csrf_protect_m
1513     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1514         with transaction.atomic(using=router.db_for_write(self.model)):
1515             return self._changeform_view(request, object_id, form_url, extra_context)
1516 
1517     def _changeform_view(self, request, object_id, form_url, extra_context):
1518         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1519         if to_field and not self.to_field_allowed(request, to_field):
1520             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1521 
1522         model = self.model
1523         opts = model._meta
1524 
1525         if request.method == 'POST' and '_saveasnew' in request.POST:
1526             object_id = None
1527 
1528         add = object_id is None
1529 
1530         if add:
1531             if not self.has_add_permission(request):
1532                 raise PermissionDenied
1533             obj = None
1534 
1535         else:
1536             obj = self.get_object(request, unquote(object_id), to_field)
1537 
1538             if not self.has_view_or_change_permission(request, obj):
1539                 raise PermissionDenied
1540 
1541             if obj is None:
1542                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1543 
1544         ModelForm = self.get_form(request, obj, change=not add)
1545         if request.method == 'POST':
1546             form = ModelForm(request.POST, request.FILES, instance=obj)
1547             form_validated = form.is_valid()
1548             if form_validated:
1549                 new_object = self.save_form(request, form, change=not add)
1550             else:
1551                 new_object = form.instance
1552             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1553             if all_valid(formsets) and form_validated:
1554                 self.save_model(request, new_object, form, not add)
1555                 self.save_related(request, form, formsets, not add)
1556                 change_message = self.construct_change_message(request, form, formsets, add)
1557                 if add:
1558                     self.log_addition(request, new_object, change_message)
1559                     return self.response_add(request, new_object)
1560                 else:
1561                     self.log_change(request, new_object, change_message)
1562                     return self.response_change(request, new_object)
1563             else:
1564                 form_validated = False
1565         else:
1566             if add:
1567                 initial = self.get_changeform_initial_data(request)
1568                 form = ModelForm(initial=initial)
1569                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1570             else:
1571                 form = ModelForm(instance=obj)
1572                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1573 
1574         if not add and not self.has_change_permission(request, obj):
1575             readonly_fields = flatten_fieldsets(self.get_fieldsets(request, obj))
1576         else:
1577             readonly_fields = self.get_readonly_fields(request, obj)
1578         adminForm = helpers.AdminForm(
1579             form,
1580             list(self.get_fieldsets(request, obj)),
1581             # Clear prepopulated fields on a view-only form to avoid a crash.
1582             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1583             readonly_fields,
1584             model_admin=self)
1585         media = self.media + adminForm.media
1586 
1587         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1588         for inline_formset in inline_formsets:
1589             media = media + inline_formset.media
1590 
1591         if add:
1592             title = _('Add %s')
1593         elif self.has_change_permission(request, obj):
1594             title = _('Change %s')
1595         else:
1596             title = _('View %s')
1597         context = {
1598             **self.admin_site.each_context(request),
1599             'title': title % opts.verbose_name,
1600             'adminform': adminForm,
1601             'object_id': object_id,
1602             'original': obj,
1603             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1604             'to_field': to_field,
1605             'media': media,
1606             'inline_admin_formsets': inline_formsets,
1607             'errors': helpers.AdminErrorList(form, formsets),
1608             'preserved_filters': self.get_preserved_filters(request),
1609         }
1610 
1611         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1612         # previously chosen to prevent the interface from getting confusing.
1613         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1614             context['show_save'] = False
1615             context['show_save_and_continue'] = False
1616             # Use the change template instead of the add template.
1617             add = False
1618 
1619         context.update(extra_context or {})
1620 
1621         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1622 
1623     def autocomplete_view(self, request):
1624         return AutocompleteJsonView.as_view(model_admin=self)(request)
1625 
1626     def add_view(self, request, form_url='', extra_context=None):
1627         return self.changeform_view(request, None, form_url, extra_context)
1628 
1629     def change_view(self, request, object_id, form_url='', extra_context=None):
1630         return self.changeform_view(request, object_id, form_url, extra_context)
1631 
1632     def _get_edited_object_pks(self, request, prefix):
1633         """Return POST data values of list_editable primary keys."""
1634         pk_pattern = re.compile(r'{}-\d+-{}$'.format(prefix, self.model._meta.pk.name))
1635         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1636 
1637     def _get_list_editable_queryset(self, request, prefix):
1638         """
1639         Based on POST data, return a queryset of the objects that were edited
1640         via list_editable.
1641         """
1642         object_pks = self._get_edited_object_pks(request, prefix)
1643         queryset = self.get_queryset(request)
1644         validate = queryset.model._meta.pk.to_python
1645         try:
1646             for pk in object_pks:
1647                 validate(pk)
1648         except ValidationError:
1649             # Disable the optimization if the POST data was tampered with.
1650             return queryset
1651         return queryset.filter(pk__in=object_pks)
1652 
1653     @csrf_protect_m
1654     def changelist_view(self, request, extra_context=None):
1655         """
1656         The 'change list' admin view for this model.
1657         """
1658         from django.contrib.admin.views.main import ERROR_FLAG
1659         opts = self.model._meta
1660         app_label = opts.app_label
1661         if not self.has_view_or_change_permission(request):
1662             raise PermissionDenied
1663 
1664         try:
1665             cl = self.get_changelist_instance(request)
1666         except IncorrectLookupParameters:
1667             # Wacky lookup parameters were given, so redirect to the main
1668             # changelist page, without parameters, and pass an 'invalid=1'
1669             # parameter via the query string. If wacky parameters were given
1670             # and the 'invalid=1' parameter was already in the query string,
1671             # something is screwed up with the database, so display an error
1672             # page.
1673             if ERROR_FLAG in request.GET:
1674                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1675                     'title': _('Database error'),
1676                 })
1677             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1678 
1679         # If the request was POSTed, this might be a bulk action or a bulk
1680         # edit. Try to look up an action or confirmation first, but if this
1681         # isn't an action the POST will fall through to the bulk edit check,
1682         # below.
1683         action_failed = False
1684         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1685 
1686         actions = self.get_actions(request)
1687         # Actions with no confirmation
1688         if (actions and request.method == 'POST' and
1689                 'index' in request.POST and '_save' not in request.POST):
1690             if selected:
1691                 response = self.response_action(request, queryset=cl.get_queryset(request))
1692                 if response:
1693                     return response
1694                 else:
1695                     action_failed = True
1696             else:
1697                 msg = _("Items must be selected in order to perform "
1698                         "actions on them. No items have been changed.")
1699                 self.message_user(request, msg, messages.WARNING)
1700                 action_failed = True
1701 
1702         # Actions with confirmation
1703         if (actions and request.method == 'POST' and
1704                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1705                 'index' not in request.POST and '_save' not in request.POST):
1706             if selected:
1707                 response = self.response_action(request, queryset=cl.get_queryset(request))
1708                 if response:
1709                     return response
1710                 else:
1711                     action_failed = True
1712 
1713         if action_failed:
1714             # Redirect back to the changelist page to avoid resubmitting the
1715             # form if the user refreshes the browser or uses the "No, take
1716             # me back" button on the action confirmation page.
1717             return HttpResponseRedirect(request.get_full_path())
1718 
1719         # If we're allowing changelist editing, we need to construct a formset
1720         # for the changelist given all the fields to be edited. Then we'll
1721         # use the formset to validate/process POSTed data.
1722         formset = cl.formset = None
1723 
1724         # Handle POSTed bulk-edit data.
1725         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1726             if not self.has_change_permission(request):
1727                 raise PermissionDenied
1728             FormSet = self.get_changelist_formset(request)
1729             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1730             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1731             if formset.is_valid():
1732                 changecount = 0
1733                 for form in formset.forms:
1734                     if form.has_changed():
1735                         obj = self.save_form(request, form, change=True)
1736                         self.save_model(request, obj, form, change=True)
1737                         self.save_related(request, form, formsets=[], change=True)
1738                         change_msg = self.construct_change_message(request, form, None)
1739                         self.log_change(request, obj, change_msg)
1740                         changecount += 1
1741 
1742                 if changecount:
1743                     msg = ngettext(
1744                         "%(count)s %(name)s was changed successfully.",
1745                         "%(count)s %(name)s were changed successfully.",
1746                         changecount
1747                     ) % {
1748                         'count': changecount,
1749                         'name': model_ngettext(opts, changecount),
1750                     }
1751                     self.message_user(request, msg, messages.SUCCESS)
1752 
1753                 return HttpResponseRedirect(request.get_full_path())
1754 
1755         # Handle GET -- construct a formset for display.
1756         elif cl.list_editable and self.has_change_permission(request):
1757             FormSet = self.get_changelist_formset(request)
1758             formset = cl.formset = FormSet(queryset=cl.result_list)
1759 
1760         # Build the list of media to be used by the formset.
1761         if formset:
1762             media = self.media + formset.media
1763         else:
1764             media = self.media
1765 
1766         # Build the action form and populate it with available actions.
1767         if actions:
1768             action_form = self.action_form(auto_id=None)
1769             action_form.fields['action'].choices = self.get_action_choices(request)
1770             media += action_form.media
1771         else:
1772             action_form = None
1773 
1774         selection_note_all = ngettext(
1775             '%(total_count)s selected',
1776             'All %(total_count)s selected',
1777             cl.result_count
1778         )
1779 
1780         context = {
1781             **self.admin_site.each_context(request),
1782             'module_name': str(opts.verbose_name_plural),
1783             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1784             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1785             'title': cl.title,
1786             'is_popup': cl.is_popup,
1787             'to_field': cl.to_field,
1788             'cl': cl,
1789             'media': media,
1790             'has_add_permission': self.has_add_permission(request),
1791             'opts': cl.opts,
1792             'action_form': action_form,
1793             'actions_on_top': self.actions_on_top,
1794             'actions_on_bottom': self.actions_on_bottom,
1795             'actions_selection_counter': self.actions_selection_counter,
1796             'preserved_filters': self.get_preserved_filters(request),
1797             **(extra_context or {}),
1798         }
1799 
1800         request.current_app = self.admin_site.name
1801 
1802         return TemplateResponse(request, self.change_list_template or [
1803             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1804             'admin/%s/change_list.html' % app_label,
1805             'admin/change_list.html'
1806         ], context)
1807 
1808     def get_deleted_objects(self, objs, request):
1809         """
1810         Hook for customizing the delete process for the delete view and the
1811         "delete selected" action.
1812         """
1813         return get_deleted_objects(objs, request, self.admin_site)
1814 
1815     @csrf_protect_m
1816     def delete_view(self, request, object_id, extra_context=None):
1817         with transaction.atomic(using=router.db_for_write(self.model)):
1818             return self._delete_view(request, object_id, extra_context)
1819 
1820     def _delete_view(self, request, object_id, extra_context):
1821         "The 'delete' admin view for this model."
1822         opts = self.model._meta
1823         app_label = opts.app_label
1824 
1825         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1826         if to_field and not self.to_field_allowed(request, to_field):
1827             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1828 
1829         obj = self.get_object(request, unquote(object_id), to_field)
1830 
1831         if not self.has_delete_permission(request, obj):
1832             raise PermissionDenied
1833 
1834         if obj is None:
1835             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1836 
1837         # Populate deleted_objects, a data structure of all related objects that
1838         # will also be deleted.
1839         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1840 
1841         if request.POST and not protected:  # The user has confirmed the deletion.
1842             if perms_needed:
1843                 raise PermissionDenied
1844             obj_display = str(obj)
1845             attr = str(to_field) if to_field else opts.pk.attname
1846             obj_id = obj.serializable_value(attr)
1847             self.log_deletion(request, obj, obj_display)
1848             self.delete_model(request, obj)
1849 
1850             return self.response_delete(request, obj_display, obj_id)
1851 
1852         object_name = str(opts.verbose_name)
1853 
1854         if perms_needed or protected:
1855             title = _("Cannot delete %(name)s") % {"name": object_name}
1856         else:
1857             title = _("Are you sure?")
1858 
1859         context = {
1860             **self.admin_site.each_context(request),
1861             'title': title,
1862             'object_name': object_name,
1863             'object': obj,
1864             'deleted_objects': deleted_objects,
1865             'model_count': dict(model_count).items(),
1866             'perms_lacking': perms_needed,
1867             'protected': protected,
1868             'opts': opts,
1869             'app_label': app_label,
1870             'preserved_filters': self.get_preserved_filters(request),
1871             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1872             'to_field': to_field,
1873             **(extra_context or {}),
1874         }
1875 
1876         return self.render_delete_form(request, context)
1877 
1878     def history_view(self, request, object_id, extra_context=None):
1879         "The 'history' admin view for this model."
1880         from django.contrib.admin.models import LogEntry
1881         # First check if the user can see this history.
1882         model = self.model
1883         obj = self.get_object(request, unquote(object_id))
1884         if obj is None:
1885             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1886 
1887         if not self.has_view_or_change_permission(request, obj):
1888             raise PermissionDenied
1889 
1890         # Then get the history for this object.
1891         opts = model._meta
1892         app_label = opts.app_label
1893         action_list = LogEntry.objects.filter(
1894             object_id=unquote(object_id),
1895             content_type=get_content_type_for_model(model)
1896         ).select_related().order_by('action_time')
1897 
1898         context = {
1899             **self.admin_site.each_context(request),
1900             'title': _('Change history: %s') % obj,
1901             'action_list': action_list,
1902             'module_name': str(capfirst(opts.verbose_name_plural)),
1903             'object': obj,
1904             'opts': opts,
1905             'preserved_filters': self.get_preserved_filters(request),
1906             **(extra_context or {}),
1907         }
1908 
1909         request.current_app = self.admin_site.name
1910 
1911         return TemplateResponse(request, self.object_history_template or [
1912             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1913             "admin/%s/object_history.html" % app_label,
1914             "admin/object_history.html"
1915         ], context)
1916 
1917     def _create_formsets(self, request, obj, change):
1918         "Helper function to generate formsets for add/change_view."
1919         formsets = []
1920         inline_instances = []
1921         prefixes = {}
1922         get_formsets_args = [request]
1923         if change:
1924             get_formsets_args.append(obj)
1925         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1926             prefix = FormSet.get_default_prefix()
1927             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1928             if prefixes[prefix] != 1 or not prefix:
1929                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1930             formset_params = {
1931                 'instance': obj,
1932                 'prefix': prefix,
1933                 'queryset': inline.get_queryset(request),
1934             }
1935             if request.method == 'POST':
1936                 formset_params.update({
1937                     'data': request.POST.copy(),
1938                     'files': request.FILES,
1939                     'save_as_new': '_saveasnew' in request.POST
1940                 })
1941             formset = FormSet(**formset_params)
1942 
1943             def user_deleted_form(request, obj, formset, index):
1944                 """Return whether or not the user deleted the form."""
1945                 return (
1946                     inline.has_delete_permission(request, obj) and
1947                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1948                 )
1949 
1950             # Bypass validation of each view-only inline form (since the form's
1951             # data won't be in request.POST), unless the form was deleted.
1952             if not inline.has_change_permission(request, obj if change else None):
1953                 for index, form in enumerate(formset.initial_forms):
1954                     if user_deleted_form(request, obj, formset, index):
1955                         continue
1956                     form._errors = {}
1957                     form.cleaned_data = form.initial
1958             formsets.append(formset)
1959             inline_instances.append(inline)
1960         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 03:01:04.818 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 03:01:04.818 | INFO     | Search-only: skipping patch selection
2025-10-15 03:01:05.070 | INFO     | Task django__django-10531 completed successfully.
2025-10-15 03:01:05.071 | INFO     | No patch generated. You can try running ACR again.
