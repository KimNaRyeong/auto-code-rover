[
    {
        "rel_file_path": "django/db/models/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/base.py",
        "start": 903,
        "end": 945,
        "class_name": null,
        "method_name": "_save_parents",
        "code": "903     def _save_parents(self, cls, using, update_fields, updated_parents=None):\n904         \"\"\"Save all the parents of cls using values from self.\"\"\"\n905         meta = cls._meta\n906         inserted = False\n907         if updated_parents is None:\n908             updated_parents = {}\n909         for parent, field in meta.parents.items():\n910             # Make sure the link fields are synced between parent and self.\n911             if (\n912                 field\n913                 and getattr(self, parent._meta.pk.attname) is None\n914                 and getattr(self, field.attname) is not None\n915             ):\n916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n917             if (parent_updated := updated_parents.get(parent)) is None:\n918                 parent_inserted = self._save_parents(\n919                     cls=parent,\n920                     using=using,\n921                     update_fields=update_fields,\n922                     updated_parents=updated_parents,\n923                 )\n924                 updated = self._save_table(\n925                     cls=parent,\n926                     using=using,\n927                     update_fields=update_fields,\n928                     force_insert=parent_inserted,\n929                 )\n930                 if not updated:\n931                     inserted = True\n932                 updated_parents[parent] = updated\n933             elif not parent_updated:\n934                 inserted = True\n935             # Set the parent's PK value to self.\n936             if field:\n937                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n938                 # Since we didn't have an instance of the parent handy set\n939                 # attname directly, bypassing the descriptor. Invalidate\n940                 # the related object cache, in case it's been accidentally\n941                 # populated. A fresh instance will be re-built from the\n942                 # database if necessary.\n943                 if field.is_cached(self):\n944                     field.delete_cached_value(self)\n945         return inserted\n",
        "intended_behavior": "This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it."
    },
    {
        "rel_file_path": "django/db/models/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/base.py",
        "start": 903,
        "end": 945,
        "class_name": "Model",
        "method_name": "_save_parents",
        "code": "903     def _save_parents(self, cls, using, update_fields, updated_parents=None):\n904         \"\"\"Save all the parents of cls using values from self.\"\"\"\n905         meta = cls._meta\n906         inserted = False\n907         if updated_parents is None:\n908             updated_parents = {}\n909         for parent, field in meta.parents.items():\n910             # Make sure the link fields are synced between parent and self.\n911             if (\n912                 field\n913                 and getattr(self, parent._meta.pk.attname) is None\n914                 and getattr(self, field.attname) is not None\n915             ):\n916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n917             if (parent_updated := updated_parents.get(parent)) is None:\n918                 parent_inserted = self._save_parents(\n919                     cls=parent,\n920                     using=using,\n921                     update_fields=update_fields,\n922                     updated_parents=updated_parents,\n923                 )\n924                 updated = self._save_table(\n925                     cls=parent,\n926                     using=using,\n927                     update_fields=update_fields,\n928                     force_insert=parent_inserted,\n929                 )\n930                 if not updated:\n931                     inserted = True\n932                 updated_parents[parent] = updated\n933             elif not parent_updated:\n934                 inserted = True\n935             # Set the parent's PK value to self.\n936             if field:\n937                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n938                 # Since we didn't have an instance of the parent handy set\n939                 # attname directly, bypassing the descriptor. Invalidate\n940                 # the related object cache, in case it's been accidentally\n941                 # populated. A fresh instance will be re-built from the\n942                 # database if necessary.\n943                 if field.is_cached(self):\n944                     field.delete_cached_value(self)\n945         return inserted\n",
        "intended_behavior": "This method needs to ensure that when saving objects with nested multi-table inheritance, all parent objects are correctly identified and saved without errors. The `_save_parents` method should include a more robust handling mechanism for fields especially when dealing with objects that have complex inheritance chains, ensuring that fields like the `OneToOneField` used to link parent and child models in MTI setups have their attributes like `attname` correctly accessed and processed. This may involve catching exceptions where `attname` is not found and either providing a fallback method of identifying the field or ensuring that the model's meta information is fully prepared before `_save_parents` attempts to process it."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/fields/related.py",
        "start": 1,
        "end": 2005,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 import warnings\n4 from functools import partial\n5 \n6 from django import forms\n7 from django.apps import apps\n8 from django.conf import SettingsReference, settings\n9 from django.core import checks, exceptions\n10 from django.db import connection, router\n11 from django.db.backends import utils\n12 from django.db.models import Q\n13 from django.db.models.constants import LOOKUP_SEP\n14 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n15 from django.db.models.query_utils import PathInfo\n16 from django.db.models.utils import make_model_tuple\n17 from django.utils.deprecation import RemovedInDjango60Warning\n18 from django.utils.functional import cached_property\n19 from django.utils.translation import gettext_lazy as _\n20 \n21 from . import Field\n22 from .mixins import FieldCacheMixin\n23 from .related_descriptors import (\n24     ForeignKeyDeferredAttribute,\n25     ForwardManyToOneDescriptor,\n26     ForwardOneToOneDescriptor,\n27     ManyToManyDescriptor,\n28     ReverseManyToOneDescriptor,\n29     ReverseOneToOneDescriptor,\n30 )\n31 from .related_lookups import (\n32     RelatedExact,\n33     RelatedGreaterThan,\n34     RelatedGreaterThanOrEqual,\n35     RelatedIn,\n36     RelatedIsNull,\n37     RelatedLessThan,\n38     RelatedLessThanOrEqual,\n39 )\n40 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel\n41 \n42 RECURSIVE_RELATIONSHIP_CONSTANT = \"self\"\n43 \n44 \n45 def resolve_relation(scope_model, relation):\n46     \"\"\"\n47     Transform relation into a model or fully-qualified model string of the form\n48     \"app_label.ModelName\", relative to scope_model.\n49 \n50     The relation argument can be:\n51       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n52         the model argument will be returned.\n53       * A bare model name without an app_label, in which case scope_model's\n54         app_label will be prepended.\n55       * An \"app_label.ModelName\" string.\n56       * A model class, which will be returned unchanged.\n57     \"\"\"\n58     # Check for recursive relations\n59     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n60         relation = scope_model\n61 \n62     # Look for an \"app.Model\" relation\n63     if isinstance(relation, str):\n64         if \".\" not in relation:\n65             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n66 \n67     return relation\n68 \n69 \n70 def lazy_related_operation(function, model, *related_models, **kwargs):\n71     \"\"\"\n72     Schedule `function` to be called once `model` and all `related_models`\n73     have been imported and registered with the app registry. `function` will\n74     be called with the newly-loaded model classes as its positional arguments,\n75     plus any optional keyword arguments.\n76 \n77     The `model` argument must be a model class. Each subsequent positional\n78     argument is another model, or a reference to another model - see\n79     `resolve_relation()` for the various forms these may take. Any relative\n80     references will be resolved relative to `model`.\n81 \n82     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n83     registry model used is the one found in `model._meta.apps`.\n84     \"\"\"\n85     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n86     model_keys = (make_model_tuple(m) for m in models)\n87     apps = model._meta.apps\n88     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n89 \n90 \n91 class RelatedField(FieldCacheMixin, Field):\n92     \"\"\"Base class that all relational fields inherit from.\"\"\"\n93 \n94     # Field flags\n95     one_to_many = False\n96     one_to_one = False\n97     many_to_many = False\n98     many_to_one = False\n99 \n100     def __init__(\n101         self,\n102         related_name=None,\n103         related_query_name=None,\n104         limit_choices_to=None,\n105         **kwargs,\n106     ):\n107         self._related_name = related_name\n108         self._related_query_name = related_query_name\n109         self._limit_choices_to = limit_choices_to\n110         super().__init__(**kwargs)\n111 \n112     @cached_property\n113     def related_model(self):\n114         # Can't cache this property until all the models are loaded.\n115         apps.check_models_ready()\n116         return self.remote_field.model\n117 \n118     def check(self, **kwargs):\n119         return [\n120             *super().check(**kwargs),\n121             *self._check_related_name_is_valid(),\n122             *self._check_related_query_name_is_valid(),\n123             *self._check_relation_model_exists(),\n124             *self._check_referencing_to_swapped_model(),\n125             *self._check_clashes(),\n126         ]\n127 \n128     def _check_related_name_is_valid(self):\n129         import keyword\n130 \n131         related_name = self.remote_field.related_name\n132         if related_name is None:\n133             return []\n134         is_valid_id = (\n135             not keyword.iskeyword(related_name) and related_name.isidentifier()\n136         )\n137         if not (is_valid_id or related_name.endswith(\"+\")):\n138             return [\n139                 checks.Error(\n140                     \"The name '%s' is invalid related_name for field %s.%s\"\n141                     % (\n142                         self.remote_field.related_name,\n143                         self.model._meta.object_name,\n144                         self.name,\n145                     ),\n146                     hint=(\n147                         \"Related name must be a valid Python identifier or end with a \"\n148                         \"'+'\"\n149                     ),\n150                     obj=self,\n151                     id=\"fields.E306\",\n152                 )\n153             ]\n154         return []\n155 \n156     def _check_related_query_name_is_valid(self):\n157         if self.remote_field.is_hidden():\n158             return []\n159         rel_query_name = self.related_query_name()\n160         errors = []\n161         if rel_query_name.endswith(\"_\"):\n162             errors.append(\n163                 checks.Error(\n164                     \"Reverse query name '%s' must not end with an underscore.\"\n165                     % rel_query_name,\n166                     hint=(\n167                         \"Add or change a related_name or related_query_name \"\n168                         \"argument for this field.\"\n169                     ),\n170                     obj=self,\n171                     id=\"fields.E308\",\n172                 )\n173             )\n174         if LOOKUP_SEP in rel_query_name:\n175             errors.append(\n176                 checks.Error(\n177                     \"Reverse query name '%s' must not contain '%s'.\"\n178                     % (rel_query_name, LOOKUP_SEP),\n179                     hint=(\n180                         \"Add or change a related_name or related_query_name \"\n181                         \"argument for this field.\"\n182                     ),\n183                     obj=self,\n184                     id=\"fields.E309\",\n185                 )\n186             )\n187         return errors\n188 \n189     def _check_relation_model_exists(self):\n190         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n191         rel_is_string = isinstance(self.remote_field.model, str)\n192         model_name = (\n193             self.remote_field.model\n194             if rel_is_string\n195             else self.remote_field.model._meta.object_name\n196         )\n197         if rel_is_missing and (\n198             rel_is_string or not self.remote_field.model._meta.swapped\n199         ):\n200             return [\n201                 checks.Error(\n202                     \"Field defines a relation with model '%s', which is either \"\n203                     \"not installed, or is abstract.\" % model_name,\n204                     obj=self,\n205                     id=\"fields.E300\",\n206                 )\n207             ]\n208         return []\n209 \n210     def _check_referencing_to_swapped_model(self):\n211         if (\n212             self.remote_field.model not in self.opts.apps.get_models()\n213             and not isinstance(self.remote_field.model, str)\n214             and self.remote_field.model._meta.swapped\n215         ):\n216             return [\n217                 checks.Error(\n218                     \"Field defines a relation with the model '%s', which has \"\n219                     \"been swapped out.\" % self.remote_field.model._meta.label,\n220                     hint=\"Update the relation to point at 'settings.%s'.\"\n221                     % self.remote_field.model._meta.swappable,\n222                     obj=self,\n223                     id=\"fields.E301\",\n224                 )\n225             ]\n226         return []\n227 \n228     def _check_clashes(self):\n229         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n230         from django.db.models.base import ModelBase\n231 \n232         errors = []\n233         opts = self.model._meta\n234 \n235         # f.remote_field.model may be a string instead of a model. Skip if\n236         # model name is not resolved.\n237         if not isinstance(self.remote_field.model, ModelBase):\n238             return []\n239 \n240         # Consider that we are checking field `Model.foreign` and the models\n241         # are:\n242         #\n243         #     class Target(models.Model):\n244         #         model = models.IntegerField()\n245         #         model_set = models.IntegerField()\n246         #\n247         #     class Model(models.Model):\n248         #         foreign = models.ForeignKey(Target)\n249         #         m2m = models.ManyToManyField(Target)\n250 \n251         # rel_opts.object_name == \"Target\"\n252         rel_opts = self.remote_field.model._meta\n253         # If the field doesn't install a backward relation on the target model\n254         # (so `is_hidden` returns True), then there are no clashes to check\n255         # and we can skip these fields.\n256         rel_is_hidden = self.remote_field.is_hidden()\n257         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n258         rel_query_name = self.related_query_name()  # i. e. \"model\"\n259         # i.e. \"app_label.Model.field\".\n260         field_name = \"%s.%s\" % (opts.label, self.name)\n261 \n262         # Check clashes between accessor or reverse query name of `field`\n263         # and any other field name -- i.e. accessor for Model.foreign is\n264         # model_set and it clashes with Target.model_set.\n265         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n266         for clash_field in potential_clashes:\n267             # i.e. \"app_label.Target.model_set\".\n268             clash_name = \"%s.%s\" % (rel_opts.label, clash_field.name)\n269             if not rel_is_hidden and clash_field.name == rel_name:\n270                 errors.append(\n271                     checks.Error(\n272                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n273                         f\"for '{field_name}' clashes with field name \"\n274                         f\"'{clash_name}'.\",\n275                         hint=(\n276                             \"Rename field '%s', or add/change a related_name \"\n277                             \"argument to the definition for field '%s'.\"\n278                         )\n279                         % (clash_name, field_name),\n280                         obj=self,\n281                         id=\"fields.E302\",\n282                     )\n283                 )\n284 \n285             if clash_field.name == rel_query_name:\n286                 errors.append(\n287                     checks.Error(\n288                         \"Reverse query name for '%s' clashes with field name '%s'.\"\n289                         % (field_name, clash_name),\n290                         hint=(\n291                             \"Rename field '%s', or add/change a related_name \"\n292                             \"argument to the definition for field '%s'.\"\n293                         )\n294                         % (clash_name, field_name),\n295                         obj=self,\n296                         id=\"fields.E303\",\n297                     )\n298                 )\n299 \n300         # Check clashes between accessors/reverse query names of `field` and\n301         # any other field accessor -- i. e. Model.foreign accessor clashes with\n302         # Model.m2m accessor.\n303         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n304         for clash_field in potential_clashes:\n305             # i.e. \"app_label.Model.m2m\".\n306             clash_name = \"%s.%s\" % (\n307                 clash_field.related_model._meta.label,\n308                 clash_field.field.name,\n309             )\n310             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n311                 errors.append(\n312                     checks.Error(\n313                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n314                         f\"for '{field_name}' clashes with reverse accessor for \"\n315                         f\"'{clash_name}'.\",\n316                         hint=(\n317                             \"Add or change a related_name argument \"\n318                             \"to the definition for '%s' or '%s'.\"\n319                         )\n320                         % (field_name, clash_name),\n321                         obj=self,\n322                         id=\"fields.E304\",\n323                     )\n324                 )\n325 \n326             if clash_field.get_accessor_name() == rel_query_name:\n327                 errors.append(\n328                     checks.Error(\n329                         \"Reverse query name for '%s' clashes with reverse query name \"\n330                         \"for '%s'.\" % (field_name, clash_name),\n331                         hint=(\n332                             \"Add or change a related_name argument \"\n333                             \"to the definition for '%s' or '%s'.\"\n334                         )\n335                         % (field_name, clash_name),\n336                         obj=self,\n337                         id=\"fields.E305\",\n338                     )\n339                 )\n340 \n341         return errors\n342 \n343     def db_type(self, connection):\n344         # By default related field will not have a column as it relates to\n345         # columns from another table.\n346         return None\n347 \n348     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n349         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n350 \n351         self.opts = cls._meta\n352 \n353         if not cls._meta.abstract:\n354             if self.remote_field.related_name:\n355                 related_name = self.remote_field.related_name\n356             else:\n357                 related_name = self.opts.default_related_name\n358             if related_name:\n359                 related_name %= {\n360                     \"class\": cls.__name__.lower(),\n361                     \"model_name\": cls._meta.model_name.lower(),\n362                     \"app_label\": cls._meta.app_label.lower(),\n363                 }\n364                 self.remote_field.related_name = related_name\n365 \n366             if self.remote_field.related_query_name:\n367                 related_query_name = self.remote_field.related_query_name % {\n368                     \"class\": cls.__name__.lower(),\n369                     \"app_label\": cls._meta.app_label.lower(),\n370                 }\n371                 self.remote_field.related_query_name = related_query_name\n372 \n373             def resolve_related_class(model, related, field):\n374                 field.remote_field.model = related\n375                 field.do_related_class(related, model)\n376 \n377             lazy_related_operation(\n378                 resolve_related_class, cls, self.remote_field.model, field=self\n379             )\n380 \n381     def deconstruct(self):\n382         name, path, args, kwargs = super().deconstruct()\n383         if self._limit_choices_to:\n384             kwargs[\"limit_choices_to\"] = self._limit_choices_to\n385         if self._related_name is not None:\n386             kwargs[\"related_name\"] = self._related_name\n387         if self._related_query_name is not None:\n388             kwargs[\"related_query_name\"] = self._related_query_name\n389         return name, path, args, kwargs\n390 \n391     def get_forward_related_filter(self, obj):\n392         \"\"\"\n393         Return the keyword arguments that when supplied to\n394         self.model.object.filter(), would select all instances related through\n395         this field to the remote obj. This is used to build the querysets\n396         returned by related descriptors. obj is an instance of\n397         self.related_field.model.\n398         \"\"\"\n399         return {\n400             \"%s__%s\" % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n401             for _, rh_field in self.related_fields\n402         }\n403 \n404     def get_reverse_related_filter(self, obj):\n405         \"\"\"\n406         Complement to get_forward_related_filter(). Return the keyword\n407         arguments that when passed to self.related_field.model.object.filter()\n408         select all instances of self.related_field.model related through\n409         this field to obj. obj is an instance of self.model.\n410         \"\"\"\n411         base_q = Q.create(\n412             [\n413                 (rh_field.attname, getattr(obj, lh_field.attname))\n414                 for lh_field, rh_field in self.related_fields\n415             ]\n416         )\n417         descriptor_filter = self.get_extra_descriptor_filter(obj)\n418         if isinstance(descriptor_filter, dict):\n419             return base_q & Q(**descriptor_filter)\n420         elif descriptor_filter:\n421             return base_q & descriptor_filter\n422         return base_q\n423 \n424     @property\n425     def swappable_setting(self):\n426         \"\"\"\n427         Get the setting that this is powered from for swapping, or None\n428         if it's not swapped in / marked with swappable=False.\n429         \"\"\"\n430         if self.swappable:\n431             # Work out string form of \"to\"\n432             if isinstance(self.remote_field.model, str):\n433                 to_string = self.remote_field.model\n434             else:\n435                 to_string = self.remote_field.model._meta.label\n436             return apps.get_swappable_settings_name(to_string)\n437         return None\n438 \n439     def set_attributes_from_rel(self):\n440         self.name = self.name or (\n441             self.remote_field.model._meta.model_name\n442             + \"_\"\n443             + self.remote_field.model._meta.pk.name\n444         )\n445         if self.verbose_name is None:\n446             self.verbose_name = self.remote_field.model._meta.verbose_name\n447         self.remote_field.set_field_name()\n448 \n449     def do_related_class(self, other, cls):\n450         self.set_attributes_from_rel()\n451         self.contribute_to_related_class(other, self.remote_field)\n452 \n453     def get_limit_choices_to(self):\n454         \"\"\"\n455         Return ``limit_choices_to`` for this model field.\n456 \n457         If it is a callable, it will be invoked and the result will be\n458         returned.\n459         \"\"\"\n460         if callable(self.remote_field.limit_choices_to):\n461             return self.remote_field.limit_choices_to()\n462         return self.remote_field.limit_choices_to\n463 \n464     def formfield(self, **kwargs):\n465         \"\"\"\n466         Pass ``limit_choices_to`` to the field being constructed.\n467 \n468         Only passes it if there is a type that supports related fields.\n469         This is a similar strategy used to pass the ``queryset`` to the field\n470         being constructed.\n471         \"\"\"\n472         defaults = {}\n473         if hasattr(self.remote_field, \"get_related_field\"):\n474             # If this is a callable, do not invoke it here. Just pass\n475             # it in the defaults for when the form class will later be\n476             # instantiated.\n477             limit_choices_to = self.remote_field.limit_choices_to\n478             defaults.update(\n479                 {\n480                     \"limit_choices_to\": limit_choices_to,\n481                 }\n482             )\n483         defaults.update(kwargs)\n484         return super().formfield(**defaults)\n485 \n486     def related_query_name(self):\n487         \"\"\"\n488         Define the name that can be used to identify this related object in a\n489         table-spanning query.\n490         \"\"\"\n491         return (\n492             self.remote_field.related_query_name\n493             or self.remote_field.related_name\n494             or self.opts.model_name\n495         )\n496 \n497     @property\n498     def target_field(self):\n499         \"\"\"\n500         When filtering against this relation, return the field on the remote\n501         model against which the filtering should happen.\n502         \"\"\"\n503         target_fields = self.path_infos[-1].target_fields\n504         if len(target_fields) > 1:\n505             raise exceptions.FieldError(\n506                 \"The relation has multiple target fields, but only single target field \"\n507                 \"was asked for\"\n508             )\n509         return target_fields[0]\n510 \n511     def get_cache_name(self):\n512         return self.name\n513 \n514 \n515 class ForeignObject(RelatedField):\n516     \"\"\"\n517     Abstraction of the ForeignKey relation to support multi-column relations.\n518     \"\"\"\n519 \n520     # Field flags\n521     many_to_many = False\n522     many_to_one = True\n523     one_to_many = False\n524     one_to_one = False\n525 \n526     requires_unique_target = True\n527     related_accessor_class = ReverseManyToOneDescriptor\n528     forward_related_accessor_class = ForwardManyToOneDescriptor\n529     rel_class = ForeignObjectRel\n530 \n531     def __init__(\n532         self,\n533         to,\n534         on_delete,\n535         from_fields,\n536         to_fields,\n537         rel=None,\n538         related_name=None,\n539         related_query_name=None,\n540         limit_choices_to=None,\n541         parent_link=False,\n542         swappable=True,\n543         **kwargs,\n544     ):\n545         if rel is None:\n546             rel = self.rel_class(\n547                 self,\n548                 to,\n549                 related_name=related_name,\n550                 related_query_name=related_query_name,\n551                 limit_choices_to=limit_choices_to,\n552                 parent_link=parent_link,\n553                 on_delete=on_delete,\n554             )\n555 \n556         super().__init__(\n557             rel=rel,\n558             related_name=related_name,\n559             related_query_name=related_query_name,\n560             limit_choices_to=limit_choices_to,\n561             **kwargs,\n562         )\n563 \n564         self.from_fields = from_fields\n565         self.to_fields = to_fields\n566         self.swappable = swappable\n567 \n568     def __copy__(self):\n569         obj = super().__copy__()\n570         # Remove any cached PathInfo values.\n571         obj.__dict__.pop(\"path_infos\", None)\n572         obj.__dict__.pop(\"reverse_path_infos\", None)\n573         return obj\n574 \n575     def check(self, **kwargs):\n576         return [\n577             *super().check(**kwargs),\n578             *self._check_to_fields_exist(),\n579             *self._check_unique_target(),\n580         ]\n581 \n582     def _check_to_fields_exist(self):\n583         # Skip nonexistent models.\n584         if isinstance(self.remote_field.model, str):\n585             return []\n586 \n587         errors = []\n588         for to_field in self.to_fields:\n589             if to_field:\n590                 try:\n591                     self.remote_field.model._meta.get_field(to_field)\n592                 except exceptions.FieldDoesNotExist:\n593                     errors.append(\n594                         checks.Error(\n595                             \"The to_field '%s' doesn't exist on the related \"\n596                             \"model '%s'.\"\n597                             % (to_field, self.remote_field.model._meta.label),\n598                             obj=self,\n599                             id=\"fields.E312\",\n600                         )\n601                     )\n602         return errors\n603 \n604     def _check_unique_target(self):\n605         rel_is_string = isinstance(self.remote_field.model, str)\n606         if rel_is_string or not self.requires_unique_target:\n607             return []\n608 \n609         try:\n610             self.foreign_related_fields\n611         except exceptions.FieldDoesNotExist:\n612             return []\n613 \n614         if not self.foreign_related_fields:\n615             return []\n616 \n617         unique_foreign_fields = {\n618             frozenset([f.name])\n619             for f in self.remote_field.model._meta.get_fields()\n620             if getattr(f, \"unique\", False)\n621         }\n622         unique_foreign_fields.update(\n623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}\n624         )\n625         unique_foreign_fields.update(\n626             {\n627                 frozenset(uc.fields)\n628                 for uc in self.remote_field.model._meta.total_unique_constraints\n629             }\n630         )\n631         foreign_fields = {f.name for f in self.foreign_related_fields}\n632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n633 \n634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n635             field_combination = \", \".join(\n636                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n637             )\n638             model_name = self.remote_field.model.__name__\n639             return [\n640                 checks.Error(\n641                     \"No subset of the fields %s on model '%s' is unique.\"\n642                     % (field_combination, model_name),\n643                     hint=(\n644                         \"Mark a single field as unique=True or add a set of \"\n645                         \"fields to a unique constraint (via unique_together \"\n646                         \"or a UniqueConstraint (without condition) in the \"\n647                         \"model Meta.constraints).\"\n648                     ),\n649                     obj=self,\n650                     id=\"fields.E310\",\n651                 )\n652             ]\n653         elif not has_unique_constraint:\n654             field_name = self.foreign_related_fields[0].name\n655             model_name = self.remote_field.model.__name__\n656             return [\n657                 checks.Error(\n658                     \"'%s.%s' must be unique because it is referenced by \"\n659                     \"a foreign key.\" % (model_name, field_name),\n660                     hint=(\n661                         \"Add unique=True to this field or add a \"\n662                         \"UniqueConstraint (without condition) in the model \"\n663                         \"Meta.constraints.\"\n664                     ),\n665                     obj=self,\n666                     id=\"fields.E311\",\n667                 )\n668             ]\n669         else:\n670             return []\n671 \n672     def deconstruct(self):\n673         name, path, args, kwargs = super().deconstruct()\n674         kwargs[\"on_delete\"] = self.remote_field.on_delete\n675         kwargs[\"from_fields\"] = self.from_fields\n676         kwargs[\"to_fields\"] = self.to_fields\n677 \n678         if self.remote_field.parent_link:\n679             kwargs[\"parent_link\"] = self.remote_field.parent_link\n680         if isinstance(self.remote_field.model, str):\n681             if \".\" in self.remote_field.model:\n682                 app_label, model_name = self.remote_field.model.split(\".\")\n683                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n684             else:\n685                 kwargs[\"to\"] = self.remote_field.model.lower()\n686         else:\n687             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n688         # If swappable is True, then see if we're actually pointing to the target\n689         # of a swap.\n690         swappable_setting = self.swappable_setting\n691         if swappable_setting is not None:\n692             # If it's already a settings reference, error\n693             if hasattr(kwargs[\"to\"], \"setting_name\"):\n694                 if kwargs[\"to\"].setting_name != swappable_setting:\n695                     raise ValueError(\n696                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n697                         \"that is swapped in place of more than one model (%s and %s)\"\n698                         % (kwargs[\"to\"].setting_name, swappable_setting)\n699                     )\n700             # Set it\n701             kwargs[\"to\"] = SettingsReference(\n702                 kwargs[\"to\"],\n703                 swappable_setting,\n704             )\n705         return name, path, args, kwargs\n706 \n707     def resolve_related_fields(self):\n708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n709             raise ValueError(\n710                 \"Foreign Object from and to fields must be the same non-zero length\"\n711             )\n712         if isinstance(self.remote_field.model, str):\n713             raise ValueError(\n714                 \"Related model %r cannot be resolved\" % self.remote_field.model\n715             )\n716         related_fields = []\n717         for index in range(len(self.from_fields)):\n718             from_field_name = self.from_fields[index]\n719             to_field_name = self.to_fields[index]\n720             from_field = (\n721                 self\n722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n723                 else self.opts.get_field(from_field_name)\n724             )\n725             to_field = (\n726                 self.remote_field.model._meta.pk\n727                 if to_field_name is None\n728                 else self.remote_field.model._meta.get_field(to_field_name)\n729             )\n730             related_fields.append((from_field, to_field))\n731         return related_fields\n732 \n733     @cached_property\n734     def related_fields(self):\n735         return self.resolve_related_fields()\n736 \n737     @cached_property\n738     def reverse_related_fields(self):\n739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n740 \n741     @cached_property\n742     def local_related_fields(self):\n743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n744 \n745     @cached_property\n746     def foreign_related_fields(self):\n747         return tuple(\n748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field\n749         )\n750 \n751     def get_local_related_value(self, instance):\n752         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n753 \n754     def get_foreign_related_value(self, instance):\n755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n756 \n757     @staticmethod\n758     def get_instance_value_for_fields(instance, fields):\n759         ret = []\n760         opts = instance._meta\n761         for field in fields:\n762             # Gotcha: in some cases (like fixture loading) a model can have\n763             # different values in parent_ptr_id and parent's id. So, use\n764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n765             if field.primary_key:\n766                 possible_parent_link = opts.get_ancestor_link(field.model)\n767                 if (\n768                     not possible_parent_link\n769                     or possible_parent_link.primary_key\n770                     or possible_parent_link.model._meta.abstract\n771                 ):\n772                     ret.append(instance.pk)\n773                     continue\n774             ret.append(getattr(instance, field.attname))\n775         return tuple(ret)\n776 \n777     def get_attname_column(self):\n778         attname, column = super().get_attname_column()\n779         return attname, None\n780 \n781     def get_joining_columns(self, reverse_join=False):\n782         warnings.warn(\n783             \"ForeignObject.get_joining_columns() is deprecated. Use \"\n784             \"get_joining_fields() instead.\",\n785             RemovedInDjango60Warning,\n786         )\n787         source = self.reverse_related_fields if reverse_join else self.related_fields\n788         return tuple(\n789             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source\n790         )\n791 \n792     def get_reverse_joining_columns(self):\n793         warnings.warn(\n794             \"ForeignObject.get_reverse_joining_columns() is deprecated. Use \"\n795             \"get_reverse_joining_fields() instead.\",\n796             RemovedInDjango60Warning,\n797         )\n798         return self.get_joining_columns(reverse_join=True)\n799 \n800     def get_joining_fields(self, reverse_join=False):\n801         return tuple(\n802             self.reverse_related_fields if reverse_join else self.related_fields\n803         )\n804 \n805     def get_reverse_joining_fields(self):\n806         return self.get_joining_fields(reverse_join=True)\n807 \n808     def get_extra_descriptor_filter(self, instance):\n809         \"\"\"\n810         Return an extra filter condition for related object fetching when\n811         user does 'instance.fieldname', that is the extra filter is used in\n812         the descriptor of the field.\n813 \n814         The filter should be either a dict usable in .filter(**kwargs) call or\n815         a Q-object. The condition will be ANDed together with the relation's\n816         joining columns.\n817 \n818         A parallel method is get_extra_restriction() which is used in\n819         JOIN and subquery conditions.\n820         \"\"\"\n821         return {}\n822 \n823     def get_extra_restriction(self, alias, related_alias):\n824         \"\"\"\n825         Return a pair condition used for joining and subquery pushdown. The\n826         condition is something that responds to as_sql(compiler, connection)\n827         method.\n828 \n829         Note that currently referring both the 'alias' and 'related_alias'\n830         will not work in some conditions, like subquery pushdown.\n831 \n832         A parallel method is get_extra_descriptor_filter() which is used in\n833         instance.fieldname related object fetching.\n834         \"\"\"\n835         return None\n836 \n837     def get_path_info(self, filtered_relation=None):\n838         \"\"\"Get path from this field to the related model.\"\"\"\n839         opts = self.remote_field.model._meta\n840         from_opts = self.model._meta\n841         return [\n842             PathInfo(\n843                 from_opts=from_opts,\n844                 to_opts=opts,\n845                 target_fields=self.foreign_related_fields,\n846                 join_field=self,\n847                 m2m=False,\n848                 direct=True,\n849                 filtered_relation=filtered_relation,\n850             )\n851         ]\n852 \n853     @cached_property\n854     def path_infos(self):\n855         return self.get_path_info()\n856 \n857     def get_reverse_path_info(self, filtered_relation=None):\n858         \"\"\"Get path from the related model to this field's model.\"\"\"\n859         opts = self.model._meta\n860         from_opts = self.remote_field.model._meta\n861         return [\n862             PathInfo(\n863                 from_opts=from_opts,\n864                 to_opts=opts,\n865                 target_fields=(opts.pk,),\n866                 join_field=self.remote_field,\n867                 m2m=not self.unique,\n868                 direct=False,\n869                 filtered_relation=filtered_relation,\n870             )\n871         ]\n872 \n873     @cached_property\n874     def reverse_path_infos(self):\n875         return self.get_reverse_path_info()\n876 \n877     @classmethod\n878     @functools.cache\n879     def get_class_lookups(cls):\n880         bases = inspect.getmro(cls)\n881         bases = bases[: bases.index(ForeignObject) + 1]\n882         class_lookups = [parent.__dict__.get(\"class_lookups\", {}) for parent in bases]\n883         return cls.merge_dicts(class_lookups)\n884 \n885     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n886         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n887         setattr(cls, self.name, self.forward_related_accessor_class(self))\n888 \n889     def contribute_to_related_class(self, cls, related):\n890         # Internal FK's - i.e., those with a related name ending with '+' -\n891         # and swapped models don't get a related descriptor.\n892         if (\n893             not self.remote_field.is_hidden()\n894             and not related.related_model._meta.swapped\n895         ):\n896             setattr(\n897                 cls._meta.concrete_model,\n898                 related.get_accessor_name(),\n899                 self.related_accessor_class(related),\n900             )\n901             # While 'limit_choices_to' might be a callable, simply pass\n902             # it along for later - this is too early because it's still\n903             # model load time.\n904             if self.remote_field.limit_choices_to:\n905                 cls._meta.related_fkey_lookups.append(\n906                     self.remote_field.limit_choices_to\n907                 )\n908 \n909 \n910 ForeignObject.register_lookup(RelatedIn)\n911 ForeignObject.register_lookup(RelatedExact)\n912 ForeignObject.register_lookup(RelatedLessThan)\n913 ForeignObject.register_lookup(RelatedGreaterThan)\n914 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n915 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n916 ForeignObject.register_lookup(RelatedIsNull)\n917 \n918 \n919 class ForeignKey(ForeignObject):\n920     \"\"\"\n921     Provide a many-to-one relation by adding a column to the local model\n922     to hold the remote value.\n923 \n924     By default ForeignKey will target the pk of the remote model but this\n925     behavior can be changed by using the ``to_field`` argument.\n926     \"\"\"\n927 \n928     descriptor_class = ForeignKeyDeferredAttribute\n929     # Field flags\n930     many_to_many = False\n931     many_to_one = True\n932     one_to_many = False\n933     one_to_one = False\n934 \n935     rel_class = ManyToOneRel\n936 \n937     empty_strings_allowed = False\n938     default_error_messages = {\n939         \"invalid\": _(\"%(model)s instance with %(field)s %(value)r does not exist.\")\n940     }\n941     description = _(\"Foreign Key (type determined by related field)\")\n942 \n943     def __init__(\n944         self,\n945         to,\n946         on_delete,\n947         related_name=None,\n948         related_query_name=None,\n949         limit_choices_to=None,\n950         parent_link=False,\n951         to_field=None,\n952         db_constraint=True,\n953         **kwargs,\n954     ):\n955         try:\n956             to._meta.model_name\n957         except AttributeError:\n958             if not isinstance(to, str):\n959                 raise TypeError(\n960                     \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n961                     \"either a model, a model name, or the string %r\"\n962                     % (\n963                         self.__class__.__name__,\n964                         to,\n965                         RECURSIVE_RELATIONSHIP_CONSTANT,\n966                     )\n967                 )\n968         else:\n969             # For backwards compatibility purposes, we need to *try* and set\n970             # the to_field during FK construction. It won't be guaranteed to\n971             # be correct until contribute_to_class is called. Refs #12190.\n972             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n973         if not callable(on_delete):\n974             raise TypeError(\"on_delete must be callable.\")\n975 \n976         kwargs[\"rel\"] = self.rel_class(\n977             self,\n978             to,\n979             to_field,\n980             related_name=related_name,\n981             related_query_name=related_query_name,\n982             limit_choices_to=limit_choices_to,\n983             parent_link=parent_link,\n984             on_delete=on_delete,\n985         )\n986         kwargs.setdefault(\"db_index\", True)\n987 \n988         super().__init__(\n989             to,\n990             on_delete,\n991             related_name=related_name,\n992             related_query_name=related_query_name,\n993             limit_choices_to=limit_choices_to,\n994             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n995             to_fields=[to_field],\n996             **kwargs,\n997         )\n998         self.db_constraint = db_constraint\n999 \n1000     def __class_getitem__(cls, *args, **kwargs):\n1001         return cls\n1002 \n1003     def check(self, **kwargs):\n1004         return [\n1005             *super().check(**kwargs),\n1006             *self._check_on_delete(),\n1007             *self._check_unique(),\n1008         ]\n1009 \n1010     def _check_on_delete(self):\n1011         on_delete = getattr(self.remote_field, \"on_delete\", None)\n1012         if on_delete == SET_NULL and not self.null:\n1013             return [\n1014                 checks.Error(\n1015                     \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n1016                     hint=(\n1017                         \"Set null=True argument on the field, or change the on_delete \"\n1018                         \"rule.\"\n1019                     ),\n1020                     obj=self,\n1021                     id=\"fields.E320\",\n1022                 )\n1023             ]\n1024         elif on_delete == SET_DEFAULT and not self.has_default():\n1025             return [\n1026                 checks.Error(\n1027                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n1028                     hint=\"Set a default value, or change the on_delete rule.\",\n1029                     obj=self,\n1030                     id=\"fields.E321\",\n1031                 )\n1032             ]\n1033         else:\n1034             return []\n1035 \n1036     def _check_unique(self, **kwargs):\n1037         return (\n1038             [\n1039                 checks.Warning(\n1040                     \"Setting unique=True on a ForeignKey has the same effect as using \"\n1041                     \"a OneToOneField.\",\n1042                     hint=(\n1043                         \"ForeignKey(unique=True) is usually better served by a \"\n1044                         \"OneToOneField.\"\n1045                     ),\n1046                     obj=self,\n1047                     id=\"fields.W342\",\n1048                 )\n1049             ]\n1050             if self.unique\n1051             else []\n1052         )\n1053 \n1054     def deconstruct(self):\n1055         name, path, args, kwargs = super().deconstruct()\n1056         del kwargs[\"to_fields\"]\n1057         del kwargs[\"from_fields\"]\n1058         # Handle the simpler arguments\n1059         if self.db_index:\n1060             del kwargs[\"db_index\"]\n1061         else:\n1062             kwargs[\"db_index\"] = False\n1063         if self.db_constraint is not True:\n1064             kwargs[\"db_constraint\"] = self.db_constraint\n1065         # Rel needs more work.\n1066         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n1067         if self.remote_field.field_name and (\n1068             not to_meta\n1069             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)\n1070         ):\n1071             kwargs[\"to_field\"] = self.remote_field.field_name\n1072         return name, path, args, kwargs\n1073 \n1074     def to_python(self, value):\n1075         return self.target_field.to_python(value)\n1076 \n1077     @property\n1078     def target_field(self):\n1079         return self.foreign_related_fields[0]\n1080 \n1081     def validate(self, value, model_instance):\n1082         if self.remote_field.parent_link:\n1083             return\n1084         super().validate(value, model_instance)\n1085         if value is None:\n1086             return\n1087 \n1088         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n1089         qs = self.remote_field.model._base_manager.using(using).filter(\n1090             **{self.remote_field.field_name: value}\n1091         )\n1092         qs = qs.complex_filter(self.get_limit_choices_to())\n1093         if not qs.exists():\n1094             raise exceptions.ValidationError(\n1095                 self.error_messages[\"invalid\"],\n1096                 code=\"invalid\",\n1097                 params={\n1098                     \"model\": self.remote_field.model._meta.verbose_name,\n1099                     \"pk\": value,\n1100                     \"field\": self.remote_field.field_name,\n1101                     \"value\": value,\n1102                 },  # 'pk' is included for backwards compatibility\n1103             )\n1104 \n1105     def resolve_related_fields(self):\n1106         related_fields = super().resolve_related_fields()\n1107         for from_field, to_field in related_fields:\n1108             if (\n1109                 to_field\n1110                 and to_field.model != self.remote_field.model._meta.concrete_model\n1111             ):\n1112                 raise exceptions.FieldError(\n1113                     \"'%s.%s' refers to field '%s' which is not local to model \"\n1114                     \"'%s'.\"\n1115                     % (\n1116                         self.model._meta.label,\n1117                         self.name,\n1118                         to_field.name,\n1119                         self.remote_field.model._meta.concrete_model._meta.label,\n1120                     )\n1121                 )\n1122         return related_fields\n1123 \n1124     def get_attname(self):\n1125         return \"%s_id\" % self.name\n1126 \n1127     def get_attname_column(self):\n1128         attname = self.get_attname()\n1129         column = self.db_column or attname\n1130         return attname, column\n1131 \n1132     def get_default(self):\n1133         \"\"\"Return the to_field if the default value is an object.\"\"\"\n1134         field_default = super().get_default()\n1135         if isinstance(field_default, self.remote_field.model):\n1136             return getattr(field_default, self.target_field.attname)\n1137         return field_default\n1138 \n1139     def get_db_prep_save(self, value, connection):\n1140         if value is None or (\n1141             value == \"\"\n1142             and (\n1143                 not self.target_field.empty_strings_allowed\n1144                 or connection.features.interprets_empty_strings_as_nulls\n1145             )\n1146         ):\n1147             return None\n1148         else:\n1149             return self.target_field.get_db_prep_save(value, connection=connection)\n1150 \n1151     def get_db_prep_value(self, value, connection, prepared=False):\n1152         return self.target_field.get_db_prep_value(value, connection, prepared)\n1153 \n1154     def get_prep_value(self, value):\n1155         return self.target_field.get_prep_value(value)\n1156 \n1157     def contribute_to_related_class(self, cls, related):\n1158         super().contribute_to_related_class(cls, related)\n1159         if self.remote_field.field_name is None:\n1160             self.remote_field.field_name = cls._meta.pk.name\n1161 \n1162     def formfield(self, *, using=None, **kwargs):\n1163         if isinstance(self.remote_field.model, str):\n1164             raise ValueError(\n1165                 \"Cannot create form field for %r yet, because \"\n1166                 \"its related model %r has not been loaded yet\"\n1167                 % (self.name, self.remote_field.model)\n1168             )\n1169         return super().formfield(\n1170             **{\n1171                 \"form_class\": forms.ModelChoiceField,\n1172                 \"queryset\": self.remote_field.model._default_manager.using(using),\n1173                 \"to_field_name\": self.remote_field.field_name,\n1174                 **kwargs,\n1175                 \"blank\": self.blank,\n1176             }\n1177         )\n1178 \n1179     def db_check(self, connection):\n1180         return None\n1181 \n1182     def db_type(self, connection):\n1183         return self.target_field.rel_db_type(connection=connection)\n1184 \n1185     def cast_db_type(self, connection):\n1186         return self.target_field.cast_db_type(connection=connection)\n1187 \n1188     def db_parameters(self, connection):\n1189         target_db_parameters = self.target_field.db_parameters(connection)\n1190         return {\n1191             \"type\": self.db_type(connection),\n1192             \"check\": self.db_check(connection),\n1193             \"collation\": target_db_parameters.get(\"collation\"),\n1194         }\n1195 \n1196     def convert_empty_strings(self, value, expression, connection):\n1197         if (not value) and isinstance(value, str):\n1198             return None\n1199         return value\n1200 \n1201     def get_db_converters(self, connection):\n1202         converters = super().get_db_converters(connection)\n1203         if connection.features.interprets_empty_strings_as_nulls:\n1204             converters += [self.convert_empty_strings]\n1205         return converters\n1206 \n1207     def get_col(self, alias, output_field=None):\n1208         if output_field is None:\n1209             output_field = self.target_field\n1210             while isinstance(output_field, ForeignKey):\n1211                 output_field = output_field.target_field\n1212                 if output_field is self:\n1213                     raise ValueError(\"Cannot resolve output_field.\")\n1214         return super().get_col(alias, output_field)\n1215 \n1216 \n1217 class OneToOneField(ForeignKey):\n1218     \"\"\"\n1219     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1220     that it always carries a \"unique\" constraint with it and the reverse\n1221     relation always returns the object pointed to (since there will only ever\n1222     be one), rather than returning a list.\n1223     \"\"\"\n1224 \n1225     # Field flags\n1226     many_to_many = False\n1227     many_to_one = False\n1228     one_to_many = False\n1229     one_to_one = True\n1230 \n1231     related_accessor_class = ReverseOneToOneDescriptor\n1232     forward_related_accessor_class = ForwardOneToOneDescriptor\n1233     rel_class = OneToOneRel\n1234 \n1235     description = _(\"One-to-one relationship\")\n1236 \n1237     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1238         kwargs[\"unique\"] = True\n1239         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1240 \n1241     def deconstruct(self):\n1242         name, path, args, kwargs = super().deconstruct()\n1243         if \"unique\" in kwargs:\n1244             del kwargs[\"unique\"]\n1245         return name, path, args, kwargs\n1246 \n1247     def formfield(self, **kwargs):\n1248         if self.remote_field.parent_link:\n1249             return None\n1250         return super().formfield(**kwargs)\n1251 \n1252     def save_form_data(self, instance, data):\n1253         if isinstance(data, self.remote_field.model):\n1254             setattr(instance, self.name, data)\n1255         else:\n1256             setattr(instance, self.attname, data)\n1257             # Remote field object must be cleared otherwise Model.save()\n1258             # will reassign attname using the related object pk.\n1259             if data is None:\n1260                 setattr(instance, self.name, data)\n1261 \n1262     def _check_unique(self, **kwargs):\n1263         # Override ForeignKey since check isn't applicable here.\n1264         return []\n1265 \n1266 \n1267 def create_many_to_many_intermediary_model(field, klass):\n1268     from django.db import models\n1269 \n1270     def set_managed(model, related, through):\n1271         through._meta.managed = model._meta.managed or related._meta.managed\n1272 \n1273     to_model = resolve_relation(klass, field.remote_field.model)\n1274     name = \"%s_%s\" % (klass._meta.object_name, field.name)\n1275     lazy_related_operation(set_managed, klass, to_model, name)\n1276 \n1277     to = make_model_tuple(to_model)[1]\n1278     from_ = klass._meta.model_name\n1279     if to == from_:\n1280         to = \"to_%s\" % to\n1281         from_ = \"from_%s\" % from_\n1282 \n1283     meta = type(\n1284         \"Meta\",\n1285         (),\n1286         {\n1287             \"db_table\": field._get_m2m_db_table(klass._meta),\n1288             \"auto_created\": klass,\n1289             \"app_label\": klass._meta.app_label,\n1290             \"db_tablespace\": klass._meta.db_tablespace,\n1291             \"unique_together\": (from_, to),\n1292             \"verbose_name\": _(\"%(from)s-%(to)s relationship\")\n1293             % {\"from\": from_, \"to\": to},\n1294             \"verbose_name_plural\": _(\"%(from)s-%(to)s relationships\")\n1295             % {\"from\": from_, \"to\": to},\n1296             \"apps\": field.model._meta.apps,\n1297         },\n1298     )\n1299     # Construct and return the new class.\n1300     return type(\n1301         name,\n1302         (models.Model,),\n1303         {\n1304             \"Meta\": meta,\n1305             \"__module__\": klass.__module__,\n1306             from_: models.ForeignKey(\n1307                 klass,\n1308                 related_name=\"%s+\" % name,\n1309                 db_tablespace=field.db_tablespace,\n1310                 db_constraint=field.remote_field.db_constraint,\n1311                 on_delete=CASCADE,\n1312             ),\n1313             to: models.ForeignKey(\n1314                 to_model,\n1315                 related_name=\"%s+\" % name,\n1316                 db_tablespace=field.db_tablespace,\n1317                 db_constraint=field.remote_field.db_constraint,\n1318                 on_delete=CASCADE,\n1319             ),\n1320         },\n1321     )\n1322 \n1323 \n1324 class ManyToManyField(RelatedField):\n1325     \"\"\"\n1326     Provide a many-to-many relation by using an intermediary model that\n1327     holds two ForeignKey fields pointed at the two sides of the relation.\n1328 \n1329     Unless a ``through`` model was provided, ManyToManyField will use the\n1330     create_many_to_many_intermediary_model factory to automatically generate\n1331     the intermediary model.\n1332     \"\"\"\n1333 \n1334     # Field flags\n1335     many_to_many = True\n1336     many_to_one = False\n1337     one_to_many = False\n1338     one_to_one = False\n1339 \n1340     rel_class = ManyToManyRel\n1341 \n1342     description = _(\"Many-to-many relationship\")\n1343 \n1344     def __init__(\n1345         self,\n1346         to,\n1347         related_name=None,\n1348         related_query_name=None,\n1349         limit_choices_to=None,\n1350         symmetrical=None,\n1351         through=None,\n1352         through_fields=None,\n1353         db_constraint=True,\n1354         db_table=None,\n1355         swappable=True,\n1356         **kwargs,\n1357     ):\n1358         try:\n1359             to._meta\n1360         except AttributeError:\n1361             if not isinstance(to, str):\n1362                 raise TypeError(\n1363                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1364                     \"must be either a model, a model name, or the string %r\"\n1365                     % (\n1366                         self.__class__.__name__,\n1367                         to,\n1368                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1369                     )\n1370                 )\n1371 \n1372         if symmetrical is None:\n1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1374 \n1375         if through is not None and db_table is not None:\n1376             raise ValueError(\n1377                 \"Cannot specify a db_table if an intermediary model is used.\"\n1378             )\n1379 \n1380         kwargs[\"rel\"] = self.rel_class(\n1381             self,\n1382             to,\n1383             related_name=related_name,\n1384             related_query_name=related_query_name,\n1385             limit_choices_to=limit_choices_to,\n1386             symmetrical=symmetrical,\n1387             through=through,\n1388             through_fields=through_fields,\n1389             db_constraint=db_constraint,\n1390         )\n1391         self.has_null_arg = \"null\" in kwargs\n1392 \n1393         super().__init__(\n1394             related_name=related_name,\n1395             related_query_name=related_query_name,\n1396             limit_choices_to=limit_choices_to,\n1397             **kwargs,\n1398         )\n1399 \n1400         self.db_table = db_table\n1401         self.swappable = swappable\n1402 \n1403     def check(self, **kwargs):\n1404         return [\n1405             *super().check(**kwargs),\n1406             *self._check_unique(**kwargs),\n1407             *self._check_relationship_model(**kwargs),\n1408             *self._check_ignored_options(**kwargs),\n1409             *self._check_table_uniqueness(**kwargs),\n1410         ]\n1411 \n1412     def _check_unique(self, **kwargs):\n1413         if self.unique:\n1414             return [\n1415                 checks.Error(\n1416                     \"ManyToManyFields cannot be unique.\",\n1417                     obj=self,\n1418                     id=\"fields.E330\",\n1419                 )\n1420             ]\n1421         return []\n1422 \n1423     def _check_ignored_options(self, **kwargs):\n1424         warnings = []\n1425 \n1426         if self.has_null_arg:\n1427             warnings.append(\n1428                 checks.Warning(\n1429                     \"null has no effect on ManyToManyField.\",\n1430                     obj=self,\n1431                     id=\"fields.W340\",\n1432                 )\n1433             )\n1434 \n1435         if self._validators:\n1436             warnings.append(\n1437                 checks.Warning(\n1438                     \"ManyToManyField does not support validators.\",\n1439                     obj=self,\n1440                     id=\"fields.W341\",\n1441                 )\n1442             )\n1443         if self.remote_field.symmetrical and self._related_name:\n1444             warnings.append(\n1445                 checks.Warning(\n1446                     \"related_name has no effect on ManyToManyField \"\n1447                     'with a symmetrical relationship, e.g. to \"self\".',\n1448                     obj=self,\n1449                     id=\"fields.W345\",\n1450                 )\n1451             )\n1452         if self.db_comment:\n1453             warnings.append(\n1454                 checks.Warning(\n1455                     \"db_comment has no effect on ManyToManyField.\",\n1456                     obj=self,\n1457                     id=\"fields.W346\",\n1458                 )\n1459             )\n1460 \n1461         return warnings\n1462 \n1463     def _check_relationship_model(self, from_model=None, **kwargs):\n1464         if hasattr(self.remote_field.through, \"_meta\"):\n1465             qualified_model_name = \"%s.%s\" % (\n1466                 self.remote_field.through._meta.app_label,\n1467                 self.remote_field.through.__name__,\n1468             )\n1469         else:\n1470             qualified_model_name = self.remote_field.through\n1471 \n1472         errors = []\n1473 \n1474         if self.remote_field.through not in self.opts.apps.get_models(\n1475             include_auto_created=True\n1476         ):\n1477             # The relationship model is not installed.\n1478             errors.append(\n1479                 checks.Error(\n1480                     \"Field specifies a many-to-many relation through model \"\n1481                     \"'%s', which has not been installed.\" % qualified_model_name,\n1482                     obj=self,\n1483                     id=\"fields.E331\",\n1484                 )\n1485             )\n1486 \n1487         else:\n1488             assert from_model is not None, (\n1489                 \"ManyToManyField with intermediate \"\n1490                 \"tables cannot be checked if you don't pass the model \"\n1491                 \"where the field is attached to.\"\n1492             )\n1493             # Set some useful local variables\n1494             to_model = resolve_relation(from_model, self.remote_field.model)\n1495             from_model_name = from_model._meta.object_name\n1496             if isinstance(to_model, str):\n1497                 to_model_name = to_model\n1498             else:\n1499                 to_model_name = to_model._meta.object_name\n1500             relationship_model_name = self.remote_field.through._meta.object_name\n1501             self_referential = from_model == to_model\n1502             # Count foreign keys in intermediate model\n1503             if self_referential:\n1504                 seen_self = sum(\n1505                     from_model == getattr(field.remote_field, \"model\", None)\n1506                     for field in self.remote_field.through._meta.fields\n1507                 )\n1508 \n1509                 if seen_self > 2 and not self.remote_field.through_fields:\n1510                     errors.append(\n1511                         checks.Error(\n1512                             \"The model is used as an intermediate model by \"\n1513                             \"'%s', but it has more than two foreign keys \"\n1514                             \"to '%s', which is ambiguous. You must specify \"\n1515                             \"which two foreign keys Django should use via the \"\n1516                             \"through_fields keyword argument.\"\n1517                             % (self, from_model_name),\n1518                             hint=(\n1519                                 \"Use through_fields to specify which two foreign keys \"\n1520                                 \"Django should use.\"\n1521                             ),\n1522                             obj=self.remote_field.through,\n1523                             id=\"fields.E333\",\n1524                         )\n1525                     )\n1526 \n1527             else:\n1528                 # Count foreign keys in relationship model\n1529                 seen_from = sum(\n1530                     from_model == getattr(field.remote_field, \"model\", None)\n1531                     for field in self.remote_field.through._meta.fields\n1532                 )\n1533                 seen_to = sum(\n1534                     to_model == getattr(field.remote_field, \"model\", None)\n1535                     for field in self.remote_field.through._meta.fields\n1536                 )\n1537 \n1538                 if seen_from > 1 and not self.remote_field.through_fields:\n1539                     errors.append(\n1540                         checks.Error(\n1541                             (\n1542                                 \"The model is used as an intermediate model by \"\n1543                                 \"'%s', but it has more than one foreign key \"\n1544                                 \"from '%s', which is ambiguous. You must specify \"\n1545                                 \"which foreign key Django should use via the \"\n1546                                 \"through_fields keyword argument.\"\n1547                             )\n1548                             % (self, from_model_name),\n1549                             hint=(\n1550                                 \"If you want to create a recursive relationship, \"\n1551                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1552                             )\n1553                             % (\n1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1555                                 relationship_model_name,\n1556                             ),\n1557                             obj=self,\n1558                             id=\"fields.E334\",\n1559                         )\n1560                     )\n1561 \n1562                 if seen_to > 1 and not self.remote_field.through_fields:\n1563                     errors.append(\n1564                         checks.Error(\n1565                             \"The model is used as an intermediate model by \"\n1566                             \"'%s', but it has more than one foreign key \"\n1567                             \"to '%s', which is ambiguous. You must specify \"\n1568                             \"which foreign key Django should use via the \"\n1569                             \"through_fields keyword argument.\" % (self, to_model_name),\n1570                             hint=(\n1571                                 \"If you want to create a recursive relationship, \"\n1572                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1573                             )\n1574                             % (\n1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1576                                 relationship_model_name,\n1577                             ),\n1578                             obj=self,\n1579                             id=\"fields.E335\",\n1580                         )\n1581                     )\n1582 \n1583                 if seen_from == 0 or seen_to == 0:\n1584                     errors.append(\n1585                         checks.Error(\n1586                             \"The model is used as an intermediate model by \"\n1587                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1588                             % (self, from_model_name, to_model_name),\n1589                             obj=self.remote_field.through,\n1590                             id=\"fields.E336\",\n1591                         )\n1592                     )\n1593 \n1594         # Validate `through_fields`.\n1595         if self.remote_field.through_fields is not None:\n1596             # Validate that we're given an iterable of at least two items\n1597             # and that none of them is \"falsy\".\n1598             if not (\n1599                 len(self.remote_field.through_fields) >= 2\n1600                 and self.remote_field.through_fields[0]\n1601                 and self.remote_field.through_fields[1]\n1602             ):\n1603                 errors.append(\n1604                     checks.Error(\n1605                         \"Field specifies 'through_fields' but does not provide \"\n1606                         \"the names of the two link fields that should be used \"\n1607                         \"for the relation through model '%s'.\" % qualified_model_name,\n1608                         hint=(\n1609                             \"Make sure you specify 'through_fields' as \"\n1610                             \"through_fields=('field1', 'field2')\"\n1611                         ),\n1612                         obj=self,\n1613                         id=\"fields.E337\",\n1614                     )\n1615                 )\n1616 \n1617             # Validate the given through fields -- they should be actual\n1618             # fields on the through model, and also be foreign keys to the\n1619             # expected models.\n1620             else:\n1621                 assert from_model is not None, (\n1622                     \"ManyToManyField with intermediate \"\n1623                     \"tables cannot be checked if you don't pass the model \"\n1624                     \"where the field is attached to.\"\n1625                 )\n1626 \n1627                 source, through, target = (\n1628                     from_model,\n1629                     self.remote_field.through,\n1630                     self.remote_field.model,\n1631                 )\n1632                 source_field_name, target_field_name = self.remote_field.through_fields[\n1633                     :2\n1634                 ]\n1635 \n1636                 for field_name, related_model in (\n1637                     (source_field_name, source),\n1638                     (target_field_name, target),\n1639                 ):\n1640                     possible_field_names = []\n1641                     for f in through._meta.fields:\n1642                         if (\n1643                             hasattr(f, \"remote_field\")\n1644                             and getattr(f.remote_field, \"model\", None) == related_model\n1645                         ):\n1646                             possible_field_names.append(f.name)\n1647                     if possible_field_names:\n1648                         hint = (\n1649                             \"Did you mean one of the following foreign keys to '%s': \"\n1650                             \"%s?\"\n1651                             % (\n1652                                 related_model._meta.object_name,\n1653                                 \", \".join(possible_field_names),\n1654                             )\n1655                         )\n1656                     else:\n1657                         hint = None\n1658 \n1659                     try:\n1660                         field = through._meta.get_field(field_name)\n1661                     except exceptions.FieldDoesNotExist:\n1662                         errors.append(\n1663                             checks.Error(\n1664                                 \"The intermediary model '%s' has no field '%s'.\"\n1665                                 % (qualified_model_name, field_name),\n1666                                 hint=hint,\n1667                                 obj=self,\n1668                                 id=\"fields.E338\",\n1669                             )\n1670                         )\n1671                     else:\n1672                         if not (\n1673                             hasattr(field, \"remote_field\")\n1674                             and getattr(field.remote_field, \"model\", None)\n1675                             == related_model\n1676                         ):\n1677                             errors.append(\n1678                                 checks.Error(\n1679                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1680                                     % (\n1681                                         through._meta.object_name,\n1682                                         field_name,\n1683                                         related_model._meta.object_name,\n1684                                     ),\n1685                                     hint=hint,\n1686                                     obj=self,\n1687                                     id=\"fields.E339\",\n1688                                 )\n1689                             )\n1690 \n1691         return errors\n1692 \n1693     def _check_table_uniqueness(self, **kwargs):\n1694         if (\n1695             isinstance(self.remote_field.through, str)\n1696             or not self.remote_field.through._meta.managed\n1697         ):\n1698             return []\n1699         registered_tables = {\n1700             model._meta.db_table: model\n1701             for model in self.opts.apps.get_models(include_auto_created=True)\n1702             if model != self.remote_field.through and model._meta.managed\n1703         }\n1704         m2m_db_table = self.m2m_db_table()\n1705         model = registered_tables.get(m2m_db_table)\n1706         # The second condition allows multiple m2m relations on a model if\n1707         # some point to a through model that proxies another through model.\n1708         if (\n1709             model\n1710             and model._meta.concrete_model\n1711             != self.remote_field.through._meta.concrete_model\n1712         ):\n1713             if model._meta.auto_created:\n1714 \n1715                 def _get_field_name(model):\n1716                     for field in model._meta.auto_created._meta.many_to_many:\n1717                         if field.remote_field.through is model:\n1718                             return field.name\n1719 \n1720                 opts = model._meta.auto_created._meta\n1721                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1722             else:\n1723                 clashing_obj = model._meta.label\n1724             if settings.DATABASE_ROUTERS:\n1725                 error_class, error_id = checks.Warning, \"fields.W344\"\n1726                 error_hint = (\n1727                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1728                     \"that the table of %r is correctly routed to a separate \"\n1729                     \"database.\" % clashing_obj\n1730                 )\n1731             else:\n1732                 error_class, error_id = checks.Error, \"fields.E340\"\n1733                 error_hint = None\n1734             return [\n1735                 error_class(\n1736                     \"The field's intermediary table '%s' clashes with the \"\n1737                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1738                     obj=self,\n1739                     hint=error_hint,\n1740                     id=error_id,\n1741                 )\n1742             ]\n1743         return []\n1744 \n1745     def deconstruct(self):\n1746         name, path, args, kwargs = super().deconstruct()\n1747         # Handle the simpler arguments.\n1748         if self.db_table is not None:\n1749             kwargs[\"db_table\"] = self.db_table\n1750         if self.remote_field.db_constraint is not True:\n1751             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1752         # Lowercase model names as they should be treated as case-insensitive.\n1753         if isinstance(self.remote_field.model, str):\n1754             if \".\" in self.remote_field.model:\n1755                 app_label, model_name = self.remote_field.model.split(\".\")\n1756                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1757             else:\n1758                 kwargs[\"to\"] = self.remote_field.model.lower()\n1759         else:\n1760             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1761         if getattr(self.remote_field, \"through\", None) is not None:\n1762             if isinstance(self.remote_field.through, str):\n1763                 kwargs[\"through\"] = self.remote_field.through\n1764             elif not self.remote_field.through._meta.auto_created:\n1765                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1766         # If swappable is True, then see if we're actually pointing to the target\n1767         # of a swap.\n1768         swappable_setting = self.swappable_setting\n1769         if swappable_setting is not None:\n1770             # If it's already a settings reference, error.\n1771             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1772                 if kwargs[\"to\"].setting_name != swappable_setting:\n1773                     raise ValueError(\n1774                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1775                         \"model that is swapped in place of more than one model \"\n1776                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1777                     )\n1778 \n1779             kwargs[\"to\"] = SettingsReference(\n1780                 kwargs[\"to\"],\n1781                 swappable_setting,\n1782             )\n1783         return name, path, args, kwargs\n1784 \n1785     def _get_path_info(self, direct=False, filtered_relation=None):\n1786         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1787         int_model = self.remote_field.through\n1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1790         if direct:\n1791             join1infos = linkfield1.reverse_path_infos\n1792             if filtered_relation:\n1793                 join2infos = linkfield2.get_path_info(filtered_relation)\n1794             else:\n1795                 join2infos = linkfield2.path_infos\n1796         else:\n1797             join1infos = linkfield2.reverse_path_infos\n1798             if filtered_relation:\n1799                 join2infos = linkfield1.get_path_info(filtered_relation)\n1800             else:\n1801                 join2infos = linkfield1.path_infos\n1802         # Get join infos between the last model of join 1 and the first model\n1803         # of join 2. Assume the only reason these may differ is due to model\n1804         # inheritance.\n1805         join1_final = join1infos[-1].to_opts\n1806         join2_initial = join2infos[0].from_opts\n1807         if join1_final is join2_initial:\n1808             intermediate_infos = []\n1809         elif issubclass(join1_final.model, join2_initial.model):\n1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1811         else:\n1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1813 \n1814         return [*join1infos, *intermediate_infos, *join2infos]\n1815 \n1816     def get_path_info(self, filtered_relation=None):\n1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1818 \n1819     @cached_property\n1820     def path_infos(self):\n1821         return self.get_path_info()\n1822 \n1823     def get_reverse_path_info(self, filtered_relation=None):\n1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1825 \n1826     @cached_property\n1827     def reverse_path_infos(self):\n1828         return self.get_reverse_path_info()\n1829 \n1830     def _get_m2m_db_table(self, opts):\n1831         \"\"\"\n1832         Function that can be curried to provide the m2m table name for this\n1833         relation.\n1834         \"\"\"\n1835         if self.remote_field.through is not None:\n1836             return self.remote_field.through._meta.db_table\n1837         elif self.db_table:\n1838             return self.db_table\n1839         else:\n1840             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1842 \n1843     def _get_m2m_attr(self, related, attr):\n1844         \"\"\"\n1845         Function that can be curried to provide the source accessor or DB\n1846         column name for the m2m table.\n1847         \"\"\"\n1848         cache_attr = \"_m2m_%s_cache\" % attr\n1849         if hasattr(self, cache_attr):\n1850             return getattr(self, cache_attr)\n1851         if self.remote_field.through_fields is not None:\n1852             link_field_name = self.remote_field.through_fields[0]\n1853         else:\n1854             link_field_name = None\n1855         for f in self.remote_field.through._meta.fields:\n1856             if (\n1857                 f.is_relation\n1858                 and f.remote_field.model == related.related_model\n1859                 and (link_field_name is None or link_field_name == f.name)\n1860             ):\n1861                 setattr(self, cache_attr, getattr(f, attr))\n1862                 return getattr(self, cache_attr)\n1863 \n1864     def _get_m2m_reverse_attr(self, related, attr):\n1865         \"\"\"\n1866         Function that can be curried to provide the related accessor or DB\n1867         column name for the m2m table.\n1868         \"\"\"\n1869         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1870         if hasattr(self, cache_attr):\n1871             return getattr(self, cache_attr)\n1872         found = False\n1873         if self.remote_field.through_fields is not None:\n1874             link_field_name = self.remote_field.through_fields[1]\n1875         else:\n1876             link_field_name = None\n1877         for f in self.remote_field.through._meta.fields:\n1878             if f.is_relation and f.remote_field.model == related.model:\n1879                 if link_field_name is None and related.related_model == related.model:\n1880                     # If this is an m2m-intermediate to self,\n1881                     # the first foreign key you find will be\n1882                     # the source column. Keep searching for\n1883                     # the second foreign key.\n1884                     if found:\n1885                         setattr(self, cache_attr, getattr(f, attr))\n1886                         break\n1887                     else:\n1888                         found = True\n1889                 elif link_field_name is None or link_field_name == f.name:\n1890                     setattr(self, cache_attr, getattr(f, attr))\n1891                     break\n1892         return getattr(self, cache_attr)\n1893 \n1894     def contribute_to_class(self, cls, name, **kwargs):\n1895         # To support multiple relations to self, it's useful to have a non-None\n1896         # related name on symmetrical relations for internal reasons. The\n1897         # concept doesn't make a lot of sense externally (\"you want me to\n1898         # specify *what* on my non-reversible relation?!\"), so we set it up\n1899         # automatically. The funky name reduces the chance of an accidental\n1900         # clash.\n1901         if self.remote_field.symmetrical and (\n1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1903             or self.remote_field.model == cls._meta.object_name\n1904         ):\n1905             self.remote_field.related_name = \"%s_rel_+\" % name\n1906         elif self.remote_field.is_hidden():\n1907             # If the backwards relation is disabled, replace the original\n1908             # related_name with one generated from the m2m field name. Django\n1909             # still uses backwards relations internally and we need to avoid\n1910             # clashes between multiple m2m fields with related_name == '+'.\n1911             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1912                 cls._meta.app_label,\n1913                 cls.__name__.lower(),\n1914                 name,\n1915             )\n1916 \n1917         super().contribute_to_class(cls, name, **kwargs)\n1918 \n1919         # The intermediate m2m model is not auto created if:\n1920         #  1) There is a manually specified intermediate, or\n1921         #  2) The class owning the m2m field is abstract.\n1922         #  3) The class owning the m2m field has been swapped out.\n1923         if not cls._meta.abstract:\n1924             if self.remote_field.through:\n1925 \n1926                 def resolve_through_model(_, model, field):\n1927                     field.remote_field.through = model\n1928 \n1929                 lazy_related_operation(\n1930                     resolve_through_model, cls, self.remote_field.through, field=self\n1931                 )\n1932             elif not cls._meta.swapped:\n1933                 self.remote_field.through = create_many_to_many_intermediary_model(\n1934                     self, cls\n1935                 )\n1936 \n1937         # Add the descriptor for the m2m relation.\n1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1939 \n1940         # Set up the accessor for the m2m table name for the relation.\n1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1942 \n1943     def contribute_to_related_class(self, cls, related):\n1944         # Internal M2Ms (i.e., those with a related name ending with '+')\n1945         # and swapped models don't get a related descriptor.\n1946         if (\n1947             not self.remote_field.is_hidden()\n1948             and not related.related_model._meta.swapped\n1949         ):\n1950             setattr(\n1951                 cls,\n1952                 related.get_accessor_name(),\n1953                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1954             )\n1955 \n1956         # Set up the accessors for the column names on the m2m table.\n1957         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1959 \n1960         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1961         self.m2m_reverse_field_name = partial(\n1962             self._get_m2m_reverse_attr, related, \"name\"\n1963         )\n1964 \n1965         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1967         get_m2m_reverse_rel = partial(\n1968             self._get_m2m_reverse_attr, related, \"remote_field\"\n1969         )\n1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1971 \n1972     def set_attributes_from_rel(self):\n1973         pass\n1974 \n1975     def value_from_object(self, obj):\n1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1977 \n1978     def save_form_data(self, instance, data):\n1979         getattr(instance, self.attname).set(data)\n1980 \n1981     def formfield(self, *, using=None, **kwargs):\n1982         defaults = {\n1983             \"form_class\": forms.ModelMultipleChoiceField,\n1984             \"queryset\": self.remote_field.model._default_manager.using(using),\n1985             **kwargs,\n1986         }\n1987         # If initial is passed in, it's a list of related objects, but the\n1988         # MultipleChoiceField takes a list of IDs.\n1989         if defaults.get(\"initial\") is not None:\n1990             initial = defaults[\"initial\"]\n1991             if callable(initial):\n1992                 initial = initial()\n1993             defaults[\"initial\"] = [i.pk for i in initial]\n1994         return super().formfield(**defaults)\n1995 \n1996     def db_check(self, connection):\n1997         return None\n1998 \n1999     def db_type(self, connection):\n2000         # A ManyToManyField is not represented by a single column,\n2001         # so return None.\n2002         return None\n2003 \n2004     def db_parameters(self, connection):\n2005         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Adjustment here could involve ensuring that during object creation and saving, all relationship fields, particularly those involved in MTI scenarios, correctly report their attributes and are fully compatible with how parent models are saved. This might include ensuring `attname` and other critical attributes are always accessible and correctly reflect the field's relationship in the database, especially in complex inheritance cases."
    }
]