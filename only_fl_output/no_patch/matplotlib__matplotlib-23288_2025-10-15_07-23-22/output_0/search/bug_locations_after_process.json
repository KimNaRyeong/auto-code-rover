[
    {
        "rel_file_path": "lib/matplotlib/backends/backend_pdf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5/lib/matplotlib/backends/backend_pdf.py",
        "start": 1,
        "end": 2796,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 A PDF Matplotlib backend.\n3 \n4 Author: Jouni K Sepp\u00e4nen <jks@iki.fi> and others.\n5 \"\"\"\n6 \n7 import codecs\n8 from datetime import datetime\n9 from enum import Enum\n10 from functools import total_ordering\n11 from io import BytesIO\n12 import itertools\n13 import logging\n14 import math\n15 import os\n16 import re\n17 import string\n18 import struct\n19 import sys\n20 import time\n21 import types\n22 import warnings\n23 import zlib\n24 \n25 import numpy as np\n26 from PIL import Image\n27 \n28 import matplotlib as mpl\n29 from matplotlib import _api, _text_helpers, _type1font, cbook, dviread\n30 from matplotlib._pylab_helpers import Gcf\n31 from matplotlib.backend_bases import (\n32     _Backend, FigureCanvasBase, FigureManagerBase, GraphicsContextBase,\n33     RendererBase)\n34 from matplotlib.backends.backend_mixed import MixedModeRenderer\n35 from matplotlib.figure import Figure\n36 from matplotlib.font_manager import findfont, get_font\n37 from matplotlib._afm import AFM\n38 from matplotlib.ft2font import (FIXED_WIDTH, ITALIC, LOAD_NO_SCALE,\n39                                 LOAD_NO_HINTING, KERNING_UNFITTED, FT2Font)\n40 from matplotlib.transforms import Affine2D, BboxBase\n41 from matplotlib.path import Path\n42 from matplotlib.dates import UTC\n43 from matplotlib import _path\n44 from . import _backend_pdf_ps\n45 \n46 _log = logging.getLogger(__name__)\n47 \n48 # Overview\n49 #\n50 # The low-level knowledge about pdf syntax lies mainly in the pdfRepr\n51 # function and the classes Reference, Name, Operator, and Stream.  The\n52 # PdfFile class knows about the overall structure of pdf documents.\n53 # It provides a \"write\" method for writing arbitrary strings in the\n54 # file, and an \"output\" method that passes objects through the pdfRepr\n55 # function before writing them in the file.  The output method is\n56 # called by the RendererPdf class, which contains the various draw_foo\n57 # methods.  RendererPdf contains a GraphicsContextPdf instance, and\n58 # each draw_foo calls self.check_gc before outputting commands.  This\n59 # method checks whether the pdf graphics state needs to be modified\n60 # and outputs the necessary commands.  GraphicsContextPdf represents\n61 # the graphics state, and its \"delta\" method returns the commands that\n62 # modify the state.\n63 \n64 # Add \"pdf.use14corefonts: True\" in your configuration file to use only\n65 # the 14 PDF core fonts. These fonts do not need to be embedded; every\n66 # PDF viewing application is required to have them. This results in very\n67 # light PDF files you can use directly in LaTeX or ConTeXt documents\n68 # generated with pdfTeX, without any conversion.\n69 \n70 # These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,\n71 # Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,\n72 # Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,\n73 # Times-BoldItalic, Symbol, ZapfDingbats.\n74 #\n75 # Some tricky points:\n76 #\n77 # 1. The clip path can only be widened by popping from the state\n78 # stack.  Thus the state must be pushed onto the stack before narrowing\n79 # the clip path.  This is taken care of by GraphicsContextPdf.\n80 #\n81 # 2. Sometimes it is necessary to refer to something (e.g., font,\n82 # image, or extended graphics state, which contains the alpha value)\n83 # in the page stream by a name that needs to be defined outside the\n84 # stream.  PdfFile provides the methods fontName, imageObject, and\n85 # alphaState for this purpose.  The implementations of these methods\n86 # should perhaps be generalized.\n87 \n88 # TODOs:\n89 #\n90 # * encoding of fonts, including mathtext fonts and Unicode support\n91 # * TTF support has lots of small TODOs, e.g., how do you know if a font\n92 #   is serif/sans-serif, or symbolic/non-symbolic?\n93 # * draw_quad_mesh\n94 \n95 \n96 @_api.deprecated(\"3.6\", alternative=\"Vendor the code\")\n97 def fill(strings, linelen=75):\n98     return _fill(strings, linelen=linelen)\n99 \n100 \n101 def _fill(strings, linelen=75):\n102     \"\"\"\n103     Make one string from sequence of strings, with whitespace in between.\n104 \n105     The whitespace is chosen to form lines of at most *linelen* characters,\n106     if possible.\n107     \"\"\"\n108     currpos = 0\n109     lasti = 0\n110     result = []\n111     for i, s in enumerate(strings):\n112         length = len(s)\n113         if currpos + length < linelen:\n114             currpos += length + 1\n115         else:\n116             result.append(b' '.join(strings[lasti:i]))\n117             lasti = i\n118             currpos = length\n119     result.append(b' '.join(strings[lasti:]))\n120     return b'\\n'.join(result)\n121 \n122 # PDF strings are supposed to be able to include any eight-bit data,\n123 # except that unbalanced parens and backslashes must be escaped by a\n124 # backslash. However, sf bug #2708559 shows that the carriage return\n125 # character may get read as a newline; these characters correspond to\n126 # \\gamma and \\Omega in TeX's math font encoding. Escaping them fixes\n127 # the bug.\n128 _string_escape_regex = re.compile(br'([\\\\()\\r\\n])')\n129 \n130 \n131 def _string_escape(match):\n132     m = match.group(0)\n133     if m in br'\\()':\n134         return b'\\\\' + m\n135     elif m == b'\\n':\n136         return br'\\n'\n137     elif m == b'\\r':\n138         return br'\\r'\n139     assert False\n140 \n141 \n142 def _create_pdf_info_dict(backend, metadata):\n143     \"\"\"\n144     Create a PDF infoDict based on user-supplied metadata.\n145 \n146     A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though\n147     the user metadata may override it. The date may be the current time, or a\n148     time set by the ``SOURCE_DATE_EPOCH`` environment variable.\n149 \n150     Metadata is verified to have the correct keys and their expected types. Any\n151     unknown keys/types will raise a warning.\n152 \n153     Parameters\n154     ----------\n155     backend : str\n156         The name of the backend to use in the Producer value.\n157 \n158     metadata : dict[str, Union[str, datetime, Name]]\n159         A dictionary of metadata supplied by the user with information\n160         following the PDF specification, also defined in\n161         `~.backend_pdf.PdfPages` below.\n162 \n163         If any value is *None*, then the key will be removed. This can be used\n164         to remove any pre-defined values.\n165 \n166     Returns\n167     -------\n168     dict[str, Union[str, datetime, Name]]\n169         A validated dictionary of metadata.\n170     \"\"\"\n171 \n172     # get source date from SOURCE_DATE_EPOCH, if set\n173     # See https://reproducible-builds.org/specs/source-date-epoch/\n174     source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n175     if source_date_epoch:\n176         source_date = datetime.utcfromtimestamp(int(source_date_epoch))\n177         source_date = source_date.replace(tzinfo=UTC)\n178     else:\n179         source_date = datetime.today()\n180 \n181     info = {\n182         'Creator': f'Matplotlib v{mpl.__version__}, https://matplotlib.org',\n183         'Producer': f'Matplotlib {backend} backend v{mpl.__version__}',\n184         'CreationDate': source_date,\n185         **metadata\n186     }\n187     info = {k: v for (k, v) in info.items() if v is not None}\n188 \n189     def is_string_like(x):\n190         return isinstance(x, str)\n191     is_string_like.text_for_warning = \"an instance of str\"\n192 \n193     def is_date(x):\n194         return isinstance(x, datetime)\n195     is_date.text_for_warning = \"an instance of datetime.datetime\"\n196 \n197     def check_trapped(x):\n198         if isinstance(x, Name):\n199             return x.name in (b'True', b'False', b'Unknown')\n200         else:\n201             return x in ('True', 'False', 'Unknown')\n202     check_trapped.text_for_warning = 'one of {\"True\", \"False\", \"Unknown\"}'\n203 \n204     keywords = {\n205         'Title': is_string_like,\n206         'Author': is_string_like,\n207         'Subject': is_string_like,\n208         'Keywords': is_string_like,\n209         'Creator': is_string_like,\n210         'Producer': is_string_like,\n211         'CreationDate': is_date,\n212         'ModDate': is_date,\n213         'Trapped': check_trapped,\n214     }\n215     for k in info:\n216         if k not in keywords:\n217             _api.warn_external(f'Unknown infodict keyword: {k!r}. '\n218                                f'Must be one of {set(keywords)!r}.')\n219         elif not keywords[k](info[k]):\n220             _api.warn_external(f'Bad value for infodict keyword {k}. '\n221                                f'Got {info[k]!r} which is not '\n222                                f'{keywords[k].text_for_warning}.')\n223     if 'Trapped' in info:\n224         info['Trapped'] = Name(info['Trapped'])\n225 \n226     return info\n227 \n228 \n229 def _datetime_to_pdf(d):\n230     \"\"\"\n231     Convert a datetime to a PDF string representing it.\n232 \n233     Used for PDF and PGF.\n234     \"\"\"\n235     r = d.strftime('D:%Y%m%d%H%M%S')\n236     z = d.utcoffset()\n237     if z is not None:\n238         z = z.seconds\n239     else:\n240         if time.daylight:\n241             z = time.altzone\n242         else:\n243             z = time.timezone\n244     if z == 0:\n245         r += 'Z'\n246     elif z < 0:\n247         r += \"+%02d'%02d'\" % ((-z) // 3600, (-z) % 3600)\n248     else:\n249         r += \"-%02d'%02d'\" % (z // 3600, z % 3600)\n250     return r\n251 \n252 \n253 def pdfRepr(obj):\n254     \"\"\"Map Python objects to PDF syntax.\"\"\"\n255 \n256     # Some objects defined later have their own pdfRepr method.\n257     if hasattr(obj, 'pdfRepr'):\n258         return obj.pdfRepr()\n259 \n260     # Floats. PDF does not have exponential notation (1.0e-10) so we\n261     # need to use %f with some precision.  Perhaps the precision\n262     # should adapt to the magnitude of the number?\n263     elif isinstance(obj, (float, np.floating)):\n264         if not np.isfinite(obj):\n265             raise ValueError(\"Can only output finite numbers in PDF\")\n266         r = b\"%.10f\" % obj\n267         return r.rstrip(b'0').rstrip(b'.')\n268 \n269     # Booleans. Needs to be tested before integers since\n270     # isinstance(True, int) is true.\n271     elif isinstance(obj, bool):\n272         return [b'false', b'true'][obj]\n273 \n274     # Integers are written as such.\n275     elif isinstance(obj, (int, np.integer)):\n276         return b\"%d\" % obj\n277 \n278     # Unicode strings are encoded in UTF-16BE with byte-order mark.\n279     elif isinstance(obj, str):\n280         try:\n281             # But maybe it's really ASCII?\n282             s = obj.encode('ASCII')\n283             return pdfRepr(s)\n284         except UnicodeEncodeError:\n285             s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')\n286             return pdfRepr(s)\n287 \n288     # Strings are written in parentheses, with backslashes and parens\n289     # escaped. Actually balanced parens are allowed, but it is\n290     # simpler to escape them all. TODO: cut long strings into lines;\n291     # I believe there is some maximum line length in PDF.\n292     elif isinstance(obj, bytes):\n293         return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'\n294 \n295     # Dictionaries. The keys must be PDF names, so if we find strings\n296     # there, we make Name objects from them. The values may be\n297     # anything, so the caller must ensure that PDF names are\n298     # represented as Name objects.\n299     elif isinstance(obj, dict):\n300         return _fill([\n301             b\"<<\",\n302             *[Name(k).pdfRepr() + b\" \" + pdfRepr(v) for k, v in obj.items()],\n303             b\">>\",\n304         ])\n305 \n306     # Lists.\n307     elif isinstance(obj, (list, tuple)):\n308         return _fill([b\"[\", *[pdfRepr(val) for val in obj], b\"]\"])\n309 \n310     # The null keyword.\n311     elif obj is None:\n312         return b'null'\n313 \n314     # A date.\n315     elif isinstance(obj, datetime):\n316         return pdfRepr(_datetime_to_pdf(obj))\n317 \n318     # A bounding box\n319     elif isinstance(obj, BboxBase):\n320         return _fill([pdfRepr(val) for val in obj.bounds])\n321 \n322     else:\n323         raise TypeError(\"Don't know a PDF representation for {} objects\"\n324                         .format(type(obj)))\n325 \n326 \n327 def _font_supports_glyph(fonttype, glyph):\n328     \"\"\"\n329     Returns True if the font is able to provide codepoint *glyph* in a PDF.\n330 \n331     For a Type 3 font, this method returns True only for single-byte\n332     characters. For Type 42 fonts this method return True if the character is\n333     from the Basic Multilingual Plane.\n334     \"\"\"\n335     if fonttype == 3:\n336         return glyph <= 255\n337     if fonttype == 42:\n338         return glyph <= 65535\n339     raise NotImplementedError()\n340 \n341 \n342 class Reference:\n343     \"\"\"\n344     PDF reference object.\n345 \n346     Use PdfFile.reserveObject() to create References.\n347     \"\"\"\n348 \n349     def __init__(self, id):\n350         self.id = id\n351 \n352     def __repr__(self):\n353         return \"<Reference %d>\" % self.id\n354 \n355     def pdfRepr(self):\n356         return b\"%d 0 R\" % self.id\n357 \n358     def write(self, contents, file):\n359         write = file.write\n360         write(b\"%d 0 obj\\n\" % self.id)\n361         write(pdfRepr(contents))\n362         write(b\"\\nendobj\\n\")\n363 \n364 \n365 @total_ordering\n366 class Name:\n367     \"\"\"PDF name object.\"\"\"\n368     __slots__ = ('name',)\n369     _hexify = {c: '#%02x' % c\n370                for c in {*range(256)} - {*range(ord('!'), ord('~') + 1)}}\n371 \n372     def __init__(self, name):\n373         if isinstance(name, Name):\n374             self.name = name.name\n375         else:\n376             if isinstance(name, bytes):\n377                 name = name.decode('ascii')\n378             self.name = name.translate(self._hexify).encode('ascii')\n379 \n380     def __repr__(self):\n381         return \"<Name %s>\" % self.name\n382 \n383     def __str__(self):\n384         return '/' + self.name.decode('ascii')\n385 \n386     def __eq__(self, other):\n387         return isinstance(other, Name) and self.name == other.name\n388 \n389     def __lt__(self, other):\n390         return isinstance(other, Name) and self.name < other.name\n391 \n392     def __hash__(self):\n393         return hash(self.name)\n394 \n395     @staticmethod\n396     @_api.deprecated(\"3.6\")\n397     def hexify(match):\n398         return '#%02x' % ord(match.group())\n399 \n400     def pdfRepr(self):\n401         return b'/' + self.name\n402 \n403 \n404 @_api.deprecated(\"3.6\")\n405 class Operator:\n406     __slots__ = ('op',)\n407 \n408     def __init__(self, op):\n409         self.op = op\n410 \n411     def __repr__(self):\n412         return '<Operator %s>' % self.op\n413 \n414     def pdfRepr(self):\n415         return self.op\n416 \n417 \n418 class Verbatim:\n419     \"\"\"Store verbatim PDF command content for later inclusion in the stream.\"\"\"\n420     def __init__(self, x):\n421         self._x = x\n422 \n423     def pdfRepr(self):\n424         return self._x\n425 \n426 \n427 class Op(Enum):\n428     \"\"\"PDF operators (not an exhaustive list).\"\"\"\n429 \n430     close_fill_stroke = b'b'\n431     fill_stroke = b'B'\n432     fill = b'f'\n433     closepath = b'h'\n434     close_stroke = b's'\n435     stroke = b'S'\n436     endpath = b'n'\n437     begin_text = b'BT'\n438     end_text = b'ET'\n439     curveto = b'c'\n440     rectangle = b're'\n441     lineto = b'l'\n442     moveto = b'm'\n443     concat_matrix = b'cm'\n444     use_xobject = b'Do'\n445     setgray_stroke = b'G'\n446     setgray_nonstroke = b'g'\n447     setrgb_stroke = b'RG'\n448     setrgb_nonstroke = b'rg'\n449     setcolorspace_stroke = b'CS'\n450     setcolorspace_nonstroke = b'cs'\n451     setcolor_stroke = b'SCN'\n452     setcolor_nonstroke = b'scn'\n453     setdash = b'd'\n454     setlinejoin = b'j'\n455     setlinecap = b'J'\n456     setgstate = b'gs'\n457     gsave = b'q'\n458     grestore = b'Q'\n459     textpos = b'Td'\n460     selectfont = b'Tf'\n461     textmatrix = b'Tm'\n462     show = b'Tj'\n463     showkern = b'TJ'\n464     setlinewidth = b'w'\n465     clip = b'W'\n466     shading = b'sh'\n467 \n468     op = _api.deprecated('3.6')(property(lambda self: self.value))\n469 \n470     def pdfRepr(self):\n471         return self.value\n472 \n473     @classmethod\n474     def paint_path(cls, fill, stroke):\n475         \"\"\"\n476         Return the PDF operator to paint a path.\n477 \n478         Parameters\n479         ----------\n480         fill : bool\n481             Fill the path with the fill color.\n482         stroke : bool\n483             Stroke the outline of the path with the line color.\n484         \"\"\"\n485         if stroke:\n486             if fill:\n487                 return cls.fill_stroke\n488             else:\n489                 return cls.stroke\n490         else:\n491             if fill:\n492                 return cls.fill\n493             else:\n494                 return cls.endpath\n495 \n496 \n497 class Stream:\n498     \"\"\"\n499     PDF stream object.\n500 \n501     This has no pdfRepr method. Instead, call begin(), then output the\n502     contents of the stream by calling write(), and finally call end().\n503     \"\"\"\n504     __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')\n505 \n506     def __init__(self, id, len, file, extra=None, png=None):\n507         \"\"\"\n508         Parameters\n509         ----------\n510         id : int\n511             Object id of the stream.\n512         len : Reference or None\n513             An unused Reference object for the length of the stream;\n514             None means to use a memory buffer so the length can be inlined.\n515         file : PdfFile\n516             The underlying object to write the stream to.\n517         extra : dict from Name to anything, or None\n518             Extra key-value pairs to include in the stream header.\n519         png : dict or None\n520             If the data is already png encoded, the decode parameters.\n521         \"\"\"\n522         self.id = id            # object id\n523         self.len = len          # id of length object\n524         self.pdfFile = file\n525         self.file = file.fh      # file to which the stream is written\n526         self.compressobj = None  # compression object\n527         if extra is None:\n528             self.extra = dict()\n529         else:\n530             self.extra = extra.copy()\n531         if png is not None:\n532             self.extra.update({'Filter':      Name('FlateDecode'),\n533                                'DecodeParms': png})\n534 \n535         self.pdfFile.recordXref(self.id)\n536         if mpl.rcParams['pdf.compression'] and not png:\n537             self.compressobj = zlib.compressobj(\n538                 mpl.rcParams['pdf.compression'])\n539         if self.len is None:\n540             self.file = BytesIO()\n541         else:\n542             self._writeHeader()\n543             self.pos = self.file.tell()\n544 \n545     def _writeHeader(self):\n546         write = self.file.write\n547         write(b\"%d 0 obj\\n\" % self.id)\n548         dict = self.extra\n549         dict['Length'] = self.len\n550         if mpl.rcParams['pdf.compression']:\n551             dict['Filter'] = Name('FlateDecode')\n552 \n553         write(pdfRepr(dict))\n554         write(b\"\\nstream\\n\")\n555 \n556     def end(self):\n557         \"\"\"Finalize stream.\"\"\"\n558 \n559         self._flush()\n560         if self.len is None:\n561             contents = self.file.getvalue()\n562             self.len = len(contents)\n563             self.file = self.pdfFile.fh\n564             self._writeHeader()\n565             self.file.write(contents)\n566             self.file.write(b\"\\nendstream\\nendobj\\n\")\n567         else:\n568             length = self.file.tell() - self.pos\n569             self.file.write(b\"\\nendstream\\nendobj\\n\")\n570             self.pdfFile.writeObject(self.len, length)\n571 \n572     def write(self, data):\n573         \"\"\"Write some data on the stream.\"\"\"\n574 \n575         if self.compressobj is None:\n576             self.file.write(data)\n577         else:\n578             compressed = self.compressobj.compress(data)\n579             self.file.write(compressed)\n580 \n581     def _flush(self):\n582         \"\"\"Flush the compression object.\"\"\"\n583 \n584         if self.compressobj is not None:\n585             compressed = self.compressobj.flush()\n586             self.file.write(compressed)\n587             self.compressobj = None\n588 \n589 \n590 def _get_pdf_charprocs(font_path, glyph_ids):\n591     font = get_font(font_path, hinting_factor=1)\n592     conv = 1000 / font.units_per_EM  # Conversion to PS units (1/1000's).\n593     procs = {}\n594     for glyph_id in glyph_ids:\n595         g = font.load_glyph(glyph_id, LOAD_NO_SCALE)\n596         # NOTE: We should be using round(), but instead use\n597         # \"(x+.5).astype(int)\" to keep backcompat with the old ttconv code\n598         # (this is different for negative x's).\n599         d1 = (np.array([g.horiAdvance, 0, *g.bbox]) * conv + .5).astype(int)\n600         v, c = font.get_path()\n601         v = (v * 64).astype(int)  # Back to TrueType's internal units (1/64's).\n602         # Backcompat with old ttconv code: control points between two quads are\n603         # omitted if they are exactly at the midpoint between the control of\n604         # the quad before and the quad after, but ttconv used to interpolate\n605         # *after* conversion to PS units, causing floating point errors.  Here\n606         # we reproduce ttconv's logic, detecting these \"implicit\" points and\n607         # re-interpolating them.  Note that occasionally (e.g. with DejaVu Sans\n608         # glyph \"0\") a point detected as \"implicit\" is actually explicit, and\n609         # will thus be shifted by 1.\n610         quads, = np.nonzero(c == 3)\n611         quads_on = quads[1::2]\n612         quads_mid_on = np.array(\n613             sorted({*quads_on} & {*(quads - 1)} & {*(quads + 1)}), int)\n614         implicit = quads_mid_on[\n615             (v[quads_mid_on]  # As above, use astype(int), not // division\n616              == ((v[quads_mid_on - 1] + v[quads_mid_on + 1]) / 2).astype(int))\n617             .all(axis=1)]\n618         if (font.postscript_name, glyph_id) in [\n619                 (\"DejaVuSerif-Italic\", 77),  # j\n620                 (\"DejaVuSerif-Italic\", 135),  # \\AA\n621         ]:\n622             v[:, 0] -= 1  # Hard-coded backcompat (FreeType shifts glyph by 1).\n623         v = (v * conv + .5).astype(int)  # As above re: truncation vs rounding.\n624         v[implicit] = ((  # Fix implicit points; again, truncate.\n625             (v[implicit - 1] + v[implicit + 1]) / 2).astype(int))\n626         procs[font.get_glyph_name(glyph_id)] = (\n627             \" \".join(map(str, d1)).encode(\"ascii\") + b\" d1\\n\"\n628             + _path.convert_to_string(\n629                 Path(v, c), None, None, False, None, -1,\n630                 # no code for quad Beziers triggers auto-conversion to cubics.\n631                 [b\"m\", b\"l\", b\"\", b\"c\", b\"h\"], True)\n632             + b\"f\")\n633     return procs\n634 \n635 \n636 class PdfFile:\n637     \"\"\"PDF file object.\"\"\"\n638 \n639     def __init__(self, filename, metadata=None):\n640         \"\"\"\n641         Parameters\n642         ----------\n643         filename : str or path-like or file-like\n644             Output target; if a string, a file will be opened for writing.\n645 \n646         metadata : dict from strings to strings and dates\n647             Information dictionary object (see PDF reference section 10.2.1\n648             'Document Information Dictionary'), e.g.:\n649             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n650 \n651             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n652             'Creator', 'Producer', 'CreationDate', 'ModDate', and\n653             'Trapped'. Values have been predefined for 'Creator', 'Producer'\n654             and 'CreationDate'. They can be removed by setting them to `None`.\n655         \"\"\"\n656         super().__init__()\n657 \n658         self._object_seq = itertools.count(1)  # consumed by reserveObject\n659         self.xrefTable = [[0, 65535, 'the zero object']]\n660         self.passed_in_file_object = False\n661         self.original_file_like = None\n662         self.tell_base = 0\n663         fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n664         if not opened:\n665             try:\n666                 self.tell_base = filename.tell()\n667             except IOError:\n668                 fh = BytesIO()\n669                 self.original_file_like = filename\n670             else:\n671                 fh = filename\n672                 self.passed_in_file_object = True\n673 \n674         self.fh = fh\n675         self.currentstream = None  # stream object to write to, if any\n676         fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n677         # Output some eight-bit chars as a comment so various utilities\n678         # recognize the file as binary by looking at the first few\n679         # lines (see note in section 3.4.1 of the PDF reference).\n680         fh.write(b\"%\\254\\334 \\253\\272\\n\")\n681 \n682         self.rootObject = self.reserveObject('root')\n683         self.pagesObject = self.reserveObject('pages')\n684         self.pageList = []\n685         self.fontObject = self.reserveObject('fonts')\n686         self._extGStateObject = self.reserveObject('extended graphics states')\n687         self.hatchObject = self.reserveObject('tiling patterns')\n688         self.gouraudObject = self.reserveObject('Gouraud triangles')\n689         self.XObjectObject = self.reserveObject('external objects')\n690         self.resourceObject = self.reserveObject('resources')\n691 \n692         root = {'Type': Name('Catalog'),\n693                 'Pages': self.pagesObject}\n694         self.writeObject(self.rootObject, root)\n695 \n696         self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n697 \n698         self.fontNames = {}     # maps filenames to internal font names\n699         self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n700         self.dviFontInfo = {}   # maps dvi font names to embedding information\n701         # differently encoded Type-1 fonts may share the same descriptor\n702         self.type1Descriptors = {}\n703         self._character_tracker = _backend_pdf_ps.CharacterTracker()\n704 \n705         self.alphaStates = {}   # maps alpha values to graphics state objects\n706         self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n707         self._soft_mask_states = {}\n708         self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n709         self._soft_mask_groups = []\n710         self.hatchPatterns = {}\n711         self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n712         self.gouraudTriangles = []\n713 \n714         self._images = {}\n715         self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n716 \n717         self.markers = {}\n718         self.multi_byte_charprocs = {}\n719 \n720         self.paths = []\n721 \n722         # A list of annotations for each page. Each entry is a tuple of the\n723         # overall Annots object reference that's inserted into the page object,\n724         # followed by a list of the actual annotations.\n725         self._annotations = []\n726         # For annotations added before a page is created; mostly for the\n727         # purpose of newTextnote.\n728         self.pageAnnotations = []\n729 \n730         # The PDF spec recommends to include every procset\n731         procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n732 \n733         # Write resource dictionary.\n734         # Possibly TODO: more general ExtGState (graphics state dictionaries)\n735         #                ColorSpace Pattern Shading Properties\n736         resources = {'Font': self.fontObject,\n737                      'XObject': self.XObjectObject,\n738                      'ExtGState': self._extGStateObject,\n739                      'Pattern': self.hatchObject,\n740                      'Shading': self.gouraudObject,\n741                      'ProcSet': procsets}\n742         self.writeObject(self.resourceObject, resources)\n743 \n744     def newPage(self, width, height):\n745         self.endStream()\n746 \n747         self.width, self.height = width, height\n748         contentObject = self.reserveObject('page contents')\n749         annotsObject = self.reserveObject('annotations')\n750         thePage = {'Type': Name('Page'),\n751                    'Parent': self.pagesObject,\n752                    'Resources': self.resourceObject,\n753                    'MediaBox': [0, 0, 72 * width, 72 * height],\n754                    'Contents': contentObject,\n755                    'Annots': annotsObject,\n756                    }\n757         pageObject = self.reserveObject('page')\n758         self.writeObject(pageObject, thePage)\n759         self.pageList.append(pageObject)\n760         self._annotations.append((annotsObject, self.pageAnnotations))\n761 \n762         self.beginStream(contentObject.id,\n763                          self.reserveObject('length of content stream'))\n764         # Initialize the pdf graphics state to match the default Matplotlib\n765         # graphics context (colorspace and joinstyle).\n766         self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)\n767         self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)\n768         self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n769 \n770         # Clear the list of annotations for the next page\n771         self.pageAnnotations = []\n772 \n773     def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n774         # Create a new annotation of type text\n775         theNote = {'Type': Name('Annot'),\n776                    'Subtype': Name('Text'),\n777                    'Contents': text,\n778                    'Rect': positionRect,\n779                    }\n780         self.pageAnnotations.append(theNote)\n781 \n782     def _get_subsetted_psname(self, ps_name, charmap):\n783         def toStr(n, base):\n784             if n < base:\n785                 return string.ascii_uppercase[n]\n786             else:\n787                 return (\n788                     toStr(n // base, base) + string.ascii_uppercase[n % base]\n789                 )\n790 \n791         # encode to string using base 26\n792         hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + 1) * 2)\n793         prefix = toStr(hashed, 26)\n794 \n795         # get first 6 characters from prefix\n796         return prefix[:6] + \"+\" + ps_name\n797 \n798     def finalize(self):\n799         \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n800 \n801         self.endStream()\n802         self._write_annotations()\n803         self.writeFonts()\n804         self.writeExtGSTates()\n805         self._write_soft_mask_groups()\n806         self.writeHatches()\n807         self.writeGouraudTriangles()\n808         xobjects = {\n809             name: ob for image, name, ob in self._images.values()}\n810         for tup in self.markers.values():\n811             xobjects[tup[0]] = tup[1]\n812         for name, value in self.multi_byte_charprocs.items():\n813             xobjects[name] = value\n814         for name, path, trans, ob, join, cap, padding, filled, stroked \\\n815                 in self.paths:\n816             xobjects[name] = ob\n817         self.writeObject(self.XObjectObject, xobjects)\n818         self.writeImages()\n819         self.writeMarkers()\n820         self.writePathCollectionTemplates()\n821         self.writeObject(self.pagesObject,\n822                          {'Type': Name('Pages'),\n823                           'Kids': self.pageList,\n824                           'Count': len(self.pageList)})\n825         self.writeInfoDict()\n826 \n827         # Finalize the file\n828         self.writeXref()\n829         self.writeTrailer()\n830 \n831     def close(self):\n832         \"\"\"Flush all buffers and free all resources.\"\"\"\n833 \n834         self.endStream()\n835         if self.passed_in_file_object:\n836             self.fh.flush()\n837         else:\n838             if self.original_file_like is not None:\n839                 self.original_file_like.write(self.fh.getvalue())\n840             self.fh.close()\n841 \n842     def write(self, data):\n843         if self.currentstream is None:\n844             self.fh.write(data)\n845         else:\n846             self.currentstream.write(data)\n847 \n848     def output(self, *data):\n849         self.write(_fill([pdfRepr(x) for x in data]))\n850         self.write(b'\\n')\n851 \n852     def beginStream(self, id, len, extra=None, png=None):\n853         assert self.currentstream is None\n854         self.currentstream = Stream(id, len, self, extra, png)\n855 \n856     def endStream(self):\n857         if self.currentstream is not None:\n858             self.currentstream.end()\n859             self.currentstream = None\n860 \n861     def outputStream(self, ref, data, *, extra=None):\n862         self.beginStream(ref.id, None, extra)\n863         self.currentstream.write(data)\n864         self.endStream()\n865 \n866     def _write_annotations(self):\n867         for annotsObject, annotations in self._annotations:\n868             self.writeObject(annotsObject, annotations)\n869 \n870     def fontName(self, fontprop):\n871         \"\"\"\n872         Select a font based on fontprop and return a name suitable for\n873         Op.selectfont. If fontprop is a string, it will be interpreted\n874         as the filename of the font.\n875         \"\"\"\n876 \n877         if isinstance(fontprop, str):\n878             filename = fontprop\n879         elif mpl.rcParams['pdf.use14corefonts']:\n880             filename = findfont(\n881                 fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)\n882         else:\n883             filename = findfont(fontprop)\n884 \n885         Fx = self.fontNames.get(filename)\n886         if Fx is None:\n887             Fx = next(self._internal_font_seq)\n888             self.fontNames[filename] = Fx\n889             _log.debug('Assigning font %s = %r', Fx, filename)\n890 \n891         return Fx\n892 \n893     def dviFontName(self, dvifont):\n894         \"\"\"\n895         Given a dvi font object, return a name suitable for Op.selectfont.\n896         This registers the font information in ``self.dviFontInfo`` if not yet\n897         registered.\n898         \"\"\"\n899 \n900         dvi_info = self.dviFontInfo.get(dvifont.texname)\n901         if dvi_info is not None:\n902             return dvi_info.pdfname\n903 \n904         tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))\n905         psfont = tex_font_map[dvifont.texname]\n906         if psfont.filename is None:\n907             raise ValueError(\n908                 \"No usable font file found for {} (TeX: {}); \"\n909                 \"the font may lack a Type-1 version\"\n910                 .format(psfont.psname, dvifont.texname))\n911 \n912         pdfname = next(self._internal_font_seq)\n913         _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n914         self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n915             dvifont=dvifont,\n916             pdfname=pdfname,\n917             fontfile=psfont.filename,\n918             basefont=psfont.psname,\n919             encodingfile=psfont.encoding,\n920             effects=psfont.effects)\n921         return pdfname\n922 \n923     def writeFonts(self):\n924         fonts = {}\n925         for dviname, info in sorted(self.dviFontInfo.items()):\n926             Fx = info.pdfname\n927             _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n928             fonts[Fx] = self._embedTeXFont(info)\n929         for filename in sorted(self.fontNames):\n930             Fx = self.fontNames[filename]\n931             _log.debug('Embedding font %s.', filename)\n932             if filename.endswith('.afm'):\n933                 # from pdf.use14corefonts\n934                 _log.debug('Writing AFM font.')\n935                 fonts[Fx] = self._write_afm_font(filename)\n936             else:\n937                 # a normal TrueType font\n938                 _log.debug('Writing TrueType font.')\n939                 chars = self._character_tracker.used.get(filename)\n940                 if chars:\n941                     fonts[Fx] = self.embedTTF(filename, chars)\n942         self.writeObject(self.fontObject, fonts)\n943 \n944     def _write_afm_font(self, filename):\n945         with open(filename, 'rb') as fh:\n946             font = AFM(fh)\n947         fontname = font.get_fontname()\n948         fontdict = {'Type': Name('Font'),\n949                     'Subtype': Name('Type1'),\n950                     'BaseFont': Name(fontname),\n951                     'Encoding': Name('WinAnsiEncoding')}\n952         fontdictObject = self.reserveObject('font dictionary')\n953         self.writeObject(fontdictObject, fontdict)\n954         return fontdictObject\n955 \n956     def _embedTeXFont(self, fontinfo):\n957         _log.debug('Embedding TeX font %s - fontinfo=%s',\n958                    fontinfo.dvifont.texname, fontinfo.__dict__)\n959 \n960         # Widths\n961         widthsObject = self.reserveObject('font widths')\n962         self.writeObject(widthsObject, fontinfo.dvifont.widths)\n963 \n964         # Font dictionary\n965         fontdictObject = self.reserveObject('font dictionary')\n966         fontdict = {\n967             'Type':      Name('Font'),\n968             'Subtype':   Name('Type1'),\n969             'FirstChar': 0,\n970             'LastChar':  len(fontinfo.dvifont.widths) - 1,\n971             'Widths':    widthsObject,\n972             }\n973 \n974         # Encoding (if needed)\n975         if fontinfo.encodingfile is not None:\n976             fontdict['Encoding'] = {\n977                 'Type': Name('Encoding'),\n978                 'Differences': [\n979                     0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],\n980             }\n981 \n982         # If no file is specified, stop short\n983         if fontinfo.fontfile is None:\n984             _log.warning(\n985                 \"Because of TeX configuration (pdftex.map, see updmap option \"\n986                 \"pdftexDownloadBase14) the font %s is not embedded. This is \"\n987                 \"deprecated as of PDF 1.5 and it may cause the consumer \"\n988                 \"application to show something that was not intended.\",\n989                 fontinfo.basefont)\n990             fontdict['BaseFont'] = Name(fontinfo.basefont)\n991             self.writeObject(fontdictObject, fontdict)\n992             return fontdictObject\n993 \n994         # We have a font file to embed - read it in and apply any effects\n995         t1font = _type1font.Type1Font(fontinfo.fontfile)\n996         if fontinfo.effects:\n997             t1font = t1font.transform(fontinfo.effects)\n998         fontdict['BaseFont'] = Name(t1font.prop['FontName'])\n999 \n1000         # Font descriptors may be shared between differently encoded\n1001         # Type-1 fonts, so only create a new descriptor if there is no\n1002         # existing descriptor for this font.\n1003         effects = (fontinfo.effects.get('slant', 0.0),\n1004                    fontinfo.effects.get('extend', 1.0))\n1005         fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))\n1006         if fontdesc is None:\n1007             fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)\n1008             self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc\n1009         fontdict['FontDescriptor'] = fontdesc\n1010 \n1011         self.writeObject(fontdictObject, fontdict)\n1012         return fontdictObject\n1013 \n1014     def createType1Descriptor(self, t1font, fontfile):\n1015         # Create and write the font descriptor and the font file\n1016         # of a Type-1 font\n1017         fontdescObject = self.reserveObject('font descriptor')\n1018         fontfileObject = self.reserveObject('font file')\n1019 \n1020         italic_angle = t1font.prop['ItalicAngle']\n1021         fixed_pitch = t1font.prop['isFixedPitch']\n1022 \n1023         flags = 0\n1024         # fixed width\n1025         if fixed_pitch:\n1026             flags |= 1 << 0\n1027         # TODO: serif\n1028         if 0:\n1029             flags |= 1 << 1\n1030         # TODO: symbolic (most TeX fonts are)\n1031         if 1:\n1032             flags |= 1 << 2\n1033         # non-symbolic\n1034         else:\n1035             flags |= 1 << 5\n1036         # italic\n1037         if italic_angle:\n1038             flags |= 1 << 6\n1039         # TODO: all caps\n1040         if 0:\n1041             flags |= 1 << 16\n1042         # TODO: small caps\n1043         if 0:\n1044             flags |= 1 << 17\n1045         # TODO: force bold\n1046         if 0:\n1047             flags |= 1 << 18\n1048 \n1049         ft2font = get_font(fontfile)\n1050 \n1051         descriptor = {\n1052             'Type':        Name('FontDescriptor'),\n1053             'FontName':    Name(t1font.prop['FontName']),\n1054             'Flags':       flags,\n1055             'FontBBox':    ft2font.bbox,\n1056             'ItalicAngle': italic_angle,\n1057             'Ascent':      ft2font.ascender,\n1058             'Descent':     ft2font.descender,\n1059             'CapHeight':   1000,  # TODO: find this out\n1060             'XHeight':     500,  # TODO: this one too\n1061             'FontFile':    fontfileObject,\n1062             'FontFamily':  t1font.prop['FamilyName'],\n1063             'StemV':       50,  # TODO\n1064             # (see also revision 3874; but not all TeX distros have AFM files!)\n1065             # 'FontWeight': a number where 400 = Regular, 700 = Bold\n1066             }\n1067 \n1068         self.writeObject(fontdescObject, descriptor)\n1069 \n1070         self.outputStream(fontfileObject, b\"\".join(t1font.parts[:2]),\n1071                           extra={'Length1': len(t1font.parts[0]),\n1072                                  'Length2': len(t1font.parts[1]),\n1073                                  'Length3': 0})\n1074 \n1075         return fontdescObject\n1076 \n1077     def _get_xobject_glyph_name(self, filename, glyph_name):\n1078         Fx = self.fontName(filename)\n1079         return \"-\".join([\n1080             Fx.name.decode(),\n1081             os.path.splitext(os.path.basename(filename))[0],\n1082             glyph_name])\n1083 \n1084     _identityToUnicodeCMap = b\"\"\"/CIDInit /ProcSet findresource begin\n1085 12 dict begin\n1086 begincmap\n1087 /CIDSystemInfo\n1088 << /Registry (Adobe)\n1089    /Ordering (UCS)\n1090    /Supplement 0\n1091 >> def\n1092 /CMapName /Adobe-Identity-UCS def\n1093 /CMapType 2 def\n1094 1 begincodespacerange\n1095 <0000> <ffff>\n1096 endcodespacerange\n1097 %d beginbfrange\n1098 %s\n1099 endbfrange\n1100 endcmap\n1101 CMapName currentdict /CMap defineresource pop\n1102 end\n1103 end\"\"\"\n1104 \n1105     def embedTTF(self, filename, characters):\n1106         \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n1107 \n1108         font = get_font(filename)\n1109         fonttype = mpl.rcParams['pdf.fonttype']\n1110 \n1111         def cvt(length, upe=font.units_per_EM, nearest=True):\n1112             \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n1113             value = length / upe * 1000\n1114             if nearest:\n1115                 return round(value)\n1116             # Best(?) to round away from zero for bounding boxes and the like.\n1117             if value < 0:\n1118                 return math.floor(value)\n1119             else:\n1120                 return math.ceil(value)\n1121 \n1122         def embedTTFType3(font, characters, descriptor):\n1123             \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n1124             widthsObject = self.reserveObject('font widths')\n1125             fontdescObject = self.reserveObject('font descriptor')\n1126             fontdictObject = self.reserveObject('font dictionary')\n1127             charprocsObject = self.reserveObject('character procs')\n1128             differencesArray = []\n1129             firstchar, lastchar = 0, 255\n1130             bbox = [cvt(x, nearest=False) for x in font.bbox]\n1131 \n1132             fontdict = {\n1133                 'Type': Name('Font'),\n1134                 'BaseFont': ps_name,\n1135                 'FirstChar': firstchar,\n1136                 'LastChar': lastchar,\n1137                 'FontDescriptor': fontdescObject,\n1138                 'Subtype': Name('Type3'),\n1139                 'Name': descriptor['FontName'],\n1140                 'FontBBox': bbox,\n1141                 'FontMatrix': [.001, 0, 0, .001, 0, 0],\n1142                 'CharProcs': charprocsObject,\n1143                 'Encoding': {\n1144                     'Type': Name('Encoding'),\n1145                     'Differences': differencesArray},\n1146                 'Widths': widthsObject\n1147                 }\n1148 \n1149             from encodings import cp1252\n1150 \n1151             # Make the \"Widths\" array\n1152             def get_char_width(charcode):\n1153                 s = ord(cp1252.decoding_table[charcode])\n1154                 width = font.load_char(\n1155                     s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n1156                 return cvt(width)\n1157 \n1158             with warnings.catch_warnings():\n1159                 # Ignore 'Required glyph missing from current font' warning\n1160                 # from ft2font: here we're just building the widths table, but\n1161                 # the missing glyphs may not even be used in the actual string.\n1162                 warnings.filterwarnings(\"ignore\")\n1163                 widths = [get_char_width(charcode)\n1164                           for charcode in range(firstchar, lastchar+1)]\n1165             descriptor['MaxWidth'] = max(widths)\n1166 \n1167             # Make the \"Differences\" array, sort the ccodes < 255 from\n1168             # the multi-byte ccodes, and build the whole set of glyph ids\n1169             # that we need from this font.\n1170             glyph_ids = []\n1171             differences = []\n1172             multi_byte_chars = set()\n1173             for c in characters:\n1174                 ccode = c\n1175                 gind = font.get_char_index(ccode)\n1176                 glyph_ids.append(gind)\n1177                 glyph_name = font.get_glyph_name(gind)\n1178                 if ccode <= 255:\n1179                     differences.append((ccode, glyph_name))\n1180                 else:\n1181                     multi_byte_chars.add(glyph_name)\n1182             differences.sort()\n1183 \n1184             last_c = -2\n1185             for c, name in differences:\n1186                 if c != last_c + 1:\n1187                     differencesArray.append(c)\n1188                 differencesArray.append(Name(name))\n1189                 last_c = c\n1190 \n1191             # Make the charprocs array.\n1192             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n1193             charprocs = {}\n1194             for charname in sorted(rawcharprocs):\n1195                 stream = rawcharprocs[charname]\n1196                 charprocDict = {}\n1197                 # The 2-byte characters are used as XObjects, so they\n1198                 # need extra info in their dictionary\n1199                 if charname in multi_byte_chars:\n1200                     charprocDict = {'Type': Name('XObject'),\n1201                                     'Subtype': Name('Form'),\n1202                                     'BBox': bbox}\n1203                     # Each glyph includes bounding box information,\n1204                     # but xpdf and ghostscript can't handle it in a\n1205                     # Form XObject (they segfault!!!), so we remove it\n1206                     # from the stream here.  It's not needed anyway,\n1207                     # since the Form XObject includes it in its BBox\n1208                     # value.\n1209                     stream = stream[stream.find(b\"d1\") + 2:]\n1210                 charprocObject = self.reserveObject('charProc')\n1211                 self.outputStream(charprocObject, stream, extra=charprocDict)\n1212 \n1213                 # Send the glyphs with ccode > 255 to the XObject dictionary,\n1214                 # and the others to the font itself\n1215                 if charname in multi_byte_chars:\n1216                     name = self._get_xobject_glyph_name(filename, charname)\n1217                     self.multi_byte_charprocs[name] = charprocObject\n1218                 else:\n1219                     charprocs[charname] = charprocObject\n1220 \n1221             # Write everything out\n1222             self.writeObject(fontdictObject, fontdict)\n1223             self.writeObject(fontdescObject, descriptor)\n1224             self.writeObject(widthsObject, widths)\n1225             self.writeObject(charprocsObject, charprocs)\n1226 \n1227             return fontdictObject\n1228 \n1229         def embedTTFType42(font, characters, descriptor):\n1230             \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n1231             fontdescObject = self.reserveObject('font descriptor')\n1232             cidFontDictObject = self.reserveObject('CID font dictionary')\n1233             type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n1234             cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n1235             fontfileObject = self.reserveObject('font file stream')\n1236             wObject = self.reserveObject('Type 0 widths')\n1237             toUnicodeMapObject = self.reserveObject('ToUnicode map')\n1238 \n1239             subset_str = \"\".join(chr(c) for c in characters)\n1240             _log.debug(\"SUBSET %s characters: %s\", filename, subset_str)\n1241             fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)\n1242             _log.debug(\n1243                 \"SUBSET %s %d -> %d\", filename,\n1244                 os.stat(filename).st_size, fontdata.getbuffer().nbytes\n1245             )\n1246 \n1247             # We need this ref for XObjects\n1248             full_font = font\n1249 \n1250             # reload the font object from the subset\n1251             # (all the necessary data could probably be obtained directly\n1252             # using fontLib.ttLib)\n1253             font = FT2Font(fontdata)\n1254 \n1255             cidFontDict = {\n1256                 'Type': Name('Font'),\n1257                 'Subtype': Name('CIDFontType2'),\n1258                 'BaseFont': ps_name,\n1259                 'CIDSystemInfo': {\n1260                     'Registry': 'Adobe',\n1261                     'Ordering': 'Identity',\n1262                     'Supplement': 0},\n1263                 'FontDescriptor': fontdescObject,\n1264                 'W': wObject,\n1265                 'CIDToGIDMap': cidToGidMapObject\n1266                 }\n1267 \n1268             type0FontDict = {\n1269                 'Type': Name('Font'),\n1270                 'Subtype': Name('Type0'),\n1271                 'BaseFont': ps_name,\n1272                 'Encoding': Name('Identity-H'),\n1273                 'DescendantFonts': [cidFontDictObject],\n1274                 'ToUnicode': toUnicodeMapObject\n1275                 }\n1276 \n1277             # Make fontfile stream\n1278             descriptor['FontFile2'] = fontfileObject\n1279             self.outputStream(\n1280                 fontfileObject, fontdata.getvalue(),\n1281                 extra={'Length1': fontdata.getbuffer().nbytes})\n1282 \n1283             # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n1284             # at the same time\n1285             cid_to_gid_map = ['\\0'] * 65536\n1286             widths = []\n1287             max_ccode = 0\n1288             for c in characters:\n1289                 ccode = c\n1290                 gind = font.get_char_index(ccode)\n1291                 glyph = font.load_char(ccode,\n1292                                        flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n1293                 widths.append((ccode, cvt(glyph.horiAdvance)))\n1294                 if ccode < 65536:\n1295                     cid_to_gid_map[ccode] = chr(gind)\n1296                 max_ccode = max(ccode, max_ccode)\n1297             widths.sort()\n1298             cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n1299 \n1300             last_ccode = -2\n1301             w = []\n1302             max_width = 0\n1303             unicode_groups = []\n1304             for ccode, width in widths:\n1305                 if ccode != last_ccode + 1:\n1306                     w.append(ccode)\n1307                     w.append([width])\n1308                     unicode_groups.append([ccode, ccode])\n1309                 else:\n1310                     w[-1].append(width)\n1311                     unicode_groups[-1][1] = ccode\n1312                 max_width = max(max_width, width)\n1313                 last_ccode = ccode\n1314 \n1315             unicode_bfrange = []\n1316             for start, end in unicode_groups:\n1317                 # Ensure the CID map contains only chars from BMP\n1318                 if start > 65535:\n1319                     continue\n1320                 end = min(65535, end)\n1321 \n1322                 unicode_bfrange.append(\n1323                     b\"<%04x> <%04x> [%s]\" %\n1324                     (start, end,\n1325                      b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n1326             unicode_cmap = (self._identityToUnicodeCMap %\n1327                             (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n1328 \n1329             # Add XObjects for unsupported chars\n1330             glyph_ids = []\n1331             for ccode in characters:\n1332                 if not _font_supports_glyph(fonttype, ccode):\n1333                     gind = full_font.get_char_index(ccode)\n1334                     glyph_ids.append(gind)\n1335 \n1336             bbox = [cvt(x, nearest=False) for x in full_font.bbox]\n1337             rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n1338             for charname in sorted(rawcharprocs):\n1339                 stream = rawcharprocs[charname]\n1340                 charprocDict = {'Type': Name('XObject'),\n1341                                 'Subtype': Name('Form'),\n1342                                 'BBox': bbox}\n1343                 # Each glyph includes bounding box information,\n1344                 # but xpdf and ghostscript can't handle it in a\n1345                 # Form XObject (they segfault!!!), so we remove it\n1346                 # from the stream here.  It's not needed anyway,\n1347                 # since the Form XObject includes it in its BBox\n1348                 # value.\n1349                 stream = stream[stream.find(b\"d1\") + 2:]\n1350                 charprocObject = self.reserveObject('charProc')\n1351                 self.outputStream(charprocObject, stream, extra=charprocDict)\n1352 \n1353                 name = self._get_xobject_glyph_name(filename, charname)\n1354                 self.multi_byte_charprocs[name] = charprocObject\n1355 \n1356             # CIDToGIDMap stream\n1357             cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n1358             self.outputStream(cidToGidMapObject, cid_to_gid_map)\n1359 \n1360             # ToUnicode CMap\n1361             self.outputStream(toUnicodeMapObject, unicode_cmap)\n1362 \n1363             descriptor['MaxWidth'] = max_width\n1364 \n1365             # Write everything out\n1366             self.writeObject(cidFontDictObject, cidFontDict)\n1367             self.writeObject(type0FontDictObject, type0FontDict)\n1368             self.writeObject(fontdescObject, descriptor)\n1369             self.writeObject(wObject, w)\n1370 \n1371             return type0FontDictObject\n1372 \n1373         # Beginning of main embedTTF function...\n1374 \n1375         ps_name = self._get_subsetted_psname(\n1376             font.postscript_name,\n1377             font.get_charmap()\n1378         )\n1379         ps_name = ps_name.encode('ascii', 'replace')\n1380         ps_name = Name(ps_name)\n1381         pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n1382         post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n1383         ff = font.face_flags\n1384         sf = font.style_flags\n1385 \n1386         flags = 0\n1387         symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n1388         if ff & FIXED_WIDTH:\n1389             flags |= 1 << 0\n1390         if 0:  # TODO: serif\n1391             flags |= 1 << 1\n1392         if symbolic:\n1393             flags |= 1 << 2\n1394         else:\n1395             flags |= 1 << 5\n1396         if sf & ITALIC:\n1397             flags |= 1 << 6\n1398         if 0:  # TODO: all caps\n1399             flags |= 1 << 16\n1400         if 0:  # TODO: small caps\n1401             flags |= 1 << 17\n1402         if 0:  # TODO: force bold\n1403             flags |= 1 << 18\n1404 \n1405         descriptor = {\n1406             'Type': Name('FontDescriptor'),\n1407             'FontName': ps_name,\n1408             'Flags': flags,\n1409             'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n1410             'Ascent': cvt(font.ascender, nearest=False),\n1411             'Descent': cvt(font.descender, nearest=False),\n1412             'CapHeight': cvt(pclt['capHeight'], nearest=False),\n1413             'XHeight': cvt(pclt['xHeight']),\n1414             'ItalicAngle': post['italicAngle'][1],  # ???\n1415             'StemV': 0  # ???\n1416             }\n1417 \n1418         if fonttype == 3:\n1419             return embedTTFType3(font, characters, descriptor)\n1420         elif fonttype == 42:\n1421             return embedTTFType42(font, characters, descriptor)\n1422 \n1423     def alphaState(self, alpha):\n1424         \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n1425 \n1426         state = self.alphaStates.get(alpha, None)\n1427         if state is not None:\n1428             return state[0]\n1429 \n1430         name = next(self._alpha_state_seq)\n1431         self.alphaStates[alpha] = \\\n1432             (name, {'Type': Name('ExtGState'),\n1433                     'CA': alpha[0], 'ca': alpha[1]})\n1434         return name\n1435 \n1436     def _soft_mask_state(self, smask):\n1437         \"\"\"\n1438         Return an ExtGState that sets the soft mask to the given shading.\n1439 \n1440         Parameters\n1441         ----------\n1442         smask : Reference\n1443             Reference to a shading in DeviceGray color space, whose luminosity\n1444             is to be used as the alpha channel.\n1445 \n1446         Returns\n1447         -------\n1448         Name\n1449         \"\"\"\n1450 \n1451         state = self._soft_mask_states.get(smask, None)\n1452         if state is not None:\n1453             return state[0]\n1454 \n1455         name = next(self._soft_mask_seq)\n1456         groupOb = self.reserveObject('transparency group for soft mask')\n1457         self._soft_mask_states[smask] = (\n1458             name,\n1459             {\n1460                 'Type': Name('ExtGState'),\n1461                 'AIS': False,\n1462                 'SMask': {\n1463                     'Type': Name('Mask'),\n1464                     'S': Name('Luminosity'),\n1465                     'BC': [1],\n1466                     'G': groupOb\n1467                 }\n1468             }\n1469         )\n1470         self._soft_mask_groups.append((\n1471             groupOb,\n1472             {\n1473                 'Type': Name('XObject'),\n1474                 'Subtype': Name('Form'),\n1475                 'FormType': 1,\n1476                 'Group': {\n1477                     'S': Name('Transparency'),\n1478                     'CS': Name('DeviceGray')\n1479                 },\n1480                 'Matrix': [1, 0, 0, 1, 0, 0],\n1481                 'Resources': {'Shading': {'S': smask}},\n1482                 'BBox': [0, 0, 1, 1]\n1483             },\n1484             [Name('S'), Op.shading]\n1485         ))\n1486         return name\n1487 \n1488     def writeExtGSTates(self):\n1489         self.writeObject(\n1490             self._extGStateObject,\n1491             dict([\n1492                 *self.alphaStates.values(),\n1493                 *self._soft_mask_states.values()\n1494             ])\n1495         )\n1496 \n1497     def _write_soft_mask_groups(self):\n1498         for ob, attributes, content in self._soft_mask_groups:\n1499             self.beginStream(ob.id, None, attributes)\n1500             self.output(*content)\n1501             self.endStream()\n1502 \n1503     def hatchPattern(self, hatch_style):\n1504         # The colors may come in as numpy arrays, which aren't hashable\n1505         if hatch_style is not None:\n1506             edge, face, hatch = hatch_style\n1507             if edge is not None:\n1508                 edge = tuple(edge)\n1509             if face is not None:\n1510                 face = tuple(face)\n1511             hatch_style = (edge, face, hatch)\n1512 \n1513         pattern = self.hatchPatterns.get(hatch_style, None)\n1514         if pattern is not None:\n1515             return pattern\n1516 \n1517         name = next(self._hatch_pattern_seq)\n1518         self.hatchPatterns[hatch_style] = name\n1519         return name\n1520 \n1521     def writeHatches(self):\n1522         hatchDict = dict()\n1523         sidelen = 72.0\n1524         for hatch_style, name in self.hatchPatterns.items():\n1525             ob = self.reserveObject('hatch pattern')\n1526             hatchDict[name] = ob\n1527             res = {'Procsets':\n1528                    [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n1529             self.beginStream(\n1530                 ob.id, None,\n1531                 {'Type': Name('Pattern'),\n1532                  'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n1533                  'BBox': [0, 0, sidelen, sidelen],\n1534                  'XStep': sidelen, 'YStep': sidelen,\n1535                  'Resources': res,\n1536                  # Change origin to match Agg at top-left.\n1537                  'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n1538 \n1539             stroke_rgb, fill_rgb, hatch = hatch_style\n1540             self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n1541                         Op.setrgb_stroke)\n1542             if fill_rgb is not None:\n1543                 self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n1544                             Op.setrgb_nonstroke,\n1545                             0, 0, sidelen, sidelen, Op.rectangle,\n1546                             Op.fill)\n1547 \n1548             self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n1549 \n1550             self.output(*self.pathOperations(\n1551                 Path.hatch(hatch),\n1552                 Affine2D().scale(sidelen),\n1553                 simplify=False))\n1554             self.output(Op.fill_stroke)\n1555 \n1556             self.endStream()\n1557         self.writeObject(self.hatchObject, hatchDict)\n1558 \n1559     def addGouraudTriangles(self, points, colors):\n1560         \"\"\"\n1561         Add a Gouraud triangle shading.\n1562 \n1563         Parameters\n1564         ----------\n1565         points : np.ndarray\n1566             Triangle vertices, shape (n, 3, 2)\n1567             where n = number of triangles, 3 = vertices, 2 = x, y.\n1568         colors : np.ndarray\n1569             Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n1570             as with points, but last dimension is either (gray,)\n1571             or (r, g, b, alpha).\n1572 \n1573         Returns\n1574         -------\n1575         Name, Reference\n1576         \"\"\"\n1577         name = Name('GT%d' % len(self.gouraudTriangles))\n1578         ob = self.reserveObject(f'Gouraud triangle {name}')\n1579         self.gouraudTriangles.append((name, ob, points, colors))\n1580         return name, ob\n1581 \n1582     def writeGouraudTriangles(self):\n1583         gouraudDict = dict()\n1584         for name, ob, points, colors in self.gouraudTriangles:\n1585             gouraudDict[name] = ob\n1586             shape = points.shape\n1587             flat_points = points.reshape((shape[0] * shape[1], 2))\n1588             colordim = colors.shape[2]\n1589             assert colordim in (1, 4)\n1590             flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n1591             if colordim == 4:\n1592                 # strip the alpha channel\n1593                 colordim = 3\n1594             points_min = np.min(flat_points, axis=0) - (1 << 8)\n1595             points_max = np.max(flat_points, axis=0) + (1 << 8)\n1596             factor = 0xffffffff / (points_max - points_min)\n1597 \n1598             self.beginStream(\n1599                 ob.id, None,\n1600                 {'ShadingType': 4,\n1601                  'BitsPerCoordinate': 32,\n1602                  'BitsPerComponent': 8,\n1603                  'BitsPerFlag': 8,\n1604                  'ColorSpace': Name(\n1605                      'DeviceRGB' if colordim == 3 else 'DeviceGray'\n1606                  ),\n1607                  'AntiAlias': False,\n1608                  'Decode': ([points_min[0], points_max[0],\n1609                              points_min[1], points_max[1]]\n1610                             + [0, 1] * colordim),\n1611                  })\n1612 \n1613             streamarr = np.empty(\n1614                 (shape[0] * shape[1],),\n1615                 dtype=[('flags', 'u1'),\n1616                        ('points', '>u4', (2,)),\n1617                        ('colors', 'u1', (colordim,))])\n1618             streamarr['flags'] = 0\n1619             streamarr['points'] = (flat_points - points_min) * factor\n1620             streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n1621 \n1622             self.write(streamarr.tobytes())\n1623             self.endStream()\n1624         self.writeObject(self.gouraudObject, gouraudDict)\n1625 \n1626     def imageObject(self, image):\n1627         \"\"\"Return name of an image XObject representing the given image.\"\"\"\n1628 \n1629         entry = self._images.get(id(image), None)\n1630         if entry is not None:\n1631             return entry[1]\n1632 \n1633         name = next(self._image_seq)\n1634         ob = self.reserveObject(f'image {name}')\n1635         self._images[id(image)] = (image, name, ob)\n1636         return name\n1637 \n1638     def _unpack(self, im):\n1639         \"\"\"\n1640         Unpack image array *im* into ``(data, alpha)``, which have shape\n1641         ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or\n1642         alpha), except that alpha is None if the image is fully opaque.\n1643         \"\"\"\n1644         im = im[::-1]\n1645         if im.ndim == 2:\n1646             return im, None\n1647         else:\n1648             rgb = im[:, :, :3]\n1649             rgb = np.array(rgb, order='C')\n1650             # PDF needs a separate alpha image\n1651             if im.shape[2] == 4:\n1652                 alpha = im[:, :, 3][..., None]\n1653                 if np.all(alpha == 255):\n1654                     alpha = None\n1655                 else:\n1656                     alpha = np.array(alpha, order='C')\n1657             else:\n1658                 alpha = None\n1659             return rgb, alpha\n1660 \n1661     def _writePng(self, img):\n1662         \"\"\"\n1663         Write the image *img* into the pdf file using png\n1664         predictors with Flate compression.\n1665         \"\"\"\n1666         buffer = BytesIO()\n1667         img.save(buffer, format=\"png\")\n1668         buffer.seek(8)\n1669         png_data = b''\n1670         bit_depth = palette = None\n1671         while True:\n1672             length, type = struct.unpack(b'!L4s', buffer.read(8))\n1673             if type in [b'IHDR', b'PLTE', b'IDAT']:\n1674                 data = buffer.read(length)\n1675                 if len(data) != length:\n1676                     raise RuntimeError(\"truncated data\")\n1677                 if type == b'IHDR':\n1678                     bit_depth = int(data[8])\n1679                 elif type == b'PLTE':\n1680                     palette = data\n1681                 elif type == b'IDAT':\n1682                     png_data += data\n1683             elif type == b'IEND':\n1684                 break\n1685             else:\n1686                 buffer.seek(length, 1)\n1687             buffer.seek(4, 1)   # skip CRC\n1688         return png_data, bit_depth, palette\n1689 \n1690     def _writeImg(self, data, id, smask=None):\n1691         \"\"\"\n1692         Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or\n1693         ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask\n1694         (alpha channel) *smask*, which should be either None or a ``(height,\n1695         width, 1)`` array.\n1696         \"\"\"\n1697         height, width, color_channels = data.shape\n1698         obj = {'Type': Name('XObject'),\n1699                'Subtype': Name('Image'),\n1700                'Width': width,\n1701                'Height': height,\n1702                'ColorSpace': Name({1: 'DeviceGray',\n1703                                    3: 'DeviceRGB'}[color_channels]),\n1704                'BitsPerComponent': 8}\n1705         if smask:\n1706             obj['SMask'] = smask\n1707         if mpl.rcParams['pdf.compression']:\n1708             if data.shape[-1] == 1:\n1709                 data = data.squeeze(axis=-1)\n1710             img = Image.fromarray(data)\n1711             img_colors = img.getcolors(maxcolors=256)\n1712             if color_channels == 3 and img_colors is not None:\n1713                 # Convert to indexed color if there are 256 colors or fewer\n1714                 # This can significantly reduce the file size\n1715                 num_colors = len(img_colors)\n1716                 # These constants were converted to IntEnums and deprecated in\n1717                 # Pillow 9.2\n1718                 dither = getattr(Image, 'Dither', Image).NONE\n1719                 pmode = getattr(Image, 'Palette', Image).ADAPTIVE\n1720                 img = img.convert(\n1721                     mode='P', dither=dither, palette=pmode, colors=num_colors\n1722                 )\n1723                 png_data, bit_depth, palette = self._writePng(img)\n1724                 if bit_depth is None or palette is None:\n1725                     raise RuntimeError(\"invalid PNG header\")\n1726                 palette = palette[:num_colors * 3]  # Trim padding\n1727                 obj['ColorSpace'] = Verbatim(\n1728                     b'[/Indexed /DeviceRGB %d %s]'\n1729                     % (num_colors - 1, pdfRepr(palette)))\n1730                 obj['BitsPerComponent'] = bit_depth\n1731                 color_channels = 1\n1732             else:\n1733                 png_data, _, _ = self._writePng(img)\n1734             png = {'Predictor': 10, 'Colors': color_channels, 'Columns': width}\n1735         else:\n1736             png = None\n1737         self.beginStream(\n1738             id,\n1739             self.reserveObject('length of image stream'),\n1740             obj,\n1741             png=png\n1742             )\n1743         if png:\n1744             self.currentstream.write(png_data)\n1745         else:\n1746             self.currentstream.write(data.tobytes())\n1747         self.endStream()\n1748 \n1749     def writeImages(self):\n1750         for img, name, ob in self._images.values():\n1751             data, adata = self._unpack(img)\n1752             if adata is not None:\n1753                 smaskObject = self.reserveObject(\"smask\")\n1754                 self._writeImg(adata, smaskObject.id)\n1755             else:\n1756                 smaskObject = None\n1757             self._writeImg(data, ob.id, smaskObject)\n1758 \n1759     def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n1760                      capstyle):\n1761         \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n1762         # self.markers used by markerObject, writeMarkers, close:\n1763         # mapping from (path operations, fill?, stroke?) to\n1764         #   [name, object reference, bounding box, linewidth]\n1765         # This enables different draw_markers calls to share the XObject\n1766         # if the gc is sufficiently similar: colors etc can vary, but\n1767         # the choices of whether to fill and whether to stroke cannot.\n1768         # We need a bounding box enclosing all of the XObject path,\n1769         # but since line width may vary, we store the maximum of all\n1770         # occurring line widths in self.markers.\n1771         # close() is somewhat tightly coupled in that it expects the\n1772         # first two components of each value in self.markers to be the\n1773         # name and object reference.\n1774         pathops = self.pathOperations(path, trans, simplify=False)\n1775         key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n1776         result = self.markers.get(key)\n1777         if result is None:\n1778             name = Name('M%d' % len(self.markers))\n1779             ob = self.reserveObject('marker %d' % len(self.markers))\n1780             bbox = path.get_extents(trans)\n1781             self.markers[key] = [name, ob, bbox, lw]\n1782         else:\n1783             if result[-1] < lw:\n1784                 result[-1] = lw\n1785             name = result[0]\n1786         return name\n1787 \n1788     def writeMarkers(self):\n1789         for ((pathops, fill, stroke, joinstyle, capstyle),\n1790              (name, ob, bbox, lw)) in self.markers.items():\n1791             # bbox wraps the exact limits of the control points, so half a line\n1792             # will appear outside it. If the join style is miter and the line\n1793             # is not parallel to the edge, then the line will extend even\n1794             # further. From the PDF specification, Section 8.4.3.5, the miter\n1795             # limit is miterLength / lineWidth and from Table 52, the default\n1796             # is 10. With half the miter length outside, that works out to the\n1797             # following padding:\n1798             bbox = bbox.padded(lw * 5)\n1799             self.beginStream(\n1800                 ob.id, None,\n1801                 {'Type': Name('XObject'), 'Subtype': Name('Form'),\n1802                  'BBox': list(bbox.extents)})\n1803             self.output(GraphicsContextPdf.joinstyles[joinstyle],\n1804                         Op.setlinejoin)\n1805             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n1806             self.output(*pathops)\n1807             self.output(Op.paint_path(fill, stroke))\n1808             self.endStream()\n1809 \n1810     def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n1811         name = Name('P%d' % len(self.paths))\n1812         ob = self.reserveObject('path %d' % len(self.paths))\n1813         self.paths.append(\n1814             (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n1815              padding, filled, stroked))\n1816         return name\n1817 \n1818     def writePathCollectionTemplates(self):\n1819         for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n1820              stroked) in self.paths:\n1821             pathops = self.pathOperations(path, trans, simplify=False)\n1822             bbox = path.get_extents(trans)\n1823             if not np.all(np.isfinite(bbox.extents)):\n1824                 extents = [0, 0, 0, 0]\n1825             else:\n1826                 bbox = bbox.padded(padding)\n1827                 extents = list(bbox.extents)\n1828             self.beginStream(\n1829                 ob.id, None,\n1830                 {'Type': Name('XObject'), 'Subtype': Name('Form'),\n1831                  'BBox': extents})\n1832             self.output(GraphicsContextPdf.joinstyles[joinstyle],\n1833                         Op.setlinejoin)\n1834             self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n1835             self.output(*pathops)\n1836             self.output(Op.paint_path(filled, stroked))\n1837             self.endStream()\n1838 \n1839     @staticmethod\n1840     def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n1841         return [Verbatim(_path.convert_to_string(\n1842             path, transform, clip, simplify, sketch,\n1843             6,\n1844             [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,\n1845              Op.closepath.value],\n1846             True))]\n1847 \n1848     def writePath(self, path, transform, clip=False, sketch=None):\n1849         if clip:\n1850             clip = (0.0, 0.0, self.width * 72, self.height * 72)\n1851             simplify = path.should_simplify\n1852         else:\n1853             clip = None\n1854             simplify = False\n1855         cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n1856                                    sketch=sketch)\n1857         self.output(*cmds)\n1858 \n1859     def reserveObject(self, name=''):\n1860         \"\"\"\n1861         Reserve an ID for an indirect object.\n1862 \n1863         The name is used for debugging in case we forget to print out\n1864         the object with writeObject.\n1865         \"\"\"\n1866         id = next(self._object_seq)\n1867         self.xrefTable.append([None, 0, name])\n1868         return Reference(id)\n1869 \n1870     def recordXref(self, id):\n1871         self.xrefTable[id][0] = self.fh.tell() - self.tell_base\n1872 \n1873     def writeObject(self, object, contents):\n1874         self.recordXref(object.id)\n1875         object.write(contents, self)\n1876 \n1877     def writeXref(self):\n1878         \"\"\"Write out the xref table.\"\"\"\n1879         self.startxref = self.fh.tell() - self.tell_base\n1880         self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n1881         for i, (offset, generation, name) in enumerate(self.xrefTable):\n1882             if offset is None:\n1883                 raise AssertionError(\n1884                     'No offset for object %d (%s)' % (i, name))\n1885             else:\n1886                 key = b\"f\" if name == 'the zero object' else b\"n\"\n1887                 text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n1888                 self.write(text)\n1889 \n1890     def writeInfoDict(self):\n1891         \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n1892 \n1893         self.infoObject = self.reserveObject('info')\n1894         self.writeObject(self.infoObject, self.infoDict)\n1895 \n1896     def writeTrailer(self):\n1897         \"\"\"Write out the PDF trailer.\"\"\"\n1898 \n1899         self.write(b\"trailer\\n\")\n1900         self.write(pdfRepr(\n1901             {'Size': len(self.xrefTable),\n1902              'Root': self.rootObject,\n1903              'Info': self.infoObject}))\n1904         # Could add 'ID'\n1905         self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)\n1906 \n1907 \n1908 class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):\n1909 \n1910     _afm_font_dir = cbook._get_data_path(\"fonts/pdfcorefonts\")\n1911     _use_afm_rc_name = \"pdf.use14corefonts\"\n1912 \n1913     def __init__(self, file, image_dpi, height, width):\n1914         super().__init__(width, height)\n1915         self.file = file\n1916         self.gc = self.new_gc()\n1917         self.image_dpi = image_dpi\n1918 \n1919     def finalize(self):\n1920         self.file.output(*self.gc.finalize())\n1921 \n1922     def check_gc(self, gc, fillcolor=None):\n1923         orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n1924         gc._fillcolor = fillcolor\n1925 \n1926         orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n1927 \n1928         if gc.get_rgb() is None:\n1929             # It should not matter what color here since linewidth should be\n1930             # 0 unless affected by global settings in rcParams, hence setting\n1931             # zero alpha just in case.\n1932             gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n1933 \n1934         if gc._forced_alpha:\n1935             gc._effective_alphas = (gc._alpha, gc._alpha)\n1936         elif fillcolor is None or len(fillcolor) < 4:\n1937             gc._effective_alphas = (gc._rgb[3], 1.0)\n1938         else:\n1939             gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n1940 \n1941         delta = self.gc.delta(gc)\n1942         if delta:\n1943             self.file.output(*delta)\n1944 \n1945         # Restore gc to avoid unwanted side effects\n1946         gc._fillcolor = orig_fill\n1947         gc._effective_alphas = orig_alphas\n1948 \n1949     def get_image_magnification(self):\n1950         return self.image_dpi/72.0\n1951 \n1952     def draw_image(self, gc, x, y, im, transform=None):\n1953         # docstring inherited\n1954 \n1955         h, w = im.shape[:2]\n1956         if w == 0 or h == 0:\n1957             return\n1958 \n1959         if transform is None:\n1960             # If there's no transform, alpha has already been applied\n1961             gc.set_alpha(1.0)\n1962 \n1963         self.check_gc(gc)\n1964 \n1965         w = 72.0 * w / self.image_dpi\n1966         h = 72.0 * h / self.image_dpi\n1967 \n1968         imob = self.file.imageObject(im)\n1969 \n1970         if transform is None:\n1971             self.file.output(Op.gsave,\n1972                              w, 0, 0, h, x, y, Op.concat_matrix,\n1973                              imob, Op.use_xobject, Op.grestore)\n1974         else:\n1975             tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n1976 \n1977             self.file.output(Op.gsave,\n1978                              1, 0, 0, 1, x, y, Op.concat_matrix,\n1979                              tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n1980                              imob, Op.use_xobject, Op.grestore)\n1981 \n1982     def draw_path(self, gc, path, transform, rgbFace=None):\n1983         # docstring inherited\n1984         self.check_gc(gc, rgbFace)\n1985         self.file.writePath(\n1986             path, transform,\n1987             rgbFace is None and gc.get_hatch_path() is None,\n1988             gc.get_sketch_params())\n1989         self.file.output(self.gc.paint())\n1990 \n1991     def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n1992                              offsets, offsetTrans, facecolors, edgecolors,\n1993                              linewidths, linestyles, antialiaseds, urls,\n1994                              offset_position):\n1995         # We can only reuse the objects if the presence of fill and\n1996         # stroke (and the amount of alpha for each) is the same for\n1997         # all of them\n1998         can_do_optimization = True\n1999         facecolors = np.asarray(facecolors)\n2000         edgecolors = np.asarray(edgecolors)\n2001 \n2002         if not len(facecolors):\n2003             filled = False\n2004             can_do_optimization = not gc.get_hatch()\n2005         else:\n2006             if np.all(facecolors[:, 3] == facecolors[0, 3]):\n2007                 filled = facecolors[0, 3] != 0.0\n2008             else:\n2009                 can_do_optimization = False\n2010 \n2011         if not len(edgecolors):\n2012             stroked = False\n2013         else:\n2014             if np.all(np.asarray(linewidths) == 0.0):\n2015                 stroked = False\n2016             elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n2017                 stroked = edgecolors[0, 3] != 0.0\n2018             else:\n2019                 can_do_optimization = False\n2020 \n2021         # Is the optimization worth it? Rough calculation:\n2022         # cost of emitting a path in-line is len_path * uses_per_path\n2023         # cost of XObject is len_path + 5 for the definition,\n2024         #    uses_per_path for the uses\n2025         len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n2026         uses_per_path = self._iter_collection_uses_per_path(\n2027             paths, all_transforms, offsets, facecolors, edgecolors)\n2028         should_do_optimization = \\\n2029             len_path + uses_per_path + 5 < len_path * uses_per_path\n2030 \n2031         if (not can_do_optimization) or (not should_do_optimization):\n2032             return RendererBase.draw_path_collection(\n2033                 self, gc, master_transform, paths, all_transforms,\n2034                 offsets, offsetTrans, facecolors, edgecolors,\n2035                 linewidths, linestyles, antialiaseds, urls,\n2036                 offset_position)\n2037 \n2038         padding = np.max(linewidths)\n2039         path_codes = []\n2040         for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n2041                 master_transform, paths, all_transforms)):\n2042             name = self.file.pathCollectionObject(\n2043                 gc, path, transform, padding, filled, stroked)\n2044             path_codes.append(name)\n2045 \n2046         output = self.file.output\n2047         output(*self.gc.push())\n2048         lastx, lasty = 0, 0\n2049         for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n2050                 gc, master_transform, all_transforms, path_codes, offsets,\n2051                 offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n2052                 antialiaseds, urls, offset_position):\n2053 \n2054             self.check_gc(gc0, rgbFace)\n2055             dx, dy = xo - lastx, yo - lasty\n2056             output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n2057                    Op.use_xobject)\n2058             lastx, lasty = xo, yo\n2059         output(*self.gc.pop())\n2060 \n2061     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n2062                      rgbFace=None):\n2063         # docstring inherited\n2064 \n2065         # Same logic as in draw_path_collection\n2066         len_marker_path = len(marker_path)\n2067         uses = len(path)\n2068         if len_marker_path * uses < len_marker_path + uses + 5:\n2069             RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n2070                                       path, trans, rgbFace)\n2071             return\n2072 \n2073         self.check_gc(gc, rgbFace)\n2074         fill = gc.fill(rgbFace)\n2075         stroke = gc.stroke()\n2076 \n2077         output = self.file.output\n2078         marker = self.file.markerObject(\n2079             marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n2080             gc.get_joinstyle(), gc.get_capstyle())\n2081 \n2082         output(Op.gsave)\n2083         lastx, lasty = 0, 0\n2084         for vertices, code in path.iter_segments(\n2085                 trans,\n2086                 clip=(0, 0, self.file.width*72, self.file.height*72),\n2087                 simplify=False):\n2088             if len(vertices):\n2089                 x, y = vertices[-2:]\n2090                 if not (0 <= x <= self.file.width * 72\n2091                         and 0 <= y <= self.file.height * 72):\n2092                     continue\n2093                 dx, dy = x - lastx, y - lasty\n2094                 output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n2095                        marker, Op.use_xobject)\n2096                 lastx, lasty = x, y\n2097         output(Op.grestore)\n2098 \n2099     def draw_gouraud_triangle(self, gc, points, colors, trans):\n2100         self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n2101                                     colors.reshape((1, 3, 4)), trans)\n2102 \n2103     def draw_gouraud_triangles(self, gc, points, colors, trans):\n2104         assert len(points) == len(colors)\n2105         if len(points) == 0:\n2106             return\n2107         assert points.ndim == 3\n2108         assert points.shape[1] == 3\n2109         assert points.shape[2] == 2\n2110         assert colors.ndim == 3\n2111         assert colors.shape[1] == 3\n2112         assert colors.shape[2] in (1, 4)\n2113 \n2114         shape = points.shape\n2115         points = points.reshape((shape[0] * shape[1], 2))\n2116         tpoints = trans.transform(points)\n2117         tpoints = tpoints.reshape(shape)\n2118         name, _ = self.file.addGouraudTriangles(tpoints, colors)\n2119         output = self.file.output\n2120 \n2121         if colors.shape[2] == 1:\n2122             # grayscale\n2123             gc.set_alpha(1.0)\n2124             self.check_gc(gc)\n2125             output(name, Op.shading)\n2126             return\n2127 \n2128         alpha = colors[0, 0, 3]\n2129         if np.allclose(alpha, colors[:, :, 3]):\n2130             # single alpha value\n2131             gc.set_alpha(alpha)\n2132             self.check_gc(gc)\n2133             output(name, Op.shading)\n2134         else:\n2135             # varying alpha: use a soft mask\n2136             alpha = colors[:, :, 3][:, :, None]\n2137             _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n2138             gstate = self.file._soft_mask_state(smask_ob)\n2139             output(Op.gsave, gstate, Op.setgstate,\n2140                    name, Op.shading,\n2141                    Op.grestore)\n2142 \n2143     def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n2144         if angle == oldangle == 0:\n2145             self.file.output(x - oldx, y - oldy, Op.textpos)\n2146         else:\n2147             angle = math.radians(angle)\n2148             self.file.output(math.cos(angle), math.sin(angle),\n2149                              -math.sin(angle), math.cos(angle),\n2150                              x, y, Op.textmatrix)\n2151             self.file.output(0, 0, Op.textpos)\n2152 \n2153     def draw_mathtext(self, gc, x, y, s, prop, angle):\n2154         # TODO: fix positioning and encoding\n2155         width, height, descent, glyphs, rects = \\\n2156             self._text2path.mathtext_parser.parse(s, 72, prop)\n2157 \n2158         if gc.get_url() is not None:\n2159             link_annotation = {\n2160                 'Type': Name('Annot'),\n2161                 'Subtype': Name('Link'),\n2162                 'Rect': (x, y, x + width, y + height),\n2163                 'Border': [0, 0, 0],\n2164                 'A': {\n2165                     'S': Name('URI'),\n2166                     'URI': gc.get_url(),\n2167                 },\n2168             }\n2169             self.file._annotations[-1][1].append(link_annotation)\n2170 \n2171         fonttype = mpl.rcParams['pdf.fonttype']\n2172 \n2173         # Set up a global transformation matrix for the whole math expression\n2174         a = math.radians(angle)\n2175         self.file.output(Op.gsave)\n2176         self.file.output(math.cos(a), math.sin(a),\n2177                          -math.sin(a), math.cos(a),\n2178                          x, y, Op.concat_matrix)\n2179 \n2180         self.check_gc(gc, gc._rgb)\n2181         prev_font = None, None\n2182         oldx, oldy = 0, 0\n2183         unsupported_chars = []\n2184 \n2185         self.file.output(Op.begin_text)\n2186         for font, fontsize, num, ox, oy in glyphs:\n2187             self.file._character_tracker.track_glyph(font, num)\n2188             fontname = font.fname\n2189             if not _font_supports_glyph(fonttype, num):\n2190                 # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n2191                 # Type 42) must be emitted separately (below).\n2192                 unsupported_chars.append((font, fontsize, ox, oy, num))\n2193             else:\n2194                 self._setup_textpos(ox, oy, 0, oldx, oldy)\n2195                 oldx, oldy = ox, oy\n2196                 if (fontname, fontsize) != prev_font:\n2197                     self.file.output(self.file.fontName(fontname), fontsize,\n2198                                      Op.selectfont)\n2199                     prev_font = fontname, fontsize\n2200                 self.file.output(self.encode_string(chr(num), fonttype),\n2201                                  Op.show)\n2202         self.file.output(Op.end_text)\n2203 \n2204         for font, fontsize, ox, oy, num in unsupported_chars:\n2205             self._draw_xobject_glyph(\n2206                 font, fontsize, font.get_char_index(num), ox, oy)\n2207 \n2208         # Draw any horizontal lines in the math layout\n2209         for ox, oy, width, height in rects:\n2210             self.file.output(Op.gsave, ox, oy, width, height,\n2211                              Op.rectangle, Op.fill, Op.grestore)\n2212 \n2213         # Pop off the global transformation\n2214         self.file.output(Op.grestore)\n2215 \n2216     def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n2217         # docstring inherited\n2218         texmanager = self.get_texmanager()\n2219         fontsize = prop.get_size_in_points()\n2220         dvifile = texmanager.make_dvi(s, fontsize)\n2221         with dviread.Dvi(dvifile, 72) as dvi:\n2222             page, = dvi\n2223 \n2224         if gc.get_url() is not None:\n2225             link_annotation = {\n2226                 'Type': Name('Annot'),\n2227                 'Subtype': Name('Link'),\n2228                 'Rect': (x, y, x + page.width, y + page.height),\n2229                 'Border': [0, 0, 0],\n2230                 'A': {\n2231                     'S': Name('URI'),\n2232                     'URI': gc.get_url(),\n2233                 },\n2234             }\n2235             self.file._annotations[-1][1].append(link_annotation)\n2236 \n2237         # Gather font information and do some setup for combining\n2238         # characters into strings. The variable seq will contain a\n2239         # sequence of font and text entries. A font entry is a list\n2240         # ['font', name, size] where name is a Name object for the\n2241         # font. A text entry is ['text', x, y, glyphs, x+w] where x\n2242         # and y are the starting coordinates, w is the width, and\n2243         # glyphs is a list; in this phase it will always contain just\n2244         # one one-character string, but later it may have longer\n2245         # strings interspersed with kern amounts.\n2246         oldfont, seq = None, []\n2247         for x1, y1, dvifont, glyph, width in page.text:\n2248             if dvifont != oldfont:\n2249                 pdfname = self.file.dviFontName(dvifont)\n2250                 seq += [['font', pdfname, dvifont.size]]\n2251                 oldfont = dvifont\n2252             seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n2253 \n2254         # Find consecutive text strings with constant y coordinate and\n2255         # combine into a sequence of strings and kerns, or just one\n2256         # string (if any kerns would be less than 0.1 points).\n2257         i, curx, fontsize = 0, 0, None\n2258         while i < len(seq)-1:\n2259             elt, nxt = seq[i:i+2]\n2260             if elt[0] == 'font':\n2261                 fontsize = elt[2]\n2262             elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n2263                 offset = elt[4] - nxt[1]\n2264                 if abs(offset) < 0.1:\n2265                     elt[3][-1] += nxt[3][0]\n2266                     elt[4] += nxt[4]-nxt[1]\n2267                 else:\n2268                     elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n2269                     elt[4] = nxt[4]\n2270                 del seq[i+1]\n2271                 continue\n2272             i += 1\n2273 \n2274         # Create a transform to map the dvi contents to the canvas.\n2275         mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n2276 \n2277         # Output the text.\n2278         self.check_gc(gc, gc._rgb)\n2279         self.file.output(Op.begin_text)\n2280         curx, cury, oldx, oldy = 0, 0, 0, 0\n2281         for elt in seq:\n2282             if elt[0] == 'font':\n2283                 self.file.output(elt[1], elt[2], Op.selectfont)\n2284             elif elt[0] == 'text':\n2285                 curx, cury = mytrans.transform((elt[1], elt[2]))\n2286                 self._setup_textpos(curx, cury, angle, oldx, oldy)\n2287                 oldx, oldy = curx, cury\n2288                 if len(elt[3]) == 1:\n2289                     self.file.output(elt[3][0], Op.show)\n2290                 else:\n2291                     self.file.output(elt[3], Op.showkern)\n2292             else:\n2293                 assert False\n2294         self.file.output(Op.end_text)\n2295 \n2296         # Then output the boxes (e.g., variable-length lines of square\n2297         # roots).\n2298         boxgc = self.new_gc()\n2299         boxgc.copy_properties(gc)\n2300         boxgc.set_linewidth(0)\n2301         pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n2302                    Path.CLOSEPOLY]\n2303         for x1, y1, h, w in page.boxes:\n2304             path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n2305                          [0, 0]], pathops)\n2306             self.draw_path(boxgc, path, mytrans, gc._rgb)\n2307 \n2308     def encode_string(self, s, fonttype):\n2309         if fonttype in (1, 3):\n2310             return s.encode('cp1252', 'replace')\n2311         return s.encode('utf-16be', 'replace')\n2312 \n2313     def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n2314         # docstring inherited\n2315 \n2316         # TODO: combine consecutive texts into one BT/ET delimited section\n2317 \n2318         self.check_gc(gc, gc._rgb)\n2319         if ismath:\n2320             return self.draw_mathtext(gc, x, y, s, prop, angle)\n2321 \n2322         fontsize = prop.get_size_in_points()\n2323 \n2324         if mpl.rcParams['pdf.use14corefonts']:\n2325             font = self._get_font_afm(prop)\n2326             fonttype = 1\n2327         else:\n2328             font = self._get_font_ttf(prop)\n2329             self.file._character_tracker.track(font, s)\n2330             fonttype = mpl.rcParams['pdf.fonttype']\n2331 \n2332         if gc.get_url() is not None:\n2333             font.set_text(s)\n2334             width, height = font.get_width_height()\n2335             link_annotation = {\n2336                 'Type': Name('Annot'),\n2337                 'Subtype': Name('Link'),\n2338                 'Rect': (x, y, x + width / 64, y + height / 64),\n2339                 'Border': [0, 0, 0],\n2340                 'A': {\n2341                     'S': Name('URI'),\n2342                     'URI': gc.get_url(),\n2343                 },\n2344             }\n2345             self.file._annotations[-1][1].append(link_annotation)\n2346 \n2347         # If fonttype is neither 3 nor 42, emit the whole string at once\n2348         # without manual kerning.\n2349         if fonttype not in [3, 42]:\n2350             self.file.output(Op.begin_text,\n2351                              self.file.fontName(prop), fontsize, Op.selectfont)\n2352             self._setup_textpos(x, y, angle)\n2353             self.file.output(self.encode_string(s, fonttype),\n2354                              Op.show, Op.end_text)\n2355 \n2356         # A sequence of characters is broken into multiple chunks. The chunking\n2357         # serves two purposes:\n2358         #   - For Type 3 fonts, there is no way to access multibyte characters,\n2359         #     as they cannot have a CIDMap.  Therefore, in this case we break\n2360         #     the string into chunks, where each chunk contains either a string\n2361         #     of consecutive 1-byte characters or a single multibyte character.\n2362         #   - A sequence of 1-byte characters is split into chunks to allow for\n2363         #     kerning adjustments between consecutive chunks.\n2364         #\n2365         # Each chunk is emitted with a separate command: 1-byte characters use\n2366         # the regular text show command (TJ) with appropriate kerning between\n2367         # chunks, whereas multibyte characters use the XObject command (Do).\n2368         else:\n2369             # List of (start_x, [prev_kern, char, char, ...]), w/o zero kerns.\n2370             singlebyte_chunks = []\n2371             # List of (start_x, glyph_index).\n2372             multibyte_glyphs = []\n2373             prev_was_multibyte = True\n2374             for item in _text_helpers.layout(\n2375                     s, font, kern_mode=KERNING_UNFITTED):\n2376                 if _font_supports_glyph(fonttype, ord(item.char)):\n2377                     if prev_was_multibyte:\n2378                         singlebyte_chunks.append((item.x, []))\n2379                     if item.prev_kern:\n2380                         singlebyte_chunks[-1][1].append(item.prev_kern)\n2381                     singlebyte_chunks[-1][1].append(item.char)\n2382                     prev_was_multibyte = False\n2383                 else:\n2384                     multibyte_glyphs.append((item.x, item.glyph_idx))\n2385                     prev_was_multibyte = True\n2386             # Do the rotation and global translation as a single matrix\n2387             # concatenation up front\n2388             self.file.output(Op.gsave)\n2389             a = math.radians(angle)\n2390             self.file.output(math.cos(a), math.sin(a),\n2391                              -math.sin(a), math.cos(a),\n2392                              x, y, Op.concat_matrix)\n2393             # Emit all the 1-byte characters in a BT/ET group.\n2394             self.file.output(Op.begin_text,\n2395                              self.file.fontName(prop), fontsize, Op.selectfont)\n2396             prev_start_x = 0\n2397             for start_x, kerns_or_chars in singlebyte_chunks:\n2398                 self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n2399                 self.file.output(\n2400                     # See pdf spec \"Text space details\" for the 1000/fontsize\n2401                     # (aka. 1000/T_fs) factor.\n2402                     [-1000 * next(group) / fontsize if tp == float  # a kern\n2403                      else self.encode_string(\"\".join(group), fonttype)\n2404                      for tp, group in itertools.groupby(kerns_or_chars, type)],\n2405                     Op.showkern)\n2406                 prev_start_x = start_x\n2407             self.file.output(Op.end_text)\n2408             # Then emit all the multibyte characters, one at a time.\n2409             for start_x, glyph_idx in multibyte_glyphs:\n2410                 self._draw_xobject_glyph(font, fontsize, glyph_idx, start_x, 0)\n2411             self.file.output(Op.grestore)\n2412 \n2413     def _draw_xobject_glyph(self, font, fontsize, glyph_idx, x, y):\n2414         \"\"\"Draw a multibyte character from a Type 3 font as an XObject.\"\"\"\n2415         glyph_name = font.get_glyph_name(glyph_idx)\n2416         name = self.file._get_xobject_glyph_name(font.fname, glyph_name)\n2417         self.file.output(\n2418             Op.gsave,\n2419             0.001 * fontsize, 0, 0, 0.001 * fontsize, x, y, Op.concat_matrix,\n2420             Name(name), Op.use_xobject,\n2421             Op.grestore,\n2422         )\n2423 \n2424     def new_gc(self):\n2425         # docstring inherited\n2426         return GraphicsContextPdf(self.file)\n2427 \n2428 \n2429 class GraphicsContextPdf(GraphicsContextBase):\n2430 \n2431     def __init__(self, file):\n2432         super().__init__()\n2433         self._fillcolor = (0.0, 0.0, 0.0)\n2434         self._effective_alphas = (1.0, 1.0)\n2435         self.file = file\n2436         self.parent = None\n2437 \n2438     def __repr__(self):\n2439         d = dict(self.__dict__)\n2440         del d['file']\n2441         del d['parent']\n2442         return repr(d)\n2443 \n2444     def stroke(self):\n2445         \"\"\"\n2446         Predicate: does the path need to be stroked (its outline drawn)?\n2447         This tests for the various conditions that disable stroking\n2448         the path, in which case it would presumably be filled.\n2449         \"\"\"\n2450         # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n2451         #   possible device width, but e.g., agg doesn't draw at all\n2452         return (self._linewidth > 0 and self._alpha > 0 and\n2453                 (len(self._rgb) <= 3 or self._rgb[3] != 0.0))\n2454 \n2455     def fill(self, *args):\n2456         \"\"\"\n2457         Predicate: does the path need to be filled?\n2458 \n2459         An optional argument can be used to specify an alternative\n2460         _fillcolor, as needed by RendererPdf.draw_markers.\n2461         \"\"\"\n2462         if len(args):\n2463             _fillcolor = args[0]\n2464         else:\n2465             _fillcolor = self._fillcolor\n2466         return (self._hatch or\n2467                 (_fillcolor is not None and\n2468                  (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))\n2469 \n2470     def paint(self):\n2471         \"\"\"\n2472         Return the appropriate pdf operator to cause the path to be\n2473         stroked, filled, or both.\n2474         \"\"\"\n2475         return Op.paint_path(self.fill(), self.stroke())\n2476 \n2477     capstyles = {'butt': 0, 'round': 1, 'projecting': 2}\n2478     joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}\n2479 \n2480     def capstyle_cmd(self, style):\n2481         return [self.capstyles[style], Op.setlinecap]\n2482 \n2483     def joinstyle_cmd(self, style):\n2484         return [self.joinstyles[style], Op.setlinejoin]\n2485 \n2486     def linewidth_cmd(self, width):\n2487         return [width, Op.setlinewidth]\n2488 \n2489     def dash_cmd(self, dashes):\n2490         offset, dash = dashes\n2491         if dash is None:\n2492             dash = []\n2493             offset = 0\n2494         return [list(dash), offset, Op.setdash]\n2495 \n2496     def alpha_cmd(self, alpha, forced, effective_alphas):\n2497         name = self.file.alphaState(effective_alphas)\n2498         return [name, Op.setgstate]\n2499 \n2500     def hatch_cmd(self, hatch, hatch_color):\n2501         if not hatch:\n2502             if self._fillcolor is not None:\n2503                 return self.fillcolor_cmd(self._fillcolor)\n2504             else:\n2505                 return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n2506         else:\n2507             hatch_style = (hatch_color, self._fillcolor, hatch)\n2508             name = self.file.hatchPattern(hatch_style)\n2509             return [Name('Pattern'), Op.setcolorspace_nonstroke,\n2510                     name, Op.setcolor_nonstroke]\n2511 \n2512     def rgb_cmd(self, rgb):\n2513         if mpl.rcParams['pdf.inheritcolor']:\n2514             return []\n2515         if rgb[0] == rgb[1] == rgb[2]:\n2516             return [rgb[0], Op.setgray_stroke]\n2517         else:\n2518             return [*rgb[:3], Op.setrgb_stroke]\n2519 \n2520     def fillcolor_cmd(self, rgb):\n2521         if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n2522             return []\n2523         elif rgb[0] == rgb[1] == rgb[2]:\n2524             return [rgb[0], Op.setgray_nonstroke]\n2525         else:\n2526             return [*rgb[:3], Op.setrgb_nonstroke]\n2527 \n2528     def push(self):\n2529         parent = GraphicsContextPdf(self.file)\n2530         parent.copy_properties(self)\n2531         parent.parent = self.parent\n2532         self.parent = parent\n2533         return [Op.gsave]\n2534 \n2535     def pop(self):\n2536         assert self.parent is not None\n2537         self.copy_properties(self.parent)\n2538         self.parent = self.parent.parent\n2539         return [Op.grestore]\n2540 \n2541     def clip_cmd(self, cliprect, clippath):\n2542         \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n2543         cmds = []\n2544         # Pop graphics state until we hit the right one or the stack is empty\n2545         while ((self._cliprect, self._clippath) != (cliprect, clippath)\n2546                 and self.parent is not None):\n2547             cmds.extend(self.pop())\n2548         # Unless we hit the right one, set the clip polygon\n2549         if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n2550                 self.parent is None):\n2551             cmds.extend(self.push())\n2552             if self._cliprect != cliprect:\n2553                 cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n2554             if self._clippath != clippath:\n2555                 path, affine = clippath.get_transformed_path_and_affine()\n2556                 cmds.extend(\n2557                     PdfFile.pathOperations(path, affine, simplify=False) +\n2558                     [Op.clip, Op.endpath])\n2559         return cmds\n2560 \n2561     commands = (\n2562         # must come first since may pop\n2563         (('_cliprect', '_clippath'), clip_cmd),\n2564         (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),\n2565         (('_capstyle',), capstyle_cmd),\n2566         (('_fillcolor',), fillcolor_cmd),\n2567         (('_joinstyle',), joinstyle_cmd),\n2568         (('_linewidth',), linewidth_cmd),\n2569         (('_dashes',), dash_cmd),\n2570         (('_rgb',), rgb_cmd),\n2571         # must come after fillcolor and rgb\n2572         (('_hatch', '_hatch_color'), hatch_cmd),\n2573         )\n2574 \n2575     def delta(self, other):\n2576         \"\"\"\n2577         Copy properties of other into self and return PDF commands\n2578         needed to transform self into other.\n2579         \"\"\"\n2580         cmds = []\n2581         fill_performed = False\n2582         for params, cmd in self.commands:\n2583             different = False\n2584             for p in params:\n2585                 ours = getattr(self, p)\n2586                 theirs = getattr(other, p)\n2587                 try:\n2588                     if ours is None or theirs is None:\n2589                         different = ours is not theirs\n2590                     else:\n2591                         different = bool(ours != theirs)\n2592                 except ValueError:\n2593                     ours = np.asarray(ours)\n2594                     theirs = np.asarray(theirs)\n2595                     different = (ours.shape != theirs.shape or\n2596                                  np.any(ours != theirs))\n2597                 if different:\n2598                     break\n2599 \n2600             # Need to update hatching if we also updated fillcolor\n2601             if params == ('_hatch', '_hatch_color') and fill_performed:\n2602                 different = True\n2603 \n2604             if different:\n2605                 if params == ('_fillcolor',):\n2606                     fill_performed = True\n2607                 theirs = [getattr(other, p) for p in params]\n2608                 cmds.extend(cmd(self, *theirs))\n2609                 for p in params:\n2610                     setattr(self, p, getattr(other, p))\n2611         return cmds\n2612 \n2613     def copy_properties(self, other):\n2614         \"\"\"\n2615         Copy properties of other into self.\n2616         \"\"\"\n2617         super().copy_properties(other)\n2618         fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n2619         effective_alphas = getattr(other, '_effective_alphas',\n2620                                    self._effective_alphas)\n2621         self._fillcolor = fillcolor\n2622         self._effective_alphas = effective_alphas\n2623 \n2624     def finalize(self):\n2625         \"\"\"\n2626         Make sure every pushed graphics state is popped.\n2627         \"\"\"\n2628         cmds = []\n2629         while self.parent is not None:\n2630             cmds.extend(self.pop())\n2631         return cmds\n2632 \n2633 \n2634 class PdfPages:\n2635     \"\"\"\n2636     A multi-page PDF file.\n2637 \n2638     Examples\n2639     --------\n2640     >>> import matplotlib.pyplot as plt\n2641     >>> # Initialize:\n2642     >>> with PdfPages('foo.pdf') as pdf:\n2643     ...     # As many times as you like, create a figure fig and save it:\n2644     ...     fig = plt.figure()\n2645     ...     pdf.savefig(fig)\n2646     ...     # When no figure is specified the current figure is saved\n2647     ...     pdf.savefig()\n2648 \n2649     Notes\n2650     -----\n2651     In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\n2652     confusion when using `~.pyplot.savefig` and forgetting the format argument.\n2653     \"\"\"\n2654     __slots__ = ('_file', 'keep_empty')\n2655 \n2656     def __init__(self, filename, keep_empty=True, metadata=None):\n2657         \"\"\"\n2658         Create a new PdfPages object.\n2659 \n2660         Parameters\n2661         ----------\n2662         filename : str or path-like or file-like\n2663             Plots using `PdfPages.savefig` will be written to a file at this\n2664             location. The file is opened at once and any older file with the\n2665             same name is overwritten.\n2666 \n2667         keep_empty : bool, optional\n2668             If set to False, then empty pdf files will be deleted automatically\n2669             when closed.\n2670 \n2671         metadata : dict, optional\n2672             Information dictionary object (see PDF reference section 10.2.1\n2673             'Document Information Dictionary'), e.g.:\n2674             ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n2675 \n2676             The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n2677             'Creator', 'Producer', 'CreationDate', 'ModDate', and\n2678             'Trapped'. Values have been predefined for 'Creator', 'Producer'\n2679             and 'CreationDate'. They can be removed by setting them to `None`.\n2680         \"\"\"\n2681         self._file = PdfFile(filename, metadata=metadata)\n2682         self.keep_empty = keep_empty\n2683 \n2684     def __enter__(self):\n2685         return self\n2686 \n2687     def __exit__(self, exc_type, exc_val, exc_tb):\n2688         self.close()\n2689 \n2690     def close(self):\n2691         \"\"\"\n2692         Finalize this object, making the underlying file a complete\n2693         PDF file.\n2694         \"\"\"\n2695         self._file.finalize()\n2696         self._file.close()\n2697         if (self.get_pagecount() == 0 and not self.keep_empty and\n2698                 not self._file.passed_in_file_object):\n2699             os.remove(self._file.fh.name)\n2700         self._file = None\n2701 \n2702     def infodict(self):\n2703         \"\"\"\n2704         Return a modifiable information dictionary object\n2705         (see PDF reference section 10.2.1 'Document Information\n2706         Dictionary').\n2707         \"\"\"\n2708         return self._file.infoDict\n2709 \n2710     def savefig(self, figure=None, **kwargs):\n2711         \"\"\"\n2712         Save a `.Figure` to this file as a new page.\n2713 \n2714         Any other keyword arguments are passed to `~.Figure.savefig`.\n2715 \n2716         Parameters\n2717         ----------\n2718         figure : `.Figure` or int, default: the active figure\n2719             The figure, or index of the figure, that is saved to the file.\n2720         \"\"\"\n2721         if not isinstance(figure, Figure):\n2722             if figure is None:\n2723                 manager = Gcf.get_active()\n2724             else:\n2725                 manager = Gcf.get_fig_manager(figure)\n2726             if manager is None:\n2727                 raise ValueError(\"No figure {}\".format(figure))\n2728             figure = manager.canvas.figure\n2729         # Force use of pdf backend, as PdfPages is tightly coupled with it.\n2730         try:\n2731             orig_canvas = figure.canvas\n2732             figure.canvas = FigureCanvasPdf(figure)\n2733             figure.savefig(self, format=\"pdf\", **kwargs)\n2734         finally:\n2735             figure.canvas = orig_canvas\n2736 \n2737     def get_pagecount(self):\n2738         \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n2739         return len(self._file.pageList)\n2740 \n2741     def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n2742         \"\"\"\n2743         Add a new text note to the page to be saved next. The optional\n2744         positionRect specifies the position of the new note on the\n2745         page. It is outside the page per default to make sure it is\n2746         invisible on printouts.\n2747         \"\"\"\n2748         self._file.newTextnote(text, positionRect)\n2749 \n2750 \n2751 class FigureCanvasPdf(FigureCanvasBase):\n2752     # docstring inherited\n2753 \n2754     fixed_dpi = 72\n2755     filetypes = {'pdf': 'Portable Document Format'}\n2756 \n2757     def get_default_filetype(self):\n2758         return 'pdf'\n2759 \n2760     def print_pdf(self, filename, *,\n2761                   bbox_inches_restore=None, metadata=None):\n2762 \n2763         dpi = self.figure.dpi\n2764         self.figure.dpi = 72  # there are 72 pdf points to an inch\n2765         width, height = self.figure.get_size_inches()\n2766         if isinstance(filename, PdfPages):\n2767             file = filename._file\n2768         else:\n2769             file = PdfFile(filename, metadata=metadata)\n2770         try:\n2771             file.newPage(width, height)\n2772             renderer = MixedModeRenderer(\n2773                 self.figure, width, height, dpi,\n2774                 RendererPdf(file, dpi, height, width),\n2775                 bbox_inches_restore=bbox_inches_restore)\n2776             self.figure.draw(renderer)\n2777             renderer.finalize()\n2778             if not isinstance(filename, PdfPages):\n2779                 file.finalize()\n2780         finally:\n2781             if isinstance(filename, PdfPages):  # finish off this page\n2782                 file.endStream()\n2783             else:            # we opened the file above; now finish it off\n2784                 file.close()\n2785 \n2786     def draw(self):\n2787         self.figure.draw_without_rendering()\n2788         return super().draw()\n2789 \n2790 \n2791 FigureManagerPdf = FigureManagerBase\n2792 \n2793 \n2794 @_Backend.export\n2795 class _BackendPdf(_Backend):\n2796     FigureCanvas = FigureCanvasPdf\n",
        "intended_behavior": "The method responsible for rendering text with URLs in PDFs should account for the text's rotation by correctly implementing the 'QuadPoints' in addition to the 'Rect' for link annotations. This implementation should allow the clickable area to correctly rotate with the text, matching its visual orientation. This enhancement must maintain backward compatibility by also providing a 'Rect' that encompasses the rotated text's footprint, ensuring that viewers not supporting 'QuadPoints' still offer a functional (though potentially less precise) clickable area."
    }
]