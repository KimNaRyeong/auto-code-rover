2025-10-15 12:53:50.686 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 12:53:55.191 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=305, output_tokens=12, cost=0.003410
2025-10-15 12:54:08.737 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=485, output_tokens=519, cost=0.020420
2025-10-15 12:54:10.020 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:54:17.889 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=608, output_tokens=266, cost=0.014060
2025-10-15 12:54:17.895 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:54:21.621 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=620, output_tokens=28, cost=0.007040
2025-10-15 12:54:21.622 | DEBUG    | Extracted a valid json.
2025-10-15 12:54:21.622 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"latex\")", "search_method(\"pprint\")"],
    "bug_locations": []
}
2025-10-15 12:54:21.656 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 12:54:21.657 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 12:54:37.345 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2921, output_tokens=640, cost=0.048410
2025-10-15 12:54:37.359 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:54:49.260 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3777, output_tokens=511, cost=0.053100
2025-10-15 12:54:49.269 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:54:55.625 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=865, output_tokens=244, cost=0.015970
2025-10-15 12:54:55.626 | DEBUG    | Extracted a valid json.
2025-10-15 12:54:55.626 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"PrettyPrinter\")",
        "search_method(\"pretty_print\")",
        "search_method_in_file(\"print\", \"sympy/printing/pretty/pretty.py\")"
    ],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "",
            "method": "latex",
            "intended_behavior": "The `latex` function should ensure consistency with the pretty printer output, which means adjustments might be necessary to handle specific cases where the output diverges unnecessarily from pretty printing. This may involve refining how expressions are decomposed or represented in LaTeX to mirror the structure seen in pretty printing more closely, while still taking advantage of the expressiveness of LaTeX where appropriate. For example, simplifying fractional expressions or the representation of exponential and logarithmic functions should align with the pretty printer's output, unless LaTeX can offer a clearer representation. It's crucial that these adjustments do not detract from the existing functionality and flexibility of the `latex` function, especially its ability to handle a wide variety of mathematical expressions and its support for multiple settings to customize the output."
        }
    ]
}
2025-10-15 12:54:55.696 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 12:54:55.697 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 12:55:15.032 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6836, output_tokens=768, cost=0.091400
2025-10-15 12:55:15.046 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:55:27.614 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7820, output_tokens=342, cost=0.088460
2025-10-15 12:55:27.621 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:55:36.294 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=696, output_tokens=316, cost=0.016440
2025-10-15 12:55:36.295 | DEBUG    | Extracted a valid json.
2025-10-15 12:55:36.295 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/printing/latex.py", 
            "class": "", 
            "method": "latex", 
            "intended_behavior": "The `latex` method should be reviewed and potentially adjusted to ensure that its output is consistent with the pretty printer's output in terms of mathematical structure and hierarchy. While LaTeX offers more sophisticated formatting capabilities, the method should aim to represent mathematical expressions in a way that aligns with the conceptual representation done by the pretty printer. Adjustments might include handling of fractions, exponentials, logarithms, and symbol assumptions to closely match the structure presented by the pretty printer, without losing the mathematical fidelity or the expressive advantages of the LaTeX format."
        }, 
        {
            "file": "sympy/printing/pretty/pretty.py", 
            "class": "PrettyPrinter", 
            "method": "", 
            "intended_behavior": "The methods within the `PrettyPrinter` class responsible for printing fractions, exponentials, logarithms, and other expressions highlighted in the issue should be evaluated to ensure they are structurally and conceptually consistent with LaTeX output where feasible. While maintaining the readability and simplicity of the pretty print format, slight adjustments may be necessary to align both outputs more closely. This might involve modifying how the pretty printer simplifies expressions or represents certain mathematical constructs to minimize discrepancies with LaTeX representations, provided these changes do not compromise the clarity or the utility of the pretty printed output."
        }
    ]
}
2025-10-15 12:55:36.306 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>None</class>
<method>latex</method>
<code>
2026 def latex(expr, **settings):
2027     r"""
2028     Convert the given expression to LaTeX representation.
2029 
2030     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational
2031     >>> from sympy.abc import x, y, mu, r, tau
2032 
2033     >>> print(latex((2*tau)**Rational(7,2)))
2034     8 \sqrt{2} \tau^{\frac{7}{2}}
2035 
2036     Not using a print statement for printing, results in double backslashes for
2037     latex commands since that's the way Python escapes backslashes in strings.
2038 
2039     >>> latex((2*tau)**Rational(7,2))
2040     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2041 
2042     order: Any of the supported monomial orderings (currently "lex", "grlex", or
2043     "grevlex"), "old", and "none". This parameter does nothing for Mul objects.
2044     Setting order to "old" uses the compatibility ordering for Add defined in
2045     Printer. For very large expressions, set the 'order' keyword to 'none' if
2046     speed is a concern.
2047 
2048     mode: Specifies how the generated code will be delimited. 'mode' can be one
2049     of 'plain', 'inline', 'equation' or 'equation*'.  If 'mode' is set to
2050     'plain', then the resulting code will not be delimited at all (this is the
2051     default). If 'mode' is set to 'inline' then inline LaTeX $ $ will be used.
2052     If 'mode' is set to 'equation' or 'equation*', the resulting code will be
2053     enclosed in the 'equation' or 'equation*' environment (remember to import
2054     'amsmath' for 'equation*'), unless the 'itex' option is set. In the latter
2055     case, the ``$$ $$`` syntax is used.
2056 
2057     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2058     8 \sqrt{2} \mu^{\frac{7}{2}}
2059 
2060     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2061     $8 \sqrt{2} \tau^{7 / 2}$
2062 
2063     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2064     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2065 
2066     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2067     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2068 
2069     itex: Specifies if itex-specific syntax is used, including emitting ``$$ $$``.
2070 
2071     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2072     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2073 
2074     fold_frac_powers: Emit "^{p/q}" instead of "^{\frac{p}{q}}" for fractional
2075     powers.
2076 
2077     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2078     8 \sqrt{2} \tau^{7/2}
2079 
2080     fold_func_brackets: Fold function brackets where applicable.
2081 
2082     >>> print(latex((2*tau)**sin(Rational(7,2))))
2083     \left(2 \tau\right)^{\sin{\left (\frac{7}{2} \right )}}
2084     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets = True))
2085     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2086 
2087     fold_short_frac: Emit "p / q" instead of "\frac{p}{q}" when the
2088     denominator is simple enough (at most two terms and no powers).
2089     The default value is `True` for inline mode, False otherwise.
2090 
2091     >>> print(latex(3*x**2/y))
2092     \frac{3 x^{2}}{y}
2093     >>> print(latex(3*x**2/y, fold_short_frac=True))
2094     3 x^{2} / y
2095 
2096     long_frac_ratio: The allowed ratio of the width of the numerator to the
2097     width of the denominator before we start breaking off long fractions.
2098     The default value is 2.
2099 
2100     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2101     \frac{\int r\, dr}{2 \pi}
2102     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2103     \frac{1}{2 \pi} \int r\, dr
2104 
2105     mul_symbol: The symbol to use for multiplication. Can be one of None,
2106     "ldot", "dot", or "times".
2107 
2108     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2109     \left(2 \times \tau\right)^{\sin{\left (\frac{7}{2} \right )}}
2110 
2111     inv_trig_style: How inverse trig functions should be displayed. Can be one
2112     of "abbreviated", "full", or "power". Defaults to "abbreviated".
2113 
2114     >>> print(latex(asin(Rational(7,2))))
2115     \operatorname{asin}{\left (\frac{7}{2} \right )}
2116     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2117     \arcsin{\left (\frac{7}{2} \right )}
2118     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2119     \sin^{-1}{\left (\frac{7}{2} \right )}
2120 
2121     mat_str: Which matrix environment string to emit. "smallmatrix", "matrix",
2122     "array", etc. Defaults to "smallmatrix" for inline mode, "matrix" for
2123     matrices of no more than 10 columns, and "array" otherwise.
2124 
2125     >>> print(latex(Matrix(2, 1, [x, y])))
2126     \left[\begin{matrix}x\\y\end{matrix}\right]
2127 
2128     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2129     \left[\begin{array}{c}x\\y\end{array}\right]
2130 
2131     mat_delim: The delimiter to wrap around matrices. Can be one of "[", "(",
2132     or the empty string. Defaults to "[".
2133 
2134     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2135     \left(\begin{matrix}x\\y\end{matrix}\right)
2136 
2137     symbol_names: Dictionary of symbols and the custom strings they should be
2138     emitted as.
2139 
2140     >>> print(latex(x**2, symbol_names={x:'x_i'}))
2141     x_i^{2}
2142 
2143     ``latex`` also supports the builtin container types list, tuple, and
2144     dictionary.
2145 
2146     >>> print(latex([2/x, y], mode='inline'))
2147     $\left [ 2 / x, \quad y\right ]$
2148 
2149     """
2150 
2151     return LatexPrinter(settings).doprint(expr)

</code><intended_behavior>The `latex` method should be reviewed and potentially adjusted to ensure that its output is consistent with the pretty printer's output in terms of mathematical structure and hierarchy. While LaTeX offers more sophisticated formatting capabilities, the method should aim to represent mathematical expressions in a way that aligns with the conceptual representation done by the pretty printer. Adjustments might include handling of fractions, exponentials, logarithms, and symbol assumptions to closely match the structure presented by the pretty printer, without losing the mathematical fidelity or the expressive advantages of the LaTeX format.</intended_behavior>, <file>sympy/printing/pretty/pretty.py</file>
<class>PrettyPrinter</class>
<method>None</method>
<code>
37 class PrettyPrinter(Printer):
38     """Printer, which converts an expression into 2D ASCII-art figure."""
39     printmethod = "_pretty"
40 
41     _default_settings = {
42         "order": None,
43         "full_prec": "auto",
44         "use_unicode": None,
45         "wrap_line": True,
46         "num_columns": None,
47         "use_unicode_sqrt_char": True,
48     }
49 
50     def __init__(self, settings=None):
51         Printer.__init__(self, settings)
52         self.emptyPrinter = lambda x: prettyForm(xstr(x))
53 
54     @property
55     def _use_unicode(self):
56         if self._settings['use_unicode']:
57             return True
58         else:
59             return pretty_use_unicode()
60 
61     def doprint(self, expr):
62         return self._print(expr).render(**self._settings)
63 
64     # empty op so _print(stringPict) returns the same
65     def _print_stringPict(self, e):
66         return e
67 
68     def _print_basestring(self, e):
69         return prettyForm(e)
70 
71     def _print_atan2(self, e):
72         pform = prettyForm(*self._print_seq(e.args).parens())
73         pform = prettyForm(*pform.left('atan2'))
74         return pform
75 
76     def _print_Symbol(self, e):
77         symb = pretty_symbol(e.name)
78         return prettyForm(symb)
79     _print_RandomSymbol = _print_Symbol
80 
81     def _print_Float(self, e):
82         # we will use StrPrinter's Float printer, but we need to handle the
83         # full_prec ourselves, according to the self._print_level
84         full_prec = self._settings["full_prec"]
85         if full_prec == "auto":
86             full_prec = self._print_level == 1
87         return prettyForm(sstr(e, full_prec=full_prec))
88 
89     def _print_Atom(self, e):
90         try:
91             # print atoms like Exp1 or Pi
92             return prettyForm(pretty_atom(e.__class__.__name__))
93         except KeyError:
94             return self.emptyPrinter(e)
95 
96     # Infinity inherits from Number, so we have to override _print_XXX order
97     _print_Infinity = _print_Atom
98     _print_NegativeInfinity = _print_Atom
99     _print_EmptySet = _print_Atom
100     _print_Naturals = _print_Atom
101     _print_Naturals0 = _print_Atom
102     _print_Integers = _print_Atom
103     _print_Reals = _print_Atom
104     _print_Complexes = _print_Atom
105 
106     def _print_subfactorial(self, e):
107         x = e.args[0]
108         pform = self._print(x)
109         # Add parentheses if needed
110         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
111             pform = prettyForm(*pform.parens())
112         pform = prettyForm(*pform.left('!'))
113         return pform
114 
115     def _print_factorial(self, e):
116         x = e.args[0]
117         pform = self._print(x)
118         # Add parentheses if needed
119         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
120             pform = prettyForm(*pform.parens())
121         pform = prettyForm(*pform.right('!'))
122         return pform
123 
124     def _print_factorial2(self, e):
125         x = e.args[0]
126         pform = self._print(x)
127         # Add parentheses if needed
128         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
129             pform = prettyForm(*pform.parens())
130         pform = prettyForm(*pform.right('!!'))
131         return pform
132 
133     def _print_binomial(self, e):
134         n, k = e.args
135 
136         n_pform = self._print(n)
137         k_pform = self._print(k)
138 
139         bar = ' '*max(n_pform.width(), k_pform.width())
140 
141         pform = prettyForm(*k_pform.above(bar))
142         pform = prettyForm(*pform.above(n_pform))
143         pform = prettyForm(*pform.parens('(', ')'))
144 
145         pform.baseline = (pform.baseline + 1)//2
146 
147         return pform
148 
149     def _print_Relational(self, e):
150         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
151 
152         l = self._print(e.lhs)
153         r = self._print(e.rhs)
154         pform = prettyForm(*stringPict.next(l, op, r))
155         return pform
156 
157     def _print_Not(self, e):
158         from sympy import Equivalent, Implies
159         if self._use_unicode:
160             arg = e.args[0]
161             pform = self._print(arg)
162             if isinstance(arg, Equivalent):
163                 return self._print_Equivalent(arg, altchar=u"\N{NOT IDENTICAL TO}")
164             if isinstance(arg, Implies):
165                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
166 
167             if arg.is_Boolean and not arg.is_Not:
168                 pform = prettyForm(*pform.parens())
169 
170             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
171         else:
172             return self._print_Function(e)
173 
174     def __print_Boolean(self, e, char, sort=True):
175         args = e.args
176         if sort:
177             args = sorted(e.args, key=default_sort_key)
178         arg = args[0]
179         pform = self._print(arg)
180 
181         if arg.is_Boolean and not arg.is_Not:
182             pform = prettyForm(*pform.parens())
183 
184         for arg in args[1:]:
185             pform_arg = self._print(arg)
186 
187             if arg.is_Boolean and not arg.is_Not:
188                 pform_arg = prettyForm(*pform_arg.parens())
189 
190             pform = prettyForm(*pform.right(u' %s ' % char))
191             pform = prettyForm(*pform.right(pform_arg))
192 
193         return pform
194 
195     def _print_And(self, e):
196         if self._use_unicode:
197             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
198         else:
199             return self._print_Function(e, sort=True)
200 
201     def _print_Or(self, e):
202         if self._use_unicode:
203             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
204         else:
205             return self._print_Function(e, sort=True)
206 
207     def _print_Xor(self, e):
208         if self._use_unicode:
209             return self.__print_Boolean(e, u"\N{XOR}")
210         else:
211             return self._print_Function(e, sort=True)
212 
213     def _print_Nand(self, e):
214         if self._use_unicode:
215             return self.__print_Boolean(e, u"\N{NAND}")
216         else:
217             return self._print_Function(e, sort=True)
218 
219     def _print_Nor(self, e):
220         if self._use_unicode:
221             return self.__print_Boolean(e, u"\N{NOR}")
222         else:
223             return self._print_Function(e, sort=True)
224 
225     def _print_Implies(self, e, altchar=None):
226         if self._use_unicode:
227             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
228         else:
229             return self._print_Function(e)
230 
231     def _print_Equivalent(self, e, altchar=None):
232         if self._use_unicode:
233             return self.__print_Boolean(e, altchar or u"\N{IDENTICAL TO}")
234         else:
235             return self._print_Function(e, sort=True)
236 
237     def _print_conjugate(self, e):
238         pform = self._print(e.args[0])
239         return prettyForm( *pform.above( hobj('_', pform.width())) )
240 
241     def _print_Abs(self, e):
242         pform = self._print(e.args[0])
243         pform = prettyForm(*pform.parens('|', '|'))
244         return pform
245     _print_Determinant = _print_Abs
246 
247     def _print_floor(self, e):
248         if self._use_unicode:
249             pform = self._print(e.args[0])
250             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
251             return pform
252         else:
253             return self._print_Function(e)
254 
255     def _print_ceiling(self, e):
256         if self._use_unicode:
257             pform = self._print(e.args[0])
258             pform = prettyForm(*pform.parens('lceil', 'rceil'))
259             return pform
260         else:
261             return self._print_Function(e)
262 
263     def _print_Derivative(self, deriv):
264         if requires_partial(deriv) and self._use_unicode:
265             deriv_symbol = U('PARTIAL DIFFERENTIAL')
266         else:
267             deriv_symbol = r'd'
268         syms = list(reversed(deriv.variables))
269         x = None
270 
271         for sym, num in group(syms, multiple=False):
272             s = self._print(sym)
273             ds = prettyForm(*s.left(deriv_symbol))
274 
275             if num > 1:
276                 ds = ds**prettyForm(str(num))
277 
278             if x is None:
279                 x = ds
280             else:
281                 x = prettyForm(*x.right(' '))
282                 x = prettyForm(*x.right(ds))
283 
284         f = prettyForm(
285             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
286 
287         pform = prettyForm(deriv_symbol)
288 
289         if len(syms) > 1:
290             pform = pform**prettyForm(str(len(syms)))
291 
292         pform = prettyForm(*pform.below(stringPict.LINE, x))
293         pform.baseline = pform.baseline + 1
294         pform = prettyForm(*stringPict.next(pform, f))
295         pform.binding = prettyForm.MUL
296 
297         return pform
298 
299     def _print_Cycle(self, dc):
300         from sympy.combinatorics.permutations import Permutation, Cycle
301         # for Empty Cycle
302         if dc == Cycle():
303             cyc = stringPict('')
304             return prettyForm(*cyc.parens())
305 
306         dc_list = Permutation(dc.list()).cyclic_form
307         # for Identity Cycle
308         if dc_list == []:
309             cyc = self._print(dc.size - 1)
310             return prettyForm(*cyc.parens())
311 
312         cyc = stringPict('')
313         for i in dc_list:
314             l = self._print(str(tuple(i)).replace(',', ''))
315             cyc = prettyForm(*cyc.right(l))
316         return cyc
317 
318     def _print_PDF(self, pdf):
319         lim = self._print(pdf.pdf.args[0])
320         lim = prettyForm(*lim.right(', '))
321         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
322         lim = prettyForm(*lim.right(', '))
323         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
324         lim = prettyForm(*lim.parens())
325 
326         f = self._print(pdf.pdf.args[1])
327         f = prettyForm(*f.right(', '))
328         f = prettyForm(*f.right(lim))
329         f = prettyForm(*f.parens())
330 
331         pform = prettyForm('PDF')
332         pform = prettyForm(*pform.right(f))
333         return pform
334 
335     def _print_Integral(self, integral):
336         f = integral.function
337 
338         # Add parentheses if arg involves addition of terms and
339         # create a pretty form for the argument
340         prettyF = self._print(f)
341         # XXX generalize parens
342         if f.is_Add:
343             prettyF = prettyForm(*prettyF.parens())
344 
345         # dx dy dz ...
346         arg = prettyF
347         for x in integral.limits:
348             prettyArg = self._print(x[0])
349             # XXX qparens (parens if needs-parens)
350             if prettyArg.width() > 1:
351                 prettyArg = prettyForm(*prettyArg.parens())
352 
353             arg = prettyForm(*arg.right(' d', prettyArg))
354 
355         # \int \int \int ...
356         firstterm = True
357         s = None
358         for lim in integral.limits:
359             x = lim[0]
360             # Create bar based on the height of the argument
361             h = arg.height()
362             H = h + 2
363 
364             # XXX hack!
365             ascii_mode = not self._use_unicode
366             if ascii_mode:
367                 H += 2
368 
369             vint = vobj('int', H)
370 
371             # Construct the pretty form with the integral sign and the argument
372             pform = prettyForm(vint)
373             pform.baseline = arg.baseline + (
374                 H - h)//2    # covering the whole argument
375 
376             if len(lim) > 1:
377                 # Create pretty forms for endpoints, if definite integral.
378                 # Do not print empty endpoints.
379                 if len(lim) == 2:
380                     prettyA = prettyForm("")
381                     prettyB = self._print(lim[1])
382                 if len(lim) == 3:
383                     prettyA = self._print(lim[1])
384                     prettyB = self._print(lim[2])
385 
386                 if ascii_mode:  # XXX hack
387                     # Add spacing so that endpoint can more easily be
388                     # identified with the correct integral sign
389                     spc = max(1, 3 - prettyB.width())
390                     prettyB = prettyForm(*prettyB.left(' ' * spc))
391 
392                     spc = max(1, 4 - prettyA.width())
393                     prettyA = prettyForm(*prettyA.right(' ' * spc))
394 
395                 pform = prettyForm(*pform.above(prettyB))
396                 pform = prettyForm(*pform.below(prettyA))
397 
398             if not ascii_mode:  # XXX hack
399                 pform = prettyForm(*pform.right(' '))
400 
401             if firstterm:
402                 s = pform   # first term
403                 firstterm = False
404             else:
405                 s = prettyForm(*s.left(pform))
406 
407         pform = prettyForm(*arg.left(s))
408         pform.binding = prettyForm.MUL
409         return pform
410 
411     def _print_Product(self, expr):
412         func = expr.term
413         pretty_func = self._print(func)
414 
415         horizontal_chr = xobj('_', 1)
416         corner_chr = xobj('_', 1)
417         vertical_chr = xobj('|', 1)
418 
419         if self._use_unicode:
420             # use unicode corners
421             horizontal_chr = xobj('-', 1)
422             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
423 
424         func_height = pretty_func.height()
425 
426         first = True
427         max_upper = 0
428         sign_height = 0
429 
430         for lim in expr.limits:
431             width = (func_height + 2) * 5 // 3 - 2
432             sign_lines = []
433             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
434             for i in range(func_height + 1):
435                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
436 
437             pretty_sign = stringPict('')
438             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
439 
440             pretty_upper = self._print(lim[2])
441             pretty_lower = self._print(Equality(lim[0], lim[1]))
442 
443             max_upper = max(max_upper, pretty_upper.height())
444 
445             if first:
446                 sign_height = pretty_sign.height()
447 
448             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
449             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
450 
451             if first:
452                 pretty_func.baseline = 0
453                 first = False
454 
455             height = pretty_sign.height()
456             padding = stringPict('')
457             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
458             pretty_sign = prettyForm(*pretty_sign.right(padding))
459 
460             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
461 
462         pretty_func.baseline = max_upper + sign_height//2
463         pretty_func.binding = prettyForm.MUL
464         return pretty_func
465 
466     def _print_Sum(self, expr):
467         ascii_mode = not self._use_unicode
468 
469         def asum(hrequired, lower, upper, use_ascii):
470             def adjust(s, wid=None, how='<^>'):
471                 if not wid or len(s) > wid:
472                     return s
473                 need = wid - len(s)
474                 if how == '<^>' or how == "<" or how not in list('<^>'):
475                     return s + ' '*need
476                 half = need//2
477                 lead = ' '*half
478                 if how == ">":
479                     return " "*need + s
480                 return lead + s + ' '*(need - len(lead))
481 
482             h = max(hrequired, 2)
483             d = h//2
484             w = d + 1
485             more = hrequired % 2
486 
487             lines = []
488             if use_ascii:
489                 lines.append("_"*(w) + ' ')
490                 lines.append("\%s`" % (' '*(w - 1)))
491                 for i in range(1, d):
492                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
493                 if more:
494                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
495                 for i in reversed(range(1, d)):
496                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
497                 lines.append("/" + "_"*(w - 1) + ',')
498                 return d, h + more, lines, 0
499             else:
500                 w = w + more
501                 d = d + more
502                 vsum = vobj('sum', 4)
503                 lines.append("_"*(w))
504                 for i in range(0, d):
505                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
506                 for i in reversed(range(0, d)):
507                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
508                 lines.append(vsum[8]*(w))
509                 return d, h + 2*more, lines, more
510 
511         f = expr.function
512 
513         prettyF = self._print(f)
514 
515         if f.is_Add:  # add parens
516             prettyF = prettyForm(*prettyF.parens())
517 
518         H = prettyF.height() + 2
519 
520         # \sum \sum \sum ...
521         first = True
522         max_upper = 0
523         sign_height = 0
524 
525         for lim in expr.limits:
526             if len(lim) == 3:
527                 prettyUpper = self._print(lim[2])
528                 prettyLower = self._print(Equality(lim[0], lim[1]))
529             elif len(lim) == 2:
530                 prettyUpper = self._print("")
531                 prettyLower = self._print(Equality(lim[0], lim[1]))
532             elif len(lim) == 1:
533                 prettyUpper = self._print("")
534                 prettyLower = self._print(lim[0])
535 
536             max_upper = max(max_upper, prettyUpper.height())
537 
538             # Create sum sign based on the height of the argument
539             d, h, slines, adjustment = asum(
540                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
541             prettySign = stringPict('')
542             prettySign = prettyForm(*prettySign.stack(*slines))
543 
544             if first:
545                 sign_height = prettySign.height()
546 
547             prettySign = prettyForm(*prettySign.above(prettyUpper))
548             prettySign = prettyForm(*prettySign.below(prettyLower))
549 
550             if first:
551                 # change F baseline so it centers on the sign
552                 prettyF.baseline -= d - (prettyF.height()//2 -
553                                          prettyF.baseline) - adjustment
554                 first = False
555 
556             # put padding to the right
557             pad = stringPict('')
558             pad = prettyForm(*pad.stack(*[' ']*h))
559             prettySign = prettyForm(*prettySign.right(pad))
560             # put the present prettyF to the right
561             prettyF = prettyForm(*prettySign.right(prettyF))
562 
563         prettyF.baseline = max_upper + sign_height//2
564         prettyF.binding = prettyForm.MUL
565         return prettyF
566 
567     def _print_Limit(self, l):
568         e, z, z0, dir = l.args
569 
570         E = self._print(e)
571         if precedence(e) <= PRECEDENCE["Mul"]:
572             E = prettyForm(*E.parens('(', ')'))
573         Lim = prettyForm('lim')
574 
575         LimArg = self._print(z)
576         if self._use_unicode:
577             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
578         else:
579             LimArg = prettyForm(*LimArg.right('->'))
580         LimArg = prettyForm(*LimArg.right(self._print(z0)))
581 
582         if z0 in (S.Infinity, S.NegativeInfinity):
583             dir = ""
584         else:
585             if self._use_unicode:
586                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
587 
588         LimArg = prettyForm(*LimArg.right(self._print(dir)))
589 
590         Lim = prettyForm(*Lim.below(LimArg))
591         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
592 
593         return Lim
594 
595     def _print_matrix_contents(self, e):
596         """
597         This method factors out what is essentially grid printing.
598         """
599         M = e   # matrix
600         Ms = {}  # i,j -> pretty(M[i,j])
601         for i in range(M.rows):
602             for j in range(M.cols):
603                 Ms[i, j] = self._print(M[i, j])
604 
605         # h- and v- spacers
606         hsep = 2
607         vsep = 1
608 
609         # max width for columns
610         maxw = [-1] * M.cols
611 
612         for j in range(M.cols):
613             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
614 
615         # drawing result
616         D = None
617 
618         for i in range(M.rows):
619 
620             D_row = None
621             for j in range(M.cols):
622                 s = Ms[i, j]
623 
624                 # reshape s to maxw
625                 # XXX this should be generalized, and go to stringPict.reshape ?
626                 assert s.width() <= maxw[j]
627 
628                 # hcenter it, +0.5 to the right                        2
629                 # ( it's better to align formula starts for say 0 and r )
630                 # XXX this is not good in all cases -- maybe introduce vbaseline?
631                 wdelta = maxw[j] - s.width()
632                 wleft = wdelta // 2
633                 wright = wdelta - wleft
634 
635                 s = prettyForm(*s.right(' '*wright))
636                 s = prettyForm(*s.left(' '*wleft))
637 
638                 # we don't need vcenter cells -- this is automatically done in
639                 # a pretty way because when their baselines are taking into
640                 # account in .right()
641 
642                 if D_row is None:
643                     D_row = s   # first box in a row
644                     continue
645 
646                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
647                 D_row = prettyForm(*D_row.right(s))
648 
649             if D is None:
650                 D = D_row       # first row in a picture
651                 continue
652 
653             # v-spacer
654             for _ in range(vsep):
655                 D = prettyForm(*D.below(' '))
656 
657             D = prettyForm(*D.below(D_row))
658 
659         if D is None:
660             D = prettyForm('')  # Empty Matrix
661 
662         return D
663 
664     def _print_MatrixBase(self, e):
665         D = self._print_matrix_contents(e)
666         D = prettyForm(*D.parens('[', ']'))
667         return D
668     _print_ImmutableMatrix = _print_MatrixBase
669     _print_Matrix = _print_MatrixBase
670 
671     def _print_Trace(self, e):
672         D = self._print(e.arg)
673         D = prettyForm(*D.parens('(',')'))
674         D.baseline = D.height()//2
675         D = prettyForm(*D.left('\n'*(0) + 'tr'))
676         return D
677 
678 
679     def _print_MatrixElement(self, expr):
680         from sympy.matrices import MatrixSymbol
681         from sympy import Symbol
682         if (isinstance(expr.parent, MatrixSymbol)
683                 and expr.i.is_number and expr.j.is_number):
684             return self._print(
685                     Symbol(expr.parent.name + '_%d%d'%(expr.i, expr.j)))
686         else:
687             prettyFunc = self._print(expr.parent)
688             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
689                     ).parens(left='[', right=']')[0]
690             pform = prettyForm(binding=prettyForm.FUNC,
691                     *stringPict.next(prettyFunc, prettyIndices))
692 
693             # store pform parts so it can be reassembled e.g. when powered
694             pform.prettyFunc = prettyFunc
695             pform.prettyArgs = prettyIndices
696 
697             return pform
698 
699 
700     def _print_MatrixSlice(self, m):
701         # XXX works only for applied functions
702 
703         prettyFunc = self._print(m.parent)
704         def ppslice(x):
705             x = list(x)
706             if x[2] == 1:
707                 del x[2]
708             if x[1] == x[0] + 1:
709                 del x[1]
710             if x[0] == 0:
711                 x[0] = ''
712             return prettyForm(*self._print_seq(x, delimiter=':'))
713         prettyArgs = self._print_seq((ppslice(m.rowslice),
714             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
715 
716         pform = prettyForm(
717             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
718 
719         # store pform parts so it can be reassembled e.g. when powered
720         pform.prettyFunc = prettyFunc
721         pform.prettyArgs = prettyArgs
722 
723         return pform
724 
725     def _print_Transpose(self, expr):
726         pform = self._print(expr.arg)
727         from sympy.matrices import MatrixSymbol
728         if not isinstance(expr.arg, MatrixSymbol):
729             pform = prettyForm(*pform.parens())
730         pform = pform**(prettyForm('T'))
731         return pform
732 
733     def _print_Adjoint(self, expr):
734         pform = self._print(expr.arg)
735         if self._use_unicode:
736             dag = prettyForm(u'\N{DAGGER}')
737         else:
738             dag = prettyForm('+')
739         from sympy.matrices import MatrixSymbol
740         if not isinstance(expr.arg, MatrixSymbol):
741             pform = prettyForm(*pform.parens())
742         pform = pform**dag
743         return pform
744 
745     def _print_BlockMatrix(self, B):
746         if B.blocks.shape == (1, 1):
747             return self._print(B.blocks[0, 0])
748         return self._print(B.blocks)
749 
750     def _print_MatAdd(self, expr):
751         return self._print_seq(expr.args, None, None, ' + ')
752 
753     def _print_MatMul(self, expr):
754         args = list(expr.args)
755         from sympy import Add, MatAdd, HadamardProduct
756         for i, a in enumerate(args):
757             if (isinstance(a, (Add, MatAdd, HadamardProduct))
758                     and len(expr.args) > 1):
759                 args[i] = prettyForm(*self._print(a).parens())
760             else:
761                 args[i] = self._print(a)
762 
763         return prettyForm.__mul__(*args)
764 
765     def _print_DotProduct(self, expr):
766         args = list(expr.args)
767 
768         for i, a in enumerate(args):
769             args[i] = self._print(a)
770         return prettyForm.__mul__(*args)
771 
772     def _print_MatPow(self, expr):
773         pform = self._print(expr.base)
774         from sympy.matrices import MatrixSymbol
775         if not isinstance(expr.base, MatrixSymbol):
776             pform = prettyForm(*pform.parens())
777         pform = pform**(self._print(expr.exp))
778         return pform
779 
780     def _print_HadamardProduct(self, expr):
781         from sympy import MatAdd, MatMul
782         if self._use_unicode:
783             delim = pretty_atom('Ring')
784         else:
785             delim = '.*'
786         return self._print_seq(expr.args, None, None, delim,
787                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
788 
789     _print_MatrixSymbol = _print_Symbol
790 
791     def _print_FunctionMatrix(self, X):
792         D = self._print(X.lamda.expr)
793         D = prettyForm(*D.parens('[', ']'))
794         return D
795 
796     def _print_BasisDependent(self, expr):
797         from sympy.vector import Vector
798 
799         if not self._use_unicode:
800             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
801 
802         if expr == expr.zero:
803             return prettyForm(expr.zero._pretty_form)
804         o1 = []
805         vectstrs = []
806         if isinstance(expr, Vector):
807             items = expr.separate().items()
808         else:
809             items = [(0, expr)]
810         for system, vect in items:
811             inneritems = list(vect.components.items())
812             inneritems.sort(key = lambda x: x[0].__str__())
813             for k, v in inneritems:
814                 #if the coef of the basis vector is 1
815                 #we skip the 1
816                 if v == 1:
817                     o1.append(u"" +
818                               k._pretty_form)
819                 #Same for -1
820                 elif v == -1:
821                     o1.append(u"(-1) " +
822                               k._pretty_form)
823                 #For a general expr
824                 else:
825                     #We always wrap the measure numbers in
826                     #parentheses
827                     arg_str = self._print(
828                         v).parens()[0]
829 
830                     o1.append(arg_str + ' ' + k._pretty_form)
831                 vectstrs.append(k._pretty_form)
832 
833         #outstr = u("").join(o1)
834         if o1[0].startswith(u" + "):
835             o1[0] = o1[0][3:]
836         elif o1[0].startswith(" "):
837             o1[0] = o1[0][1:]
838         #Fixing the newlines
839         lengths = []
840         strs = ['']
841         for i, partstr in enumerate(o1):
842             # XXX: What is this hack?
843             if '\n' in partstr:
844                 tempstr = partstr
845                 tempstr = tempstr.replace(vectstrs[i], '')
846                 tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
847                                           u'\N{RIGHT PARENTHESIS UPPER HOOK}'
848                                           + ' ' + vectstrs[i])
849                 o1[i] = tempstr
850         o1 = [x.split('\n') for x in o1]
851         n_newlines = max([len(x) for x in o1])
852         for parts in o1:
853             lengths.append(len(parts[0]))
854             for j in range(n_newlines):
855                 if j+1 <= len(parts):
856                     if j >= len(strs):
857                         strs.append(' ' * (sum(lengths[:-1]) +
858                                            3*(len(lengths)-1)))
859                     if j == 0:
860                         strs[0] += parts[0] + ' + '
861                     else:
862                         strs[j] += parts[j] + ' '*(lengths[-1] -
863                                                    len(parts[j])+
864                                                    3)
865                 else:
866                     if j >= len(strs):
867                         strs.append(' ' * (sum(lengths[:-1]) +
868                                            3*(len(lengths)-1)))
869                     strs[j] += ' '*(lengths[-1]+3)
870 
871         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
872 
873     def _print_NDimArray(self, expr):
874         from sympy import ImmutableMatrix
875 
876         if expr.rank() == 0:
877             return self._print_matrix_contents(expr.tomatrix())
878 
879         level_str = [[]] + [[] for i in range(expr.rank())]
880         shape_ranges = [list(range(i)) for i in expr.shape]
881         for outer_i in itertools.product(*shape_ranges):
882             level_str[-1].append(expr[outer_i])
883             even = True
884             for back_outer_i in range(expr.rank()-1, -1, -1):
885                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
886                     break
887                 if even:
888                     level_str[back_outer_i].append(level_str[back_outer_i+1])
889                 else:
890                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
891                     if len(level_str[back_outer_i + 1]) == 1:
892                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
893                 even = not even
894                 level_str[back_outer_i+1] = []
895 
896         out_expr = level_str[0][0]
897         if expr.rank() % 2 == 1:
898             out_expr = ImmutableMatrix([out_expr])
899 
900         return self._print(out_expr)
901 
902     _print_ImmutableDenseNDimArray = _print_NDimArray
903     _print_ImmutableSparseNDimArray = _print_NDimArray
904     _print_MutableDenseNDimArray = _print_NDimArray
905     _print_MutableSparseNDimArray = _print_NDimArray
906 
907     def _print_Piecewise(self, pexpr):
908 
909         P = {}
910         for n, ec in enumerate(pexpr.args):
911             P[n, 0] = self._print(ec.expr)
912             if ec.cond == True:
913                 P[n, 1] = prettyForm('otherwise')
914             else:
915                 P[n, 1] = prettyForm(
916                     *prettyForm('for ').right(self._print(ec.cond)))
917         hsep = 2
918         vsep = 1
919         len_args = len(pexpr.args)
920 
921         # max widths
922         maxw = [max([P[i, j].width() for i in range(len_args)])
923                 for j in range(2)]
924 
925         # FIXME: Refactor this code and matrix into some tabular environment.
926         # drawing result
927         D = None
928 
929         for i in range(len_args):
930             D_row = None
931             for j in range(2):
932                 p = P[i, j]
933                 assert p.width() <= maxw[j]
934 
935                 wdelta = maxw[j] - p.width()
936                 wleft = wdelta // 2
937                 wright = wdelta - wleft
938 
939                 p = prettyForm(*p.right(' '*wright))
940                 p = prettyForm(*p.left(' '*wleft))
941 
942                 if D_row is None:
943                     D_row = p
944                     continue
945 
946                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
947                 D_row = prettyForm(*D_row.right(p))
948             if D is None:
949                 D = D_row       # first row in a picture
950                 continue
951 
952             # v-spacer
953             for _ in range(vsep):
954                 D = prettyForm(*D.below(' '))
955 
956             D = prettyForm(*D.below(D_row))
957 
958         D = prettyForm(*D.parens('{', ''))
959         D.baseline = D.height()//2
960         D.binding = prettyForm.OPEN
961         return D
962 
963     def _hprint_vec(self, v):
964         D = None
965 
966         for a in v:
967             p = a
968             if D is None:
969                 D = p
970             else:
971                 D = prettyForm(*D.right(', '))
972                 D = prettyForm(*D.right(p))
973         if D is None:
974             D = stringPict(' ')
975 
976         return D
977 
978     def _hprint_vseparator(self, p1, p2):
979         tmp = prettyForm(*p1.right(p2))
980         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
981         return prettyForm(*p1.right(sep, p2))
982 
983     def _print_hyper(self, e):
984         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
985         ap = [self._print(a) for a in e.ap]
986         bq = [self._print(b) for b in e.bq]
987 
988         P = self._print(e.argument)
989         P.baseline = P.height()//2
990 
991         # Drawing result - first create the ap, bq vectors
992         D = None
993         for v in [ap, bq]:
994             D_row = self._hprint_vec(v)
995             if D is None:
996                 D = D_row       # first row in a picture
997             else:
998                 D = prettyForm(*D.below(' '))
999                 D = prettyForm(*D.below(D_row))
1000 
1001         # make sure that the argument `z' is centred vertically
1002         D.baseline = D.height()//2
1003 
1004         # insert horizontal separator
1005         P = prettyForm(*P.left(' '))
1006         D = prettyForm(*D.right(' '))
1007 
1008         # insert separating `|`
1009         D = self._hprint_vseparator(D, P)
1010 
1011         # add parens
1012         D = prettyForm(*D.parens('(', ')'))
1013 
1014         # create the F symbol
1015         above = D.height()//2 - 1
1016         below = D.height() - above - 1
1017 
1018         sz, t, b, add, img = annotated('F')
1019         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1020                        baseline=above + sz)
1021         add = (sz + 1)//2
1022 
1023         F = prettyForm(*F.left(self._print(len(e.ap))))
1024         F = prettyForm(*F.right(self._print(len(e.bq))))
1025         F.baseline = above + add
1026 
1027         D = prettyForm(*F.right(' ', D))
1028 
1029         return D
1030 
1031     def _print_meijerg(self, e):
1032         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1033 
1034         v = {}
1035         v[(0, 0)] = [self._print(a) for a in e.an]
1036         v[(0, 1)] = [self._print(a) for a in e.aother]
1037         v[(1, 0)] = [self._print(b) for b in e.bm]
1038         v[(1, 1)] = [self._print(b) for b in e.bother]
1039 
1040         P = self._print(e.argument)
1041         P.baseline = P.height()//2
1042 
1043         vp = {}
1044         for idx in v:
1045             vp[idx] = self._hprint_vec(v[idx])
1046 
1047         for i in range(2):
1048             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1049             for j in range(2):
1050                 s = vp[(j, i)]
1051                 left = (maxw - s.width()) // 2
1052                 right = maxw - left - s.width()
1053                 s = prettyForm(*s.left(' ' * left))
1054                 s = prettyForm(*s.right(' ' * right))
1055                 vp[(j, i)] = s
1056 
1057         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1058         D1 = prettyForm(*D1.below(' '))
1059         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1060         D = prettyForm(*D1.below(D2))
1061 
1062         # make sure that the argument `z' is centred vertically
1063         D.baseline = D.height()//2
1064 
1065         # insert horizontal separator
1066         P = prettyForm(*P.left(' '))
1067         D = prettyForm(*D.right(' '))
1068 
1069         # insert separating `|`
1070         D = self._hprint_vseparator(D, P)
1071 
1072         # add parens
1073         D = prettyForm(*D.parens('(', ')'))
1074 
1075         # create the G symbol
1076         above = D.height()//2 - 1
1077         below = D.height() - above - 1
1078 
1079         sz, t, b, add, img = annotated('G')
1080         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1081                        baseline=above + sz)
1082 
1083         pp = self._print(len(e.ap))
1084         pq = self._print(len(e.bq))
1085         pm = self._print(len(e.bm))
1086         pn = self._print(len(e.an))
1087 
1088         def adjust(p1, p2):
1089             diff = p1.width() - p2.width()
1090             if diff == 0:
1091                 return p1, p2
1092             elif diff > 0:
1093                 return p1, prettyForm(*p2.left(' '*diff))
1094             else:
1095                 return prettyForm(*p1.left(' '*-diff)), p2
1096         pp, pm = adjust(pp, pm)
1097         pq, pn = adjust(pq, pn)
1098         pu = prettyForm(*pm.right(', ', pn))
1099         pl = prettyForm(*pp.right(', ', pq))
1100 
1101         ht = F.baseline - above - 2
1102         if ht > 0:
1103             pu = prettyForm(*pu.below('\n'*ht))
1104         p = prettyForm(*pu.below(pl))
1105 
1106         F.baseline = above
1107         F = prettyForm(*F.right(p))
1108 
1109         F.baseline = above + add
1110 
1111         D = prettyForm(*F.right(' ', D))
1112 
1113         return D
1114 
1115     def _print_ExpBase(self, e):
1116         # TODO should exp_polar be printed differently?
1117         #      what about exp_polar(0), exp_polar(1)?
1118         base = prettyForm(pretty_atom('Exp1', 'e'))
1119         return base ** self._print(e.args[0])
1120 
1121     def _print_Function(self, e, sort=False):
1122         # XXX works only for applied functions
1123         func = e.func
1124         args = e.args
1125         if sort:
1126             args = sorted(args, key=default_sort_key)
1127 
1128         func_name = func.__name__
1129 
1130         prettyFunc = self._print(Symbol(func_name))
1131         prettyArgs = prettyForm(*self._print_seq(args).parens())
1132 
1133         pform = prettyForm(
1134             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1135 
1136         # store pform parts so it can be reassembled e.g. when powered
1137         pform.prettyFunc = prettyFunc
1138         pform.prettyArgs = prettyArgs
1139 
1140         return pform
1141 
1142     def _print_GeometryEntity(self, expr):
1143         # GeometryEntity is based on Tuple but should not print like a Tuple
1144         return self.emptyPrinter(expr)
1145 
1146     def _print_Lambda(self, e):
1147         vars, expr = e.args
1148         if self._use_unicode:
1149             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1150         else:
1151             arrow = " -> "
1152         if len(vars) == 1:
1153             var_form = self._print(vars[0])
1154         else:
1155             var_form = self._print(tuple(vars))
1156 
1157         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1158 
1159     def _print_Order(self, expr):
1160         pform = self._print(expr.expr)
1161         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1162            len(expr.variables) > 1:
1163             pform = prettyForm(*pform.right("; "))
1164             if len(expr.variables) > 1:
1165                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1166             elif len(expr.variables):
1167                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1168             if self._use_unicode:
1169                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1170             else:
1171                 pform = prettyForm(*pform.right(" -> "))
1172             if len(expr.point) > 1:
1173                 pform = prettyForm(*pform.right(self._print(expr.point)))
1174             else:
1175                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1176         pform = prettyForm(*pform.parens())
1177         pform = prettyForm(*pform.left("O"))
1178         return pform
1179 
1180     def _print_SingularityFunction(self, e):
1181         if self._use_unicode:
1182             shift = self._print(e.args[0]-e.args[1])
1183             n = self._print(e.args[2])
1184             base = prettyForm("<")
1185             base = prettyForm(*base.right(shift))
1186             base = prettyForm(*base.right(">"))
1187             pform = base**n
1188             return pform
1189         else:
1190             n = self._print(e.args[2])
1191             shift = self._print(e.args[0]-e.args[1])
1192             base = self._print_seq(shift, "<", ">", ' ')
1193             return base**n
1194 
1195     def _print_gamma(self, e):
1196         if self._use_unicode:
1197             pform = self._print(e.args[0])
1198             pform = prettyForm(*pform.parens())
1199             pform = prettyForm(*pform.left(greek_unicode['Gamma']))
1200             return pform
1201         else:
1202             return self._print_Function(e)
1203 
1204     def _print_uppergamma(self, e):
1205         if self._use_unicode:
1206             pform = self._print(e.args[0])
1207             pform = prettyForm(*pform.right(', ', self._print(e.args[1])))
1208             pform = prettyForm(*pform.parens())
1209             pform = prettyForm(*pform.left(greek_unicode['Gamma']))
1210             return pform
1211         else:
1212             return self._print_Function(e)
1213 
1214     def _print_lowergamma(self, e):
1215         if self._use_unicode:
1216             pform = self._print(e.args[0])
1217             pform = prettyForm(*pform.right(', ', self._print(e.args[1])))
1218             pform = prettyForm(*pform.parens())
1219             pform = prettyForm(*pform.left(greek_unicode['gamma']))
1220             return pform
1221         else:
1222             return self._print_Function(e)
1223 
1224     def _print_DiracDelta(self, e):
1225         if self._use_unicode:
1226             if len(e.args) == 2:
1227                 a = prettyForm(greek_unicode['delta'])
1228                 b = self._print(e.args[1])
1229                 b = prettyForm(*b.parens())
1230                 c = self._print(e.args[0])
1231                 c = prettyForm(*c.parens())
1232                 pform = a**b
1233                 pform = stringPict(*pform.right(' '))
1234                 pform = stringPict(*pform.right(c))
1235                 return pform
1236             pform = self._print(e.args[0])
1237             pform = prettyForm(*pform.parens())
1238             pform = prettyForm(*pform.left(greek_unicode['delta']))
1239             return pform
1240         else:
1241             return self._print_Function(e)
1242 
1243     def _print_expint(self, e):
1244         from sympy import Function
1245         if e.args[0].is_Integer and self._use_unicode:
1246             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1247         return self._print_Function(e)
1248 
1249     def _print_Chi(self, e):
1250         # This needs a special case since otherwise it comes out as greek
1251         # letter chi...
1252         prettyFunc = prettyForm("Chi")
1253         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1254 
1255         pform = prettyForm(
1256             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1257 
1258         # store pform parts so it can be reassembled e.g. when powered
1259         pform.prettyFunc = prettyFunc
1260         pform.prettyArgs = prettyArgs
1261 
1262         return pform
1263 
1264     def _print_elliptic_e(self, e):
1265         pforma0 = self._print(e.args[0])
1266         if len(e.args) == 1:
1267             pform = pforma0
1268         else:
1269             pforma1 = self._print(e.args[1])
1270             pform = self._hprint_vseparator(pforma0, pforma1)
1271         pform = prettyForm(*pform.parens())
1272         pform = prettyForm(*pform.left('E'))
1273         return pform
1274 
1275     def _print_elliptic_k(self, e):
1276         pform = self._print(e.args[0])
1277         pform = prettyForm(*pform.parens())
1278         pform = prettyForm(*pform.left('K'))
1279         return pform
1280 
1281     def _print_elliptic_f(self, e):
1282         pforma0 = self._print(e.args[0])
1283         pforma1 = self._print(e.args[1])
1284         pform = self._hprint_vseparator(pforma0, pforma1)
1285         pform = prettyForm(*pform.parens())
1286         pform = prettyForm(*pform.left('F'))
1287         return pform
1288 
1289     def _print_elliptic_pi(self, e):
1290         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1291         pforma0 = self._print(e.args[0])
1292         pforma1 = self._print(e.args[1])
1293         if len(e.args) == 2:
1294             pform = self._hprint_vseparator(pforma0, pforma1)
1295         else:
1296             pforma2 = self._print(e.args[2])
1297             pforma = self._hprint_vseparator(pforma1, pforma2)
1298             pforma = prettyForm(*pforma.left('; '))
1299             pform = prettyForm(*pforma.left(pforma0))
1300         pform = prettyForm(*pform.parens())
1301         pform = prettyForm(*pform.left(name))
1302         return pform
1303 
1304     def _print_GoldenRatio(self, expr):
1305         if self._use_unicode:
1306             return prettyForm(pretty_symbol('phi'))
1307         return self._print(Symbol("GoldenRatio"))
1308 
1309     def _print_EulerGamma(self, expr):
1310         if self._use_unicode:
1311             return prettyForm(pretty_symbol('gamma'))
1312         return self._print(Symbol("EulerGamma"))
1313 
1314     def _print_Mod(self, expr):
1315         pform = self._print(expr.args[0])
1316         if pform.binding > prettyForm.MUL:
1317             pform = prettyForm(*pform.parens())
1318         pform = prettyForm(*pform.right(' mod '))
1319         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1320         pform.binding = prettyForm.OPEN
1321         return pform
1322 
1323     def _print_Add(self, expr, order=None):
1324         if self.order == 'none':
1325             terms = list(expr.args)
1326         else:
1327             terms = self._as_ordered_terms(expr, order=order)
1328         pforms, indices = [], []
1329 
1330         def pretty_negative(pform, index):
1331             """Prepend a minus sign to a pretty form. """
1332             #TODO: Move this code to prettyForm
1333             if index == 0:
1334                 if pform.height() > 1:
1335                     pform_neg = '- '
1336                 else:
1337                     pform_neg = '-'
1338             else:
1339                 pform_neg = ' - '
1340 
1341             if pform.binding > prettyForm.NEG:
1342                 p = stringPict(*pform.parens())
1343             else:
1344                 p = pform
1345             p = stringPict.next(pform_neg, p)
1346             # Lower the binding to NEG, even if it was higher. Otherwise, it
1347             # will print as a + ( - (b)), instead of a - (b).
1348             return prettyForm(binding=prettyForm.NEG, *p)
1349 
1350         for i, term in enumerate(terms):
1351             if term.is_Mul and _coeff_isneg(term):
1352                 coeff, other = term.as_coeff_mul(rational=False)
1353                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1354                 pforms.append(pretty_negative(pform, i))
1355             elif term.is_Rational and term.q > 1:
1356                 pforms.append(None)
1357                 indices.append(i)
1358             elif term.is_Number and term < 0:
1359                 pform = self._print(-term)
1360                 pforms.append(pretty_negative(pform, i))
1361             elif term.is_Relational:
1362                 pforms.append(prettyForm(*self._print(term).parens()))
1363             else:
1364                 pforms.append(self._print(term))
1365 
1366         if indices:
1367             large = True
1368 
1369             for pform in pforms:
1370                 if pform is not None and pform.height() > 1:
1371                     break
1372             else:
1373                 large = False
1374 
1375             for i in indices:
1376                 term, negative = terms[i], False
1377 
1378                 if term < 0:
1379                     term, negative = -term, True
1380 
1381                 if large:
1382                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1383                 else:
1384                     pform = self._print(term)
1385 
1386                 if negative:
1387                     pform = pretty_negative(pform, i)
1388 
1389                 pforms[i] = pform
1390 
1391         return prettyForm.__add__(*pforms)
1392 
1393     def _print_Mul(self, product):
1394         a = []  # items in the numerator
1395         b = []  # items that are in the denominator (if any)
1396 
1397         if self.order not in ('old', 'none'):
1398             args = product.as_ordered_factors()
1399         else:
1400             args = product.args
1401 
1402         # Gather terms for numerator/denominator
1403         for item in args:
1404             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1405                 if item.exp != -1:
1406                     b.append(Pow(item.base, -item.exp, evaluate=False))
1407                 else:
1408                     b.append(Pow(item.base, -item.exp))
1409             elif item.is_Rational and item is not S.Infinity:
1410                 if item.p != 1:
1411                     a.append( Rational(item.p) )
1412                 if item.q != 1:
1413                     b.append( Rational(item.q) )
1414             else:
1415                 a.append(item)
1416 
1417         from sympy import Integral, Piecewise, Product, Sum
1418 
1419         # Convert to pretty forms. Add parens to Add instances if there
1420         # is more than one term in the numer/denom
1421         for i in range(0, len(a)):
1422             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1423                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1424                 a[i] = prettyForm(*self._print(a[i]).parens())
1425             elif a[i].is_Relational:
1426                 a[i] = prettyForm(*self._print(a[i]).parens())
1427             else:
1428                 a[i] = self._print(a[i])
1429 
1430         for i in range(0, len(b)):
1431             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1432                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1433                 b[i] = prettyForm(*self._print(b[i]).parens())
1434             else:
1435                 b[i] = self._print(b[i])
1436 
1437         # Construct a pretty form
1438         if len(b) == 0:
1439             return prettyForm.__mul__(*a)
1440         else:
1441             if len(a) == 0:
1442                 a.append( self._print(S.One) )
1443             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1444 
1445     # A helper function for _print_Pow to print x**(1/n)
1446     def _print_nth_root(self, base, expt):
1447         bpretty = self._print(base)
1448 
1449         # In very simple cases, use a single-char root sign
1450         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1451             and expt is S.Half and bpretty.height() == 1
1452             and (bpretty.width() == 1
1453                  or (base.is_Integer and base.is_nonnegative))):
1454             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1455 
1456         # Construct root sign, start with the \/ shape
1457         _zZ = xobj('/', 1)
1458         rootsign = xobj('\\', 1) + _zZ
1459         # Make exponent number to put above it
1460         if isinstance(expt, Rational):
1461             exp = str(expt.q)
1462             if exp == '2':
1463                 exp = ''
1464         else:
1465             exp = str(expt.args[0])
1466         exp = exp.ljust(2)
1467         if len(exp) > 2:
1468             rootsign = ' '*(len(exp) - 2) + rootsign
1469         # Stack the exponent
1470         rootsign = stringPict(exp + '\n' + rootsign)
1471         rootsign.baseline = 0
1472         # Diagonal: length is one less than height of base
1473         linelength = bpretty.height() - 1
1474         diagonal = stringPict('\n'.join(
1475             ' '*(linelength - i - 1) + _zZ + ' '*i
1476             for i in range(linelength)
1477         ))
1478         # Put baseline just below lowest line: next to exp
1479         diagonal.baseline = linelength - 1
1480         # Make the root symbol
1481         rootsign = prettyForm(*rootsign.right(diagonal))
1482         # Det the baseline to match contents to fix the height
1483         # but if the height of bpretty is one, the rootsign must be one higher
1484         rootsign.baseline = max(1, bpretty.baseline)
1485         #build result
1486         s = prettyForm(hobj('_', 2 + bpretty.width()))
1487         s = prettyForm(*bpretty.above(s))
1488         s = prettyForm(*s.left(rootsign))
1489         return s
1490 
1491     def _print_Pow(self, power):
1492         from sympy.simplify.simplify import fraction
1493         b, e = power.as_base_exp()
1494         if power.is_commutative:
1495             if e is S.NegativeOne:
1496                 return prettyForm("1")/self._print(b)
1497             n, d = fraction(e)
1498             if n is S.One and d.is_Atom and not e.is_Integer:
1499                 return self._print_nth_root(b, e)
1500             if e.is_Rational and e < 0:
1501                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1502 
1503         if b.is_Relational:
1504             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1505 
1506         return self._print(b)**self._print(e)
1507 
1508     def _print_UnevaluatedExpr(self, expr):
1509         return self._print(expr.args[0])
1510 
1511     def __print_numer_denom(self, p, q):
1512         if q == 1:
1513             if p < 0:
1514                 return prettyForm(str(p), binding=prettyForm.NEG)
1515             else:
1516                 return prettyForm(str(p))
1517         elif abs(p) >= 10 and abs(q) >= 10:
1518             # If more than one digit in numer and denom, print larger fraction
1519             if p < 0:
1520                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1521                 # Old printing method:
1522                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1523                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1524             else:
1525                 return prettyForm(str(p))/prettyForm(str(q))
1526         else:
1527             return None
1528 
1529     def _print_Rational(self, expr):
1530         result = self.__print_numer_denom(expr.p, expr.q)
1531 
1532         if result is not None:
1533             return result
1534         else:
1535             return self.emptyPrinter(expr)
1536 
1537     def _print_Fraction(self, expr):
1538         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1539 
1540         if result is not None:
1541             return result
1542         else:
1543             return self.emptyPrinter(expr)
1544 
1545     def _print_ProductSet(self, p):
1546         if len(p.sets) > 1 and not has_variety(p.sets):
1547             from sympy import Pow
1548             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1549         else:
1550             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1551             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1552                                    parenthesize=lambda set: set.is_Union or
1553                                    set.is_Intersection or set.is_ProductSet)
1554 
1555     def _print_FiniteSet(self, s):
1556         items = sorted(s.args, key=default_sort_key)
1557         return self._print_seq(items, '{', '}', ', ' )
1558 
1559     def _print_Range(self, s):
1560 
1561         if self._use_unicode:
1562             dots = u"\N{HORIZONTAL ELLIPSIS}"
1563         else:
1564             dots = '...'
1565 
1566         if s.start.is_infinite:
1567             printset = s.start, dots, s[-1] - s.step, s[-1]
1568         elif s.stop.is_infinite or len(s) > 4:
1569             it = iter(s)
1570             printset = next(it), next(it), dots, s[-1]
1571         else:
1572             printset = tuple(s)
1573 
1574         return self._print_seq(printset, '{', '}', ', ' )
1575 
1576     def _print_Interval(self, i):
1577         if i.start == i.end:
1578             return self._print_seq(i.args[:1], '{', '}')
1579 
1580         else:
1581             if i.left_open:
1582                 left = '('
1583             else:
1584                 left = '['
1585 
1586             if i.right_open:
1587                 right = ')'
1588             else:
1589                 right = ']'
1590 
1591             return self._print_seq(i.args[:2], left, right)
1592 
1593     def _print_AccumuBounds(self, i):
1594         left = '<'
1595         right = '>'
1596 
1597         return self._print_seq(i.args[:2], left, right)
1598 
1599     def _print_Intersection(self, u):
1600 
1601         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1602 
1603         return self._print_seq(u.args, None, None, delimiter,
1604                                parenthesize=lambda set: set.is_ProductSet or
1605                                set.is_Union or set.is_Complement)
1606 
1607     def _print_Union(self, u):
1608 
1609         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1610 
1611         return self._print_seq(u.args, None, None, union_delimiter,
1612                                parenthesize=lambda set: set.is_ProductSet or
1613                                set.is_Intersection or set.is_Complement)
1614 
1615     def _print_SymmetricDifference(self, u):
1616         if not self._use_unicode:
1617             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1618 
1619         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1620 
1621         return self._print_seq(u.args, None, None, sym_delimeter)
1622 
1623     def _print_Complement(self, u):
1624 
1625         delimiter = ' \ '
1626 
1627         return self._print_seq(u.args, None, None, delimiter,
1628              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1629                                or set.is_Union)
1630 
1631     def _print_ImageSet(self, ts):
1632         if self._use_unicode:
1633             inn = u"\N{SMALL ELEMENT OF}"
1634         else:
1635             inn = 'in'
1636         variables = self._print_seq(ts.lamda.variables)
1637         expr = self._print(ts.lamda.expr)
1638         bar = self._print("|")
1639         base = self._print(ts.base_set)
1640 
1641         return self._print_seq((expr, bar, variables, inn, base), "{", "}", ' ')
1642 
1643     def _print_ConditionSet(self, ts):
1644         if self._use_unicode:
1645             inn = u"\N{SMALL ELEMENT OF}"
1646             # using _and because and is a keyword and it is bad practice to
1647             # overwrite them
1648             _and = u"\N{LOGICAL AND}"
1649         else:
1650             inn = 'in'
1651             _and = 'and'
1652 
1653         variables = self._print_seq(Tuple(ts.sym))
1654         try:
1655             cond = self._print(ts.condition.as_expr())
1656         except AttributeError:
1657             cond = self._print(ts.condition)
1658             if self._use_unicode:
1659                 cond = self._print_seq(cond, "(", ")")
1660 
1661         bar = self._print("|")
1662         base = self._print(ts.base_set)
1663 
1664         return self._print_seq((variables, bar, variables, inn,
1665                                 base, _and, cond), "{", "}", ' ')
1666 
1667     def _print_ComplexRegion(self, ts):
1668         if self._use_unicode:
1669             inn = u"\N{SMALL ELEMENT OF}"
1670         else:
1671             inn = 'in'
1672         variables = self._print_seq(ts.variables)
1673         expr = self._print(ts.expr)
1674         bar = self._print("|")
1675         prodsets = self._print(ts.sets)
1676 
1677         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1678 
1679     def _print_Contains(self, e):
1680         var, set = e.args
1681         if self._use_unicode:
1682             el = u" \N{ELEMENT OF} "
1683             return prettyForm(*stringPict.next(self._print(var),
1684                                                el, self._print(set)), binding=8)
1685         else:
1686             return prettyForm(sstr(e))
1687 
1688     def _print_FourierSeries(self, s):
1689         if self._use_unicode:
1690             dots = u"\N{HORIZONTAL ELLIPSIS}"
1691         else:
1692             dots = '...'
1693         return self._print_Add(s.truncate()) + self._print(dots)
1694 
1695     def _print_FormalPowerSeries(self, s):
1696         return self._print_Add(s.infinite)
1697 
1698     def _print_SeqFormula(self, s):
1699         if self._use_unicode:
1700             dots = u"\N{HORIZONTAL ELLIPSIS}"
1701         else:
1702             dots = '...'
1703 
1704         if s.start is S.NegativeInfinity:
1705             stop = s.stop
1706             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1707                 s.coeff(stop - 1), s.coeff(stop))
1708         elif s.stop is S.Infinity or s.length > 4:
1709             printset = s[:4]
1710             printset.append(dots)
1711             printset = tuple(printset)
1712         else:
1713             printset = tuple(s)
1714         return self._print_list(printset)
1715 
1716     _print_SeqPer = _print_SeqFormula
1717     _print_SeqAdd = _print_SeqFormula
1718     _print_SeqMul = _print_SeqFormula
1719 
1720     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1721             parenthesize=lambda x: False):
1722         s = None
1723 
1724         for item in seq:
1725             pform = self._print(item)
1726 
1727             if parenthesize(item):
1728                 pform = prettyForm(*pform.parens())
1729             if s is None:
1730                 # first element
1731                 s = pform
1732             else:
1733                 s = prettyForm(*stringPict.next(s, delimiter))
1734                 s = prettyForm(*stringPict.next(s, pform))
1735 
1736         if s is None:
1737             s = stringPict('')
1738 
1739         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
1740         return s
1741 
1742     def join(self, delimiter, args):
1743         pform = None
1744 
1745         for arg in args:
1746             if pform is None:
1747                 pform = arg
1748             else:
1749                 pform = prettyForm(*pform.right(delimiter))
1750                 pform = prettyForm(*pform.right(arg))
1751 
1752         if pform is None:
1753             return prettyForm("")
1754         else:
1755             return pform
1756 
1757     def _print_list(self, l):
1758         return self._print_seq(l, '[', ']')
1759 
1760     def _print_tuple(self, t):
1761         if len(t) == 1:
1762             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
1763             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
1764         else:
1765             return self._print_seq(t, '(', ')')
1766 
1767     def _print_Tuple(self, expr):
1768         return self._print_tuple(expr)
1769 
1770     def _print_dict(self, d):
1771         keys = sorted(d.keys(), key=default_sort_key)
1772         items = []
1773 
1774         for k in keys:
1775             K = self._print(k)
1776             V = self._print(d[k])
1777             s = prettyForm(*stringPict.next(K, ': ', V))
1778 
1779             items.append(s)
1780 
1781         return self._print_seq(items, '{', '}')
1782 
1783     def _print_Dict(self, d):
1784         return self._print_dict(d)
1785 
1786     def _print_set(self, s):
1787         items = sorted(s, key=default_sort_key)
1788         pretty = self._print_seq(items, '[', ']')
1789         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
1790         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
1791         return pretty
1792 
1793     _print_frozenset = _print_set
1794 
1795     def _print_PolyRing(self, ring):
1796         return prettyForm(sstr(ring))
1797 
1798     def _print_FracField(self, field):
1799         return prettyForm(sstr(field))
1800 
1801     def _print_FreeGroupElement(self, elm):
1802         return prettyForm(str(elm))
1803 
1804     def _print_PolyElement(self, poly):
1805         return prettyForm(sstr(poly))
1806 
1807     def _print_FracElement(self, frac):
1808         return prettyForm(sstr(frac))
1809 
1810     def _print_AlgebraicNumber(self, expr):
1811         if expr.is_aliased:
1812             return self._print(expr.as_poly().as_expr())
1813         else:
1814             return self._print(expr.as_expr())
1815 
1816     def _print_ComplexRootOf(self, expr):
1817         args = [self._print_Add(expr.expr, order='lex'), expr.index]
1818         pform = prettyForm(*self._print_seq(args).parens())
1819         pform = prettyForm(*pform.left('CRootOf'))
1820         return pform
1821 
1822     def _print_RootSum(self, expr):
1823         args = [self._print_Add(expr.expr, order='lex')]
1824 
1825         if expr.fun is not S.IdentityFunction:
1826             args.append(self._print(expr.fun))
1827 
1828         pform = prettyForm(*self._print_seq(args).parens())
1829         pform = prettyForm(*pform.left('RootSum'))
1830 
1831         return pform
1832 
1833     def _print_FiniteField(self, expr):
1834         if self._use_unicode:
1835             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
1836         else:
1837             form = 'GF(%d)'
1838 
1839         return prettyForm(pretty_symbol(form % expr.mod))
1840 
1841     def _print_IntegerRing(self, expr):
1842         if self._use_unicode:
1843             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
1844         else:
1845             return prettyForm('ZZ')
1846 
1847     def _print_RationalField(self, expr):
1848         if self._use_unicode:
1849             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
1850         else:
1851             return prettyForm('QQ')
1852 
1853     def _print_RealField(self, domain):
1854         if self._use_unicode:
1855             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
1856         else:
1857             prefix = 'RR'
1858 
1859         if domain.has_default_precision:
1860             return prettyForm(prefix)
1861         else:
1862             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
1863 
1864     def _print_ComplexField(self, domain):
1865         if self._use_unicode:
1866             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
1867         else:
1868             prefix = 'CC'
1869 
1870         if domain.has_default_precision:
1871             return prettyForm(prefix)
1872         else:
1873             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
1874 
1875     def _print_PolynomialRing(self, expr):
1876         args = list(expr.symbols)
1877 
1878         if not expr.order.is_default:
1879             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
1880             args.append(order)
1881 
1882         pform = self._print_seq(args, '[', ']')
1883         pform = prettyForm(*pform.left(self._print(expr.domain)))
1884 
1885         return pform
1886 
1887     def _print_FractionField(self, expr):
1888         args = list(expr.symbols)
1889 
1890         if not expr.order.is_default:
1891             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
1892             args.append(order)
1893 
1894         pform = self._print_seq(args, '(', ')')
1895         pform = prettyForm(*pform.left(self._print(expr.domain)))
1896 
1897         return pform
1898 
1899     def _print_PolynomialRingBase(self, expr):
1900         g = expr.symbols
1901         if str(expr.order) != str(expr.default_order):
1902             g = g + ("order=" + str(expr.order),)
1903         pform = self._print_seq(g, '[', ']')
1904         pform = prettyForm(*pform.left(self._print(expr.domain)))
1905 
1906         return pform
1907 
1908     def _print_GroebnerBasis(self, basis):
1909         exprs = [ self._print_Add(arg, order=basis.order)
1910                   for arg in basis.exprs ]
1911         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
1912 
1913         gens = [ self._print(gen) for gen in basis.gens ]
1914 
1915         domain = prettyForm(
1916             *prettyForm("domain=").right(self._print(basis.domain)))
1917         order = prettyForm(
1918             *prettyForm("order=").right(self._print(basis.order)))
1919 
1920         pform = self.join(", ", [exprs] + gens + [domain, order])
1921 
1922         pform = prettyForm(*pform.parens())
1923         pform = prettyForm(*pform.left(basis.__class__.__name__))
1924 
1925         return pform
1926 
1927     def _print_Subs(self, e):
1928         pform = self._print(e.expr)
1929         pform = prettyForm(*pform.parens())
1930 
1931         h = pform.height() if pform.height() > 1 else 2
1932         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
1933         pform = prettyForm(*pform.right(rvert))
1934 
1935         b = pform.baseline
1936         pform.baseline = pform.height() - 1
1937         pform = prettyForm(*pform.right(self._print_seq([
1938             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
1939                 delimiter='') for v in zip(e.variables, e.point) ])))
1940 
1941         pform.baseline = b
1942         return pform
1943 
1944     def _print_euler(self, e):
1945         pform = prettyForm("E")
1946         arg = self._print(e.args[0])
1947         pform_arg = prettyForm(" "*arg.width())
1948         pform_arg = prettyForm(*pform_arg.below(arg))
1949         pform = prettyForm(*pform.right(pform_arg))
1950         return pform
1951 
1952     def _print_catalan(self, e):
1953         pform = prettyForm("C")
1954         arg = self._print(e.args[0])
1955         pform_arg = prettyForm(" "*arg.width())
1956         pform_arg = prettyForm(*pform_arg.below(arg))
1957         pform = prettyForm(*pform.right(pform_arg))
1958         return pform
1959 
1960     def _print_KroneckerDelta(self, e):
1961         pform = self._print(e.args[0])
1962         pform = prettyForm(*pform.right((prettyForm(','))))
1963         pform = prettyForm(*pform.right((self._print(e.args[1]))))
1964         if self._use_unicode:
1965             a = stringPict(pretty_symbol('delta'))
1966         else:
1967             a = stringPict('d')
1968         b = pform
1969         top = stringPict(*b.left(' '*a.width()))
1970         bot = stringPict(*a.right(' '*b.width()))
1971         return prettyForm(binding=prettyForm.POW, *bot.below(top))
1972 
1973     def _print_RandomDomain(self, d):
1974         try:
1975             pform = self._print('Domain: ')
1976             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
1977             return pform
1978 
1979         except Exception:
1980             try:
1981                 pform = self._print('Domain: ')
1982                 pform = prettyForm(*pform.right(self._print(d.symbols)))
1983                 pform = prettyForm(*pform.right(self._print(' in ')))
1984                 pform = prettyForm(*pform.right(self._print(d.set)))
1985                 return pform
1986             except:
1987                 return self._print(None)
1988 
1989     def _print_DMP(self, p):
1990         try:
1991             if p.ring is not None:
1992                 # TODO incorporate order
1993                 return self._print(p.ring.to_sympy(p))
1994         except SympifyError:
1995             pass
1996         return self._print(repr(p))
1997 
1998     def _print_DMF(self, p):
1999         return self._print_DMP(p)
2000 
2001     def _print_Object(self, object):
2002         return self._print(pretty_symbol(object.name))
2003 
2004     def _print_Morphism(self, morphism):
2005         arrow = xsym("-->")
2006 
2007         domain = self._print(morphism.domain)
2008         codomain = self._print(morphism.codomain)
2009         tail = domain.right(arrow, codomain)[0]
2010 
2011         return prettyForm(tail)
2012 
2013     def _print_NamedMorphism(self, morphism):
2014         pretty_name = self._print(pretty_symbol(morphism.name))
2015         pretty_morphism = self._print_Morphism(morphism)
2016         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2017 
2018     def _print_IdentityMorphism(self, morphism):
2019         from sympy.categories import NamedMorphism
2020         return self._print_NamedMorphism(
2021             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2022 
2023     def _print_CompositeMorphism(self, morphism):
2024 
2025         circle = xsym(".")
2026 
2027         # All components of the morphism have names and it is thus
2028         # possible to build the name of the composite.
2029         component_names_list = [pretty_symbol(component.name) for
2030                                 component in morphism.components]
2031         component_names_list.reverse()
2032         component_names = circle.join(component_names_list) + ":"
2033 
2034         pretty_name = self._print(component_names)
2035         pretty_morphism = self._print_Morphism(morphism)
2036         return prettyForm(pretty_name.right(pretty_morphism)[0])
2037 
2038     def _print_Category(self, category):
2039         return self._print(pretty_symbol(category.name))
2040 
2041     def _print_Diagram(self, diagram):
2042         if not diagram.premises:
2043             # This is an empty diagram.
2044             return self._print(S.EmptySet)
2045 
2046         pretty_result = self._print(diagram.premises)
2047         if diagram.conclusions:
2048             results_arrow = " %s " % xsym("==>")
2049 
2050             pretty_conclusions = self._print(diagram.conclusions)[0]
2051             pretty_result = pretty_result.right(
2052                 results_arrow, pretty_conclusions)
2053 
2054         return prettyForm(pretty_result[0])
2055 
2056     def _print_DiagramGrid(self, grid):
2057         from sympy.matrices import Matrix
2058         from sympy import Symbol
2059         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2060                           for j in range(grid.width)]
2061                          for i in range(grid.height)])
2062         return self._print_matrix_contents(matrix)
2063 
2064     def _print_FreeModuleElement(self, m):
2065         # Print as row vector for convenience, for now.
2066         return self._print_seq(m, '[', ']')
2067 
2068     def _print_SubModule(self, M):
2069         return self._print_seq(M.gens, '<', '>')
2070 
2071     def _print_FreeModule(self, M):
2072         return self._print(M.ring)**self._print(M.rank)
2073 
2074     def _print_ModuleImplementedIdeal(self, M):
2075         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2076 
2077     def _print_QuotientRing(self, R):
2078         return self._print(R.ring) / self._print(R.base_ideal)
2079 
2080     def _print_QuotientRingElement(self, R):
2081         return self._print(R.data) + self._print(R.ring.base_ideal)
2082 
2083     def _print_QuotientModuleElement(self, m):
2084         return self._print(m.data) + self._print(m.module.killed_module)
2085 
2086     def _print_QuotientModule(self, M):
2087         return self._print(M.base) / self._print(M.killed_module)
2088 
2089     def _print_MatrixHomomorphism(self, h):
2090         matrix = self._print(h._sympy_matrix())
2091         matrix.baseline = matrix.height() // 2
2092         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2093             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2094         return pform
2095 
2096     def _print_BaseScalarField(self, field):
2097         string = field._coord_sys._names[field._index]
2098         return self._print(pretty_symbol(string))
2099 
2100     def _print_BaseVectorField(self, field):
2101         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2102         return self._print(pretty_symbol(s))
2103 
2104     def _print_Differential(self, diff):
2105         field = diff._form_field
2106         if hasattr(field, '_coord_sys'):
2107             string = field._coord_sys._names[field._index]
2108             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2109         else:
2110             pform = self._print(field)
2111             pform = prettyForm(*pform.parens())
2112             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2113 
2114     def _print_Tr(self, p):
2115         #TODO: Handle indices
2116         pform = self._print(p.args[0])
2117         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2118         pform = prettyForm(*pform.right(')'))
2119         return pform
2120 
2121     def _print_primenu(self, e):
2122         pform = self._print(e.args[0])
2123         pform = prettyForm(*pform.parens())
2124         if self._use_unicode:
2125             pform = prettyForm(*pform.left(greek_unicode['nu']))
2126         else:
2127             pform = prettyForm(*pform.left('nu'))
2128         return pform
2129 
2130     def _print_primeomega(self, e):
2131         pform = self._print(e.args[0])
2132         pform = prettyForm(*pform.parens())
2133         if self._use_unicode:
2134             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2135         else:
2136             pform = prettyForm(*pform.left('Omega'))
2137         return pform

</code><intended_behavior>The methods within the `PrettyPrinter` class responsible for printing fractions, exponentials, logarithms, and other expressions highlighted in the issue should be evaluated to ensure they are structurally and conceptually consistent with LaTeX output where feasible. While maintaining the readability and simplicity of the pretty print format, slight adjustments may be necessary to align both outputs more closely. This might involve modifying how the pretty printer simplifies expressions or represents certain mathematical constructs to minimize discrepancies with LaTeX representations, provided these changes do not compromise the clarity or the utility of the pretty printed output.</intended_behavior>]
2025-10-15 12:55:36.307 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>None</class>
<method>latex</method>
<code>
2026 def latex(expr, **settings):
2027     r"""
2028     Convert the given expression to LaTeX representation.
2029 
2030     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational
2031     >>> from sympy.abc import x, y, mu, r, tau
2032 
2033     >>> print(latex((2*tau)**Rational(7,2)))
2034     8 \sqrt{2} \tau^{\frac{7}{2}}
2035 
2036     Not using a print statement for printing, results in double backslashes for
2037     latex commands since that's the way Python escapes backslashes in strings.
2038 
2039     >>> latex((2*tau)**Rational(7,2))
2040     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2041 
2042     order: Any of the supported monomial orderings (currently "lex", "grlex", or
2043     "grevlex"), "old", and "none". This parameter does nothing for Mul objects.
2044     Setting order to "old" uses the compatibility ordering for Add defined in
2045     Printer. For very large expressions, set the 'order' keyword to 'none' if
2046     speed is a concern.
2047 
2048     mode: Specifies how the generated code will be delimited. 'mode' can be one
2049     of 'plain', 'inline', 'equation' or 'equation*'.  If 'mode' is set to
2050     'plain', then the resulting code will not be delimited at all (this is the
2051     default). If 'mode' is set to 'inline' then inline LaTeX $ $ will be used.
2052     If 'mode' is set to 'equation' or 'equation*', the resulting code will be
2053     enclosed in the 'equation' or 'equation*' environment (remember to import
2054     'amsmath' for 'equation*'), unless the 'itex' option is set. In the latter
2055     case, the ``$$ $$`` syntax is used.
2056 
2057     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2058     8 \sqrt{2} \mu^{\frac{7}{2}}
2059 
2060     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2061     $8 \sqrt{2} \tau^{7 / 2}$
2062 
2063     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2064     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2065 
2066     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2067     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2068 
2069     itex: Specifies if itex-specific syntax is used, including emitting ``$$ $$``.
2070 
2071     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2072     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2073 
2074     fold_frac_powers: Emit "^{p/q}" instead of "^{\frac{p}{q}}" for fractional
2075     powers.
2076 
2077     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2078     8 \sqrt{2} \tau^{7/2}
2079 
2080     fold_func_brackets: Fold function brackets where applicable.
2081 
2082     >>> print(latex((2*tau)**sin(Rational(7,2))))
2083     \left(2 \tau\right)^{\sin{\left (\frac{7}{2} \right )}}
2084     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets = True))
2085     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2086 
2087     fold_short_frac: Emit "p / q" instead of "\frac{p}{q}" when the
2088     denominator is simple enough (at most two terms and no powers).
2089     The default value is `True` for inline mode, False otherwise.
2090 
2091     >>> print(latex(3*x**2/y))
2092     \frac{3 x^{2}}{y}
2093     >>> print(latex(3*x**2/y, fold_short_frac=True))
2094     3 x^{2} / y
2095 
2096     long_frac_ratio: The allowed ratio of the width of the numerator to the
2097     width of the denominator before we start breaking off long fractions.
2098     The default value is 2.
2099 
2100     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2101     \frac{\int r\, dr}{2 \pi}
2102     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2103     \frac{1}{2 \pi} \int r\, dr
2104 
2105     mul_symbol: The symbol to use for multiplication. Can be one of None,
2106     "ldot", "dot", or "times".
2107 
2108     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2109     \left(2 \times \tau\right)^{\sin{\left (\frac{7}{2} \right )}}
2110 
2111     inv_trig_style: How inverse trig functions should be displayed. Can be one
2112     of "abbreviated", "full", or "power". Defaults to "abbreviated".
2113 
2114     >>> print(latex(asin(Rational(7,2))))
2115     \operatorname{asin}{\left (\frac{7}{2} \right )}
2116     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2117     \arcsin{\left (\frac{7}{2} \right )}
2118     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2119     \sin^{-1}{\left (\frac{7}{2} \right )}
2120 
2121     mat_str: Which matrix environment string to emit. "smallmatrix", "matrix",
2122     "array", etc. Defaults to "smallmatrix" for inline mode, "matrix" for
2123     matrices of no more than 10 columns, and "array" otherwise.
2124 
2125     >>> print(latex(Matrix(2, 1, [x, y])))
2126     \left[\begin{matrix}x\\y\end{matrix}\right]
2127 
2128     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2129     \left[\begin{array}{c}x\\y\end{array}\right]
2130 
2131     mat_delim: The delimiter to wrap around matrices. Can be one of "[", "(",
2132     or the empty string. Defaults to "[".
2133 
2134     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2135     \left(\begin{matrix}x\\y\end{matrix}\right)
2136 
2137     symbol_names: Dictionary of symbols and the custom strings they should be
2138     emitted as.
2139 
2140     >>> print(latex(x**2, symbol_names={x:'x_i'}))
2141     x_i^{2}
2142 
2143     ``latex`` also supports the builtin container types list, tuple, and
2144     dictionary.
2145 
2146     >>> print(latex([2/x, y], mode='inline'))
2147     $\left [ 2 / x, \quad y\right ]$
2148 
2149     """
2150 
2151     return LatexPrinter(settings).doprint(expr)

</code><intended_behavior>The `latex` method should be reviewed and potentially adjusted to ensure that its output is consistent with the pretty printer's output in terms of mathematical structure and hierarchy. While LaTeX offers more sophisticated formatting capabilities, the method should aim to represent mathematical expressions in a way that aligns with the conceptual representation done by the pretty printer. Adjustments might include handling of fractions, exponentials, logarithms, and symbol assumptions to closely match the structure presented by the pretty printer, without losing the mathematical fidelity or the expressive advantages of the LaTeX format.</intended_behavior>, <file>sympy/printing/pretty/pretty.py</file>
<class>PrettyPrinter</class>
<method>None</method>
<code>
37 class PrettyPrinter(Printer):
38     """Printer, which converts an expression into 2D ASCII-art figure."""
39     printmethod = "_pretty"
40 
41     _default_settings = {
42         "order": None,
43         "full_prec": "auto",
44         "use_unicode": None,
45         "wrap_line": True,
46         "num_columns": None,
47         "use_unicode_sqrt_char": True,
48     }
49 
50     def __init__(self, settings=None):
51         Printer.__init__(self, settings)
52         self.emptyPrinter = lambda x: prettyForm(xstr(x))
53 
54     @property
55     def _use_unicode(self):
56         if self._settings['use_unicode']:
57             return True
58         else:
59             return pretty_use_unicode()
60 
61     def doprint(self, expr):
62         return self._print(expr).render(**self._settings)
63 
64     # empty op so _print(stringPict) returns the same
65     def _print_stringPict(self, e):
66         return e
67 
68     def _print_basestring(self, e):
69         return prettyForm(e)
70 
71     def _print_atan2(self, e):
72         pform = prettyForm(*self._print_seq(e.args).parens())
73         pform = prettyForm(*pform.left('atan2'))
74         return pform
75 
76     def _print_Symbol(self, e):
77         symb = pretty_symbol(e.name)
78         return prettyForm(symb)
79     _print_RandomSymbol = _print_Symbol
80 
81     def _print_Float(self, e):
82         # we will use StrPrinter's Float printer, but we need to handle the
83         # full_prec ourselves, according to the self._print_level
84         full_prec = self._settings["full_prec"]
85         if full_prec == "auto":
86             full_prec = self._print_level == 1
87         return prettyForm(sstr(e, full_prec=full_prec))
88 
89     def _print_Atom(self, e):
90         try:
91             # print atoms like Exp1 or Pi
92             return prettyForm(pretty_atom(e.__class__.__name__))
93         except KeyError:
94             return self.emptyPrinter(e)
95 
96     # Infinity inherits from Number, so we have to override _print_XXX order
97     _print_Infinity = _print_Atom
98     _print_NegativeInfinity = _print_Atom
99     _print_EmptySet = _print_Atom
100     _print_Naturals = _print_Atom
101     _print_Naturals0 = _print_Atom
102     _print_Integers = _print_Atom
103     _print_Reals = _print_Atom
104     _print_Complexes = _print_Atom
105 
106     def _print_subfactorial(self, e):
107         x = e.args[0]
108         pform = self._print(x)
109         # Add parentheses if needed
110         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
111             pform = prettyForm(*pform.parens())
112         pform = prettyForm(*pform.left('!'))
113         return pform
114 
115     def _print_factorial(self, e):
116         x = e.args[0]
117         pform = self._print(x)
118         # Add parentheses if needed
119         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
120             pform = prettyForm(*pform.parens())
121         pform = prettyForm(*pform.right('!'))
122         return pform
123 
124     def _print_factorial2(self, e):
125         x = e.args[0]
126         pform = self._print(x)
127         # Add parentheses if needed
128         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
129             pform = prettyForm(*pform.parens())
130         pform = prettyForm(*pform.right('!!'))
131         return pform
132 
133     def _print_binomial(self, e):
134         n, k = e.args
135 
136         n_pform = self._print(n)
137         k_pform = self._print(k)
138 
139         bar = ' '*max(n_pform.width(), k_pform.width())
140 
141         pform = prettyForm(*k_pform.above(bar))
142         pform = prettyForm(*pform.above(n_pform))
143         pform = prettyForm(*pform.parens('(', ')'))
144 
145         pform.baseline = (pform.baseline + 1)//2
146 
147         return pform
148 
149     def _print_Relational(self, e):
150         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
151 
152         l = self._print(e.lhs)
153         r = self._print(e.rhs)
154         pform = prettyForm(*stringPict.next(l, op, r))
155         return pform
156 
157     def _print_Not(self, e):
158         from sympy import Equivalent, Implies
159         if self._use_unicode:
160             arg = e.args[0]
161             pform = self._print(arg)
162             if isinstance(arg, Equivalent):
163                 return self._print_Equivalent(arg, altchar=u"\N{NOT IDENTICAL TO}")
164             if isinstance(arg, Implies):
165                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
166 
167             if arg.is_Boolean and not arg.is_Not:
168                 pform = prettyForm(*pform.parens())
169 
170             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
171         else:
172             return self._print_Function(e)
173 
174     def __print_Boolean(self, e, char, sort=True):
175         args = e.args
176         if sort:
177             args = sorted(e.args, key=default_sort_key)
178         arg = args[0]
179         pform = self._print(arg)
180 
181         if arg.is_Boolean and not arg.is_Not:
182             pform = prettyForm(*pform.parens())
183 
184         for arg in args[1:]:
185             pform_arg = self._print(arg)
186 
187             if arg.is_Boolean and not arg.is_Not:
188                 pform_arg = prettyForm(*pform_arg.parens())
189 
190             pform = prettyForm(*pform.right(u' %s ' % char))
191             pform = prettyForm(*pform.right(pform_arg))
192 
193         return pform
194 
195     def _print_And(self, e):
196         if self._use_unicode:
197             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
198         else:
199             return self._print_Function(e, sort=True)
200 
201     def _print_Or(self, e):
202         if self._use_unicode:
203             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
204         else:
205             return self._print_Function(e, sort=True)
206 
207     def _print_Xor(self, e):
208         if self._use_unicode:
209             return self.__print_Boolean(e, u"\N{XOR}")
210         else:
211             return self._print_Function(e, sort=True)
212 
213     def _print_Nand(self, e):
214         if self._use_unicode:
215             return self.__print_Boolean(e, u"\N{NAND}")
216         else:
217             return self._print_Function(e, sort=True)
218 
219     def _print_Nor(self, e):
220         if self._use_unicode:
221             return self.__print_Boolean(e, u"\N{NOR}")
222         else:
223             return self._print_Function(e, sort=True)
224 
225     def _print_Implies(self, e, altchar=None):
226         if self._use_unicode:
227             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
228         else:
229             return self._print_Function(e)
230 
231     def _print_Equivalent(self, e, altchar=None):
232         if self._use_unicode:
233             return self.__print_Boolean(e, altchar or u"\N{IDENTICAL TO}")
234         else:
235             return self._print_Function(e, sort=True)
236 
237     def _print_conjugate(self, e):
238         pform = self._print(e.args[0])
239         return prettyForm( *pform.above( hobj('_', pform.width())) )
240 
241     def _print_Abs(self, e):
242         pform = self._print(e.args[0])
243         pform = prettyForm(*pform.parens('|', '|'))
244         return pform
245     _print_Determinant = _print_Abs
246 
247     def _print_floor(self, e):
248         if self._use_unicode:
249             pform = self._print(e.args[0])
250             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
251             return pform
252         else:
253             return self._print_Function(e)
254 
255     def _print_ceiling(self, e):
256         if self._use_unicode:
257             pform = self._print(e.args[0])
258             pform = prettyForm(*pform.parens('lceil', 'rceil'))
259             return pform
260         else:
261             return self._print_Function(e)
262 
263     def _print_Derivative(self, deriv):
264         if requires_partial(deriv) and self._use_unicode:
265             deriv_symbol = U('PARTIAL DIFFERENTIAL')
266         else:
267             deriv_symbol = r'd'
268         syms = list(reversed(deriv.variables))
269         x = None
270 
271         for sym, num in group(syms, multiple=False):
272             s = self._print(sym)
273             ds = prettyForm(*s.left(deriv_symbol))
274 
275             if num > 1:
276                 ds = ds**prettyForm(str(num))
277 
278             if x is None:
279                 x = ds
280             else:
281                 x = prettyForm(*x.right(' '))
282                 x = prettyForm(*x.right(ds))
283 
284         f = prettyForm(
285             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
286 
287         pform = prettyForm(deriv_symbol)
288 
289         if len(syms) > 1:
290             pform = pform**prettyForm(str(len(syms)))
291 
292         pform = prettyForm(*pform.below(stringPict.LINE, x))
293         pform.baseline = pform.baseline + 1
294         pform = prettyForm(*stringPict.next(pform, f))
295         pform.binding = prettyForm.MUL
296 
297         return pform
298 
299     def _print_Cycle(self, dc):
300         from sympy.combinatorics.permutations import Permutation, Cycle
301         # for Empty Cycle
302         if dc == Cycle():
303             cyc = stringPict('')
304             return prettyForm(*cyc.parens())
305 
306         dc_list = Permutation(dc.list()).cyclic_form
307         # for Identity Cycle
308         if dc_list == []:
309             cyc = self._print(dc.size - 1)
310             return prettyForm(*cyc.parens())
311 
312         cyc = stringPict('')
313         for i in dc_list:
314             l = self._print(str(tuple(i)).replace(',', ''))
315             cyc = prettyForm(*cyc.right(l))
316         return cyc
317 
318     def _print_PDF(self, pdf):
319         lim = self._print(pdf.pdf.args[0])
320         lim = prettyForm(*lim.right(', '))
321         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
322         lim = prettyForm(*lim.right(', '))
323         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
324         lim = prettyForm(*lim.parens())
325 
326         f = self._print(pdf.pdf.args[1])
327         f = prettyForm(*f.right(', '))
328         f = prettyForm(*f.right(lim))
329         f = prettyForm(*f.parens())
330 
331         pform = prettyForm('PDF')
332         pform = prettyForm(*pform.right(f))
333         return pform
334 
335     def _print_Integral(self, integral):
336         f = integral.function
337 
338         # Add parentheses if arg involves addition of terms and
339         # create a pretty form for the argument
340         prettyF = self._print(f)
341         # XXX generalize parens
342         if f.is_Add:
343             prettyF = prettyForm(*prettyF.parens())
344 
345         # dx dy dz ...
346         arg = prettyF
347         for x in integral.limits:
348             prettyArg = self._print(x[0])
349             # XXX qparens (parens if needs-parens)
350             if prettyArg.width() > 1:
351                 prettyArg = prettyForm(*prettyArg.parens())
352 
353             arg = prettyForm(*arg.right(' d', prettyArg))
354 
355         # \int \int \int ...
356         firstterm = True
357         s = None
358         for lim in integral.limits:
359             x = lim[0]
360             # Create bar based on the height of the argument
361             h = arg.height()
362             H = h + 2
363 
364             # XXX hack!
365             ascii_mode = not self._use_unicode
366             if ascii_mode:
367                 H += 2
368 
369             vint = vobj('int', H)
370 
371             # Construct the pretty form with the integral sign and the argument
372             pform = prettyForm(vint)
373             pform.baseline = arg.baseline + (
374                 H - h)//2    # covering the whole argument
375 
376             if len(lim) > 1:
377                 # Create pretty forms for endpoints, if definite integral.
378                 # Do not print empty endpoints.
379                 if len(lim) == 2:
380                     prettyA = prettyForm("")
381                     prettyB = self._print(lim[1])
382                 if len(lim) == 3:
383                     prettyA = self._print(lim[1])
384                     prettyB = self._print(lim[2])
385 
386                 if ascii_mode:  # XXX hack
387                     # Add spacing so that endpoint can more easily be
388                     # identified with the correct integral sign
389                     spc = max(1, 3 - prettyB.width())
390                     prettyB = prettyForm(*prettyB.left(' ' * spc))
391 
392                     spc = max(1, 4 - prettyA.width())
393                     prettyA = prettyForm(*prettyA.right(' ' * spc))
394 
395                 pform = prettyForm(*pform.above(prettyB))
396                 pform = prettyForm(*pform.below(prettyA))
397 
398             if not ascii_mode:  # XXX hack
399                 pform = prettyForm(*pform.right(' '))
400 
401             if firstterm:
402                 s = pform   # first term
403                 firstterm = False
404             else:
405                 s = prettyForm(*s.left(pform))
406 
407         pform = prettyForm(*arg.left(s))
408         pform.binding = prettyForm.MUL
409         return pform
410 
411     def _print_Product(self, expr):
412         func = expr.term
413         pretty_func = self._print(func)
414 
415         horizontal_chr = xobj('_', 1)
416         corner_chr = xobj('_', 1)
417         vertical_chr = xobj('|', 1)
418 
419         if self._use_unicode:
420             # use unicode corners
421             horizontal_chr = xobj('-', 1)
422             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
423 
424         func_height = pretty_func.height()
425 
426         first = True
427         max_upper = 0
428         sign_height = 0
429 
430         for lim in expr.limits:
431             width = (func_height + 2) * 5 // 3 - 2
432             sign_lines = []
433             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
434             for i in range(func_height + 1):
435                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
436 
437             pretty_sign = stringPict('')
438             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
439 
440             pretty_upper = self._print(lim[2])
441             pretty_lower = self._print(Equality(lim[0], lim[1]))
442 
443             max_upper = max(max_upper, pretty_upper.height())
444 
445             if first:
446                 sign_height = pretty_sign.height()
447 
448             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
449             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
450 
451             if first:
452                 pretty_func.baseline = 0
453                 first = False
454 
455             height = pretty_sign.height()
456             padding = stringPict('')
457             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
458             pretty_sign = prettyForm(*pretty_sign.right(padding))
459 
460             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
461 
462         pretty_func.baseline = max_upper + sign_height//2
463         pretty_func.binding = prettyForm.MUL
464         return pretty_func
465 
466     def _print_Sum(self, expr):
467         ascii_mode = not self._use_unicode
468 
469         def asum(hrequired, lower, upper, use_ascii):
470             def adjust(s, wid=None, how='<^>'):
471                 if not wid or len(s) > wid:
472                     return s
473                 need = wid - len(s)
474                 if how == '<^>' or how == "<" or how not in list('<^>'):
475                     return s + ' '*need
476                 half = need//2
477                 lead = ' '*half
478                 if how == ">":
479                     return " "*need + s
480                 return lead + s + ' '*(need - len(lead))
481 
482             h = max(hrequired, 2)
483             d = h//2
484             w = d + 1
485             more = hrequired % 2
486 
487             lines = []
488             if use_ascii:
489                 lines.append("_"*(w) + ' ')
490                 lines.append("\%s`" % (' '*(w - 1)))
491                 for i in range(1, d):
492                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
493                 if more:
494                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
495                 for i in reversed(range(1, d)):
496                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
497                 lines.append("/" + "_"*(w - 1) + ',')
498                 return d, h + more, lines, 0
499             else:
500                 w = w + more
501                 d = d + more
502                 vsum = vobj('sum', 4)
503                 lines.append("_"*(w))
504                 for i in range(0, d):
505                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
506                 for i in reversed(range(0, d)):
507                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
508                 lines.append(vsum[8]*(w))
509                 return d, h + 2*more, lines, more
510 
511         f = expr.function
512 
513         prettyF = self._print(f)
514 
515         if f.is_Add:  # add parens
516             prettyF = prettyForm(*prettyF.parens())
517 
518         H = prettyF.height() + 2
519 
520         # \sum \sum \sum ...
521         first = True
522         max_upper = 0
523         sign_height = 0
524 
525         for lim in expr.limits:
526             if len(lim) == 3:
527                 prettyUpper = self._print(lim[2])
528                 prettyLower = self._print(Equality(lim[0], lim[1]))
529             elif len(lim) == 2:
530                 prettyUpper = self._print("")
531                 prettyLower = self._print(Equality(lim[0], lim[1]))
532             elif len(lim) == 1:
533                 prettyUpper = self._print("")
534                 prettyLower = self._print(lim[0])
535 
536             max_upper = max(max_upper, prettyUpper.height())
537 
538             # Create sum sign based on the height of the argument
539             d, h, slines, adjustment = asum(
540                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
541             prettySign = stringPict('')
542             prettySign = prettyForm(*prettySign.stack(*slines))
543 
544             if first:
545                 sign_height = prettySign.height()
546 
547             prettySign = prettyForm(*prettySign.above(prettyUpper))
548             prettySign = prettyForm(*prettySign.below(prettyLower))
549 
550             if first:
551                 # change F baseline so it centers on the sign
552                 prettyF.baseline -= d - (prettyF.height()//2 -
553                                          prettyF.baseline) - adjustment
554                 first = False
555 
556             # put padding to the right
557             pad = stringPict('')
558             pad = prettyForm(*pad.stack(*[' ']*h))
559             prettySign = prettyForm(*prettySign.right(pad))
560             # put the present prettyF to the right
561             prettyF = prettyForm(*prettySign.right(prettyF))
562 
563         prettyF.baseline = max_upper + sign_height//2
564         prettyF.binding = prettyForm.MUL
565         return prettyF
566 
567     def _print_Limit(self, l):
568         e, z, z0, dir = l.args
569 
570         E = self._print(e)
571         if precedence(e) <= PRECEDENCE["Mul"]:
572             E = prettyForm(*E.parens('(', ')'))
573         Lim = prettyForm('lim')
574 
575         LimArg = self._print(z)
576         if self._use_unicode:
577             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
578         else:
579             LimArg = prettyForm(*LimArg.right('->'))
580         LimArg = prettyForm(*LimArg.right(self._print(z0)))
581 
582         if z0 in (S.Infinity, S.NegativeInfinity):
583             dir = ""
584         else:
585             if self._use_unicode:
586                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
587 
588         LimArg = prettyForm(*LimArg.right(self._print(dir)))
589 
590         Lim = prettyForm(*Lim.below(LimArg))
591         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
592 
593         return Lim
594 
595     def _print_matrix_contents(self, e):
596         """
597         This method factors out what is essentially grid printing.
598         """
599         M = e   # matrix
600         Ms = {}  # i,j -> pretty(M[i,j])
601         for i in range(M.rows):
602             for j in range(M.cols):
603                 Ms[i, j] = self._print(M[i, j])
604 
605         # h- and v- spacers
606         hsep = 2
607         vsep = 1
608 
609         # max width for columns
610         maxw = [-1] * M.cols
611 
612         for j in range(M.cols):
613             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
614 
615         # drawing result
616         D = None
617 
618         for i in range(M.rows):
619 
620             D_row = None
621             for j in range(M.cols):
622                 s = Ms[i, j]
623 
624                 # reshape s to maxw
625                 # XXX this should be generalized, and go to stringPict.reshape ?
626                 assert s.width() <= maxw[j]
627 
628                 # hcenter it, +0.5 to the right                        2
629                 # ( it's better to align formula starts for say 0 and r )
630                 # XXX this is not good in all cases -- maybe introduce vbaseline?
631                 wdelta = maxw[j] - s.width()
632                 wleft = wdelta // 2
633                 wright = wdelta - wleft
634 
635                 s = prettyForm(*s.right(' '*wright))
636                 s = prettyForm(*s.left(' '*wleft))
637 
638                 # we don't need vcenter cells -- this is automatically done in
639                 # a pretty way because when their baselines are taking into
640                 # account in .right()
641 
642                 if D_row is None:
643                     D_row = s   # first box in a row
644                     continue
645 
646                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
647                 D_row = prettyForm(*D_row.right(s))
648 
649             if D is None:
650                 D = D_row       # first row in a picture
651                 continue
652 
653             # v-spacer
654             for _ in range(vsep):
655                 D = prettyForm(*D.below(' '))
656 
657             D = prettyForm(*D.below(D_row))
658 
659         if D is None:
660             D = prettyForm('')  # Empty Matrix
661 
662         return D
663 
664     def _print_MatrixBase(self, e):
665         D = self._print_matrix_contents(e)
666         D = prettyForm(*D.parens('[', ']'))
667         return D
668     _print_ImmutableMatrix = _print_MatrixBase
669     _print_Matrix = _print_MatrixBase
670 
671     def _print_Trace(self, e):
672         D = self._print(e.arg)
673         D = prettyForm(*D.parens('(',')'))
674         D.baseline = D.height()//2
675         D = prettyForm(*D.left('\n'*(0) + 'tr'))
676         return D
677 
678 
679     def _print_MatrixElement(self, expr):
680         from sympy.matrices import MatrixSymbol
681         from sympy import Symbol
682         if (isinstance(expr.parent, MatrixSymbol)
683                 and expr.i.is_number and expr.j.is_number):
684             return self._print(
685                     Symbol(expr.parent.name + '_%d%d'%(expr.i, expr.j)))
686         else:
687             prettyFunc = self._print(expr.parent)
688             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
689                     ).parens(left='[', right=']')[0]
690             pform = prettyForm(binding=prettyForm.FUNC,
691                     *stringPict.next(prettyFunc, prettyIndices))
692 
693             # store pform parts so it can be reassembled e.g. when powered
694             pform.prettyFunc = prettyFunc
695             pform.prettyArgs = prettyIndices
696 
697             return pform
698 
699 
700     def _print_MatrixSlice(self, m):
701         # XXX works only for applied functions
702 
703         prettyFunc = self._print(m.parent)
704         def ppslice(x):
705             x = list(x)
706             if x[2] == 1:
707                 del x[2]
708             if x[1] == x[0] + 1:
709                 del x[1]
710             if x[0] == 0:
711                 x[0] = ''
712             return prettyForm(*self._print_seq(x, delimiter=':'))
713         prettyArgs = self._print_seq((ppslice(m.rowslice),
714             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
715 
716         pform = prettyForm(
717             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
718 
719         # store pform parts so it can be reassembled e.g. when powered
720         pform.prettyFunc = prettyFunc
721         pform.prettyArgs = prettyArgs
722 
723         return pform
724 
725     def _print_Transpose(self, expr):
726         pform = self._print(expr.arg)
727         from sympy.matrices import MatrixSymbol
728         if not isinstance(expr.arg, MatrixSymbol):
729             pform = prettyForm(*pform.parens())
730         pform = pform**(prettyForm('T'))
731         return pform
732 
733     def _print_Adjoint(self, expr):
734         pform = self._print(expr.arg)
735         if self._use_unicode:
736             dag = prettyForm(u'\N{DAGGER}')
737         else:
738             dag = prettyForm('+')
739         from sympy.matrices import MatrixSymbol
740         if not isinstance(expr.arg, MatrixSymbol):
741             pform = prettyForm(*pform.parens())
742         pform = pform**dag
743         return pform
744 
745     def _print_BlockMatrix(self, B):
746         if B.blocks.shape == (1, 1):
747             return self._print(B.blocks[0, 0])
748         return self._print(B.blocks)
749 
750     def _print_MatAdd(self, expr):
751         return self._print_seq(expr.args, None, None, ' + ')
752 
753     def _print_MatMul(self, expr):
754         args = list(expr.args)
755         from sympy import Add, MatAdd, HadamardProduct
756         for i, a in enumerate(args):
757             if (isinstance(a, (Add, MatAdd, HadamardProduct))
758                     and len(expr.args) > 1):
759                 args[i] = prettyForm(*self._print(a).parens())
760             else:
761                 args[i] = self._print(a)
762 
763         return prettyForm.__mul__(*args)
764 
765     def _print_DotProduct(self, expr):
766         args = list(expr.args)
767 
768         for i, a in enumerate(args):
769             args[i] = self._print(a)
770         return prettyForm.__mul__(*args)
771 
772     def _print_MatPow(self, expr):
773         pform = self._print(expr.base)
774         from sympy.matrices import MatrixSymbol
775         if not isinstance(expr.base, MatrixSymbol):
776             pform = prettyForm(*pform.parens())
777         pform = pform**(self._print(expr.exp))
778         return pform
779 
780     def _print_HadamardProduct(self, expr):
781         from sympy import MatAdd, MatMul
782         if self._use_unicode:
783             delim = pretty_atom('Ring')
784         else:
785             delim = '.*'
786         return self._print_seq(expr.args, None, None, delim,
787                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
788 
789     _print_MatrixSymbol = _print_Symbol
790 
791     def _print_FunctionMatrix(self, X):
792         D = self._print(X.lamda.expr)
793         D = prettyForm(*D.parens('[', ']'))
794         return D
795 
796     def _print_BasisDependent(self, expr):
797         from sympy.vector import Vector
798 
799         if not self._use_unicode:
800             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
801 
802         if expr == expr.zero:
803             return prettyForm(expr.zero._pretty_form)
804         o1 = []
805         vectstrs = []
806         if isinstance(expr, Vector):
807             items = expr.separate().items()
808         else:
809             items = [(0, expr)]
810         for system, vect in items:
811             inneritems = list(vect.components.items())
812             inneritems.sort(key = lambda x: x[0].__str__())
813             for k, v in inneritems:
814                 #if the coef of the basis vector is 1
815                 #we skip the 1
816                 if v == 1:
817                     o1.append(u"" +
818                               k._pretty_form)
819                 #Same for -1
820                 elif v == -1:
821                     o1.append(u"(-1) " +
822                               k._pretty_form)
823                 #For a general expr
824                 else:
825                     #We always wrap the measure numbers in
826                     #parentheses
827                     arg_str = self._print(
828                         v).parens()[0]
829 
830                     o1.append(arg_str + ' ' + k._pretty_form)
831                 vectstrs.append(k._pretty_form)
832 
833         #outstr = u("").join(o1)
834         if o1[0].startswith(u" + "):
835             o1[0] = o1[0][3:]
836         elif o1[0].startswith(" "):
837             o1[0] = o1[0][1:]
838         #Fixing the newlines
839         lengths = []
840         strs = ['']
841         for i, partstr in enumerate(o1):
842             # XXX: What is this hack?
843             if '\n' in partstr:
844                 tempstr = partstr
845                 tempstr = tempstr.replace(vectstrs[i], '')
846                 tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
847                                           u'\N{RIGHT PARENTHESIS UPPER HOOK}'
848                                           + ' ' + vectstrs[i])
849                 o1[i] = tempstr
850         o1 = [x.split('\n') for x in o1]
851         n_newlines = max([len(x) for x in o1])
852         for parts in o1:
853             lengths.append(len(parts[0]))
854             for j in range(n_newlines):
855                 if j+1 <= len(parts):
856                     if j >= len(strs):
857                         strs.append(' ' * (sum(lengths[:-1]) +
858                                            3*(len(lengths)-1)))
859                     if j == 0:
860                         strs[0] += parts[0] + ' + '
861                     else:
862                         strs[j] += parts[j] + ' '*(lengths[-1] -
863                                                    len(parts[j])+
864                                                    3)
865                 else:
866                     if j >= len(strs):
867                         strs.append(' ' * (sum(lengths[:-1]) +
868                                            3*(len(lengths)-1)))
869                     strs[j] += ' '*(lengths[-1]+3)
870 
871         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
872 
873     def _print_NDimArray(self, expr):
874         from sympy import ImmutableMatrix
875 
876         if expr.rank() == 0:
877             return self._print_matrix_contents(expr.tomatrix())
878 
879         level_str = [[]] + [[] for i in range(expr.rank())]
880         shape_ranges = [list(range(i)) for i in expr.shape]
881         for outer_i in itertools.product(*shape_ranges):
882             level_str[-1].append(expr[outer_i])
883             even = True
884             for back_outer_i in range(expr.rank()-1, -1, -1):
885                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
886                     break
887                 if even:
888                     level_str[back_outer_i].append(level_str[back_outer_i+1])
889                 else:
890                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
891                     if len(level_str[back_outer_i + 1]) == 1:
892                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
893                 even = not even
894                 level_str[back_outer_i+1] = []
895 
896         out_expr = level_str[0][0]
897         if expr.rank() % 2 == 1:
898             out_expr = ImmutableMatrix([out_expr])
899 
900         return self._print(out_expr)
901 
902     _print_ImmutableDenseNDimArray = _print_NDimArray
903     _print_ImmutableSparseNDimArray = _print_NDimArray
904     _print_MutableDenseNDimArray = _print_NDimArray
905     _print_MutableSparseNDimArray = _print_NDimArray
906 
907     def _print_Piecewise(self, pexpr):
908 
909         P = {}
910         for n, ec in enumerate(pexpr.args):
911             P[n, 0] = self._print(ec.expr)
912             if ec.cond == True:
913                 P[n, 1] = prettyForm('otherwise')
914             else:
915                 P[n, 1] = prettyForm(
916                     *prettyForm('for ').right(self._print(ec.cond)))
917         hsep = 2
918         vsep = 1
919         len_args = len(pexpr.args)
920 
921         # max widths
922         maxw = [max([P[i, j].width() for i in range(len_args)])
923                 for j in range(2)]
924 
925         # FIXME: Refactor this code and matrix into some tabular environment.
926         # drawing result
927         D = None
928 
929         for i in range(len_args):
930             D_row = None
931             for j in range(2):
932                 p = P[i, j]
933                 assert p.width() <= maxw[j]
934 
935                 wdelta = maxw[j] - p.width()
936                 wleft = wdelta // 2
937                 wright = wdelta - wleft
938 
939                 p = prettyForm(*p.right(' '*wright))
940                 p = prettyForm(*p.left(' '*wleft))
941 
942                 if D_row is None:
943                     D_row = p
944                     continue
945 
946                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
947                 D_row = prettyForm(*D_row.right(p))
948             if D is None:
949                 D = D_row       # first row in a picture
950                 continue
951 
952             # v-spacer
953             for _ in range(vsep):
954                 D = prettyForm(*D.below(' '))
955 
956             D = prettyForm(*D.below(D_row))
957 
958         D = prettyForm(*D.parens('{', ''))
959         D.baseline = D.height()//2
960         D.binding = prettyForm.OPEN
961         return D
962 
963     def _hprint_vec(self, v):
964         D = None
965 
966         for a in v:
967             p = a
968             if D is None:
969                 D = p
970             else:
971                 D = prettyForm(*D.right(', '))
972                 D = prettyForm(*D.right(p))
973         if D is None:
974             D = stringPict(' ')
975 
976         return D
977 
978     def _hprint_vseparator(self, p1, p2):
979         tmp = prettyForm(*p1.right(p2))
980         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
981         return prettyForm(*p1.right(sep, p2))
982 
983     def _print_hyper(self, e):
984         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
985         ap = [self._print(a) for a in e.ap]
986         bq = [self._print(b) for b in e.bq]
987 
988         P = self._print(e.argument)
989         P.baseline = P.height()//2
990 
991         # Drawing result - first create the ap, bq vectors
992         D = None
993         for v in [ap, bq]:
994             D_row = self._hprint_vec(v)
995             if D is None:
996                 D = D_row       # first row in a picture
997             else:
998                 D = prettyForm(*D.below(' '))
999                 D = prettyForm(*D.below(D_row))
1000 
1001         # make sure that the argument `z' is centred vertically
1002         D.baseline = D.height()//2
1003 
1004         # insert horizontal separator
1005         P = prettyForm(*P.left(' '))
1006         D = prettyForm(*D.right(' '))
1007 
1008         # insert separating `|`
1009         D = self._hprint_vseparator(D, P)
1010 
1011         # add parens
1012         D = prettyForm(*D.parens('(', ')'))
1013 
1014         # create the F symbol
1015         above = D.height()//2 - 1
1016         below = D.height() - above - 1
1017 
1018         sz, t, b, add, img = annotated('F')
1019         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1020                        baseline=above + sz)
1021         add = (sz + 1)//2
1022 
1023         F = prettyForm(*F.left(self._print(len(e.ap))))
1024         F = prettyForm(*F.right(self._print(len(e.bq))))
1025         F.baseline = above + add
1026 
1027         D = prettyForm(*F.right(' ', D))
1028 
1029         return D
1030 
1031     def _print_meijerg(self, e):
1032         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1033 
1034         v = {}
1035         v[(0, 0)] = [self._print(a) for a in e.an]
1036         v[(0, 1)] = [self._print(a) for a in e.aother]
1037         v[(1, 0)] = [self._print(b) for b in e.bm]
1038         v[(1, 1)] = [self._print(b) for b in e.bother]
1039 
1040         P = self._print(e.argument)
1041         P.baseline = P.height()//2
1042 
1043         vp = {}
1044         for idx in v:
1045             vp[idx] = self._hprint_vec(v[idx])
1046 
1047         for i in range(2):
1048             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1049             for j in range(2):
1050                 s = vp[(j, i)]
1051                 left = (maxw - s.width()) // 2
1052                 right = maxw - left - s.width()
1053                 s = prettyForm(*s.left(' ' * left))
1054                 s = prettyForm(*s.right(' ' * right))
1055                 vp[(j, i)] = s
1056 
1057         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1058         D1 = prettyForm(*D1.below(' '))
1059         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1060         D = prettyForm(*D1.below(D2))
1061 
1062         # make sure that the argument `z' is centred vertically
1063         D.baseline = D.height()//2
1064 
1065         # insert horizontal separator
1066         P = prettyForm(*P.left(' '))
1067         D = prettyForm(*D.right(' '))
1068 
1069         # insert separating `|`
1070         D = self._hprint_vseparator(D, P)
1071 
1072         # add parens
1073         D = prettyForm(*D.parens('(', ')'))
1074 
1075         # create the G symbol
1076         above = D.height()//2 - 1
1077         below = D.height() - above - 1
1078 
1079         sz, t, b, add, img = annotated('G')
1080         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1081                        baseline=above + sz)
1082 
1083         pp = self._print(len(e.ap))
1084         pq = self._print(len(e.bq))
1085         pm = self._print(len(e.bm))
1086         pn = self._print(len(e.an))
1087 
1088         def adjust(p1, p2):
1089             diff = p1.width() - p2.width()
1090             if diff == 0:
1091                 return p1, p2
1092             elif diff > 0:
1093                 return p1, prettyForm(*p2.left(' '*diff))
1094             else:
1095                 return prettyForm(*p1.left(' '*-diff)), p2
1096         pp, pm = adjust(pp, pm)
1097         pq, pn = adjust(pq, pn)
1098         pu = prettyForm(*pm.right(', ', pn))
1099         pl = prettyForm(*pp.right(', ', pq))
1100 
1101         ht = F.baseline - above - 2
1102         if ht > 0:
1103             pu = prettyForm(*pu.below('\n'*ht))
1104         p = prettyForm(*pu.below(pl))
1105 
1106         F.baseline = above
1107         F = prettyForm(*F.right(p))
1108 
1109         F.baseline = above + add
1110 
1111         D = prettyForm(*F.right(' ', D))
1112 
1113         return D
1114 
1115     def _print_ExpBase(self, e):
1116         # TODO should exp_polar be printed differently?
1117         #      what about exp_polar(0), exp_polar(1)?
1118         base = prettyForm(pretty_atom('Exp1', 'e'))
1119         return base ** self._print(e.args[0])
1120 
1121     def _print_Function(self, e, sort=False):
1122         # XXX works only for applied functions
1123         func = e.func
1124         args = e.args
1125         if sort:
1126             args = sorted(args, key=default_sort_key)
1127 
1128         func_name = func.__name__
1129 
1130         prettyFunc = self._print(Symbol(func_name))
1131         prettyArgs = prettyForm(*self._print_seq(args).parens())
1132 
1133         pform = prettyForm(
1134             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1135 
1136         # store pform parts so it can be reassembled e.g. when powered
1137         pform.prettyFunc = prettyFunc
1138         pform.prettyArgs = prettyArgs
1139 
1140         return pform
1141 
1142     def _print_GeometryEntity(self, expr):
1143         # GeometryEntity is based on Tuple but should not print like a Tuple
1144         return self.emptyPrinter(expr)
1145 
1146     def _print_Lambda(self, e):
1147         vars, expr = e.args
1148         if self._use_unicode:
1149             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1150         else:
1151             arrow = " -> "
1152         if len(vars) == 1:
1153             var_form = self._print(vars[0])
1154         else:
1155             var_form = self._print(tuple(vars))
1156 
1157         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1158 
1159     def _print_Order(self, expr):
1160         pform = self._print(expr.expr)
1161         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1162            len(expr.variables) > 1:
1163             pform = prettyForm(*pform.right("; "))
1164             if len(expr.variables) > 1:
1165                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1166             elif len(expr.variables):
1167                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1168             if self._use_unicode:
1169                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1170             else:
1171                 pform = prettyForm(*pform.right(" -> "))
1172             if len(expr.point) > 1:
1173                 pform = prettyForm(*pform.right(self._print(expr.point)))
1174             else:
1175                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1176         pform = prettyForm(*pform.parens())
1177         pform = prettyForm(*pform.left("O"))
1178         return pform
1179 
1180     def _print_SingularityFunction(self, e):
1181         if self._use_unicode:
1182             shift = self._print(e.args[0]-e.args[1])
1183             n = self._print(e.args[2])
1184             base = prettyForm("<")
1185             base = prettyForm(*base.right(shift))
1186             base = prettyForm(*base.right(">"))
1187             pform = base**n
1188             return pform
1189         else:
1190             n = self._print(e.args[2])
1191             shift = self._print(e.args[0]-e.args[1])
1192             base = self._print_seq(shift, "<", ">", ' ')
1193             return base**n
1194 
1195     def _print_gamma(self, e):
1196         if self._use_unicode:
1197             pform = self._print(e.args[0])
1198             pform = prettyForm(*pform.parens())
1199             pform = prettyForm(*pform.left(greek_unicode['Gamma']))
1200             return pform
1201         else:
1202             return self._print_Function(e)
1203 
1204     def _print_uppergamma(self, e):
1205         if self._use_unicode:
1206             pform = self._print(e.args[0])
1207             pform = prettyForm(*pform.right(', ', self._print(e.args[1])))
1208             pform = prettyForm(*pform.parens())
1209             pform = prettyForm(*pform.left(greek_unicode['Gamma']))
1210             return pform
1211         else:
1212             return self._print_Function(e)
1213 
1214     def _print_lowergamma(self, e):
1215         if self._use_unicode:
1216             pform = self._print(e.args[0])
1217             pform = prettyForm(*pform.right(', ', self._print(e.args[1])))
1218             pform = prettyForm(*pform.parens())
1219             pform = prettyForm(*pform.left(greek_unicode['gamma']))
1220             return pform
1221         else:
1222             return self._print_Function(e)
1223 
1224     def _print_DiracDelta(self, e):
1225         if self._use_unicode:
1226             if len(e.args) == 2:
1227                 a = prettyForm(greek_unicode['delta'])
1228                 b = self._print(e.args[1])
1229                 b = prettyForm(*b.parens())
1230                 c = self._print(e.args[0])
1231                 c = prettyForm(*c.parens())
1232                 pform = a**b
1233                 pform = stringPict(*pform.right(' '))
1234                 pform = stringPict(*pform.right(c))
1235                 return pform
1236             pform = self._print(e.args[0])
1237             pform = prettyForm(*pform.parens())
1238             pform = prettyForm(*pform.left(greek_unicode['delta']))
1239             return pform
1240         else:
1241             return self._print_Function(e)
1242 
1243     def _print_expint(self, e):
1244         from sympy import Function
1245         if e.args[0].is_Integer and self._use_unicode:
1246             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1247         return self._print_Function(e)
1248 
1249     def _print_Chi(self, e):
1250         # This needs a special case since otherwise it comes out as greek
1251         # letter chi...
1252         prettyFunc = prettyForm("Chi")
1253         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1254 
1255         pform = prettyForm(
1256             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1257 
1258         # store pform parts so it can be reassembled e.g. when powered
1259         pform.prettyFunc = prettyFunc
1260         pform.prettyArgs = prettyArgs
1261 
1262         return pform
1263 
1264     def _print_elliptic_e(self, e):
1265         pforma0 = self._print(e.args[0])
1266         if len(e.args) == 1:
1267             pform = pforma0
1268         else:
1269             pforma1 = self._print(e.args[1])
1270             pform = self._hprint_vseparator(pforma0, pforma1)
1271         pform = prettyForm(*pform.parens())
1272         pform = prettyForm(*pform.left('E'))
1273         return pform
1274 
1275     def _print_elliptic_k(self, e):
1276         pform = self._print(e.args[0])
1277         pform = prettyForm(*pform.parens())
1278         pform = prettyForm(*pform.left('K'))
1279         return pform
1280 
1281     def _print_elliptic_f(self, e):
1282         pforma0 = self._print(e.args[0])
1283         pforma1 = self._print(e.args[1])
1284         pform = self._hprint_vseparator(pforma0, pforma1)
1285         pform = prettyForm(*pform.parens())
1286         pform = prettyForm(*pform.left('F'))
1287         return pform
1288 
1289     def _print_elliptic_pi(self, e):
1290         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1291         pforma0 = self._print(e.args[0])
1292         pforma1 = self._print(e.args[1])
1293         if len(e.args) == 2:
1294             pform = self._hprint_vseparator(pforma0, pforma1)
1295         else:
1296             pforma2 = self._print(e.args[2])
1297             pforma = self._hprint_vseparator(pforma1, pforma2)
1298             pforma = prettyForm(*pforma.left('; '))
1299             pform = prettyForm(*pforma.left(pforma0))
1300         pform = prettyForm(*pform.parens())
1301         pform = prettyForm(*pform.left(name))
1302         return pform
1303 
1304     def _print_GoldenRatio(self, expr):
1305         if self._use_unicode:
1306             return prettyForm(pretty_symbol('phi'))
1307         return self._print(Symbol("GoldenRatio"))
1308 
1309     def _print_EulerGamma(self, expr):
1310         if self._use_unicode:
1311             return prettyForm(pretty_symbol('gamma'))
1312         return self._print(Symbol("EulerGamma"))
1313 
1314     def _print_Mod(self, expr):
1315         pform = self._print(expr.args[0])
1316         if pform.binding > prettyForm.MUL:
1317             pform = prettyForm(*pform.parens())
1318         pform = prettyForm(*pform.right(' mod '))
1319         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1320         pform.binding = prettyForm.OPEN
1321         return pform
1322 
1323     def _print_Add(self, expr, order=None):
1324         if self.order == 'none':
1325             terms = list(expr.args)
1326         else:
1327             terms = self._as_ordered_terms(expr, order=order)
1328         pforms, indices = [], []
1329 
1330         def pretty_negative(pform, index):
1331             """Prepend a minus sign to a pretty form. """
1332             #TODO: Move this code to prettyForm
1333             if index == 0:
1334                 if pform.height() > 1:
1335                     pform_neg = '- '
1336                 else:
1337                     pform_neg = '-'
1338             else:
1339                 pform_neg = ' - '
1340 
1341             if pform.binding > prettyForm.NEG:
1342                 p = stringPict(*pform.parens())
1343             else:
1344                 p = pform
1345             p = stringPict.next(pform_neg, p)
1346             # Lower the binding to NEG, even if it was higher. Otherwise, it
1347             # will print as a + ( - (b)), instead of a - (b).
1348             return prettyForm(binding=prettyForm.NEG, *p)
1349 
1350         for i, term in enumerate(terms):
1351             if term.is_Mul and _coeff_isneg(term):
1352                 coeff, other = term.as_coeff_mul(rational=False)
1353                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1354                 pforms.append(pretty_negative(pform, i))
1355             elif term.is_Rational and term.q > 1:
1356                 pforms.append(None)
1357                 indices.append(i)
1358             elif term.is_Number and term < 0:
1359                 pform = self._print(-term)
1360                 pforms.append(pretty_negative(pform, i))
1361             elif term.is_Relational:
1362                 pforms.append(prettyForm(*self._print(term).parens()))
1363             else:
1364                 pforms.append(self._print(term))
1365 
1366         if indices:
1367             large = True
1368 
1369             for pform in pforms:
1370                 if pform is not None and pform.height() > 1:
1371                     break
1372             else:
1373                 large = False
1374 
1375             for i in indices:
1376                 term, negative = terms[i], False
1377 
1378                 if term < 0:
1379                     term, negative = -term, True
1380 
1381                 if large:
1382                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1383                 else:
1384                     pform = self._print(term)
1385 
1386                 if negative:
1387                     pform = pretty_negative(pform, i)
1388 
1389                 pforms[i] = pform
1390 
1391         return prettyForm.__add__(*pforms)
1392 
1393     def _print_Mul(self, product):
1394         a = []  # items in the numerator
1395         b = []  # items that are in the denominator (if any)
1396 
1397         if self.order not in ('old', 'none'):
1398             args = product.as_ordered_factors()
1399         else:
1400             args = product.args
1401 
1402         # Gather terms for numerator/denominator
1403         for item in args:
1404             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1405                 if item.exp != -1:
1406                     b.append(Pow(item.base, -item.exp, evaluate=False))
1407                 else:
1408                     b.append(Pow(item.base, -item.exp))
1409             elif item.is_Rational and item is not S.Infinity:
1410                 if item.p != 1:
1411                     a.append( Rational(item.p) )
1412                 if item.q != 1:
1413                     b.append( Rational(item.q) )
1414             else:
1415                 a.append(item)
1416 
1417         from sympy import Integral, Piecewise, Product, Sum
1418 
1419         # Convert to pretty forms. Add parens to Add instances if there
1420         # is more than one term in the numer/denom
1421         for i in range(0, len(a)):
1422             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1423                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1424                 a[i] = prettyForm(*self._print(a[i]).parens())
1425             elif a[i].is_Relational:
1426                 a[i] = prettyForm(*self._print(a[i]).parens())
1427             else:
1428                 a[i] = self._print(a[i])
1429 
1430         for i in range(0, len(b)):
1431             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1432                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1433                 b[i] = prettyForm(*self._print(b[i]).parens())
1434             else:
1435                 b[i] = self._print(b[i])
1436 
1437         # Construct a pretty form
1438         if len(b) == 0:
1439             return prettyForm.__mul__(*a)
1440         else:
1441             if len(a) == 0:
1442                 a.append( self._print(S.One) )
1443             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1444 
1445     # A helper function for _print_Pow to print x**(1/n)
1446     def _print_nth_root(self, base, expt):
1447         bpretty = self._print(base)
1448 
1449         # In very simple cases, use a single-char root sign
1450         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1451             and expt is S.Half and bpretty.height() == 1
1452             and (bpretty.width() == 1
1453                  or (base.is_Integer and base.is_nonnegative))):
1454             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1455 
1456         # Construct root sign, start with the \/ shape
1457         _zZ = xobj('/', 1)
1458         rootsign = xobj('\\', 1) + _zZ
1459         # Make exponent number to put above it
1460         if isinstance(expt, Rational):
1461             exp = str(expt.q)
1462             if exp == '2':
1463                 exp = ''
1464         else:
1465             exp = str(expt.args[0])
1466         exp = exp.ljust(2)
1467         if len(exp) > 2:
1468             rootsign = ' '*(len(exp) - 2) + rootsign
1469         # Stack the exponent
1470         rootsign = stringPict(exp + '\n' + rootsign)
1471         rootsign.baseline = 0
1472         # Diagonal: length is one less than height of base
1473         linelength = bpretty.height() - 1
1474         diagonal = stringPict('\n'.join(
1475             ' '*(linelength - i - 1) + _zZ + ' '*i
1476             for i in range(linelength)
1477         ))
1478         # Put baseline just below lowest line: next to exp
1479         diagonal.baseline = linelength - 1
1480         # Make the root symbol
1481         rootsign = prettyForm(*rootsign.right(diagonal))
1482         # Det the baseline to match contents to fix the height
1483         # but if the height of bpretty is one, the rootsign must be one higher
1484         rootsign.baseline = max(1, bpretty.baseline)
1485         #build result
1486         s = prettyForm(hobj('_', 2 + bpretty.width()))
1487         s = prettyForm(*bpretty.above(s))
1488         s = prettyForm(*s.left(rootsign))
1489         return s
1490 
1491     def _print_Pow(self, power):
1492         from sympy.simplify.simplify import fraction
1493         b, e = power.as_base_exp()
1494         if power.is_commutative:
1495             if e is S.NegativeOne:
1496                 return prettyForm("1")/self._print(b)
1497             n, d = fraction(e)
1498             if n is S.One and d.is_Atom and not e.is_Integer:
1499                 return self._print_nth_root(b, e)
1500             if e.is_Rational and e < 0:
1501                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1502 
1503         if b.is_Relational:
1504             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1505 
1506         return self._print(b)**self._print(e)
1507 
1508     def _print_UnevaluatedExpr(self, expr):
1509         return self._print(expr.args[0])
1510 
1511     def __print_numer_denom(self, p, q):
1512         if q == 1:
1513             if p < 0:
1514                 return prettyForm(str(p), binding=prettyForm.NEG)
1515             else:
1516                 return prettyForm(str(p))
1517         elif abs(p) >= 10 and abs(q) >= 10:
1518             # If more than one digit in numer and denom, print larger fraction
1519             if p < 0:
1520                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1521                 # Old printing method:
1522                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1523                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1524             else:
1525                 return prettyForm(str(p))/prettyForm(str(q))
1526         else:
1527             return None
1528 
1529     def _print_Rational(self, expr):
1530         result = self.__print_numer_denom(expr.p, expr.q)
1531 
1532         if result is not None:
1533             return result
1534         else:
1535             return self.emptyPrinter(expr)
1536 
1537     def _print_Fraction(self, expr):
1538         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1539 
1540         if result is not None:
1541             return result
1542         else:
1543             return self.emptyPrinter(expr)
1544 
1545     def _print_ProductSet(self, p):
1546         if len(p.sets) > 1 and not has_variety(p.sets):
1547             from sympy import Pow
1548             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1549         else:
1550             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1551             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1552                                    parenthesize=lambda set: set.is_Union or
1553                                    set.is_Intersection or set.is_ProductSet)
1554 
1555     def _print_FiniteSet(self, s):
1556         items = sorted(s.args, key=default_sort_key)
1557         return self._print_seq(items, '{', '}', ', ' )
1558 
1559     def _print_Range(self, s):
1560 
1561         if self._use_unicode:
1562             dots = u"\N{HORIZONTAL ELLIPSIS}"
1563         else:
1564             dots = '...'
1565 
1566         if s.start.is_infinite:
1567             printset = s.start, dots, s[-1] - s.step, s[-1]
1568         elif s.stop.is_infinite or len(s) > 4:
1569             it = iter(s)
1570             printset = next(it), next(it), dots, s[-1]
1571         else:
1572             printset = tuple(s)
1573 
1574         return self._print_seq(printset, '{', '}', ', ' )
1575 
1576     def _print_Interval(self, i):
1577         if i.start == i.end:
1578             return self._print_seq(i.args[:1], '{', '}')
1579 
1580         else:
1581             if i.left_open:
1582                 left = '('
1583             else:
1584                 left = '['
1585 
1586             if i.right_open:
1587                 right = ')'
1588             else:
1589                 right = ']'
1590 
1591             return self._print_seq(i.args[:2], left, right)
1592 
1593     def _print_AccumuBounds(self, i):
1594         left = '<'
1595         right = '>'
1596 
1597         return self._print_seq(i.args[:2], left, right)
1598 
1599     def _print_Intersection(self, u):
1600 
1601         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1602 
1603         return self._print_seq(u.args, None, None, delimiter,
1604                                parenthesize=lambda set: set.is_ProductSet or
1605                                set.is_Union or set.is_Complement)
1606 
1607     def _print_Union(self, u):
1608 
1609         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1610 
1611         return self._print_seq(u.args, None, None, union_delimiter,
1612                                parenthesize=lambda set: set.is_ProductSet or
1613                                set.is_Intersection or set.is_Complement)
1614 
1615     def _print_SymmetricDifference(self, u):
1616         if not self._use_unicode:
1617             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1618 
1619         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1620 
1621         return self._print_seq(u.args, None, None, sym_delimeter)
1622 
1623     def _print_Complement(self, u):
1624 
1625         delimiter = ' \ '
1626 
1627         return self._print_seq(u.args, None, None, delimiter,
1628              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1629                                or set.is_Union)
1630 
1631     def _print_ImageSet(self, ts):
1632         if self._use_unicode:
1633             inn = u"\N{SMALL ELEMENT OF}"
1634         else:
1635             inn = 'in'
1636         variables = self._print_seq(ts.lamda.variables)
1637         expr = self._print(ts.lamda.expr)
1638         bar = self._print("|")
1639         base = self._print(ts.base_set)
1640 
1641         return self._print_seq((expr, bar, variables, inn, base), "{", "}", ' ')
1642 
1643     def _print_ConditionSet(self, ts):
1644         if self._use_unicode:
1645             inn = u"\N{SMALL ELEMENT OF}"
1646             # using _and because and is a keyword and it is bad practice to
1647             # overwrite them
1648             _and = u"\N{LOGICAL AND}"
1649         else:
1650             inn = 'in'
1651             _and = 'and'
1652 
1653         variables = self._print_seq(Tuple(ts.sym))
1654         try:
1655             cond = self._print(ts.condition.as_expr())
1656         except AttributeError:
1657             cond = self._print(ts.condition)
1658             if self._use_unicode:
1659                 cond = self._print_seq(cond, "(", ")")
1660 
1661         bar = self._print("|")
1662         base = self._print(ts.base_set)
1663 
1664         return self._print_seq((variables, bar, variables, inn,
1665                                 base, _and, cond), "{", "}", ' ')
1666 
1667     def _print_ComplexRegion(self, ts):
1668         if self._use_unicode:
1669             inn = u"\N{SMALL ELEMENT OF}"
1670         else:
1671             inn = 'in'
1672         variables = self._print_seq(ts.variables)
1673         expr = self._print(ts.expr)
1674         bar = self._print("|")
1675         prodsets = self._print(ts.sets)
1676 
1677         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1678 
1679     def _print_Contains(self, e):
1680         var, set = e.args
1681         if self._use_unicode:
1682             el = u" \N{ELEMENT OF} "
1683             return prettyForm(*stringPict.next(self._print(var),
1684                                                el, self._print(set)), binding=8)
1685         else:
1686             return prettyForm(sstr(e))
1687 
1688     def _print_FourierSeries(self, s):
1689         if self._use_unicode:
1690             dots = u"\N{HORIZONTAL ELLIPSIS}"
1691         else:
1692             dots = '...'
1693         return self._print_Add(s.truncate()) + self._print(dots)
1694 
1695     def _print_FormalPowerSeries(self, s):
1696         return self._print_Add(s.infinite)
1697 
1698     def _print_SeqFormula(self, s):
1699         if self._use_unicode:
1700             dots = u"\N{HORIZONTAL ELLIPSIS}"
1701         else:
1702             dots = '...'
1703 
1704         if s.start is S.NegativeInfinity:
1705             stop = s.stop
1706             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1707                 s.coeff(stop - 1), s.coeff(stop))
1708         elif s.stop is S.Infinity or s.length > 4:
1709             printset = s[:4]
1710             printset.append(dots)
1711             printset = tuple(printset)
1712         else:
1713             printset = tuple(s)
1714         return self._print_list(printset)
1715 
1716     _print_SeqPer = _print_SeqFormula
1717     _print_SeqAdd = _print_SeqFormula
1718     _print_SeqMul = _print_SeqFormula
1719 
1720     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1721             parenthesize=lambda x: False):
1722         s = None
1723 
1724         for item in seq:
1725             pform = self._print(item)
1726 
1727             if parenthesize(item):
1728                 pform = prettyForm(*pform.parens())
1729             if s is None:
1730                 # first element
1731                 s = pform
1732             else:
1733                 s = prettyForm(*stringPict.next(s, delimiter))
1734                 s = prettyForm(*stringPict.next(s, pform))
1735 
1736         if s is None:
1737             s = stringPict('')
1738 
1739         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
1740         return s
1741 
1742     def join(self, delimiter, args):
1743         pform = None
1744 
1745         for arg in args:
1746             if pform is None:
1747                 pform = arg
1748             else:
1749                 pform = prettyForm(*pform.right(delimiter))
1750                 pform = prettyForm(*pform.right(arg))
1751 
1752         if pform is None:
1753             return prettyForm("")
1754         else:
1755             return pform
1756 
1757     def _print_list(self, l):
1758         return self._print_seq(l, '[', ']')
1759 
1760     def _print_tuple(self, t):
1761         if len(t) == 1:
1762             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
1763             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
1764         else:
1765             return self._print_seq(t, '(', ')')
1766 
1767     def _print_Tuple(self, expr):
1768         return self._print_tuple(expr)
1769 
1770     def _print_dict(self, d):
1771         keys = sorted(d.keys(), key=default_sort_key)
1772         items = []
1773 
1774         for k in keys:
1775             K = self._print(k)
1776             V = self._print(d[k])
1777             s = prettyForm(*stringPict.next(K, ': ', V))
1778 
1779             items.append(s)
1780 
1781         return self._print_seq(items, '{', '}')
1782 
1783     def _print_Dict(self, d):
1784         return self._print_dict(d)
1785 
1786     def _print_set(self, s):
1787         items = sorted(s, key=default_sort_key)
1788         pretty = self._print_seq(items, '[', ']')
1789         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
1790         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
1791         return pretty
1792 
1793     _print_frozenset = _print_set
1794 
1795     def _print_PolyRing(self, ring):
1796         return prettyForm(sstr(ring))
1797 
1798     def _print_FracField(self, field):
1799         return prettyForm(sstr(field))
1800 
1801     def _print_FreeGroupElement(self, elm):
1802         return prettyForm(str(elm))
1803 
1804     def _print_PolyElement(self, poly):
1805         return prettyForm(sstr(poly))
1806 
1807     def _print_FracElement(self, frac):
1808         return prettyForm(sstr(frac))
1809 
1810     def _print_AlgebraicNumber(self, expr):
1811         if expr.is_aliased:
1812             return self._print(expr.as_poly().as_expr())
1813         else:
1814             return self._print(expr.as_expr())
1815 
1816     def _print_ComplexRootOf(self, expr):
1817         args = [self._print_Add(expr.expr, order='lex'), expr.index]
1818         pform = prettyForm(*self._print_seq(args).parens())
1819         pform = prettyForm(*pform.left('CRootOf'))
1820         return pform
1821 
1822     def _print_RootSum(self, expr):
1823         args = [self._print_Add(expr.expr, order='lex')]
1824 
1825         if expr.fun is not S.IdentityFunction:
1826             args.append(self._print(expr.fun))
1827 
1828         pform = prettyForm(*self._print_seq(args).parens())
1829         pform = prettyForm(*pform.left('RootSum'))
1830 
1831         return pform
1832 
1833     def _print_FiniteField(self, expr):
1834         if self._use_unicode:
1835             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
1836         else:
1837             form = 'GF(%d)'
1838 
1839         return prettyForm(pretty_symbol(form % expr.mod))
1840 
1841     def _print_IntegerRing(self, expr):
1842         if self._use_unicode:
1843             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
1844         else:
1845             return prettyForm('ZZ')
1846 
1847     def _print_RationalField(self, expr):
1848         if self._use_unicode:
1849             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
1850         else:
1851             return prettyForm('QQ')
1852 
1853     def _print_RealField(self, domain):
1854         if self._use_unicode:
1855             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
1856         else:
1857             prefix = 'RR'
1858 
1859         if domain.has_default_precision:
1860             return prettyForm(prefix)
1861         else:
1862             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
1863 
1864     def _print_ComplexField(self, domain):
1865         if self._use_unicode:
1866             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
1867         else:
1868             prefix = 'CC'
1869 
1870         if domain.has_default_precision:
1871             return prettyForm(prefix)
1872         else:
1873             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
1874 
1875     def _print_PolynomialRing(self, expr):
1876         args = list(expr.symbols)
1877 
1878         if not expr.order.is_default:
1879             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
1880             args.append(order)
1881 
1882         pform = self._print_seq(args, '[', ']')
1883         pform = prettyForm(*pform.left(self._print(expr.domain)))
1884 
1885         return pform
1886 
1887     def _print_FractionField(self, expr):
1888         args = list(expr.symbols)
1889 
1890         if not expr.order.is_default:
1891             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
1892             args.append(order)
1893 
1894         pform = self._print_seq(args, '(', ')')
1895         pform = prettyForm(*pform.left(self._print(expr.domain)))
1896 
1897         return pform
1898 
1899     def _print_PolynomialRingBase(self, expr):
1900         g = expr.symbols
1901         if str(expr.order) != str(expr.default_order):
1902             g = g + ("order=" + str(expr.order),)
1903         pform = self._print_seq(g, '[', ']')
1904         pform = prettyForm(*pform.left(self._print(expr.domain)))
1905 
1906         return pform
1907 
1908     def _print_GroebnerBasis(self, basis):
1909         exprs = [ self._print_Add(arg, order=basis.order)
1910                   for arg in basis.exprs ]
1911         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
1912 
1913         gens = [ self._print(gen) for gen in basis.gens ]
1914 
1915         domain = prettyForm(
1916             *prettyForm("domain=").right(self._print(basis.domain)))
1917         order = prettyForm(
1918             *prettyForm("order=").right(self._print(basis.order)))
1919 
1920         pform = self.join(", ", [exprs] + gens + [domain, order])
1921 
1922         pform = prettyForm(*pform.parens())
1923         pform = prettyForm(*pform.left(basis.__class__.__name__))
1924 
1925         return pform
1926 
1927     def _print_Subs(self, e):
1928         pform = self._print(e.expr)
1929         pform = prettyForm(*pform.parens())
1930 
1931         h = pform.height() if pform.height() > 1 else 2
1932         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
1933         pform = prettyForm(*pform.right(rvert))
1934 
1935         b = pform.baseline
1936         pform.baseline = pform.height() - 1
1937         pform = prettyForm(*pform.right(self._print_seq([
1938             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
1939                 delimiter='') for v in zip(e.variables, e.point) ])))
1940 
1941         pform.baseline = b
1942         return pform
1943 
1944     def _print_euler(self, e):
1945         pform = prettyForm("E")
1946         arg = self._print(e.args[0])
1947         pform_arg = prettyForm(" "*arg.width())
1948         pform_arg = prettyForm(*pform_arg.below(arg))
1949         pform = prettyForm(*pform.right(pform_arg))
1950         return pform
1951 
1952     def _print_catalan(self, e):
1953         pform = prettyForm("C")
1954         arg = self._print(e.args[0])
1955         pform_arg = prettyForm(" "*arg.width())
1956         pform_arg = prettyForm(*pform_arg.below(arg))
1957         pform = prettyForm(*pform.right(pform_arg))
1958         return pform
1959 
1960     def _print_KroneckerDelta(self, e):
1961         pform = self._print(e.args[0])
1962         pform = prettyForm(*pform.right((prettyForm(','))))
1963         pform = prettyForm(*pform.right((self._print(e.args[1]))))
1964         if self._use_unicode:
1965             a = stringPict(pretty_symbol('delta'))
1966         else:
1967             a = stringPict('d')
1968         b = pform
1969         top = stringPict(*b.left(' '*a.width()))
1970         bot = stringPict(*a.right(' '*b.width()))
1971         return prettyForm(binding=prettyForm.POW, *bot.below(top))
1972 
1973     def _print_RandomDomain(self, d):
1974         try:
1975             pform = self._print('Domain: ')
1976             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
1977             return pform
1978 
1979         except Exception:
1980             try:
1981                 pform = self._print('Domain: ')
1982                 pform = prettyForm(*pform.right(self._print(d.symbols)))
1983                 pform = prettyForm(*pform.right(self._print(' in ')))
1984                 pform = prettyForm(*pform.right(self._print(d.set)))
1985                 return pform
1986             except:
1987                 return self._print(None)
1988 
1989     def _print_DMP(self, p):
1990         try:
1991             if p.ring is not None:
1992                 # TODO incorporate order
1993                 return self._print(p.ring.to_sympy(p))
1994         except SympifyError:
1995             pass
1996         return self._print(repr(p))
1997 
1998     def _print_DMF(self, p):
1999         return self._print_DMP(p)
2000 
2001     def _print_Object(self, object):
2002         return self._print(pretty_symbol(object.name))
2003 
2004     def _print_Morphism(self, morphism):
2005         arrow = xsym("-->")
2006 
2007         domain = self._print(morphism.domain)
2008         codomain = self._print(morphism.codomain)
2009         tail = domain.right(arrow, codomain)[0]
2010 
2011         return prettyForm(tail)
2012 
2013     def _print_NamedMorphism(self, morphism):
2014         pretty_name = self._print(pretty_symbol(morphism.name))
2015         pretty_morphism = self._print_Morphism(morphism)
2016         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2017 
2018     def _print_IdentityMorphism(self, morphism):
2019         from sympy.categories import NamedMorphism
2020         return self._print_NamedMorphism(
2021             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2022 
2023     def _print_CompositeMorphism(self, morphism):
2024 
2025         circle = xsym(".")
2026 
2027         # All components of the morphism have names and it is thus
2028         # possible to build the name of the composite.
2029         component_names_list = [pretty_symbol(component.name) for
2030                                 component in morphism.components]
2031         component_names_list.reverse()
2032         component_names = circle.join(component_names_list) + ":"
2033 
2034         pretty_name = self._print(component_names)
2035         pretty_morphism = self._print_Morphism(morphism)
2036         return prettyForm(pretty_name.right(pretty_morphism)[0])
2037 
2038     def _print_Category(self, category):
2039         return self._print(pretty_symbol(category.name))
2040 
2041     def _print_Diagram(self, diagram):
2042         if not diagram.premises:
2043             # This is an empty diagram.
2044             return self._print(S.EmptySet)
2045 
2046         pretty_result = self._print(diagram.premises)
2047         if diagram.conclusions:
2048             results_arrow = " %s " % xsym("==>")
2049 
2050             pretty_conclusions = self._print(diagram.conclusions)[0]
2051             pretty_result = pretty_result.right(
2052                 results_arrow, pretty_conclusions)
2053 
2054         return prettyForm(pretty_result[0])
2055 
2056     def _print_DiagramGrid(self, grid):
2057         from sympy.matrices import Matrix
2058         from sympy import Symbol
2059         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2060                           for j in range(grid.width)]
2061                          for i in range(grid.height)])
2062         return self._print_matrix_contents(matrix)
2063 
2064     def _print_FreeModuleElement(self, m):
2065         # Print as row vector for convenience, for now.
2066         return self._print_seq(m, '[', ']')
2067 
2068     def _print_SubModule(self, M):
2069         return self._print_seq(M.gens, '<', '>')
2070 
2071     def _print_FreeModule(self, M):
2072         return self._print(M.ring)**self._print(M.rank)
2073 
2074     def _print_ModuleImplementedIdeal(self, M):
2075         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2076 
2077     def _print_QuotientRing(self, R):
2078         return self._print(R.ring) / self._print(R.base_ideal)
2079 
2080     def _print_QuotientRingElement(self, R):
2081         return self._print(R.data) + self._print(R.ring.base_ideal)
2082 
2083     def _print_QuotientModuleElement(self, m):
2084         return self._print(m.data) + self._print(m.module.killed_module)
2085 
2086     def _print_QuotientModule(self, M):
2087         return self._print(M.base) / self._print(M.killed_module)
2088 
2089     def _print_MatrixHomomorphism(self, h):
2090         matrix = self._print(h._sympy_matrix())
2091         matrix.baseline = matrix.height() // 2
2092         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2093             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2094         return pform
2095 
2096     def _print_BaseScalarField(self, field):
2097         string = field._coord_sys._names[field._index]
2098         return self._print(pretty_symbol(string))
2099 
2100     def _print_BaseVectorField(self, field):
2101         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2102         return self._print(pretty_symbol(s))
2103 
2104     def _print_Differential(self, diff):
2105         field = diff._form_field
2106         if hasattr(field, '_coord_sys'):
2107             string = field._coord_sys._names[field._index]
2108             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2109         else:
2110             pform = self._print(field)
2111             pform = prettyForm(*pform.parens())
2112             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2113 
2114     def _print_Tr(self, p):
2115         #TODO: Handle indices
2116         pform = self._print(p.args[0])
2117         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2118         pform = prettyForm(*pform.right(')'))
2119         return pform
2120 
2121     def _print_primenu(self, e):
2122         pform = self._print(e.args[0])
2123         pform = prettyForm(*pform.parens())
2124         if self._use_unicode:
2125             pform = prettyForm(*pform.left(greek_unicode['nu']))
2126         else:
2127             pform = prettyForm(*pform.left('nu'))
2128         return pform
2129 
2130     def _print_primeomega(self, e):
2131         pform = self._print(e.args[0])
2132         pform = prettyForm(*pform.parens())
2133         if self._use_unicode:
2134             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2135         else:
2136             pform = prettyForm(*pform.left('Omega'))
2137         return pform

</code><intended_behavior>The methods within the `PrettyPrinter` class responsible for printing fractions, exponentials, logarithms, and other expressions highlighted in the issue should be evaluated to ensure they are structurally and conceptually consistent with LaTeX output where feasible. While maintaining the readability and simplicity of the pretty print format, slight adjustments may be necessary to align both outputs more closely. This might involve modifying how the pretty printer simplifies expressions or represents certain mathematical constructs to minimize discrepancies with LaTeX representations, provided these changes do not compromise the clarity or the utility of the pretty printed output.</intended_behavior>]
2025-10-15 12:55:36.307 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 12:55:36.307 | INFO     | Search-only: skipping patch selection
2025-10-15 12:55:36.386 | INFO     | Task sympy__sympy-11897 completed successfully.
2025-10-15 12:55:36.387 | INFO     | No patch generated. You can try running ACR again.
