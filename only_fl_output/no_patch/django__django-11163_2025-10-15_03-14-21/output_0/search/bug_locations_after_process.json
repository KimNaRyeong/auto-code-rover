[
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/forms/models.py",
        "start": 69,
        "end": 91,
        "class_name": null,
        "method_name": "model_to_dict",
        "code": "69 def model_to_dict(instance, fields=None, exclude=None):\n70     \"\"\"\n71     Return a dict containing the data in ``instance`` suitable for passing as\n72     a Form's ``initial`` keyword argument.\n73 \n74     ``fields`` is an optional list of field names. If provided, return only the\n75     named.\n76 \n77     ``exclude`` is an optional list of field names. If provided, exclude the\n78     named from the returned dict, even if they are listed in the ``fields``\n79     argument.\n80     \"\"\"\n81     opts = instance._meta\n82     data = {}\n83     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n84         if not getattr(f, 'editable', False):\n85             continue\n86         if fields and f.name not in fields:\n87             continue\n88         if exclude and f.name in exclude:\n89             continue\n90         data[f.name] = f.value_from_object(instance)\n91     return data\n",
        "intended_behavior": "The condition checking whether a field is contained in the `fields` argument should accurately distinguish between `None` and an empty list (`[]`). When `fields` is `None`, the behavior should remain as currently implemented, including all fields by default unless they are in the `exclude` list. However, when `fields` is an empty list, it signifies that no fields were requested, and thus the function should return an empty dictionary. This can be achieved by adjusting the conditional from `if fields and f.name not in fields:` to `if fields is not None and f.name not in fields:`, ensuring that an empty list for `fields` results in an empty dictionary."
    }
]