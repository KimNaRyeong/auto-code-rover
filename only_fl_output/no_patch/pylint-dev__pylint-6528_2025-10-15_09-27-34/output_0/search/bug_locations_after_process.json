[
    {
        "rel_file_path": "pylint/config/argument.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/argument.py",
        "start": 1,
        "end": 486,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 \"\"\"Definition of an Argument class and transformers for various argument types.\n6 \n7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser\n8 \"\"\"\n9 \n10 from __future__ import annotations\n11 \n12 import argparse\n13 import os\n14 import pathlib\n15 import re\n16 import sys\n17 from collections.abc import Callable\n18 from typing import Any, Pattern, Sequence, Tuple, Union\n19 \n20 from pylint import interfaces\n21 from pylint import utils as pylint_utils\n22 from pylint.config.callback_actions import _CallbackAction, _ExtendAction\n23 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction\n24 from pylint.constants import PY38_PLUS\n25 \n26 if sys.version_info >= (3, 8):\n27     from typing import Literal\n28 else:\n29     from typing_extensions import Literal\n30 \n31 \n32 _ArgumentTypes = Union[\n33     str,\n34     int,\n35     float,\n36     bool,\n37     Pattern[str],\n38     Sequence[str],\n39     Sequence[Pattern[str]],\n40     Tuple[int, ...],\n41 ]\n42 \"\"\"List of possible argument types.\"\"\"\n43 \n44 \n45 def _confidence_transformer(value: str) -> Sequence[str]:\n46     \"\"\"Transforms a comma separated string of confidence values.\"\"\"\n47     if not value:\n48         return interfaces.CONFIDENCE_LEVEL_NAMES\n49     values = pylint_utils._check_csv(value)\n50     for confidence in values:\n51         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:\n52             raise argparse.ArgumentTypeError(\n53                 f\"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}\"\n54             )\n55     return values\n56 \n57 \n58 def _csv_transformer(value: str) -> Sequence[str]:\n59     \"\"\"Transforms a comma separated string.\"\"\"\n60     return pylint_utils._check_csv(value)\n61 \n62 \n63 YES_VALUES = {\"y\", \"yes\", \"true\"}\n64 NO_VALUES = {\"n\", \"no\", \"false\"}\n65 \n66 \n67 def _yn_transformer(value: str) -> bool:\n68     \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n69     value = value.lower()\n70     if value in YES_VALUES:\n71         return True\n72     if value in NO_VALUES:\n73         return False\n74     raise argparse.ArgumentTypeError(\n75         None, f\"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}\"\n76     )\n77 \n78 \n79 def _non_empty_string_transformer(value: str) -> str:\n80     \"\"\"Check that a string is not empty and remove quotes.\"\"\"\n81     if not value:\n82         raise argparse.ArgumentTypeError(\"Option cannot be an empty string.\")\n83     return pylint_utils._unquote(value)\n84 \n85 \n86 def _path_transformer(value: str) -> str:\n87     \"\"\"Expand user and variables in a path.\"\"\"\n88     return os.path.expandvars(os.path.expanduser(value))\n89 \n90 \n91 def _py_version_transformer(value: str) -> tuple[int, ...]:\n92     \"\"\"Transforms a version string into a version tuple.\"\"\"\n93     try:\n94         version = tuple(int(val) for val in value.replace(\",\", \".\").split(\".\"))\n95     except ValueError:\n96         raise argparse.ArgumentTypeError(\n97             f\"{value} has an invalid format, should be a version string. E.g., '3.8'\"\n98         ) from None\n99     return version\n100 \n101 \n102 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n103     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n104     patterns: list[Pattern[str]] = []\n105     for pattern in _csv_transformer(value):\n106         patterns.append(re.compile(pattern))\n107     return patterns\n108 \n109 \n110 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n111     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n112     patterns: list[Pattern[str]] = []\n113     for pattern in _csv_transformer(value):\n114         patterns.append(\n115             re.compile(\n116                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n117                 + \"|\"\n118                 + pathlib.PureWindowsPath(pattern).as_posix()\n119             )\n120         )\n121     return patterns\n122 \n123 \n124 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n125     \"choice\": str,\n126     \"csv\": _csv_transformer,\n127     \"float\": float,\n128     \"int\": int,\n129     \"confidence\": _confidence_transformer,\n130     \"non_empty_string\": _non_empty_string_transformer,\n131     \"path\": _path_transformer,\n132     \"py_version\": _py_version_transformer,\n133     \"regexp\": re.compile,\n134     \"regexp_csv\": _regexp_csv_transfomer,\n135     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n136     \"string\": pylint_utils._unquote,\n137     \"yn\": _yn_transformer,\n138 }\n139 \"\"\"Type transformers for all argument types.\n140 \n141 A transformer should accept a string and return one of the supported\n142 Argument types. It will only be called when parsing 1) command-line,\n143 2) configuration files and 3) a string default value.\n144 Non-string default values are assumed to be of the correct type.\n145 \"\"\"\n146 \n147 \n148 class _Argument:\n149     \"\"\"Class representing an argument to be parsed by an argparse.ArgumentsParser.\n150 \n151     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n152     See:\n153     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n154     \"\"\"\n155 \n156     def __init__(\n157         self,\n158         *,\n159         flags: list[str],\n160         arg_help: str,\n161         hide_help: bool,\n162         section: str | None,\n163     ) -> None:\n164         self.flags = flags\n165         \"\"\"The name of the argument.\"\"\"\n166 \n167         self.hide_help = hide_help\n168         \"\"\"Whether to hide this argument in the help message.\"\"\"\n169 \n170         # argparse uses % formatting on help strings, so a % needs to be escaped\n171         self.help = arg_help.replace(\"%\", \"%%\")\n172         \"\"\"The description of the argument.\"\"\"\n173 \n174         if hide_help:\n175             self.help = argparse.SUPPRESS\n176 \n177         self.section = section\n178         \"\"\"The section to add this argument to.\"\"\"\n179 \n180 \n181 class _BaseStoreArgument(_Argument):\n182     \"\"\"Base class for store arguments to be parsed by an argparse.ArgumentsParser.\n183 \n184     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n185     See:\n186     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n187     \"\"\"\n188 \n189     def __init__(\n190         self,\n191         *,\n192         flags: list[str],\n193         action: str,\n194         default: _ArgumentTypes,\n195         arg_help: str,\n196         hide_help: bool,\n197         section: str | None,\n198     ) -> None:\n199         super().__init__(\n200             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n201         )\n202 \n203         self.action = action\n204         \"\"\"The action to perform with the argument.\"\"\"\n205 \n206         self.default = default\n207         \"\"\"The default value of the argument.\"\"\"\n208 \n209 \n210 class _StoreArgument(_BaseStoreArgument):\n211     \"\"\"Class representing a store argument to be parsed by an argparse.ArgumentsParser.\n212 \n213     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n214     See:\n215     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n216     \"\"\"\n217 \n218     def __init__(\n219         self,\n220         *,\n221         flags: list[str],\n222         action: str,\n223         default: _ArgumentTypes,\n224         arg_type: str,\n225         choices: list[str] | None,\n226         arg_help: str,\n227         metavar: str,\n228         hide_help: bool,\n229         section: str | None,\n230     ) -> None:\n231         super().__init__(\n232             flags=flags,\n233             action=action,\n234             default=default,\n235             arg_help=arg_help,\n236             hide_help=hide_help,\n237             section=section,\n238         )\n239 \n240         self.type = _TYPE_TRANSFORMERS[arg_type]\n241         \"\"\"A transformer function that returns a transformed type of the argument.\"\"\"\n242 \n243         self.choices = choices\n244         \"\"\"A list of possible choices for the argument.\n245 \n246         None if there are no restrictions.\n247         \"\"\"\n248 \n249         self.metavar = metavar\n250         \"\"\"The metavar of the argument.\n251 \n252         See:\n253         https://docs.python.org/3/library/argparse.html#metavar\n254         \"\"\"\n255 \n256 \n257 class _StoreTrueArgument(_BaseStoreArgument):\n258     \"\"\"Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.\n259 \n260     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n261     See:\n262     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n263     \"\"\"\n264 \n265     # pylint: disable-next=useless-super-delegation # We narrow down the type of action\n266     def __init__(\n267         self,\n268         *,\n269         flags: list[str],\n270         action: Literal[\"store_true\"],\n271         default: _ArgumentTypes,\n272         arg_help: str,\n273         hide_help: bool,\n274         section: str | None,\n275     ) -> None:\n276         super().__init__(\n277             flags=flags,\n278             action=action,\n279             default=default,\n280             arg_help=arg_help,\n281             hide_help=hide_help,\n282             section=section,\n283         )\n284 \n285 \n286 class _DeprecationArgument(_Argument):\n287     \"\"\"Store arguments while also handling deprecation warnings for old and new names.\n288 \n289     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n290     See:\n291     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n292     \"\"\"\n293 \n294     def __init__(\n295         self,\n296         *,\n297         flags: list[str],\n298         action: type[argparse.Action],\n299         default: _ArgumentTypes,\n300         arg_type: str,\n301         choices: list[str] | None,\n302         arg_help: str,\n303         metavar: str,\n304         hide_help: bool,\n305         section: str | None,\n306     ) -> None:\n307         super().__init__(\n308             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n309         )\n310 \n311         self.action = action\n312         \"\"\"The action to perform with the argument.\"\"\"\n313 \n314         self.default = default\n315         \"\"\"The default value of the argument.\"\"\"\n316 \n317         self.type = _TYPE_TRANSFORMERS[arg_type]\n318         \"\"\"A transformer function that returns a transformed type of the argument.\"\"\"\n319 \n320         self.choices = choices\n321         \"\"\"A list of possible choices for the argument.\n322 \n323         None if there are no restrictions.\n324         \"\"\"\n325 \n326         self.metavar = metavar\n327         \"\"\"The metavar of the argument.\n328 \n329         See:\n330         https://docs.python.org/3/library/argparse.html#metavar\n331         \"\"\"\n332 \n333 \n334 class _ExtendArgument(_DeprecationArgument):\n335     \"\"\"Class for extend arguments to be parsed by an argparse.ArgumentsParser.\n336 \n337     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n338     See:\n339     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n340     \"\"\"\n341 \n342     def __init__(\n343         self,\n344         *,\n345         flags: list[str],\n346         action: Literal[\"extend\"],\n347         default: _ArgumentTypes,\n348         arg_type: str,\n349         metavar: str,\n350         arg_help: str,\n351         hide_help: bool,\n352         section: str | None,\n353         choices: list[str] | None,\n354         dest: str | None,\n355     ) -> None:\n356         # The extend action is included in the stdlib from 3.8+\n357         if PY38_PLUS:\n358             action_class = argparse._ExtendAction  # type: ignore[attr-defined]\n359         else:\n360             action_class = _ExtendAction\n361 \n362         self.dest = dest\n363         \"\"\"The destination of the argument.\"\"\"\n364 \n365         super().__init__(\n366             flags=flags,\n367             action=action_class,\n368             default=default,\n369             arg_type=arg_type,\n370             choices=choices,\n371             arg_help=arg_help,\n372             metavar=metavar,\n373             hide_help=hide_help,\n374             section=section,\n375         )\n376 \n377 \n378 class _StoreOldNamesArgument(_DeprecationArgument):\n379     \"\"\"Store arguments while also handling old names.\n380 \n381     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n382     See:\n383     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n384     \"\"\"\n385 \n386     def __init__(\n387         self,\n388         *,\n389         flags: list[str],\n390         default: _ArgumentTypes,\n391         arg_type: str,\n392         choices: list[str] | None,\n393         arg_help: str,\n394         metavar: str,\n395         hide_help: bool,\n396         kwargs: dict[str, Any],\n397         section: str | None,\n398     ) -> None:\n399         super().__init__(\n400             flags=flags,\n401             action=_OldNamesAction,\n402             default=default,\n403             arg_type=arg_type,\n404             choices=choices,\n405             arg_help=arg_help,\n406             metavar=metavar,\n407             hide_help=hide_help,\n408             section=section,\n409         )\n410 \n411         self.kwargs = kwargs\n412         \"\"\"Any additional arguments passed to the action.\"\"\"\n413 \n414 \n415 class _StoreNewNamesArgument(_DeprecationArgument):\n416     \"\"\"Store arguments while also emitting deprecation warnings.\n417 \n418     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n419     See:\n420     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n421     \"\"\"\n422 \n423     def __init__(\n424         self,\n425         *,\n426         flags: list[str],\n427         default: _ArgumentTypes,\n428         arg_type: str,\n429         choices: list[str] | None,\n430         arg_help: str,\n431         metavar: str,\n432         hide_help: bool,\n433         kwargs: dict[str, Any],\n434         section: str | None,\n435     ) -> None:\n436         super().__init__(\n437             flags=flags,\n438             action=_NewNamesAction,\n439             default=default,\n440             arg_type=arg_type,\n441             choices=choices,\n442             arg_help=arg_help,\n443             metavar=metavar,\n444             hide_help=hide_help,\n445             section=section,\n446         )\n447 \n448         self.kwargs = kwargs\n449         \"\"\"Any additional arguments passed to the action.\"\"\"\n450 \n451 \n452 class _CallableArgument(_Argument):\n453     \"\"\"Class representing an callable argument to be parsed by an argparse.ArgumentsParser.\n454 \n455     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n456     See:\n457     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n458     \"\"\"\n459 \n460     def __init__(\n461         self,\n462         *,\n463         flags: list[str],\n464         action: type[_CallbackAction],\n465         arg_help: str,\n466         kwargs: dict[str, Any],\n467         hide_help: bool,\n468         section: str | None,\n469         metavar: str,\n470     ) -> None:\n471         super().__init__(\n472             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n473         )\n474 \n475         self.action = action\n476         \"\"\"The action to perform with the argument.\"\"\"\n477 \n478         self.kwargs = kwargs\n479         \"\"\"Any additional arguments passed to the action.\"\"\"\n480 \n481         self.metavar = metavar\n482         \"\"\"The metavar of the argument.\n483 \n484         See:\n485         https://docs.python.org/3/library/argparse.html#metavar\n486         \"\"\"\n",
        "intended_behavior": "Ignored files, paths, or patterns must consistently be excluded from the linting process, irrespective of the depth of recursion. This might require refactoring how ignore arguments are parsed, interpreted, and applied across the codebase."
    },
    {
        "rel_file_path": "pylint/config/callback_actions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/callback_actions.py",
        "start": 1,
        "end": 422,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 # pylint: disable=too-many-arguments, redefined-builtin, duplicate-code\n6 \n7 \"\"\"Callback actions for various options.\"\"\"\n8 \n9 from __future__ import annotations\n10 \n11 import abc\n12 import argparse\n13 import sys\n14 import warnings\n15 from collections.abc import Sequence\n16 from pathlib import Path\n17 from typing import TYPE_CHECKING, Any\n18 \n19 from pylint import exceptions, extensions, interfaces, utils\n20 \n21 if TYPE_CHECKING:\n22     from pylint.config.help_formatter import _HelpFormatter\n23     from pylint.lint import PyLinter\n24     from pylint.lint.run import Run\n25 \n26 \n27 class _CallbackAction(argparse.Action):\n28     \"\"\"Custom callback action.\"\"\"\n29 \n30     @abc.abstractmethod\n31     def __call__(\n32         self,\n33         parser: argparse.ArgumentParser,\n34         namespace: argparse.Namespace,\n35         values: str | Sequence[Any] | None,\n36         option_string: str | None = None,\n37     ) -> None:\n38         raise NotImplementedError  # pragma: no cover\n39 \n40 \n41 class _DoNothingAction(_CallbackAction):\n42     \"\"\"Action that just passes.\n43 \n44     This action is used to allow pre-processing of certain options\n45     without erroring when they are then processed again by argparse.\n46     \"\"\"\n47 \n48     def __call__(\n49         self,\n50         parser: argparse.ArgumentParser,\n51         namespace: argparse.Namespace,\n52         values: str | Sequence[Any] | None,\n53         option_string: str | None = None,\n54     ) -> None:\n55         return None\n56 \n57 \n58 class _ExtendAction(argparse._AppendAction):\n59     \"\"\"Action that adds the value to a pre-existing list.\n60 \n61     It is directly copied from the stdlib implementation which is only available\n62     on 3.8+.\n63     \"\"\"\n64 \n65     def __call__(\n66         self,\n67         parser: argparse.ArgumentParser,\n68         namespace: argparse.Namespace,\n69         values: str | Sequence[Any] | None,\n70         option_string: str | None = None,\n71     ) -> None:\n72         assert isinstance(values, (tuple, list))\n73         current = getattr(namespace, self.dest, [])\n74         assert isinstance(current, list)\n75         current.extend(values)\n76         setattr(namespace, self.dest, current)\n77 \n78 \n79 class _AccessRunObjectAction(_CallbackAction):\n80     \"\"\"Action that has access to the Run object.\"\"\"\n81 \n82     def __init__(\n83         self,\n84         option_strings: Sequence[str],\n85         dest: str,\n86         nargs: None = None,\n87         const: None = None,\n88         default: None = None,\n89         type: None = None,\n90         choices: None = None,\n91         required: bool = False,\n92         help: str = \"\",\n93         metavar: str = \"\",\n94         **kwargs: Run,\n95     ) -> None:\n96         self.run = kwargs[\"Run\"]\n97 \n98         super().__init__(\n99             option_strings,\n100             dest,\n101             0,\n102             const,\n103             default,\n104             type,\n105             choices,\n106             required,\n107             help,\n108             metavar,\n109         )\n110 \n111     @abc.abstractmethod\n112     def __call__(\n113         self,\n114         parser: argparse.ArgumentParser,\n115         namespace: argparse.Namespace,\n116         values: str | Sequence[Any] | None,\n117         option_string: str | None = None,\n118     ) -> None:\n119         raise NotImplementedError  # pragma: no cover\n120 \n121 \n122 class _MessageHelpAction(_CallbackAction):\n123     \"\"\"Display the help message of a message.\"\"\"\n124 \n125     def __init__(\n126         self,\n127         option_strings: Sequence[str],\n128         dest: str,\n129         nargs: None = None,\n130         const: None = None,\n131         default: None = None,\n132         type: None = None,\n133         choices: None = None,\n134         required: bool = False,\n135         help: str = \"\",\n136         metavar: str = \"\",\n137         **kwargs: Run,\n138     ) -> None:\n139         self.run = kwargs[\"Run\"]\n140         super().__init__(\n141             option_strings,\n142             dest,\n143             \"+\",\n144             const,\n145             default,\n146             type,\n147             choices,\n148             required,\n149             help,\n150             metavar,\n151         )\n152 \n153     def __call__(\n154         self,\n155         parser: argparse.ArgumentParser,\n156         namespace: argparse.Namespace,\n157         values: str | Sequence[str] | None,\n158         option_string: str | None = \"--help-msg\",\n159     ) -> None:\n160         assert isinstance(values, (list, tuple))\n161         self.run.linter.msgs_store.help_message(values)\n162         sys.exit(0)\n163 \n164 \n165 class _ListMessagesAction(_AccessRunObjectAction):\n166     \"\"\"Display all available messages.\"\"\"\n167 \n168     def __call__(\n169         self,\n170         parser: argparse.ArgumentParser,\n171         namespace: argparse.Namespace,\n172         values: str | Sequence[Any] | None,\n173         option_string: str | None = \"--list-enabled\",\n174     ) -> None:\n175         self.run.linter.msgs_store.list_messages()\n176         sys.exit(0)\n177 \n178 \n179 class _ListMessagesEnabledAction(_AccessRunObjectAction):\n180     \"\"\"Display all enabled messages.\"\"\"\n181 \n182     def __call__(\n183         self,\n184         parser: argparse.ArgumentParser,\n185         namespace: argparse.Namespace,\n186         values: str | Sequence[Any] | None,\n187         option_string: str | None = \"--list-msgs-enabled\",\n188     ) -> None:\n189         self.run.linter.list_messages_enabled()\n190         sys.exit(0)\n191 \n192 \n193 class _ListCheckGroupsAction(_AccessRunObjectAction):\n194     \"\"\"Display all the check groups that pylint knows about.\"\"\"\n195 \n196     def __call__(\n197         self,\n198         parser: argparse.ArgumentParser,\n199         namespace: argparse.Namespace,\n200         values: str | Sequence[Any] | None,\n201         option_string: str | None = \"--list-groups\",\n202     ) -> None:\n203         for check in self.run.linter.get_checker_names():\n204             print(check)\n205         sys.exit(0)\n206 \n207 \n208 class _ListConfidenceLevelsAction(_AccessRunObjectAction):\n209     \"\"\"Display all the confidence levels that pylint knows about.\"\"\"\n210 \n211     def __call__(\n212         self,\n213         parser: argparse.ArgumentParser,\n214         namespace: argparse.Namespace,\n215         values: str | Sequence[Any] | None,\n216         option_string: str | None = \"--list-conf-levels\",\n217     ) -> None:\n218         for level in interfaces.CONFIDENCE_LEVELS:\n219             print(f\"%-18s: {level}\")\n220         sys.exit(0)\n221 \n222 \n223 class _ListExtensionsAction(_AccessRunObjectAction):\n224     \"\"\"Display all extensions under pylint.extensions.\"\"\"\n225 \n226     def __call__(\n227         self,\n228         parser: argparse.ArgumentParser,\n229         namespace: argparse.Namespace,\n230         values: str | Sequence[Any] | None,\n231         option_string: str | None = \"--list-extensions\",\n232     ) -> None:\n233         for filename in Path(extensions.__file__).parent.iterdir():\n234             if filename.suffix == \".py\" and not filename.stem.startswith(\"_\"):\n235                 extension_name, _, _ = filename.stem.partition(\".\")\n236                 print(f\"pylint.extensions.{extension_name}\")\n237         sys.exit(0)\n238 \n239 \n240 class _FullDocumentationAction(_AccessRunObjectAction):\n241     \"\"\"Display the full documentation.\"\"\"\n242 \n243     def __call__(\n244         self,\n245         parser: argparse.ArgumentParser,\n246         namespace: argparse.Namespace,\n247         values: str | Sequence[Any] | None,\n248         option_string: str | None = \"--full-documentation\",\n249     ) -> None:\n250         utils.print_full_documentation(self.run.linter)\n251         sys.exit(0)\n252 \n253 \n254 class _GenerateRCFileAction(_AccessRunObjectAction):\n255     \"\"\"Generate a pylintrc file.\"\"\"\n256 \n257     def __call__(\n258         self,\n259         parser: argparse.ArgumentParser,\n260         namespace: argparse.Namespace,\n261         values: str | Sequence[Any] | None,\n262         option_string: str | None = \"--generate-rcfile\",\n263     ) -> None:\n264         # TODO: 2.14: Deprecate this after discussion about this removal has been completed.\n265         with warnings.catch_warnings():\n266             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n267             self.run.linter.generate_config(skipsections=(\"Commands\",))\n268         sys.exit(0)\n269 \n270 \n271 class _GenerateConfigFileAction(_AccessRunObjectAction):\n272     \"\"\"Generate a .toml format configuration file.\"\"\"\n273 \n274     def __call__(\n275         self,\n276         parser: argparse.ArgumentParser,\n277         namespace: argparse.Namespace,\n278         values: str | Sequence[Any] | None,\n279         option_string: str | None = \"--generate-toml-config\",\n280     ) -> None:\n281         self.run.linter._generate_config_file()\n282         sys.exit(0)\n283 \n284 \n285 class _ErrorsOnlyModeAction(_AccessRunObjectAction):\n286     \"\"\"Turn on errors-only mode.\n287 \n288     Error mode:\n289         * disable all but error messages\n290         * disable the 'miscellaneous' checker which can be safely deactivated in\n291           debug\n292         * disable reports\n293         * do not save execution information\n294     \"\"\"\n295 \n296     def __call__(\n297         self,\n298         parser: argparse.ArgumentParser,\n299         namespace: argparse.Namespace,\n300         values: str | Sequence[Any] | None,\n301         option_string: str | None = \"--errors-only\",\n302     ) -> None:\n303         self.run.linter._error_mode = True\n304 \n305 \n306 class _LongHelpAction(_AccessRunObjectAction):\n307     \"\"\"Display the long help message.\"\"\"\n308 \n309     def __call__(\n310         self,\n311         parser: argparse.ArgumentParser,\n312         namespace: argparse.Namespace,\n313         values: str | Sequence[Any] | None,\n314         option_string: str | None = \"--long-help\",\n315     ) -> None:\n316         formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter()  # type: ignore[assignment]\n317 \n318         # Add extra info as epilog to the help message\n319         self.run.linter._arg_parser.epilog = formatter.get_long_description()\n320         print(self.run.linter.help())\n321 \n322         sys.exit(0)\n323 \n324 \n325 class _AccessLinterObjectAction(_CallbackAction):\n326     \"\"\"Action that has access to the Linter object.\"\"\"\n327 \n328     def __init__(\n329         self,\n330         option_strings: Sequence[str],\n331         dest: str,\n332         nargs: None = None,\n333         const: None = None,\n334         default: None = None,\n335         type: None = None,\n336         choices: None = None,\n337         required: bool = False,\n338         help: str = \"\",\n339         metavar: str = \"\",\n340         **kwargs: PyLinter,\n341     ) -> None:\n342         self.linter = kwargs[\"linter\"]\n343 \n344         super().__init__(\n345             option_strings,\n346             dest,\n347             1,\n348             const,\n349             default,\n350             type,\n351             choices,\n352             required,\n353             help,\n354             metavar,\n355         )\n356 \n357     @abc.abstractmethod\n358     def __call__(\n359         self,\n360         parser: argparse.ArgumentParser,\n361         namespace: argparse.Namespace,\n362         values: str | Sequence[Any] | None,\n363         option_string: str | None = None,\n364     ) -> None:\n365         raise NotImplementedError  # pragma: no cover\n366 \n367 \n368 class _DisableAction(_AccessLinterObjectAction):\n369     \"\"\"Callback action for disabling a message.\"\"\"\n370 \n371     def __call__(\n372         self,\n373         parser: argparse.ArgumentParser,\n374         namespace: argparse.Namespace,\n375         values: str | Sequence[Any] | None,\n376         option_string: str | None = \"--disable\",\n377     ) -> None:\n378         assert isinstance(values, (tuple, list))\n379         msgids = utils._check_csv(values[0])\n380         for msgid in msgids:\n381             try:\n382                 self.linter.disable(msgid)\n383             except exceptions.UnknownMessageError:\n384                 msg = f\"{option_string}. Don't recognize message {msgid}.\"\n385                 self.linter.add_message(\"bad-option-value\", args=msg, line=0)\n386 \n387 \n388 class _EnableAction(_AccessLinterObjectAction):\n389     \"\"\"Callback action for enabling a message.\"\"\"\n390 \n391     def __call__(\n392         self,\n393         parser: argparse.ArgumentParser,\n394         namespace: argparse.Namespace,\n395         values: str | Sequence[Any] | None,\n396         option_string: str | None = \"--enable\",\n397     ) -> None:\n398         assert isinstance(values, (tuple, list))\n399         msgids = utils._check_csv(values[0])\n400         for msgid in msgids:\n401             try:\n402                 self.linter.enable(msgid)\n403             except exceptions.UnknownMessageError:\n404                 msg = f\"{option_string}. Don't recognize message {msgid}.\"\n405                 self.linter.add_message(\"bad-option-value\", args=msg, line=0)\n406 \n407 \n408 class _OutputFormatAction(_AccessLinterObjectAction):\n409     \"\"\"Callback action for setting the output format.\"\"\"\n410 \n411     def __call__(\n412         self,\n413         parser: argparse.ArgumentParser,\n414         namespace: argparse.Namespace,\n415         values: str | Sequence[Any] | None,\n416         option_string: str | None = \"--enable\",\n417     ) -> None:\n418         assert isinstance(values, (tuple, list))\n419         assert isinstance(\n420             values[0], str\n421         ), \"'output-format' should be a comma separated string of reporters\"\n422         self.linter._load_reporters(values[0])\n",
        "intended_behavior": "This exclusion logic should be centralized or consistently applied across different modules to ensure uniform behavior. Preserve the existing functionality of ignore settings while ensuring they are respected in recursive file analysis scenarios."
    }
]