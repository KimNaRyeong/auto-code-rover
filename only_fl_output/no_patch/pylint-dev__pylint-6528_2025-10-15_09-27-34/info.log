2025-10-15 09:27:34.347 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 09:27:35.960 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=639, output_tokens=12, cost=0.006750
2025-10-15 09:27:50.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=500, cost=0.023190
2025-10-15 09:27:51.403 | INFO     | registered non reproducing test 0
2025-10-15 09:28:15.069 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1895, output_tokens=839, cost=0.044120
2025-10-15 09:28:16.116 | INFO     | registered non reproducing test 1
2025-10-15 09:28:40.224 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2168, output_tokens=848, cost=0.047120
2025-10-15 09:28:41.351 | INFO     | registered non reproducing test 2
2025-10-15 09:28:41.351 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 09:28:41.357 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:28:52.009 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=934, output_tokens=336, cost=0.019420
2025-10-15 09:28:52.017 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:28:55.848 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=690, output_tokens=77, cost=0.009210
2025-10-15 09:28:55.849 | DEBUG    | Extracted a valid json.
2025-10-15 09:28:55.849 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"run_pylint\")",
        "search_code(\"--recursive=y\")",
        "search_code(\"--ignore\")",
        "search_code(\"--ignore-paths\")",
        "search_code(\"--ignore-patterns\")",
        "search_method(\"parse_args\")"
    ],
    "bug_locations": []
}
2025-10-15 09:28:55.912 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:28:55.913 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:29:17.560 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1672, output_tokens=805, cost=0.040870
2025-10-15 09:29:17.575 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:29:29.185 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2693, output_tokens=404, cost=0.039050
2025-10-15 09:29:29.193 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:29:35.140 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=758, output_tokens=106, cost=0.010760
2025-10-15 09:29:35.141 | DEBUG    | Extracted a valid json.
2025-10-15 09:29:35.141 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "",
            "class": "PylintRun",
            "method": "",
            "intended_behavior": "The code should respect the `--ignore`, `--ignore-paths`, and `--ignore-patterns` arguments by excluding specified files or paths from the set of files to lint, especially when processing directories recursively. Ensure this logic is applied consistently across the codebase, and maintain existing functionality."
        }
    ]
}
2025-10-15 09:29:35.144 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-15 09:29:35.145 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 09:29:35.145 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:29:41.668 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3131, output_tokens=217, cost=0.037820
2025-10-15 09:29:41.673 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:29:44.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=571, output_tokens=56, cost=0.007390
2025-10-15 09:29:44.244 | DEBUG    | Extracted a valid json.
2025-10-15 09:29:44.244 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"PylintRun\")",
        "search_code(\"argparse\")",
        "search_code_in_file(\"--ignore\", \"pylint/checkers/similar.py\")"
    ],
    "bug_locations": []
}
2025-10-15 09:29:44.324 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 09:29:44.325 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 09:30:05.808 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3907, output_tokens=729, cost=0.060940
2025-10-15 09:30:05.815 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 09:30:20.810 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4852, output_tokens=490, cost=0.063220
2025-10-15 09:30:20.818 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 09:30:29.727 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=844, output_tokens=256, cost=0.016120
2025-10-15 09:30:29.728 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 09:30:29.728 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-15 09:30:37.139 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=844, output_tokens=200, cost=0.014440
2025-10-15 09:30:37.140 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 09:30:37.140 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-15 09:30:42.613 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=844, output_tokens=162, cost=0.013300
2025-10-15 09:30:42.614 | DEBUG    | Extracted a valid json.
2025-10-15 09:30:42.614 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/config/argument.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ignored files, paths, or patterns must consistently be excluded from the linting process, irrespective of the depth of recursion. This might require refactoring how ignore arguments are parsed, interpreted, and applied across the codebase."
        },
        {
            "file": "pylint/config/callback_actions.py",
            "class": "",
            "method": "",
            "intended_behavior": "This exclusion logic should be centralized or consistently applied across different modules to ensure uniform behavior. Preserve the existing functionality of ignore settings while ensuring they are respected in recursive file analysis scenarios."
        }
    ]
}
2025-10-15 09:30:42.619 | DEBUG    | Bug location extracted successfully: [<file>pylint/config/argument.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Definition of an Argument class and transformers for various argument types.
6 
7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser
8 """
9 
10 from __future__ import annotations
11 
12 import argparse
13 import os
14 import pathlib
15 import re
16 import sys
17 from collections.abc import Callable
18 from typing import Any, Pattern, Sequence, Tuple, Union
19 
20 from pylint import interfaces
21 from pylint import utils as pylint_utils
22 from pylint.config.callback_actions import _CallbackAction, _ExtendAction
23 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction
24 from pylint.constants import PY38_PLUS
25 
26 if sys.version_info >= (3, 8):
27     from typing import Literal
28 else:
29     from typing_extensions import Literal
30 
31 
32 _ArgumentTypes = Union[
33     str,
34     int,
35     float,
36     bool,
37     Pattern[str],
38     Sequence[str],
39     Sequence[Pattern[str]],
40     Tuple[int, ...],
41 ]
42 """List of possible argument types."""
43 
44 
45 def _confidence_transformer(value: str) -> Sequence[str]:
46     """Transforms a comma separated string of confidence values."""
47     if not value:
48         return interfaces.CONFIDENCE_LEVEL_NAMES
49     values = pylint_utils._check_csv(value)
50     for confidence in values:
51         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:
52             raise argparse.ArgumentTypeError(
53                 f"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}"
54             )
55     return values
56 
57 
58 def _csv_transformer(value: str) -> Sequence[str]:
59     """Transforms a comma separated string."""
60     return pylint_utils._check_csv(value)
61 
62 
63 YES_VALUES = {"y", "yes", "true"}
64 NO_VALUES = {"n", "no", "false"}
65 
66 
67 def _yn_transformer(value: str) -> bool:
68     """Transforms a yes/no or stringified bool into a bool."""
69     value = value.lower()
70     if value in YES_VALUES:
71         return True
72     if value in NO_VALUES:
73         return False
74     raise argparse.ArgumentTypeError(
75         None, f"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}"
76     )
77 
78 
79 def _non_empty_string_transformer(value: str) -> str:
80     """Check that a string is not empty and remove quotes."""
81     if not value:
82         raise argparse.ArgumentTypeError("Option cannot be an empty string.")
83     return pylint_utils._unquote(value)
84 
85 
86 def _path_transformer(value: str) -> str:
87     """Expand user and variables in a path."""
88     return os.path.expandvars(os.path.expanduser(value))
89 
90 
91 def _py_version_transformer(value: str) -> tuple[int, ...]:
92     """Transforms a version string into a version tuple."""
93     try:
94         version = tuple(int(val) for val in value.replace(",", ".").split("."))
95     except ValueError:
96         raise argparse.ArgumentTypeError(
97             f"{value} has an invalid format, should be a version string. E.g., '3.8'"
98         ) from None
99     return version
100 
101 
102 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
103     """Transforms a comma separated list of regular expressions."""
104     patterns: list[Pattern[str]] = []
105     for pattern in _csv_transformer(value):
106         patterns.append(re.compile(pattern))
107     return patterns
108 
109 
110 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
111     """Transforms a comma separated list of regular expressions paths."""
112     patterns: list[Pattern[str]] = []
113     for pattern in _csv_transformer(value):
114         patterns.append(
115             re.compile(
116                 str(pathlib.PureWindowsPath(pattern)).replace("\\", "\\\\")
117                 + "|"
118                 + pathlib.PureWindowsPath(pattern).as_posix()
119             )
120         )
121     return patterns
122 
123 
124 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {
125     "choice": str,
126     "csv": _csv_transformer,
127     "float": float,
128     "int": int,
129     "confidence": _confidence_transformer,
130     "non_empty_string": _non_empty_string_transformer,
131     "path": _path_transformer,
132     "py_version": _py_version_transformer,
133     "regexp": re.compile,
134     "regexp_csv": _regexp_csv_transfomer,
135     "regexp_paths_csv": _regexp_paths_csv_transfomer,
136     "string": pylint_utils._unquote,
137     "yn": _yn_transformer,
138 }
139 """Type transformers for all argument types.
140 
141 A transformer should accept a string and return one of the supported
142 Argument types. It will only be called when parsing 1) command-line,
143 2) configuration files and 3) a string default value.
144 Non-string default values are assumed to be of the correct type.
145 """
146 
147 
148 class _Argument:
149     """Class representing an argument to be parsed by an argparse.ArgumentsParser.
150 
151     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
152     See:
153     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
154     """
155 
156     def __init__(
157         self,
158         *,
159         flags: list[str],
160         arg_help: str,
161         hide_help: bool,
162         section: str | None,
163     ) -> None:
164         self.flags = flags
165         """The name of the argument."""
166 
167         self.hide_help = hide_help
168         """Whether to hide this argument in the help message."""
169 
170         # argparse uses % formatting on help strings, so a % needs to be escaped
171         self.help = arg_help.replace("%", "%%")
172         """The description of the argument."""
173 
174         if hide_help:
175             self.help = argparse.SUPPRESS
176 
177         self.section = section
178         """The section to add this argument to."""
179 
180 
181 class _BaseStoreArgument(_Argument):
182     """Base class for store arguments to be parsed by an argparse.ArgumentsParser.
183 
184     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
185     See:
186     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
187     """
188 
189     def __init__(
190         self,
191         *,
192         flags: list[str],
193         action: str,
194         default: _ArgumentTypes,
195         arg_help: str,
196         hide_help: bool,
197         section: str | None,
198     ) -> None:
199         super().__init__(
200             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
201         )
202 
203         self.action = action
204         """The action to perform with the argument."""
205 
206         self.default = default
207         """The default value of the argument."""
208 
209 
210 class _StoreArgument(_BaseStoreArgument):
211     """Class representing a store argument to be parsed by an argparse.ArgumentsParser.
212 
213     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
214     See:
215     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
216     """
217 
218     def __init__(
219         self,
220         *,
221         flags: list[str],
222         action: str,
223         default: _ArgumentTypes,
224         arg_type: str,
225         choices: list[str] | None,
226         arg_help: str,
227         metavar: str,
228         hide_help: bool,
229         section: str | None,
230     ) -> None:
231         super().__init__(
232             flags=flags,
233             action=action,
234             default=default,
235             arg_help=arg_help,
236             hide_help=hide_help,
237             section=section,
238         )
239 
240         self.type = _TYPE_TRANSFORMERS[arg_type]
241         """A transformer function that returns a transformed type of the argument."""
242 
243         self.choices = choices
244         """A list of possible choices for the argument.
245 
246         None if there are no restrictions.
247         """
248 
249         self.metavar = metavar
250         """The metavar of the argument.
251 
252         See:
253         https://docs.python.org/3/library/argparse.html#metavar
254         """
255 
256 
257 class _StoreTrueArgument(_BaseStoreArgument):
258     """Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.
259 
260     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
261     See:
262     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
263     """
264 
265     # pylint: disable-next=useless-super-delegation # We narrow down the type of action
266     def __init__(
267         self,
268         *,
269         flags: list[str],
270         action: Literal["store_true"],
271         default: _ArgumentTypes,
272         arg_help: str,
273         hide_help: bool,
274         section: str | None,
275     ) -> None:
276         super().__init__(
277             flags=flags,
278             action=action,
279             default=default,
280             arg_help=arg_help,
281             hide_help=hide_help,
282             section=section,
283         )
284 
285 
286 class _DeprecationArgument(_Argument):
287     """Store arguments while also handling deprecation warnings for old and new names.
288 
289     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
290     See:
291     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
292     """
293 
294     def __init__(
295         self,
296         *,
297         flags: list[str],
298         action: type[argparse.Action],
299         default: _ArgumentTypes,
300         arg_type: str,
301         choices: list[str] | None,
302         arg_help: str,
303         metavar: str,
304         hide_help: bool,
305         section: str | None,
306     ) -> None:
307         super().__init__(
308             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
309         )
310 
311         self.action = action
312         """The action to perform with the argument."""
313 
314         self.default = default
315         """The default value of the argument."""
316 
317         self.type = _TYPE_TRANSFORMERS[arg_type]
318         """A transformer function that returns a transformed type of the argument."""
319 
320         self.choices = choices
321         """A list of possible choices for the argument.
322 
323         None if there are no restrictions.
324         """
325 
326         self.metavar = metavar
327         """The metavar of the argument.
328 
329         See:
330         https://docs.python.org/3/library/argparse.html#metavar
331         """
332 
333 
334 class _ExtendArgument(_DeprecationArgument):
335     """Class for extend arguments to be parsed by an argparse.ArgumentsParser.
336 
337     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
338     See:
339     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
340     """
341 
342     def __init__(
343         self,
344         *,
345         flags: list[str],
346         action: Literal["extend"],
347         default: _ArgumentTypes,
348         arg_type: str,
349         metavar: str,
350         arg_help: str,
351         hide_help: bool,
352         section: str | None,
353         choices: list[str] | None,
354         dest: str | None,
355     ) -> None:
356         # The extend action is included in the stdlib from 3.8+
357         if PY38_PLUS:
358             action_class = argparse._ExtendAction  # type: ignore[attr-defined]
359         else:
360             action_class = _ExtendAction
361 
362         self.dest = dest
363         """The destination of the argument."""
364 
365         super().__init__(
366             flags=flags,
367             action=action_class,
368             default=default,
369             arg_type=arg_type,
370             choices=choices,
371             arg_help=arg_help,
372             metavar=metavar,
373             hide_help=hide_help,
374             section=section,
375         )
376 
377 
378 class _StoreOldNamesArgument(_DeprecationArgument):
379     """Store arguments while also handling old names.
380 
381     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
382     See:
383     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
384     """
385 
386     def __init__(
387         self,
388         *,
389         flags: list[str],
390         default: _ArgumentTypes,
391         arg_type: str,
392         choices: list[str] | None,
393         arg_help: str,
394         metavar: str,
395         hide_help: bool,
396         kwargs: dict[str, Any],
397         section: str | None,
398     ) -> None:
399         super().__init__(
400             flags=flags,
401             action=_OldNamesAction,
402             default=default,
403             arg_type=arg_type,
404             choices=choices,
405             arg_help=arg_help,
406             metavar=metavar,
407             hide_help=hide_help,
408             section=section,
409         )
410 
411         self.kwargs = kwargs
412         """Any additional arguments passed to the action."""
413 
414 
415 class _StoreNewNamesArgument(_DeprecationArgument):
416     """Store arguments while also emitting deprecation warnings.
417 
418     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
419     See:
420     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
421     """
422 
423     def __init__(
424         self,
425         *,
426         flags: list[str],
427         default: _ArgumentTypes,
428         arg_type: str,
429         choices: list[str] | None,
430         arg_help: str,
431         metavar: str,
432         hide_help: bool,
433         kwargs: dict[str, Any],
434         section: str | None,
435     ) -> None:
436         super().__init__(
437             flags=flags,
438             action=_NewNamesAction,
439             default=default,
440             arg_type=arg_type,
441             choices=choices,
442             arg_help=arg_help,
443             metavar=metavar,
444             hide_help=hide_help,
445             section=section,
446         )
447 
448         self.kwargs = kwargs
449         """Any additional arguments passed to the action."""
450 
451 
452 class _CallableArgument(_Argument):
453     """Class representing an callable argument to be parsed by an argparse.ArgumentsParser.
454 
455     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
456     See:
457     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
458     """
459 
460     def __init__(
461         self,
462         *,
463         flags: list[str],
464         action: type[_CallbackAction],
465         arg_help: str,
466         kwargs: dict[str, Any],
467         hide_help: bool,
468         section: str | None,
469         metavar: str,
470     ) -> None:
471         super().__init__(
472             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
473         )
474 
475         self.action = action
476         """The action to perform with the argument."""
477 
478         self.kwargs = kwargs
479         """Any additional arguments passed to the action."""
480 
481         self.metavar = metavar
482         """The metavar of the argument.
483 
484         See:
485         https://docs.python.org/3/library/argparse.html#metavar
486         """

</code><intended_behavior>Ignored files, paths, or patterns must consistently be excluded from the linting process, irrespective of the depth of recursion. This might require refactoring how ignore arguments are parsed, interpreted, and applied across the codebase.</intended_behavior>, <file>pylint/config/callback_actions.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 # pylint: disable=too-many-arguments, redefined-builtin, duplicate-code
6 
7 """Callback actions for various options."""
8 
9 from __future__ import annotations
10 
11 import abc
12 import argparse
13 import sys
14 import warnings
15 from collections.abc import Sequence
16 from pathlib import Path
17 from typing import TYPE_CHECKING, Any
18 
19 from pylint import exceptions, extensions, interfaces, utils
20 
21 if TYPE_CHECKING:
22     from pylint.config.help_formatter import _HelpFormatter
23     from pylint.lint import PyLinter
24     from pylint.lint.run import Run
25 
26 
27 class _CallbackAction(argparse.Action):
28     """Custom callback action."""
29 
30     @abc.abstractmethod
31     def __call__(
32         self,
33         parser: argparse.ArgumentParser,
34         namespace: argparse.Namespace,
35         values: str | Sequence[Any] | None,
36         option_string: str | None = None,
37     ) -> None:
38         raise NotImplementedError  # pragma: no cover
39 
40 
41 class _DoNothingAction(_CallbackAction):
42     """Action that just passes.
43 
44     This action is used to allow pre-processing of certain options
45     without erroring when they are then processed again by argparse.
46     """
47 
48     def __call__(
49         self,
50         parser: argparse.ArgumentParser,
51         namespace: argparse.Namespace,
52         values: str | Sequence[Any] | None,
53         option_string: str | None = None,
54     ) -> None:
55         return None
56 
57 
58 class _ExtendAction(argparse._AppendAction):
59     """Action that adds the value to a pre-existing list.
60 
61     It is directly copied from the stdlib implementation which is only available
62     on 3.8+.
63     """
64 
65     def __call__(
66         self,
67         parser: argparse.ArgumentParser,
68         namespace: argparse.Namespace,
69         values: str | Sequence[Any] | None,
70         option_string: str | None = None,
71     ) -> None:
72         assert isinstance(values, (tuple, list))
73         current = getattr(namespace, self.dest, [])
74         assert isinstance(current, list)
75         current.extend(values)
76         setattr(namespace, self.dest, current)
77 
78 
79 class _AccessRunObjectAction(_CallbackAction):
80     """Action that has access to the Run object."""
81 
82     def __init__(
83         self,
84         option_strings: Sequence[str],
85         dest: str,
86         nargs: None = None,
87         const: None = None,
88         default: None = None,
89         type: None = None,
90         choices: None = None,
91         required: bool = False,
92         help: str = "",
93         metavar: str = "",
94         **kwargs: Run,
95     ) -> None:
96         self.run = kwargs["Run"]
97 
98         super().__init__(
99             option_strings,
100             dest,
101             0,
102             const,
103             default,
104             type,
105             choices,
106             required,
107             help,
108             metavar,
109         )
110 
111     @abc.abstractmethod
112     def __call__(
113         self,
114         parser: argparse.ArgumentParser,
115         namespace: argparse.Namespace,
116         values: str | Sequence[Any] | None,
117         option_string: str | None = None,
118     ) -> None:
119         raise NotImplementedError  # pragma: no cover
120 
121 
122 class _MessageHelpAction(_CallbackAction):
123     """Display the help message of a message."""
124 
125     def __init__(
126         self,
127         option_strings: Sequence[str],
128         dest: str,
129         nargs: None = None,
130         const: None = None,
131         default: None = None,
132         type: None = None,
133         choices: None = None,
134         required: bool = False,
135         help: str = "",
136         metavar: str = "",
137         **kwargs: Run,
138     ) -> None:
139         self.run = kwargs["Run"]
140         super().__init__(
141             option_strings,
142             dest,
143             "+",
144             const,
145             default,
146             type,
147             choices,
148             required,
149             help,
150             metavar,
151         )
152 
153     def __call__(
154         self,
155         parser: argparse.ArgumentParser,
156         namespace: argparse.Namespace,
157         values: str | Sequence[str] | None,
158         option_string: str | None = "--help-msg",
159     ) -> None:
160         assert isinstance(values, (list, tuple))
161         self.run.linter.msgs_store.help_message(values)
162         sys.exit(0)
163 
164 
165 class _ListMessagesAction(_AccessRunObjectAction):
166     """Display all available messages."""
167 
168     def __call__(
169         self,
170         parser: argparse.ArgumentParser,
171         namespace: argparse.Namespace,
172         values: str | Sequence[Any] | None,
173         option_string: str | None = "--list-enabled",
174     ) -> None:
175         self.run.linter.msgs_store.list_messages()
176         sys.exit(0)
177 
178 
179 class _ListMessagesEnabledAction(_AccessRunObjectAction):
180     """Display all enabled messages."""
181 
182     def __call__(
183         self,
184         parser: argparse.ArgumentParser,
185         namespace: argparse.Namespace,
186         values: str | Sequence[Any] | None,
187         option_string: str | None = "--list-msgs-enabled",
188     ) -> None:
189         self.run.linter.list_messages_enabled()
190         sys.exit(0)
191 
192 
193 class _ListCheckGroupsAction(_AccessRunObjectAction):
194     """Display all the check groups that pylint knows about."""
195 
196     def __call__(
197         self,
198         parser: argparse.ArgumentParser,
199         namespace: argparse.Namespace,
200         values: str | Sequence[Any] | None,
201         option_string: str | None = "--list-groups",
202     ) -> None:
203         for check in self.run.linter.get_checker_names():
204             print(check)
205         sys.exit(0)
206 
207 
208 class _ListConfidenceLevelsAction(_AccessRunObjectAction):
209     """Display all the confidence levels that pylint knows about."""
210 
211     def __call__(
212         self,
213         parser: argparse.ArgumentParser,
214         namespace: argparse.Namespace,
215         values: str | Sequence[Any] | None,
216         option_string: str | None = "--list-conf-levels",
217     ) -> None:
218         for level in interfaces.CONFIDENCE_LEVELS:
219             print(f"%-18s: {level}")
220         sys.exit(0)
221 
222 
223 class _ListExtensionsAction(_AccessRunObjectAction):
224     """Display all extensions under pylint.extensions."""
225 
226     def __call__(
227         self,
228         parser: argparse.ArgumentParser,
229         namespace: argparse.Namespace,
230         values: str | Sequence[Any] | None,
231         option_string: str | None = "--list-extensions",
232     ) -> None:
233         for filename in Path(extensions.__file__).parent.iterdir():
234             if filename.suffix == ".py" and not filename.stem.startswith("_"):
235                 extension_name, _, _ = filename.stem.partition(".")
236                 print(f"pylint.extensions.{extension_name}")
237         sys.exit(0)
238 
239 
240 class _FullDocumentationAction(_AccessRunObjectAction):
241     """Display the full documentation."""
242 
243     def __call__(
244         self,
245         parser: argparse.ArgumentParser,
246         namespace: argparse.Namespace,
247         values: str | Sequence[Any] | None,
248         option_string: str | None = "--full-documentation",
249     ) -> None:
250         utils.print_full_documentation(self.run.linter)
251         sys.exit(0)
252 
253 
254 class _GenerateRCFileAction(_AccessRunObjectAction):
255     """Generate a pylintrc file."""
256 
257     def __call__(
258         self,
259         parser: argparse.ArgumentParser,
260         namespace: argparse.Namespace,
261         values: str | Sequence[Any] | None,
262         option_string: str | None = "--generate-rcfile",
263     ) -> None:
264         # TODO: 2.14: Deprecate this after discussion about this removal has been completed.
265         with warnings.catch_warnings():
266             warnings.filterwarnings("ignore", category=DeprecationWarning)
267             self.run.linter.generate_config(skipsections=("Commands",))
268         sys.exit(0)
269 
270 
271 class _GenerateConfigFileAction(_AccessRunObjectAction):
272     """Generate a .toml format configuration file."""
273 
274     def __call__(
275         self,
276         parser: argparse.ArgumentParser,
277         namespace: argparse.Namespace,
278         values: str | Sequence[Any] | None,
279         option_string: str | None = "--generate-toml-config",
280     ) -> None:
281         self.run.linter._generate_config_file()
282         sys.exit(0)
283 
284 
285 class _ErrorsOnlyModeAction(_AccessRunObjectAction):
286     """Turn on errors-only mode.
287 
288     Error mode:
289         * disable all but error messages
290         * disable the 'miscellaneous' checker which can be safely deactivated in
291           debug
292         * disable reports
293         * do not save execution information
294     """
295 
296     def __call__(
297         self,
298         parser: argparse.ArgumentParser,
299         namespace: argparse.Namespace,
300         values: str | Sequence[Any] | None,
301         option_string: str | None = "--errors-only",
302     ) -> None:
303         self.run.linter._error_mode = True
304 
305 
306 class _LongHelpAction(_AccessRunObjectAction):
307     """Display the long help message."""
308 
309     def __call__(
310         self,
311         parser: argparse.ArgumentParser,
312         namespace: argparse.Namespace,
313         values: str | Sequence[Any] | None,
314         option_string: str | None = "--long-help",
315     ) -> None:
316         formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter()  # type: ignore[assignment]
317 
318         # Add extra info as epilog to the help message
319         self.run.linter._arg_parser.epilog = formatter.get_long_description()
320         print(self.run.linter.help())
321 
322         sys.exit(0)
323 
324 
325 class _AccessLinterObjectAction(_CallbackAction):
326     """Action that has access to the Linter object."""
327 
328     def __init__(
329         self,
330         option_strings: Sequence[str],
331         dest: str,
332         nargs: None = None,
333         const: None = None,
334         default: None = None,
335         type: None = None,
336         choices: None = None,
337         required: bool = False,
338         help: str = "",
339         metavar: str = "",
340         **kwargs: PyLinter,
341     ) -> None:
342         self.linter = kwargs["linter"]
343 
344         super().__init__(
345             option_strings,
346             dest,
347             1,
348             const,
349             default,
350             type,
351             choices,
352             required,
353             help,
354             metavar,
355         )
356 
357     @abc.abstractmethod
358     def __call__(
359         self,
360         parser: argparse.ArgumentParser,
361         namespace: argparse.Namespace,
362         values: str | Sequence[Any] | None,
363         option_string: str | None = None,
364     ) -> None:
365         raise NotImplementedError  # pragma: no cover
366 
367 
368 class _DisableAction(_AccessLinterObjectAction):
369     """Callback action for disabling a message."""
370 
371     def __call__(
372         self,
373         parser: argparse.ArgumentParser,
374         namespace: argparse.Namespace,
375         values: str | Sequence[Any] | None,
376         option_string: str | None = "--disable",
377     ) -> None:
378         assert isinstance(values, (tuple, list))
379         msgids = utils._check_csv(values[0])
380         for msgid in msgids:
381             try:
382                 self.linter.disable(msgid)
383             except exceptions.UnknownMessageError:
384                 msg = f"{option_string}. Don't recognize message {msgid}."
385                 self.linter.add_message("bad-option-value", args=msg, line=0)
386 
387 
388 class _EnableAction(_AccessLinterObjectAction):
389     """Callback action for enabling a message."""
390 
391     def __call__(
392         self,
393         parser: argparse.ArgumentParser,
394         namespace: argparse.Namespace,
395         values: str | Sequence[Any] | None,
396         option_string: str | None = "--enable",
397     ) -> None:
398         assert isinstance(values, (tuple, list))
399         msgids = utils._check_csv(values[0])
400         for msgid in msgids:
401             try:
402                 self.linter.enable(msgid)
403             except exceptions.UnknownMessageError:
404                 msg = f"{option_string}. Don't recognize message {msgid}."
405                 self.linter.add_message("bad-option-value", args=msg, line=0)
406 
407 
408 class _OutputFormatAction(_AccessLinterObjectAction):
409     """Callback action for setting the output format."""
410 
411     def __call__(
412         self,
413         parser: argparse.ArgumentParser,
414         namespace: argparse.Namespace,
415         values: str | Sequence[Any] | None,
416         option_string: str | None = "--enable",
417     ) -> None:
418         assert isinstance(values, (tuple, list))
419         assert isinstance(
420             values[0], str
421         ), "'output-format' should be a comma separated string of reporters"
422         self.linter._load_reporters(values[0])

</code><intended_behavior>This exclusion logic should be centralized or consistently applied across different modules to ensure uniform behavior. Preserve the existing functionality of ignore settings while ensuring they are respected in recursive file analysis scenarios.</intended_behavior>]
2025-10-15 09:30:42.619 | INFO     | Search completed. Bug locations: [<file>pylint/config/argument.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Definition of an Argument class and transformers for various argument types.
6 
7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser
8 """
9 
10 from __future__ import annotations
11 
12 import argparse
13 import os
14 import pathlib
15 import re
16 import sys
17 from collections.abc import Callable
18 from typing import Any, Pattern, Sequence, Tuple, Union
19 
20 from pylint import interfaces
21 from pylint import utils as pylint_utils
22 from pylint.config.callback_actions import _CallbackAction, _ExtendAction
23 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction
24 from pylint.constants import PY38_PLUS
25 
26 if sys.version_info >= (3, 8):
27     from typing import Literal
28 else:
29     from typing_extensions import Literal
30 
31 
32 _ArgumentTypes = Union[
33     str,
34     int,
35     float,
36     bool,
37     Pattern[str],
38     Sequence[str],
39     Sequence[Pattern[str]],
40     Tuple[int, ...],
41 ]
42 """List of possible argument types."""
43 
44 
45 def _confidence_transformer(value: str) -> Sequence[str]:
46     """Transforms a comma separated string of confidence values."""
47     if not value:
48         return interfaces.CONFIDENCE_LEVEL_NAMES
49     values = pylint_utils._check_csv(value)
50     for confidence in values:
51         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:
52             raise argparse.ArgumentTypeError(
53                 f"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}"
54             )
55     return values
56 
57 
58 def _csv_transformer(value: str) -> Sequence[str]:
59     """Transforms a comma separated string."""
60     return pylint_utils._check_csv(value)
61 
62 
63 YES_VALUES = {"y", "yes", "true"}
64 NO_VALUES = {"n", "no", "false"}
65 
66 
67 def _yn_transformer(value: str) -> bool:
68     """Transforms a yes/no or stringified bool into a bool."""
69     value = value.lower()
70     if value in YES_VALUES:
71         return True
72     if value in NO_VALUES:
73         return False
74     raise argparse.ArgumentTypeError(
75         None, f"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}"
76     )
77 
78 
79 def _non_empty_string_transformer(value: str) -> str:
80     """Check that a string is not empty and remove quotes."""
81     if not value:
82         raise argparse.ArgumentTypeError("Option cannot be an empty string.")
83     return pylint_utils._unquote(value)
84 
85 
86 def _path_transformer(value: str) -> str:
87     """Expand user and variables in a path."""
88     return os.path.expandvars(os.path.expanduser(value))
89 
90 
91 def _py_version_transformer(value: str) -> tuple[int, ...]:
92     """Transforms a version string into a version tuple."""
93     try:
94         version = tuple(int(val) for val in value.replace(",", ".").split("."))
95     except ValueError:
96         raise argparse.ArgumentTypeError(
97             f"{value} has an invalid format, should be a version string. E.g., '3.8'"
98         ) from None
99     return version
100 
101 
102 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
103     """Transforms a comma separated list of regular expressions."""
104     patterns: list[Pattern[str]] = []
105     for pattern in _csv_transformer(value):
106         patterns.append(re.compile(pattern))
107     return patterns
108 
109 
110 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
111     """Transforms a comma separated list of regular expressions paths."""
112     patterns: list[Pattern[str]] = []
113     for pattern in _csv_transformer(value):
114         patterns.append(
115             re.compile(
116                 str(pathlib.PureWindowsPath(pattern)).replace("\\", "\\\\")
117                 + "|"
118                 + pathlib.PureWindowsPath(pattern).as_posix()
119             )
120         )
121     return patterns
122 
123 
124 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {
125     "choice": str,
126     "csv": _csv_transformer,
127     "float": float,
128     "int": int,
129     "confidence": _confidence_transformer,
130     "non_empty_string": _non_empty_string_transformer,
131     "path": _path_transformer,
132     "py_version": _py_version_transformer,
133     "regexp": re.compile,
134     "regexp_csv": _regexp_csv_transfomer,
135     "regexp_paths_csv": _regexp_paths_csv_transfomer,
136     "string": pylint_utils._unquote,
137     "yn": _yn_transformer,
138 }
139 """Type transformers for all argument types.
140 
141 A transformer should accept a string and return one of the supported
142 Argument types. It will only be called when parsing 1) command-line,
143 2) configuration files and 3) a string default value.
144 Non-string default values are assumed to be of the correct type.
145 """
146 
147 
148 class _Argument:
149     """Class representing an argument to be parsed by an argparse.ArgumentsParser.
150 
151     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
152     See:
153     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
154     """
155 
156     def __init__(
157         self,
158         *,
159         flags: list[str],
160         arg_help: str,
161         hide_help: bool,
162         section: str | None,
163     ) -> None:
164         self.flags = flags
165         """The name of the argument."""
166 
167         self.hide_help = hide_help
168         """Whether to hide this argument in the help message."""
169 
170         # argparse uses % formatting on help strings, so a % needs to be escaped
171         self.help = arg_help.replace("%", "%%")
172         """The description of the argument."""
173 
174         if hide_help:
175             self.help = argparse.SUPPRESS
176 
177         self.section = section
178         """The section to add this argument to."""
179 
180 
181 class _BaseStoreArgument(_Argument):
182     """Base class for store arguments to be parsed by an argparse.ArgumentsParser.
183 
184     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
185     See:
186     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
187     """
188 
189     def __init__(
190         self,
191         *,
192         flags: list[str],
193         action: str,
194         default: _ArgumentTypes,
195         arg_help: str,
196         hide_help: bool,
197         section: str | None,
198     ) -> None:
199         super().__init__(
200             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
201         )
202 
203         self.action = action
204         """The action to perform with the argument."""
205 
206         self.default = default
207         """The default value of the argument."""
208 
209 
210 class _StoreArgument(_BaseStoreArgument):
211     """Class representing a store argument to be parsed by an argparse.ArgumentsParser.
212 
213     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
214     See:
215     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
216     """
217 
218     def __init__(
219         self,
220         *,
221         flags: list[str],
222         action: str,
223         default: _ArgumentTypes,
224         arg_type: str,
225         choices: list[str] | None,
226         arg_help: str,
227         metavar: str,
228         hide_help: bool,
229         section: str | None,
230     ) -> None:
231         super().__init__(
232             flags=flags,
233             action=action,
234             default=default,
235             arg_help=arg_help,
236             hide_help=hide_help,
237             section=section,
238         )
239 
240         self.type = _TYPE_TRANSFORMERS[arg_type]
241         """A transformer function that returns a transformed type of the argument."""
242 
243         self.choices = choices
244         """A list of possible choices for the argument.
245 
246         None if there are no restrictions.
247         """
248 
249         self.metavar = metavar
250         """The metavar of the argument.
251 
252         See:
253         https://docs.python.org/3/library/argparse.html#metavar
254         """
255 
256 
257 class _StoreTrueArgument(_BaseStoreArgument):
258     """Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.
259 
260     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
261     See:
262     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
263     """
264 
265     # pylint: disable-next=useless-super-delegation # We narrow down the type of action
266     def __init__(
267         self,
268         *,
269         flags: list[str],
270         action: Literal["store_true"],
271         default: _ArgumentTypes,
272         arg_help: str,
273         hide_help: bool,
274         section: str | None,
275     ) -> None:
276         super().__init__(
277             flags=flags,
278             action=action,
279             default=default,
280             arg_help=arg_help,
281             hide_help=hide_help,
282             section=section,
283         )
284 
285 
286 class _DeprecationArgument(_Argument):
287     """Store arguments while also handling deprecation warnings for old and new names.
288 
289     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
290     See:
291     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
292     """
293 
294     def __init__(
295         self,
296         *,
297         flags: list[str],
298         action: type[argparse.Action],
299         default: _ArgumentTypes,
300         arg_type: str,
301         choices: list[str] | None,
302         arg_help: str,
303         metavar: str,
304         hide_help: bool,
305         section: str | None,
306     ) -> None:
307         super().__init__(
308             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
309         )
310 
311         self.action = action
312         """The action to perform with the argument."""
313 
314         self.default = default
315         """The default value of the argument."""
316 
317         self.type = _TYPE_TRANSFORMERS[arg_type]
318         """A transformer function that returns a transformed type of the argument."""
319 
320         self.choices = choices
321         """A list of possible choices for the argument.
322 
323         None if there are no restrictions.
324         """
325 
326         self.metavar = metavar
327         """The metavar of the argument.
328 
329         See:
330         https://docs.python.org/3/library/argparse.html#metavar
331         """
332 
333 
334 class _ExtendArgument(_DeprecationArgument):
335     """Class for extend arguments to be parsed by an argparse.ArgumentsParser.
336 
337     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
338     See:
339     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
340     """
341 
342     def __init__(
343         self,
344         *,
345         flags: list[str],
346         action: Literal["extend"],
347         default: _ArgumentTypes,
348         arg_type: str,
349         metavar: str,
350         arg_help: str,
351         hide_help: bool,
352         section: str | None,
353         choices: list[str] | None,
354         dest: str | None,
355     ) -> None:
356         # The extend action is included in the stdlib from 3.8+
357         if PY38_PLUS:
358             action_class = argparse._ExtendAction  # type: ignore[attr-defined]
359         else:
360             action_class = _ExtendAction
361 
362         self.dest = dest
363         """The destination of the argument."""
364 
365         super().__init__(
366             flags=flags,
367             action=action_class,
368             default=default,
369             arg_type=arg_type,
370             choices=choices,
371             arg_help=arg_help,
372             metavar=metavar,
373             hide_help=hide_help,
374             section=section,
375         )
376 
377 
378 class _StoreOldNamesArgument(_DeprecationArgument):
379     """Store arguments while also handling old names.
380 
381     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
382     See:
383     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
384     """
385 
386     def __init__(
387         self,
388         *,
389         flags: list[str],
390         default: _ArgumentTypes,
391         arg_type: str,
392         choices: list[str] | None,
393         arg_help: str,
394         metavar: str,
395         hide_help: bool,
396         kwargs: dict[str, Any],
397         section: str | None,
398     ) -> None:
399         super().__init__(
400             flags=flags,
401             action=_OldNamesAction,
402             default=default,
403             arg_type=arg_type,
404             choices=choices,
405             arg_help=arg_help,
406             metavar=metavar,
407             hide_help=hide_help,
408             section=section,
409         )
410 
411         self.kwargs = kwargs
412         """Any additional arguments passed to the action."""
413 
414 
415 class _StoreNewNamesArgument(_DeprecationArgument):
416     """Store arguments while also emitting deprecation warnings.
417 
418     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
419     See:
420     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
421     """
422 
423     def __init__(
424         self,
425         *,
426         flags: list[str],
427         default: _ArgumentTypes,
428         arg_type: str,
429         choices: list[str] | None,
430         arg_help: str,
431         metavar: str,
432         hide_help: bool,
433         kwargs: dict[str, Any],
434         section: str | None,
435     ) -> None:
436         super().__init__(
437             flags=flags,
438             action=_NewNamesAction,
439             default=default,
440             arg_type=arg_type,
441             choices=choices,
442             arg_help=arg_help,
443             metavar=metavar,
444             hide_help=hide_help,
445             section=section,
446         )
447 
448         self.kwargs = kwargs
449         """Any additional arguments passed to the action."""
450 
451 
452 class _CallableArgument(_Argument):
453     """Class representing an callable argument to be parsed by an argparse.ArgumentsParser.
454 
455     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
456     See:
457     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
458     """
459 
460     def __init__(
461         self,
462         *,
463         flags: list[str],
464         action: type[_CallbackAction],
465         arg_help: str,
466         kwargs: dict[str, Any],
467         hide_help: bool,
468         section: str | None,
469         metavar: str,
470     ) -> None:
471         super().__init__(
472             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
473         )
474 
475         self.action = action
476         """The action to perform with the argument."""
477 
478         self.kwargs = kwargs
479         """Any additional arguments passed to the action."""
480 
481         self.metavar = metavar
482         """The metavar of the argument.
483 
484         See:
485         https://docs.python.org/3/library/argparse.html#metavar
486         """

</code><intended_behavior>Ignored files, paths, or patterns must consistently be excluded from the linting process, irrespective of the depth of recursion. This might require refactoring how ignore arguments are parsed, interpreted, and applied across the codebase.</intended_behavior>, <file>pylint/config/callback_actions.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 # pylint: disable=too-many-arguments, redefined-builtin, duplicate-code
6 
7 """Callback actions for various options."""
8 
9 from __future__ import annotations
10 
11 import abc
12 import argparse
13 import sys
14 import warnings
15 from collections.abc import Sequence
16 from pathlib import Path
17 from typing import TYPE_CHECKING, Any
18 
19 from pylint import exceptions, extensions, interfaces, utils
20 
21 if TYPE_CHECKING:
22     from pylint.config.help_formatter import _HelpFormatter
23     from pylint.lint import PyLinter
24     from pylint.lint.run import Run
25 
26 
27 class _CallbackAction(argparse.Action):
28     """Custom callback action."""
29 
30     @abc.abstractmethod
31     def __call__(
32         self,
33         parser: argparse.ArgumentParser,
34         namespace: argparse.Namespace,
35         values: str | Sequence[Any] | None,
36         option_string: str | None = None,
37     ) -> None:
38         raise NotImplementedError  # pragma: no cover
39 
40 
41 class _DoNothingAction(_CallbackAction):
42     """Action that just passes.
43 
44     This action is used to allow pre-processing of certain options
45     without erroring when they are then processed again by argparse.
46     """
47 
48     def __call__(
49         self,
50         parser: argparse.ArgumentParser,
51         namespace: argparse.Namespace,
52         values: str | Sequence[Any] | None,
53         option_string: str | None = None,
54     ) -> None:
55         return None
56 
57 
58 class _ExtendAction(argparse._AppendAction):
59     """Action that adds the value to a pre-existing list.
60 
61     It is directly copied from the stdlib implementation which is only available
62     on 3.8+.
63     """
64 
65     def __call__(
66         self,
67         parser: argparse.ArgumentParser,
68         namespace: argparse.Namespace,
69         values: str | Sequence[Any] | None,
70         option_string: str | None = None,
71     ) -> None:
72         assert isinstance(values, (tuple, list))
73         current = getattr(namespace, self.dest, [])
74         assert isinstance(current, list)
75         current.extend(values)
76         setattr(namespace, self.dest, current)
77 
78 
79 class _AccessRunObjectAction(_CallbackAction):
80     """Action that has access to the Run object."""
81 
82     def __init__(
83         self,
84         option_strings: Sequence[str],
85         dest: str,
86         nargs: None = None,
87         const: None = None,
88         default: None = None,
89         type: None = None,
90         choices: None = None,
91         required: bool = False,
92         help: str = "",
93         metavar: str = "",
94         **kwargs: Run,
95     ) -> None:
96         self.run = kwargs["Run"]
97 
98         super().__init__(
99             option_strings,
100             dest,
101             0,
102             const,
103             default,
104             type,
105             choices,
106             required,
107             help,
108             metavar,
109         )
110 
111     @abc.abstractmethod
112     def __call__(
113         self,
114         parser: argparse.ArgumentParser,
115         namespace: argparse.Namespace,
116         values: str | Sequence[Any] | None,
117         option_string: str | None = None,
118     ) -> None:
119         raise NotImplementedError  # pragma: no cover
120 
121 
122 class _MessageHelpAction(_CallbackAction):
123     """Display the help message of a message."""
124 
125     def __init__(
126         self,
127         option_strings: Sequence[str],
128         dest: str,
129         nargs: None = None,
130         const: None = None,
131         default: None = None,
132         type: None = None,
133         choices: None = None,
134         required: bool = False,
135         help: str = "",
136         metavar: str = "",
137         **kwargs: Run,
138     ) -> None:
139         self.run = kwargs["Run"]
140         super().__init__(
141             option_strings,
142             dest,
143             "+",
144             const,
145             default,
146             type,
147             choices,
148             required,
149             help,
150             metavar,
151         )
152 
153     def __call__(
154         self,
155         parser: argparse.ArgumentParser,
156         namespace: argparse.Namespace,
157         values: str | Sequence[str] | None,
158         option_string: str | None = "--help-msg",
159     ) -> None:
160         assert isinstance(values, (list, tuple))
161         self.run.linter.msgs_store.help_message(values)
162         sys.exit(0)
163 
164 
165 class _ListMessagesAction(_AccessRunObjectAction):
166     """Display all available messages."""
167 
168     def __call__(
169         self,
170         parser: argparse.ArgumentParser,
171         namespace: argparse.Namespace,
172         values: str | Sequence[Any] | None,
173         option_string: str | None = "--list-enabled",
174     ) -> None:
175         self.run.linter.msgs_store.list_messages()
176         sys.exit(0)
177 
178 
179 class _ListMessagesEnabledAction(_AccessRunObjectAction):
180     """Display all enabled messages."""
181 
182     def __call__(
183         self,
184         parser: argparse.ArgumentParser,
185         namespace: argparse.Namespace,
186         values: str | Sequence[Any] | None,
187         option_string: str | None = "--list-msgs-enabled",
188     ) -> None:
189         self.run.linter.list_messages_enabled()
190         sys.exit(0)
191 
192 
193 class _ListCheckGroupsAction(_AccessRunObjectAction):
194     """Display all the check groups that pylint knows about."""
195 
196     def __call__(
197         self,
198         parser: argparse.ArgumentParser,
199         namespace: argparse.Namespace,
200         values: str | Sequence[Any] | None,
201         option_string: str | None = "--list-groups",
202     ) -> None:
203         for check in self.run.linter.get_checker_names():
204             print(check)
205         sys.exit(0)
206 
207 
208 class _ListConfidenceLevelsAction(_AccessRunObjectAction):
209     """Display all the confidence levels that pylint knows about."""
210 
211     def __call__(
212         self,
213         parser: argparse.ArgumentParser,
214         namespace: argparse.Namespace,
215         values: str | Sequence[Any] | None,
216         option_string: str | None = "--list-conf-levels",
217     ) -> None:
218         for level in interfaces.CONFIDENCE_LEVELS:
219             print(f"%-18s: {level}")
220         sys.exit(0)
221 
222 
223 class _ListExtensionsAction(_AccessRunObjectAction):
224     """Display all extensions under pylint.extensions."""
225 
226     def __call__(
227         self,
228         parser: argparse.ArgumentParser,
229         namespace: argparse.Namespace,
230         values: str | Sequence[Any] | None,
231         option_string: str | None = "--list-extensions",
232     ) -> None:
233         for filename in Path(extensions.__file__).parent.iterdir():
234             if filename.suffix == ".py" and not filename.stem.startswith("_"):
235                 extension_name, _, _ = filename.stem.partition(".")
236                 print(f"pylint.extensions.{extension_name}")
237         sys.exit(0)
238 
239 
240 class _FullDocumentationAction(_AccessRunObjectAction):
241     """Display the full documentation."""
242 
243     def __call__(
244         self,
245         parser: argparse.ArgumentParser,
246         namespace: argparse.Namespace,
247         values: str | Sequence[Any] | None,
248         option_string: str | None = "--full-documentation",
249     ) -> None:
250         utils.print_full_documentation(self.run.linter)
251         sys.exit(0)
252 
253 
254 class _GenerateRCFileAction(_AccessRunObjectAction):
255     """Generate a pylintrc file."""
256 
257     def __call__(
258         self,
259         parser: argparse.ArgumentParser,
260         namespace: argparse.Namespace,
261         values: str | Sequence[Any] | None,
262         option_string: str | None = "--generate-rcfile",
263     ) -> None:
264         # TODO: 2.14: Deprecate this after discussion about this removal has been completed.
265         with warnings.catch_warnings():
266             warnings.filterwarnings("ignore", category=DeprecationWarning)
267             self.run.linter.generate_config(skipsections=("Commands",))
268         sys.exit(0)
269 
270 
271 class _GenerateConfigFileAction(_AccessRunObjectAction):
272     """Generate a .toml format configuration file."""
273 
274     def __call__(
275         self,
276         parser: argparse.ArgumentParser,
277         namespace: argparse.Namespace,
278         values: str | Sequence[Any] | None,
279         option_string: str | None = "--generate-toml-config",
280     ) -> None:
281         self.run.linter._generate_config_file()
282         sys.exit(0)
283 
284 
285 class _ErrorsOnlyModeAction(_AccessRunObjectAction):
286     """Turn on errors-only mode.
287 
288     Error mode:
289         * disable all but error messages
290         * disable the 'miscellaneous' checker which can be safely deactivated in
291           debug
292         * disable reports
293         * do not save execution information
294     """
295 
296     def __call__(
297         self,
298         parser: argparse.ArgumentParser,
299         namespace: argparse.Namespace,
300         values: str | Sequence[Any] | None,
301         option_string: str | None = "--errors-only",
302     ) -> None:
303         self.run.linter._error_mode = True
304 
305 
306 class _LongHelpAction(_AccessRunObjectAction):
307     """Display the long help message."""
308 
309     def __call__(
310         self,
311         parser: argparse.ArgumentParser,
312         namespace: argparse.Namespace,
313         values: str | Sequence[Any] | None,
314         option_string: str | None = "--long-help",
315     ) -> None:
316         formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter()  # type: ignore[assignment]
317 
318         # Add extra info as epilog to the help message
319         self.run.linter._arg_parser.epilog = formatter.get_long_description()
320         print(self.run.linter.help())
321 
322         sys.exit(0)
323 
324 
325 class _AccessLinterObjectAction(_CallbackAction):
326     """Action that has access to the Linter object."""
327 
328     def __init__(
329         self,
330         option_strings: Sequence[str],
331         dest: str,
332         nargs: None = None,
333         const: None = None,
334         default: None = None,
335         type: None = None,
336         choices: None = None,
337         required: bool = False,
338         help: str = "",
339         metavar: str = "",
340         **kwargs: PyLinter,
341     ) -> None:
342         self.linter = kwargs["linter"]
343 
344         super().__init__(
345             option_strings,
346             dest,
347             1,
348             const,
349             default,
350             type,
351             choices,
352             required,
353             help,
354             metavar,
355         )
356 
357     @abc.abstractmethod
358     def __call__(
359         self,
360         parser: argparse.ArgumentParser,
361         namespace: argparse.Namespace,
362         values: str | Sequence[Any] | None,
363         option_string: str | None = None,
364     ) -> None:
365         raise NotImplementedError  # pragma: no cover
366 
367 
368 class _DisableAction(_AccessLinterObjectAction):
369     """Callback action for disabling a message."""
370 
371     def __call__(
372         self,
373         parser: argparse.ArgumentParser,
374         namespace: argparse.Namespace,
375         values: str | Sequence[Any] | None,
376         option_string: str | None = "--disable",
377     ) -> None:
378         assert isinstance(values, (tuple, list))
379         msgids = utils._check_csv(values[0])
380         for msgid in msgids:
381             try:
382                 self.linter.disable(msgid)
383             except exceptions.UnknownMessageError:
384                 msg = f"{option_string}. Don't recognize message {msgid}."
385                 self.linter.add_message("bad-option-value", args=msg, line=0)
386 
387 
388 class _EnableAction(_AccessLinterObjectAction):
389     """Callback action for enabling a message."""
390 
391     def __call__(
392         self,
393         parser: argparse.ArgumentParser,
394         namespace: argparse.Namespace,
395         values: str | Sequence[Any] | None,
396         option_string: str | None = "--enable",
397     ) -> None:
398         assert isinstance(values, (tuple, list))
399         msgids = utils._check_csv(values[0])
400         for msgid in msgids:
401             try:
402                 self.linter.enable(msgid)
403             except exceptions.UnknownMessageError:
404                 msg = f"{option_string}. Don't recognize message {msgid}."
405                 self.linter.add_message("bad-option-value", args=msg, line=0)
406 
407 
408 class _OutputFormatAction(_AccessLinterObjectAction):
409     """Callback action for setting the output format."""
410 
411     def __call__(
412         self,
413         parser: argparse.ArgumentParser,
414         namespace: argparse.Namespace,
415         values: str | Sequence[Any] | None,
416         option_string: str | None = "--enable",
417     ) -> None:
418         assert isinstance(values, (tuple, list))
419         assert isinstance(
420             values[0], str
421         ), "'output-format' should be a comma separated string of reporters"
422         self.linter._load_reporters(values[0])

</code><intended_behavior>This exclusion logic should be centralized or consistently applied across different modules to ensure uniform behavior. Preserve the existing functionality of ignore settings while ensuring they are respected in recursive file analysis scenarios.</intended_behavior>]
2025-10-15 09:30:42.619 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 09:30:42.619 | INFO     | Search-only: skipping patch selection
2025-10-15 09:30:42.706 | INFO     | Task pylint-dev__pylint-6528 completed successfully.
2025-10-15 09:30:42.707 | INFO     | No patch generated. You can try running ACR again.
