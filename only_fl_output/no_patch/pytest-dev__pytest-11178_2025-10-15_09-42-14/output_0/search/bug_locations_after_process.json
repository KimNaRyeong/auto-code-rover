[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 426,
        "end": 465,
        "class_name": "ApproxScalar",
        "method_name": "__eq__",
        "code": "426     def __eq__(self, actual) -> bool:\n427         \"\"\"Return whether the given value is equal to the expected value\n428         within the pre-specified tolerance.\"\"\"\n429         asarray = _as_numpy_array(actual)\n430         if asarray is not None:\n431             # Call ``__eq__()`` manually to prevent infinite-recursion with\n432             # numpy<1.13.  See #3748.\n433             return all(self.__eq__(a) for a in asarray.flat)\n434 \n435         # Short-circuit exact equality.\n436         if actual == self.expected:\n437             return True\n438 \n439         # If either type is non-numeric, fall back to strict equality.\n440         # NB: we need Complex, rather than just Number, to ensure that __abs__,\n441         # __sub__, and __float__ are defined.\n442         if not (\n443             isinstance(self.expected, (Complex, Decimal))\n444             and isinstance(actual, (Complex, Decimal))\n445         ):\n446             return False\n447 \n448         # Allow the user to control whether NaNs are considered equal to each\n449         # other or not.  The abs() calls are for compatibility with complex\n450         # numbers.\n451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]\n452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]\n453 \n454         # Infinity shouldn't be approximately equal to anything but itself, but\n455         # if there's a relative tolerance, it will be infinite and infinity\n456         # will seem approximately equal to everything.  The equal-to-itself\n457         # case would have been short circuited above, so here we can just\n458         # return false if the expected value is infinite.  The abs() call is\n459         # for compatibility with complex numbers.\n460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]\n461             return False\n462 \n463         # Return true if the two numbers are within the tolerance.\n464         result: bool = abs(self.expected - actual) <= self.tolerance\n465         return result\n",
        "intended_behavior": "The `__eq__` method in the `ApproxScalar` class should be updated to explicitly handle cases where the `actual` value is `None`. Before proceeding with any numerical comparisons or checks for non-numeric types, it should check if `actual` is `None` and return `False`. This ensures that the method aligns with the principle of generating clear, understandable error messages or results when a comparison involves `None` and a numeric type. This adjustment will prevent the method from attempting subtractive operations or other numeric comparisons that result in a `TypeError` when one of the operands is `None`. This change must be made while ensuring that the existing functionality for numerical and non-numeric comparisons remains unaffected."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 389,
        "end": 515,
        "class_name": "ApproxScalar",
        "method_name": null,
        "code": "389 class ApproxScalar(ApproxBase):\n390     \"\"\"Perform approximate comparisons where the expected value is a single number.\"\"\"\n391 \n392     # Using Real should be better than this Union, but not possible yet:\n393     # https://github.com/python/typeshed/pull/3108\n394     DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12\n395     DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6\n396 \n397     def __repr__(self) -> str:\n398         \"\"\"Return a string communicating both the expected value and the\n399         tolerance for the comparison being made.\n400 \n401         For example, ``1.0 \u00b1 1e-6``, ``(3+4j) \u00b1 5e-6 \u2220 \u00b1180\u00b0``.\n402         \"\"\"\n403         # Don't show a tolerance for values that aren't compared using\n404         # tolerances, i.e. non-numerics and infinities. Need to call abs to\n405         # handle complex numbers, e.g. (inf + 1j).\n406         if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(\n407             abs(self.expected)  # type: ignore[arg-type]\n408         ):\n409             return str(self.expected)\n410 \n411         # If a sensible tolerance can't be calculated, self.tolerance will\n412         # raise a ValueError.  In this case, display '???'.\n413         try:\n414             vetted_tolerance = f\"{self.tolerance:.1e}\"\n415             if (\n416                 isinstance(self.expected, Complex)\n417                 and self.expected.imag\n418                 and not math.isinf(self.tolerance)\n419             ):\n420                 vetted_tolerance += \" \u2220 \u00b1180\u00b0\"\n421         except ValueError:\n422             vetted_tolerance = \"???\"\n423 \n424         return f\"{self.expected} \u00b1 {vetted_tolerance}\"\n425 \n426     def __eq__(self, actual) -> bool:\n427         \"\"\"Return whether the given value is equal to the expected value\n428         within the pre-specified tolerance.\"\"\"\n429         asarray = _as_numpy_array(actual)\n430         if asarray is not None:\n431             # Call ``__eq__()`` manually to prevent infinite-recursion with\n432             # numpy<1.13.  See #3748.\n433             return all(self.__eq__(a) for a in asarray.flat)\n434 \n435         # Short-circuit exact equality.\n436         if actual == self.expected:\n437             return True\n438 \n439         # If either type is non-numeric, fall back to strict equality.\n440         # NB: we need Complex, rather than just Number, to ensure that __abs__,\n441         # __sub__, and __float__ are defined.\n442         if not (\n443             isinstance(self.expected, (Complex, Decimal))\n444             and isinstance(actual, (Complex, Decimal))\n445         ):\n446             return False\n447 \n448         # Allow the user to control whether NaNs are considered equal to each\n449         # other or not.  The abs() calls are for compatibility with complex\n450         # numbers.\n451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]\n452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]\n453 \n454         # Infinity shouldn't be approximately equal to anything but itself, but\n455         # if there's a relative tolerance, it will be infinite and infinity\n456         # will seem approximately equal to everything.  The equal-to-itself\n457         # case would have been short circuited above, so here we can just\n458         # return false if the expected value is infinite.  The abs() call is\n459         # for compatibility with complex numbers.\n460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]\n461             return False\n462 \n463         # Return true if the two numbers are within the tolerance.\n464         result: bool = abs(self.expected - actual) <= self.tolerance\n465         return result\n466 \n467     # Ignore type because of https://github.com/python/mypy/issues/4266.\n468     __hash__ = None  # type: ignore\n469 \n470     @property\n471     def tolerance(self):\n472         \"\"\"Return the tolerance for the comparison.\n473 \n474         This could be either an absolute tolerance or a relative tolerance,\n475         depending on what the user specified or which would be larger.\n476         \"\"\"\n477 \n478         def set_default(x, default):\n479             return x if x is not None else default\n480 \n481         # Figure out what the absolute tolerance should be.  ``self.abs`` is\n482         # either None or a value specified by the user.\n483         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n484 \n485         if absolute_tolerance < 0:\n486             raise ValueError(\n487                 f\"absolute tolerance can't be negative: {absolute_tolerance}\"\n488             )\n489         if math.isnan(absolute_tolerance):\n490             raise ValueError(\"absolute tolerance can't be NaN.\")\n491 \n492         # If the user specified an absolute tolerance but not a relative one,\n493         # just return the absolute tolerance.\n494         if self.rel is None:\n495             if self.abs is not None:\n496                 return absolute_tolerance\n497 \n498         # Figure out what the relative tolerance should be.  ``self.rel`` is\n499         # either None or a value specified by the user.  This is done after\n500         # we've made sure the user didn't ask for an absolute tolerance only,\n501         # because we don't want to raise errors about the relative tolerance if\n502         # we aren't even going to use it.\n503         relative_tolerance = set_default(\n504             self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n505         ) * abs(self.expected)\n506 \n507         if relative_tolerance < 0:\n508             raise ValueError(\n509                 f\"relative tolerance can't be negative: {relative_tolerance}\"\n510             )\n511         if math.isnan(relative_tolerance):\n512             raise ValueError(\"relative tolerance can't be NaN.\")\n513 \n514         # Return the larger of the relative and absolute tolerances.\n515         return max(relative_tolerance, absolute_tolerance)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 71,
        "end": 127,
        "class_name": "ApproxBase",
        "method_name": null,
        "code": "71 class ApproxBase:\n72     \"\"\"Provide shared utilities for making approximate comparisons between\n73     numbers or sequences of numbers.\"\"\"\n74 \n75     # Tell numpy to use our `__eq__` operator instead of its.\n76     __array_ufunc__ = None\n77     __array_priority__ = 100\n78 \n79     def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:\n80         __tracebackhide__ = True\n81         self.expected = expected\n82         self.abs = abs\n83         self.rel = rel\n84         self.nan_ok = nan_ok\n85         self._check_type()\n86 \n87     def __repr__(self) -> str:\n88         raise NotImplementedError\n89 \n90     def _repr_compare(self, other_side: Any) -> List[str]:\n91         return [\n92             \"comparison failed\",\n93             f\"Obtained: {other_side}\",\n94             f\"Expected: {self}\",\n95         ]\n96 \n97     def __eq__(self, actual) -> bool:\n98         return all(\n99             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)\n100         )\n101 \n102     def __bool__(self):\n103         __tracebackhide__ = True\n104         raise AssertionError(\n105             \"approx() is not supported in a boolean context.\\nDid you mean: `assert a == approx(b)`?\"\n106         )\n107 \n108     # Ignore type because of https://github.com/python/mypy/issues/4266.\n109     __hash__ = None  # type: ignore\n110 \n111     def __ne__(self, actual) -> bool:\n112         return not (actual == self)\n113 \n114     def _approx_scalar(self, x) -> \"ApproxScalar\":\n115         if isinstance(x, Decimal):\n116             return ApproxDecimal(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n117         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n118 \n119     def _yield_comparisons(self, actual):\n120         \"\"\"Yield all the pairs of numbers to be compared.\n121 \n122         This is used to implement the `__eq__` method.\n123         \"\"\"\n124         raise NotImplementedError\n125 \n126     def _check_type(self) -> None:\n127         \"\"\"Raise a TypeError if the expected value is not a valid type.\"\"\"\n",
        "intended_behavior": "Although the `ApproxBase` class might not directly contribute to the observed bug, a review and potential update could ensure that its subclasses uniformly handle `None` as an `actual` value in comparisons. Specifically, initializing or utility methods in `ApproxBase` that affect how comparisons are made could include guidelines or checks that prevent subclasses from conducting operations leading to `TypeError`. This would largely be a preventive measure to maintain consistency and reliability in how `approx` functions deal with non-numeric and special values like `None` across different contexts."
    }
]