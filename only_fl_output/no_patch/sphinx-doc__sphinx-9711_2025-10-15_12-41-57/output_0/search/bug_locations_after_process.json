[
    {
        "rel_file_path": "sphinx/extension.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.3/sphinx/extension.py",
        "start": 1,
        "end": 68,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.extension\n3     ~~~~~~~~~~~~~~~~\n4 \n5     Utilities for Sphinx extensions.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import TYPE_CHECKING, Any, Dict\n12 \n13 from sphinx.config import Config\n14 from sphinx.errors import VersionRequirementError\n15 from sphinx.locale import __\n16 from sphinx.util import logging\n17 \n18 if TYPE_CHECKING:\n19     from sphinx.application import Sphinx\n20 \n21 logger = logging.getLogger(__name__)\n22 \n23 \n24 class Extension:\n25     def __init__(self, name: str, module: Any, **kwargs: Any) -> None:\n26         self.name = name\n27         self.module = module\n28         self.metadata = kwargs\n29         self.version = kwargs.pop('version', 'unknown version')\n30 \n31         # The extension supports parallel read or not.  The default value\n32         # is ``None``.  It means the extension does not tell the status.\n33         # It will be warned on parallel reading.\n34         self.parallel_read_safe = kwargs.pop('parallel_read_safe', None)\n35 \n36         # The extension supports parallel write or not.  The default value\n37         # is ``True``.  Sphinx writes parallelly documents even if\n38         # the extension does not tell its status.\n39         self.parallel_write_safe = kwargs.pop('parallel_write_safe', True)\n40 \n41 \n42 def verify_needs_extensions(app: \"Sphinx\", config: Config) -> None:\n43     \"\"\"Verify the required Sphinx extensions are loaded.\"\"\"\n44     if config.needs_extensions is None:\n45         return\n46 \n47     for extname, reqversion in config.needs_extensions.items():\n48         extension = app.extensions.get(extname)\n49         if extension is None:\n50             logger.warning(__('The %s extension is required by needs_extensions settings, '\n51                               'but it is not loaded.'), extname)\n52             continue\n53 \n54         if extension.version == 'unknown version' or reqversion > extension.version:\n55             raise VersionRequirementError(__('This project needs the extension %s at least in '\n56                                              'version %s and therefore cannot be built with '\n57                                              'the loaded version (%s).') %\n58                                           (extname, reqversion, extension.version))\n59 \n60 \n61 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n62     app.connect('config-inited', verify_needs_extensions, priority=800)\n63 \n64     return {\n65         'version': 'builtin',\n66         'parallel_read_safe': True,\n67         'parallel_write_safe': True,\n68     }\n",
        "intended_behavior": "The code responsible for version comparison within `needs_extensions` or any associated version checking logic should correctly compare semantic versioning numbers. This means parsing the version strings into numerical components and comparing them numerically to ensure that, for instance, version '0.10.0' is correctly recognized as greater than '0.6.0'. This can be achieved by utilizing a version parsing library that understands semantic versioning, or by implementing a custom comparator that accurately reflects the hierarchy of major.minor.patch components. The existing functionality for determining if an extension meets the required minimum version should be preserved, but enhanced to ensure accurate version comparison."
    },
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.3/sphinx/config.py",
        "start": 1,
        "end": 498,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.config\n3     ~~~~~~~~~~~~~\n4 \n5     Build configuration file handling.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import traceback\n13 import types\n14 from collections import OrderedDict\n15 from os import getenv, path\n16 from typing import (TYPE_CHECKING, Any, Callable, Dict, Generator, Iterator, List, NamedTuple,\n17                     Optional, Set, Tuple, Union)\n18 \n19 from sphinx.errors import ConfigError, ExtensionError\n20 from sphinx.locale import _, __\n21 from sphinx.util import logging\n22 from sphinx.util.i18n import format_date\n23 from sphinx.util.osutil import cd, fs_encoding\n24 from sphinx.util.tags import Tags\n25 from sphinx.util.typing import NoneType\n26 \n27 if TYPE_CHECKING:\n28     from sphinx.application import Sphinx\n29     from sphinx.environment import BuildEnvironment\n30 \n31 logger = logging.getLogger(__name__)\n32 \n33 CONFIG_FILENAME = 'conf.py'\n34 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\n35 copyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n36 \n37 \n38 class ConfigValue(NamedTuple):\n39     name: str\n40     value: Any\n41     rebuild: Union[bool, str]\n42 \n43 \n44 def is_serializable(obj: Any) -> bool:\n45     \"\"\"Check if object is serializable or not.\"\"\"\n46     if isinstance(obj, UNSERIALIZABLE_TYPES):\n47         return False\n48     elif isinstance(obj, dict):\n49         for key, value in obj.items():\n50             if not is_serializable(key) or not is_serializable(value):\n51                 return False\n52     elif isinstance(obj, (list, tuple, set)):\n53         return all(is_serializable(i) for i in obj)\n54 \n55     return True\n56 \n57 \n58 class ENUM:\n59     \"\"\"Represents the candidates which a config value should be one of.\n60 \n61     Example:\n62         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))\n63     \"\"\"\n64     def __init__(self, *candidates: str) -> None:\n65         self.candidates = candidates\n66 \n67     def match(self, value: Union[str, List, Tuple]) -> bool:\n68         if isinstance(value, (list, tuple)):\n69             return all(item in self.candidates for item in value)\n70         else:\n71             return value in self.candidates\n72 \n73 \n74 class Config:\n75     \"\"\"Configuration file abstraction.\n76 \n77     The config object makes the values of all config values available as\n78     attributes.\n79 \n80     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n81     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n82     to get the value of :confval:`language`, use either ``app.config.language``\n83     or ``env.config.language``.\n84     \"\"\"\n85 \n86     # the values are: (default, what needs to be rebuilt if changed)\n87 \n88     # If you add a value here, don't forget to include it in the\n89     # quickstart.py file template as well as in the docs!\n90 \n91     config_values: Dict[str, Tuple] = {\n92         # general options\n93         'project': ('Python', 'env', []),\n94         'author': ('unknown', 'env', []),\n95         'project_copyright': ('', 'html', [str]),\n96         'copyright': (lambda c: c.project_copyright, 'html', [str]),\n97         'version': ('', 'env', []),\n98         'release': ('', 'env', []),\n99         'today': ('', 'env', []),\n100         # the real default is locale-dependent\n101         'today_fmt': (None, 'env', [str]),\n102 \n103         'language': (None, 'env', [str]),\n104         'locale_dirs': (['locales'], 'env', []),\n105         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n106 \n107         'master_doc': ('index', 'env', []),\n108         'root_doc': (lambda config: config.master_doc, 'env', []),\n109         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n110         'source_encoding': ('utf-8-sig', 'env', []),\n111         'exclude_patterns': ([], 'env', []),\n112         'default_role': (None, 'env', [str]),\n113         'add_function_parentheses': (True, 'env', []),\n114         'add_module_names': (True, 'env', []),\n115         'trim_footnote_reference_space': (False, 'env', []),\n116         'show_authors': (False, 'env', []),\n117         'pygments_style': (None, 'html', [str]),\n118         'highlight_language': ('default', 'env', []),\n119         'highlight_options': ({}, 'env', []),\n120         'templates_path': ([], 'html', []),\n121         'template_bridge': (None, 'html', [str]),\n122         'keep_warnings': (False, 'env', []),\n123         'suppress_warnings': ([], 'env', []),\n124         'modindex_common_prefix': ([], 'html', []),\n125         'rst_epilog': (None, 'env', [str]),\n126         'rst_prolog': (None, 'env', [str]),\n127         'trim_doctest_flags': (True, 'env', []),\n128         'primary_domain': ('py', 'env', [NoneType]),\n129         'needs_sphinx': (None, None, [str]),\n130         'needs_extensions': ({}, None, []),\n131         'manpages_url': (None, 'env', []),\n132         'nitpicky': (False, None, []),\n133         'nitpick_ignore': ([], None, []),\n134         'nitpick_ignore_regex': ([], None, []),\n135         'numfig': (False, 'env', []),\n136         'numfig_secnum_depth': (1, 'env', []),\n137         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n138 \n139         'math_number_all': (False, 'env', []),\n140         'math_eqref_format': (None, 'env', [str]),\n141         'math_numfig': (True, 'env', []),\n142         'tls_verify': (True, 'env', []),\n143         'tls_cacerts': (None, 'env', []),\n144         'user_agent': (None, 'env', [str]),\n145         'smartquotes': (True, 'env', []),\n146         'smartquotes_action': ('qDe', 'env', []),\n147         'smartquotes_excludes': ({'languages': ['ja'],\n148                                   'builders': ['man', 'text']},\n149                                  'env', []),\n150     }\n151 \n152     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n153         self.overrides = dict(overrides)\n154         self.values = Config.config_values.copy()\n155         self._raw_config = config\n156         self.setup: Optional[Callable] = config.get('setup', None)\n157 \n158         if 'extensions' in self.overrides:\n159             if isinstance(self.overrides['extensions'], str):\n160                 config['extensions'] = self.overrides.pop('extensions').split(',')\n161             else:\n162                 config['extensions'] = self.overrides.pop('extensions')\n163         self.extensions: List[str] = config.get('extensions', [])\n164 \n165     @classmethod\n166     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n167         \"\"\"Create a Config object from configuration file.\"\"\"\n168         filename = path.join(confdir, CONFIG_FILENAME)\n169         if not path.isfile(filename):\n170             raise ConfigError(__(\"config directory doesn't contain a conf.py file (%s)\") %\n171                               confdir)\n172         namespace = eval_config_file(filename, tags)\n173         return cls(namespace, overrides or {})\n174 \n175     def convert_overrides(self, name: str, value: Any) -> Any:\n176         if not isinstance(value, str):\n177             return value\n178         else:\n179             defvalue = self.values[name][0]\n180             if self.values[name][2] == Any:\n181                 return value\n182             elif self.values[name][2] == {bool, str}:\n183                 if value == '0':\n184                     # given falsy string from command line option\n185                     return False\n186                 elif value == '1':\n187                     return True\n188                 else:\n189                     return value\n190             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n191                 if value == '0':\n192                     # given falsy string from command line option\n193                     return False\n194                 else:\n195                     return bool(value)\n196             elif isinstance(defvalue, dict):\n197                 raise ValueError(__('cannot override dictionary config setting %r, '\n198                                     'ignoring (use %r to set individual elements)') %\n199                                  (name, name + '.key=value'))\n200             elif isinstance(defvalue, list):\n201                 return value.split(',')\n202             elif isinstance(defvalue, int):\n203                 try:\n204                     return int(value)\n205                 except ValueError as exc:\n206                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n207                                      (value, name)) from exc\n208             elif hasattr(defvalue, '__call__'):\n209                 return value\n210             elif defvalue is not None and not isinstance(defvalue, str):\n211                 raise ValueError(__('cannot override config setting %r with unsupported '\n212                                     'type, ignoring') % name)\n213             else:\n214                 return value\n215 \n216     def pre_init_values(self) -> None:\n217         \"\"\"\n218         Initialize some limited config variables before initializing i18n and loading\n219         extensions.\n220         \"\"\"\n221         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n222         for name in variables:\n223             try:\n224                 if name in self.overrides:\n225                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n226                 elif name in self._raw_config:\n227                     self.__dict__[name] = self._raw_config[name]\n228             except ValueError as exc:\n229                 logger.warning(\"%s\", exc)\n230 \n231     def init_values(self) -> None:\n232         config = self._raw_config\n233         for valname, value in self.overrides.items():\n234             try:\n235                 if '.' in valname:\n236                     realvalname, key = valname.split('.', 1)\n237                     config.setdefault(realvalname, {})[key] = value\n238                     continue\n239                 elif valname not in self.values:\n240                     logger.warning(__('unknown config value %r in override, ignoring'),\n241                                    valname)\n242                     continue\n243                 if isinstance(value, str):\n244                     config[valname] = self.convert_overrides(valname, value)\n245                 else:\n246                     config[valname] = value\n247             except ValueError as exc:\n248                 logger.warning(\"%s\", exc)\n249         for name in config:\n250             if name in self.values:\n251                 self.__dict__[name] = config[name]\n252 \n253     def __getattr__(self, name: str) -> Any:\n254         if name.startswith('_'):\n255             raise AttributeError(name)\n256         if name not in self.values:\n257             raise AttributeError(__('No such config value: %s') % name)\n258         default = self.values[name][0]\n259         if hasattr(default, '__call__'):\n260             return default(self)\n261         return default\n262 \n263     def __getitem__(self, name: str) -> Any:\n264         return getattr(self, name)\n265 \n266     def __setitem__(self, name: str, value: Any) -> None:\n267         setattr(self, name, value)\n268 \n269     def __delitem__(self, name: str) -> None:\n270         delattr(self, name)\n271 \n272     def __contains__(self, name: str) -> bool:\n273         return name in self.values\n274 \n275     def __iter__(self) -> Generator[ConfigValue, None, None]:\n276         for name, value in self.values.items():\n277             yield ConfigValue(name, getattr(self, name), value[1])\n278 \n279     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n280         if name in self.values:\n281             raise ExtensionError(__('Config value %r already present') % name)\n282         else:\n283             self.values[name] = (default, rebuild, types)\n284 \n285     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n286         if isinstance(rebuild, str):\n287             rebuild = [rebuild]\n288         return (value for value in self if value.rebuild in rebuild)\n289 \n290     def __getstate__(self) -> Dict:\n291         \"\"\"Obtains serializable data for pickling.\"\"\"\n292         # remove potentially pickling-problematic values from config\n293         __dict__ = {}\n294         for key, value in self.__dict__.items():\n295             if key.startswith('_') or not is_serializable(value):\n296                 pass\n297             else:\n298                 __dict__[key] = value\n299 \n300         # create a picklable copy of values list\n301         __dict__['values'] = {}\n302         for key, value in self.values.items():\n303             real_value = getattr(self, key)\n304             if not is_serializable(real_value):\n305                 # omit unserializable value\n306                 real_value = None\n307 \n308             # types column is also omitted\n309             __dict__['values'][key] = (real_value, value[1], None)\n310 \n311         return __dict__\n312 \n313     def __setstate__(self, state: Dict) -> None:\n314         self.__dict__.update(state)\n315 \n316 \n317 def eval_config_file(filename: str, tags: Optional[Tags]) -> Dict[str, Any]:\n318     \"\"\"Evaluate a config file.\"\"\"\n319     namespace: Dict[str, Any] = {}\n320     namespace['__file__'] = filename\n321     namespace['tags'] = tags\n322 \n323     with cd(path.dirname(filename)):\n324         # during executing config file, current dir is changed to ``confdir``.\n325         try:\n326             with open(filename, 'rb') as f:\n327                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')\n328                 exec(code, namespace)\n329         except SyntaxError as err:\n330             msg = __(\"There is a syntax error in your configuration file: %s\\n\")\n331             raise ConfigError(msg % err) from err\n332         except SystemExit as exc:\n333             msg = __(\"The configuration file (or one of the modules it imports) \"\n334                      \"called sys.exit()\")\n335             raise ConfigError(msg) from exc\n336         except ConfigError:\n337             # pass through ConfigError from conf.py as is.  It will be shown in console.\n338             raise\n339         except Exception as exc:\n340             msg = __(\"There is a programmable error in your configuration file:\\n\\n%s\")\n341             raise ConfigError(msg % traceback.format_exc()) from exc\n342 \n343     return namespace\n344 \n345 \n346 def convert_source_suffix(app: \"Sphinx\", config: Config) -> None:\n347     \"\"\"Convert old styled source_suffix to new styled one.\n348 \n349     * old style: str or list\n350     * new style: a dict which maps from fileext to filetype\n351     \"\"\"\n352     source_suffix = config.source_suffix\n353     if isinstance(source_suffix, str):\n354         # if str, considers as default filetype (None)\n355         #\n356         # The default filetype is determined on later step.\n357         # By default, it is considered as restructuredtext.\n358         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore\n359     elif isinstance(source_suffix, (list, tuple)):\n360         # if list, considers as all of them are default filetype\n361         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA\n362     elif isinstance(source_suffix, dict):\n363         # if dict, convert it to OrderedDict\n364         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore\n365     else:\n366         logger.warning(__(\"The config value `source_suffix' expects \"\n367                           \"a string, list of strings, or dictionary. \"\n368                           \"But `%r' is given.\" % source_suffix))\n369 \n370 \n371 def convert_highlight_options(app: \"Sphinx\", config: Config) -> None:\n372     \"\"\"Convert old styled highlight_options to new styled one.\n373 \n374     * old style: options\n375     * new style: a dict which maps from language name to options\n376     \"\"\"\n377     options = config.highlight_options\n378     if options and not all(isinstance(v, dict) for v in options.values()):\n379         # old styled option detected because all values are not dictionary.\n380         config.highlight_options = {config.highlight_language: options}  # type: ignore\n381 \n382 \n383 def init_numfig_format(app: \"Sphinx\", config: Config) -> None:\n384     \"\"\"Initialize :confval:`numfig_format`.\"\"\"\n385     numfig_format = {'section': _('Section %s'),\n386                      'figure': _('Fig. %s'),\n387                      'table': _('Table %s'),\n388                      'code-block': _('Listing %s')}\n389 \n390     # override default labels by configuration\n391     numfig_format.update(config.numfig_format)\n392     config.numfig_format = numfig_format  # type: ignore\n393 \n394 \n395 def correct_copyright_year(app: \"Sphinx\", config: Config) -> None:\n396     \"\"\"Correct values of copyright year that are not coherent with\n397     the SOURCE_DATE_EPOCH environment variable (if set)\n398 \n399     See https://reproducible-builds.org/specs/source-date-epoch/\n400     \"\"\"\n401     if getenv('SOURCE_DATE_EPOCH') is not None:\n402         for k in ('copyright', 'epub_copyright'):\n403             if k in config:\n404                 replace = r'\\g<1>%s' % format_date('%Y')\n405                 config[k] = copyright_year_re.sub(replace, config[k])\n406 \n407 \n408 def check_confval_types(app: \"Sphinx\", config: Config) -> None:\n409     \"\"\"Check all values for deviation from the default value's type, since\n410     that can result in TypeErrors all over the place NB.\n411     \"\"\"\n412     for confval in config:\n413         default, rebuild, annotations = config.values[confval.name]\n414 \n415         if hasattr(default, '__call__'):\n416             default = default(config)  # evaluate default value\n417         if default is None and not annotations:\n418             continue  # neither inferable nor expliclitly annotated types\n419 \n420         if annotations is Any:\n421             # any type of value is accepted\n422             pass\n423         elif isinstance(annotations, ENUM):\n424             if not annotations.match(confval.value):\n425                 msg = __(\"The config value `{name}` has to be a one of {candidates}, \"\n426                          \"but `{current}` is given.\")\n427                 logger.warning(msg.format(name=confval.name,\n428                                           current=confval.value,\n429                                           candidates=annotations.candidates))\n430         else:\n431             if type(confval.value) is type(default):\n432                 continue\n433             if type(confval.value) in annotations:\n434                 continue\n435 \n436             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &\n437                             set(type(default).__bases__))\n438             common_bases.discard(object)\n439             if common_bases:\n440                 continue  # at least we share a non-trivial base class\n441 \n442             if annotations:\n443                 msg = __(\"The config value `{name}' has type `{current.__name__}'; \"\n444                          \"expected {permitted}.\")\n445                 wrapped_annotations = [\"`{}'\".format(c.__name__) for c in annotations]\n446                 if len(wrapped_annotations) > 2:\n447                     permitted = \"{}, or {}\".format(\n448                         \", \".join(wrapped_annotations[:-1]),\n449                         wrapped_annotations[-1])\n450                 else:\n451                     permitted = \" or \".join(wrapped_annotations)\n452                 logger.warning(msg.format(name=confval.name,\n453                                           current=type(confval.value),\n454                                           permitted=permitted))\n455             else:\n456                 msg = __(\"The config value `{name}' has type `{current.__name__}', \"\n457                          \"defaults to `{default.__name__}'.\")\n458                 logger.warning(msg.format(name=confval.name,\n459                                           current=type(confval.value),\n460                                           default=type(default)))\n461 \n462 \n463 def check_primary_domain(app: \"Sphinx\", config: Config) -> None:\n464     primary_domain = config.primary_domain\n465     if primary_domain and not app.registry.has_domain(primary_domain):\n466         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)\n467         config.primary_domain = None  # type: ignore\n468 \n469 \n470 def check_root_doc(app: \"Sphinx\", env: \"BuildEnvironment\", added: Set[str],\n471                    changed: Set[str], removed: Set[str]) -> Set[str]:\n472     \"\"\"Adjust root_doc to 'contents' to support an old project which does not have\n473     any root_doc setting.\n474     \"\"\"\n475     if (app.config.root_doc == 'index' and\n476             'index' not in app.project.docnames and\n477             'contents' in app.project.docnames):\n478         logger.warning(__('Since v2.0, Sphinx uses \"index\" as root_doc by default. '\n479                           'Please add \"root_doc = \\'contents\\'\" to your conf.py.'))\n480         app.config.root_doc = \"contents\"  # type: ignore\n481 \n482     return changed\n483 \n484 \n485 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n486     app.connect('config-inited', convert_source_suffix, priority=800)\n487     app.connect('config-inited', convert_highlight_options, priority=800)\n488     app.connect('config-inited', init_numfig_format, priority=800)\n489     app.connect('config-inited', correct_copyright_year, priority=800)\n490     app.connect('config-inited', check_confval_types, priority=800)\n491     app.connect('config-inited', check_primary_domain, priority=800)\n492     app.connect('env-get-outdated', check_root_doc)\n493 \n494     return {\n495         'version': 'builtin',\n496         'parallel_read_safe': True,\n497         'parallel_write_safe': True,\n498     }\n",
        "intended_behavior": "If `config.py` plays a role in defining, parsing, or enforcing `needs_extensions` version constraints, it must ensure that extension versions are compared using a method that respects semantic versioning rules. The intended behavior is to parse and compare version numbers correctly, recognizing the proper order of versions beyond simple string-based comparisons. For instance, facilitating or ensuring that any utilities or methods used for version constraints are capable of semantic version analysis."
    }
]