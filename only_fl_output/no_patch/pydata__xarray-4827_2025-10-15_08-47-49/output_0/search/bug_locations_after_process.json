[
    {
        "rel_file_path": "xarray/core/merge.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.12/xarray/core/merge.py",
        "start": 1,
        "end": 940,
        "class_name": null,
        "method_name": null,
        "code": "1 from typing import (\n2     TYPE_CHECKING,\n3     AbstractSet,\n4     Any,\n5     Dict,\n6     Hashable,\n7     Iterable,\n8     List,\n9     Mapping,\n10     NamedTuple,\n11     Optional,\n12     Sequence,\n13     Set,\n14     Tuple,\n15     Union,\n16 )\n17 \n18 import pandas as pd\n19 \n20 from . import dtypes, pdcompat\n21 from .alignment import deep_align\n22 from .duck_array_ops import lazy_array_equiv\n23 from .utils import Frozen, compat_dict_union, dict_equiv\n24 from .variable import Variable, as_variable, assert_unique_multiindex_level_names\n25 \n26 if TYPE_CHECKING:\n27     from .coordinates import Coordinates\n28     from .dataarray import DataArray\n29     from .dataset import Dataset\n30 \n31     DimsLike = Union[Hashable, Sequence[Hashable]]\n32     ArrayLike = Any\n33     VariableLike = Union[\n34         ArrayLike,\n35         Tuple[DimsLike, ArrayLike],\n36         Tuple[DimsLike, ArrayLike, Mapping],\n37         Tuple[DimsLike, ArrayLike, Mapping, Mapping],\n38     ]\n39     XarrayValue = Union[DataArray, Variable, VariableLike]\n40     DatasetLike = Union[Dataset, Mapping[Hashable, XarrayValue]]\n41     CoercibleValue = Union[XarrayValue, pd.Series, pd.DataFrame]\n42     CoercibleMapping = Union[Dataset, Mapping[Hashable, CoercibleValue]]\n43 \n44 \n45 PANDAS_TYPES = (pd.Series, pd.DataFrame, pdcompat.Panel)\n46 \n47 _VALID_COMPAT = Frozen(\n48     {\n49         \"identical\": 0,\n50         \"equals\": 1,\n51         \"broadcast_equals\": 2,\n52         \"minimal\": 3,\n53         \"no_conflicts\": 4,\n54         \"override\": 5,\n55     }\n56 )\n57 \n58 \n59 def broadcast_dimension_size(variables: List[Variable]) -> Dict[Hashable, int]:\n60     \"\"\"Extract dimension sizes from a dictionary of variables.\n61 \n62     Raises ValueError if any dimensions have different sizes.\n63     \"\"\"\n64     dims: Dict[Hashable, int] = {}\n65     for var in variables:\n66         for dim, size in zip(var.dims, var.shape):\n67             if dim in dims and size != dims[dim]:\n68                 raise ValueError(\"index %r not aligned\" % dim)\n69             dims[dim] = size\n70     return dims\n71 \n72 \n73 class MergeError(ValueError):\n74     \"\"\"Error class for merge failures due to incompatible arguments.\"\"\"\n75 \n76     # inherits from ValueError for backward compatibility\n77     # TODO: move this to an xarray.exceptions module?\n78 \n79 \n80 def unique_variable(\n81     name: Hashable,\n82     variables: List[Variable],\n83     compat: str = \"broadcast_equals\",\n84     equals: bool = None,\n85 ) -> Variable:\n86     \"\"\"Return the unique variable from a list of variables or raise MergeError.\n87 \n88     Parameters\n89     ----------\n90     name : hashable\n91         Name for this variable.\n92     variables : list of Variable\n93         List of Variable objects, all of which go by the same name in different\n94         inputs.\n95     compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\", \"override\"}, optional\n96         Type of equality check to use.\n97     equals : None or bool, optional\n98         corresponding to result of compat test\n99 \n100     Returns\n101     -------\n102     Variable to use in the result.\n103 \n104     Raises\n105     ------\n106     MergeError: if any of the variables are not equal.\n107     \"\"\"\n108     out = variables[0]\n109 \n110     if len(variables) == 1 or compat == \"override\":\n111         return out\n112 \n113     combine_method = None\n114 \n115     if compat == \"minimal\":\n116         compat = \"broadcast_equals\"\n117 \n118     if compat == \"broadcast_equals\":\n119         dim_lengths = broadcast_dimension_size(variables)\n120         out = out.set_dims(dim_lengths)\n121 \n122     if compat == \"no_conflicts\":\n123         combine_method = \"fillna\"\n124 \n125     if equals is None:\n126         # first check without comparing values i.e. no computes\n127         for var in variables[1:]:\n128             equals = getattr(out, compat)(var, equiv=lazy_array_equiv)\n129             if equals is not True:\n130                 break\n131 \n132         if equals is None:\n133             # now compare values with minimum number of computes\n134             out = out.compute()\n135             for var in variables[1:]:\n136                 equals = getattr(out, compat)(var)\n137                 if not equals:\n138                     break\n139 \n140     if not equals:\n141         raise MergeError(\n142             f\"conflicting values for variable {name!r} on objects to be combined. \"\n143             \"You can skip this check by specifying compat='override'.\"\n144         )\n145 \n146     if combine_method:\n147         for var in variables[1:]:\n148             out = getattr(out, combine_method)(var)\n149 \n150     return out\n151 \n152 \n153 def _assert_compat_valid(compat):\n154     if compat not in _VALID_COMPAT:\n155         raise ValueError(\n156             \"compat={!r} invalid: must be {}\".format(compat, set(_VALID_COMPAT))\n157         )\n158 \n159 \n160 MergeElement = Tuple[Variable, Optional[pd.Index]]\n161 \n162 \n163 def merge_collected(\n164     grouped: Dict[Hashable, List[MergeElement]],\n165     prioritized: Mapping[Hashable, MergeElement] = None,\n166     compat: str = \"minimal\",\n167 ) -> Tuple[Dict[Hashable, Variable], Dict[Hashable, pd.Index]]:\n168     \"\"\"Merge dicts of variables, while resolving conflicts appropriately.\n169 \n170     Parameters\n171     ----------\n172     grouped : mapping\n173     prioritized : mapping\n174     compat : str\n175         Type of equality check to use when checking for conflicts.\n176 \n177     Returns\n178     -------\n179     Dict with keys taken by the union of keys on list_of_mappings,\n180     and Variable values corresponding to those that should be found on the\n181     merged result.\n182     \"\"\"\n183     if prioritized is None:\n184         prioritized = {}\n185 \n186     _assert_compat_valid(compat)\n187 \n188     merged_vars: Dict[Hashable, Variable] = {}\n189     merged_indexes: Dict[Hashable, pd.Index] = {}\n190 \n191     for name, elements_list in grouped.items():\n192         if name in prioritized:\n193             variable, index = prioritized[name]\n194             merged_vars[name] = variable\n195             if index is not None:\n196                 merged_indexes[name] = index\n197         else:\n198             indexed_elements = [\n199                 (variable, index)\n200                 for variable, index in elements_list\n201                 if index is not None\n202             ]\n203 \n204             if indexed_elements:\n205                 # TODO(shoyer): consider adjusting this logic. Are we really\n206                 # OK throwing away variable without an index in favor of\n207                 # indexed variables, without even checking if values match?\n208                 variable, index = indexed_elements[0]\n209                 for _, other_index in indexed_elements[1:]:\n210                     if not index.equals(other_index):\n211                         raise MergeError(\n212                             \"conflicting values for index %r on objects to be \"\n213                             \"combined:\\nfirst value: %r\\nsecond value: %r\"\n214                             % (name, index, other_index)\n215                         )\n216                 if compat == \"identical\":\n217                     for other_variable, _ in indexed_elements[1:]:\n218                         if not dict_equiv(variable.attrs, other_variable.attrs):\n219                             raise MergeError(\n220                                 \"conflicting attribute values on combined \"\n221                                 \"variable %r:\\nfirst value: %r\\nsecond value: %r\"\n222                                 % (name, variable.attrs, other_variable.attrs)\n223                             )\n224                 merged_vars[name] = variable\n225                 merged_indexes[name] = index\n226             else:\n227                 variables = [variable for variable, _ in elements_list]\n228                 try:\n229                     merged_vars[name] = unique_variable(name, variables, compat)\n230                 except MergeError:\n231                     if compat != \"minimal\":\n232                         # we need more than \"minimal\" compatibility (for which\n233                         # we drop conflicting coordinates)\n234                         raise\n235 \n236     return merged_vars, merged_indexes\n237 \n238 \n239 def collect_variables_and_indexes(\n240     list_of_mappings: \"List[DatasetLike]\",\n241 ) -> Dict[Hashable, List[MergeElement]]:\n242     \"\"\"Collect variables and indexes from list of mappings of xarray objects.\n243 \n244     Mappings must either be Dataset objects, or have values of one of the\n245     following types:\n246     - an xarray.Variable\n247     - a tuple `(dims, data[, attrs[, encoding]])` that can be converted in\n248       an xarray.Variable\n249     - or an xarray.DataArray\n250     \"\"\"\n251     from .dataarray import DataArray\n252     from .dataset import Dataset\n253 \n254     grouped: Dict[Hashable, List[Tuple[Variable, pd.Index]]] = {}\n255 \n256     def append(name, variable, index):\n257         values = grouped.setdefault(name, [])\n258         values.append((variable, index))\n259 \n260     def append_all(variables, indexes):\n261         for name, variable in variables.items():\n262             append(name, variable, indexes.get(name))\n263 \n264     for mapping in list_of_mappings:\n265         if isinstance(mapping, Dataset):\n266             append_all(mapping.variables, mapping.indexes)\n267             continue\n268 \n269         for name, variable in mapping.items():\n270             if isinstance(variable, DataArray):\n271                 coords = variable._coords.copy()  # use private API for speed\n272                 indexes = dict(variable.indexes)\n273                 # explicitly overwritten variables should take precedence\n274                 coords.pop(name, None)\n275                 indexes.pop(name, None)\n276                 append_all(coords, indexes)\n277 \n278             variable = as_variable(variable, name=name)\n279             if variable.dims == (name,):\n280                 variable = variable.to_index_variable()\n281                 index = variable.to_index()\n282             else:\n283                 index = None\n284             append(name, variable, index)\n285 \n286     return grouped\n287 \n288 \n289 def collect_from_coordinates(\n290     list_of_coords: \"List[Coordinates]\",\n291 ) -> Dict[Hashable, List[MergeElement]]:\n292     \"\"\"Collect variables and indexes to be merged from Coordinate objects.\"\"\"\n293     grouped: Dict[Hashable, List[Tuple[Variable, pd.Index]]] = {}\n294 \n295     for coords in list_of_coords:\n296         variables = coords.variables\n297         indexes = coords.indexes\n298         for name, variable in variables.items():\n299             value = grouped.setdefault(name, [])\n300             value.append((variable, indexes.get(name)))\n301     return grouped\n302 \n303 \n304 def merge_coordinates_without_align(\n305     objects: \"List[Coordinates]\",\n306     prioritized: Mapping[Hashable, MergeElement] = None,\n307     exclude_dims: AbstractSet = frozenset(),\n308 ) -> Tuple[Dict[Hashable, Variable], Dict[Hashable, pd.Index]]:\n309     \"\"\"Merge variables/indexes from coordinates without automatic alignments.\n310 \n311     This function is used for merging coordinate from pre-existing xarray\n312     objects.\n313     \"\"\"\n314     collected = collect_from_coordinates(objects)\n315 \n316     if exclude_dims:\n317         filtered: Dict[Hashable, List[MergeElement]] = {}\n318         for name, elements in collected.items():\n319             new_elements = [\n320                 (variable, index)\n321                 for variable, index in elements\n322                 if exclude_dims.isdisjoint(variable.dims)\n323             ]\n324             if new_elements:\n325                 filtered[name] = new_elements\n326     else:\n327         filtered = collected\n328 \n329     return merge_collected(filtered, prioritized)\n330 \n331 \n332 def determine_coords(\n333     list_of_mappings: Iterable[\"DatasetLike\"],\n334 ) -> Tuple[Set[Hashable], Set[Hashable]]:\n335     \"\"\"Given a list of dicts with xarray object values, identify coordinates.\n336 \n337     Parameters\n338     ----------\n339     list_of_mappings : list of dict or list of Dataset\n340         Of the same form as the arguments to expand_variable_dicts.\n341 \n342     Returns\n343     -------\n344     coord_names : set of variable names\n345     noncoord_names : set of variable names\n346         All variable found in the input should appear in either the set of\n347         coordinate or non-coordinate names.\n348     \"\"\"\n349     from .dataarray import DataArray\n350     from .dataset import Dataset\n351 \n352     coord_names: Set[Hashable] = set()\n353     noncoord_names: Set[Hashable] = set()\n354 \n355     for mapping in list_of_mappings:\n356         if isinstance(mapping, Dataset):\n357             coord_names.update(mapping.coords)\n358             noncoord_names.update(mapping.data_vars)\n359         else:\n360             for name, var in mapping.items():\n361                 if isinstance(var, DataArray):\n362                     coords = set(var._coords)  # use private API for speed\n363                     # explicitly overwritten variables should take precedence\n364                     coords.discard(name)\n365                     coord_names.update(coords)\n366 \n367     return coord_names, noncoord_names\n368 \n369 \n370 def coerce_pandas_values(objects: Iterable[\"CoercibleMapping\"]) -> List[\"DatasetLike\"]:\n371     \"\"\"Convert pandas values found in a list of labeled objects.\n372 \n373     Parameters\n374     ----------\n375     objects : list of Dataset or mapping\n376         The mappings may contain any sort of objects coercible to\n377         xarray.Variables as keys, including pandas objects.\n378 \n379     Returns\n380     -------\n381     List of Dataset or dictionary objects. Any inputs or values in the inputs\n382     that were pandas objects have been converted into native xarray objects.\n383     \"\"\"\n384     from .dataarray import DataArray\n385     from .dataset import Dataset\n386 \n387     out = []\n388     for obj in objects:\n389         if isinstance(obj, Dataset):\n390             variables: \"DatasetLike\" = obj\n391         else:\n392             variables = {}\n393             if isinstance(obj, PANDAS_TYPES):\n394                 obj = dict(obj.iteritems())\n395             for k, v in obj.items():\n396                 if isinstance(v, PANDAS_TYPES):\n397                     v = DataArray(v)\n398                 variables[k] = v\n399         out.append(variables)\n400     return out\n401 \n402 \n403 def _get_priority_vars_and_indexes(\n404     objects: List[\"DatasetLike\"], priority_arg: Optional[int], compat: str = \"equals\"\n405 ) -> Dict[Hashable, MergeElement]:\n406     \"\"\"Extract the priority variable from a list of mappings.\n407 \n408     We need this method because in some cases the priority argument itself\n409     might have conflicting values (e.g., if it is a dict with two DataArray\n410     values with conflicting coordinate values).\n411 \n412     Parameters\n413     ----------\n414     objects : list of dict-like of Variable\n415         Dictionaries in which to find the priority variables.\n416     priority_arg : int or None\n417         Integer object whose variable should take priority.\n418     compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\"}, optional\n419         Compatibility checks to use when merging variables.\n420 \n421     Returns\n422     -------\n423     A dictionary of variables and associated indexes (if any) to prioritize.\n424     \"\"\"\n425     if priority_arg is None:\n426         return {}\n427 \n428     collected = collect_variables_and_indexes([objects[priority_arg]])\n429     variables, indexes = merge_collected(collected, compat=compat)\n430     grouped: Dict[Hashable, MergeElement] = {}\n431     for name, variable in variables.items():\n432         grouped[name] = (variable, indexes.get(name))\n433     return grouped\n434 \n435 \n436 def merge_coords(\n437     objects: Iterable[\"CoercibleMapping\"],\n438     compat: str = \"minimal\",\n439     join: str = \"outer\",\n440     priority_arg: Optional[int] = None,\n441     indexes: Optional[Mapping[Hashable, pd.Index]] = None,\n442     fill_value: object = dtypes.NA,\n443 ) -> Tuple[Dict[Hashable, Variable], Dict[Hashable, pd.Index]]:\n444     \"\"\"Merge coordinate variables.\n445 \n446     See merge_core below for argument descriptions. This works similarly to\n447     merge_core, except everything we don't worry about whether variables are\n448     coordinates or not.\n449     \"\"\"\n450     _assert_compat_valid(compat)\n451     coerced = coerce_pandas_values(objects)\n452     aligned = deep_align(\n453         coerced, join=join, copy=False, indexes=indexes, fill_value=fill_value\n454     )\n455     collected = collect_variables_and_indexes(aligned)\n456     prioritized = _get_priority_vars_and_indexes(aligned, priority_arg, compat=compat)\n457     variables, out_indexes = merge_collected(collected, prioritized, compat=compat)\n458     assert_unique_multiindex_level_names(variables)\n459     return variables, out_indexes\n460 \n461 \n462 def merge_data_and_coords(data, coords, compat=\"broadcast_equals\", join=\"outer\"):\n463     \"\"\"Used in Dataset.__init__.\"\"\"\n464     objects = [data, coords]\n465     explicit_coords = coords.keys()\n466     indexes = dict(_extract_indexes_from_coords(coords))\n467     return merge_core(\n468         objects, compat, join, explicit_coords=explicit_coords, indexes=indexes\n469     )\n470 \n471 \n472 def _extract_indexes_from_coords(coords):\n473     \"\"\"Yields the name & index of valid indexes from a mapping of coords\"\"\"\n474     for name, variable in coords.items():\n475         variable = as_variable(variable, name=name)\n476         if variable.dims == (name,):\n477             yield name, variable.to_index()\n478 \n479 \n480 def assert_valid_explicit_coords(variables, dims, explicit_coords):\n481     \"\"\"Validate explicit coordinate names/dims.\n482 \n483     Raise a MergeError if an explicit coord shares a name with a dimension\n484     but is comprised of arbitrary dimensions.\n485     \"\"\"\n486     for coord_name in explicit_coords:\n487         if coord_name in dims and variables[coord_name].dims != (coord_name,):\n488             raise MergeError(\n489                 \"coordinate %s shares a name with a dataset dimension, but is \"\n490                 \"not a 1D variable along that dimension. This is disallowed \"\n491                 \"by the xarray data model.\" % coord_name\n492             )\n493 \n494 \n495 def merge_attrs(variable_attrs, combine_attrs):\n496     \"\"\"Combine attributes from different variables according to combine_attrs\"\"\"\n497     if not variable_attrs:\n498         # no attributes to merge\n499         return None\n500 \n501     if combine_attrs == \"drop\":\n502         return {}\n503     elif combine_attrs == \"override\":\n504         return dict(variable_attrs[0])\n505     elif combine_attrs == \"no_conflicts\":\n506         result = dict(variable_attrs[0])\n507         for attrs in variable_attrs[1:]:\n508             try:\n509                 result = compat_dict_union(result, attrs)\n510             except ValueError:\n511                 raise MergeError(\n512                     \"combine_attrs='no_conflicts', but some values are not \"\n513                     \"the same. Merging %s with %s\" % (str(result), str(attrs))\n514                 )\n515         return result\n516     elif combine_attrs == \"identical\":\n517         result = dict(variable_attrs[0])\n518         for attrs in variable_attrs[1:]:\n519             if not dict_equiv(result, attrs):\n520                 raise MergeError(\n521                     \"combine_attrs='identical', but attrs differ. First is %s \"\n522                     \", other is %s.\" % (str(result), str(attrs))\n523                 )\n524         return result\n525     else:\n526         raise ValueError(\"Unrecognised value for combine_attrs=%s\" % combine_attrs)\n527 \n528 \n529 class _MergeResult(NamedTuple):\n530     variables: Dict[Hashable, Variable]\n531     coord_names: Set[Hashable]\n532     dims: Dict[Hashable, int]\n533     indexes: Dict[Hashable, pd.Index]\n534     attrs: Dict[Hashable, Any]\n535 \n536 \n537 def merge_core(\n538     objects: Iterable[\"CoercibleMapping\"],\n539     compat: str = \"broadcast_equals\",\n540     join: str = \"outer\",\n541     combine_attrs: Optional[str] = \"override\",\n542     priority_arg: Optional[int] = None,\n543     explicit_coords: Optional[Sequence] = None,\n544     indexes: Optional[Mapping[Hashable, pd.Index]] = None,\n545     fill_value: object = dtypes.NA,\n546 ) -> _MergeResult:\n547     \"\"\"Core logic for merging labeled objects.\n548 \n549     This is not public API.\n550 \n551     Parameters\n552     ----------\n553     objects : list of mapping\n554         All values must be convertable to labeled arrays.\n555     compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\", \"override\"}, optional\n556         Compatibility checks to use when merging variables.\n557     join : {\"outer\", \"inner\", \"left\", \"right\"}, optional\n558         How to combine objects with different indexes.\n559     combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, optional\n560         How to combine attributes of objects\n561     priority_arg : int, optional\n562         Optional argument in `objects` that takes precedence over the others.\n563     explicit_coords : set, optional\n564         An explicit list of variables from `objects` that are coordinates.\n565     indexes : dict, optional\n566         Dictionary with values given by pandas.Index objects.\n567     fill_value : scalar, optional\n568         Value to use for newly missing values\n569 \n570     Returns\n571     -------\n572     variables : dict\n573         Dictionary of Variable objects.\n574     coord_names : set\n575         Set of coordinate names.\n576     dims : dict\n577         Dictionary mapping from dimension names to sizes.\n578     attrs : dict\n579         Dictionary of attributes\n580 \n581     Raises\n582     ------\n583     MergeError if the merge cannot be done successfully.\n584     \"\"\"\n585     from .dataarray import DataArray\n586     from .dataset import Dataset, calculate_dimensions\n587 \n588     _assert_compat_valid(compat)\n589 \n590     coerced = coerce_pandas_values(objects)\n591     aligned = deep_align(\n592         coerced, join=join, copy=False, indexes=indexes, fill_value=fill_value\n593     )\n594     collected = collect_variables_and_indexes(aligned)\n595 \n596     prioritized = _get_priority_vars_and_indexes(aligned, priority_arg, compat=compat)\n597     variables, out_indexes = merge_collected(collected, prioritized, compat=compat)\n598     assert_unique_multiindex_level_names(variables)\n599 \n600     dims = calculate_dimensions(variables)\n601 \n602     coord_names, noncoord_names = determine_coords(coerced)\n603     if explicit_coords is not None:\n604         assert_valid_explicit_coords(variables, dims, explicit_coords)\n605         coord_names.update(explicit_coords)\n606     for dim, size in dims.items():\n607         if dim in variables:\n608             coord_names.add(dim)\n609     ambiguous_coords = coord_names.intersection(noncoord_names)\n610     if ambiguous_coords:\n611         raise MergeError(\n612             \"unable to determine if these variables should be \"\n613             \"coordinates or not in the merged result: %s\" % ambiguous_coords\n614         )\n615 \n616     attrs = merge_attrs(\n617         [\n618             var.attrs\n619             for var in coerced\n620             if isinstance(var, Dataset) or isinstance(var, DataArray)\n621         ],\n622         combine_attrs,\n623     )\n624 \n625     return _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n626 \n627 \n628 def merge(\n629     objects: Iterable[Union[\"DataArray\", \"CoercibleMapping\"]],\n630     compat: str = \"no_conflicts\",\n631     join: str = \"outer\",\n632     fill_value: object = dtypes.NA,\n633     combine_attrs: str = \"drop\",\n634 ) -> \"Dataset\":\n635     \"\"\"Merge any number of xarray objects into a single Dataset as variables.\n636 \n637     Parameters\n638     ----------\n639     objects : iterable of Dataset or iterable of DataArray or iterable of dict-like\n640         Merge together all variables from these objects. If any of them are\n641         DataArray objects, they must have a name.\n642     compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\", \"override\"}, optional\n643         String indicating how to compare variables of the same name for\n644         potential conflicts:\n645 \n646         - \"broadcast_equals\": all values must be equal when variables are\n647           broadcast against each other to ensure common dimensions.\n648         - \"equals\": all values and dimensions must be the same.\n649         - \"identical\": all values, dimensions and attributes must be the\n650           same.\n651         - \"no_conflicts\": only values which are not null in both datasets\n652           must be equal. The returned dataset then contains the combination\n653           of all non-null values.\n654         - \"override\": skip comparing and pick variable from first dataset\n655     join : {\"outer\", \"inner\", \"left\", \"right\", \"exact\"}, optional\n656         String indicating how to combine differing indexes in objects.\n657 \n658         - \"outer\": use the union of object indexes\n659         - \"inner\": use the intersection of object indexes\n660         - \"left\": use indexes from the first object with each dimension\n661         - \"right\": use indexes from the last object with each dimension\n662         - \"exact\": instead of aligning, raise `ValueError` when indexes to be\n663           aligned are not equal\n664         - \"override\": if indexes are of same size, rewrite indexes to be\n665           those of the first object with that dimension. Indexes for the same\n666           dimension must have the same size in all objects.\n667     fill_value : scalar or dict-like, optional\n668         Value to use for newly missing values. If a dict-like, maps\n669         variable names to fill values. Use a data array's name to\n670         refer to its values.\n671     combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\\n672                     default: \"drop\"\n673         String indicating how to combine attrs of the objects being merged:\n674 \n675         - \"drop\": empty attrs on returned Dataset.\n676         - \"identical\": all attrs must be the same on every object.\n677         - \"no_conflicts\": attrs from all objects are combined, any that have\n678           the same name must also have the same value.\n679         - \"override\": skip comparing and copy attrs from the first dataset to\n680           the result.\n681 \n682     Returns\n683     -------\n684     Dataset\n685         Dataset with combined variables from each object.\n686 \n687     Examples\n688     --------\n689     >>> import xarray as xr\n690     >>> x = xr.DataArray(\n691     ...     [[1.0, 2.0], [3.0, 5.0]],\n692     ...     dims=(\"lat\", \"lon\"),\n693     ...     coords={\"lat\": [35.0, 40.0], \"lon\": [100.0, 120.0]},\n694     ...     name=\"var1\",\n695     ... )\n696     >>> y = xr.DataArray(\n697     ...     [[5.0, 6.0], [7.0, 8.0]],\n698     ...     dims=(\"lat\", \"lon\"),\n699     ...     coords={\"lat\": [35.0, 42.0], \"lon\": [100.0, 150.0]},\n700     ...     name=\"var2\",\n701     ... )\n702     >>> z = xr.DataArray(\n703     ...     [[0.0, 3.0], [4.0, 9.0]],\n704     ...     dims=(\"time\", \"lon\"),\n705     ...     coords={\"time\": [30.0, 60.0], \"lon\": [100.0, 150.0]},\n706     ...     name=\"var3\",\n707     ... )\n708 \n709     >>> x\n710     <xarray.DataArray 'var1' (lat: 2, lon: 2)>\n711     array([[1., 2.],\n712            [3., 5.]])\n713     Coordinates:\n714       * lat      (lat) float64 35.0 40.0\n715       * lon      (lon) float64 100.0 120.0\n716 \n717     >>> y\n718     <xarray.DataArray 'var2' (lat: 2, lon: 2)>\n719     array([[5., 6.],\n720            [7., 8.]])\n721     Coordinates:\n722       * lat      (lat) float64 35.0 42.0\n723       * lon      (lon) float64 100.0 150.0\n724 \n725     >>> z\n726     <xarray.DataArray 'var3' (time: 2, lon: 2)>\n727     array([[0., 3.],\n728            [4., 9.]])\n729     Coordinates:\n730       * time     (time) float64 30.0 60.0\n731       * lon      (lon) float64 100.0 150.0\n732 \n733     >>> xr.merge([x, y, z])\n734     <xarray.Dataset>\n735     Dimensions:  (lat: 3, lon: 3, time: 2)\n736     Coordinates:\n737       * lat      (lat) float64 35.0 40.0 42.0\n738       * lon      (lon) float64 100.0 120.0 150.0\n739       * time     (time) float64 30.0 60.0\n740     Data variables:\n741         var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan\n742         var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0\n743         var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0\n744 \n745     >>> xr.merge([x, y, z], compat=\"identical\")\n746     <xarray.Dataset>\n747     Dimensions:  (lat: 3, lon: 3, time: 2)\n748     Coordinates:\n749       * lat      (lat) float64 35.0 40.0 42.0\n750       * lon      (lon) float64 100.0 120.0 150.0\n751       * time     (time) float64 30.0 60.0\n752     Data variables:\n753         var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan\n754         var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0\n755         var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0\n756 \n757     >>> xr.merge([x, y, z], compat=\"equals\")\n758     <xarray.Dataset>\n759     Dimensions:  (lat: 3, lon: 3, time: 2)\n760     Coordinates:\n761       * lat      (lat) float64 35.0 40.0 42.0\n762       * lon      (lon) float64 100.0 120.0 150.0\n763       * time     (time) float64 30.0 60.0\n764     Data variables:\n765         var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan\n766         var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0\n767         var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0\n768 \n769     >>> xr.merge([x, y, z], compat=\"equals\", fill_value=-999.0)\n770     <xarray.Dataset>\n771     Dimensions:  (lat: 3, lon: 3, time: 2)\n772     Coordinates:\n773       * lat      (lat) float64 35.0 40.0 42.0\n774       * lon      (lon) float64 100.0 120.0 150.0\n775       * time     (time) float64 30.0 60.0\n776     Data variables:\n777         var1     (lat, lon) float64 1.0 2.0 -999.0 3.0 ... -999.0 -999.0 -999.0\n778         var2     (lat, lon) float64 5.0 -999.0 6.0 -999.0 ... -999.0 7.0 -999.0 8.0\n779         var3     (time, lon) float64 0.0 -999.0 3.0 4.0 -999.0 9.0\n780 \n781     >>> xr.merge([x, y, z], join=\"override\")\n782     <xarray.Dataset>\n783     Dimensions:  (lat: 2, lon: 2, time: 2)\n784     Coordinates:\n785       * lat      (lat) float64 35.0 40.0\n786       * lon      (lon) float64 100.0 120.0\n787       * time     (time) float64 30.0 60.0\n788     Data variables:\n789         var1     (lat, lon) float64 1.0 2.0 3.0 5.0\n790         var2     (lat, lon) float64 5.0 6.0 7.0 8.0\n791         var3     (time, lon) float64 0.0 3.0 4.0 9.0\n792 \n793     >>> xr.merge([x, y, z], join=\"inner\")\n794     <xarray.Dataset>\n795     Dimensions:  (lat: 1, lon: 1, time: 2)\n796     Coordinates:\n797       * lat      (lat) float64 35.0\n798       * lon      (lon) float64 100.0\n799       * time     (time) float64 30.0 60.0\n800     Data variables:\n801         var1     (lat, lon) float64 1.0\n802         var2     (lat, lon) float64 5.0\n803         var3     (time, lon) float64 0.0 4.0\n804 \n805     >>> xr.merge([x, y, z], compat=\"identical\", join=\"inner\")\n806     <xarray.Dataset>\n807     Dimensions:  (lat: 1, lon: 1, time: 2)\n808     Coordinates:\n809       * lat      (lat) float64 35.0\n810       * lon      (lon) float64 100.0\n811       * time     (time) float64 30.0 60.0\n812     Data variables:\n813         var1     (lat, lon) float64 1.0\n814         var2     (lat, lon) float64 5.0\n815         var3     (time, lon) float64 0.0 4.0\n816 \n817     >>> xr.merge([x, y, z], compat=\"broadcast_equals\", join=\"outer\")\n818     <xarray.Dataset>\n819     Dimensions:  (lat: 3, lon: 3, time: 2)\n820     Coordinates:\n821       * lat      (lat) float64 35.0 40.0 42.0\n822       * lon      (lon) float64 100.0 120.0 150.0\n823       * time     (time) float64 30.0 60.0\n824     Data variables:\n825         var1     (lat, lon) float64 1.0 2.0 nan 3.0 5.0 nan nan nan nan\n826         var2     (lat, lon) float64 5.0 nan 6.0 nan nan nan 7.0 nan 8.0\n827         var3     (time, lon) float64 0.0 nan 3.0 4.0 nan 9.0\n828 \n829     >>> xr.merge([x, y, z], join=\"exact\")\n830     Traceback (most recent call last):\n831     ...\n832     ValueError: indexes along dimension 'lat' are not equal\n833 \n834     Raises\n835     ------\n836     xarray.MergeError\n837         If any variables with the same name have conflicting values.\n838 \n839     See also\n840     --------\n841     concat\n842     \"\"\"\n843     from .dataarray import DataArray\n844     from .dataset import Dataset\n845 \n846     dict_like_objects = []\n847     for obj in objects:\n848         if not isinstance(obj, (DataArray, Dataset, dict)):\n849             raise TypeError(\n850                 \"objects must be an iterable containing only \"\n851                 \"Dataset(s), DataArray(s), and dictionaries.\"\n852             )\n853 \n854         obj = obj.to_dataset(promote_attrs=True) if isinstance(obj, DataArray) else obj\n855         dict_like_objects.append(obj)\n856 \n857     merge_result = merge_core(\n858         dict_like_objects,\n859         compat,\n860         join,\n861         combine_attrs=combine_attrs,\n862         fill_value=fill_value,\n863     )\n864     merged = Dataset._construct_direct(**merge_result._asdict())\n865     return merged\n866 \n867 \n868 def dataset_merge_method(\n869     dataset: \"Dataset\",\n870     other: \"CoercibleMapping\",\n871     overwrite_vars: Union[Hashable, Iterable[Hashable]],\n872     compat: str,\n873     join: str,\n874     fill_value: Any,\n875 ) -> _MergeResult:\n876     \"\"\"Guts of the Dataset.merge method.\"\"\"\n877     # we are locked into supporting overwrite_vars for the Dataset.merge\n878     # method due for backwards compatibility\n879     # TODO: consider deprecating it?\n880 \n881     if isinstance(overwrite_vars, Iterable) and not isinstance(overwrite_vars, str):\n882         overwrite_vars = set(overwrite_vars)\n883     else:\n884         overwrite_vars = {overwrite_vars}\n885 \n886     if not overwrite_vars:\n887         objs = [dataset, other]\n888         priority_arg = None\n889     elif overwrite_vars == set(other):\n890         objs = [dataset, other]\n891         priority_arg = 1\n892     else:\n893         other_overwrite: Dict[Hashable, CoercibleValue] = {}\n894         other_no_overwrite: Dict[Hashable, CoercibleValue] = {}\n895         for k, v in other.items():\n896             if k in overwrite_vars:\n897                 other_overwrite[k] = v\n898             else:\n899                 other_no_overwrite[k] = v\n900         objs = [dataset, other_no_overwrite, other_overwrite]\n901         priority_arg = 2\n902 \n903     return merge_core(\n904         objs, compat, join, priority_arg=priority_arg, fill_value=fill_value\n905     )\n906 \n907 \n908 def dataset_update_method(\n909     dataset: \"Dataset\", other: \"CoercibleMapping\"\n910 ) -> _MergeResult:\n911     \"\"\"Guts of the Dataset.update method.\n912 \n913     This drops a duplicated coordinates from `other` if `other` is not an\n914     `xarray.Dataset`, e.g., if it's a dict with DataArray values (GH2068,\n915     GH2180).\n916     \"\"\"\n917     from .dataarray import DataArray\n918     from .dataset import Dataset\n919 \n920     if not isinstance(other, Dataset):\n921         other = dict(other)\n922         for key, value in other.items():\n923             if isinstance(value, DataArray):\n924                 # drop conflicting coordinates\n925                 coord_names = [\n926                     c\n927                     for c in value.coords\n928                     if c not in value.dims and c in dataset.coords\n929                 ]\n930                 if coord_names:\n931                     other[key] = value.drop_vars(coord_names)\n932 \n933     # use ds.coords and not ds.indexes, else str coords are cast to object\n934     indexes = {key: dataset.coords[key] for key in dataset.indexes.keys()}\n935     return merge_core(\n936         [dataset, other],\n937         priority_arg=1,\n938         indexes=indexes,\n939         combine_attrs=\"override\",\n940     )\n",
        "intended_behavior": "This file likely contains the core logic for merging xarray objects and handling the combine_attrs parameter. To resolve the issue, the method(s) within this file that implement the combine_attrs logic must be extended to include a new option, drop_conflicts (or matching, as suggested). The intended behavior here is to iterate over the attributes of the objects being merged, compare them, and for any attribute with conflicting values (i.e., same name but different values), those attributes should be silently dropped instead of raising an error or including them in the merged object. This functionality preserves existing options (drop, identical, no_conflicts, override) while adding the new behavior as an additional choice for users."
    },
    {
        "rel_file_path": "xarray/core/combine.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.12/xarray/core/combine.py",
        "start": 1,
        "end": 800,
        "class_name": null,
        "method_name": null,
        "code": "1 import itertools\n2 from collections import Counter\n3 \n4 import pandas as pd\n5 \n6 from . import dtypes\n7 from .concat import concat\n8 from .dataarray import DataArray\n9 from .dataset import Dataset\n10 from .merge import merge\n11 \n12 \n13 def _infer_concat_order_from_positions(datasets):\n14     combined_ids = dict(_infer_tile_ids_from_nested_list(datasets, ()))\n15     return combined_ids\n16 \n17 \n18 def _infer_tile_ids_from_nested_list(entry, current_pos):\n19     \"\"\"\n20     Given a list of lists (of lists...) of objects, returns a iterator\n21     which returns a tuple containing the index of each object in the nested\n22     list structure as the key, and the object. This can then be called by the\n23     dict constructor to create a dictionary of the objects organised by their\n24     position in the original nested list.\n25 \n26     Recursively traverses the given structure, while keeping track of the\n27     current position. Should work for any type of object which isn't a list.\n28 \n29     Parameters\n30     ----------\n31     entry : list[list[obj, obj, ...], ...]\n32         List of lists of arbitrary depth, containing objects in the order\n33         they are to be concatenated.\n34 \n35     Returns\n36     -------\n37     combined_tile_ids : dict[tuple(int, ...), obj]\n38     \"\"\"\n39 \n40     if isinstance(entry, list):\n41         for i, item in enumerate(entry):\n42             yield from _infer_tile_ids_from_nested_list(item, current_pos + (i,))\n43     else:\n44         yield current_pos, entry\n45 \n46 \n47 def _infer_concat_order_from_coords(datasets):\n48 \n49     concat_dims = []\n50     tile_ids = [() for ds in datasets]\n51 \n52     # All datasets have same variables because they've been grouped as such\n53     ds0 = datasets[0]\n54     for dim in ds0.dims:\n55 \n56         # Check if dim is a coordinate dimension\n57         if dim in ds0:\n58 \n59             # Need to read coordinate values to do ordering\n60             indexes = [ds.indexes.get(dim) for ds in datasets]\n61             if any(index is None for index in indexes):\n62                 raise ValueError(\n63                     \"Every dimension needs a coordinate for \"\n64                     \"inferring concatenation order\"\n65                 )\n66 \n67             # If dimension coordinate values are same on every dataset then\n68             # should be leaving this dimension alone (it's just a \"bystander\")\n69             if not all(index.equals(indexes[0]) for index in indexes[1:]):\n70 \n71                 # Infer order datasets should be arranged in along this dim\n72                 concat_dims.append(dim)\n73 \n74                 if all(index.is_monotonic_increasing for index in indexes):\n75                     ascending = True\n76                 elif all(index.is_monotonic_decreasing for index in indexes):\n77                     ascending = False\n78                 else:\n79                     raise ValueError(\n80                         \"Coordinate variable {} is neither \"\n81                         \"monotonically increasing nor \"\n82                         \"monotonically decreasing on all datasets\".format(dim)\n83                     )\n84 \n85                 # Assume that any two datasets whose coord along dim starts\n86                 # with the same value have the same coord values throughout.\n87                 if any(index.size == 0 for index in indexes):\n88                     raise ValueError(\"Cannot handle size zero dimensions\")\n89                 first_items = pd.Index([index[0] for index in indexes])\n90 \n91                 # Sort datasets along dim\n92                 # We want rank but with identical elements given identical\n93                 # position indices - they should be concatenated along another\n94                 # dimension, not along this one\n95                 series = first_items.to_series()\n96                 rank = series.rank(\n97                     method=\"dense\", ascending=ascending, numeric_only=False\n98                 )\n99                 order = rank.astype(int).values - 1\n100 \n101                 # Append positions along extra dimension to structure which\n102                 # encodes the multi-dimensional concatentation order\n103                 tile_ids = [\n104                     tile_id + (position,) for tile_id, position in zip(tile_ids, order)\n105                 ]\n106 \n107     if len(datasets) > 1 and not concat_dims:\n108         raise ValueError(\n109             \"Could not find any dimension coordinates to use to \"\n110             \"order the datasets for concatenation\"\n111         )\n112 \n113     combined_ids = dict(zip(tile_ids, datasets))\n114 \n115     return combined_ids, concat_dims\n116 \n117 \n118 def _check_dimension_depth_tile_ids(combined_tile_ids):\n119     \"\"\"\n120     Check all tuples are the same length, i.e. check that all lists are\n121     nested to the same depth.\n122     \"\"\"\n123     tile_ids = combined_tile_ids.keys()\n124     nesting_depths = [len(tile_id) for tile_id in tile_ids]\n125     if not nesting_depths:\n126         nesting_depths = [0]\n127     if not set(nesting_depths) == {nesting_depths[0]}:\n128         raise ValueError(\n129             \"The supplied objects do not form a hypercube because\"\n130             \" sub-lists do not have consistent depths\"\n131         )\n132     # return these just to be reused in _check_shape_tile_ids\n133     return tile_ids, nesting_depths\n134 \n135 \n136 def _check_shape_tile_ids(combined_tile_ids):\n137     \"\"\"Check all lists along one dimension are same length.\"\"\"\n138     tile_ids, nesting_depths = _check_dimension_depth_tile_ids(combined_tile_ids)\n139     for dim in range(nesting_depths[0]):\n140         indices_along_dim = [tile_id[dim] for tile_id in tile_ids]\n141         occurrences = Counter(indices_along_dim)\n142         if len(set(occurrences.values())) != 1:\n143             raise ValueError(\n144                 \"The supplied objects do not form a hypercube \"\n145                 \"because sub-lists do not have consistent \"\n146                 \"lengths along dimension\" + str(dim)\n147             )\n148 \n149 \n150 def _combine_nd(\n151     combined_ids,\n152     concat_dims,\n153     data_vars=\"all\",\n154     coords=\"different\",\n155     compat=\"no_conflicts\",\n156     fill_value=dtypes.NA,\n157     join=\"outer\",\n158     combine_attrs=\"drop\",\n159 ):\n160     \"\"\"\n161     Combines an N-dimensional structure of datasets into one by applying a\n162     series of either concat and merge operations along each dimension.\n163 \n164     No checks are performed on the consistency of the datasets, concat_dims or\n165     tile_IDs, because it is assumed that this has already been done.\n166 \n167     Parameters\n168     ----------\n169     combined_ids : Dict[Tuple[int, ...]], xarray.Dataset]\n170         Structure containing all datasets to be concatenated with \"tile_IDs\" as\n171         keys, which specify position within the desired final combined result.\n172     concat_dims : sequence of str\n173         The dimensions along which the datasets should be concatenated. Must be\n174         in order, and the length must match the length of the tuples used as\n175         keys in combined_ids. If the string is a dimension name then concat\n176         along that dimension, if it is None then merge.\n177 \n178     Returns\n179     -------\n180     combined_ds : xarray.Dataset\n181     \"\"\"\n182 \n183     example_tile_id = next(iter(combined_ids.keys()))\n184 \n185     n_dims = len(example_tile_id)\n186     if len(concat_dims) != n_dims:\n187         raise ValueError(\n188             \"concat_dims has length {} but the datasets \"\n189             \"passed are nested in a {}-dimensional structure\".format(\n190                 len(concat_dims), n_dims\n191             )\n192         )\n193 \n194     # Each iteration of this loop reduces the length of the tile_ids tuples\n195     # by one. It always combines along the first dimension, removing the first\n196     # element of the tuple\n197     for concat_dim in concat_dims:\n198         combined_ids = _combine_all_along_first_dim(\n199             combined_ids,\n200             dim=concat_dim,\n201             data_vars=data_vars,\n202             coords=coords,\n203             compat=compat,\n204             fill_value=fill_value,\n205             join=join,\n206             combine_attrs=combine_attrs,\n207         )\n208     (combined_ds,) = combined_ids.values()\n209     return combined_ds\n210 \n211 \n212 def _combine_all_along_first_dim(\n213     combined_ids,\n214     dim,\n215     data_vars,\n216     coords,\n217     compat,\n218     fill_value=dtypes.NA,\n219     join=\"outer\",\n220     combine_attrs=\"drop\",\n221 ):\n222 \n223     # Group into lines of datasets which must be combined along dim\n224     # need to sort by _new_tile_id first for groupby to work\n225     # TODO: is the sorted need?\n226     combined_ids = dict(sorted(combined_ids.items(), key=_new_tile_id))\n227     grouped = itertools.groupby(combined_ids.items(), key=_new_tile_id)\n228 \n229     # Combine all of these datasets along dim\n230     new_combined_ids = {}\n231     for new_id, group in grouped:\n232         combined_ids = dict(sorted(group))\n233         datasets = combined_ids.values()\n234         new_combined_ids[new_id] = _combine_1d(\n235             datasets, dim, compat, data_vars, coords, fill_value, join, combine_attrs\n236         )\n237     return new_combined_ids\n238 \n239 \n240 def _combine_1d(\n241     datasets,\n242     concat_dim,\n243     compat=\"no_conflicts\",\n244     data_vars=\"all\",\n245     coords=\"different\",\n246     fill_value=dtypes.NA,\n247     join=\"outer\",\n248     combine_attrs=\"drop\",\n249 ):\n250     \"\"\"\n251     Applies either concat or merge to 1D list of datasets depending on value\n252     of concat_dim\n253     \"\"\"\n254 \n255     if concat_dim is not None:\n256         try:\n257             combined = concat(\n258                 datasets,\n259                 dim=concat_dim,\n260                 data_vars=data_vars,\n261                 coords=coords,\n262                 compat=compat,\n263                 fill_value=fill_value,\n264                 join=join,\n265                 combine_attrs=combine_attrs,\n266             )\n267         except ValueError as err:\n268             if \"encountered unexpected variable\" in str(err):\n269                 raise ValueError(\n270                     \"These objects cannot be combined using only \"\n271                     \"xarray.combine_nested, instead either use \"\n272                     \"xarray.combine_by_coords, or do it manually \"\n273                     \"with xarray.concat, xarray.merge and \"\n274                     \"xarray.align\"\n275                 )\n276             else:\n277                 raise\n278     else:\n279         combined = merge(\n280             datasets,\n281             compat=compat,\n282             fill_value=fill_value,\n283             join=join,\n284             combine_attrs=combine_attrs,\n285         )\n286 \n287     return combined\n288 \n289 \n290 def _new_tile_id(single_id_ds_pair):\n291     tile_id, ds = single_id_ds_pair\n292     return tile_id[1:]\n293 \n294 \n295 def _nested_combine(\n296     datasets,\n297     concat_dims,\n298     compat,\n299     data_vars,\n300     coords,\n301     ids,\n302     fill_value=dtypes.NA,\n303     join=\"outer\",\n304     combine_attrs=\"drop\",\n305 ):\n306 \n307     if len(datasets) == 0:\n308         return Dataset()\n309 \n310     # Arrange datasets for concatenation\n311     # Use information from the shape of the user input\n312     if not ids:\n313         # Determine tile_IDs by structure of input in N-D\n314         # (i.e. ordering in list-of-lists)\n315         combined_ids = _infer_concat_order_from_positions(datasets)\n316     else:\n317         # Already sorted so just use the ids already passed\n318         combined_ids = dict(zip(ids, datasets))\n319 \n320     # Check that the inferred shape is combinable\n321     _check_shape_tile_ids(combined_ids)\n322 \n323     # Apply series of concatenate or merge operations along each dimension\n324     combined = _combine_nd(\n325         combined_ids,\n326         concat_dims,\n327         compat=compat,\n328         data_vars=data_vars,\n329         coords=coords,\n330         fill_value=fill_value,\n331         join=join,\n332         combine_attrs=combine_attrs,\n333     )\n334     return combined\n335 \n336 \n337 def combine_nested(\n338     datasets,\n339     concat_dim,\n340     compat=\"no_conflicts\",\n341     data_vars=\"all\",\n342     coords=\"different\",\n343     fill_value=dtypes.NA,\n344     join=\"outer\",\n345     combine_attrs=\"drop\",\n346 ):\n347     \"\"\"\n348     Explicitly combine an N-dimensional grid of datasets into one by using a\n349     succession of concat and merge operations along each dimension of the grid.\n350 \n351     Does not sort the supplied datasets under any circumstances, so the\n352     datasets must be passed in the order you wish them to be concatenated. It\n353     does align coordinates, but different variables on datasets can cause it to\n354     fail under some scenarios. In complex cases, you may need to clean up your\n355     data and use concat/merge explicitly.\n356 \n357     To concatenate along multiple dimensions the datasets must be passed as a\n358     nested list-of-lists, with a depth equal to the length of ``concat_dims``.\n359     ``manual_combine`` will concatenate along the top-level list first.\n360 \n361     Useful for combining datasets from a set of nested directories, or for\n362     collecting the output of a simulation parallelized along multiple\n363     dimensions.\n364 \n365     Parameters\n366     ----------\n367     datasets : list or nested list of Dataset\n368         Dataset objects to combine.\n369         If concatenation or merging along more than one dimension is desired,\n370         then datasets must be supplied in a nested list-of-lists.\n371     concat_dim : str, or list of str, DataArray, Index or None\n372         Dimensions along which to concatenate variables, as used by\n373         :py:func:`xarray.concat`.\n374         Set ``concat_dim=[..., None, ...]`` explicitly to disable concatenation\n375         and merge instead along a particular dimension.\n376         The position of ``None`` in the list specifies the dimension of the\n377         nested-list input along which to merge.\n378         Must be the same length as the depth of the list passed to\n379         ``datasets``.\n380     compat : {\"identical\", \"equals\", \"broadcast_equals\", \\\n381               \"no_conflicts\", \"override\"}, optional\n382         String indicating how to compare variables of the same name for\n383         potential merge conflicts:\n384 \n385         - \"broadcast_equals\": all values must be equal when variables are\n386           broadcast against each other to ensure common dimensions.\n387         - \"equals\": all values and dimensions must be the same.\n388         - \"identical\": all values, dimensions and attributes must be the\n389           same.\n390         - \"no_conflicts\": only values which are not null in both datasets\n391           must be equal. The returned dataset then contains the combination\n392           of all non-null values.\n393         - \"override\": skip comparing and pick variable from first dataset\n394     data_vars : {\"minimal\", \"different\", \"all\" or list of str}, optional\n395         Details are in the documentation of concat\n396     coords : {\"minimal\", \"different\", \"all\" or list of str}, optional\n397         Details are in the documentation of concat\n398     fill_value : scalar or dict-like, optional\n399         Value to use for newly missing values. If a dict-like, maps\n400         variable names to fill values. Use a data array's name to\n401         refer to its values.\n402     join : {\"outer\", \"inner\", \"left\", \"right\", \"exact\"}, optional\n403         String indicating how to combine differing indexes\n404         (excluding concat_dim) in objects\n405 \n406         - \"outer\": use the union of object indexes\n407         - \"inner\": use the intersection of object indexes\n408         - \"left\": use indexes from the first object with each dimension\n409         - \"right\": use indexes from the last object with each dimension\n410         - \"exact\": instead of aligning, raise `ValueError` when indexes to be\n411           aligned are not equal\n412         - \"override\": if indexes are of same size, rewrite indexes to be\n413           those of the first object with that dimension. Indexes for the same\n414           dimension must have the same size in all objects.\n415     combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\\n416                     default: \"drop\"\n417         String indicating how to combine attrs of the objects being merged:\n418 \n419         - \"drop\": empty attrs on returned Dataset.\n420         - \"identical\": all attrs must be the same on every object.\n421         - \"no_conflicts\": attrs from all objects are combined, any that have\n422           the same name must also have the same value.\n423         - \"override\": skip comparing and copy attrs from the first dataset to\n424           the result.\n425 \n426     Returns\n427     -------\n428     combined : xarray.Dataset\n429 \n430     Examples\n431     --------\n432 \n433     A common task is collecting data from a parallelized simulation in which\n434     each process wrote out to a separate file. A domain which was decomposed\n435     into 4 parts, 2 each along both the x and y axes, requires organising the\n436     datasets into a doubly-nested list, e.g:\n437 \n438     >>> x1y1 = xr.Dataset(\n439     ...     {\n440     ...         \"temperature\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n441     ...         \"precipitation\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n442     ...     }\n443     ... )\n444     >>> x1y1\n445     <xarray.Dataset>\n446     Dimensions:        (x: 2, y: 2)\n447     Dimensions without coordinates: x, y\n448     Data variables:\n449         temperature    (x, y) float64 1.764 0.4002 0.9787 2.241\n450         precipitation  (x, y) float64 1.868 -0.9773 0.9501 -0.1514\n451     >>> x1y2 = xr.Dataset(\n452     ...     {\n453     ...         \"temperature\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n454     ...         \"precipitation\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n455     ...     }\n456     ... )\n457     >>> x2y1 = xr.Dataset(\n458     ...     {\n459     ...         \"temperature\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n460     ...         \"precipitation\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n461     ...     }\n462     ... )\n463     >>> x2y2 = xr.Dataset(\n464     ...     {\n465     ...         \"temperature\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n466     ...         \"precipitation\": ((\"x\", \"y\"), np.random.randn(2, 2)),\n467     ...     }\n468     ... )\n469 \n470 \n471     >>> ds_grid = [[x1y1, x1y2], [x2y1, x2y2]]\n472     >>> combined = xr.combine_nested(ds_grid, concat_dim=[\"x\", \"y\"])\n473     >>> combined\n474     <xarray.Dataset>\n475     Dimensions:        (x: 4, y: 4)\n476     Dimensions without coordinates: x, y\n477     Data variables:\n478         temperature    (x, y) float64 1.764 0.4002 -0.1032 ... 0.04576 -0.1872\n479         precipitation  (x, y) float64 1.868 -0.9773 0.761 ... -0.7422 0.1549 0.3782\n480 \n481     ``manual_combine`` can also be used to explicitly merge datasets with\n482     different variables. For example if we have 4 datasets, which are divided\n483     along two times, and contain two different variables, we can pass ``None``\n484     to ``concat_dim`` to specify the dimension of the nested list over which\n485     we wish to use ``merge`` instead of ``concat``:\n486 \n487     >>> t1temp = xr.Dataset({\"temperature\": (\"t\", np.random.randn(5))})\n488     >>> t1temp\n489     <xarray.Dataset>\n490     Dimensions:      (t: 5)\n491     Dimensions without coordinates: t\n492     Data variables:\n493         temperature  (t) float64 -0.8878 -1.981 -0.3479 0.1563 1.23\n494 \n495     >>> t1precip = xr.Dataset({\"precipitation\": (\"t\", np.random.randn(5))})\n496     >>> t1precip\n497     <xarray.Dataset>\n498     Dimensions:        (t: 5)\n499     Dimensions without coordinates: t\n500     Data variables:\n501         precipitation  (t) float64 1.202 -0.3873 -0.3023 -1.049 -1.42\n502 \n503     >>> t2temp = xr.Dataset({\"temperature\": (\"t\", np.random.randn(5))})\n504     >>> t2precip = xr.Dataset({\"precipitation\": (\"t\", np.random.randn(5))})\n505 \n506 \n507     >>> ds_grid = [[t1temp, t1precip], [t2temp, t2precip]]\n508     >>> combined = xr.combine_nested(ds_grid, concat_dim=[\"t\", None])\n509     >>> combined\n510     <xarray.Dataset>\n511     Dimensions:        (t: 10)\n512     Dimensions without coordinates: t\n513     Data variables:\n514         temperature    (t) float64 -0.8878 -1.981 -0.3479 ... -0.5097 -0.4381 -1.253\n515         precipitation  (t) float64 1.202 -0.3873 -0.3023 ... -0.2127 -0.8955 0.3869\n516 \n517     See also\n518     --------\n519     concat\n520     merge\n521     \"\"\"\n522     if isinstance(concat_dim, (str, DataArray)) or concat_dim is None:\n523         concat_dim = [concat_dim]\n524 \n525     # The IDs argument tells _manual_combine that datasets aren't yet sorted\n526     return _nested_combine(\n527         datasets,\n528         concat_dims=concat_dim,\n529         compat=compat,\n530         data_vars=data_vars,\n531         coords=coords,\n532         ids=False,\n533         fill_value=fill_value,\n534         join=join,\n535         combine_attrs=combine_attrs,\n536     )\n537 \n538 \n539 def vars_as_keys(ds):\n540     return tuple(sorted(ds))\n541 \n542 \n543 def combine_by_coords(\n544     datasets,\n545     compat=\"no_conflicts\",\n546     data_vars=\"all\",\n547     coords=\"different\",\n548     fill_value=dtypes.NA,\n549     join=\"outer\",\n550     combine_attrs=\"no_conflicts\",\n551 ):\n552     \"\"\"\n553     Attempt to auto-magically combine the given datasets into one by using\n554     dimension coordinates.\n555 \n556     This method attempts to combine a group of datasets along any number of\n557     dimensions into a single entity by inspecting coords and metadata and using\n558     a combination of concat and merge.\n559 \n560     Will attempt to order the datasets such that the values in their dimension\n561     coordinates are monotonic along all dimensions. If it cannot determine the\n562     order in which to concatenate the datasets, it will raise a ValueError.\n563     Non-coordinate dimensions will be ignored, as will any coordinate\n564     dimensions which do not vary between each dataset.\n565 \n566     Aligns coordinates, but different variables on datasets can cause it\n567     to fail under some scenarios. In complex cases, you may need to clean up\n568     your data and use concat/merge explicitly (also see `manual_combine`).\n569 \n570     Works well if, for example, you have N years of data and M data variables,\n571     and each combination of a distinct time period and set of data variables is\n572     saved as its own dataset. Also useful for if you have a simulation which is\n573     parallelized in multiple dimensions, but has global coordinates saved in\n574     each file specifying the positions of points within the global domain.\n575 \n576     Parameters\n577     ----------\n578     datasets : sequence of xarray.Dataset\n579         Dataset objects to combine.\n580     compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\", \"override\"}, optional\n581         String indicating how to compare variables of the same name for\n582         potential conflicts:\n583 \n584         - \"broadcast_equals\": all values must be equal when variables are\n585           broadcast against each other to ensure common dimensions.\n586         - \"equals\": all values and dimensions must be the same.\n587         - \"identical\": all values, dimensions and attributes must be the\n588           same.\n589         - \"no_conflicts\": only values which are not null in both datasets\n590           must be equal. The returned dataset then contains the combination\n591           of all non-null values.\n592         - \"override\": skip comparing and pick variable from first dataset\n593     data_vars : {\"minimal\", \"different\", \"all\" or list of str}, optional\n594         These data variables will be concatenated together:\n595 \n596         * \"minimal\": Only data variables in which the dimension already\n597           appears are included.\n598         * \"different\": Data variables which are not equal (ignoring\n599           attributes) across all datasets are also concatenated (as well as\n600           all for which dimension already appears). Beware: this option may\n601           load the data payload of data variables into memory if they are not\n602           already loaded.\n603         * \"all\": All data variables will be concatenated.\n604         * list of str: The listed data variables will be concatenated, in\n605           addition to the \"minimal\" data variables.\n606 \n607         If objects are DataArrays, `data_vars` must be \"all\".\n608     coords : {\"minimal\", \"different\", \"all\"} or list of str, optional\n609         As per the \"data_vars\" kwarg, but for coordinate variables.\n610     fill_value : scalar or dict-like, optional\n611         Value to use for newly missing values. If a dict-like, maps\n612         variable names to fill values. Use a data array's name to\n613         refer to its values. If None, raises a ValueError if\n614         the passed Datasets do not create a complete hypercube.\n615     join : {\"outer\", \"inner\", \"left\", \"right\", \"exact\"}, optional\n616         String indicating how to combine differing indexes\n617         (excluding concat_dim) in objects\n618 \n619         - \"outer\": use the union of object indexes\n620         - \"inner\": use the intersection of object indexes\n621         - \"left\": use indexes from the first object with each dimension\n622         - \"right\": use indexes from the last object with each dimension\n623         - \"exact\": instead of aligning, raise `ValueError` when indexes to be\n624           aligned are not equal\n625         - \"override\": if indexes are of same size, rewrite indexes to be\n626           those of the first object with that dimension. Indexes for the same\n627           dimension must have the same size in all objects.\n628     combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\\n629                     default: \"drop\"\n630         String indicating how to combine attrs of the objects being merged:\n631 \n632         - \"drop\": empty attrs on returned Dataset.\n633         - \"identical\": all attrs must be the same on every object.\n634         - \"no_conflicts\": attrs from all objects are combined, any that have\n635           the same name must also have the same value.\n636         - \"override\": skip comparing and copy attrs from the first dataset to\n637           the result.\n638 \n639     Returns\n640     -------\n641     combined : xarray.Dataset\n642 \n643     See also\n644     --------\n645     concat\n646     merge\n647     combine_nested\n648 \n649     Examples\n650     --------\n651 \n652     Combining two datasets using their common dimension coordinates. Notice\n653     they are concatenated based on the values in their dimension coordinates,\n654     not on their position in the list passed to `combine_by_coords`.\n655 \n656     >>> import numpy as np\n657     >>> import xarray as xr\n658 \n659     >>> x1 = xr.Dataset(\n660     ...     {\n661     ...         \"temperature\": ((\"y\", \"x\"), 20 * np.random.rand(6).reshape(2, 3)),\n662     ...         \"precipitation\": ((\"y\", \"x\"), np.random.rand(6).reshape(2, 3)),\n663     ...     },\n664     ...     coords={\"y\": [0, 1], \"x\": [10, 20, 30]},\n665     ... )\n666     >>> x2 = xr.Dataset(\n667     ...     {\n668     ...         \"temperature\": ((\"y\", \"x\"), 20 * np.random.rand(6).reshape(2, 3)),\n669     ...         \"precipitation\": ((\"y\", \"x\"), np.random.rand(6).reshape(2, 3)),\n670     ...     },\n671     ...     coords={\"y\": [2, 3], \"x\": [10, 20, 30]},\n672     ... )\n673     >>> x3 = xr.Dataset(\n674     ...     {\n675     ...         \"temperature\": ((\"y\", \"x\"), 20 * np.random.rand(6).reshape(2, 3)),\n676     ...         \"precipitation\": ((\"y\", \"x\"), np.random.rand(6).reshape(2, 3)),\n677     ...     },\n678     ...     coords={\"y\": [2, 3], \"x\": [40, 50, 60]},\n679     ... )\n680 \n681     >>> x1\n682     <xarray.Dataset>\n683     Dimensions:        (x: 3, y: 2)\n684     Coordinates:\n685       * y              (y) int64 0 1\n686       * x              (x) int64 10 20 30\n687     Data variables:\n688         temperature    (y, x) float64 10.98 14.3 12.06 10.9 8.473 12.92\n689         precipitation  (y, x) float64 0.4376 0.8918 0.9637 0.3834 0.7917 0.5289\n690 \n691     >>> x2\n692     <xarray.Dataset>\n693     Dimensions:        (x: 3, y: 2)\n694     Coordinates:\n695       * y              (y) int64 2 3\n696       * x              (x) int64 10 20 30\n697     Data variables:\n698         temperature    (y, x) float64 11.36 18.51 1.421 1.743 0.4044 16.65\n699         precipitation  (y, x) float64 0.7782 0.87 0.9786 0.7992 0.4615 0.7805\n700 \n701     >>> x3\n702     <xarray.Dataset>\n703     Dimensions:        (x: 3, y: 2)\n704     Coordinates:\n705       * y              (y) int64 2 3\n706       * x              (x) int64 40 50 60\n707     Data variables:\n708         temperature    (y, x) float64 2.365 12.8 2.867 18.89 10.44 8.293\n709         precipitation  (y, x) float64 0.2646 0.7742 0.4562 0.5684 0.01879 0.6176\n710 \n711     >>> xr.combine_by_coords([x2, x1])\n712     <xarray.Dataset>\n713     Dimensions:        (x: 3, y: 4)\n714     Coordinates:\n715       * y              (y) int64 0 1 2 3\n716       * x              (x) int64 10 20 30\n717     Data variables:\n718         temperature    (y, x) float64 10.98 14.3 12.06 10.9 ... 1.743 0.4044 16.65\n719         precipitation  (y, x) float64 0.4376 0.8918 0.9637 ... 0.7992 0.4615 0.7805\n720 \n721     >>> xr.combine_by_coords([x3, x1])\n722     <xarray.Dataset>\n723     Dimensions:        (x: 6, y: 4)\n724     Coordinates:\n725       * x              (x) int64 10 20 30 40 50 60\n726       * y              (y) int64 0 1 2 3\n727     Data variables:\n728         temperature    (y, x) float64 10.98 14.3 12.06 nan ... nan 18.89 10.44 8.293\n729         precipitation  (y, x) float64 0.4376 0.8918 0.9637 ... 0.5684 0.01879 0.6176\n730 \n731     >>> xr.combine_by_coords([x3, x1], join=\"override\")\n732     <xarray.Dataset>\n733     Dimensions:        (x: 3, y: 4)\n734     Coordinates:\n735       * x              (x) int64 10 20 30\n736       * y              (y) int64 0 1 2 3\n737     Data variables:\n738         temperature    (y, x) float64 10.98 14.3 12.06 10.9 ... 18.89 10.44 8.293\n739         precipitation  (y, x) float64 0.4376 0.8918 0.9637 ... 0.5684 0.01879 0.6176\n740 \n741     >>> xr.combine_by_coords([x1, x2, x3])\n742     <xarray.Dataset>\n743     Dimensions:        (x: 6, y: 4)\n744     Coordinates:\n745       * x              (x) int64 10 20 30 40 50 60\n746       * y              (y) int64 0 1 2 3\n747     Data variables:\n748         temperature    (y, x) float64 10.98 14.3 12.06 nan ... 18.89 10.44 8.293\n749         precipitation  (y, x) float64 0.4376 0.8918 0.9637 ... 0.5684 0.01879 0.6176\n750     \"\"\"\n751 \n752     # Group by data vars\n753     sorted_datasets = sorted(datasets, key=vars_as_keys)\n754     grouped_by_vars = itertools.groupby(sorted_datasets, key=vars_as_keys)\n755 \n756     # Perform the multidimensional combine on each group of data variables\n757     # before merging back together\n758     concatenated_grouped_by_data_vars = []\n759     for vars, datasets_with_same_vars in grouped_by_vars:\n760         combined_ids, concat_dims = _infer_concat_order_from_coords(\n761             list(datasets_with_same_vars)\n762         )\n763 \n764         if fill_value is None:\n765             # check that datasets form complete hypercube\n766             _check_shape_tile_ids(combined_ids)\n767         else:\n768             # check only that all datasets have same dimension depth for these\n769             # vars\n770             _check_dimension_depth_tile_ids(combined_ids)\n771 \n772         # Concatenate along all of concat_dims one by one to create single ds\n773         concatenated = _combine_nd(\n774             combined_ids,\n775             concat_dims=concat_dims,\n776             data_vars=data_vars,\n777             coords=coords,\n778             compat=compat,\n779             fill_value=fill_value,\n780             join=join,\n781             combine_attrs=combine_attrs,\n782         )\n783 \n784         # Check the overall coordinates are monotonically increasing\n785         for dim in concat_dims:\n786             indexes = concatenated.indexes.get(dim)\n787             if not (indexes.is_monotonic_increasing or indexes.is_monotonic_decreasing):\n788                 raise ValueError(\n789                     \"Resulting object does not have monotonic\"\n790                     \" global indexes along dimension {}\".format(dim)\n791                 )\n792         concatenated_grouped_by_data_vars.append(concatenated)\n793 \n794     return merge(\n795         concatenated_grouped_by_data_vars,\n796         compat=compat,\n797         fill_value=fill_value,\n798         join=join,\n799         combine_attrs=combine_attrs,\n800     )\n",
        "intended_behavior": "Given that this file also deals with handling combine_attrs in the context of combining datasets, it's necessary to include the new drop_conflicts option here too. Any functionality that merges datasets and uses or refers to combine_attrs would need to be updated to recognize and correctly implement the new drop_conflicts logic. Similar to merge.py, this involves comparing attributes for conflicts and excluding any conflicting pairs from the result. The updated behavior must integrate seamlessly with existing combine operations, enabling users to choose the new drop_conflicts option for their combine operations."
    }
]