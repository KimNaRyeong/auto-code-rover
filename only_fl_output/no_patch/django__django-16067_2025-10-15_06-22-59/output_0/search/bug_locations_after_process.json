[
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 402,
        "end": 417,
        "class_name": "DecimalField",
        "method_name": "to_python",
        "code": "402     def to_python(self, value):\n403         \"\"\"\n404         Validate that the input is a decimal number. Return a Decimal\n405         instance or None for empty values. Ensure that there are no more\n406         than max_digits in the number and no more than decimal_places digits\n407         after the decimal point.\n408         \"\"\"\n409         if value in self.empty_values:\n410             return None\n411         if self.localize:\n412             value = formats.sanitize_separators(value)\n413         try:\n414             value = Decimal(str(value))\n415         except DecimalException:\n416             raise ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")\n417         return value\n",
        "intended_behavior": "This method should be enhanced to detect and correctly normalize decimal numbers provided in scientific notation before performing validations for the number of digits and decimal places. This enhancement involves adding a pre-validation step to check if the input value is in scientific notation (e.g., matches a regex pattern for scientific notation) and, if so, converting it to a standard decimal format (e.g., using Decimal(value).normalize()) before proceeding with the existing validation logic. This modification must be done ensuring that any input which is currently handled as valid remains so, ensuring this fix only expands the method's ability to interpret and validate scientific notation correctly."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 1702,
        "end": 1722,
        "class_name": "DecimalField",
        "method_name": "to_python",
        "code": "1702     def to_python(self, value):\n1703         if value is None:\n1704             return value\n1705         try:\n1706             if isinstance(value, float):\n1707                 decimal_value = self.context.create_decimal_from_float(value)\n1708             else:\n1709                 decimal_value = decimal.Decimal(value)\n1710         except (decimal.InvalidOperation, TypeError, ValueError):\n1711             raise exceptions.ValidationError(\n1712                 self.error_messages[\"invalid\"],\n1713                 code=\"invalid\",\n1714                 params={\"value\": value},\n1715             )\n1716         if not decimal_value.is_finite():\n1717             raise exceptions.ValidationError(\n1718                 self.error_messages[\"invalid\"],\n1719                 code=\"invalid\",\n1720                 params={\"value\": value},\n1721             )\n1722         return decimal_value\n",
        "intended_behavior": "This method should be enhanced to detect and correctly normalize decimal numbers provided in scientific notation before performing validations for the number of digits and decimal places. This enhancement involves adding a pre-validation step to check if the input value is in scientific notation (e.g., matches a regex pattern for scientific notation) and, if so, converting it to a standard decimal format (e.g., using Decimal(value).normalize()) before proceeding with the existing validation logic. This modification must be done ensuring that any input which is currently handled as valid remains so, ensuring this fix only expands the method's ability to interpret and validate scientific notation correctly."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 384,
        "end": 440,
        "class_name": "DecimalField",
        "method_name": null,
        "code": "384 class DecimalField(IntegerField):\n385     default_error_messages = {\n386         \"invalid\": _(\"Enter a number.\"),\n387     }\n388 \n389     def __init__(\n390         self,\n391         *,\n392         max_value=None,\n393         min_value=None,\n394         max_digits=None,\n395         decimal_places=None,\n396         **kwargs,\n397     ):\n398         self.max_digits, self.decimal_places = max_digits, decimal_places\n399         super().__init__(max_value=max_value, min_value=min_value, **kwargs)\n400         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))\n401 \n402     def to_python(self, value):\n403         \"\"\"\n404         Validate that the input is a decimal number. Return a Decimal\n405         instance or None for empty values. Ensure that there are no more\n406         than max_digits in the number and no more than decimal_places digits\n407         after the decimal point.\n408         \"\"\"\n409         if value in self.empty_values:\n410             return None\n411         if self.localize:\n412             value = formats.sanitize_separators(value)\n413         try:\n414             value = Decimal(str(value))\n415         except DecimalException:\n416             raise ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")\n417         return value\n418 \n419     def validate(self, value):\n420         super().validate(value)\n421         if value in self.empty_values:\n422             return\n423         if not value.is_finite():\n424             raise ValidationError(\n425                 self.error_messages[\"invalid\"],\n426                 code=\"invalid\",\n427                 params={\"value\": value},\n428             )\n429 \n430     def widget_attrs(self, widget):\n431         attrs = super().widget_attrs(widget)\n432         if isinstance(widget, NumberInput) and \"step\" not in widget.attrs:\n433             if self.decimal_places is not None:\n434                 # Use exponential notation for small values since they might\n435                 # be parsed as 0 otherwise. ref #20765\n436                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()\n437             else:\n438                 step = \"any\"\n439             attrs.setdefault(\"step\", step)\n440         return attrs\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 1591,
        "end": 1741,
        "class_name": "DecimalField",
        "method_name": null,
        "code": "1591 class DecimalField(Field):\n1592     empty_strings_allowed = False\n1593     default_error_messages = {\n1594         \"invalid\": _(\"\u201c%(value)s\u201d value must be a decimal number.\"),\n1595     }\n1596     description = _(\"Decimal number\")\n1597 \n1598     def __init__(\n1599         self,\n1600         verbose_name=None,\n1601         name=None,\n1602         max_digits=None,\n1603         decimal_places=None,\n1604         **kwargs,\n1605     ):\n1606         self.max_digits, self.decimal_places = max_digits, decimal_places\n1607         super().__init__(verbose_name, name, **kwargs)\n1608 \n1609     def check(self, **kwargs):\n1610         errors = super().check(**kwargs)\n1611 \n1612         digits_errors = [\n1613             *self._check_decimal_places(),\n1614             *self._check_max_digits(),\n1615         ]\n1616         if not digits_errors:\n1617             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1618         else:\n1619             errors.extend(digits_errors)\n1620         return errors\n1621 \n1622     def _check_decimal_places(self):\n1623         try:\n1624             decimal_places = int(self.decimal_places)\n1625             if decimal_places < 0:\n1626                 raise ValueError()\n1627         except TypeError:\n1628             return [\n1629                 checks.Error(\n1630                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1631                     obj=self,\n1632                     id=\"fields.E130\",\n1633                 )\n1634             ]\n1635         except ValueError:\n1636             return [\n1637                 checks.Error(\n1638                     \"'decimal_places' must be a non-negative integer.\",\n1639                     obj=self,\n1640                     id=\"fields.E131\",\n1641                 )\n1642             ]\n1643         else:\n1644             return []\n1645 \n1646     def _check_max_digits(self):\n1647         try:\n1648             max_digits = int(self.max_digits)\n1649             if max_digits <= 0:\n1650                 raise ValueError()\n1651         except TypeError:\n1652             return [\n1653                 checks.Error(\n1654                     \"DecimalFields must define a 'max_digits' attribute.\",\n1655                     obj=self,\n1656                     id=\"fields.E132\",\n1657                 )\n1658             ]\n1659         except ValueError:\n1660             return [\n1661                 checks.Error(\n1662                     \"'max_digits' must be a positive integer.\",\n1663                     obj=self,\n1664                     id=\"fields.E133\",\n1665                 )\n1666             ]\n1667         else:\n1668             return []\n1669 \n1670     def _check_decimal_places_and_max_digits(self, **kwargs):\n1671         if int(self.decimal_places) > int(self.max_digits):\n1672             return [\n1673                 checks.Error(\n1674                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1675                     obj=self,\n1676                     id=\"fields.E134\",\n1677                 )\n1678             ]\n1679         return []\n1680 \n1681     @cached_property\n1682     def validators(self):\n1683         return super().validators + [\n1684             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1685         ]\n1686 \n1687     @cached_property\n1688     def context(self):\n1689         return decimal.Context(prec=self.max_digits)\n1690 \n1691     def deconstruct(self):\n1692         name, path, args, kwargs = super().deconstruct()\n1693         if self.max_digits is not None:\n1694             kwargs[\"max_digits\"] = self.max_digits\n1695         if self.decimal_places is not None:\n1696             kwargs[\"decimal_places\"] = self.decimal_places\n1697         return name, path, args, kwargs\n1698 \n1699     def get_internal_type(self):\n1700         return \"DecimalField\"\n1701 \n1702     def to_python(self, value):\n1703         if value is None:\n1704             return value\n1705         try:\n1706             if isinstance(value, float):\n1707                 decimal_value = self.context.create_decimal_from_float(value)\n1708             else:\n1709                 decimal_value = decimal.Decimal(value)\n1710         except (decimal.InvalidOperation, TypeError, ValueError):\n1711             raise exceptions.ValidationError(\n1712                 self.error_messages[\"invalid\"],\n1713                 code=\"invalid\",\n1714                 params={\"value\": value},\n1715             )\n1716         if not decimal_value.is_finite():\n1717             raise exceptions.ValidationError(\n1718                 self.error_messages[\"invalid\"],\n1719                 code=\"invalid\",\n1720                 params={\"value\": value},\n1721             )\n1722         return decimal_value\n1723 \n1724     def get_db_prep_save(self, value, connection):\n1725         return connection.ops.adapt_decimalfield_value(\n1726             self.to_python(value), self.max_digits, self.decimal_places\n1727         )\n1728 \n1729     def get_prep_value(self, value):\n1730         value = super().get_prep_value(value)\n1731         return self.to_python(value)\n1732 \n1733     def formfield(self, **kwargs):\n1734         return super().formfield(\n1735             **{\n1736                 \"max_digits\": self.max_digits,\n1737                 \"decimal_places\": self.decimal_places,\n1738                 \"form_class\": forms.DecimalField,\n1739                 **kwargs,\n1740             }\n1741         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 179,
        "end": 191,
        "class_name": "Field",
        "method_name": "run_validators",
        "code": "179     def run_validators(self, value):\n180         if value in self.empty_values:\n181             return\n182         errors = []\n183         for v in self.validators:\n184             try:\n185                 v(value)\n186             except ValidationError as e:\n187                 if hasattr(e, \"code\") and e.code in self.error_messages:\n188                     e.message = self.error_messages[e.code]\n189                 errors.extend(e.error_list)\n190         if errors:\n191             raise ValidationError(errors)\n",
        "intended_behavior": "While the run_validators method might not directly relate to handling the scientific notation, it's crucial that this method, which orchestrates the validation process, supports the capability to validate decimal numbers in both standard and scientific notation seamlessly. This method should ensure that all validators in the validation chain can handle decimal values correctly post-normalization. If necessary, this could involve ensuring validators are aware of and can correctly interpret the normalized decimal numbers. While no specific change is suggested here without further context, being mindful of how validators are executed and ensuring they are compatible with normalized decimal inputs could be a consideration to prevent similar issues."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 700,
        "end": 714,
        "class_name": "Field",
        "method_name": "run_validators",
        "code": "700     def run_validators(self, value):\n701         if value in self.empty_values:\n702             return\n703 \n704         errors = []\n705         for v in self.validators:\n706             try:\n707                 v(value)\n708             except exceptions.ValidationError as e:\n709                 if hasattr(e, \"code\") and e.code in self.error_messages:\n710                     e.message = self.error_messages[e.code]\n711                 errors.extend(e.error_list)\n712 \n713         if errors:\n714             raise exceptions.ValidationError(errors)\n",
        "intended_behavior": "While the run_validators method might not directly relate to handling the scientific notation, it's crucial that this method, which orchestrates the validation process, supports the capability to validate decimal numbers in both standard and scientific notation seamlessly. This method should ensure that all validators in the validation chain can handle decimal values correctly post-normalization. If necessary, this could involve ensuring validators are aware of and can correctly interpret the normalized decimal numbers. While no specific change is suggested here without further context, being mindful of how validators are executed and ensuring they are compatible with normalized decimal inputs could be a consideration to prevent similar issues."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 82,
        "end": 256,
        "class_name": "Field",
        "method_name": null,
        "code": "82 class Field:\n83     widget = TextInput  # Default widget to use when rendering this type of Field.\n84     hidden_widget = (\n85         HiddenInput  # Default widget to use when rendering this as \"hidden\".\n86     )\n87     default_validators = []  # Default set of validators\n88     # Add an 'invalid' entry to default_error_message if you want a specific\n89     # field error message not raised by the field validators.\n90     default_error_messages = {\n91         \"required\": _(\"This field is required.\"),\n92     }\n93     empty_values = list(validators.EMPTY_VALUES)\n94 \n95     def __init__(\n96         self,\n97         *,\n98         required=True,\n99         widget=None,\n100         label=None,\n101         initial=None,\n102         help_text=\"\",\n103         error_messages=None,\n104         show_hidden_initial=False,\n105         validators=(),\n106         localize=False,\n107         disabled=False,\n108         label_suffix=None,\n109     ):\n110         # required -- Boolean that specifies whether the field is required.\n111         #             True by default.\n112         # widget -- A Widget class, or instance of a Widget class, that should\n113         #           be used for this Field when displaying it. Each Field has a\n114         #           default Widget that it'll use if you don't specify this. In\n115         #           most cases, the default widget is TextInput.\n116         # label -- A verbose name for this field, for use in displaying this\n117         #          field in a form. By default, Django will use a \"pretty\"\n118         #          version of the form field name, if the Field is part of a\n119         #          Form.\n120         # initial -- A value to use in this Field's initial display. This value\n121         #            is *not* used as a fallback if data isn't given.\n122         # help_text -- An optional string to use as \"help text\" for this Field.\n123         # error_messages -- An optional dictionary to override the default\n124         #                   messages that the field will raise.\n125         # show_hidden_initial -- Boolean that specifies if it is needed to render a\n126         #                        hidden widget with initial value after widget.\n127         # validators -- List of additional validators to use\n128         # localize -- Boolean that specifies if the field should be localized.\n129         # disabled -- Boolean that specifies whether the field is disabled, that\n130         #             is its widget is shown in the form but not editable.\n131         # label_suffix -- Suffix to be added to the label. Overrides\n132         #                 form's label_suffix.\n133         self.required, self.label, self.initial = required, label, initial\n134         self.show_hidden_initial = show_hidden_initial\n135         self.help_text = help_text\n136         self.disabled = disabled\n137         self.label_suffix = label_suffix\n138         widget = widget or self.widget\n139         if isinstance(widget, type):\n140             widget = widget()\n141         else:\n142             widget = copy.deepcopy(widget)\n143 \n144         # Trigger the localization machinery if needed.\n145         self.localize = localize\n146         if self.localize:\n147             widget.is_localized = True\n148 \n149         # Let the widget know whether it should display as required.\n150         widget.is_required = self.required\n151 \n152         # Hook into self.widget_attrs() for any Field-specific HTML attributes.\n153         extra_attrs = self.widget_attrs(widget)\n154         if extra_attrs:\n155             widget.attrs.update(extra_attrs)\n156 \n157         self.widget = widget\n158 \n159         messages = {}\n160         for c in reversed(self.__class__.__mro__):\n161             messages.update(getattr(c, \"default_error_messages\", {}))\n162         messages.update(error_messages or {})\n163         self.error_messages = messages\n164 \n165         self.validators = [*self.default_validators, *validators]\n166 \n167         super().__init__()\n168 \n169     def prepare_value(self, value):\n170         return value\n171 \n172     def to_python(self, value):\n173         return value\n174 \n175     def validate(self, value):\n176         if value in self.empty_values and self.required:\n177             raise ValidationError(self.error_messages[\"required\"], code=\"required\")\n178 \n179     def run_validators(self, value):\n180         if value in self.empty_values:\n181             return\n182         errors = []\n183         for v in self.validators:\n184             try:\n185                 v(value)\n186             except ValidationError as e:\n187                 if hasattr(e, \"code\") and e.code in self.error_messages:\n188                     e.message = self.error_messages[e.code]\n189                 errors.extend(e.error_list)\n190         if errors:\n191             raise ValidationError(errors)\n192 \n193     def clean(self, value):\n194         \"\"\"\n195         Validate the given value and return its \"cleaned\" value as an\n196         appropriate Python object. Raise ValidationError for any errors.\n197         \"\"\"\n198         value = self.to_python(value)\n199         self.validate(value)\n200         self.run_validators(value)\n201         return value\n202 \n203     def bound_data(self, data, initial):\n204         \"\"\"\n205         Return the value that should be shown for this field on render of a\n206         bound form, given the submitted POST data for the field and the initial\n207         data, if any.\n208 \n209         For most fields, this will simply be data; FileFields need to handle it\n210         a bit differently.\n211         \"\"\"\n212         if self.disabled:\n213             return initial\n214         return data\n215 \n216     def widget_attrs(self, widget):\n217         \"\"\"\n218         Given a Widget instance (*not* a Widget class), return a dictionary of\n219         any HTML attributes that should be added to the Widget, based on this\n220         Field.\n221         \"\"\"\n222         return {}\n223 \n224     def has_changed(self, initial, data):\n225         \"\"\"Return True if data differs from initial.\"\"\"\n226         # Always return False if the field is disabled since self.bound_data\n227         # always uses the initial value in this case.\n228         if self.disabled:\n229             return False\n230         try:\n231             data = self.to_python(data)\n232             if hasattr(self, \"_coerce\"):\n233                 return self._coerce(data) != self._coerce(initial)\n234         except ValidationError:\n235             return True\n236         # For purposes of seeing whether something has changed, None is\n237         # the same as an empty string, if the data or initial value we get\n238         # is None, replace it with ''.\n239         initial_value = initial if initial is not None else \"\"\n240         data_value = data if data is not None else \"\"\n241         return initial_value != data_value\n242 \n243     def get_bound_field(self, form, field_name):\n244         \"\"\"\n245         Return a BoundField instance that will be used when accessing the form\n246         field in a template.\n247         \"\"\"\n248         return BoundField(form, self, field_name)\n249 \n250     def __deepcopy__(self, memo):\n251         result = copy.copy(self)\n252         memo[id(self)] = result\n253         result.widget = copy.deepcopy(self.widget, memo)\n254         result.error_messages = self.error_messages.copy()\n255         result.validators = self.validators[:]\n256         return result\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 113,
        "end": 1058,
        "class_name": "Field",
        "method_name": null,
        "code": "113 class Field(RegisterLookupMixin):\n114     \"\"\"Base class for all field types\"\"\"\n115 \n116     # Designates whether empty strings fundamentally are allowed at the\n117     # database level.\n118     empty_strings_allowed = True\n119     empty_values = list(validators.EMPTY_VALUES)\n120 \n121     # These track each time a Field instance is created. Used to retain order.\n122     # The auto_creation_counter is used for fields that Django implicitly\n123     # creates, creation_counter is used for all user-specified fields.\n124     creation_counter = 0\n125     auto_creation_counter = -1\n126     default_validators = []  # Default set of validators\n127     default_error_messages = {\n128         \"invalid_choice\": _(\"Value %(value)r is not a valid choice.\"),\n129         \"null\": _(\"This field cannot be null.\"),\n130         \"blank\": _(\"This field cannot be blank.\"),\n131         \"unique\": _(\"%(model_name)s with this %(field_label)s already exists.\"),\n132         \"unique_for_date\": _(\n133             # Translators: The 'lookup_type' is one of 'date', 'year' or\n134             # 'month'. Eg: \"Title must be unique for pub_date year\"\n135             \"%(field_label)s must be unique for \"\n136             \"%(date_field_label)s %(lookup_type)s.\"\n137         ),\n138     }\n139     system_check_deprecated_details = None\n140     system_check_removed_details = None\n141 \n142     # Attributes that don't affect a column definition.\n143     # These attributes are ignored when altering the field.\n144     non_db_attrs = (\n145         \"blank\",\n146         \"choices\",\n147         \"db_column\",\n148         \"editable\",\n149         \"error_messages\",\n150         \"help_text\",\n151         \"limit_choices_to\",\n152         # Database-level options are not supported, see #21961.\n153         \"on_delete\",\n154         \"related_name\",\n155         \"related_query_name\",\n156         \"validators\",\n157         \"verbose_name\",\n158     )\n159 \n160     # Field flags\n161     hidden = False\n162 \n163     many_to_many = None\n164     many_to_one = None\n165     one_to_many = None\n166     one_to_one = None\n167     related_model = None\n168 \n169     descriptor_class = DeferredAttribute\n170 \n171     # Generic field type description, usually overridden by subclasses\n172     def _description(self):\n173         return _(\"Field of type: %(field_type)s\") % {\n174             \"field_type\": self.__class__.__name__\n175         }\n176 \n177     description = property(_description)\n178 \n179     def __init__(\n180         self,\n181         verbose_name=None,\n182         name=None,\n183         primary_key=False,\n184         max_length=None,\n185         unique=False,\n186         blank=False,\n187         null=False,\n188         db_index=False,\n189         rel=None,\n190         default=NOT_PROVIDED,\n191         editable=True,\n192         serialize=True,\n193         unique_for_date=None,\n194         unique_for_month=None,\n195         unique_for_year=None,\n196         choices=None,\n197         help_text=\"\",\n198         db_column=None,\n199         db_tablespace=None,\n200         auto_created=False,\n201         validators=(),\n202         error_messages=None,\n203     ):\n204         self.name = name\n205         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n206         self._verbose_name = verbose_name  # Store original for deconstruction\n207         self.primary_key = primary_key\n208         self.max_length, self._unique = max_length, unique\n209         self.blank, self.null = blank, null\n210         self.remote_field = rel\n211         self.is_relation = self.remote_field is not None\n212         self.default = default\n213         self.editable = editable\n214         self.serialize = serialize\n215         self.unique_for_date = unique_for_date\n216         self.unique_for_month = unique_for_month\n217         self.unique_for_year = unique_for_year\n218         if isinstance(choices, collections.abc.Iterator):\n219             choices = list(choices)\n220         self.choices = choices\n221         self.help_text = help_text\n222         self.db_index = db_index\n223         self.db_column = db_column\n224         self._db_tablespace = db_tablespace\n225         self.auto_created = auto_created\n226 \n227         # Adjust the appropriate creation counter, and save our local copy.\n228         if auto_created:\n229             self.creation_counter = Field.auto_creation_counter\n230             Field.auto_creation_counter -= 1\n231         else:\n232             self.creation_counter = Field.creation_counter\n233             Field.creation_counter += 1\n234 \n235         self._validators = list(validators)  # Store for deconstruction later\n236 \n237         self._error_messages = error_messages  # Store for deconstruction later\n238 \n239     def __str__(self):\n240         \"\"\"\n241         Return \"app_label.model_label.field_name\" for fields attached to\n242         models.\n243         \"\"\"\n244         if not hasattr(self, \"model\"):\n245             return super().__str__()\n246         model = self.model\n247         return \"%s.%s\" % (model._meta.label, self.name)\n248 \n249     def __repr__(self):\n250         \"\"\"Display the module, class, and name of the field.\"\"\"\n251         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n252         name = getattr(self, \"name\", None)\n253         if name is not None:\n254             return \"<%s: %s>\" % (path, name)\n255         return \"<%s>\" % path\n256 \n257     def check(self, **kwargs):\n258         return [\n259             *self._check_field_name(),\n260             *self._check_choices(),\n261             *self._check_db_index(),\n262             *self._check_null_allowed_for_primary_keys(),\n263             *self._check_backend_specific_checks(**kwargs),\n264             *self._check_validators(),\n265             *self._check_deprecation_details(),\n266         ]\n267 \n268     def _check_field_name(self):\n269         \"\"\"\n270         Check if field name is valid, i.e. 1) does not end with an\n271         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n272         \"\"\"\n273         if self.name.endswith(\"_\"):\n274             return [\n275                 checks.Error(\n276                     \"Field names must not end with an underscore.\",\n277                     obj=self,\n278                     id=\"fields.E001\",\n279                 )\n280             ]\n281         elif LOOKUP_SEP in self.name:\n282             return [\n283                 checks.Error(\n284                     'Field names must not contain \"%s\".' % LOOKUP_SEP,\n285                     obj=self,\n286                     id=\"fields.E002\",\n287                 )\n288             ]\n289         elif self.name == \"pk\":\n290             return [\n291                 checks.Error(\n292                     \"'pk' is a reserved word that cannot be used as a field name.\",\n293                     obj=self,\n294                     id=\"fields.E003\",\n295                 )\n296             ]\n297         else:\n298             return []\n299 \n300     @classmethod\n301     def _choices_is_value(cls, value):\n302         return isinstance(value, (str, Promise)) or not is_iterable(value)\n303 \n304     def _check_choices(self):\n305         if not self.choices:\n306             return []\n307 \n308         if not is_iterable(self.choices) or isinstance(self.choices, str):\n309             return [\n310                 checks.Error(\n311                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n312                     obj=self,\n313                     id=\"fields.E004\",\n314                 )\n315             ]\n316 \n317         choice_max_length = 0\n318         # Expect [group_name, [value, display]]\n319         for choices_group in self.choices:\n320             try:\n321                 group_name, group_choices = choices_group\n322             except (TypeError, ValueError):\n323                 # Containing non-pairs\n324                 break\n325             try:\n326                 if not all(\n327                     self._choices_is_value(value) and self._choices_is_value(human_name)\n328                     for value, human_name in group_choices\n329                 ):\n330                     break\n331                 if self.max_length is not None and group_choices:\n332                     choice_max_length = max(\n333                         [\n334                             choice_max_length,\n335                             *(\n336                                 len(value)\n337                                 for value, _ in group_choices\n338                                 if isinstance(value, str)\n339                             ),\n340                         ]\n341                     )\n342             except (TypeError, ValueError):\n343                 # No groups, choices in the form [value, display]\n344                 value, human_name = group_name, group_choices\n345                 if not self._choices_is_value(value) or not self._choices_is_value(\n346                     human_name\n347                 ):\n348                     break\n349                 if self.max_length is not None and isinstance(value, str):\n350                     choice_max_length = max(choice_max_length, len(value))\n351 \n352             # Special case: choices=['ab']\n353             if isinstance(choices_group, str):\n354                 break\n355         else:\n356             if self.max_length is not None and choice_max_length > self.max_length:\n357                 return [\n358                     checks.Error(\n359                         \"'max_length' is too small to fit the longest value \"\n360                         \"in 'choices' (%d characters).\" % choice_max_length,\n361                         obj=self,\n362                         id=\"fields.E009\",\n363                     ),\n364                 ]\n365             return []\n366 \n367         return [\n368             checks.Error(\n369                 \"'choices' must be an iterable containing \"\n370                 \"(actual value, human readable name) tuples.\",\n371                 obj=self,\n372                 id=\"fields.E005\",\n373             )\n374         ]\n375 \n376     def _check_db_index(self):\n377         if self.db_index not in (None, True, False):\n378             return [\n379                 checks.Error(\n380                     \"'db_index' must be None, True or False.\",\n381                     obj=self,\n382                     id=\"fields.E006\",\n383                 )\n384             ]\n385         else:\n386             return []\n387 \n388     def _check_null_allowed_for_primary_keys(self):\n389         if (\n390             self.primary_key\n391             and self.null\n392             and not connection.features.interprets_empty_strings_as_nulls\n393         ):\n394             # We cannot reliably check this for backends like Oracle which\n395             # consider NULL and '' to be equal (and thus set up\n396             # character-based fields a little differently).\n397             return [\n398                 checks.Error(\n399                     \"Primary keys must not have null=True.\",\n400                     hint=(\n401                         \"Set null=False on the field, or \"\n402                         \"remove primary_key=True argument.\"\n403                     ),\n404                     obj=self,\n405                     id=\"fields.E007\",\n406                 )\n407             ]\n408         else:\n409             return []\n410 \n411     def _check_backend_specific_checks(self, databases=None, **kwargs):\n412         if databases is None:\n413             return []\n414         app_label = self.model._meta.app_label\n415         errors = []\n416         for alias in databases:\n417             if router.allow_migrate(\n418                 alias, app_label, model_name=self.model._meta.model_name\n419             ):\n420                 errors.extend(connections[alias].validation.check_field(self, **kwargs))\n421         return errors\n422 \n423     def _check_validators(self):\n424         errors = []\n425         for i, validator in enumerate(self.validators):\n426             if not callable(validator):\n427                 errors.append(\n428                     checks.Error(\n429                         \"All 'validators' must be callable.\",\n430                         hint=(\n431                             \"validators[{i}] ({repr}) isn't a function or \"\n432                             \"instance of a validator class.\".format(\n433                                 i=i,\n434                                 repr=repr(validator),\n435                             )\n436                         ),\n437                         obj=self,\n438                         id=\"fields.E008\",\n439                     )\n440                 )\n441         return errors\n442 \n443     def _check_deprecation_details(self):\n444         if self.system_check_removed_details is not None:\n445             return [\n446                 checks.Error(\n447                     self.system_check_removed_details.get(\n448                         \"msg\",\n449                         \"%s has been removed except for support in historical \"\n450                         \"migrations.\" % self.__class__.__name__,\n451                     ),\n452                     hint=self.system_check_removed_details.get(\"hint\"),\n453                     obj=self,\n454                     id=self.system_check_removed_details.get(\"id\", \"fields.EXXX\"),\n455                 )\n456             ]\n457         elif self.system_check_deprecated_details is not None:\n458             return [\n459                 checks.Warning(\n460                     self.system_check_deprecated_details.get(\n461                         \"msg\", \"%s has been deprecated.\" % self.__class__.__name__\n462                     ),\n463                     hint=self.system_check_deprecated_details.get(\"hint\"),\n464                     obj=self,\n465                     id=self.system_check_deprecated_details.get(\"id\", \"fields.WXXX\"),\n466                 )\n467             ]\n468         return []\n469 \n470     def get_col(self, alias, output_field=None):\n471         if alias == self.model._meta.db_table and (\n472             output_field is None or output_field == self\n473         ):\n474             return self.cached_col\n475         from django.db.models.expressions import Col\n476 \n477         return Col(alias, self, output_field)\n478 \n479     @cached_property\n480     def cached_col(self):\n481         from django.db.models.expressions import Col\n482 \n483         return Col(self.model._meta.db_table, self)\n484 \n485     def select_format(self, compiler, sql, params):\n486         \"\"\"\n487         Custom format for select clauses. For example, GIS columns need to be\n488         selected as AsText(table.col) on MySQL as the table.col data can't be\n489         used by Django.\n490         \"\"\"\n491         return sql, params\n492 \n493     def deconstruct(self):\n494         \"\"\"\n495         Return enough information to recreate the field as a 4-tuple:\n496 \n497          * The name of the field on the model, if contribute_to_class() has\n498            been run.\n499          * The import path of the field, including the class, e.g.\n500            django.db.models.IntegerField. This should be the most portable\n501            version, so less specific may be better.\n502          * A list of positional arguments.\n503          * A dict of keyword arguments.\n504 \n505         Note that the positional or keyword arguments must contain values of\n506         the following types (including inner values of collection types):\n507 \n508          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n509            dict\n510          * UUID\n511          * datetime.datetime (naive), datetime.date\n512          * top-level classes, top-level functions - will be referenced by their\n513            full import path\n514          * Storage instances - these have their own deconstruct() method\n515 \n516         This is because the values here must be serialized into a text format\n517         (possibly new Python code, possibly JSON) and these are the only types\n518         with encoding handlers defined.\n519 \n520         There's no need to return the exact way the field was instantiated this\n521         time, just ensure that the resulting field is the same - prefer keyword\n522         arguments over positional ones, and omit parameters with their default\n523         values.\n524         \"\"\"\n525         # Short-form way of fetching all the default parameters\n526         keywords = {}\n527         possibles = {\n528             \"verbose_name\": None,\n529             \"primary_key\": False,\n530             \"max_length\": None,\n531             \"unique\": False,\n532             \"blank\": False,\n533             \"null\": False,\n534             \"db_index\": False,\n535             \"default\": NOT_PROVIDED,\n536             \"editable\": True,\n537             \"serialize\": True,\n538             \"unique_for_date\": None,\n539             \"unique_for_month\": None,\n540             \"unique_for_year\": None,\n541             \"choices\": None,\n542             \"help_text\": \"\",\n543             \"db_column\": None,\n544             \"db_tablespace\": None,\n545             \"auto_created\": False,\n546             \"validators\": [],\n547             \"error_messages\": None,\n548         }\n549         attr_overrides = {\n550             \"unique\": \"_unique\",\n551             \"error_messages\": \"_error_messages\",\n552             \"validators\": \"_validators\",\n553             \"verbose_name\": \"_verbose_name\",\n554             \"db_tablespace\": \"_db_tablespace\",\n555         }\n556         equals_comparison = {\"choices\", \"validators\"}\n557         for name, default in possibles.items():\n558             value = getattr(self, attr_overrides.get(name, name))\n559             # Unroll anything iterable for choices into a concrete list\n560             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n561                 value = list(value)\n562             # Do correct kind of comparison\n563             if name in equals_comparison:\n564                 if value != default:\n565                     keywords[name] = value\n566             else:\n567                 if value is not default:\n568                     keywords[name] = value\n569         # Work out path - we shorten it for known Django core fields\n570         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n571         if path.startswith(\"django.db.models.fields.related\"):\n572             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n573         elif path.startswith(\"django.db.models.fields.files\"):\n574             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n575         elif path.startswith(\"django.db.models.fields.json\"):\n576             path = path.replace(\"django.db.models.fields.json\", \"django.db.models\")\n577         elif path.startswith(\"django.db.models.fields.proxy\"):\n578             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n579         elif path.startswith(\"django.db.models.fields\"):\n580             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n581         # Return basic info - other fields should override this.\n582         return (self.name, path, [], keywords)\n583 \n584     def clone(self):\n585         \"\"\"\n586         Uses deconstruct() to clone a new copy of this Field.\n587         Will not preserve any class attachments/attribute names.\n588         \"\"\"\n589         name, path, args, kwargs = self.deconstruct()\n590         return self.__class__(*args, **kwargs)\n591 \n592     def __eq__(self, other):\n593         # Needed for @total_ordering\n594         if isinstance(other, Field):\n595             return self.creation_counter == other.creation_counter and getattr(\n596                 self, \"model\", None\n597             ) == getattr(other, \"model\", None)\n598         return NotImplemented\n599 \n600     def __lt__(self, other):\n601         # This is needed because bisect does not take a comparison function.\n602         # Order by creation_counter first for backward compatibility.\n603         if isinstance(other, Field):\n604             if (\n605                 self.creation_counter != other.creation_counter\n606                 or not hasattr(self, \"model\")\n607                 and not hasattr(other, \"model\")\n608             ):\n609                 return self.creation_counter < other.creation_counter\n610             elif hasattr(self, \"model\") != hasattr(other, \"model\"):\n611                 return not hasattr(self, \"model\")  # Order no-model fields first\n612             else:\n613                 # creation_counter's are equal, compare only models.\n614                 return (self.model._meta.app_label, self.model._meta.model_name) < (\n615                     other.model._meta.app_label,\n616                     other.model._meta.model_name,\n617                 )\n618         return NotImplemented\n619 \n620     def __hash__(self):\n621         return hash(self.creation_counter)\n622 \n623     def __deepcopy__(self, memodict):\n624         # We don't have to deepcopy very much here, since most things are not\n625         # intended to be altered after initial creation.\n626         obj = copy.copy(self)\n627         if self.remote_field:\n628             obj.remote_field = copy.copy(self.remote_field)\n629             if hasattr(self.remote_field, \"field\") and self.remote_field.field is self:\n630                 obj.remote_field.field = obj\n631         memodict[id(self)] = obj\n632         return obj\n633 \n634     def __copy__(self):\n635         # We need to avoid hitting __reduce__, so define this\n636         # slightly weird copy construct.\n637         obj = Empty()\n638         obj.__class__ = self.__class__\n639         obj.__dict__ = self.__dict__.copy()\n640         return obj\n641 \n642     def __reduce__(self):\n643         \"\"\"\n644         Pickling should return the model._meta.fields instance of the field,\n645         not a new copy of that field. So, use the app registry to load the\n646         model and then the field back.\n647         \"\"\"\n648         if not hasattr(self, \"model\"):\n649             # Fields are sometimes used without attaching them to models (for\n650             # example in aggregation). In this case give back a plain field\n651             # instance. The code below will create a new empty instance of\n652             # class self.__class__, then update its dict with self.__dict__\n653             # values - so, this is very close to normal pickle.\n654             state = self.__dict__.copy()\n655             # The _get_default cached_property can't be pickled due to lambda\n656             # usage.\n657             state.pop(\"_get_default\", None)\n658             return _empty, (self.__class__,), state\n659         return _load_field, (\n660             self.model._meta.app_label,\n661             self.model._meta.object_name,\n662             self.name,\n663         )\n664 \n665     def get_pk_value_on_save(self, instance):\n666         \"\"\"\n667         Hook to generate new PK values on save. This method is called when\n668         saving instances with no primary key value set. If this method returns\n669         something else than None, then the returned value is used when saving\n670         the new instance.\n671         \"\"\"\n672         if self.default:\n673             return self.get_default()\n674         return None\n675 \n676     def to_python(self, value):\n677         \"\"\"\n678         Convert the input value into the expected Python data type, raising\n679         django.core.exceptions.ValidationError if the data can't be converted.\n680         Return the converted value. Subclasses should override this.\n681         \"\"\"\n682         return value\n683 \n684     @cached_property\n685     def error_messages(self):\n686         messages = {}\n687         for c in reversed(self.__class__.__mro__):\n688             messages.update(getattr(c, \"default_error_messages\", {}))\n689         messages.update(self._error_messages or {})\n690         return messages\n691 \n692     @cached_property\n693     def validators(self):\n694         \"\"\"\n695         Some validators can't be created at field initialization time.\n696         This method provides a way to delay their creation until required.\n697         \"\"\"\n698         return [*self.default_validators, *self._validators]\n699 \n700     def run_validators(self, value):\n701         if value in self.empty_values:\n702             return\n703 \n704         errors = []\n705         for v in self.validators:\n706             try:\n707                 v(value)\n708             except exceptions.ValidationError as e:\n709                 if hasattr(e, \"code\") and e.code in self.error_messages:\n710                     e.message = self.error_messages[e.code]\n711                 errors.extend(e.error_list)\n712 \n713         if errors:\n714             raise exceptions.ValidationError(errors)\n715 \n716     def validate(self, value, model_instance):\n717         \"\"\"\n718         Validate value and raise ValidationError if necessary. Subclasses\n719         should override this to provide validation logic.\n720         \"\"\"\n721         if not self.editable:\n722             # Skip validation for non-editable fields.\n723             return\n724 \n725         if self.choices is not None and value not in self.empty_values:\n726             for option_key, option_value in self.choices:\n727                 if isinstance(option_value, (list, tuple)):\n728                     # This is an optgroup, so look inside the group for\n729                     # options.\n730                     for optgroup_key, optgroup_value in option_value:\n731                         if value == optgroup_key:\n732                             return\n733                 elif value == option_key:\n734                     return\n735             raise exceptions.ValidationError(\n736                 self.error_messages[\"invalid_choice\"],\n737                 code=\"invalid_choice\",\n738                 params={\"value\": value},\n739             )\n740 \n741         if value is None and not self.null:\n742             raise exceptions.ValidationError(self.error_messages[\"null\"], code=\"null\")\n743 \n744         if not self.blank and value in self.empty_values:\n745             raise exceptions.ValidationError(self.error_messages[\"blank\"], code=\"blank\")\n746 \n747     def clean(self, value, model_instance):\n748         \"\"\"\n749         Convert the value's type and run validation. Validation errors\n750         from to_python() and validate() are propagated. Return the correct\n751         value if no error is raised.\n752         \"\"\"\n753         value = self.to_python(value)\n754         self.validate(value, model_instance)\n755         self.run_validators(value)\n756         return value\n757 \n758     def db_type_parameters(self, connection):\n759         return DictWrapper(self.__dict__, connection.ops.quote_name, \"qn_\")\n760 \n761     def db_check(self, connection):\n762         \"\"\"\n763         Return the database column check constraint for this field, for the\n764         provided connection. Works the same way as db_type() for the case that\n765         get_internal_type() does not map to a preexisting model field.\n766         \"\"\"\n767         data = self.db_type_parameters(connection)\n768         try:\n769             return (\n770                 connection.data_type_check_constraints[self.get_internal_type()] % data\n771             )\n772         except KeyError:\n773             return None\n774 \n775     def db_type(self, connection):\n776         \"\"\"\n777         Return the database column data type for this field, for the provided\n778         connection.\n779         \"\"\"\n780         # The default implementation of this method looks at the\n781         # backend-specific data_types dictionary, looking up the field by its\n782         # \"internal type\".\n783         #\n784         # A Field class can implement the get_internal_type() method to specify\n785         # which *preexisting* Django Field class it's most similar to -- i.e.,\n786         # a custom field might be represented by a TEXT column type, which is\n787         # the same as the TextField Django field type, which means the custom\n788         # field's get_internal_type() returns 'TextField'.\n789         #\n790         # But the limitation of the get_internal_type() / data_types approach\n791         # is that it cannot handle database column types that aren't already\n792         # mapped to one of the built-in Django field types. In this case, you\n793         # can implement db_type() instead of get_internal_type() to specify\n794         # exactly which wacky database column type you want to use.\n795         data = self.db_type_parameters(connection)\n796         try:\n797             return connection.data_types[self.get_internal_type()] % data\n798         except KeyError:\n799             return None\n800 \n801     def rel_db_type(self, connection):\n802         \"\"\"\n803         Return the data type that a related field pointing to this field should\n804         use. For example, this method is called by ForeignKey and OneToOneField\n805         to determine its data type.\n806         \"\"\"\n807         return self.db_type(connection)\n808 \n809     def cast_db_type(self, connection):\n810         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n811         db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n812         if db_type:\n813             return db_type % self.db_type_parameters(connection)\n814         return self.db_type(connection)\n815 \n816     def db_parameters(self, connection):\n817         \"\"\"\n818         Extension of db_type(), providing a range of different return values\n819         (type, checks). This will look at db_type(), allowing custom model\n820         fields to override it.\n821         \"\"\"\n822         type_string = self.db_type(connection)\n823         check_string = self.db_check(connection)\n824         return {\n825             \"type\": type_string,\n826             \"check\": check_string,\n827         }\n828 \n829     def db_type_suffix(self, connection):\n830         return connection.data_types_suffix.get(self.get_internal_type())\n831 \n832     def get_db_converters(self, connection):\n833         if hasattr(self, \"from_db_value\"):\n834             return [self.from_db_value]\n835         return []\n836 \n837     @property\n838     def unique(self):\n839         return self._unique or self.primary_key\n840 \n841     @property\n842     def db_tablespace(self):\n843         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n844 \n845     @property\n846     def db_returning(self):\n847         \"\"\"\n848         Private API intended only to be used by Django itself. Currently only\n849         the PostgreSQL backend supports returning multiple fields on a model.\n850         \"\"\"\n851         return False\n852 \n853     def set_attributes_from_name(self, name):\n854         self.name = self.name or name\n855         self.attname, self.column = self.get_attname_column()\n856         self.concrete = self.column is not None\n857         if self.verbose_name is None and self.name:\n858             self.verbose_name = self.name.replace(\"_\", \" \")\n859 \n860     def contribute_to_class(self, cls, name, private_only=False):\n861         \"\"\"\n862         Register the field with the model class it belongs to.\n863 \n864         If private_only is True, create a separate instance of this field\n865         for every subclass of cls, even if cls is not an abstract model.\n866         \"\"\"\n867         self.set_attributes_from_name(name)\n868         self.model = cls\n869         cls._meta.add_field(self, private=private_only)\n870         if self.column:\n871             setattr(cls, self.attname, self.descriptor_class(self))\n872         if self.choices is not None:\n873             # Don't override a get_FOO_display() method defined explicitly on\n874             # this class, but don't check methods derived from inheritance, to\n875             # allow overriding inherited choices. For more complex inheritance\n876             # structures users should override contribute_to_class().\n877             if \"get_%s_display\" % self.name not in cls.__dict__:\n878                 setattr(\n879                     cls,\n880                     \"get_%s_display\" % self.name,\n881                     partialmethod(cls._get_FIELD_display, field=self),\n882                 )\n883 \n884     def get_filter_kwargs_for_object(self, obj):\n885         \"\"\"\n886         Return a dict that when passed as kwargs to self.model.filter(), would\n887         yield all instances having the same value for this field as obj has.\n888         \"\"\"\n889         return {self.name: getattr(obj, self.attname)}\n890 \n891     def get_attname(self):\n892         return self.name\n893 \n894     def get_attname_column(self):\n895         attname = self.get_attname()\n896         column = self.db_column or attname\n897         return attname, column\n898 \n899     def get_internal_type(self):\n900         return self.__class__.__name__\n901 \n902     def pre_save(self, model_instance, add):\n903         \"\"\"Return field's value just before saving.\"\"\"\n904         return getattr(model_instance, self.attname)\n905 \n906     def get_prep_value(self, value):\n907         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n908         if isinstance(value, Promise):\n909             value = value._proxy____cast()\n910         return value\n911 \n912     def get_db_prep_value(self, value, connection, prepared=False):\n913         \"\"\"\n914         Return field's value prepared for interacting with the database backend.\n915 \n916         Used by the default implementations of get_db_prep_save().\n917         \"\"\"\n918         if not prepared:\n919             value = self.get_prep_value(value)\n920         return value\n921 \n922     def get_db_prep_save(self, value, connection):\n923         \"\"\"Return field's value prepared for saving into a database.\"\"\"\n924         return self.get_db_prep_value(value, connection=connection, prepared=False)\n925 \n926     def has_default(self):\n927         \"\"\"Return a boolean of whether this field has a default value.\"\"\"\n928         return self.default is not NOT_PROVIDED\n929 \n930     def get_default(self):\n931         \"\"\"Return the default value for this field.\"\"\"\n932         return self._get_default()\n933 \n934     @cached_property\n935     def _get_default(self):\n936         if self.has_default():\n937             if callable(self.default):\n938                 return self.default\n939             return lambda: self.default\n940 \n941         if (\n942             not self.empty_strings_allowed\n943             or self.null\n944             and not connection.features.interprets_empty_strings_as_nulls\n945         ):\n946             return return_None\n947         return str  # return empty string\n948 \n949     def get_choices(\n950         self,\n951         include_blank=True,\n952         blank_choice=BLANK_CHOICE_DASH,\n953         limit_choices_to=None,\n954         ordering=(),\n955     ):\n956         \"\"\"\n957         Return choices with a default blank choices included, for use\n958         as <select> choices for this field.\n959         \"\"\"\n960         if self.choices is not None:\n961             choices = list(self.choices)\n962             if include_blank:\n963                 blank_defined = any(\n964                     choice in (\"\", None) for choice, _ in self.flatchoices\n965                 )\n966                 if not blank_defined:\n967                     choices = blank_choice + choices\n968             return choices\n969         rel_model = self.remote_field.model\n970         limit_choices_to = limit_choices_to or self.get_limit_choices_to()\n971         choice_func = operator.attrgetter(\n972             self.remote_field.get_related_field().attname\n973             if hasattr(self.remote_field, \"get_related_field\")\n974             else \"pk\"\n975         )\n976         qs = rel_model._default_manager.complex_filter(limit_choices_to)\n977         if ordering:\n978             qs = qs.order_by(*ordering)\n979         return (blank_choice if include_blank else []) + [\n980             (choice_func(x), str(x)) for x in qs\n981         ]\n982 \n983     def value_to_string(self, obj):\n984         \"\"\"\n985         Return a string value of this field from the passed obj.\n986         This is used by the serialization framework.\n987         \"\"\"\n988         return str(self.value_from_object(obj))\n989 \n990     def _get_flatchoices(self):\n991         \"\"\"Flattened version of choices tuple.\"\"\"\n992         if self.choices is None:\n993             return []\n994         flat = []\n995         for choice, value in self.choices:\n996             if isinstance(value, (list, tuple)):\n997                 flat.extend(value)\n998             else:\n999                 flat.append((choice, value))\n1000         return flat\n1001 \n1002     flatchoices = property(_get_flatchoices)\n1003 \n1004     def save_form_data(self, instance, data):\n1005         setattr(instance, self.name, data)\n1006 \n1007     def formfield(self, form_class=None, choices_form_class=None, **kwargs):\n1008         \"\"\"Return a django.forms.Field instance for this field.\"\"\"\n1009         defaults = {\n1010             \"required\": not self.blank,\n1011             \"label\": capfirst(self.verbose_name),\n1012             \"help_text\": self.help_text,\n1013         }\n1014         if self.has_default():\n1015             if callable(self.default):\n1016                 defaults[\"initial\"] = self.default\n1017                 defaults[\"show_hidden_initial\"] = True\n1018             else:\n1019                 defaults[\"initial\"] = self.get_default()\n1020         if self.choices is not None:\n1021             # Fields with choices get special treatment.\n1022             include_blank = self.blank or not (\n1023                 self.has_default() or \"initial\" in kwargs\n1024             )\n1025             defaults[\"choices\"] = self.get_choices(include_blank=include_blank)\n1026             defaults[\"coerce\"] = self.to_python\n1027             if self.null:\n1028                 defaults[\"empty_value\"] = None\n1029             if choices_form_class is not None:\n1030                 form_class = choices_form_class\n1031             else:\n1032                 form_class = forms.TypedChoiceField\n1033             # Many of the subclass-specific formfield arguments (min_value,\n1034             # max_value) don't apply for choice fields, so be sure to only pass\n1035             # the values that TypedChoiceField will understand.\n1036             for k in list(kwargs):\n1037                 if k not in (\n1038                     \"coerce\",\n1039                     \"empty_value\",\n1040                     \"choices\",\n1041                     \"required\",\n1042                     \"widget\",\n1043                     \"label\",\n1044                     \"initial\",\n1045                     \"help_text\",\n1046                     \"error_messages\",\n1047                     \"show_hidden_initial\",\n1048                     \"disabled\",\n1049                 ):\n1050                     del kwargs[k]\n1051         defaults.update(kwargs)\n1052         if form_class is None:\n1053             form_class = forms.CharField\n1054         return form_class(**defaults)\n1055 \n1056     def value_from_object(self, obj):\n1057         \"\"\"Return the value of this field in the given model instance.\"\"\"\n1058         return getattr(obj, self.attname)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]