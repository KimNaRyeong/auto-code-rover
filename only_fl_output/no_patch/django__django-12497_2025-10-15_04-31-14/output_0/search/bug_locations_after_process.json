[
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/fields/related.py",
        "start": 1,
        "end": 1696,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25 )\n26 from .related_lookups import (\n27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29 )\n30 from .reverse_related import (\n31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32 )\n33 \n34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35 \n36 \n37 def resolve_relation(scope_model, relation):\n38     \"\"\"\n39     Transform relation into a model or fully-qualified model string of the form\n40     \"app_label.ModelName\", relative to scope_model.\n41 \n42     The relation argument can be:\n43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44         the model argument will be returned.\n45       * A bare model name without an app_label, in which case scope_model's\n46         app_label will be prepended.\n47       * An \"app_label.ModelName\" string.\n48       * A model class, which will be returned unchanged.\n49     \"\"\"\n50     # Check for recursive relations\n51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n52         relation = scope_model\n53 \n54     # Look for an \"app.Model\" relation\n55     if isinstance(relation, str):\n56         if \".\" not in relation:\n57             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n58 \n59     return relation\n60 \n61 \n62 def lazy_related_operation(function, model, *related_models, **kwargs):\n63     \"\"\"\n64     Schedule `function` to be called once `model` and all `related_models`\n65     have been imported and registered with the app registry. `function` will\n66     be called with the newly-loaded model classes as its positional arguments,\n67     plus any optional keyword arguments.\n68 \n69     The `model` argument must be a model class. Each subsequent positional\n70     argument is another model, or a reference to another model - see\n71     `resolve_relation()` for the various forms these may take. Any relative\n72     references will be resolved relative to `model`.\n73 \n74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n75     registry model used is the one found in `model._meta.apps`.\n76     \"\"\"\n77     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n78     model_keys = (make_model_tuple(m) for m in models)\n79     apps = model._meta.apps\n80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n81 \n82 \n83 class RelatedField(FieldCacheMixin, Field):\n84     \"\"\"Base class that all relational fields inherit from.\"\"\"\n85 \n86     # Field flags\n87     one_to_many = False\n88     one_to_one = False\n89     many_to_many = False\n90     many_to_one = False\n91 \n92     @cached_property\n93     def related_model(self):\n94         # Can't cache this property until all the models are loaded.\n95         apps.check_models_ready()\n96         return self.remote_field.model\n97 \n98     def check(self, **kwargs):\n99         return [\n100             *super().check(**kwargs),\n101             *self._check_related_name_is_valid(),\n102             *self._check_related_query_name_is_valid(),\n103             *self._check_relation_model_exists(),\n104             *self._check_referencing_to_swapped_model(),\n105             *self._check_clashes(),\n106         ]\n107 \n108     def _check_related_name_is_valid(self):\n109         import keyword\n110         related_name = self.remote_field.related_name\n111         if related_name is None:\n112             return []\n113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()\n114         if not (is_valid_id or related_name.endswith('+')):\n115             return [\n116                 checks.Error(\n117                     \"The name '%s' is invalid related_name for field %s.%s\" %\n118                     (self.remote_field.related_name, self.model._meta.object_name,\n119                      self.name),\n120                     hint=\"Related name must be a valid Python identifier or end with a '+'\",\n121                     obj=self,\n122                     id='fields.E306',\n123                 )\n124             ]\n125         return []\n126 \n127     def _check_related_query_name_is_valid(self):\n128         if self.remote_field.is_hidden():\n129             return []\n130         rel_query_name = self.related_query_name()\n131         errors = []\n132         if rel_query_name.endswith('_'):\n133             errors.append(\n134                 checks.Error(\n135                     \"Reverse query name '%s' must not end with an underscore.\"\n136                     % (rel_query_name,),\n137                     hint=(\"Add or change a related_name or related_query_name \"\n138                           \"argument for this field.\"),\n139                     obj=self,\n140                     id='fields.E308',\n141                 )\n142             )\n143         if LOOKUP_SEP in rel_query_name:\n144             errors.append(\n145                 checks.Error(\n146                     \"Reverse query name '%s' must not contain '%s'.\"\n147                     % (rel_query_name, LOOKUP_SEP),\n148                     hint=(\"Add or change a related_name or related_query_name \"\n149                           \"argument for this field.\"),\n150                     obj=self,\n151                     id='fields.E309',\n152                 )\n153             )\n154         return errors\n155 \n156     def _check_relation_model_exists(self):\n157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n158         rel_is_string = isinstance(self.remote_field.model, str)\n159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name\n160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):\n161             return [\n162                 checks.Error(\n163                     \"Field defines a relation with model '%s', which is either \"\n164                     \"not installed, or is abstract.\" % model_name,\n165                     obj=self,\n166                     id='fields.E300',\n167                 )\n168             ]\n169         return []\n170 \n171     def _check_referencing_to_swapped_model(self):\n172         if (self.remote_field.model not in self.opts.apps.get_models() and\n173                 not isinstance(self.remote_field.model, str) and\n174                 self.remote_field.model._meta.swapped):\n175             model = \"%s.%s\" % (\n176                 self.remote_field.model._meta.app_label,\n177                 self.remote_field.model._meta.object_name\n178             )\n179             return [\n180                 checks.Error(\n181                     \"Field defines a relation with the model '%s', which has \"\n182                     \"been swapped out.\" % model,\n183                     hint=\"Update the relation to point at 'settings.%s'.\" % self.remote_field.model._meta.swappable,\n184                     obj=self,\n185                     id='fields.E301',\n186                 )\n187             ]\n188         return []\n189 \n190     def _check_clashes(self):\n191         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n192         from django.db.models.base import ModelBase\n193 \n194         errors = []\n195         opts = self.model._meta\n196 \n197         # `f.remote_field.model` may be a string instead of a model. Skip if model name is\n198         # not resolved.\n199         if not isinstance(self.remote_field.model, ModelBase):\n200             return []\n201 \n202         # Consider that we are checking field `Model.foreign` and the models\n203         # are:\n204         #\n205         #     class Target(models.Model):\n206         #         model = models.IntegerField()\n207         #         model_set = models.IntegerField()\n208         #\n209         #     class Model(models.Model):\n210         #         foreign = models.ForeignKey(Target)\n211         #         m2m = models.ManyToManyField(Target)\n212 \n213         # rel_opts.object_name == \"Target\"\n214         rel_opts = self.remote_field.model._meta\n215         # If the field doesn't install a backward relation on the target model\n216         # (so `is_hidden` returns True), then there are no clashes to check\n217         # and we can skip these fields.\n218         rel_is_hidden = self.remote_field.is_hidden()\n219         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n220         rel_query_name = self.related_query_name()  # i. e. \"model\"\n221         field_name = \"%s.%s\" % (opts.object_name, self.name)  # i. e. \"Model.field\"\n222 \n223         # Check clashes between accessor or reverse query name of `field`\n224         # and any other field name -- i.e. accessor for Model.foreign is\n225         # model_set and it clashes with Target.model_set.\n226         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n227         for clash_field in potential_clashes:\n228             clash_name = \"%s.%s\" % (rel_opts.object_name, clash_field.name)  # i.e. \"Target.model_set\"\n229             if not rel_is_hidden and clash_field.name == rel_name:\n230                 errors.append(\n231                     checks.Error(\n232                         \"Reverse accessor for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n233                         hint=(\"Rename field '%s', or add/change a related_name \"\n234                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n235                         obj=self,\n236                         id='fields.E302',\n237                     )\n238                 )\n239 \n240             if clash_field.name == rel_query_name:\n241                 errors.append(\n242                     checks.Error(\n243                         \"Reverse query name for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n244                         hint=(\"Rename field '%s', or add/change a related_name \"\n245                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n246                         obj=self,\n247                         id='fields.E303',\n248                     )\n249                 )\n250 \n251         # Check clashes between accessors/reverse query names of `field` and\n252         # any other field accessor -- i. e. Model.foreign accessor clashes with\n253         # Model.m2m accessor.\n254         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n255         for clash_field in potential_clashes:\n256             clash_name = \"%s.%s\" % (  # i. e. \"Model.m2m\"\n257                 clash_field.related_model._meta.object_name,\n258                 clash_field.field.name)\n259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n260                 errors.append(\n261                     checks.Error(\n262                         \"Reverse accessor for '%s' clashes with reverse accessor for '%s'.\" % (field_name, clash_name),\n263                         hint=(\"Add or change a related_name argument \"\n264                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n265                         obj=self,\n266                         id='fields.E304',\n267                     )\n268                 )\n269 \n270             if clash_field.get_accessor_name() == rel_query_name:\n271                 errors.append(\n272                     checks.Error(\n273                         \"Reverse query name for '%s' clashes with reverse query name for '%s'.\"\n274                         % (field_name, clash_name),\n275                         hint=(\"Add or change a related_name argument \"\n276                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n277                         obj=self,\n278                         id='fields.E305',\n279                     )\n280                 )\n281 \n282         return errors\n283 \n284     def db_type(self, connection):\n285         # By default related field will not have a column as it relates to\n286         # columns from another table.\n287         return None\n288 \n289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n290 \n291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n292 \n293         self.opts = cls._meta\n294 \n295         if not cls._meta.abstract:\n296             if self.remote_field.related_name:\n297                 related_name = self.remote_field.related_name\n298             else:\n299                 related_name = self.opts.default_related_name\n300             if related_name:\n301                 related_name = related_name % {\n302                     'class': cls.__name__.lower(),\n303                     'model_name': cls._meta.model_name.lower(),\n304                     'app_label': cls._meta.app_label.lower()\n305                 }\n306                 self.remote_field.related_name = related_name\n307 \n308             if self.remote_field.related_query_name:\n309                 related_query_name = self.remote_field.related_query_name % {\n310                     'class': cls.__name__.lower(),\n311                     'app_label': cls._meta.app_label.lower(),\n312                 }\n313                 self.remote_field.related_query_name = related_query_name\n314 \n315             def resolve_related_class(model, related, field):\n316                 field.remote_field.model = related\n317                 field.do_related_class(related, model)\n318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)\n319 \n320     def deconstruct(self):\n321         name, path, args, kwargs = super().deconstruct()\n322         if self.remote_field.limit_choices_to:\n323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to\n324         if self.remote_field.related_name is not None:\n325             kwargs['related_name'] = self.remote_field.related_name\n326         if self.remote_field.related_query_name is not None:\n327             kwargs['related_query_name'] = self.remote_field.related_query_name\n328         return name, path, args, kwargs\n329 \n330     def get_forward_related_filter(self, obj):\n331         \"\"\"\n332         Return the keyword arguments that when supplied to\n333         self.model.object.filter(), would select all instances related through\n334         this field to the remote obj. This is used to build the querysets\n335         returned by related descriptors. obj is an instance of\n336         self.related_field.model.\n337         \"\"\"\n338         return {\n339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n340             for _, rh_field in self.related_fields\n341         }\n342 \n343     def get_reverse_related_filter(self, obj):\n344         \"\"\"\n345         Complement to get_forward_related_filter(). Return the keyword\n346         arguments that when passed to self.related_field.model.object.filter()\n347         select all instances of self.related_field.model related through\n348         this field to obj. obj is an instance of self.model.\n349         \"\"\"\n350         base_filter = {\n351             rh_field.attname: getattr(obj, lh_field.attname)\n352             for lh_field, rh_field in self.related_fields\n353         }\n354         descriptor_filter = self.get_extra_descriptor_filter(obj)\n355         base_q = Q(**base_filter)\n356         if isinstance(descriptor_filter, dict):\n357             return base_q & Q(**descriptor_filter)\n358         elif descriptor_filter:\n359             return base_q & descriptor_filter\n360         return base_q\n361 \n362     @property\n363     def swappable_setting(self):\n364         \"\"\"\n365         Get the setting that this is powered from for swapping, or None\n366         if it's not swapped in / marked with swappable=False.\n367         \"\"\"\n368         if self.swappable:\n369             # Work out string form of \"to\"\n370             if isinstance(self.remote_field.model, str):\n371                 to_string = self.remote_field.model\n372             else:\n373                 to_string = self.remote_field.model._meta.label\n374             return apps.get_swappable_settings_name(to_string)\n375         return None\n376 \n377     def set_attributes_from_rel(self):\n378         self.name = (\n379             self.name or\n380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)\n381         )\n382         if self.verbose_name is None:\n383             self.verbose_name = self.remote_field.model._meta.verbose_name\n384         self.remote_field.set_field_name()\n385 \n386     def do_related_class(self, other, cls):\n387         self.set_attributes_from_rel()\n388         self.contribute_to_related_class(other, self.remote_field)\n389 \n390     def get_limit_choices_to(self):\n391         \"\"\"\n392         Return ``limit_choices_to`` for this model field.\n393 \n394         If it is a callable, it will be invoked and the result will be\n395         returned.\n396         \"\"\"\n397         if callable(self.remote_field.limit_choices_to):\n398             return self.remote_field.limit_choices_to()\n399         return self.remote_field.limit_choices_to\n400 \n401     def formfield(self, **kwargs):\n402         \"\"\"\n403         Pass ``limit_choices_to`` to the field being constructed.\n404 \n405         Only passes it if there is a type that supports related fields.\n406         This is a similar strategy used to pass the ``queryset`` to the field\n407         being constructed.\n408         \"\"\"\n409         defaults = {}\n410         if hasattr(self.remote_field, 'get_related_field'):\n411             # If this is a callable, do not invoke it here. Just pass\n412             # it in the defaults for when the form class will later be\n413             # instantiated.\n414             limit_choices_to = self.remote_field.limit_choices_to\n415             defaults.update({\n416                 'limit_choices_to': limit_choices_to,\n417             })\n418         defaults.update(kwargs)\n419         return super().formfield(**defaults)\n420 \n421     def related_query_name(self):\n422         \"\"\"\n423         Define the name that can be used to identify this related object in a\n424         table-spanning query.\n425         \"\"\"\n426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name\n427 \n428     @property\n429     def target_field(self):\n430         \"\"\"\n431         When filtering against this relation, return the field on the remote\n432         model against which the filtering should happen.\n433         \"\"\"\n434         target_fields = self.get_path_info()[-1].target_fields\n435         if len(target_fields) > 1:\n436             raise exceptions.FieldError(\n437                 \"The relation has multiple target fields, but only single target field was asked for\")\n438         return target_fields[0]\n439 \n440     def get_cache_name(self):\n441         return self.name\n442 \n443 \n444 class ForeignObject(RelatedField):\n445     \"\"\"\n446     Abstraction of the ForeignKey relation to support multi-column relations.\n447     \"\"\"\n448 \n449     # Field flags\n450     many_to_many = False\n451     many_to_one = True\n452     one_to_many = False\n453     one_to_one = False\n454 \n455     requires_unique_target = True\n456     related_accessor_class = ReverseManyToOneDescriptor\n457     forward_related_accessor_class = ForwardManyToOneDescriptor\n458     rel_class = ForeignObjectRel\n459 \n460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,\n461                  related_query_name=None, limit_choices_to=None, parent_link=False,\n462                  swappable=True, **kwargs):\n463 \n464         if rel is None:\n465             rel = self.rel_class(\n466                 self, to,\n467                 related_name=related_name,\n468                 related_query_name=related_query_name,\n469                 limit_choices_to=limit_choices_to,\n470                 parent_link=parent_link,\n471                 on_delete=on_delete,\n472             )\n473 \n474         super().__init__(rel=rel, **kwargs)\n475 \n476         self.from_fields = from_fields\n477         self.to_fields = to_fields\n478         self.swappable = swappable\n479 \n480     def check(self, **kwargs):\n481         return [\n482             *super().check(**kwargs),\n483             *self._check_to_fields_exist(),\n484             *self._check_unique_target(),\n485         ]\n486 \n487     def _check_to_fields_exist(self):\n488         # Skip nonexistent models.\n489         if isinstance(self.remote_field.model, str):\n490             return []\n491 \n492         errors = []\n493         for to_field in self.to_fields:\n494             if to_field:\n495                 try:\n496                     self.remote_field.model._meta.get_field(to_field)\n497                 except exceptions.FieldDoesNotExist:\n498                     errors.append(\n499                         checks.Error(\n500                             \"The to_field '%s' doesn't exist on the related \"\n501                             \"model '%s'.\"\n502                             % (to_field, self.remote_field.model._meta.label),\n503                             obj=self,\n504                             id='fields.E312',\n505                         )\n506                     )\n507         return errors\n508 \n509     def _check_unique_target(self):\n510         rel_is_string = isinstance(self.remote_field.model, str)\n511         if rel_is_string or not self.requires_unique_target:\n512             return []\n513 \n514         try:\n515             self.foreign_related_fields\n516         except exceptions.FieldDoesNotExist:\n517             return []\n518 \n519         if not self.foreign_related_fields:\n520             return []\n521 \n522         unique_foreign_fields = {\n523             frozenset([f.name])\n524             for f in self.remote_field.model._meta.get_fields()\n525             if getattr(f, 'unique', False)\n526         }\n527         unique_foreign_fields.update({\n528             frozenset(ut)\n529             for ut in self.remote_field.model._meta.unique_together\n530         })\n531         unique_foreign_fields.update({\n532             frozenset(uc.fields)\n533             for uc in self.remote_field.model._meta.total_unique_constraints\n534         })\n535         foreign_fields = {f.name for f in self.foreign_related_fields}\n536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n537 \n538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n539             field_combination = ', '.join(\n540                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n541             )\n542             model_name = self.remote_field.model.__name__\n543             return [\n544                 checks.Error(\n545                     \"No subset of the fields %s on model '%s' is unique.\"\n546                     % (field_combination, model_name),\n547                     hint=(\n548                         'Mark a single field as unique=True or add a set of '\n549                         'fields to a unique constraint (via unique_together '\n550                         'or a UniqueConstraint (without condition) in the '\n551                         'model Meta.constraints).'\n552                     ),\n553                     obj=self,\n554                     id='fields.E310',\n555                 )\n556             ]\n557         elif not has_unique_constraint:\n558             field_name = self.foreign_related_fields[0].name\n559             model_name = self.remote_field.model.__name__\n560             return [\n561                 checks.Error(\n562                     \"'%s.%s' must be unique because it is referenced by \"\n563                     \"a foreign key.\" % (model_name, field_name),\n564                     hint=(\n565                         'Add unique=True to this field or add a '\n566                         'UniqueConstraint (without condition) in the model '\n567                         'Meta.constraints.'\n568                     ),\n569                     obj=self,\n570                     id='fields.E311',\n571                 )\n572             ]\n573         else:\n574             return []\n575 \n576     def deconstruct(self):\n577         name, path, args, kwargs = super().deconstruct()\n578         kwargs['on_delete'] = self.remote_field.on_delete\n579         kwargs['from_fields'] = self.from_fields\n580         kwargs['to_fields'] = self.to_fields\n581 \n582         if self.remote_field.parent_link:\n583             kwargs['parent_link'] = self.remote_field.parent_link\n584         # Work out string form of \"to\"\n585         if isinstance(self.remote_field.model, str):\n586             kwargs['to'] = self.remote_field.model\n587         else:\n588             kwargs['to'] = \"%s.%s\" % (\n589                 self.remote_field.model._meta.app_label,\n590                 self.remote_field.model._meta.object_name,\n591             )\n592         # If swappable is True, then see if we're actually pointing to the target\n593         # of a swap.\n594         swappable_setting = self.swappable_setting\n595         if swappable_setting is not None:\n596             # If it's already a settings reference, error\n597             if hasattr(kwargs['to'], \"setting_name\"):\n598                 if kwargs['to'].setting_name != swappable_setting:\n599                     raise ValueError(\n600                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n601                         \"that is swapped in place of more than one model (%s and %s)\"\n602                         % (kwargs['to'].setting_name, swappable_setting)\n603                     )\n604             # Set it\n605             kwargs['to'] = SettingsReference(\n606                 kwargs['to'],\n607                 swappable_setting,\n608             )\n609         return name, path, args, kwargs\n610 \n611     def resolve_related_fields(self):\n612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')\n614         if isinstance(self.remote_field.model, str):\n615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)\n616         related_fields = []\n617         for index in range(len(self.from_fields)):\n618             from_field_name = self.from_fields[index]\n619             to_field_name = self.to_fields[index]\n620             from_field = (\n621                 self\n622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n623                 else self.opts.get_field(from_field_name)\n624             )\n625             to_field = (self.remote_field.model._meta.pk if to_field_name is None\n626                         else self.remote_field.model._meta.get_field(to_field_name))\n627             related_fields.append((from_field, to_field))\n628         return related_fields\n629 \n630     @cached_property\n631     def related_fields(self):\n632         return self.resolve_related_fields()\n633 \n634     @cached_property\n635     def reverse_related_fields(self):\n636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n637 \n638     @cached_property\n639     def local_related_fields(self):\n640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n641 \n642     @cached_property\n643     def foreign_related_fields(self):\n644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n645 \n646     def get_local_related_value(self, instance):\n647         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n648 \n649     def get_foreign_related_value(self, instance):\n650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n651 \n652     @staticmethod\n653     def get_instance_value_for_fields(instance, fields):\n654         ret = []\n655         opts = instance._meta\n656         for field in fields:\n657             # Gotcha: in some cases (like fixture loading) a model can have\n658             # different values in parent_ptr_id and parent's id. So, use\n659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n660             if field.primary_key:\n661                 possible_parent_link = opts.get_ancestor_link(field.model)\n662                 if (not possible_parent_link or\n663                         possible_parent_link.primary_key or\n664                         possible_parent_link.model._meta.abstract):\n665                     ret.append(instance.pk)\n666                     continue\n667             ret.append(getattr(instance, field.attname))\n668         return tuple(ret)\n669 \n670     def get_attname_column(self):\n671         attname, column = super().get_attname_column()\n672         return attname, None\n673 \n674     def get_joining_columns(self, reverse_join=False):\n675         source = self.reverse_related_fields if reverse_join else self.related_fields\n676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)\n677 \n678     def get_reverse_joining_columns(self):\n679         return self.get_joining_columns(reverse_join=True)\n680 \n681     def get_extra_descriptor_filter(self, instance):\n682         \"\"\"\n683         Return an extra filter condition for related object fetching when\n684         user does 'instance.fieldname', that is the extra filter is used in\n685         the descriptor of the field.\n686 \n687         The filter should be either a dict usable in .filter(**kwargs) call or\n688         a Q-object. The condition will be ANDed together with the relation's\n689         joining columns.\n690 \n691         A parallel method is get_extra_restriction() which is used in\n692         JOIN and subquery conditions.\n693         \"\"\"\n694         return {}\n695 \n696     def get_extra_restriction(self, where_class, alias, related_alias):\n697         \"\"\"\n698         Return a pair condition used for joining and subquery pushdown. The\n699         condition is something that responds to as_sql(compiler, connection)\n700         method.\n701 \n702         Note that currently referring both the 'alias' and 'related_alias'\n703         will not work in some conditions, like subquery pushdown.\n704 \n705         A parallel method is get_extra_descriptor_filter() which is used in\n706         instance.fieldname related object fetching.\n707         \"\"\"\n708         return None\n709 \n710     def get_path_info(self, filtered_relation=None):\n711         \"\"\"Get path from this field to the related model.\"\"\"\n712         opts = self.remote_field.model._meta\n713         from_opts = self.model._meta\n714         return [PathInfo(\n715             from_opts=from_opts,\n716             to_opts=opts,\n717             target_fields=self.foreign_related_fields,\n718             join_field=self,\n719             m2m=False,\n720             direct=True,\n721             filtered_relation=filtered_relation,\n722         )]\n723 \n724     def get_reverse_path_info(self, filtered_relation=None):\n725         \"\"\"Get path from the related model to this field's model.\"\"\"\n726         opts = self.model._meta\n727         from_opts = self.remote_field.model._meta\n728         return [PathInfo(\n729             from_opts=from_opts,\n730             to_opts=opts,\n731             target_fields=(opts.pk,),\n732             join_field=self.remote_field,\n733             m2m=not self.unique,\n734             direct=False,\n735             filtered_relation=filtered_relation,\n736         )]\n737 \n738     @classmethod\n739     @functools.lru_cache(maxsize=None)\n740     def get_lookups(cls):\n741         bases = inspect.getmro(cls)\n742         bases = bases[:bases.index(ForeignObject) + 1]\n743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]\n744         return cls.merge_dicts(class_lookups)\n745 \n746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n748         setattr(cls, self.name, self.forward_related_accessor_class(self))\n749 \n750     def contribute_to_related_class(self, cls, related):\n751         # Internal FK's - i.e., those with a related name ending with '+' -\n752         # and swapped models don't get a related descriptor.\n753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))\n755             # While 'limit_choices_to' might be a callable, simply pass\n756             # it along for later - this is too early because it's still\n757             # model load time.\n758             if self.remote_field.limit_choices_to:\n759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)\n760 \n761 \n762 ForeignObject.register_lookup(RelatedIn)\n763 ForeignObject.register_lookup(RelatedExact)\n764 ForeignObject.register_lookup(RelatedLessThan)\n765 ForeignObject.register_lookup(RelatedGreaterThan)\n766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n767 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n768 ForeignObject.register_lookup(RelatedIsNull)\n769 \n770 \n771 class ForeignKey(ForeignObject):\n772     \"\"\"\n773     Provide a many-to-one relation by adding a column to the local model\n774     to hold the remote value.\n775 \n776     By default ForeignKey will target the pk of the remote model but this\n777     behavior can be changed by using the ``to_field`` argument.\n778     \"\"\"\n779     descriptor_class = ForeignKeyDeferredAttribute\n780     # Field flags\n781     many_to_many = False\n782     many_to_one = True\n783     one_to_many = False\n784     one_to_one = False\n785 \n786     rel_class = ManyToOneRel\n787 \n788     empty_strings_allowed = False\n789     default_error_messages = {\n790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n791     }\n792     description = _(\"Foreign Key (type determined by related field)\")\n793 \n794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,\n795                  limit_choices_to=None, parent_link=False, to_field=None,\n796                  db_constraint=True, **kwargs):\n797         try:\n798             to._meta.model_name\n799         except AttributeError:\n800             assert isinstance(to, str), (\n801                 \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n802                 \"either a model, a model name, or the string %r\" % (\n803                     self.__class__.__name__, to,\n804                     RECURSIVE_RELATIONSHIP_CONSTANT,\n805                 )\n806             )\n807         else:\n808             # For backwards compatibility purposes, we need to *try* and set\n809             # the to_field during FK construction. It won't be guaranteed to\n810             # be correct until contribute_to_class is called. Refs #12190.\n811             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n812         if not callable(on_delete):\n813             raise TypeError('on_delete must be callable.')\n814 \n815         kwargs['rel'] = self.rel_class(\n816             self, to, to_field,\n817             related_name=related_name,\n818             related_query_name=related_query_name,\n819             limit_choices_to=limit_choices_to,\n820             parent_link=parent_link,\n821             on_delete=on_delete,\n822         )\n823         kwargs.setdefault('db_index', True)\n824 \n825         super().__init__(\n826             to,\n827             on_delete,\n828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n829             to_fields=[to_field],\n830             **kwargs,\n831         )\n832         self.db_constraint = db_constraint\n833 \n834     def check(self, **kwargs):\n835         return [\n836             *super().check(**kwargs),\n837             *self._check_on_delete(),\n838             *self._check_unique(),\n839         ]\n840 \n841     def _check_on_delete(self):\n842         on_delete = getattr(self.remote_field, 'on_delete', None)\n843         if on_delete == SET_NULL and not self.null:\n844             return [\n845                 checks.Error(\n846                     'Field specifies on_delete=SET_NULL, but cannot be null.',\n847                     hint='Set null=True argument on the field, or change the on_delete rule.',\n848                     obj=self,\n849                     id='fields.E320',\n850                 )\n851             ]\n852         elif on_delete == SET_DEFAULT and not self.has_default():\n853             return [\n854                 checks.Error(\n855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',\n856                     hint='Set a default value, or change the on_delete rule.',\n857                     obj=self,\n858                     id='fields.E321',\n859                 )\n860             ]\n861         else:\n862             return []\n863 \n864     def _check_unique(self, **kwargs):\n865         return [\n866             checks.Warning(\n867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n869                 obj=self,\n870                 id='fields.W342',\n871             )\n872         ] if self.unique else []\n873 \n874     def deconstruct(self):\n875         name, path, args, kwargs = super().deconstruct()\n876         del kwargs['to_fields']\n877         del kwargs['from_fields']\n878         # Handle the simpler arguments\n879         if self.db_index:\n880             del kwargs['db_index']\n881         else:\n882             kwargs['db_index'] = False\n883         if self.db_constraint is not True:\n884             kwargs['db_constraint'] = self.db_constraint\n885         # Rel needs more work.\n886         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n887         if self.remote_field.field_name and (\n888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):\n889             kwargs['to_field'] = self.remote_field.field_name\n890         return name, path, args, kwargs\n891 \n892     def to_python(self, value):\n893         return self.target_field.to_python(value)\n894 \n895     @property\n896     def target_field(self):\n897         return self.foreign_related_fields[0]\n898 \n899     def get_reverse_path_info(self, filtered_relation=None):\n900         \"\"\"Get path from the related model to this field's model.\"\"\"\n901         opts = self.model._meta\n902         from_opts = self.remote_field.model._meta\n903         return [PathInfo(\n904             from_opts=from_opts,\n905             to_opts=opts,\n906             target_fields=(opts.pk,),\n907             join_field=self.remote_field,\n908             m2m=not self.unique,\n909             direct=False,\n910             filtered_relation=filtered_relation,\n911         )]\n912 \n913     def validate(self, value, model_instance):\n914         if self.remote_field.parent_link:\n915             return\n916         super().validate(value, model_instance)\n917         if value is None:\n918             return\n919 \n920         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n921         qs = self.remote_field.model._default_manager.using(using).filter(\n922             **{self.remote_field.field_name: value}\n923         )\n924         qs = qs.complex_filter(self.get_limit_choices_to())\n925         if not qs.exists():\n926             raise exceptions.ValidationError(\n927                 self.error_messages['invalid'],\n928                 code='invalid',\n929                 params={\n930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,\n931                     'field': self.remote_field.field_name, 'value': value,\n932                 },  # 'pk' is included for backwards compatibility\n933             )\n934 \n935     def resolve_related_fields(self):\n936         related_fields = super().resolve_related_fields()\n937         for from_field, to_field in related_fields:\n938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:\n939                 raise exceptions.FieldError(\n940                     \"'%s.%s' refers to field '%s' which is not local to model \"\n941                     \"'%s'.\" % (\n942                         self.model._meta.label,\n943                         self.name,\n944                         to_field.name,\n945                         self.remote_field.model._meta.concrete_model._meta.label,\n946                     )\n947                 )\n948         return related_fields\n949 \n950     def get_attname(self):\n951         return '%s_id' % self.name\n952 \n953     def get_attname_column(self):\n954         attname = self.get_attname()\n955         column = self.db_column or attname\n956         return attname, column\n957 \n958     def get_default(self):\n959         \"\"\"Return the to_field if the default value is an object.\"\"\"\n960         field_default = super().get_default()\n961         if isinstance(field_default, self.remote_field.model):\n962             return getattr(field_default, self.target_field.attname)\n963         return field_default\n964 \n965     def get_db_prep_save(self, value, connection):\n966         if value is None or (value == '' and\n967                              (not self.target_field.empty_strings_allowed or\n968                               connection.features.interprets_empty_strings_as_nulls)):\n969             return None\n970         else:\n971             return self.target_field.get_db_prep_save(value, connection=connection)\n972 \n973     def get_db_prep_value(self, value, connection, prepared=False):\n974         return self.target_field.get_db_prep_value(value, connection, prepared)\n975 \n976     def get_prep_value(self, value):\n977         return self.target_field.get_prep_value(value)\n978 \n979     def contribute_to_related_class(self, cls, related):\n980         super().contribute_to_related_class(cls, related)\n981         if self.remote_field.field_name is None:\n982             self.remote_field.field_name = cls._meta.pk.name\n983 \n984     def formfield(self, *, using=None, **kwargs):\n985         if isinstance(self.remote_field.model, str):\n986             raise ValueError(\"Cannot create form field for %r yet, because \"\n987                              \"its related model %r has not been loaded yet\" %\n988                              (self.name, self.remote_field.model))\n989         return super().formfield(**{\n990             'form_class': forms.ModelChoiceField,\n991             'queryset': self.remote_field.model._default_manager.using(using),\n992             'to_field_name': self.remote_field.field_name,\n993             **kwargs,\n994             'blank': self.blank,\n995         })\n996 \n997     def db_check(self, connection):\n998         return []\n999 \n1000     def db_type(self, connection):\n1001         return self.target_field.rel_db_type(connection=connection)\n1002 \n1003     def db_parameters(self, connection):\n1004         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1005 \n1006     def convert_empty_strings(self, value, expression, connection):\n1007         if (not value) and isinstance(value, str):\n1008             return None\n1009         return value\n1010 \n1011     def get_db_converters(self, connection):\n1012         converters = super().get_db_converters(connection)\n1013         if connection.features.interprets_empty_strings_as_nulls:\n1014             converters += [self.convert_empty_strings]\n1015         return converters\n1016 \n1017     def get_col(self, alias, output_field=None):\n1018         if output_field is None:\n1019             output_field = self.target_field\n1020             while isinstance(output_field, ForeignKey):\n1021                 output_field = output_field.target_field\n1022                 if output_field is self:\n1023                     raise ValueError('Cannot resolve output_field.')\n1024         return super().get_col(alias, output_field)\n1025 \n1026 \n1027 class OneToOneField(ForeignKey):\n1028     \"\"\"\n1029     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1030     that it always carries a \"unique\" constraint with it and the reverse\n1031     relation always returns the object pointed to (since there will only ever\n1032     be one), rather than returning a list.\n1033     \"\"\"\n1034 \n1035     # Field flags\n1036     many_to_many = False\n1037     many_to_one = False\n1038     one_to_many = False\n1039     one_to_one = True\n1040 \n1041     related_accessor_class = ReverseOneToOneDescriptor\n1042     forward_related_accessor_class = ForwardOneToOneDescriptor\n1043     rel_class = OneToOneRel\n1044 \n1045     description = _(\"One-to-one relationship\")\n1046 \n1047     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1048         kwargs['unique'] = True\n1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1050 \n1051     def deconstruct(self):\n1052         name, path, args, kwargs = super().deconstruct()\n1053         if \"unique\" in kwargs:\n1054             del kwargs['unique']\n1055         return name, path, args, kwargs\n1056 \n1057     def formfield(self, **kwargs):\n1058         if self.remote_field.parent_link:\n1059             return None\n1060         return super().formfield(**kwargs)\n1061 \n1062     def save_form_data(self, instance, data):\n1063         if isinstance(data, self.remote_field.model):\n1064             setattr(instance, self.name, data)\n1065         else:\n1066             setattr(instance, self.attname, data)\n1067             # Remote field object must be cleared otherwise Model.save()\n1068             # will reassign attname using the related object pk.\n1069             if data is None:\n1070                 setattr(instance, self.name, data)\n1071 \n1072     def _check_unique(self, **kwargs):\n1073         # Override ForeignKey since check isn't applicable here.\n1074         return []\n1075 \n1076 \n1077 def create_many_to_many_intermediary_model(field, klass):\n1078     from django.db import models\n1079 \n1080     def set_managed(model, related, through):\n1081         through._meta.managed = model._meta.managed or related._meta.managed\n1082 \n1083     to_model = resolve_relation(klass, field.remote_field.model)\n1084     name = '%s_%s' % (klass._meta.object_name, field.name)\n1085     lazy_related_operation(set_managed, klass, to_model, name)\n1086 \n1087     to = make_model_tuple(to_model)[1]\n1088     from_ = klass._meta.model_name\n1089     if to == from_:\n1090         to = 'to_%s' % to\n1091         from_ = 'from_%s' % from_\n1092 \n1093     meta = type('Meta', (), {\n1094         'db_table': field._get_m2m_db_table(klass._meta),\n1095         'auto_created': klass,\n1096         'app_label': klass._meta.app_label,\n1097         'db_tablespace': klass._meta.db_tablespace,\n1098         'unique_together': (from_, to),\n1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},\n1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},\n1101         'apps': field.model._meta.apps,\n1102     })\n1103     # Construct and return the new class.\n1104     return type(name, (models.Model,), {\n1105         'Meta': meta,\n1106         '__module__': klass.__module__,\n1107         from_: models.ForeignKey(\n1108             klass,\n1109             related_name='%s+' % name,\n1110             db_tablespace=field.db_tablespace,\n1111             db_constraint=field.remote_field.db_constraint,\n1112             on_delete=CASCADE,\n1113         ),\n1114         to: models.ForeignKey(\n1115             to_model,\n1116             related_name='%s+' % name,\n1117             db_tablespace=field.db_tablespace,\n1118             db_constraint=field.remote_field.db_constraint,\n1119             on_delete=CASCADE,\n1120         )\n1121     })\n1122 \n1123 \n1124 class ManyToManyField(RelatedField):\n1125     \"\"\"\n1126     Provide a many-to-many relation by using an intermediary model that\n1127     holds two ForeignKey fields pointed at the two sides of the relation.\n1128 \n1129     Unless a ``through`` model was provided, ManyToManyField will use the\n1130     create_many_to_many_intermediary_model factory to automatically generate\n1131     the intermediary model.\n1132     \"\"\"\n1133 \n1134     # Field flags\n1135     many_to_many = True\n1136     many_to_one = False\n1137     one_to_many = False\n1138     one_to_one = False\n1139 \n1140     rel_class = ManyToManyRel\n1141 \n1142     description = _(\"Many-to-many relationship\")\n1143 \n1144     def __init__(self, to, related_name=None, related_query_name=None,\n1145                  limit_choices_to=None, symmetrical=None, through=None,\n1146                  through_fields=None, db_constraint=True, db_table=None,\n1147                  swappable=True, **kwargs):\n1148         try:\n1149             to._meta\n1150         except AttributeError:\n1151             assert isinstance(to, str), (\n1152                 \"%s(%r) is invalid. First parameter to ManyToManyField must be \"\n1153                 \"either a model, a model name, or the string %r\" %\n1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)\n1155             )\n1156 \n1157         if symmetrical is None:\n1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n1159 \n1160         if through is not None:\n1161             assert db_table is None, (\n1162                 \"Cannot specify a db_table if an intermediary model is used.\"\n1163             )\n1164 \n1165         kwargs['rel'] = self.rel_class(\n1166             self, to,\n1167             related_name=related_name,\n1168             related_query_name=related_query_name,\n1169             limit_choices_to=limit_choices_to,\n1170             symmetrical=symmetrical,\n1171             through=through,\n1172             through_fields=through_fields,\n1173             db_constraint=db_constraint,\n1174         )\n1175         self.has_null_arg = 'null' in kwargs\n1176 \n1177         super().__init__(**kwargs)\n1178 \n1179         self.db_table = db_table\n1180         self.swappable = swappable\n1181 \n1182     def check(self, **kwargs):\n1183         return [\n1184             *super().check(**kwargs),\n1185             *self._check_unique(**kwargs),\n1186             *self._check_relationship_model(**kwargs),\n1187             *self._check_ignored_options(**kwargs),\n1188             *self._check_table_uniqueness(**kwargs),\n1189         ]\n1190 \n1191     def _check_unique(self, **kwargs):\n1192         if self.unique:\n1193             return [\n1194                 checks.Error(\n1195                     'ManyToManyFields cannot be unique.',\n1196                     obj=self,\n1197                     id='fields.E330',\n1198                 )\n1199             ]\n1200         return []\n1201 \n1202     def _check_ignored_options(self, **kwargs):\n1203         warnings = []\n1204 \n1205         if self.has_null_arg:\n1206             warnings.append(\n1207                 checks.Warning(\n1208                     'null has no effect on ManyToManyField.',\n1209                     obj=self,\n1210                     id='fields.W340',\n1211                 )\n1212             )\n1213 \n1214         if self._validators:\n1215             warnings.append(\n1216                 checks.Warning(\n1217                     'ManyToManyField does not support validators.',\n1218                     obj=self,\n1219                     id='fields.W341',\n1220                 )\n1221             )\n1222         if (self.remote_field.limit_choices_to and self.remote_field.through and\n1223                 not self.remote_field.through._meta.auto_created):\n1224             warnings.append(\n1225                 checks.Warning(\n1226                     'limit_choices_to has no effect on ManyToManyField '\n1227                     'with a through model.',\n1228                     obj=self,\n1229                     id='fields.W343',\n1230                 )\n1231             )\n1232 \n1233         return warnings\n1234 \n1235     def _check_relationship_model(self, from_model=None, **kwargs):\n1236         if hasattr(self.remote_field.through, '_meta'):\n1237             qualified_model_name = \"%s.%s\" % (\n1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n1239         else:\n1240             qualified_model_name = self.remote_field.through\n1241 \n1242         errors = []\n1243 \n1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n1245             # The relationship model is not installed.\n1246             errors.append(\n1247                 checks.Error(\n1248                     \"Field specifies a many-to-many relation through model \"\n1249                     \"'%s', which has not been installed.\" % qualified_model_name,\n1250                     obj=self,\n1251                     id='fields.E331',\n1252                 )\n1253             )\n1254 \n1255         else:\n1256             assert from_model is not None, (\n1257                 \"ManyToManyField with intermediate \"\n1258                 \"tables cannot be checked if you don't pass the model \"\n1259                 \"where the field is attached to.\"\n1260             )\n1261             # Set some useful local variables\n1262             to_model = resolve_relation(from_model, self.remote_field.model)\n1263             from_model_name = from_model._meta.object_name\n1264             if isinstance(to_model, str):\n1265                 to_model_name = to_model\n1266             else:\n1267                 to_model_name = to_model._meta.object_name\n1268             relationship_model_name = self.remote_field.through._meta.object_name\n1269             self_referential = from_model == to_model\n1270             # Count foreign keys in intermediate model\n1271             if self_referential:\n1272                 seen_self = sum(\n1273                     from_model == getattr(field.remote_field, 'model', None)\n1274                     for field in self.remote_field.through._meta.fields\n1275                 )\n1276 \n1277                 if seen_self > 2 and not self.remote_field.through_fields:\n1278                     errors.append(\n1279                         checks.Error(\n1280                             \"The model is used as an intermediate model by \"\n1281                             \"'%s', but it has more than two foreign keys \"\n1282                             \"to '%s', which is ambiguous. You must specify \"\n1283                             \"which two foreign keys Django should use via the \"\n1284                             \"through_fields keyword argument.\" % (self, from_model_name),\n1285                             hint=\"Use through_fields to specify which two foreign keys Django should use.\",\n1286                             obj=self.remote_field.through,\n1287                             id='fields.E333',\n1288                         )\n1289                     )\n1290 \n1291             else:\n1292                 # Count foreign keys in relationship model\n1293                 seen_from = sum(\n1294                     from_model == getattr(field.remote_field, 'model', None)\n1295                     for field in self.remote_field.through._meta.fields\n1296                 )\n1297                 seen_to = sum(\n1298                     to_model == getattr(field.remote_field, 'model', None)\n1299                     for field in self.remote_field.through._meta.fields\n1300                 )\n1301 \n1302                 if seen_from > 1 and not self.remote_field.through_fields:\n1303                     errors.append(\n1304                         checks.Error(\n1305                             (\"The model is used as an intermediate model by \"\n1306                              \"'%s', but it has more than one foreign key \"\n1307                              \"from '%s', which is ambiguous. You must specify \"\n1308                              \"which foreign key Django should use via the \"\n1309                              \"through_fields keyword argument.\") % (self, from_model_name),\n1310                             hint=(\n1311                                 'If you want to create a recursive relationship, '\n1312                                 'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n1313                             ) % (\n1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1315                                 relationship_model_name,\n1316                             ),\n1317                             obj=self,\n1318                             id='fields.E334',\n1319                         )\n1320                     )\n1321 \n1322                 if seen_to > 1 and not self.remote_field.through_fields:\n1323                     errors.append(\n1324                         checks.Error(\n1325                             \"The model is used as an intermediate model by \"\n1326                             \"'%s', but it has more than one foreign key \"\n1327                             \"to '%s', which is ambiguous. You must specify \"\n1328                             \"which foreign key Django should use via the \"\n1329                             \"through_fields keyword argument.\" % (self, to_model_name),\n1330                             hint=(\n1331                                 'If you want to create a recursive relationship, '\n1332                                 'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'\n1333                             ) % (\n1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1335                                 relationship_model_name,\n1336                             ),\n1337                             obj=self,\n1338                             id='fields.E335',\n1339                         )\n1340                     )\n1341 \n1342                 if seen_from == 0 or seen_to == 0:\n1343                     errors.append(\n1344                         checks.Error(\n1345                             \"The model is used as an intermediate model by \"\n1346                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\" % (\n1347                                 self, from_model_name, to_model_name\n1348                             ),\n1349                             obj=self.remote_field.through,\n1350                             id='fields.E336',\n1351                         )\n1352                     )\n1353 \n1354         # Validate `through_fields`.\n1355         if self.remote_field.through_fields is not None:\n1356             # Validate that we're given an iterable of at least two items\n1357             # and that none of them is \"falsy\".\n1358             if not (len(self.remote_field.through_fields) >= 2 and\n1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):\n1360                 errors.append(\n1361                     checks.Error(\n1362                         \"Field specifies 'through_fields' but does not provide \"\n1363                         \"the names of the two link fields that should be used \"\n1364                         \"for the relation through model '%s'.\" % qualified_model_name,\n1365                         hint=\"Make sure you specify 'through_fields' as through_fields=('field1', 'field2')\",\n1366                         obj=self,\n1367                         id='fields.E337',\n1368                     )\n1369                 )\n1370 \n1371             # Validate the given through fields -- they should be actual\n1372             # fields on the through model, and also be foreign keys to the\n1373             # expected models.\n1374             else:\n1375                 assert from_model is not None, (\n1376                     \"ManyToManyField with intermediate \"\n1377                     \"tables cannot be checked if you don't pass the model \"\n1378                     \"where the field is attached to.\"\n1379                 )\n1380 \n1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model\n1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]\n1383 \n1384                 for field_name, related_model in ((source_field_name, source),\n1385                                                   (target_field_name, target)):\n1386 \n1387                     possible_field_names = []\n1388                     for f in through._meta.fields:\n1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:\n1390                             possible_field_names.append(f.name)\n1391                     if possible_field_names:\n1392                         hint = \"Did you mean one of the following foreign keys to '%s': %s?\" % (\n1393                             related_model._meta.object_name,\n1394                             ', '.join(possible_field_names),\n1395                         )\n1396                     else:\n1397                         hint = None\n1398 \n1399                     try:\n1400                         field = through._meta.get_field(field_name)\n1401                     except exceptions.FieldDoesNotExist:\n1402                         errors.append(\n1403                             checks.Error(\n1404                                 \"The intermediary model '%s' has no field '%s'.\"\n1405                                 % (qualified_model_name, field_name),\n1406                                 hint=hint,\n1407                                 obj=self,\n1408                                 id='fields.E338',\n1409                             )\n1410                         )\n1411                     else:\n1412                         if not (hasattr(field, 'remote_field') and\n1413                                 getattr(field.remote_field, 'model', None) == related_model):\n1414                             errors.append(\n1415                                 checks.Error(\n1416                                     \"'%s.%s' is not a foreign key to '%s'.\" % (\n1417                                         through._meta.object_name, field_name,\n1418                                         related_model._meta.object_name,\n1419                                     ),\n1420                                     hint=hint,\n1421                                     obj=self,\n1422                                     id='fields.E339',\n1423                                 )\n1424                             )\n1425 \n1426         return errors\n1427 \n1428     def _check_table_uniqueness(self, **kwargs):\n1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:\n1430             return []\n1431         registered_tables = {\n1432             model._meta.db_table: model\n1433             for model in self.opts.apps.get_models(include_auto_created=True)\n1434             if model != self.remote_field.through and model._meta.managed\n1435         }\n1436         m2m_db_table = self.m2m_db_table()\n1437         model = registered_tables.get(m2m_db_table)\n1438         # The second condition allows multiple m2m relations on a model if\n1439         # some point to a through model that proxies another through model.\n1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:\n1441             if model._meta.auto_created:\n1442                 def _get_field_name(model):\n1443                     for field in model._meta.auto_created._meta.many_to_many:\n1444                         if field.remote_field.through is model:\n1445                             return field.name\n1446                 opts = model._meta.auto_created._meta\n1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))\n1448             else:\n1449                 clashing_obj = model._meta.label\n1450             if settings.DATABASE_ROUTERS:\n1451                 error_class, error_id = checks.Warning, 'fields.W344'\n1452                 error_hint = (\n1453                     'You have configured settings.DATABASE_ROUTERS. Verify '\n1454                     'that the table of %r is correctly routed to a separate '\n1455                     'database.' % clashing_obj\n1456                 )\n1457             else:\n1458                 error_class, error_id = checks.Error, 'fields.E340'\n1459                 error_hint = None\n1460             return [\n1461                 error_class(\n1462                     \"The field's intermediary table '%s' clashes with the \"\n1463                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1464                     obj=self,\n1465                     hint=error_hint,\n1466                     id=error_id,\n1467                 )\n1468             ]\n1469         return []\n1470 \n1471     def deconstruct(self):\n1472         name, path, args, kwargs = super().deconstruct()\n1473         # Handle the simpler arguments.\n1474         if self.db_table is not None:\n1475             kwargs['db_table'] = self.db_table\n1476         if self.remote_field.db_constraint is not True:\n1477             kwargs['db_constraint'] = self.remote_field.db_constraint\n1478         # Rel needs more work.\n1479         if isinstance(self.remote_field.model, str):\n1480             kwargs['to'] = self.remote_field.model\n1481         else:\n1482             kwargs['to'] = \"%s.%s\" % (\n1483                 self.remote_field.model._meta.app_label,\n1484                 self.remote_field.model._meta.object_name,\n1485             )\n1486         if getattr(self.remote_field, 'through', None) is not None:\n1487             if isinstance(self.remote_field.through, str):\n1488                 kwargs['through'] = self.remote_field.through\n1489             elif not self.remote_field.through._meta.auto_created:\n1490                 kwargs['through'] = \"%s.%s\" % (\n1491                     self.remote_field.through._meta.app_label,\n1492                     self.remote_field.through._meta.object_name,\n1493                 )\n1494         # If swappable is True, then see if we're actually pointing to the target\n1495         # of a swap.\n1496         swappable_setting = self.swappable_setting\n1497         if swappable_setting is not None:\n1498             # If it's already a settings reference, error.\n1499             if hasattr(kwargs['to'], \"setting_name\"):\n1500                 if kwargs['to'].setting_name != swappable_setting:\n1501                     raise ValueError(\n1502                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1503                         \"model that is swapped in place of more than one model \"\n1504                         \"(%s and %s)\" % (kwargs['to'].setting_name, swappable_setting)\n1505                     )\n1506 \n1507             kwargs['to'] = SettingsReference(\n1508                 kwargs['to'],\n1509                 swappable_setting,\n1510             )\n1511         return name, path, args, kwargs\n1512 \n1513     def _get_path_info(self, direct=False, filtered_relation=None):\n1514         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1515         int_model = self.remote_field.through\n1516         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1517         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1518         if direct:\n1519             join1infos = linkfield1.get_reverse_path_info()\n1520             join2infos = linkfield2.get_path_info(filtered_relation)\n1521         else:\n1522             join1infos = linkfield2.get_reverse_path_info()\n1523             join2infos = linkfield1.get_path_info(filtered_relation)\n1524 \n1525         # Get join infos between the last model of join 1 and the first model\n1526         # of join 2. Assume the only reason these may differ is due to model\n1527         # inheritance.\n1528         join1_final = join1infos[-1].to_opts\n1529         join2_initial = join2infos[0].from_opts\n1530         if join1_final is join2_initial:\n1531             intermediate_infos = []\n1532         elif issubclass(join1_final.model, join2_initial.model):\n1533             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1534         else:\n1535             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1536 \n1537         return [*join1infos, *intermediate_infos, *join2infos]\n1538 \n1539     def get_path_info(self, filtered_relation=None):\n1540         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1541 \n1542     def get_reverse_path_info(self, filtered_relation=None):\n1543         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1544 \n1545     def _get_m2m_db_table(self, opts):\n1546         \"\"\"\n1547         Function that can be curried to provide the m2m table name for this\n1548         relation.\n1549         \"\"\"\n1550         if self.remote_field.through is not None:\n1551             return self.remote_field.through._meta.db_table\n1552         elif self.db_table:\n1553             return self.db_table\n1554         else:\n1555             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)\n1556             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1557 \n1558     def _get_m2m_attr(self, related, attr):\n1559         \"\"\"\n1560         Function that can be curried to provide the source accessor or DB\n1561         column name for the m2m table.\n1562         \"\"\"\n1563         cache_attr = '_m2m_%s_cache' % attr\n1564         if hasattr(self, cache_attr):\n1565             return getattr(self, cache_attr)\n1566         if self.remote_field.through_fields is not None:\n1567             link_field_name = self.remote_field.through_fields[0]\n1568         else:\n1569             link_field_name = None\n1570         for f in self.remote_field.through._meta.fields:\n1571             if (f.is_relation and f.remote_field.model == related.related_model and\n1572                     (link_field_name is None or link_field_name == f.name)):\n1573                 setattr(self, cache_attr, getattr(f, attr))\n1574                 return getattr(self, cache_attr)\n1575 \n1576     def _get_m2m_reverse_attr(self, related, attr):\n1577         \"\"\"\n1578         Function that can be curried to provide the related accessor or DB\n1579         column name for the m2m table.\n1580         \"\"\"\n1581         cache_attr = '_m2m_reverse_%s_cache' % attr\n1582         if hasattr(self, cache_attr):\n1583             return getattr(self, cache_attr)\n1584         found = False\n1585         if self.remote_field.through_fields is not None:\n1586             link_field_name = self.remote_field.through_fields[1]\n1587         else:\n1588             link_field_name = None\n1589         for f in self.remote_field.through._meta.fields:\n1590             if f.is_relation and f.remote_field.model == related.model:\n1591                 if link_field_name is None and related.related_model == related.model:\n1592                     # If this is an m2m-intermediate to self,\n1593                     # the first foreign key you find will be\n1594                     # the source column. Keep searching for\n1595                     # the second foreign key.\n1596                     if found:\n1597                         setattr(self, cache_attr, getattr(f, attr))\n1598                         break\n1599                     else:\n1600                         found = True\n1601                 elif link_field_name is None or link_field_name == f.name:\n1602                     setattr(self, cache_attr, getattr(f, attr))\n1603                     break\n1604         return getattr(self, cache_attr)\n1605 \n1606     def contribute_to_class(self, cls, name, **kwargs):\n1607         # To support multiple relations to self, it's useful to have a non-None\n1608         # related name on symmetrical relations for internal reasons. The\n1609         # concept doesn't make a lot of sense externally (\"you want me to\n1610         # specify *what* on my non-reversible relation?!\"), so we set it up\n1611         # automatically. The funky name reduces the chance of an accidental\n1612         # clash.\n1613         if self.remote_field.symmetrical and (\n1614             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or\n1615             self.remote_field.model == cls._meta.object_name\n1616         ):\n1617             self.remote_field.related_name = \"%s_rel_+\" % name\n1618         elif self.remote_field.is_hidden():\n1619             # If the backwards relation is disabled, replace the original\n1620             # related_name with one generated from the m2m field name. Django\n1621             # still uses backwards relations internally and we need to avoid\n1622             # clashes between multiple m2m fields with related_name == '+'.\n1623             self.remote_field.related_name = \"_%s_%s_+\" % (cls.__name__.lower(), name)\n1624 \n1625         super().contribute_to_class(cls, name, **kwargs)\n1626 \n1627         # The intermediate m2m model is not auto created if:\n1628         #  1) There is a manually specified intermediate, or\n1629         #  2) The class owning the m2m field is abstract.\n1630         #  3) The class owning the m2m field has been swapped out.\n1631         if not cls._meta.abstract:\n1632             if self.remote_field.through:\n1633                 def resolve_through_model(_, model, field):\n1634                     field.remote_field.through = model\n1635                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)\n1636             elif not cls._meta.swapped:\n1637                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)\n1638 \n1639         # Add the descriptor for the m2m relation.\n1640         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1641 \n1642         # Set up the accessor for the m2m table name for the relation.\n1643         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1644 \n1645     def contribute_to_related_class(self, cls, related):\n1646         # Internal M2Ms (i.e., those with a related name ending with '+')\n1647         # and swapped models don't get a related descriptor.\n1648         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n1649             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))\n1650 \n1651         # Set up the accessors for the column names on the m2m table.\n1652         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')\n1653         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')\n1654 \n1655         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')\n1656         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')\n1657 \n1658         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')\n1659         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1660         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')\n1661         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1662 \n1663     def set_attributes_from_rel(self):\n1664         pass\n1665 \n1666     def value_from_object(self, obj):\n1667         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1668 \n1669     def save_form_data(self, instance, data):\n1670         getattr(instance, self.attname).set(data)\n1671 \n1672     def formfield(self, *, using=None, **kwargs):\n1673         defaults = {\n1674             'form_class': forms.ModelMultipleChoiceField,\n1675             'queryset': self.remote_field.model._default_manager.using(using),\n1676             **kwargs,\n1677         }\n1678         # If initial is passed in, it's a list of related objects, but the\n1679         # MultipleChoiceField takes a list of IDs.\n1680         if defaults.get('initial') is not None:\n1681             initial = defaults['initial']\n1682             if callable(initial):\n1683                 initial = initial()\n1684             defaults['initial'] = [i.pk for i in initial]\n1685         return super().formfield(**defaults)\n1686 \n1687     def db_check(self, connection):\n1688         return None\n1689 \n1690     def db_type(self, connection):\n1691         # A ManyToManyField is not represented by a single column,\n1692         # so return None.\n1693         return None\n1694 \n1695     def db_parameters(self, connection):\n1696         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "The error message for incorrectly configured ManyToManyField relationships should accurately reference `ManyToManyField`, clarify arguments for configuring many-to-many relationships, and correct guidance around the `symmetrical` attribute."
    }
]