2025-10-15 14:28:59.102 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 14:29:08.676 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=169, output_tokens=12, cost=0.002050
2025-10-15 14:29:08.677 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 14:29:08.681 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:29:18.457 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=476, output_tokens=363, cost=0.015650
2025-10-15 14:29:18.466 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:29:22.203 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=717, output_tokens=78, cost=0.009510
2025-10-15 14:29:22.205 | DEBUG    | Extracted a valid json.
2025-10-15 14:29:22.205 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"min_fixed\")",
        "search_code(\"max_fixed\")",
        "search_class(\"Printer\")",
        "search_method(\"print\")",
        "search_code(\"strip_zeros\")",
        "search_class(\"LatexPrinter\")",
        "search_class(\"StringPrinter\")"
    ],
    "bug_locations": []
}
2025-10-15 14:29:22.365 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:29:22.366 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:29:41.765 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5192, output_tokens=820, cost=0.076520
2025-10-15 14:29:41.782 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:29:54.192 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6228, output_tokens=446, cost=0.075660
2025-10-15 14:29:54.202 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:30:03.902 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=392, cost=0.019760
2025-10-15 14:30:03.903 | DEBUG    | Extracted a valid json.
2025-10-15 14:30:03.903 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"_print_Float\", \"Printer\")",
        "search_class_in_file(\"StrPrinter\", \"sympy/printing/str.py\")"
    ],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Float",
            "intended_behavior": "This method should be updated or extended to support 'min_fixed' and 'max_fixed' settings for controlling the conversion of float to string in various presentations. The current method already supports 'strip_zeros'. Integrating 'min_fixed' and 'max_fixed' would mean introducing logic to decide on the notation (fixed vs. scientific) based on these thresholds while maintaining the existing functionality around 'strip_zeros'."
        },
        {
            "file": "sympy/printing/printer.py",
            "class": "Printer",
            "intended_behavior": "Though not directly implied as buggy, this file and class may need to be extended to globally define and manage 'min_fixed' and 'max_fixed' settings across all printers. This could take the form of new entries in '_default_settings', ensuring these new settings are inheritable by all printer subclasses. This change would not alter existing functionality but expand on the configurable options available to downstream printers."
        },
        {
            "file": "sympy/printing/str.py",
            "class": "StrPrinter",
            "intended_behavior": "Similar to the 'LatexPrinter', but because we lack current insights due to previous context retrieval limitations, it's anticipated that the class will need adjustments to support 'min_fixed' and 'max_fixed'. This would ensure a uniform approach across different textual representations (e.g., LaTeX, string) for displaying floating-point numbers, adhering to the mentioned settings."
        }
    ]
}
2025-10-15 14:30:04.045 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 14:30:04.046 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 14:30:28.911 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=15077, output_tokens=633, cost=0.169760
2025-10-15 14:30:28.926 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 14:30:42.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=15926, output_tokens=444, cost=0.172580
2025-10-15 14:30:42.251 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 14:30:49.938 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=798, output_tokens=340, cost=0.018180
2025-10-15 14:30:49.939 | DEBUG    | Extracted a valid json.
2025-10-15 14:30:49.940 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/printing/str.py",
            "class": "StrPrinter",
            "method": "_print_Float",
            "intended_behavior": "This method should be adapted to respect `min_fixed` and `max_fixed` settings. If these settings are provided within the `_settings` dict of the `StrPrinter` class, they should be used to decide the format (fixed or scientific notation) of floating-point numbers based on their value. The method must preserve its functionality for handling `strip_zeros` and any original formatting logic. The modification should introduce a check to determine if the float's value falls within the range specified by `min_fixed` and `max_fixed`. If so, use fixed-point notation; otherwise, use scientific notation. This requires integration with the number formatting mechanisms already in place."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Float",
            "intended_behavior": "Similar to `StrPrinter`, this method in the `LatexPrinter` class needs to incorporate `min_fixed` and `max_fixed` settings into its logic for printing floats. The method must ensure that floating-point numbers are produced in LaTeX format adhering to these new settings while still accommodating the existing `strip_zeros` setting. This change involves adjusting the formatting decision process to use fixed or scientific notation based on the provided settings. As in `StrPrinter`, ensure the functionality does not disrupt existing behavior but extends it to consider these additional settings."
        }
    ]
}
2025-10-15 14:30:49.954 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/str.py</file>
<class>StrPrinter</class>
<method>_print_Float</method>
<code>
682     def _print_Float(self, expr):
683         prec = expr._prec
684         if prec < 5:
685             dps = 0
686         else:
687             dps = prec_to_dps(expr._prec)
688         if self._settings["full_prec"] is True:
689             strip = False
690         elif self._settings["full_prec"] is False:
691             strip = True
692         elif self._settings["full_prec"] == "auto":
693             strip = self._print_level > 1
694         rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip)
695         if rv.startswith('-.0'):
696             rv = '-0.' + rv[3:]
697         elif rv.startswith('.0'):
698             rv = '0.' + rv[2:]
699         if rv.startswith('+'):
700             # e.g., +inf -> inf
701             rv = rv[1:]
702         return rv

</code><intended_behavior>This method should be adapted to respect `min_fixed` and `max_fixed` settings. If these settings are provided within the `_settings` dict of the `StrPrinter` class, they should be used to decide the format (fixed or scientific notation) of floating-point numbers based on their value. The method must preserve its functionality for handling `strip_zeros` and any original formatting logic. The modification should introduce a check to determine if the float's value falls within the range specified by `min_fixed` and `max_fixed`. If so, use fixed-point notation; otherwise, use scientific notation. This requires integration with the number formatting mechanisms already in place.</intended_behavior>, <file>sympy/printing/str.py</file>
<class>StrPrinter</class>
<method>None</method>
<code>
19 class StrPrinter(Printer):
20     printmethod = "_sympystr"
21     _default_settings = {
22         "order": None,
23         "full_prec": "auto",
24         "sympy_integers": False,
25         "abbrev": False,
26         "perm_cyclic": True,
27     }  # type: Dict[str, Any]
28 
29     _relationals = dict()  # type: Dict[str, str]
30 
31     def parenthesize(self, item, level, strict=False):
32         if (precedence(item) < level) or ((not strict) and precedence(item) <= level):
33             return "(%s)" % self._print(item)
34         else:
35             return self._print(item)
36 
37     def stringify(self, args, sep, level=0):
38         return sep.join([self.parenthesize(item, level) for item in args])
39 
40     def emptyPrinter(self, expr):
41         if isinstance(expr, str):
42             return expr
43         elif isinstance(expr, Basic):
44             return repr(expr)
45         else:
46             return str(expr)
47 
48     def _print_Add(self, expr, order=None):
49         if self.order == 'none':
50             terms = list(expr.args)
51         else:
52             terms = self._as_ordered_terms(expr, order=order)
53 
54         PREC = precedence(expr)
55         l = []
56         for term in terms:
57             t = self._print(term)
58             if t.startswith('-'):
59                 sign = "-"
60                 t = t[1:]
61             else:
62                 sign = "+"
63             if precedence(term) < PREC:
64                 l.extend([sign, "(%s)" % t])
65             else:
66                 l.extend([sign, t])
67         sign = l.pop(0)
68         if sign == '+':
69             sign = ""
70         return sign + ' '.join(l)
71 
72     def _print_BooleanTrue(self, expr):
73         return "True"
74 
75     def _print_BooleanFalse(self, expr):
76         return "False"
77 
78     def _print_Not(self, expr):
79         return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE["Not"]))
80 
81     def _print_And(self, expr):
82         return self.stringify(expr.args, " & ", PRECEDENCE["BitwiseAnd"])
83 
84     def _print_Or(self, expr):
85         return self.stringify(expr.args, " | ", PRECEDENCE["BitwiseOr"])
86 
87     def _print_Xor(self, expr):
88         return self.stringify(expr.args, " ^ ", PRECEDENCE["BitwiseXor"])
89 
90     def _print_AppliedPredicate(self, expr):
91         return '%s(%s)' % (self._print(expr.func), self._print(expr.arg))
92 
93     def _print_Basic(self, expr):
94         l = [self._print(o) for o in expr.args]
95         return expr.__class__.__name__ + "(%s)" % ", ".join(l)
96 
97     def _print_BlockMatrix(self, B):
98         if B.blocks.shape == (1, 1):
99             self._print(B.blocks[0, 0])
100         return self._print(B.blocks)
101 
102     def _print_Catalan(self, expr):
103         return 'Catalan'
104 
105     def _print_ComplexInfinity(self, expr):
106         return 'zoo'
107 
108     def _print_ConditionSet(self, s):
109         args = tuple([self._print(i) for i in (s.sym, s.condition)])
110         if s.base_set is S.UniversalSet:
111             return 'ConditionSet(%s, %s)' % args
112         args += (self._print(s.base_set),)
113         return 'ConditionSet(%s, %s, %s)' % args
114 
115     def _print_Derivative(self, expr):
116         dexpr = expr.expr
117         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
118         return 'Derivative(%s)' % ", ".join(map(lambda arg: self._print(arg), [dexpr] + dvars))
119 
120     def _print_dict(self, d):
121         keys = sorted(d.keys(), key=default_sort_key)
122         items = []
123 
124         for key in keys:
125             item = "%s: %s" % (self._print(key), self._print(d[key]))
126             items.append(item)
127 
128         return "{%s}" % ", ".join(items)
129 
130     def _print_Dict(self, expr):
131         return self._print_dict(expr)
132 
133     def _print_RandomDomain(self, d):
134         if hasattr(d, 'as_boolean'):
135             return 'Domain: ' + self._print(d.as_boolean())
136         elif hasattr(d, 'set'):
137             return ('Domain: ' + self._print(d.symbols) + ' in ' +
138                     self._print(d.set))
139         else:
140             return 'Domain on ' + self._print(d.symbols)
141 
142     def _print_Dummy(self, expr):
143         return '_' + expr.name
144 
145     def _print_EulerGamma(self, expr):
146         return 'EulerGamma'
147 
148     def _print_Exp1(self, expr):
149         return 'E'
150 
151     def _print_ExprCondPair(self, expr):
152         return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))
153 
154     def _print_Function(self, expr):
155         return expr.func.__name__ + "(%s)" % self.stringify(expr.args, ", ")
156 
157     def _print_GeometryEntity(self, expr):
158         # GeometryEntity is special -- it's base is tuple
159         return str(expr)
160 
161     def _print_GoldenRatio(self, expr):
162         return 'GoldenRatio'
163 
164     def _print_TribonacciConstant(self, expr):
165         return 'TribonacciConstant'
166 
167     def _print_ImaginaryUnit(self, expr):
168         return 'I'
169 
170     def _print_Infinity(self, expr):
171         return 'oo'
172 
173     def _print_Integral(self, expr):
174         def _xab_tostr(xab):
175             if len(xab) == 1:
176                 return self._print(xab[0])
177             else:
178                 return self._print((xab[0],) + tuple(xab[1:]))
179         L = ', '.join([_xab_tostr(l) for l in expr.limits])
180         return 'Integral(%s, %s)' % (self._print(expr.function), L)
181 
182     def _print_Interval(self, i):
183         fin =  'Interval{m}({a}, {b})'
184         a, b, l, r = i.args
185         if a.is_infinite and b.is_infinite:
186             m = ''
187         elif a.is_infinite and not r:
188             m = ''
189         elif b.is_infinite and not l:
190             m = ''
191         elif not l and not r:
192             m = ''
193         elif l and r:
194             m = '.open'
195         elif l:
196             m = '.Lopen'
197         else:
198             m = '.Ropen'
199         return fin.format(**{'a': a, 'b': b, 'm': m})
200 
201     def _print_AccumulationBounds(self, i):
202         return "AccumBounds(%s, %s)" % (self._print(i.min),
203                                         self._print(i.max))
204 
205     def _print_Inverse(self, I):
206         return "%s**(-1)" % self.parenthesize(I.arg, PRECEDENCE["Pow"])
207 
208     def _print_Lambda(self, obj):
209         expr = obj.expr
210         sig = obj.signature
211         if len(sig) == 1 and sig[0].is_symbol:
212             sig = sig[0]
213         return "Lambda(%s, %s)" % (self._print(sig), self._print(expr))
214 
215     def _print_LatticeOp(self, expr):
216         args = sorted(expr.args, key=default_sort_key)
217         return expr.func.__name__ + "(%s)" % ", ".join(self._print(arg) for arg in args)
218 
219     def _print_Limit(self, expr):
220         e, z, z0, dir = expr.args
221         if str(dir) == "+":
222             return "Limit(%s, %s, %s)" % tuple(map(self._print, (e, z, z0)))
223         else:
224             return "Limit(%s, %s, %s, dir='%s')" % tuple(map(self._print,
225                                                             (e, z, z0, dir)))
226 
227     def _print_list(self, expr):
228         return "[%s]" % self.stringify(expr, ", ")
229 
230     def _print_MatrixBase(self, expr):
231         return expr._format_str(self)
232 
233     def _print_MutableSparseMatrix(self, expr):
234         return self._print_MatrixBase(expr)
235 
236     def _print_SparseMatrix(self, expr):
237         from sympy.matrices import Matrix
238         return self._print(Matrix(expr))
239 
240     def _print_ImmutableSparseMatrix(self, expr):
241         return self._print_MatrixBase(expr)
242 
243     def _print_Matrix(self, expr):
244         return self._print_MatrixBase(expr)
245 
246     def _print_DenseMatrix(self, expr):
247         return self._print_MatrixBase(expr)
248 
249     def _print_MutableDenseMatrix(self, expr):
250         return self._print_MatrixBase(expr)
251 
252     def _print_ImmutableMatrix(self, expr):
253         return self._print_MatrixBase(expr)
254 
255     def _print_ImmutableDenseMatrix(self, expr):
256         return self._print_MatrixBase(expr)
257 
258     def _print_MatrixElement(self, expr):
259         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
260             + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))
261 
262     def _print_MatrixSlice(self, expr):
263         def strslice(x):
264             x = list(x)
265             if x[2] == 1:
266                 del x[2]
267             if x[1] == x[0] + 1:
268                 del x[1]
269             if x[0] == 0:
270                 x[0] = ''
271             return ':'.join(map(lambda arg: self._print(arg), x))
272         return (self._print(expr.parent) + '[' +
273                 strslice(expr.rowslice) + ', ' +
274                 strslice(expr.colslice) + ']')
275 
276     def _print_DeferredVector(self, expr):
277         return expr.name
278 
279     def _print_Mul(self, expr):
280 
281         prec = precedence(expr)
282 
283         c, e = expr.as_coeff_Mul()
284         if c < 0:
285             expr = _keep_coeff(-c, e)
286             sign = "-"
287         else:
288             sign = ""
289 
290         a = []  # items in the numerator
291         b = []  # items that are in the denominator (if any)
292 
293         pow_paren = []  # Will collect all pow with more than one base element and exp = -1
294 
295         if self.order not in ('old', 'none'):
296             args = expr.as_ordered_factors()
297         else:
298             # use make_args in case expr was something like -x -> x
299             args = Mul.make_args(expr)
300 
301         # Gather args for numerator/denominator
302         for item in args:
303             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
304                 if item.exp != -1:
305                     b.append(Pow(item.base, -item.exp, evaluate=False))
306                 else:
307                     if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160
308                         pow_paren.append(item)
309                     b.append(Pow(item.base, -item.exp))
310             elif item.is_Rational and item is not S.Infinity:
311                 if item.p != 1:
312                     a.append(Rational(item.p))
313                 if item.q != 1:
314                     b.append(Rational(item.q))
315             else:
316                 a.append(item)
317 
318         a = a or [S.One]
319 
320         a_str = [self.parenthesize(x, prec, strict=False) for x in a]
321         b_str = [self.parenthesize(x, prec, strict=False) for x in b]
322 
323         # To parenthesize Pow with exp = -1 and having more than one Symbol
324         for item in pow_paren:
325             if item.base in b:
326                 b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]
327 
328         if not b:
329             return sign + '*'.join(a_str)
330         elif len(b) == 1:
331             return sign + '*'.join(a_str) + "/" + b_str[0]
332         else:
333             return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)
334 
335     def _print_MatMul(self, expr):
336         c, m = expr.as_coeff_mmul()
337         if c.is_number and c < 0:
338             expr = _keep_coeff(-c, m)
339             sign = "-"
340         else:
341             sign = ""
342 
343         return sign + '*'.join(
344             [self.parenthesize(arg, precedence(expr)) for arg in expr.args]
345         )
346 
347     def _print_ElementwiseApplyFunction(self, expr):
348         return "{0}.({1})".format(
349             expr.function,
350             self._print(expr.expr),
351         )
352 
353     def _print_NaN(self, expr):
354         return 'nan'
355 
356     def _print_NegativeInfinity(self, expr):
357         return '-oo'
358 
359     def _print_Order(self, expr):
360         if not expr.variables or all(p is S.Zero for p in expr.point):
361             if len(expr.variables) <= 1:
362                 return 'O(%s)' % self._print(expr.expr)
363             else:
364                 return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)
365         else:
366             return 'O(%s)' % self.stringify(expr.args, ', ', 0)
367 
368     def _print_Ordinal(self, expr):
369         return expr.__str__()
370 
371     def _print_Cycle(self, expr):
372         return expr.__str__()
373 
374     def _print_Permutation(self, expr):
375         from sympy.combinatorics.permutations import Permutation, Cycle
376         from sympy.utilities.exceptions import SymPyDeprecationWarning
377 
378         perm_cyclic = Permutation.print_cyclic
379         if perm_cyclic is not None:
380             SymPyDeprecationWarning(
381                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
382                 useinstead="init_printing(perm_cyclic={})"
383                 .format(perm_cyclic),
384                 issue=15201,
385                 deprecated_since_version="1.6").warn()
386         else:
387             perm_cyclic = self._settings.get("perm_cyclic", True)
388 
389         if perm_cyclic:
390             if not expr.size:
391                 return '()'
392             # before taking Cycle notation, see if the last element is
393             # a singleton and move it to the head of the string
394             s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
395             last = s.rfind('(')
396             if not last == 0 and ',' not in s[last:]:
397                 s = s[last:] + s[:last]
398             s = s.replace(',', '')
399             return s
400         else:
401             s = expr.support()
402             if not s:
403                 if expr.size < 5:
404                     return 'Permutation(%s)' % self._print(expr.array_form)
405                 return 'Permutation([], size=%s)' % self._print(expr.size)
406             trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)
407             use = full = self._print(expr.array_form)
408             if len(trim) < len(full):
409                 use = trim
410             return 'Permutation(%s)' % use
411 
412     def _print_Subs(self, obj):
413         expr, old, new = obj.args
414         if len(obj.point) == 1:
415             old = old[0]
416             new = new[0]
417         return "Subs(%s, %s, %s)" % (
418             self._print(expr), self._print(old), self._print(new))
419 
420     def _print_TensorIndex(self, expr):
421         return expr._print()
422 
423     def _print_TensorHead(self, expr):
424         return expr._print()
425 
426     def _print_Tensor(self, expr):
427         return expr._print()
428 
429     def _print_TensMul(self, expr):
430         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
431         sign, args = expr._get_args_for_traditional_printer()
432         return sign + "*".join(
433             [self.parenthesize(arg, precedence(expr)) for arg in args]
434         )
435 
436     def _print_TensAdd(self, expr):
437         return expr._print()
438 
439     def _print_PermutationGroup(self, expr):
440         p = ['    %s' % self._print(a) for a in expr.args]
441         return 'PermutationGroup([\n%s])' % ',\n'.join(p)
442 
443     def _print_Pi(self, expr):
444         return 'pi'
445 
446     def _print_PolyRing(self, ring):
447         return "Polynomial ring in %s over %s with %s order" % \
448             (", ".join(map(lambda rs: self._print(rs), ring.symbols)),
449             self._print(ring.domain), self._print(ring.order))
450 
451     def _print_FracField(self, field):
452         return "Rational function field in %s over %s with %s order" % \
453             (", ".join(map(lambda fs: self._print(fs), field.symbols)),
454             self._print(field.domain), self._print(field.order))
455 
456     def _print_FreeGroupElement(self, elm):
457         return elm.__str__()
458 
459     def _print_PolyElement(self, poly):
460         return poly.str(self, PRECEDENCE, "%s**%s", "*")
461 
462     def _print_FracElement(self, frac):
463         if frac.denom == 1:
464             return self._print(frac.numer)
465         else:
466             numer = self.parenthesize(frac.numer, PRECEDENCE["Mul"], strict=True)
467             denom = self.parenthesize(frac.denom, PRECEDENCE["Atom"], strict=True)
468             return numer + "/" + denom
469 
470     def _print_Poly(self, expr):
471         ATOM_PREC = PRECEDENCE["Atom"] - 1
472         terms, gens = [], [ self.parenthesize(s, ATOM_PREC) for s in expr.gens ]
473 
474         for monom, coeff in expr.terms():
475             s_monom = []
476 
477             for i, exp in enumerate(monom):
478                 if exp > 0:
479                     if exp == 1:
480                         s_monom.append(gens[i])
481                     else:
482                         s_monom.append(gens[i] + "**%d" % exp)
483 
484             s_monom = "*".join(s_monom)
485 
486             if coeff.is_Add:
487                 if s_monom:
488                     s_coeff = "(" + self._print(coeff) + ")"
489                 else:
490                     s_coeff = self._print(coeff)
491             else:
492                 if s_monom:
493                     if coeff is S.One:
494                         terms.extend(['+', s_monom])
495                         continue
496 
497                     if coeff is S.NegativeOne:
498                         terms.extend(['-', s_monom])
499                         continue
500 
501                 s_coeff = self._print(coeff)
502 
503             if not s_monom:
504                 s_term = s_coeff
505             else:
506                 s_term = s_coeff + "*" + s_monom
507 
508             if s_term.startswith('-'):
509                 terms.extend(['-', s_term[1:]])
510             else:
511                 terms.extend(['+', s_term])
512 
513         if terms[0] in ['-', '+']:
514             modifier = terms.pop(0)
515 
516             if modifier == '-':
517                 terms[0] = '-' + terms[0]
518 
519         format = expr.__class__.__name__ + "(%s, %s"
520 
521         from sympy.polys.polyerrors import PolynomialError
522 
523         try:
524             format += ", modulus=%s" % expr.get_modulus()
525         except PolynomialError:
526             format += ", domain='%s'" % expr.get_domain()
527 
528         format += ")"
529 
530         for index, item in enumerate(gens):
531             if len(item) > 2 and (item[:1] == "(" and item[len(item) - 1:] == ")"):
532                 gens[index] = item[1:len(item) - 1]
533 
534         return format % (' '.join(terms), ', '.join(gens))
535 
536     def _print_UniversalSet(self, p):
537         return 'UniversalSet'
538 
539     def _print_AlgebraicNumber(self, expr):
540         if expr.is_aliased:
541             return self._print(expr.as_poly().as_expr())
542         else:
543             return self._print(expr.as_expr())
544 
545     def _print_Pow(self, expr, rational=False):
546         """Printing helper function for ``Pow``
547 
548         Parameters
549         ==========
550 
551         rational : bool, optional
552             If ``True``, it will not attempt printing ``sqrt(x)`` or
553             ``x**S.Half`` as ``sqrt``, and will use ``x**(1/2)``
554             instead.
555 
556             See examples for additional details
557 
558         Examples
559         ========
560 
561         >>> from sympy.functions import sqrt
562         >>> from sympy.printing.str import StrPrinter
563         >>> from sympy.abc import x
564 
565         How ``rational`` keyword works with ``sqrt``:
566 
567         >>> printer = StrPrinter()
568         >>> printer._print_Pow(sqrt(x), rational=True)
569         'x**(1/2)'
570         >>> printer._print_Pow(sqrt(x), rational=False)
571         'sqrt(x)'
572         >>> printer._print_Pow(1/sqrt(x), rational=True)
573         'x**(-1/2)'
574         >>> printer._print_Pow(1/sqrt(x), rational=False)
575         '1/sqrt(x)'
576 
577         Notes
578         =====
579 
580         ``sqrt(x)`` is canonicalized as ``Pow(x, S.Half)`` in SymPy,
581         so there is no need of defining a separate printer for ``sqrt``.
582         Instead, it should be handled here as well.
583         """
584         PREC = precedence(expr)
585 
586         if expr.exp is S.Half and not rational:
587             return "sqrt(%s)" % self._print(expr.base)
588 
589         if expr.is_commutative:
590             if -expr.exp is S.Half and not rational:
591                 # Note: Don't test "expr.exp == -S.Half" here, because that will
592                 # match -0.5, which we don't want.
593                 return "%s/sqrt(%s)" % tuple(map(lambda arg: self._print(arg), (S.One, expr.base)))
594             if expr.exp is -S.One:
595                 # Similarly to the S.Half case, don't test with "==" here.
596                 return '%s/%s' % (self._print(S.One),
597                                   self.parenthesize(expr.base, PREC, strict=False))
598 
599         e = self.parenthesize(expr.exp, PREC, strict=False)
600         if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and expr.exp.q != 1:
601             # the parenthesized exp should be '(Rational(a, b))' so strip parens,
602             # but just check to be sure.
603             if e.startswith('(Rational'):
604                 return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
605         return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)
606 
607     def _print_UnevaluatedExpr(self, expr):
608         return self._print(expr.args[0])
609 
610     def _print_MatPow(self, expr):
611         PREC = precedence(expr)
612         return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False),
613                          self.parenthesize(expr.exp, PREC, strict=False))
614 
615     def _print_ImmutableDenseNDimArray(self, expr):
616         return str(expr)
617 
618     def _print_ImmutableSparseNDimArray(self, expr):
619         return str(expr)
620 
621     def _print_Integer(self, expr):
622         if self._settings.get("sympy_integers", False):
623             return "S(%s)" % (expr)
624         return str(expr.p)
625 
626     def _print_Integers(self, expr):
627         return 'Integers'
628 
629     def _print_Naturals(self, expr):
630         return 'Naturals'
631 
632     def _print_Naturals0(self, expr):
633         return 'Naturals0'
634 
635     def _print_Rationals(self, expr):
636         return 'Rationals'
637 
638     def _print_Reals(self, expr):
639         return 'Reals'
640 
641     def _print_Complexes(self, expr):
642         return 'Complexes'
643 
644     def _print_EmptySet(self, expr):
645         return 'EmptySet'
646 
647     def _print_EmptySequence(self, expr):
648         return 'EmptySequence'
649 
650     def _print_int(self, expr):
651         return str(expr)
652 
653     def _print_mpz(self, expr):
654         return str(expr)
655 
656     def _print_Rational(self, expr):
657         if expr.q == 1:
658             return str(expr.p)
659         else:
660             if self._settings.get("sympy_integers", False):
661                 return "S(%s)/%s" % (expr.p, expr.q)
662             return "%s/%s" % (expr.p, expr.q)
663 
664     def _print_PythonRational(self, expr):
665         if expr.q == 1:
666             return str(expr.p)
667         else:
668             return "%d/%d" % (expr.p, expr.q)
669 
670     def _print_Fraction(self, expr):
671         if expr.denominator == 1:
672             return str(expr.numerator)
673         else:
674             return "%s/%s" % (expr.numerator, expr.denominator)
675 
676     def _print_mpq(self, expr):
677         if expr.denominator == 1:
678             return str(expr.numerator)
679         else:
680             return "%s/%s" % (expr.numerator, expr.denominator)
681 
682     def _print_Float(self, expr):
683         prec = expr._prec
684         if prec < 5:
685             dps = 0
686         else:
687             dps = prec_to_dps(expr._prec)
688         if self._settings["full_prec"] is True:
689             strip = False
690         elif self._settings["full_prec"] is False:
691             strip = True
692         elif self._settings["full_prec"] == "auto":
693             strip = self._print_level > 1
694         rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip)
695         if rv.startswith('-.0'):
696             rv = '-0.' + rv[3:]
697         elif rv.startswith('.0'):
698             rv = '0.' + rv[2:]
699         if rv.startswith('+'):
700             # e.g., +inf -> inf
701             rv = rv[1:]
702         return rv
703 
704     def _print_Relational(self, expr):
705 
706         charmap = {
707             "==": "Eq",
708             "!=": "Ne",
709             ":=": "Assignment",
710             '+=': "AddAugmentedAssignment",
711             "-=": "SubAugmentedAssignment",
712             "*=": "MulAugmentedAssignment",
713             "/=": "DivAugmentedAssignment",
714             "%=": "ModAugmentedAssignment",
715         }
716 
717         if expr.rel_op in charmap:
718             return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs),
719                                    self._print(expr.rhs))
720 
721         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
722                            self._relationals.get(expr.rel_op) or expr.rel_op,
723                            self.parenthesize(expr.rhs, precedence(expr)))
724 
725     def _print_ComplexRootOf(self, expr):
726         return "CRootOf(%s, %d)" % (self._print_Add(expr.expr,  order='lex'),
727                                     expr.index)
728 
729     def _print_RootSum(self, expr):
730         args = [self._print_Add(expr.expr, order='lex')]
731 
732         if expr.fun is not S.IdentityFunction:
733             args.append(self._print(expr.fun))
734 
735         return "RootSum(%s)" % ", ".join(args)
736 
737     def _print_GroebnerBasis(self, basis):
738         cls = basis.__class__.__name__
739 
740         exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]
741         exprs = "[%s]" % ", ".join(exprs)
742 
743         gens = [ self._print(gen) for gen in basis.gens ]
744         domain = "domain='%s'" % self._print(basis.domain)
745         order = "order='%s'" % self._print(basis.order)
746 
747         args = [exprs] + gens + [domain, order]
748 
749         return "%s(%s)" % (cls, ", ".join(args))
750 
751     def _print_set(self, s):
752         items = sorted(s, key=default_sort_key)
753 
754         args = ', '.join(self._print(item) for item in items)
755         if not args:
756             return "set()"
757         return '{%s}' % args
758 
759     def _print_frozenset(self, s):
760         if not s:
761             return "frozenset()"
762         return "frozenset(%s)" % self._print_set(s)
763 
764     def _print_Sum(self, expr):
765         def _xab_tostr(xab):
766             if len(xab) == 1:
767                 return self._print(xab[0])
768             else:
769                 return self._print((xab[0],) + tuple(xab[1:]))
770         L = ', '.join([_xab_tostr(l) for l in expr.limits])
771         return 'Sum(%s, %s)' % (self._print(expr.function), L)
772 
773     def _print_Symbol(self, expr):
774         return expr.name
775     _print_MatrixSymbol = _print_Symbol
776     _print_RandomSymbol = _print_Symbol
777 
778     def _print_Identity(self, expr):
779         return "I"
780 
781     def _print_ZeroMatrix(self, expr):
782         return "0"
783 
784     def _print_OneMatrix(self, expr):
785         return "1"
786 
787     def _print_Predicate(self, expr):
788         return "Q.%s" % expr.name
789 
790     def _print_str(self, expr):
791         return str(expr)
792 
793     def _print_tuple(self, expr):
794         if len(expr) == 1:
795             return "(%s,)" % self._print(expr[0])
796         else:
797             return "(%s)" % self.stringify(expr, ", ")
798 
799     def _print_Tuple(self, expr):
800         return self._print_tuple(expr)
801 
802     def _print_Transpose(self, T):
803         return "%s.T" % self.parenthesize(T.arg, PRECEDENCE["Pow"])
804 
805     def _print_Uniform(self, expr):
806         return "Uniform(%s, %s)" % (self._print(expr.a), self._print(expr.b))
807 
808     def _print_Quantity(self, expr):
809         if self._settings.get("abbrev", False):
810             return "%s" % expr.abbrev
811         return "%s" % expr.name
812 
813     def _print_Quaternion(self, expr):
814         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
815         a = [s[0]] + [i+"*"+j for i, j in zip(s[1:], "ijk")]
816         return " + ".join(a)
817 
818     def _print_Dimension(self, expr):
819         return str(expr)
820 
821     def _print_Wild(self, expr):
822         return expr.name + '_'
823 
824     def _print_WildFunction(self, expr):
825         return expr.name + '_'
826 
827     def _print_Zero(self, expr):
828         if self._settings.get("sympy_integers", False):
829             return "S(0)"
830         return "0"
831 
832     def _print_DMP(self, p):
833         from sympy.core.sympify import SympifyError
834         try:
835             if p.ring is not None:
836                 # TODO incorporate order
837                 return self._print(p.ring.to_sympy(p))
838         except SympifyError:
839             pass
840 
841         cls = p.__class__.__name__
842         rep = self._print(p.rep)
843         dom = self._print(p.dom)
844         ring = self._print(p.ring)
845 
846         return "%s(%s, %s, %s)" % (cls, rep, dom, ring)
847 
848     def _print_DMF(self, expr):
849         return self._print_DMP(expr)
850 
851     def _print_Object(self, obj):
852         return 'Object("%s")' % obj.name
853 
854     def _print_IdentityMorphism(self, morphism):
855         return 'IdentityMorphism(%s)' % morphism.domain
856 
857     def _print_NamedMorphism(self, morphism):
858         return 'NamedMorphism(%s, %s, "%s")' % \
859                (morphism.domain, morphism.codomain, morphism.name)
860 
861     def _print_Category(self, category):
862         return 'Category("%s")' % category.name
863 
864     def _print_BaseScalarField(self, field):
865         return field._coord_sys._names[field._index]
866 
867     def _print_BaseVectorField(self, field):
868         return 'e_%s' % field._coord_sys._names[field._index]
869 
870     def _print_Differential(self, diff):
871         field = diff._form_field
872         if hasattr(field, '_coord_sys'):
873             return 'd%s' % field._coord_sys._names[field._index]
874         else:
875             return 'd(%s)' % self._print(field)
876 
877     def _print_Tr(self, expr):
878         #TODO : Handle indices
879         return "%s(%s)" % ("Tr", self._print(expr.args[0]))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Float</method>
<code>
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real

</code><intended_behavior>Similar to `StrPrinter`, this method in the `LatexPrinter` class needs to incorporate `min_fixed` and `max_fixed` settings into its logic for printing floats. The method must ensure that floating-point numbers are produced in LaTeX format adhering to these new settings while still accommodating the existing `strip_zeros` setting. This change involves adjusting the formatting decision process to use fixed or scientific notation based on the provided settings. As in `StrPrinter`, ensure the functionality does not disrupt existing behavior but extends it to consider these additional settings.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
124 class LatexPrinter(Printer):
125     printmethod = "_latex"
126 
127     _default_settings = {
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "inv_trig_style": "abbreviated",
132         "itex": False,
133         "ln_notation": False,
134         "long_frac_ratio": None,
135         "mat_delim": "[",
136         "mat_str": None,
137         "mode": "plain",
138         "mul_symbol": None,
139         "order": None,
140         "symbol_names": {},
141         "root_notation": True,
142         "mat_symbol_style": "plain",
143         "imaginary_unit": "i",
144         "gothic_re_im": False,
145         "decimal_separator": "period",
146         "perm_cyclic": True,
147     }  # type: Dict[str, Any]
148 
149     def __init__(self, settings=None):
150         Printer.__init__(self, settings)
151 
152         if 'mode' in self._settings:
153             valid_modes = ['inline', 'plain', 'equation',
154                            'equation*']
155             if self._settings['mode'] not in valid_modes:
156                 raise ValueError("'mode' must be one of 'inline', 'plain', "
157                                  "'equation' or 'equation*'")
158 
159         if self._settings['fold_short_frac'] is None and \
160                 self._settings['mode'] == 'inline':
161             self._settings['fold_short_frac'] = True
162 
163         mul_symbol_table = {
164             None: r" ",
165             "ldot": r" \,.\, ",
166             "dot": r" \cdot ",
167             "times": r" \times "
168         }
169         try:
170             self._settings['mul_symbol_latex'] = \
171                 mul_symbol_table[self._settings['mul_symbol']]
172         except KeyError:
173             self._settings['mul_symbol_latex'] = \
174                 self._settings['mul_symbol']
175         try:
176             self._settings['mul_symbol_latex_numbers'] = \
177                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
178         except KeyError:
179             if (self._settings['mul_symbol'].strip() in
180                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
181                 self._settings['mul_symbol_latex_numbers'] = \
182                     mul_symbol_table['dot']
183             else:
184                 self._settings['mul_symbol_latex_numbers'] = \
185                     self._settings['mul_symbol']
186 
187         self._delim_dict = {'(': ')', '[': ']'}
188 
189         imaginary_unit_table = {
190             None: r"i",
191             "i": r"i",
192             "ri": r"\mathrm{i}",
193             "ti": r"\text{i}",
194             "j": r"j",
195             "rj": r"\mathrm{j}",
196             "tj": r"\text{j}",
197         }
198         try:
199             self._settings['imaginary_unit_latex'] = \
200                 imaginary_unit_table[self._settings['imaginary_unit']]
201         except KeyError:
202             self._settings['imaginary_unit_latex'] = \
203                 self._settings['imaginary_unit']
204 
205     def parenthesize(self, item, level, strict=False):
206         prec_val = precedence_traditional(item)
207         if (prec_val < level) or ((not strict) and prec_val <= level):
208             return r"\left({}\right)".format(self._print(item))
209         else:
210             return self._print(item)
211 
212     def parenthesize_super(self, s):
213         """ Parenthesize s if there is a superscript in s"""
214         if "^" in s:
215             return r"\left({}\right)".format(s)
216         return s
217 
218     def embed_super(self, s):
219         """ Embed s in {} if there is a superscript in s"""
220         if "^" in s:
221             return "{{{}}}".format(s)
222         return s
223 
224     def doprint(self, expr):
225         tex = Printer.doprint(self, expr)
226 
227         if self._settings['mode'] == 'plain':
228             return tex
229         elif self._settings['mode'] == 'inline':
230             return r"$%s$" % tex
231         elif self._settings['itex']:
232             return r"$$%s$$" % tex
233         else:
234             env_str = self._settings['mode']
235             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
236 
237     def _needs_brackets(self, expr):
238         """
239         Returns True if the expression needs to be wrapped in brackets when
240         printed, False otherwise. For example: a + b => True; a => False;
241         10 => False; -10 => True.
242         """
243         return not ((expr.is_Integer and expr.is_nonnegative)
244                     or (expr.is_Atom and (expr is not S.NegativeOne
245                                           and expr.is_Rational is False)))
246 
247     def _needs_function_brackets(self, expr):
248         """
249         Returns True if the expression needs to be wrapped in brackets when
250         passed as an argument to a function, False otherwise. This is a more
251         liberal version of _needs_brackets, in that many expressions which need
252         to be wrapped in brackets when added/subtracted/raised to a power do
253         not need them when passed to a function. Such an example is a*b.
254         """
255         if not self._needs_brackets(expr):
256             return False
257         else:
258             # Muls of the form a*b*c... can be folded
259             if expr.is_Mul and not self._mul_is_clean(expr):
260                 return True
261             # Pows which don't need brackets can be folded
262             elif expr.is_Pow and not self._pow_is_clean(expr):
263                 return True
264             # Add and Function always need brackets
265             elif expr.is_Add or expr.is_Function:
266                 return True
267             else:
268                 return False
269 
270     def _needs_mul_brackets(self, expr, first=False, last=False):
271         """
272         Returns True if the expression needs to be wrapped in brackets when
273         printed as part of a Mul, False otherwise. This is True for Add,
274         but also for some container objects that would not need brackets
275         when appearing last in a Mul, e.g. an Integral. ``last=True``
276         specifies that this expr is the last to appear in a Mul.
277         ``first=True`` specifies that this expr is the first to appear in
278         a Mul.
279         """
280         from sympy import Integral, Product, Sum
281 
282         if expr.is_Mul:
283             if not first and _coeff_isneg(expr):
284                 return True
285         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
286             return True
287         elif expr.is_Relational:
288             return True
289         if expr.is_Piecewise:
290             return True
291         if any([expr.has(x) for x in (Mod,)]):
292             return True
293         if (not last and
294                 any([expr.has(x) for x in (Integral, Product, Sum)])):
295             return True
296 
297         return False
298 
299     def _needs_add_brackets(self, expr):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of an Add, False otherwise.  This is False for most
303         things.
304         """
305         if expr.is_Relational:
306             return True
307         if any([expr.has(x) for x in (Mod,)]):
308             return True
309         if expr.is_Add:
310             return True
311         return False
312 
313     def _mul_is_clean(self, expr):
314         for arg in expr.args:
315             if arg.is_Function:
316                 return False
317         return True
318 
319     def _pow_is_clean(self, expr):
320         return not self._needs_brackets(expr.base)
321 
322     def _do_exponent(self, expr, exp):
323         if exp is not None:
324             return r"\left(%s\right)^{%s}" % (expr, exp)
325         else:
326             return expr
327 
328     def _print_Basic(self, expr):
329         ls = [self._print(o) for o in expr.args]
330         return self._deal_with_super_sub(expr.__class__.__name__) + \
331             r"\left(%s\right)" % ", ".join(ls)
332 
333     def _print_bool(self, e):
334         return r"\text{%s}" % e
335 
336     _print_BooleanTrue = _print_bool
337     _print_BooleanFalse = _print_bool
338 
339     def _print_NoneType(self, e):
340         return r"\text{%s}" % e
341 
342     def _print_Add(self, expr, order=None):
343         if self.order == 'none':
344             terms = list(expr.args)
345         else:
346             terms = self._as_ordered_terms(expr, order=order)
347 
348         tex = ""
349         for i, term in enumerate(terms):
350             if i == 0:
351                 pass
352             elif _coeff_isneg(term):
353                 tex += " - "
354                 term = -term
355             else:
356                 tex += " + "
357             term_tex = self._print(term)
358             if self._needs_add_brackets(term):
359                 term_tex = r"\left(%s\right)" % term_tex
360             tex += term_tex
361 
362         return tex
363 
364     def _print_Cycle(self, expr):
365         from sympy.combinatorics.permutations import Permutation
366         if expr.size == 0:
367             return r"\left( \right)"
368         expr = Permutation(expr)
369         expr_perm = expr.cyclic_form
370         siz = expr.size
371         if expr.array_form[-1] == siz - 1:
372             expr_perm = expr_perm + [[siz - 1]]
373         term_tex = ''
374         for i in expr_perm:
375             term_tex += str(i).replace(',', r"\;")
376         term_tex = term_tex.replace('[', r"\left( ")
377         term_tex = term_tex.replace(']', r"\right)")
378         return term_tex
379 
380     def _print_Permutation(self, expr):
381         from sympy.combinatorics.permutations import Permutation
382         from sympy.utilities.exceptions import SymPyDeprecationWarning
383 
384         perm_cyclic = Permutation.print_cyclic
385         if perm_cyclic is not None:
386             SymPyDeprecationWarning(
387                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
388                 useinstead="init_printing(perm_cyclic={})"
389                 .format(perm_cyclic),
390                 issue=15201,
391                 deprecated_since_version="1.6").warn()
392         else:
393             perm_cyclic = self._settings.get("perm_cyclic", True)
394 
395         if perm_cyclic:
396             return self._print_Cycle(expr)
397 
398         if expr.size == 0:
399             return r"\left( \right)"
400 
401         lower = [self._print(arg) for arg in expr.array_form]
402         upper = [self._print(arg) for arg in range(len(lower))]
403 
404         row1 = " & ".join(upper)
405         row2 = " & ".join(lower)
406         mat = r" \\ ".join((row1, row2))
407         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
408 
409 
410     def _print_AppliedPermutation(self, expr):
411         perm, var = expr.args
412         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
413 
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real
440 
441     def _print_Cross(self, expr):
442         vec1 = expr._expr1
443         vec2 = expr._expr2
444         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
445                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
446 
447     def _print_Curl(self, expr):
448         vec = expr._expr
449         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
450 
451     def _print_Divergence(self, expr):
452         vec = expr._expr
453         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
454 
455     def _print_Dot(self, expr):
456         vec1 = expr._expr1
457         vec2 = expr._expr2
458         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
459                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
460 
461     def _print_Gradient(self, expr):
462         func = expr._expr
463         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
464 
465     def _print_Laplacian(self, expr):
466         func = expr._expr
467         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
468 
469     def _print_Mul(self, expr):
470         from sympy.core.power import Pow
471         from sympy.physics.units import Quantity
472         include_parens = False
473         if _coeff_isneg(expr):
474             expr = -expr
475             tex = "- "
476             if expr.is_Add:
477                 tex += "("
478                 include_parens = True
479         else:
480             tex = ""
481 
482         from sympy.simplify import fraction
483         numer, denom = fraction(expr, exact=True)
484         separator = self._settings['mul_symbol_latex']
485         numbersep = self._settings['mul_symbol_latex_numbers']
486 
487         def convert(expr):
488             if not expr.is_Mul:
489                 return str(self._print(expr))
490             else:
491                 _tex = last_term_tex = ""
492 
493                 if self.order not in ('old', 'none'):
494                     args = expr.as_ordered_factors()
495                 else:
496                     args = list(expr.args)
497 
498                 # If quantities are present append them at the back
499                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
500                               (isinstance(x, Pow) and
501                                isinstance(x.base, Quantity)))
502 
503                 for i, term in enumerate(args):
504                     term_tex = self._print(term)
505 
506                     if self._needs_mul_brackets(term, first=(i == 0),
507                                                 last=(i == len(args) - 1)):
508                         term_tex = r"\left(%s\right)" % term_tex
509 
510                     if _between_two_numbers_p[0].search(last_term_tex) and \
511                             _between_two_numbers_p[1].match(term_tex):
512                         # between two numbers
513                         _tex += numbersep
514                     elif _tex:
515                         _tex += separator
516 
517                     _tex += term_tex
518                     last_term_tex = term_tex
519                 return _tex
520 
521         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
522             # use the original expression here, since fraction() may have
523             # altered it when producing numer and denom
524             tex += convert(expr)
525 
526         else:
527             snumer = convert(numer)
528             sdenom = convert(denom)
529             ldenom = len(sdenom.split())
530             ratio = self._settings['long_frac_ratio']
531             if self._settings['fold_short_frac'] and ldenom <= 2 and \
532                     "^" not in sdenom:
533                 # handle short fractions
534                 if self._needs_mul_brackets(numer, last=False):
535                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
536                 else:
537                     tex += r"%s / %s" % (snumer, sdenom)
538             elif ratio is not None and \
539                     len(snumer.split()) > ratio*ldenom:
540                 # handle long fractions
541                 if self._needs_mul_brackets(numer, last=True):
542                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
543                         % (sdenom, separator, snumer)
544                 elif numer.is_Mul:
545                     # split a long numerator
546                     a = S.One
547                     b = S.One
548                     for x in numer.args:
549                         if self._needs_mul_brackets(x, last=False) or \
550                                 len(convert(a*x).split()) > ratio*ldenom or \
551                                 (b.is_commutative is x.is_commutative is False):
552                             b *= x
553                         else:
554                             a *= x
555                     if self._needs_mul_brackets(b, last=True):
556                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
557                             % (convert(a), sdenom, separator, convert(b))
558                     else:
559                         tex += r"\frac{%s}{%s}%s%s" \
560                             % (convert(a), sdenom, separator, convert(b))
561                 else:
562                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
563             else:
564                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
565 
566         if include_parens:
567             tex += ")"
568         return tex
569 
570     def _print_Pow(self, expr):
571         # Treat x**Rational(1,n) as special case
572         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
573                 and self._settings['root_notation']:
574             base = self._print(expr.base)
575             expq = expr.exp.q
576 
577             if expq == 2:
578                 tex = r"\sqrt{%s}" % base
579             elif self._settings['itex']:
580                 tex = r"\root{%d}{%s}" % (expq, base)
581             else:
582                 tex = r"\sqrt[%d]{%s}" % (expq, base)
583 
584             if expr.exp.is_negative:
585                 return r"\frac{1}{%s}" % tex
586             else:
587                 return tex
588         elif self._settings['fold_frac_powers'] \
589             and expr.exp.is_Rational \
590                 and expr.exp.q != 1:
591             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
592             p, q = expr.exp.p, expr.exp.q
593             # issue #12886: add parentheses for superscripts raised to powers
594             if '^' in base and expr.base.is_Symbol:
595                 base = r"\left(%s\right)" % base
596             if expr.base.is_Function:
597                 return self._print(expr.base, exp="%s/%s" % (p, q))
598             return r"%s^{%s/%s}" % (base, p, q)
599         elif expr.exp.is_Rational and expr.exp.is_negative and \
600                 expr.base.is_commutative:
601             # special case for 1^(-x), issue 9216
602             if expr.base == 1:
603                 return r"%s^{%s}" % (expr.base, expr.exp)
604             # things like 1/x
605             return self._print_Mul(expr)
606         else:
607             if expr.base.is_Function:
608                 return self._print(expr.base, exp=self._print(expr.exp))
609             else:
610                 tex = r"%s^{%s}"
611                 return self._helper_print_standard_power(expr, tex)
612 
613     def _helper_print_standard_power(self, expr, template):
614         exp = self._print(expr.exp)
615         # issue #12886: add parentheses around superscripts raised
616         # to powers
617         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
618         if '^' in base and expr.base.is_Symbol:
619             base = r"\left(%s\right)" % base
620         elif (isinstance(expr.base, Derivative)
621             and base.startswith(r'\left(')
622             and re.match(r'\\left\(\\d?d?dot', base)
623             and base.endswith(r'\right)')):
624             # don't use parentheses around dotted derivative
625             base = base[6: -7]  # remove outermost added parens
626         return template % (base, exp)
627 
628     def _print_UnevaluatedExpr(self, expr):
629         return self._print(expr.args[0])
630 
631     def _print_Sum(self, expr):
632         if len(expr.limits) == 1:
633             tex = r"\sum_{%s=%s}^{%s} " % \
634                 tuple([self._print(i) for i in expr.limits[0]])
635         else:
636             def _format_ineq(l):
637                 return r"%s \leq %s \leq %s" % \
638                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
639 
640             tex = r"\sum_{\substack{%s}} " % \
641                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
642 
643         if isinstance(expr.function, Add):
644             tex += r"\left(%s\right)" % self._print(expr.function)
645         else:
646             tex += self._print(expr.function)
647 
648         return tex
649 
650     def _print_Product(self, expr):
651         if len(expr.limits) == 1:
652             tex = r"\prod_{%s=%s}^{%s} " % \
653                 tuple([self._print(i) for i in expr.limits[0]])
654         else:
655             def _format_ineq(l):
656                 return r"%s \leq %s \leq %s" % \
657                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
658 
659             tex = r"\prod_{\substack{%s}} " % \
660                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
661 
662         if isinstance(expr.function, Add):
663             tex += r"\left(%s\right)" % self._print(expr.function)
664         else:
665             tex += self._print(expr.function)
666 
667         return tex
668 
669     def _print_BasisDependent(self, expr):
670         from sympy.vector import Vector
671 
672         o1 = []
673         if expr == expr.zero:
674             return expr.zero._latex_form
675         if isinstance(expr, Vector):
676             items = expr.separate().items()
677         else:
678             items = [(0, expr)]
679 
680         for system, vect in items:
681             inneritems = list(vect.components.items())
682             inneritems.sort(key=lambda x: x[0].__str__())
683             for k, v in inneritems:
684                 if v == 1:
685                     o1.append(' + ' + k._latex_form)
686                 elif v == -1:
687                     o1.append(' - ' + k._latex_form)
688                 else:
689                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
690                     o1.append(' + ' + arg_str + k._latex_form)
691 
692         outstr = (''.join(o1))
693         if outstr[1] != '-':
694             outstr = outstr[3:]
695         else:
696             outstr = outstr[1:]
697         return outstr
698 
699     def _print_Indexed(self, expr):
700         tex_base = self._print(expr.base)
701         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
702             map(self._print, expr.indices))
703         return tex
704 
705     def _print_IndexedBase(self, expr):
706         return self._print(expr.label)
707 
708     def _print_Derivative(self, expr):
709         if requires_partial(expr.expr):
710             diff_symbol = r'\partial'
711         else:
712             diff_symbol = r'd'
713 
714         tex = ""
715         dim = 0
716         for x, num in reversed(expr.variable_count):
717             dim += num
718             if num == 1:
719                 tex += r"%s %s" % (diff_symbol, self._print(x))
720             else:
721                 tex += r"%s %s^{%s}" % (diff_symbol,
722                                         self.parenthesize_super(self._print(x)),
723                                         self._print(num))
724 
725         if dim == 1:
726             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
727         else:
728             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
729 
730         return r"%s %s" % (tex, self.parenthesize(expr.expr,
731                                                   PRECEDENCE["Mul"],
732                                                   strict=True))
733 
734     def _print_Subs(self, subs):
735         expr, old, new = subs.args
736         latex_expr = self._print(expr)
737         latex_old = (self._print(e) for e in old)
738         latex_new = (self._print(e) for e in new)
739         latex_subs = r'\\ '.join(
740             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
741         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
742                                                          latex_subs)
743 
744     def _print_Integral(self, expr):
745         tex, symbols = "", []
746 
747         # Only up to \iiiint exists
748         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
749             # Use len(expr.limits)-1 so that syntax highlighters don't think
750             # \" is an escaped quote
751             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
752             symbols = [r"\, d%s" % self._print(symbol[0])
753                        for symbol in expr.limits]
754 
755         else:
756             for lim in reversed(expr.limits):
757                 symbol = lim[0]
758                 tex += r"\int"
759 
760                 if len(lim) > 1:
761                     if self._settings['mode'] != 'inline' \
762                             and not self._settings['itex']:
763                         tex += r"\limits"
764 
765                     if len(lim) == 3:
766                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
767                                                self._print(lim[2]))
768                     if len(lim) == 2:
769                         tex += "^{%s}" % (self._print(lim[1]))
770 
771                 symbols.insert(0, r"\, d%s" % self._print(symbol))
772 
773         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
774                                                     PRECEDENCE["Mul"],
775                                                     strict=True),
776                              "".join(symbols))
777 
778     def _print_Limit(self, expr):
779         e, z, z0, dir = expr.args
780 
781         tex = r"\lim_{%s \to " % self._print(z)
782         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
783             tex += r"%s}" % self._print(z0)
784         else:
785             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
786 
787         if isinstance(e, AssocOp):
788             return r"%s\left(%s\right)" % (tex, self._print(e))
789         else:
790             return r"%s %s" % (tex, self._print(e))
791 
792     def _hprint_Function(self, func):
793         r'''
794         Logic to decide how to render a function to latex
795           - if it is a recognized latex name, use the appropriate latex command
796           - if it is a single letter, just use that letter
797           - if it is a longer name, then put \operatorname{} around it and be
798             mindful of undercores in the name
799         '''
800         func = self._deal_with_super_sub(func)
801         if func in accepted_latex_functions:
802             name = r"\%s" % func
803         elif len(func) == 1 or func.startswith('\\'):
804             name = func
805         else:
806             name = r"\operatorname{%s}" % func
807         return name
808 
809     def _print_Function(self, expr, exp=None):
810         r'''
811         Render functions to LaTeX, handling functions that LaTeX knows about
812         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
813         For single-letter function names, render them as regular LaTeX math
814         symbols. For multi-letter function names that LaTeX does not know
815         about, (e.g., Li, sech) use \operatorname{} so that the function name
816         is rendered in Roman font and LaTeX handles spacing properly.
817 
818         expr is the expression involving the function
819         exp is an exponent
820         '''
821         func = expr.func.__name__
822         if hasattr(self, '_print_' + func) and \
823                 not isinstance(expr, AppliedUndef):
824             return getattr(self, '_print_' + func)(expr, exp)
825         else:
826             args = [str(self._print(arg)) for arg in expr.args]
827             # How inverse trig functions should be displayed, formats are:
828             # abbreviated: asin, full: arcsin, power: sin^-1
829             inv_trig_style = self._settings['inv_trig_style']
830             # If we are dealing with a power-style inverse trig function
831             inv_trig_power_case = False
832             # If it is applicable to fold the argument brackets
833             can_fold_brackets = self._settings['fold_func_brackets'] and \
834                 len(args) == 1 and \
835                 not self._needs_function_brackets(expr.args[0])
836 
837             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
838 
839             # If the function is an inverse trig function, handle the style
840             if func in inv_trig_table:
841                 if inv_trig_style == "abbreviated":
842                     pass
843                 elif inv_trig_style == "full":
844                     func = "arc" + func[1:]
845                 elif inv_trig_style == "power":
846                     func = func[1:]
847                     inv_trig_power_case = True
848 
849                     # Can never fold brackets if we're raised to a power
850                     if exp is not None:
851                         can_fold_brackets = False
852 
853             if inv_trig_power_case:
854                 if func in accepted_latex_functions:
855                     name = r"\%s^{-1}" % func
856                 else:
857                     name = r"\operatorname{%s}^{-1}" % func
858             elif exp is not None:
859                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
860             else:
861                 name = self._hprint_Function(func)
862 
863             if can_fold_brackets:
864                 if func in accepted_latex_functions:
865                     # Wrap argument safely to avoid parse-time conflicts
866                     # with the function name itself
867                     name += r" {%s}"
868                 else:
869                     name += r"%s"
870             else:
871                 name += r"{\left(%s \right)}"
872 
873             if inv_trig_power_case and exp is not None:
874                 name += r"^{%s}" % exp
875 
876             return name % ",".join(args)
877 
878     def _print_UndefinedFunction(self, expr):
879         return self._hprint_Function(str(expr))
880 
881     def _print_ElementwiseApplyFunction(self, expr):
882         return r"{%s}_{\circ}\left({%s}\right)" % (
883             self._print(expr.function),
884             self._print(expr.expr),
885         )
886 
887     @property
888     def _special_function_classes(self):
889         from sympy.functions.special.tensor_functions import KroneckerDelta
890         from sympy.functions.special.gamma_functions import gamma, lowergamma
891         from sympy.functions.special.beta_functions import beta
892         from sympy.functions.special.delta_functions import DiracDelta
893         from sympy.functions.special.error_functions import Chi
894         return {KroneckerDelta: r'\delta',
895                 gamma:  r'\Gamma',
896                 lowergamma: r'\gamma',
897                 beta: r'\operatorname{B}',
898                 DiracDelta: r'\delta',
899                 Chi: r'\operatorname{Chi}'}
900 
901     def _print_FunctionClass(self, expr):
902         for cls in self._special_function_classes:
903             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
904                 return self._special_function_classes[cls]
905         return self._hprint_Function(str(expr))
906 
907     def _print_Lambda(self, expr):
908         symbols, expr = expr.args
909 
910         if len(symbols) == 1:
911             symbols = self._print(symbols[0])
912         else:
913             symbols = self._print(tuple(symbols))
914 
915         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
916 
917         return tex
918 
919     def _hprint_variadic_function(self, expr, exp=None):
920         args = sorted(expr.args, key=default_sort_key)
921         texargs = [r"%s" % self._print(symbol) for symbol in args]
922         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()),
923                                        ", ".join(texargs))
924         if exp is not None:
925             return r"%s^{%s}" % (tex, exp)
926         else:
927             return tex
928 
929     _print_Min = _print_Max = _hprint_variadic_function
930 
931     def _print_floor(self, expr, exp=None):
932         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_ceiling(self, expr, exp=None):
940         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
941 
942         if exp is not None:
943             return r"%s^{%s}" % (tex, exp)
944         else:
945             return tex
946 
947     def _print_log(self, expr, exp=None):
948         if not self._settings["ln_notation"]:
949             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
950         else:
951             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
952 
953         if exp is not None:
954             return r"%s^{%s}" % (tex, exp)
955         else:
956             return tex
957 
958     def _print_Abs(self, expr, exp=None):
959         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
960 
961         if exp is not None:
962             return r"%s^{%s}" % (tex, exp)
963         else:
964             return tex
965     _print_Determinant = _print_Abs
966 
967     def _print_re(self, expr, exp=None):
968         if self._settings['gothic_re_im']:
969             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
970         else:
971             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
972 
973         return self._do_exponent(tex, exp)
974 
975     def _print_im(self, expr, exp=None):
976         if self._settings['gothic_re_im']:
977             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
978         else:
979             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
980 
981         return self._do_exponent(tex, exp)
982 
983     def _print_Not(self, e):
984         from sympy import Equivalent, Implies
985         if isinstance(e.args[0], Equivalent):
986             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
987         if isinstance(e.args[0], Implies):
988             return self._print_Implies(e.args[0], r"\not\Rightarrow")
989         if (e.args[0].is_Boolean):
990             return r"\neg \left(%s\right)" % self._print(e.args[0])
991         else:
992             return r"\neg %s" % self._print(e.args[0])
993 
994     def _print_LogOp(self, args, char):
995         arg = args[0]
996         if arg.is_Boolean and not arg.is_Not:
997             tex = r"\left(%s\right)" % self._print(arg)
998         else:
999             tex = r"%s" % self._print(arg)
1000 
1001         for arg in args[1:]:
1002             if arg.is_Boolean and not arg.is_Not:
1003                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1004             else:
1005                 tex += r" %s %s" % (char, self._print(arg))
1006 
1007         return tex
1008 
1009     def _print_And(self, e):
1010         args = sorted(e.args, key=default_sort_key)
1011         return self._print_LogOp(args, r"\wedge")
1012 
1013     def _print_Or(self, e):
1014         args = sorted(e.args, key=default_sort_key)
1015         return self._print_LogOp(args, r"\vee")
1016 
1017     def _print_Xor(self, e):
1018         args = sorted(e.args, key=default_sort_key)
1019         return self._print_LogOp(args, r"\veebar")
1020 
1021     def _print_Implies(self, e, altchar=None):
1022         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1023 
1024     def _print_Equivalent(self, e, altchar=None):
1025         args = sorted(e.args, key=default_sort_key)
1026         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1027 
1028     def _print_conjugate(self, expr, exp=None):
1029         tex = r"\overline{%s}" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"%s^{%s}" % (tex, exp)
1033         else:
1034             return tex
1035 
1036     def _print_polar_lift(self, expr, exp=None):
1037         func = r"\operatorname{polar\_lift}"
1038         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"%s^{%s}%s" % (func, exp, arg)
1042         else:
1043             return r"%s%s" % (func, arg)
1044 
1045     def _print_ExpBase(self, expr, exp=None):
1046         # TODO should exp_polar be printed differently?
1047         #      what about exp_polar(0), exp_polar(1)?
1048         tex = r"e^{%s}" % self._print(expr.args[0])
1049         return self._do_exponent(tex, exp)
1050 
1051     def _print_elliptic_k(self, expr, exp=None):
1052         tex = r"\left(%s\right)" % self._print(expr.args[0])
1053         if exp is not None:
1054             return r"K^{%s}%s" % (exp, tex)
1055         else:
1056             return r"K%s" % tex
1057 
1058     def _print_elliptic_f(self, expr, exp=None):
1059         tex = r"\left(%s\middle| %s\right)" % \
1060             (self._print(expr.args[0]), self._print(expr.args[1]))
1061         if exp is not None:
1062             return r"F^{%s}%s" % (exp, tex)
1063         else:
1064             return r"F%s" % tex
1065 
1066     def _print_elliptic_e(self, expr, exp=None):
1067         if len(expr.args) == 2:
1068             tex = r"\left(%s\middle| %s\right)" % \
1069                 (self._print(expr.args[0]), self._print(expr.args[1]))
1070         else:
1071             tex = r"\left(%s\right)" % self._print(expr.args[0])
1072         if exp is not None:
1073             return r"E^{%s}%s" % (exp, tex)
1074         else:
1075             return r"E%s" % tex
1076 
1077     def _print_elliptic_pi(self, expr, exp=None):
1078         if len(expr.args) == 3:
1079             tex = r"\left(%s; %s\middle| %s\right)" % \
1080                 (self._print(expr.args[0]), self._print(expr.args[1]),
1081                  self._print(expr.args[2]))
1082         else:
1083             tex = r"\left(%s\middle| %s\right)" % \
1084                 (self._print(expr.args[0]), self._print(expr.args[1]))
1085         if exp is not None:
1086             return r"\Pi^{%s}%s" % (exp, tex)
1087         else:
1088             return r"\Pi%s" % tex
1089 
1090     def _print_beta(self, expr, exp=None):
1091         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1092                                         self._print(expr.args[1]))
1093 
1094         if exp is not None:
1095             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1096         else:
1097             return r"\operatorname{B}%s" % tex
1098 
1099     def _print_uppergamma(self, expr, exp=None):
1100         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1101                                         self._print(expr.args[1]))
1102 
1103         if exp is not None:
1104             return r"\Gamma^{%s}%s" % (exp, tex)
1105         else:
1106             return r"\Gamma%s" % tex
1107 
1108     def _print_lowergamma(self, expr, exp=None):
1109         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1110                                         self._print(expr.args[1]))
1111 
1112         if exp is not None:
1113             return r"\gamma^{%s}%s" % (exp, tex)
1114         else:
1115             return r"\gamma%s" % tex
1116 
1117     def _hprint_one_arg_func(self, expr, exp=None):
1118         tex = r"\left(%s\right)" % self._print(expr.args[0])
1119 
1120         if exp is not None:
1121             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1122         else:
1123             return r"%s%s" % (self._print(expr.func), tex)
1124 
1125     _print_gamma = _hprint_one_arg_func
1126 
1127     def _print_Chi(self, expr, exp=None):
1128         tex = r"\left(%s\right)" % self._print(expr.args[0])
1129 
1130         if exp is not None:
1131             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1132         else:
1133             return r"\operatorname{Chi}%s" % tex
1134 
1135     def _print_expint(self, expr, exp=None):
1136         tex = r"\left(%s\right)" % self._print(expr.args[1])
1137         nu = self._print(expr.args[0])
1138 
1139         if exp is not None:
1140             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1141         else:
1142             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1143 
1144     def _print_fresnels(self, expr, exp=None):
1145         tex = r"\left(%s\right)" % self._print(expr.args[0])
1146 
1147         if exp is not None:
1148             return r"S^{%s}%s" % (exp, tex)
1149         else:
1150             return r"S%s" % tex
1151 
1152     def _print_fresnelc(self, expr, exp=None):
1153         tex = r"\left(%s\right)" % self._print(expr.args[0])
1154 
1155         if exp is not None:
1156             return r"C^{%s}%s" % (exp, tex)
1157         else:
1158             return r"C%s" % tex
1159 
1160     def _print_subfactorial(self, expr, exp=None):
1161         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1162 
1163         if exp is not None:
1164             return r"\left(%s\right)^{%s}" % (tex, exp)
1165         else:
1166             return tex
1167 
1168     def _print_factorial(self, expr, exp=None):
1169         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1170 
1171         if exp is not None:
1172             return r"%s^{%s}" % (tex, exp)
1173         else:
1174             return tex
1175 
1176     def _print_factorial2(self, expr, exp=None):
1177         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1178 
1179         if exp is not None:
1180             return r"%s^{%s}" % (tex, exp)
1181         else:
1182             return tex
1183 
1184     def _print_binomial(self, expr, exp=None):
1185         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1186                                      self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"%s^{%s}" % (tex, exp)
1190         else:
1191             return tex
1192 
1193     def _print_RisingFactorial(self, expr, exp=None):
1194         n, k = expr.args
1195         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1196 
1197         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1198 
1199         return self._do_exponent(tex, exp)
1200 
1201     def _print_FallingFactorial(self, expr, exp=None):
1202         n, k = expr.args
1203         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1204 
1205         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1206 
1207         return self._do_exponent(tex, exp)
1208 
1209     def _hprint_BesselBase(self, expr, exp, sym):
1210         tex = r"%s" % (sym)
1211 
1212         need_exp = False
1213         if exp is not None:
1214             if tex.find('^') == -1:
1215                 tex = r"%s^{%s}" % (tex, self._print(exp))
1216             else:
1217                 need_exp = True
1218 
1219         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1220                                            self._print(expr.argument))
1221 
1222         if need_exp:
1223             tex = self._do_exponent(tex, exp)
1224         return tex
1225 
1226     def _hprint_vec(self, vec):
1227         if not vec:
1228             return ""
1229         s = ""
1230         for i in vec[:-1]:
1231             s += "%s, " % self._print(i)
1232         s += self._print(vec[-1])
1233         return s
1234 
1235     def _print_besselj(self, expr, exp=None):
1236         return self._hprint_BesselBase(expr, exp, 'J')
1237 
1238     def _print_besseli(self, expr, exp=None):
1239         return self._hprint_BesselBase(expr, exp, 'I')
1240 
1241     def _print_besselk(self, expr, exp=None):
1242         return self._hprint_BesselBase(expr, exp, 'K')
1243 
1244     def _print_bessely(self, expr, exp=None):
1245         return self._hprint_BesselBase(expr, exp, 'Y')
1246 
1247     def _print_yn(self, expr, exp=None):
1248         return self._hprint_BesselBase(expr, exp, 'y')
1249 
1250     def _print_jn(self, expr, exp=None):
1251         return self._hprint_BesselBase(expr, exp, 'j')
1252 
1253     def _print_hankel1(self, expr, exp=None):
1254         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1255 
1256     def _print_hankel2(self, expr, exp=None):
1257         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1258 
1259     def _print_hn1(self, expr, exp=None):
1260         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1261 
1262     def _print_hn2(self, expr, exp=None):
1263         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1264 
1265     def _hprint_airy(self, expr, exp=None, notation=""):
1266         tex = r"\left(%s\right)" % self._print(expr.args[0])
1267 
1268         if exp is not None:
1269             return r"%s^{%s}%s" % (notation, exp, tex)
1270         else:
1271             return r"%s%s" % (notation, tex)
1272 
1273     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1274         tex = r"\left(%s\right)" % self._print(expr.args[0])
1275 
1276         if exp is not None:
1277             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1278         else:
1279             return r"%s^\prime%s" % (notation, tex)
1280 
1281     def _print_airyai(self, expr, exp=None):
1282         return self._hprint_airy(expr, exp, 'Ai')
1283 
1284     def _print_airybi(self, expr, exp=None):
1285         return self._hprint_airy(expr, exp, 'Bi')
1286 
1287     def _print_airyaiprime(self, expr, exp=None):
1288         return self._hprint_airy_prime(expr, exp, 'Ai')
1289 
1290     def _print_airybiprime(self, expr, exp=None):
1291         return self._hprint_airy_prime(expr, exp, 'Bi')
1292 
1293     def _print_hyper(self, expr, exp=None):
1294         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1295               r"\middle| {%s} \right)}" % \
1296             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1297               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1298               self._print(expr.argument))
1299 
1300         if exp is not None:
1301             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1302         return tex
1303 
1304     def _print_meijerg(self, expr, exp=None):
1305         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1306               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1307             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1308               self._print(len(expr.bm)), self._print(len(expr.an)),
1309               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1310               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1311               self._print(expr.argument))
1312 
1313         if exp is not None:
1314             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1315         return tex
1316 
1317     def _print_dirichlet_eta(self, expr, exp=None):
1318         tex = r"\left(%s\right)" % self._print(expr.args[0])
1319         if exp is not None:
1320             return r"\eta^{%s}%s" % (self._print(exp), tex)
1321         return r"\eta%s" % tex
1322 
1323     def _print_zeta(self, expr, exp=None):
1324         if len(expr.args) == 2:
1325             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1326         else:
1327             tex = r"\left(%s\right)" % self._print(expr.args[0])
1328         if exp is not None:
1329             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1330         return r"\zeta%s" % tex
1331 
1332     def _print_stieltjes(self, expr, exp=None):
1333         if len(expr.args) == 2:
1334             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1335         else:
1336             tex = r"_{%s}" % self._print(expr.args[0])
1337         if exp is not None:
1338             return r"\gamma%s^{%s}" % (tex, self._print(exp))
1339         return r"\gamma%s" % tex
1340 
1341     def _print_lerchphi(self, expr, exp=None):
1342         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1343         if exp is None:
1344             return r"\Phi%s" % tex
1345         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1346 
1347     def _print_polylog(self, expr, exp=None):
1348         s, z = map(self._print, expr.args)
1349         tex = r"\left(%s\right)" % z
1350         if exp is None:
1351             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1352         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1353 
1354     def _print_jacobi(self, expr, exp=None):
1355         n, a, b, x = map(self._print, expr.args)
1356         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1357         if exp is not None:
1358             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1359         return tex
1360 
1361     def _print_gegenbauer(self, expr, exp=None):
1362         n, a, x = map(self._print, expr.args)
1363         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1364         if exp is not None:
1365             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1366         return tex
1367 
1368     def _print_chebyshevt(self, expr, exp=None):
1369         n, x = map(self._print, expr.args)
1370         tex = r"T_{%s}\left(%s\right)" % (n, x)
1371         if exp is not None:
1372             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1373         return tex
1374 
1375     def _print_chebyshevu(self, expr, exp=None):
1376         n, x = map(self._print, expr.args)
1377         tex = r"U_{%s}\left(%s\right)" % (n, x)
1378         if exp is not None:
1379             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1380         return tex
1381 
1382     def _print_legendre(self, expr, exp=None):
1383         n, x = map(self._print, expr.args)
1384         tex = r"P_{%s}\left(%s\right)" % (n, x)
1385         if exp is not None:
1386             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1387         return tex
1388 
1389     def _print_assoc_legendre(self, expr, exp=None):
1390         n, a, x = map(self._print, expr.args)
1391         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1392         if exp is not None:
1393             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1394         return tex
1395 
1396     def _print_hermite(self, expr, exp=None):
1397         n, x = map(self._print, expr.args)
1398         tex = r"H_{%s}\left(%s\right)" % (n, x)
1399         if exp is not None:
1400             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1401         return tex
1402 
1403     def _print_laguerre(self, expr, exp=None):
1404         n, x = map(self._print, expr.args)
1405         tex = r"L_{%s}\left(%s\right)" % (n, x)
1406         if exp is not None:
1407             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1408         return tex
1409 
1410     def _print_assoc_laguerre(self, expr, exp=None):
1411         n, a, x = map(self._print, expr.args)
1412         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1413         if exp is not None:
1414             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1415         return tex
1416 
1417     def _print_Ynm(self, expr, exp=None):
1418         n, m, theta, phi = map(self._print, expr.args)
1419         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1420         if exp is not None:
1421             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1422         return tex
1423 
1424     def _print_Znm(self, expr, exp=None):
1425         n, m, theta, phi = map(self._print, expr.args)
1426         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1427         if exp is not None:
1428             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1429         return tex
1430 
1431     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1432         a, q, z = map(self._print, args)
1433         sup = r"^{\prime}" if prime else ""
1434         exp = "" if not exp else "^{%s}" % self._print(exp)
1435         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1436 
1437     def _print_mathieuc(self, expr, exp=None):
1438         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1439 
1440     def _print_mathieus(self, expr, exp=None):
1441         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1442 
1443     def _print_mathieucprime(self, expr, exp=None):
1444         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1445 
1446     def _print_mathieusprime(self, expr, exp=None):
1447         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1448 
1449     def _print_Rational(self, expr):
1450         if expr.q != 1:
1451             sign = ""
1452             p = expr.p
1453             if expr.p < 0:
1454                 sign = "- "
1455                 p = -p
1456             if self._settings['fold_short_frac']:
1457                 return r"%s%d / %d" % (sign, p, expr.q)
1458             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1459         else:
1460             return self._print(expr.p)
1461 
1462     def _print_Order(self, expr):
1463         s = self._print(expr.expr)
1464         if expr.point and any(p != S.Zero for p in expr.point) or \
1465            len(expr.variables) > 1:
1466             s += '; '
1467             if len(expr.variables) > 1:
1468                 s += self._print(expr.variables)
1469             elif expr.variables:
1470                 s += self._print(expr.variables[0])
1471             s += r'\rightarrow '
1472             if len(expr.point) > 1:
1473                 s += self._print(expr.point)
1474             else:
1475                 s += self._print(expr.point[0])
1476         return r"O\left(%s\right)" % s
1477 
1478     def _print_Symbol(self, expr, style='plain'):
1479         if expr in self._settings['symbol_names']:
1480             return self._settings['symbol_names'][expr]
1481 
1482         result = self._deal_with_super_sub(expr.name) if \
1483             '\\' not in expr.name else expr.name
1484 
1485         if style == 'bold':
1486             result = r"\mathbf{{{}}}".format(result)
1487 
1488         return result
1489 
1490     _print_RandomSymbol = _print_Symbol
1491 
1492     def _deal_with_super_sub(self, string):
1493         if '{' in string:
1494             return string
1495 
1496         name, supers, subs = split_super_sub(string)
1497 
1498         name = translate(name)
1499         supers = [translate(sup) for sup in supers]
1500         subs = [translate(sub) for sub in subs]
1501 
1502         # glue all items together:
1503         if supers:
1504             name += "^{%s}" % " ".join(supers)
1505         if subs:
1506             name += "_{%s}" % " ".join(subs)
1507 
1508         return name
1509 
1510     def _print_Relational(self, expr):
1511         if self._settings['itex']:
1512             gt = r"\gt"
1513             lt = r"\lt"
1514         else:
1515             gt = ">"
1516             lt = "<"
1517 
1518         charmap = {
1519             "==": "=",
1520             ">": gt,
1521             "<": lt,
1522             ">=": r"\geq",
1523             "<=": r"\leq",
1524             "!=": r"\neq",
1525         }
1526 
1527         return "%s %s %s" % (self._print(expr.lhs),
1528                              charmap[expr.rel_op], self._print(expr.rhs))
1529 
1530     def _print_Piecewise(self, expr):
1531         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1532                    for e, c in expr.args[:-1]]
1533         if expr.args[-1].cond == true:
1534             ecpairs.append(r"%s & \text{otherwise}" %
1535                            self._print(expr.args[-1].expr))
1536         else:
1537             ecpairs.append(r"%s & \text{for}\: %s" %
1538                            (self._print(expr.args[-1].expr),
1539                             self._print(expr.args[-1].cond)))
1540         tex = r"\begin{cases} %s \end{cases}"
1541         return tex % r" \\".join(ecpairs)
1542 
1543     def _print_MatrixBase(self, expr):
1544         lines = []
1545 
1546         for line in range(expr.rows):  # horrible, should be 'rows'
1547             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1548 
1549         mat_str = self._settings['mat_str']
1550         if mat_str is None:
1551             if self._settings['mode'] == 'inline':
1552                 mat_str = 'smallmatrix'
1553             else:
1554                 if (expr.cols <= 10) is True:
1555                     mat_str = 'matrix'
1556                 else:
1557                     mat_str = 'array'
1558 
1559         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1560         out_str = out_str.replace('%MATSTR%', mat_str)
1561         if mat_str == 'array':
1562             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1563         if self._settings['mat_delim']:
1564             left_delim = self._settings['mat_delim']
1565             right_delim = self._delim_dict[left_delim]
1566             out_str = r'\left' + left_delim + out_str + \
1567                       r'\right' + right_delim
1568         return out_str % r"\\".join(lines)
1569     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1570                            = _print_Matrix \
1571                            = _print_MatrixBase
1572 
1573     def _print_MatrixElement(self, expr):
1574         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1575             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1576 
1577     def _print_MatrixSlice(self, expr):
1578         def latexslice(x):
1579             x = list(x)
1580             if x[2] == 1:
1581                 del x[2]
1582             if x[1] == x[0] + 1:
1583                 del x[1]
1584             if x[0] == 0:
1585                 x[0] = ''
1586             return ':'.join(map(self._print, x))
1587         return (self._print(expr.parent) + r'\left[' +
1588                 latexslice(expr.rowslice) + ', ' +
1589                 latexslice(expr.colslice) + r'\right]')
1590 
1591     def _print_BlockMatrix(self, expr):
1592         return self._print(expr.blocks)
1593 
1594     def _print_Transpose(self, expr):
1595         mat = expr.arg
1596         from sympy.matrices import MatrixSymbol
1597         if not isinstance(mat, MatrixSymbol):
1598             return r"\left(%s\right)^{T}" % self._print(mat)
1599         else:
1600             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1601 
1602     def _print_Trace(self, expr):
1603         mat = expr.arg
1604         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1605 
1606     def _print_Adjoint(self, expr):
1607         mat = expr.arg
1608         from sympy.matrices import MatrixSymbol
1609         if not isinstance(mat, MatrixSymbol):
1610             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1611         else:
1612             return r"%s^{\dagger}" % self._print(mat)
1613 
1614     def _print_MatMul(self, expr):
1615         from sympy import MatMul, Mul
1616 
1617         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1618                                              False)
1619 
1620         args = expr.args
1621         if isinstance(args[0], Mul):
1622             args = args[0].as_ordered_factors() + list(args[1:])
1623         else:
1624             args = list(args)
1625 
1626         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1627             if args[0] == -1:
1628                 args = args[1:]
1629             else:
1630                 args[0] = -args[0]
1631             return '- ' + ' '.join(map(parens, args))
1632         else:
1633             return ' '.join(map(parens, args))
1634 
1635     def _print_Mod(self, expr, exp=None):
1636         if exp is not None:
1637             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1638                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1639                                    strict=True), self._print(expr.args[1]),
1640                  self._print(exp))
1641         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1642                                  PRECEDENCE['Mul'], strict=True),
1643                                  self._print(expr.args[1]))
1644 
1645     def _print_HadamardProduct(self, expr):
1646         args = expr.args
1647         prec = PRECEDENCE['Pow']
1648         parens = self.parenthesize
1649 
1650         return r' \circ '.join(
1651             map(lambda arg: parens(arg, prec, strict=True), args))
1652 
1653     def _print_HadamardPower(self, expr):
1654         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1655             template = r"%s^{\circ \left({%s}\right)}"
1656         else:
1657             template = r"%s^{\circ {%s}}"
1658         return self._helper_print_standard_power(expr, template)
1659 
1660     def _print_KroneckerProduct(self, expr):
1661         args = expr.args
1662         prec = PRECEDENCE['Pow']
1663         parens = self.parenthesize
1664 
1665         return r' \otimes '.join(
1666             map(lambda arg: parens(arg, prec, strict=True), args))
1667 
1668     def _print_MatPow(self, expr):
1669         base, exp = expr.base, expr.exp
1670         from sympy.matrices import MatrixSymbol
1671         if not isinstance(base, MatrixSymbol):
1672             return "\\left(%s\\right)^{%s}" % (self._print(base),
1673                                               self._print(exp))
1674         else:
1675             return "%s^{%s}" % (self._print(base), self._print(exp))
1676 
1677     def _print_MatrixSymbol(self, expr):
1678         return self._print_Symbol(expr, style=self._settings[
1679             'mat_symbol_style'])
1680 
1681     def _print_ZeroMatrix(self, Z):
1682         return r"\mathbb{0}" if self._settings[
1683             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1684 
1685     def _print_OneMatrix(self, O):
1686         return r"\mathbb{1}" if self._settings[
1687             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1688 
1689     def _print_Identity(self, I):
1690         return r"\mathbb{I}" if self._settings[
1691             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1692 
1693     def _print_PermutationMatrix(self, P):
1694         perm_str = self._print(P.args[0])
1695         return "P_{%s}" % perm_str
1696 
1697     def _print_NDimArray(self, expr):
1698 
1699         if expr.rank() == 0:
1700             return self._print(expr[()])
1701 
1702         mat_str = self._settings['mat_str']
1703         if mat_str is None:
1704             if self._settings['mode'] == 'inline':
1705                 mat_str = 'smallmatrix'
1706             else:
1707                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1708                     mat_str = 'matrix'
1709                 else:
1710                     mat_str = 'array'
1711         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1712         block_str = block_str.replace('%MATSTR%', mat_str)
1713         if self._settings['mat_delim']:
1714             left_delim = self._settings['mat_delim']
1715             right_delim = self._delim_dict[left_delim]
1716             block_str = r'\left' + left_delim + block_str + \
1717                         r'\right' + right_delim
1718 
1719         if expr.rank() == 0:
1720             return block_str % ""
1721 
1722         level_str = [[]] + [[] for i in range(expr.rank())]
1723         shape_ranges = [list(range(i)) for i in expr.shape]
1724         for outer_i in itertools.product(*shape_ranges):
1725             level_str[-1].append(self._print(expr[outer_i]))
1726             even = True
1727             for back_outer_i in range(expr.rank()-1, -1, -1):
1728                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1729                     break
1730                 if even:
1731                     level_str[back_outer_i].append(
1732                         r" & ".join(level_str[back_outer_i+1]))
1733                 else:
1734                     level_str[back_outer_i].append(
1735                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1736                     if len(level_str[back_outer_i+1]) == 1:
1737                         level_str[back_outer_i][-1] = r"\left[" + \
1738                             level_str[back_outer_i][-1] + r"\right]"
1739                 even = not even
1740                 level_str[back_outer_i+1] = []
1741 
1742         out_str = level_str[0][0]
1743 
1744         if expr.rank() % 2 == 1:
1745             out_str = block_str % out_str
1746 
1747         return out_str
1748 
1749     _print_ImmutableDenseNDimArray = _print_NDimArray
1750     _print_ImmutableSparseNDimArray = _print_NDimArray
1751     _print_MutableDenseNDimArray = _print_NDimArray
1752     _print_MutableSparseNDimArray = _print_NDimArray
1753 
1754     def _printer_tensor_indices(self, name, indices, index_map={}):
1755         out_str = self._print(name)
1756         last_valence = None
1757         prev_map = None
1758         for index in indices:
1759             new_valence = index.is_up
1760             if ((index in index_map) or prev_map) and \
1761                     last_valence == new_valence:
1762                 out_str += ","
1763             if last_valence != new_valence:
1764                 if last_valence is not None:
1765                     out_str += "}"
1766                 if index.is_up:
1767                     out_str += "{}^{"
1768                 else:
1769                     out_str += "{}_{"
1770             out_str += self._print(index.args[0])
1771             if index in index_map:
1772                 out_str += "="
1773                 out_str += self._print(index_map[index])
1774                 prev_map = True
1775             else:
1776                 prev_map = False
1777             last_valence = new_valence
1778         if last_valence is not None:
1779             out_str += "}"
1780         return out_str
1781 
1782     def _print_Tensor(self, expr):
1783         name = expr.args[0].args[0]
1784         indices = expr.get_indices()
1785         return self._printer_tensor_indices(name, indices)
1786 
1787     def _print_TensorElement(self, expr):
1788         name = expr.expr.args[0].args[0]
1789         indices = expr.expr.get_indices()
1790         index_map = expr.index_map
1791         return self._printer_tensor_indices(name, indices, index_map)
1792 
1793     def _print_TensMul(self, expr):
1794         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1795         sign, args = expr._get_args_for_traditional_printer()
1796         return sign + "".join(
1797             [self.parenthesize(arg, precedence(expr)) for arg in args]
1798         )
1799 
1800     def _print_TensAdd(self, expr):
1801         a = []
1802         args = expr.args
1803         for x in args:
1804             a.append(self.parenthesize(x, precedence(expr)))
1805         a.sort()
1806         s = ' + '.join(a)
1807         s = s.replace('+ -', '- ')
1808         return s
1809 
1810     def _print_TensorIndex(self, expr):
1811         return "{}%s{%s}" % (
1812             "^" if expr.is_up else "_",
1813             self._print(expr.args[0])
1814         )
1815 
1816     def _print_PartialDerivative(self, expr):
1817         if len(expr.variables) == 1:
1818             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1819                 self._print(expr.variables[0]),
1820                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1821             )
1822         else:
1823             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1824                 len(expr.variables),
1825                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1826                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1827             )
1828 
1829     def _print_UniversalSet(self, expr):
1830         return r"\mathbb{U}"
1831 
1832     def _print_frac(self, expr, exp=None):
1833         if exp is None:
1834             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1835         else:
1836             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1837                     self._print(expr.args[0]), self._print(exp))
1838 
1839     def _print_tuple(self, expr):
1840         if self._settings['decimal_separator'] =='comma':
1841             return r"\left( %s\right)" % \
1842                 r"; \  ".join([self._print(i) for i in expr])
1843         elif self._settings['decimal_separator'] =='period':
1844             return r"\left( %s\right)" % \
1845                 r", \  ".join([self._print(i) for i in expr])
1846         else:
1847             raise ValueError('Unknown Decimal Separator')
1848 
1849     def _print_TensorProduct(self, expr):
1850         elements = [self._print(a) for a in expr.args]
1851         return r' \otimes '.join(elements)
1852 
1853     def _print_WedgeProduct(self, expr):
1854         elements = [self._print(a) for a in expr.args]
1855         return r' \wedge '.join(elements)
1856 
1857     def _print_Tuple(self, expr):
1858         return self._print_tuple(expr)
1859 
1860     def _print_list(self, expr):
1861         if self._settings['decimal_separator'] == 'comma':
1862             return r"\left[ %s\right]" % \
1863                 r"; \  ".join([self._print(i) for i in expr])
1864         elif self._settings['decimal_separator'] == 'period':
1865             return r"\left[ %s\right]" % \
1866                 r", \  ".join([self._print(i) for i in expr])
1867         else:
1868             raise ValueError('Unknown Decimal Separator')
1869 
1870 
1871     def _print_dict(self, d):
1872         keys = sorted(d.keys(), key=default_sort_key)
1873         items = []
1874 
1875         for key in keys:
1876             val = d[key]
1877             items.append("%s : %s" % (self._print(key), self._print(val)))
1878 
1879         return r"\left\{ %s\right\}" % r", \  ".join(items)
1880 
1881     def _print_Dict(self, expr):
1882         return self._print_dict(expr)
1883 
1884     def _print_DiracDelta(self, expr, exp=None):
1885         if len(expr.args) == 1 or expr.args[1] == 0:
1886             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1887         else:
1888             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1889                 self._print(expr.args[1]), self._print(expr.args[0]))
1890         if exp:
1891             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1892         return tex
1893 
1894     def _print_SingularityFunction(self, expr):
1895         shift = self._print(expr.args[0] - expr.args[1])
1896         power = self._print(expr.args[2])
1897         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1898         return tex
1899 
1900     def _print_Heaviside(self, expr, exp=None):
1901         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1902         if exp:
1903             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1904         return tex
1905 
1906     def _print_KroneckerDelta(self, expr, exp=None):
1907         i = self._print(expr.args[0])
1908         j = self._print(expr.args[1])
1909         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1910             tex = r'\delta_{%s %s}' % (i, j)
1911         else:
1912             tex = r'\delta_{%s, %s}' % (i, j)
1913         if exp is not None:
1914             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1915         return tex
1916 
1917     def _print_LeviCivita(self, expr, exp=None):
1918         indices = map(self._print, expr.args)
1919         if all(x.is_Atom for x in expr.args):
1920             tex = r'\varepsilon_{%s}' % " ".join(indices)
1921         else:
1922             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1923         if exp:
1924             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1925         return tex
1926 
1927     def _print_RandomDomain(self, d):
1928         if hasattr(d, 'as_boolean'):
1929             return '\\text{Domain: }' + self._print(d.as_boolean())
1930         elif hasattr(d, 'set'):
1931             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1932                     self._print(d.set))
1933         elif hasattr(d, 'symbols'):
1934             return '\\text{Domain on }' + self._print(d.symbols)
1935         else:
1936             return self._print(None)
1937 
1938     def _print_FiniteSet(self, s):
1939         items = sorted(s.args, key=default_sort_key)
1940         return self._print_set(items)
1941 
1942     def _print_set(self, s):
1943         items = sorted(s, key=default_sort_key)
1944         if self._settings['decimal_separator'] == 'comma':
1945             items = "; ".join(map(self._print, items))
1946         elif self._settings['decimal_separator'] == 'period':
1947             items = ", ".join(map(self._print, items))
1948         else:
1949             raise ValueError('Unknown Decimal Separator')
1950         return r"\left\{%s\right\}" % items
1951 
1952 
1953     _print_frozenset = _print_set
1954 
1955     def _print_Range(self, s):
1956         dots = r'\ldots'
1957 
1958         if s.has(Symbol):
1959             return self._print_Basic(s)
1960 
1961         if s.start.is_infinite and s.stop.is_infinite:
1962             if s.step.is_positive:
1963                 printset = dots, -1, 0, 1, dots
1964             else:
1965                 printset = dots, 1, 0, -1, dots
1966         elif s.start.is_infinite:
1967             printset = dots, s[-1] - s.step, s[-1]
1968         elif s.stop.is_infinite:
1969             it = iter(s)
1970             printset = next(it), next(it), dots
1971         elif len(s) > 4:
1972             it = iter(s)
1973             printset = next(it), next(it), dots, s[-1]
1974         else:
1975             printset = tuple(s)
1976 
1977         return (r"\left\{" +
1978                 r", ".join(self._print(el) for el in printset) +
1979                 r"\right\}")
1980 
1981     def __print_number_polynomial(self, expr, letter, exp=None):
1982         if len(expr.args) == 2:
1983             if exp is not None:
1984                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
1985                             self._print(expr.args[0]), self._print(exp),
1986                             self._print(expr.args[1]))
1987             return r"%s_{%s}\left(%s\right)" % (letter,
1988                         self._print(expr.args[0]), self._print(expr.args[1]))
1989 
1990         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
1991         if exp is not None:
1992             tex = r"%s^{%s}" % (tex, self._print(exp))
1993         return tex
1994 
1995     def _print_bernoulli(self, expr, exp=None):
1996         return self.__print_number_polynomial(expr, "B", exp)
1997 
1998     def _print_bell(self, expr, exp=None):
1999         if len(expr.args) == 3:
2000             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2001                                 self._print(expr.args[1]))
2002             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2003                                                el in expr.args[2])
2004             if exp is not None:
2005                 tex = r"%s^{%s}%s" % (tex1, self._print(exp), tex2)
2006             else:
2007                 tex = tex1 + tex2
2008             return tex
2009         return self.__print_number_polynomial(expr, "B", exp)
2010 
2011 
2012     def _print_fibonacci(self, expr, exp=None):
2013         return self.__print_number_polynomial(expr, "F", exp)
2014 
2015     def _print_lucas(self, expr, exp=None):
2016         tex = r"L_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_tribonacci(self, expr, exp=None):
2022         return self.__print_number_polynomial(expr, "T", exp)
2023 
2024     def _print_SeqFormula(self, s):
2025         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2026             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2027                 self._print(s.formula),
2028                 self._print(s.variables[0]),
2029                 self._print(s.start),
2030                 self._print(s.stop)
2031             )
2032         if s.start is S.NegativeInfinity:
2033             stop = s.stop
2034             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
2035                         s.coeff(stop - 1), s.coeff(stop))
2036         elif s.stop is S.Infinity or s.length > 4:
2037             printset = s[:4]
2038             printset.append(r'\ldots')
2039         else:
2040             printset = tuple(s)
2041 
2042         return (r"\left[" +
2043                 r", ".join(self._print(el) for el in printset) +
2044                 r"\right]")
2045 
2046     _print_SeqPer = _print_SeqFormula
2047     _print_SeqAdd = _print_SeqFormula
2048     _print_SeqMul = _print_SeqFormula
2049 
2050     def _print_Interval(self, i):
2051         if i.start == i.end:
2052             return r"\left\{%s\right\}" % self._print(i.start)
2053 
2054         else:
2055             if i.left_open:
2056                 left = '('
2057             else:
2058                 left = '['
2059 
2060             if i.right_open:
2061                 right = ')'
2062             else:
2063                 right = ']'
2064 
2065             return r"\left%s%s, %s\right%s" % \
2066                    (left, self._print(i.start), self._print(i.end), right)
2067 
2068     def _print_AccumulationBounds(self, i):
2069         return r"\left\langle %s, %s\right\rangle" % \
2070                 (self._print(i.min), self._print(i.max))
2071 
2072     def _print_Union(self, u):
2073         prec = precedence_traditional(u)
2074         args_str = [self.parenthesize(i, prec) for i in u.args]
2075         return r" \cup ".join(args_str)
2076 
2077     def _print_Complement(self, u):
2078         prec = precedence_traditional(u)
2079         args_str = [self.parenthesize(i, prec) for i in u.args]
2080         return r" \setminus ".join(args_str)
2081 
2082     def _print_Intersection(self, u):
2083         prec = precedence_traditional(u)
2084         args_str = [self.parenthesize(i, prec) for i in u.args]
2085         return r" \cap ".join(args_str)
2086 
2087     def _print_SymmetricDifference(self, u):
2088         prec = precedence_traditional(u)
2089         args_str = [self.parenthesize(i, prec) for i in u.args]
2090         return r" \triangle ".join(args_str)
2091 
2092     def _print_ProductSet(self, p):
2093         prec = precedence_traditional(p)
2094         if len(p.sets) >= 1 and not has_variety(p.sets):
2095             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2096         return r" \times ".join(
2097             self.parenthesize(set, prec) for set in p.sets)
2098 
2099     def _print_EmptySet(self, e):
2100         return r"\emptyset"
2101 
2102     def _print_Naturals(self, n):
2103         return r"\mathbb{N}"
2104 
2105     def _print_Naturals0(self, n):
2106         return r"\mathbb{N}_0"
2107 
2108     def _print_Integers(self, i):
2109         return r"\mathbb{Z}"
2110 
2111     def _print_Rationals(self, i):
2112         return r"\mathbb{Q}"
2113 
2114     def _print_Reals(self, i):
2115         return r"\mathbb{R}"
2116 
2117     def _print_Complexes(self, i):
2118         return r"\mathbb{C}"
2119 
2120     def _print_ImageSet(self, s):
2121         expr = s.lamda.expr
2122         sig = s.lamda.signature
2123         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2124         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2125         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2126 
2127     def _print_ConditionSet(self, s):
2128         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2129         if s.base_set is S.UniversalSet:
2130             return r"\left\{%s \mid %s \right\}" % \
2131                 (vars_print, self._print(s.condition))
2132 
2133         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2134             vars_print,
2135             vars_print,
2136             self._print(s.base_set),
2137             self._print(s.condition))
2138 
2139     def _print_ComplexRegion(self, s):
2140         vars_print = ', '.join([self._print(var) for var in s.variables])
2141         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2142             self._print(s.expr),
2143             vars_print,
2144             self._print(s.sets))
2145 
2146     def _print_Contains(self, e):
2147         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2148 
2149     def _print_FourierSeries(self, s):
2150         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
2151 
2152     def _print_FormalPowerSeries(self, s):
2153         return self._print_Add(s.infinite)
2154 
2155     def _print_FiniteField(self, expr):
2156         return r"\mathbb{F}_{%s}" % expr.mod
2157 
2158     def _print_IntegerRing(self, expr):
2159         return r"\mathbb{Z}"
2160 
2161     def _print_RationalField(self, expr):
2162         return r"\mathbb{Q}"
2163 
2164     def _print_RealField(self, expr):
2165         return r"\mathbb{R}"
2166 
2167     def _print_ComplexField(self, expr):
2168         return r"\mathbb{C}"
2169 
2170     def _print_PolynomialRing(self, expr):
2171         domain = self._print(expr.domain)
2172         symbols = ", ".join(map(self._print, expr.symbols))
2173         return r"%s\left[%s\right]" % (domain, symbols)
2174 
2175     def _print_FractionField(self, expr):
2176         domain = self._print(expr.domain)
2177         symbols = ", ".join(map(self._print, expr.symbols))
2178         return r"%s\left(%s\right)" % (domain, symbols)
2179 
2180     def _print_PolynomialRingBase(self, expr):
2181         domain = self._print(expr.domain)
2182         symbols = ", ".join(map(self._print, expr.symbols))
2183         inv = ""
2184         if not expr.is_Poly:
2185             inv = r"S_<^{-1}"
2186         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2187 
2188     def _print_Poly(self, poly):
2189         cls = poly.__class__.__name__
2190         terms = []
2191         for monom, coeff in poly.terms():
2192             s_monom = ''
2193             for i, exp in enumerate(monom):
2194                 if exp > 0:
2195                     if exp == 1:
2196                         s_monom += self._print(poly.gens[i])
2197                     else:
2198                         s_monom += self._print(pow(poly.gens[i], exp))
2199 
2200             if coeff.is_Add:
2201                 if s_monom:
2202                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2203                 else:
2204                     s_coeff = self._print(coeff)
2205             else:
2206                 if s_monom:
2207                     if coeff is S.One:
2208                         terms.extend(['+', s_monom])
2209                         continue
2210 
2211                     if coeff is S.NegativeOne:
2212                         terms.extend(['-', s_monom])
2213                         continue
2214 
2215                 s_coeff = self._print(coeff)
2216 
2217             if not s_monom:
2218                 s_term = s_coeff
2219             else:
2220                 s_term = s_coeff + " " + s_monom
2221 
2222             if s_term.startswith('-'):
2223                 terms.extend(['-', s_term[1:]])
2224             else:
2225                 terms.extend(['+', s_term])
2226 
2227         if terms[0] in ['-', '+']:
2228             modifier = terms.pop(0)
2229 
2230             if modifier == '-':
2231                 terms[0] = '-' + terms[0]
2232 
2233         expr = ' '.join(terms)
2234         gens = list(map(self._print, poly.gens))
2235         domain = "domain=%s" % self._print(poly.get_domain())
2236 
2237         args = ", ".join([expr] + gens + [domain])
2238         if cls in accepted_latex_functions:
2239             tex = r"\%s {\left(%s \right)}" % (cls, args)
2240         else:
2241             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2242 
2243         return tex
2244 
2245     def _print_ComplexRootOf(self, root):
2246         cls = root.__class__.__name__
2247         if cls == "ComplexRootOf":
2248             cls = "CRootOf"
2249         expr = self._print(root.expr)
2250         index = root.index
2251         if cls in accepted_latex_functions:
2252             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2253         else:
2254             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2255                                                                  index)
2256 
2257     def _print_RootSum(self, expr):
2258         cls = expr.__class__.__name__
2259         args = [self._print(expr.expr)]
2260 
2261         if expr.fun is not S.IdentityFunction:
2262             args.append(self._print(expr.fun))
2263 
2264         if cls in accepted_latex_functions:
2265             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2266         else:
2267             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2268                                                              ", ".join(args))
2269 
2270     def _print_PolyElement(self, poly):
2271         mul_symbol = self._settings['mul_symbol_latex']
2272         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2273 
2274     def _print_FracElement(self, frac):
2275         if frac.denom == 1:
2276             return self._print(frac.numer)
2277         else:
2278             numer = self._print(frac.numer)
2279             denom = self._print(frac.denom)
2280             return r"\frac{%s}{%s}" % (numer, denom)
2281 
2282     def _print_euler(self, expr, exp=None):
2283         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2284         tex = r"E_{%s}" % self._print(m)
2285         if exp is not None:
2286             tex = r"%s^{%s}" % (tex, self._print(exp))
2287         if x is not None:
2288             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2289         return tex
2290 
2291     def _print_catalan(self, expr, exp=None):
2292         tex = r"C_{%s}" % self._print(expr.args[0])
2293         if exp is not None:
2294             tex = r"%s^{%s}" % (tex, self._print(exp))
2295         return tex
2296 
2297     def _print_UnifiedTransform(self, expr, s, inverse=False):
2298         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2299 
2300     def _print_MellinTransform(self, expr):
2301         return self._print_UnifiedTransform(expr, 'M')
2302 
2303     def _print_InverseMellinTransform(self, expr):
2304         return self._print_UnifiedTransform(expr, 'M', True)
2305 
2306     def _print_LaplaceTransform(self, expr):
2307         return self._print_UnifiedTransform(expr, 'L')
2308 
2309     def _print_InverseLaplaceTransform(self, expr):
2310         return self._print_UnifiedTransform(expr, 'L', True)
2311 
2312     def _print_FourierTransform(self, expr):
2313         return self._print_UnifiedTransform(expr, 'F')
2314 
2315     def _print_InverseFourierTransform(self, expr):
2316         return self._print_UnifiedTransform(expr, 'F', True)
2317 
2318     def _print_SineTransform(self, expr):
2319         return self._print_UnifiedTransform(expr, 'SIN')
2320 
2321     def _print_InverseSineTransform(self, expr):
2322         return self._print_UnifiedTransform(expr, 'SIN', True)
2323 
2324     def _print_CosineTransform(self, expr):
2325         return self._print_UnifiedTransform(expr, 'COS')
2326 
2327     def _print_InverseCosineTransform(self, expr):
2328         return self._print_UnifiedTransform(expr, 'COS', True)
2329 
2330     def _print_DMP(self, p):
2331         try:
2332             if p.ring is not None:
2333                 # TODO incorporate order
2334                 return self._print(p.ring.to_sympy(p))
2335         except SympifyError:
2336             pass
2337         return self._print(repr(p))
2338 
2339     def _print_DMF(self, p):
2340         return self._print_DMP(p)
2341 
2342     def _print_Object(self, object):
2343         return self._print(Symbol(object.name))
2344 
2345     def _print_LambertW(self, expr):
2346         if len(expr.args) == 1:
2347             return r"W\left(%s\right)" % self._print(expr.args[0])
2348         return r"W_{%s}\left(%s\right)" % \
2349             (self._print(expr.args[1]), self._print(expr.args[0]))
2350 
2351     def _print_Morphism(self, morphism):
2352         domain = self._print(morphism.domain)
2353         codomain = self._print(morphism.codomain)
2354         return "%s\\rightarrow %s" % (domain, codomain)
2355 
2356     def _print_NamedMorphism(self, morphism):
2357         pretty_name = self._print(Symbol(morphism.name))
2358         pretty_morphism = self._print_Morphism(morphism)
2359         return "%s:%s" % (pretty_name, pretty_morphism)
2360 
2361     def _print_IdentityMorphism(self, morphism):
2362         from sympy.categories import NamedMorphism
2363         return self._print_NamedMorphism(NamedMorphism(
2364             morphism.domain, morphism.codomain, "id"))
2365 
2366     def _print_CompositeMorphism(self, morphism):
2367         # All components of the morphism have names and it is thus
2368         # possible to build the name of the composite.
2369         component_names_list = [self._print(Symbol(component.name)) for
2370                                 component in morphism.components]
2371         component_names_list.reverse()
2372         component_names = "\\circ ".join(component_names_list) + ":"
2373 
2374         pretty_morphism = self._print_Morphism(morphism)
2375         return component_names + pretty_morphism
2376 
2377     def _print_Category(self, morphism):
2378         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2379 
2380     def _print_Diagram(self, diagram):
2381         if not diagram.premises:
2382             # This is an empty diagram.
2383             return self._print(S.EmptySet)
2384 
2385         latex_result = self._print(diagram.premises)
2386         if diagram.conclusions:
2387             latex_result += "\\Longrightarrow %s" % \
2388                             self._print(diagram.conclusions)
2389 
2390         return latex_result
2391 
2392     def _print_DiagramGrid(self, grid):
2393         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2394 
2395         for i in range(grid.height):
2396             for j in range(grid.width):
2397                 if grid[i, j]:
2398                     latex_result += latex(grid[i, j])
2399                 latex_result += " "
2400                 if j != grid.width - 1:
2401                     latex_result += "& "
2402 
2403             if i != grid.height - 1:
2404                 latex_result += "\\\\"
2405             latex_result += "\n"
2406 
2407         latex_result += "\\end{array}\n"
2408         return latex_result
2409 
2410     def _print_FreeModule(self, M):
2411         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2412 
2413     def _print_FreeModuleElement(self, m):
2414         # Print as row vector for convenience, for now.
2415         return r"\left[ {} \right]".format(",".join(
2416             '{' + self._print(x) + '}' for x in m))
2417 
2418     def _print_SubModule(self, m):
2419         return r"\left\langle {} \right\rangle".format(",".join(
2420             '{' + self._print(x) + '}' for x in m.gens))
2421 
2422     def _print_ModuleImplementedIdeal(self, m):
2423         return r"\left\langle {} \right\rangle".format(",".join(
2424             '{' + self._print(x) + '}' for [x] in m._module.gens))
2425 
2426     def _print_Quaternion(self, expr):
2427         # TODO: This expression is potentially confusing,
2428         # shall we print it as `Quaternion( ... )`?
2429         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2430              for i in expr.args]
2431         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2432         return " + ".join(a)
2433 
2434     def _print_QuotientRing(self, R):
2435         # TODO nicer fractions for few generators...
2436         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2437                  self._print(R.base_ideal))
2438 
2439     def _print_QuotientRingElement(self, x):
2440         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2441                  self._print(x.ring.base_ideal))
2442 
2443     def _print_QuotientModuleElement(self, m):
2444         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2445                  self._print(m.module.killed_module))
2446 
2447     def _print_QuotientModule(self, M):
2448         # TODO nicer fractions for few generators...
2449         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2450                  self._print(M.killed_module))
2451 
2452     def _print_MatrixHomomorphism(self, h):
2453         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2454             self._print(h.domain), self._print(h.codomain))
2455 
2456     def _print_BaseScalarField(self, field):
2457         string = field._coord_sys._names[field._index]
2458         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2459 
2460     def _print_BaseVectorField(self, field):
2461         string = field._coord_sys._names[field._index]
2462         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2463 
2464     def _print_Differential(self, diff):
2465         field = diff._form_field
2466         if hasattr(field, '_coord_sys'):
2467             string = field._coord_sys._names[field._index]
2468             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2469         else:
2470             string = self._print(field)
2471             return r'\operatorname{{d}}\left({}\right)'.format(string)
2472 
2473     def _print_Tr(self, p):
2474         # TODO: Handle indices
2475         contents = self._print(p.args[0])
2476         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2477 
2478     def _print_totient(self, expr, exp=None):
2479         if exp is not None:
2480             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2481                 (self._print(expr.args[0]), self._print(exp))
2482         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2483 
2484     def _print_reduced_totient(self, expr, exp=None):
2485         if exp is not None:
2486             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2487                 (self._print(expr.args[0]), self._print(exp))
2488         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2489 
2490     def _print_divisor_sigma(self, expr, exp=None):
2491         if len(expr.args) == 2:
2492             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2493                                                 (expr.args[1], expr.args[0])))
2494         else:
2495             tex = r"\left(%s\right)" % self._print(expr.args[0])
2496         if exp is not None:
2497             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2498         return r"\sigma%s" % tex
2499 
2500     def _print_udivisor_sigma(self, expr, exp=None):
2501         if len(expr.args) == 2:
2502             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2503                                                 (expr.args[1], expr.args[0])))
2504         else:
2505             tex = r"\left(%s\right)" % self._print(expr.args[0])
2506         if exp is not None:
2507             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2508         return r"\sigma^*%s" % tex
2509 
2510     def _print_primenu(self, expr, exp=None):
2511         if exp is not None:
2512             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2513                 (self._print(expr.args[0]), self._print(exp))
2514         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2515 
2516     def _print_primeomega(self, expr, exp=None):
2517         if exp is not None:
2518             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2519                 (self._print(expr.args[0]), self._print(exp))
2520         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 14:30:49.955 | INFO     | Search completed. Bug locations: [<file>sympy/printing/str.py</file>
<class>StrPrinter</class>
<method>_print_Float</method>
<code>
682     def _print_Float(self, expr):
683         prec = expr._prec
684         if prec < 5:
685             dps = 0
686         else:
687             dps = prec_to_dps(expr._prec)
688         if self._settings["full_prec"] is True:
689             strip = False
690         elif self._settings["full_prec"] is False:
691             strip = True
692         elif self._settings["full_prec"] == "auto":
693             strip = self._print_level > 1
694         rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip)
695         if rv.startswith('-.0'):
696             rv = '-0.' + rv[3:]
697         elif rv.startswith('.0'):
698             rv = '0.' + rv[2:]
699         if rv.startswith('+'):
700             # e.g., +inf -> inf
701             rv = rv[1:]
702         return rv

</code><intended_behavior>This method should be adapted to respect `min_fixed` and `max_fixed` settings. If these settings are provided within the `_settings` dict of the `StrPrinter` class, they should be used to decide the format (fixed or scientific notation) of floating-point numbers based on their value. The method must preserve its functionality for handling `strip_zeros` and any original formatting logic. The modification should introduce a check to determine if the float's value falls within the range specified by `min_fixed` and `max_fixed`. If so, use fixed-point notation; otherwise, use scientific notation. This requires integration with the number formatting mechanisms already in place.</intended_behavior>, <file>sympy/printing/str.py</file>
<class>StrPrinter</class>
<method>None</method>
<code>
19 class StrPrinter(Printer):
20     printmethod = "_sympystr"
21     _default_settings = {
22         "order": None,
23         "full_prec": "auto",
24         "sympy_integers": False,
25         "abbrev": False,
26         "perm_cyclic": True,
27     }  # type: Dict[str, Any]
28 
29     _relationals = dict()  # type: Dict[str, str]
30 
31     def parenthesize(self, item, level, strict=False):
32         if (precedence(item) < level) or ((not strict) and precedence(item) <= level):
33             return "(%s)" % self._print(item)
34         else:
35             return self._print(item)
36 
37     def stringify(self, args, sep, level=0):
38         return sep.join([self.parenthesize(item, level) for item in args])
39 
40     def emptyPrinter(self, expr):
41         if isinstance(expr, str):
42             return expr
43         elif isinstance(expr, Basic):
44             return repr(expr)
45         else:
46             return str(expr)
47 
48     def _print_Add(self, expr, order=None):
49         if self.order == 'none':
50             terms = list(expr.args)
51         else:
52             terms = self._as_ordered_terms(expr, order=order)
53 
54         PREC = precedence(expr)
55         l = []
56         for term in terms:
57             t = self._print(term)
58             if t.startswith('-'):
59                 sign = "-"
60                 t = t[1:]
61             else:
62                 sign = "+"
63             if precedence(term) < PREC:
64                 l.extend([sign, "(%s)" % t])
65             else:
66                 l.extend([sign, t])
67         sign = l.pop(0)
68         if sign == '+':
69             sign = ""
70         return sign + ' '.join(l)
71 
72     def _print_BooleanTrue(self, expr):
73         return "True"
74 
75     def _print_BooleanFalse(self, expr):
76         return "False"
77 
78     def _print_Not(self, expr):
79         return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE["Not"]))
80 
81     def _print_And(self, expr):
82         return self.stringify(expr.args, " & ", PRECEDENCE["BitwiseAnd"])
83 
84     def _print_Or(self, expr):
85         return self.stringify(expr.args, " | ", PRECEDENCE["BitwiseOr"])
86 
87     def _print_Xor(self, expr):
88         return self.stringify(expr.args, " ^ ", PRECEDENCE["BitwiseXor"])
89 
90     def _print_AppliedPredicate(self, expr):
91         return '%s(%s)' % (self._print(expr.func), self._print(expr.arg))
92 
93     def _print_Basic(self, expr):
94         l = [self._print(o) for o in expr.args]
95         return expr.__class__.__name__ + "(%s)" % ", ".join(l)
96 
97     def _print_BlockMatrix(self, B):
98         if B.blocks.shape == (1, 1):
99             self._print(B.blocks[0, 0])
100         return self._print(B.blocks)
101 
102     def _print_Catalan(self, expr):
103         return 'Catalan'
104 
105     def _print_ComplexInfinity(self, expr):
106         return 'zoo'
107 
108     def _print_ConditionSet(self, s):
109         args = tuple([self._print(i) for i in (s.sym, s.condition)])
110         if s.base_set is S.UniversalSet:
111             return 'ConditionSet(%s, %s)' % args
112         args += (self._print(s.base_set),)
113         return 'ConditionSet(%s, %s, %s)' % args
114 
115     def _print_Derivative(self, expr):
116         dexpr = expr.expr
117         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
118         return 'Derivative(%s)' % ", ".join(map(lambda arg: self._print(arg), [dexpr] + dvars))
119 
120     def _print_dict(self, d):
121         keys = sorted(d.keys(), key=default_sort_key)
122         items = []
123 
124         for key in keys:
125             item = "%s: %s" % (self._print(key), self._print(d[key]))
126             items.append(item)
127 
128         return "{%s}" % ", ".join(items)
129 
130     def _print_Dict(self, expr):
131         return self._print_dict(expr)
132 
133     def _print_RandomDomain(self, d):
134         if hasattr(d, 'as_boolean'):
135             return 'Domain: ' + self._print(d.as_boolean())
136         elif hasattr(d, 'set'):
137             return ('Domain: ' + self._print(d.symbols) + ' in ' +
138                     self._print(d.set))
139         else:
140             return 'Domain on ' + self._print(d.symbols)
141 
142     def _print_Dummy(self, expr):
143         return '_' + expr.name
144 
145     def _print_EulerGamma(self, expr):
146         return 'EulerGamma'
147 
148     def _print_Exp1(self, expr):
149         return 'E'
150 
151     def _print_ExprCondPair(self, expr):
152         return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))
153 
154     def _print_Function(self, expr):
155         return expr.func.__name__ + "(%s)" % self.stringify(expr.args, ", ")
156 
157     def _print_GeometryEntity(self, expr):
158         # GeometryEntity is special -- it's base is tuple
159         return str(expr)
160 
161     def _print_GoldenRatio(self, expr):
162         return 'GoldenRatio'
163 
164     def _print_TribonacciConstant(self, expr):
165         return 'TribonacciConstant'
166 
167     def _print_ImaginaryUnit(self, expr):
168         return 'I'
169 
170     def _print_Infinity(self, expr):
171         return 'oo'
172 
173     def _print_Integral(self, expr):
174         def _xab_tostr(xab):
175             if len(xab) == 1:
176                 return self._print(xab[0])
177             else:
178                 return self._print((xab[0],) + tuple(xab[1:]))
179         L = ', '.join([_xab_tostr(l) for l in expr.limits])
180         return 'Integral(%s, %s)' % (self._print(expr.function), L)
181 
182     def _print_Interval(self, i):
183         fin =  'Interval{m}({a}, {b})'
184         a, b, l, r = i.args
185         if a.is_infinite and b.is_infinite:
186             m = ''
187         elif a.is_infinite and not r:
188             m = ''
189         elif b.is_infinite and not l:
190             m = ''
191         elif not l and not r:
192             m = ''
193         elif l and r:
194             m = '.open'
195         elif l:
196             m = '.Lopen'
197         else:
198             m = '.Ropen'
199         return fin.format(**{'a': a, 'b': b, 'm': m})
200 
201     def _print_AccumulationBounds(self, i):
202         return "AccumBounds(%s, %s)" % (self._print(i.min),
203                                         self._print(i.max))
204 
205     def _print_Inverse(self, I):
206         return "%s**(-1)" % self.parenthesize(I.arg, PRECEDENCE["Pow"])
207 
208     def _print_Lambda(self, obj):
209         expr = obj.expr
210         sig = obj.signature
211         if len(sig) == 1 and sig[0].is_symbol:
212             sig = sig[0]
213         return "Lambda(%s, %s)" % (self._print(sig), self._print(expr))
214 
215     def _print_LatticeOp(self, expr):
216         args = sorted(expr.args, key=default_sort_key)
217         return expr.func.__name__ + "(%s)" % ", ".join(self._print(arg) for arg in args)
218 
219     def _print_Limit(self, expr):
220         e, z, z0, dir = expr.args
221         if str(dir) == "+":
222             return "Limit(%s, %s, %s)" % tuple(map(self._print, (e, z, z0)))
223         else:
224             return "Limit(%s, %s, %s, dir='%s')" % tuple(map(self._print,
225                                                             (e, z, z0, dir)))
226 
227     def _print_list(self, expr):
228         return "[%s]" % self.stringify(expr, ", ")
229 
230     def _print_MatrixBase(self, expr):
231         return expr._format_str(self)
232 
233     def _print_MutableSparseMatrix(self, expr):
234         return self._print_MatrixBase(expr)
235 
236     def _print_SparseMatrix(self, expr):
237         from sympy.matrices import Matrix
238         return self._print(Matrix(expr))
239 
240     def _print_ImmutableSparseMatrix(self, expr):
241         return self._print_MatrixBase(expr)
242 
243     def _print_Matrix(self, expr):
244         return self._print_MatrixBase(expr)
245 
246     def _print_DenseMatrix(self, expr):
247         return self._print_MatrixBase(expr)
248 
249     def _print_MutableDenseMatrix(self, expr):
250         return self._print_MatrixBase(expr)
251 
252     def _print_ImmutableMatrix(self, expr):
253         return self._print_MatrixBase(expr)
254 
255     def _print_ImmutableDenseMatrix(self, expr):
256         return self._print_MatrixBase(expr)
257 
258     def _print_MatrixElement(self, expr):
259         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
260             + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))
261 
262     def _print_MatrixSlice(self, expr):
263         def strslice(x):
264             x = list(x)
265             if x[2] == 1:
266                 del x[2]
267             if x[1] == x[0] + 1:
268                 del x[1]
269             if x[0] == 0:
270                 x[0] = ''
271             return ':'.join(map(lambda arg: self._print(arg), x))
272         return (self._print(expr.parent) + '[' +
273                 strslice(expr.rowslice) + ', ' +
274                 strslice(expr.colslice) + ']')
275 
276     def _print_DeferredVector(self, expr):
277         return expr.name
278 
279     def _print_Mul(self, expr):
280 
281         prec = precedence(expr)
282 
283         c, e = expr.as_coeff_Mul()
284         if c < 0:
285             expr = _keep_coeff(-c, e)
286             sign = "-"
287         else:
288             sign = ""
289 
290         a = []  # items in the numerator
291         b = []  # items that are in the denominator (if any)
292 
293         pow_paren = []  # Will collect all pow with more than one base element and exp = -1
294 
295         if self.order not in ('old', 'none'):
296             args = expr.as_ordered_factors()
297         else:
298             # use make_args in case expr was something like -x -> x
299             args = Mul.make_args(expr)
300 
301         # Gather args for numerator/denominator
302         for item in args:
303             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
304                 if item.exp != -1:
305                     b.append(Pow(item.base, -item.exp, evaluate=False))
306                 else:
307                     if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160
308                         pow_paren.append(item)
309                     b.append(Pow(item.base, -item.exp))
310             elif item.is_Rational and item is not S.Infinity:
311                 if item.p != 1:
312                     a.append(Rational(item.p))
313                 if item.q != 1:
314                     b.append(Rational(item.q))
315             else:
316                 a.append(item)
317 
318         a = a or [S.One]
319 
320         a_str = [self.parenthesize(x, prec, strict=False) for x in a]
321         b_str = [self.parenthesize(x, prec, strict=False) for x in b]
322 
323         # To parenthesize Pow with exp = -1 and having more than one Symbol
324         for item in pow_paren:
325             if item.base in b:
326                 b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]
327 
328         if not b:
329             return sign + '*'.join(a_str)
330         elif len(b) == 1:
331             return sign + '*'.join(a_str) + "/" + b_str[0]
332         else:
333             return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)
334 
335     def _print_MatMul(self, expr):
336         c, m = expr.as_coeff_mmul()
337         if c.is_number and c < 0:
338             expr = _keep_coeff(-c, m)
339             sign = "-"
340         else:
341             sign = ""
342 
343         return sign + '*'.join(
344             [self.parenthesize(arg, precedence(expr)) for arg in expr.args]
345         )
346 
347     def _print_ElementwiseApplyFunction(self, expr):
348         return "{0}.({1})".format(
349             expr.function,
350             self._print(expr.expr),
351         )
352 
353     def _print_NaN(self, expr):
354         return 'nan'
355 
356     def _print_NegativeInfinity(self, expr):
357         return '-oo'
358 
359     def _print_Order(self, expr):
360         if not expr.variables or all(p is S.Zero for p in expr.point):
361             if len(expr.variables) <= 1:
362                 return 'O(%s)' % self._print(expr.expr)
363             else:
364                 return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)
365         else:
366             return 'O(%s)' % self.stringify(expr.args, ', ', 0)
367 
368     def _print_Ordinal(self, expr):
369         return expr.__str__()
370 
371     def _print_Cycle(self, expr):
372         return expr.__str__()
373 
374     def _print_Permutation(self, expr):
375         from sympy.combinatorics.permutations import Permutation, Cycle
376         from sympy.utilities.exceptions import SymPyDeprecationWarning
377 
378         perm_cyclic = Permutation.print_cyclic
379         if perm_cyclic is not None:
380             SymPyDeprecationWarning(
381                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
382                 useinstead="init_printing(perm_cyclic={})"
383                 .format(perm_cyclic),
384                 issue=15201,
385                 deprecated_since_version="1.6").warn()
386         else:
387             perm_cyclic = self._settings.get("perm_cyclic", True)
388 
389         if perm_cyclic:
390             if not expr.size:
391                 return '()'
392             # before taking Cycle notation, see if the last element is
393             # a singleton and move it to the head of the string
394             s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]
395             last = s.rfind('(')
396             if not last == 0 and ',' not in s[last:]:
397                 s = s[last:] + s[:last]
398             s = s.replace(',', '')
399             return s
400         else:
401             s = expr.support()
402             if not s:
403                 if expr.size < 5:
404                     return 'Permutation(%s)' % self._print(expr.array_form)
405                 return 'Permutation([], size=%s)' % self._print(expr.size)
406             trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)
407             use = full = self._print(expr.array_form)
408             if len(trim) < len(full):
409                 use = trim
410             return 'Permutation(%s)' % use
411 
412     def _print_Subs(self, obj):
413         expr, old, new = obj.args
414         if len(obj.point) == 1:
415             old = old[0]
416             new = new[0]
417         return "Subs(%s, %s, %s)" % (
418             self._print(expr), self._print(old), self._print(new))
419 
420     def _print_TensorIndex(self, expr):
421         return expr._print()
422 
423     def _print_TensorHead(self, expr):
424         return expr._print()
425 
426     def _print_Tensor(self, expr):
427         return expr._print()
428 
429     def _print_TensMul(self, expr):
430         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
431         sign, args = expr._get_args_for_traditional_printer()
432         return sign + "*".join(
433             [self.parenthesize(arg, precedence(expr)) for arg in args]
434         )
435 
436     def _print_TensAdd(self, expr):
437         return expr._print()
438 
439     def _print_PermutationGroup(self, expr):
440         p = ['    %s' % self._print(a) for a in expr.args]
441         return 'PermutationGroup([\n%s])' % ',\n'.join(p)
442 
443     def _print_Pi(self, expr):
444         return 'pi'
445 
446     def _print_PolyRing(self, ring):
447         return "Polynomial ring in %s over %s with %s order" % \
448             (", ".join(map(lambda rs: self._print(rs), ring.symbols)),
449             self._print(ring.domain), self._print(ring.order))
450 
451     def _print_FracField(self, field):
452         return "Rational function field in %s over %s with %s order" % \
453             (", ".join(map(lambda fs: self._print(fs), field.symbols)),
454             self._print(field.domain), self._print(field.order))
455 
456     def _print_FreeGroupElement(self, elm):
457         return elm.__str__()
458 
459     def _print_PolyElement(self, poly):
460         return poly.str(self, PRECEDENCE, "%s**%s", "*")
461 
462     def _print_FracElement(self, frac):
463         if frac.denom == 1:
464             return self._print(frac.numer)
465         else:
466             numer = self.parenthesize(frac.numer, PRECEDENCE["Mul"], strict=True)
467             denom = self.parenthesize(frac.denom, PRECEDENCE["Atom"], strict=True)
468             return numer + "/" + denom
469 
470     def _print_Poly(self, expr):
471         ATOM_PREC = PRECEDENCE["Atom"] - 1
472         terms, gens = [], [ self.parenthesize(s, ATOM_PREC) for s in expr.gens ]
473 
474         for monom, coeff in expr.terms():
475             s_monom = []
476 
477             for i, exp in enumerate(monom):
478                 if exp > 0:
479                     if exp == 1:
480                         s_monom.append(gens[i])
481                     else:
482                         s_monom.append(gens[i] + "**%d" % exp)
483 
484             s_monom = "*".join(s_monom)
485 
486             if coeff.is_Add:
487                 if s_monom:
488                     s_coeff = "(" + self._print(coeff) + ")"
489                 else:
490                     s_coeff = self._print(coeff)
491             else:
492                 if s_monom:
493                     if coeff is S.One:
494                         terms.extend(['+', s_monom])
495                         continue
496 
497                     if coeff is S.NegativeOne:
498                         terms.extend(['-', s_monom])
499                         continue
500 
501                 s_coeff = self._print(coeff)
502 
503             if not s_monom:
504                 s_term = s_coeff
505             else:
506                 s_term = s_coeff + "*" + s_monom
507 
508             if s_term.startswith('-'):
509                 terms.extend(['-', s_term[1:]])
510             else:
511                 terms.extend(['+', s_term])
512 
513         if terms[0] in ['-', '+']:
514             modifier = terms.pop(0)
515 
516             if modifier == '-':
517                 terms[0] = '-' + terms[0]
518 
519         format = expr.__class__.__name__ + "(%s, %s"
520 
521         from sympy.polys.polyerrors import PolynomialError
522 
523         try:
524             format += ", modulus=%s" % expr.get_modulus()
525         except PolynomialError:
526             format += ", domain='%s'" % expr.get_domain()
527 
528         format += ")"
529 
530         for index, item in enumerate(gens):
531             if len(item) > 2 and (item[:1] == "(" and item[len(item) - 1:] == ")"):
532                 gens[index] = item[1:len(item) - 1]
533 
534         return format % (' '.join(terms), ', '.join(gens))
535 
536     def _print_UniversalSet(self, p):
537         return 'UniversalSet'
538 
539     def _print_AlgebraicNumber(self, expr):
540         if expr.is_aliased:
541             return self._print(expr.as_poly().as_expr())
542         else:
543             return self._print(expr.as_expr())
544 
545     def _print_Pow(self, expr, rational=False):
546         """Printing helper function for ``Pow``
547 
548         Parameters
549         ==========
550 
551         rational : bool, optional
552             If ``True``, it will not attempt printing ``sqrt(x)`` or
553             ``x**S.Half`` as ``sqrt``, and will use ``x**(1/2)``
554             instead.
555 
556             See examples for additional details
557 
558         Examples
559         ========
560 
561         >>> from sympy.functions import sqrt
562         >>> from sympy.printing.str import StrPrinter
563         >>> from sympy.abc import x
564 
565         How ``rational`` keyword works with ``sqrt``:
566 
567         >>> printer = StrPrinter()
568         >>> printer._print_Pow(sqrt(x), rational=True)
569         'x**(1/2)'
570         >>> printer._print_Pow(sqrt(x), rational=False)
571         'sqrt(x)'
572         >>> printer._print_Pow(1/sqrt(x), rational=True)
573         'x**(-1/2)'
574         >>> printer._print_Pow(1/sqrt(x), rational=False)
575         '1/sqrt(x)'
576 
577         Notes
578         =====
579 
580         ``sqrt(x)`` is canonicalized as ``Pow(x, S.Half)`` in SymPy,
581         so there is no need of defining a separate printer for ``sqrt``.
582         Instead, it should be handled here as well.
583         """
584         PREC = precedence(expr)
585 
586         if expr.exp is S.Half and not rational:
587             return "sqrt(%s)" % self._print(expr.base)
588 
589         if expr.is_commutative:
590             if -expr.exp is S.Half and not rational:
591                 # Note: Don't test "expr.exp == -S.Half" here, because that will
592                 # match -0.5, which we don't want.
593                 return "%s/sqrt(%s)" % tuple(map(lambda arg: self._print(arg), (S.One, expr.base)))
594             if expr.exp is -S.One:
595                 # Similarly to the S.Half case, don't test with "==" here.
596                 return '%s/%s' % (self._print(S.One),
597                                   self.parenthesize(expr.base, PREC, strict=False))
598 
599         e = self.parenthesize(expr.exp, PREC, strict=False)
600         if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and expr.exp.q != 1:
601             # the parenthesized exp should be '(Rational(a, b))' so strip parens,
602             # but just check to be sure.
603             if e.startswith('(Rational'):
604                 return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])
605         return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)
606 
607     def _print_UnevaluatedExpr(self, expr):
608         return self._print(expr.args[0])
609 
610     def _print_MatPow(self, expr):
611         PREC = precedence(expr)
612         return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False),
613                          self.parenthesize(expr.exp, PREC, strict=False))
614 
615     def _print_ImmutableDenseNDimArray(self, expr):
616         return str(expr)
617 
618     def _print_ImmutableSparseNDimArray(self, expr):
619         return str(expr)
620 
621     def _print_Integer(self, expr):
622         if self._settings.get("sympy_integers", False):
623             return "S(%s)" % (expr)
624         return str(expr.p)
625 
626     def _print_Integers(self, expr):
627         return 'Integers'
628 
629     def _print_Naturals(self, expr):
630         return 'Naturals'
631 
632     def _print_Naturals0(self, expr):
633         return 'Naturals0'
634 
635     def _print_Rationals(self, expr):
636         return 'Rationals'
637 
638     def _print_Reals(self, expr):
639         return 'Reals'
640 
641     def _print_Complexes(self, expr):
642         return 'Complexes'
643 
644     def _print_EmptySet(self, expr):
645         return 'EmptySet'
646 
647     def _print_EmptySequence(self, expr):
648         return 'EmptySequence'
649 
650     def _print_int(self, expr):
651         return str(expr)
652 
653     def _print_mpz(self, expr):
654         return str(expr)
655 
656     def _print_Rational(self, expr):
657         if expr.q == 1:
658             return str(expr.p)
659         else:
660             if self._settings.get("sympy_integers", False):
661                 return "S(%s)/%s" % (expr.p, expr.q)
662             return "%s/%s" % (expr.p, expr.q)
663 
664     def _print_PythonRational(self, expr):
665         if expr.q == 1:
666             return str(expr.p)
667         else:
668             return "%d/%d" % (expr.p, expr.q)
669 
670     def _print_Fraction(self, expr):
671         if expr.denominator == 1:
672             return str(expr.numerator)
673         else:
674             return "%s/%s" % (expr.numerator, expr.denominator)
675 
676     def _print_mpq(self, expr):
677         if expr.denominator == 1:
678             return str(expr.numerator)
679         else:
680             return "%s/%s" % (expr.numerator, expr.denominator)
681 
682     def _print_Float(self, expr):
683         prec = expr._prec
684         if prec < 5:
685             dps = 0
686         else:
687             dps = prec_to_dps(expr._prec)
688         if self._settings["full_prec"] is True:
689             strip = False
690         elif self._settings["full_prec"] is False:
691             strip = True
692         elif self._settings["full_prec"] == "auto":
693             strip = self._print_level > 1
694         rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip)
695         if rv.startswith('-.0'):
696             rv = '-0.' + rv[3:]
697         elif rv.startswith('.0'):
698             rv = '0.' + rv[2:]
699         if rv.startswith('+'):
700             # e.g., +inf -> inf
701             rv = rv[1:]
702         return rv
703 
704     def _print_Relational(self, expr):
705 
706         charmap = {
707             "==": "Eq",
708             "!=": "Ne",
709             ":=": "Assignment",
710             '+=': "AddAugmentedAssignment",
711             "-=": "SubAugmentedAssignment",
712             "*=": "MulAugmentedAssignment",
713             "/=": "DivAugmentedAssignment",
714             "%=": "ModAugmentedAssignment",
715         }
716 
717         if expr.rel_op in charmap:
718             return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs),
719                                    self._print(expr.rhs))
720 
721         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
722                            self._relationals.get(expr.rel_op) or expr.rel_op,
723                            self.parenthesize(expr.rhs, precedence(expr)))
724 
725     def _print_ComplexRootOf(self, expr):
726         return "CRootOf(%s, %d)" % (self._print_Add(expr.expr,  order='lex'),
727                                     expr.index)
728 
729     def _print_RootSum(self, expr):
730         args = [self._print_Add(expr.expr, order='lex')]
731 
732         if expr.fun is not S.IdentityFunction:
733             args.append(self._print(expr.fun))
734 
735         return "RootSum(%s)" % ", ".join(args)
736 
737     def _print_GroebnerBasis(self, basis):
738         cls = basis.__class__.__name__
739 
740         exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]
741         exprs = "[%s]" % ", ".join(exprs)
742 
743         gens = [ self._print(gen) for gen in basis.gens ]
744         domain = "domain='%s'" % self._print(basis.domain)
745         order = "order='%s'" % self._print(basis.order)
746 
747         args = [exprs] + gens + [domain, order]
748 
749         return "%s(%s)" % (cls, ", ".join(args))
750 
751     def _print_set(self, s):
752         items = sorted(s, key=default_sort_key)
753 
754         args = ', '.join(self._print(item) for item in items)
755         if not args:
756             return "set()"
757         return '{%s}' % args
758 
759     def _print_frozenset(self, s):
760         if not s:
761             return "frozenset()"
762         return "frozenset(%s)" % self._print_set(s)
763 
764     def _print_Sum(self, expr):
765         def _xab_tostr(xab):
766             if len(xab) == 1:
767                 return self._print(xab[0])
768             else:
769                 return self._print((xab[0],) + tuple(xab[1:]))
770         L = ', '.join([_xab_tostr(l) for l in expr.limits])
771         return 'Sum(%s, %s)' % (self._print(expr.function), L)
772 
773     def _print_Symbol(self, expr):
774         return expr.name
775     _print_MatrixSymbol = _print_Symbol
776     _print_RandomSymbol = _print_Symbol
777 
778     def _print_Identity(self, expr):
779         return "I"
780 
781     def _print_ZeroMatrix(self, expr):
782         return "0"
783 
784     def _print_OneMatrix(self, expr):
785         return "1"
786 
787     def _print_Predicate(self, expr):
788         return "Q.%s" % expr.name
789 
790     def _print_str(self, expr):
791         return str(expr)
792 
793     def _print_tuple(self, expr):
794         if len(expr) == 1:
795             return "(%s,)" % self._print(expr[0])
796         else:
797             return "(%s)" % self.stringify(expr, ", ")
798 
799     def _print_Tuple(self, expr):
800         return self._print_tuple(expr)
801 
802     def _print_Transpose(self, T):
803         return "%s.T" % self.parenthesize(T.arg, PRECEDENCE["Pow"])
804 
805     def _print_Uniform(self, expr):
806         return "Uniform(%s, %s)" % (self._print(expr.a), self._print(expr.b))
807 
808     def _print_Quantity(self, expr):
809         if self._settings.get("abbrev", False):
810             return "%s" % expr.abbrev
811         return "%s" % expr.name
812 
813     def _print_Quaternion(self, expr):
814         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
815         a = [s[0]] + [i+"*"+j for i, j in zip(s[1:], "ijk")]
816         return " + ".join(a)
817 
818     def _print_Dimension(self, expr):
819         return str(expr)
820 
821     def _print_Wild(self, expr):
822         return expr.name + '_'
823 
824     def _print_WildFunction(self, expr):
825         return expr.name + '_'
826 
827     def _print_Zero(self, expr):
828         if self._settings.get("sympy_integers", False):
829             return "S(0)"
830         return "0"
831 
832     def _print_DMP(self, p):
833         from sympy.core.sympify import SympifyError
834         try:
835             if p.ring is not None:
836                 # TODO incorporate order
837                 return self._print(p.ring.to_sympy(p))
838         except SympifyError:
839             pass
840 
841         cls = p.__class__.__name__
842         rep = self._print(p.rep)
843         dom = self._print(p.dom)
844         ring = self._print(p.ring)
845 
846         return "%s(%s, %s, %s)" % (cls, rep, dom, ring)
847 
848     def _print_DMF(self, expr):
849         return self._print_DMP(expr)
850 
851     def _print_Object(self, obj):
852         return 'Object("%s")' % obj.name
853 
854     def _print_IdentityMorphism(self, morphism):
855         return 'IdentityMorphism(%s)' % morphism.domain
856 
857     def _print_NamedMorphism(self, morphism):
858         return 'NamedMorphism(%s, %s, "%s")' % \
859                (morphism.domain, morphism.codomain, morphism.name)
860 
861     def _print_Category(self, category):
862         return 'Category("%s")' % category.name
863 
864     def _print_BaseScalarField(self, field):
865         return field._coord_sys._names[field._index]
866 
867     def _print_BaseVectorField(self, field):
868         return 'e_%s' % field._coord_sys._names[field._index]
869 
870     def _print_Differential(self, diff):
871         field = diff._form_field
872         if hasattr(field, '_coord_sys'):
873             return 'd%s' % field._coord_sys._names[field._index]
874         else:
875             return 'd(%s)' % self._print(field)
876 
877     def _print_Tr(self, expr):
878         #TODO : Handle indices
879         return "%s(%s)" % ("Tr", self._print(expr.args[0]))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Float</method>
<code>
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real

</code><intended_behavior>Similar to `StrPrinter`, this method in the `LatexPrinter` class needs to incorporate `min_fixed` and `max_fixed` settings into its logic for printing floats. The method must ensure that floating-point numbers are produced in LaTeX format adhering to these new settings while still accommodating the existing `strip_zeros` setting. This change involves adjusting the formatting decision process to use fixed or scientific notation based on the provided settings. As in `StrPrinter`, ensure the functionality does not disrupt existing behavior but extends it to consider these additional settings.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
124 class LatexPrinter(Printer):
125     printmethod = "_latex"
126 
127     _default_settings = {
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "inv_trig_style": "abbreviated",
132         "itex": False,
133         "ln_notation": False,
134         "long_frac_ratio": None,
135         "mat_delim": "[",
136         "mat_str": None,
137         "mode": "plain",
138         "mul_symbol": None,
139         "order": None,
140         "symbol_names": {},
141         "root_notation": True,
142         "mat_symbol_style": "plain",
143         "imaginary_unit": "i",
144         "gothic_re_im": False,
145         "decimal_separator": "period",
146         "perm_cyclic": True,
147     }  # type: Dict[str, Any]
148 
149     def __init__(self, settings=None):
150         Printer.__init__(self, settings)
151 
152         if 'mode' in self._settings:
153             valid_modes = ['inline', 'plain', 'equation',
154                            'equation*']
155             if self._settings['mode'] not in valid_modes:
156                 raise ValueError("'mode' must be one of 'inline', 'plain', "
157                                  "'equation' or 'equation*'")
158 
159         if self._settings['fold_short_frac'] is None and \
160                 self._settings['mode'] == 'inline':
161             self._settings['fold_short_frac'] = True
162 
163         mul_symbol_table = {
164             None: r" ",
165             "ldot": r" \,.\, ",
166             "dot": r" \cdot ",
167             "times": r" \times "
168         }
169         try:
170             self._settings['mul_symbol_latex'] = \
171                 mul_symbol_table[self._settings['mul_symbol']]
172         except KeyError:
173             self._settings['mul_symbol_latex'] = \
174                 self._settings['mul_symbol']
175         try:
176             self._settings['mul_symbol_latex_numbers'] = \
177                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
178         except KeyError:
179             if (self._settings['mul_symbol'].strip() in
180                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
181                 self._settings['mul_symbol_latex_numbers'] = \
182                     mul_symbol_table['dot']
183             else:
184                 self._settings['mul_symbol_latex_numbers'] = \
185                     self._settings['mul_symbol']
186 
187         self._delim_dict = {'(': ')', '[': ']'}
188 
189         imaginary_unit_table = {
190             None: r"i",
191             "i": r"i",
192             "ri": r"\mathrm{i}",
193             "ti": r"\text{i}",
194             "j": r"j",
195             "rj": r"\mathrm{j}",
196             "tj": r"\text{j}",
197         }
198         try:
199             self._settings['imaginary_unit_latex'] = \
200                 imaginary_unit_table[self._settings['imaginary_unit']]
201         except KeyError:
202             self._settings['imaginary_unit_latex'] = \
203                 self._settings['imaginary_unit']
204 
205     def parenthesize(self, item, level, strict=False):
206         prec_val = precedence_traditional(item)
207         if (prec_val < level) or ((not strict) and prec_val <= level):
208             return r"\left({}\right)".format(self._print(item))
209         else:
210             return self._print(item)
211 
212     def parenthesize_super(self, s):
213         """ Parenthesize s if there is a superscript in s"""
214         if "^" in s:
215             return r"\left({}\right)".format(s)
216         return s
217 
218     def embed_super(self, s):
219         """ Embed s in {} if there is a superscript in s"""
220         if "^" in s:
221             return "{{{}}}".format(s)
222         return s
223 
224     def doprint(self, expr):
225         tex = Printer.doprint(self, expr)
226 
227         if self._settings['mode'] == 'plain':
228             return tex
229         elif self._settings['mode'] == 'inline':
230             return r"$%s$" % tex
231         elif self._settings['itex']:
232             return r"$$%s$$" % tex
233         else:
234             env_str = self._settings['mode']
235             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
236 
237     def _needs_brackets(self, expr):
238         """
239         Returns True if the expression needs to be wrapped in brackets when
240         printed, False otherwise. For example: a + b => True; a => False;
241         10 => False; -10 => True.
242         """
243         return not ((expr.is_Integer and expr.is_nonnegative)
244                     or (expr.is_Atom and (expr is not S.NegativeOne
245                                           and expr.is_Rational is False)))
246 
247     def _needs_function_brackets(self, expr):
248         """
249         Returns True if the expression needs to be wrapped in brackets when
250         passed as an argument to a function, False otherwise. This is a more
251         liberal version of _needs_brackets, in that many expressions which need
252         to be wrapped in brackets when added/subtracted/raised to a power do
253         not need them when passed to a function. Such an example is a*b.
254         """
255         if not self._needs_brackets(expr):
256             return False
257         else:
258             # Muls of the form a*b*c... can be folded
259             if expr.is_Mul and not self._mul_is_clean(expr):
260                 return True
261             # Pows which don't need brackets can be folded
262             elif expr.is_Pow and not self._pow_is_clean(expr):
263                 return True
264             # Add and Function always need brackets
265             elif expr.is_Add or expr.is_Function:
266                 return True
267             else:
268                 return False
269 
270     def _needs_mul_brackets(self, expr, first=False, last=False):
271         """
272         Returns True if the expression needs to be wrapped in brackets when
273         printed as part of a Mul, False otherwise. This is True for Add,
274         but also for some container objects that would not need brackets
275         when appearing last in a Mul, e.g. an Integral. ``last=True``
276         specifies that this expr is the last to appear in a Mul.
277         ``first=True`` specifies that this expr is the first to appear in
278         a Mul.
279         """
280         from sympy import Integral, Product, Sum
281 
282         if expr.is_Mul:
283             if not first and _coeff_isneg(expr):
284                 return True
285         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
286             return True
287         elif expr.is_Relational:
288             return True
289         if expr.is_Piecewise:
290             return True
291         if any([expr.has(x) for x in (Mod,)]):
292             return True
293         if (not last and
294                 any([expr.has(x) for x in (Integral, Product, Sum)])):
295             return True
296 
297         return False
298 
299     def _needs_add_brackets(self, expr):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of an Add, False otherwise.  This is False for most
303         things.
304         """
305         if expr.is_Relational:
306             return True
307         if any([expr.has(x) for x in (Mod,)]):
308             return True
309         if expr.is_Add:
310             return True
311         return False
312 
313     def _mul_is_clean(self, expr):
314         for arg in expr.args:
315             if arg.is_Function:
316                 return False
317         return True
318 
319     def _pow_is_clean(self, expr):
320         return not self._needs_brackets(expr.base)
321 
322     def _do_exponent(self, expr, exp):
323         if exp is not None:
324             return r"\left(%s\right)^{%s}" % (expr, exp)
325         else:
326             return expr
327 
328     def _print_Basic(self, expr):
329         ls = [self._print(o) for o in expr.args]
330         return self._deal_with_super_sub(expr.__class__.__name__) + \
331             r"\left(%s\right)" % ", ".join(ls)
332 
333     def _print_bool(self, e):
334         return r"\text{%s}" % e
335 
336     _print_BooleanTrue = _print_bool
337     _print_BooleanFalse = _print_bool
338 
339     def _print_NoneType(self, e):
340         return r"\text{%s}" % e
341 
342     def _print_Add(self, expr, order=None):
343         if self.order == 'none':
344             terms = list(expr.args)
345         else:
346             terms = self._as_ordered_terms(expr, order=order)
347 
348         tex = ""
349         for i, term in enumerate(terms):
350             if i == 0:
351                 pass
352             elif _coeff_isneg(term):
353                 tex += " - "
354                 term = -term
355             else:
356                 tex += " + "
357             term_tex = self._print(term)
358             if self._needs_add_brackets(term):
359                 term_tex = r"\left(%s\right)" % term_tex
360             tex += term_tex
361 
362         return tex
363 
364     def _print_Cycle(self, expr):
365         from sympy.combinatorics.permutations import Permutation
366         if expr.size == 0:
367             return r"\left( \right)"
368         expr = Permutation(expr)
369         expr_perm = expr.cyclic_form
370         siz = expr.size
371         if expr.array_form[-1] == siz - 1:
372             expr_perm = expr_perm + [[siz - 1]]
373         term_tex = ''
374         for i in expr_perm:
375             term_tex += str(i).replace(',', r"\;")
376         term_tex = term_tex.replace('[', r"\left( ")
377         term_tex = term_tex.replace(']', r"\right)")
378         return term_tex
379 
380     def _print_Permutation(self, expr):
381         from sympy.combinatorics.permutations import Permutation
382         from sympy.utilities.exceptions import SymPyDeprecationWarning
383 
384         perm_cyclic = Permutation.print_cyclic
385         if perm_cyclic is not None:
386             SymPyDeprecationWarning(
387                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
388                 useinstead="init_printing(perm_cyclic={})"
389                 .format(perm_cyclic),
390                 issue=15201,
391                 deprecated_since_version="1.6").warn()
392         else:
393             perm_cyclic = self._settings.get("perm_cyclic", True)
394 
395         if perm_cyclic:
396             return self._print_Cycle(expr)
397 
398         if expr.size == 0:
399             return r"\left( \right)"
400 
401         lower = [self._print(arg) for arg in expr.array_form]
402         upper = [self._print(arg) for arg in range(len(lower))]
403 
404         row1 = " & ".join(upper)
405         row2 = " & ".join(lower)
406         mat = r" \\ ".join((row1, row2))
407         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
408 
409 
410     def _print_AppliedPermutation(self, expr):
411         perm, var = expr.args
412         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
413 
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real
440 
441     def _print_Cross(self, expr):
442         vec1 = expr._expr1
443         vec2 = expr._expr2
444         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
445                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
446 
447     def _print_Curl(self, expr):
448         vec = expr._expr
449         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
450 
451     def _print_Divergence(self, expr):
452         vec = expr._expr
453         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
454 
455     def _print_Dot(self, expr):
456         vec1 = expr._expr1
457         vec2 = expr._expr2
458         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
459                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
460 
461     def _print_Gradient(self, expr):
462         func = expr._expr
463         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
464 
465     def _print_Laplacian(self, expr):
466         func = expr._expr
467         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
468 
469     def _print_Mul(self, expr):
470         from sympy.core.power import Pow
471         from sympy.physics.units import Quantity
472         include_parens = False
473         if _coeff_isneg(expr):
474             expr = -expr
475             tex = "- "
476             if expr.is_Add:
477                 tex += "("
478                 include_parens = True
479         else:
480             tex = ""
481 
482         from sympy.simplify import fraction
483         numer, denom = fraction(expr, exact=True)
484         separator = self._settings['mul_symbol_latex']
485         numbersep = self._settings['mul_symbol_latex_numbers']
486 
487         def convert(expr):
488             if not expr.is_Mul:
489                 return str(self._print(expr))
490             else:
491                 _tex = last_term_tex = ""
492 
493                 if self.order not in ('old', 'none'):
494                     args = expr.as_ordered_factors()
495                 else:
496                     args = list(expr.args)
497 
498                 # If quantities are present append them at the back
499                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
500                               (isinstance(x, Pow) and
501                                isinstance(x.base, Quantity)))
502 
503                 for i, term in enumerate(args):
504                     term_tex = self._print(term)
505 
506                     if self._needs_mul_brackets(term, first=(i == 0),
507                                                 last=(i == len(args) - 1)):
508                         term_tex = r"\left(%s\right)" % term_tex
509 
510                     if _between_two_numbers_p[0].search(last_term_tex) and \
511                             _between_two_numbers_p[1].match(term_tex):
512                         # between two numbers
513                         _tex += numbersep
514                     elif _tex:
515                         _tex += separator
516 
517                     _tex += term_tex
518                     last_term_tex = term_tex
519                 return _tex
520 
521         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
522             # use the original expression here, since fraction() may have
523             # altered it when producing numer and denom
524             tex += convert(expr)
525 
526         else:
527             snumer = convert(numer)
528             sdenom = convert(denom)
529             ldenom = len(sdenom.split())
530             ratio = self._settings['long_frac_ratio']
531             if self._settings['fold_short_frac'] and ldenom <= 2 and \
532                     "^" not in sdenom:
533                 # handle short fractions
534                 if self._needs_mul_brackets(numer, last=False):
535                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
536                 else:
537                     tex += r"%s / %s" % (snumer, sdenom)
538             elif ratio is not None and \
539                     len(snumer.split()) > ratio*ldenom:
540                 # handle long fractions
541                 if self._needs_mul_brackets(numer, last=True):
542                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
543                         % (sdenom, separator, snumer)
544                 elif numer.is_Mul:
545                     # split a long numerator
546                     a = S.One
547                     b = S.One
548                     for x in numer.args:
549                         if self._needs_mul_brackets(x, last=False) or \
550                                 len(convert(a*x).split()) > ratio*ldenom or \
551                                 (b.is_commutative is x.is_commutative is False):
552                             b *= x
553                         else:
554                             a *= x
555                     if self._needs_mul_brackets(b, last=True):
556                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
557                             % (convert(a), sdenom, separator, convert(b))
558                     else:
559                         tex += r"\frac{%s}{%s}%s%s" \
560                             % (convert(a), sdenom, separator, convert(b))
561                 else:
562                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
563             else:
564                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
565 
566         if include_parens:
567             tex += ")"
568         return tex
569 
570     def _print_Pow(self, expr):
571         # Treat x**Rational(1,n) as special case
572         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
573                 and self._settings['root_notation']:
574             base = self._print(expr.base)
575             expq = expr.exp.q
576 
577             if expq == 2:
578                 tex = r"\sqrt{%s}" % base
579             elif self._settings['itex']:
580                 tex = r"\root{%d}{%s}" % (expq, base)
581             else:
582                 tex = r"\sqrt[%d]{%s}" % (expq, base)
583 
584             if expr.exp.is_negative:
585                 return r"\frac{1}{%s}" % tex
586             else:
587                 return tex
588         elif self._settings['fold_frac_powers'] \
589             and expr.exp.is_Rational \
590                 and expr.exp.q != 1:
591             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
592             p, q = expr.exp.p, expr.exp.q
593             # issue #12886: add parentheses for superscripts raised to powers
594             if '^' in base and expr.base.is_Symbol:
595                 base = r"\left(%s\right)" % base
596             if expr.base.is_Function:
597                 return self._print(expr.base, exp="%s/%s" % (p, q))
598             return r"%s^{%s/%s}" % (base, p, q)
599         elif expr.exp.is_Rational and expr.exp.is_negative and \
600                 expr.base.is_commutative:
601             # special case for 1^(-x), issue 9216
602             if expr.base == 1:
603                 return r"%s^{%s}" % (expr.base, expr.exp)
604             # things like 1/x
605             return self._print_Mul(expr)
606         else:
607             if expr.base.is_Function:
608                 return self._print(expr.base, exp=self._print(expr.exp))
609             else:
610                 tex = r"%s^{%s}"
611                 return self._helper_print_standard_power(expr, tex)
612 
613     def _helper_print_standard_power(self, expr, template):
614         exp = self._print(expr.exp)
615         # issue #12886: add parentheses around superscripts raised
616         # to powers
617         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
618         if '^' in base and expr.base.is_Symbol:
619             base = r"\left(%s\right)" % base
620         elif (isinstance(expr.base, Derivative)
621             and base.startswith(r'\left(')
622             and re.match(r'\\left\(\\d?d?dot', base)
623             and base.endswith(r'\right)')):
624             # don't use parentheses around dotted derivative
625             base = base[6: -7]  # remove outermost added parens
626         return template % (base, exp)
627 
628     def _print_UnevaluatedExpr(self, expr):
629         return self._print(expr.args[0])
630 
631     def _print_Sum(self, expr):
632         if len(expr.limits) == 1:
633             tex = r"\sum_{%s=%s}^{%s} " % \
634                 tuple([self._print(i) for i in expr.limits[0]])
635         else:
636             def _format_ineq(l):
637                 return r"%s \leq %s \leq %s" % \
638                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
639 
640             tex = r"\sum_{\substack{%s}} " % \
641                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
642 
643         if isinstance(expr.function, Add):
644             tex += r"\left(%s\right)" % self._print(expr.function)
645         else:
646             tex += self._print(expr.function)
647 
648         return tex
649 
650     def _print_Product(self, expr):
651         if len(expr.limits) == 1:
652             tex = r"\prod_{%s=%s}^{%s} " % \
653                 tuple([self._print(i) for i in expr.limits[0]])
654         else:
655             def _format_ineq(l):
656                 return r"%s \leq %s \leq %s" % \
657                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
658 
659             tex = r"\prod_{\substack{%s}} " % \
660                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
661 
662         if isinstance(expr.function, Add):
663             tex += r"\left(%s\right)" % self._print(expr.function)
664         else:
665             tex += self._print(expr.function)
666 
667         return tex
668 
669     def _print_BasisDependent(self, expr):
670         from sympy.vector import Vector
671 
672         o1 = []
673         if expr == expr.zero:
674             return expr.zero._latex_form
675         if isinstance(expr, Vector):
676             items = expr.separate().items()
677         else:
678             items = [(0, expr)]
679 
680         for system, vect in items:
681             inneritems = list(vect.components.items())
682             inneritems.sort(key=lambda x: x[0].__str__())
683             for k, v in inneritems:
684                 if v == 1:
685                     o1.append(' + ' + k._latex_form)
686                 elif v == -1:
687                     o1.append(' - ' + k._latex_form)
688                 else:
689                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
690                     o1.append(' + ' + arg_str + k._latex_form)
691 
692         outstr = (''.join(o1))
693         if outstr[1] != '-':
694             outstr = outstr[3:]
695         else:
696             outstr = outstr[1:]
697         return outstr
698 
699     def _print_Indexed(self, expr):
700         tex_base = self._print(expr.base)
701         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
702             map(self._print, expr.indices))
703         return tex
704 
705     def _print_IndexedBase(self, expr):
706         return self._print(expr.label)
707 
708     def _print_Derivative(self, expr):
709         if requires_partial(expr.expr):
710             diff_symbol = r'\partial'
711         else:
712             diff_symbol = r'd'
713 
714         tex = ""
715         dim = 0
716         for x, num in reversed(expr.variable_count):
717             dim += num
718             if num == 1:
719                 tex += r"%s %s" % (diff_symbol, self._print(x))
720             else:
721                 tex += r"%s %s^{%s}" % (diff_symbol,
722                                         self.parenthesize_super(self._print(x)),
723                                         self._print(num))
724 
725         if dim == 1:
726             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
727         else:
728             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
729 
730         return r"%s %s" % (tex, self.parenthesize(expr.expr,
731                                                   PRECEDENCE["Mul"],
732                                                   strict=True))
733 
734     def _print_Subs(self, subs):
735         expr, old, new = subs.args
736         latex_expr = self._print(expr)
737         latex_old = (self._print(e) for e in old)
738         latex_new = (self._print(e) for e in new)
739         latex_subs = r'\\ '.join(
740             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
741         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
742                                                          latex_subs)
743 
744     def _print_Integral(self, expr):
745         tex, symbols = "", []
746 
747         # Only up to \iiiint exists
748         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
749             # Use len(expr.limits)-1 so that syntax highlighters don't think
750             # \" is an escaped quote
751             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
752             symbols = [r"\, d%s" % self._print(symbol[0])
753                        for symbol in expr.limits]
754 
755         else:
756             for lim in reversed(expr.limits):
757                 symbol = lim[0]
758                 tex += r"\int"
759 
760                 if len(lim) > 1:
761                     if self._settings['mode'] != 'inline' \
762                             and not self._settings['itex']:
763                         tex += r"\limits"
764 
765                     if len(lim) == 3:
766                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
767                                                self._print(lim[2]))
768                     if len(lim) == 2:
769                         tex += "^{%s}" % (self._print(lim[1]))
770 
771                 symbols.insert(0, r"\, d%s" % self._print(symbol))
772 
773         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
774                                                     PRECEDENCE["Mul"],
775                                                     strict=True),
776                              "".join(symbols))
777 
778     def _print_Limit(self, expr):
779         e, z, z0, dir = expr.args
780 
781         tex = r"\lim_{%s \to " % self._print(z)
782         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
783             tex += r"%s}" % self._print(z0)
784         else:
785             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
786 
787         if isinstance(e, AssocOp):
788             return r"%s\left(%s\right)" % (tex, self._print(e))
789         else:
790             return r"%s %s" % (tex, self._print(e))
791 
792     def _hprint_Function(self, func):
793         r'''
794         Logic to decide how to render a function to latex
795           - if it is a recognized latex name, use the appropriate latex command
796           - if it is a single letter, just use that letter
797           - if it is a longer name, then put \operatorname{} around it and be
798             mindful of undercores in the name
799         '''
800         func = self._deal_with_super_sub(func)
801         if func in accepted_latex_functions:
802             name = r"\%s" % func
803         elif len(func) == 1 or func.startswith('\\'):
804             name = func
805         else:
806             name = r"\operatorname{%s}" % func
807         return name
808 
809     def _print_Function(self, expr, exp=None):
810         r'''
811         Render functions to LaTeX, handling functions that LaTeX knows about
812         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
813         For single-letter function names, render them as regular LaTeX math
814         symbols. For multi-letter function names that LaTeX does not know
815         about, (e.g., Li, sech) use \operatorname{} so that the function name
816         is rendered in Roman font and LaTeX handles spacing properly.
817 
818         expr is the expression involving the function
819         exp is an exponent
820         '''
821         func = expr.func.__name__
822         if hasattr(self, '_print_' + func) and \
823                 not isinstance(expr, AppliedUndef):
824             return getattr(self, '_print_' + func)(expr, exp)
825         else:
826             args = [str(self._print(arg)) for arg in expr.args]
827             # How inverse trig functions should be displayed, formats are:
828             # abbreviated: asin, full: arcsin, power: sin^-1
829             inv_trig_style = self._settings['inv_trig_style']
830             # If we are dealing with a power-style inverse trig function
831             inv_trig_power_case = False
832             # If it is applicable to fold the argument brackets
833             can_fold_brackets = self._settings['fold_func_brackets'] and \
834                 len(args) == 1 and \
835                 not self._needs_function_brackets(expr.args[0])
836 
837             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
838 
839             # If the function is an inverse trig function, handle the style
840             if func in inv_trig_table:
841                 if inv_trig_style == "abbreviated":
842                     pass
843                 elif inv_trig_style == "full":
844                     func = "arc" + func[1:]
845                 elif inv_trig_style == "power":
846                     func = func[1:]
847                     inv_trig_power_case = True
848 
849                     # Can never fold brackets if we're raised to a power
850                     if exp is not None:
851                         can_fold_brackets = False
852 
853             if inv_trig_power_case:
854                 if func in accepted_latex_functions:
855                     name = r"\%s^{-1}" % func
856                 else:
857                     name = r"\operatorname{%s}^{-1}" % func
858             elif exp is not None:
859                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
860             else:
861                 name = self._hprint_Function(func)
862 
863             if can_fold_brackets:
864                 if func in accepted_latex_functions:
865                     # Wrap argument safely to avoid parse-time conflicts
866                     # with the function name itself
867                     name += r" {%s}"
868                 else:
869                     name += r"%s"
870             else:
871                 name += r"{\left(%s \right)}"
872 
873             if inv_trig_power_case and exp is not None:
874                 name += r"^{%s}" % exp
875 
876             return name % ",".join(args)
877 
878     def _print_UndefinedFunction(self, expr):
879         return self._hprint_Function(str(expr))
880 
881     def _print_ElementwiseApplyFunction(self, expr):
882         return r"{%s}_{\circ}\left({%s}\right)" % (
883             self._print(expr.function),
884             self._print(expr.expr),
885         )
886 
887     @property
888     def _special_function_classes(self):
889         from sympy.functions.special.tensor_functions import KroneckerDelta
890         from sympy.functions.special.gamma_functions import gamma, lowergamma
891         from sympy.functions.special.beta_functions import beta
892         from sympy.functions.special.delta_functions import DiracDelta
893         from sympy.functions.special.error_functions import Chi
894         return {KroneckerDelta: r'\delta',
895                 gamma:  r'\Gamma',
896                 lowergamma: r'\gamma',
897                 beta: r'\operatorname{B}',
898                 DiracDelta: r'\delta',
899                 Chi: r'\operatorname{Chi}'}
900 
901     def _print_FunctionClass(self, expr):
902         for cls in self._special_function_classes:
903             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
904                 return self._special_function_classes[cls]
905         return self._hprint_Function(str(expr))
906 
907     def _print_Lambda(self, expr):
908         symbols, expr = expr.args
909 
910         if len(symbols) == 1:
911             symbols = self._print(symbols[0])
912         else:
913             symbols = self._print(tuple(symbols))
914 
915         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
916 
917         return tex
918 
919     def _hprint_variadic_function(self, expr, exp=None):
920         args = sorted(expr.args, key=default_sort_key)
921         texargs = [r"%s" % self._print(symbol) for symbol in args]
922         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()),
923                                        ", ".join(texargs))
924         if exp is not None:
925             return r"%s^{%s}" % (tex, exp)
926         else:
927             return tex
928 
929     _print_Min = _print_Max = _hprint_variadic_function
930 
931     def _print_floor(self, expr, exp=None):
932         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_ceiling(self, expr, exp=None):
940         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
941 
942         if exp is not None:
943             return r"%s^{%s}" % (tex, exp)
944         else:
945             return tex
946 
947     def _print_log(self, expr, exp=None):
948         if not self._settings["ln_notation"]:
949             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
950         else:
951             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
952 
953         if exp is not None:
954             return r"%s^{%s}" % (tex, exp)
955         else:
956             return tex
957 
958     def _print_Abs(self, expr, exp=None):
959         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
960 
961         if exp is not None:
962             return r"%s^{%s}" % (tex, exp)
963         else:
964             return tex
965     _print_Determinant = _print_Abs
966 
967     def _print_re(self, expr, exp=None):
968         if self._settings['gothic_re_im']:
969             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
970         else:
971             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
972 
973         return self._do_exponent(tex, exp)
974 
975     def _print_im(self, expr, exp=None):
976         if self._settings['gothic_re_im']:
977             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
978         else:
979             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
980 
981         return self._do_exponent(tex, exp)
982 
983     def _print_Not(self, e):
984         from sympy import Equivalent, Implies
985         if isinstance(e.args[0], Equivalent):
986             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
987         if isinstance(e.args[0], Implies):
988             return self._print_Implies(e.args[0], r"\not\Rightarrow")
989         if (e.args[0].is_Boolean):
990             return r"\neg \left(%s\right)" % self._print(e.args[0])
991         else:
992             return r"\neg %s" % self._print(e.args[0])
993 
994     def _print_LogOp(self, args, char):
995         arg = args[0]
996         if arg.is_Boolean and not arg.is_Not:
997             tex = r"\left(%s\right)" % self._print(arg)
998         else:
999             tex = r"%s" % self._print(arg)
1000 
1001         for arg in args[1:]:
1002             if arg.is_Boolean and not arg.is_Not:
1003                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1004             else:
1005                 tex += r" %s %s" % (char, self._print(arg))
1006 
1007         return tex
1008 
1009     def _print_And(self, e):
1010         args = sorted(e.args, key=default_sort_key)
1011         return self._print_LogOp(args, r"\wedge")
1012 
1013     def _print_Or(self, e):
1014         args = sorted(e.args, key=default_sort_key)
1015         return self._print_LogOp(args, r"\vee")
1016 
1017     def _print_Xor(self, e):
1018         args = sorted(e.args, key=default_sort_key)
1019         return self._print_LogOp(args, r"\veebar")
1020 
1021     def _print_Implies(self, e, altchar=None):
1022         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1023 
1024     def _print_Equivalent(self, e, altchar=None):
1025         args = sorted(e.args, key=default_sort_key)
1026         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1027 
1028     def _print_conjugate(self, expr, exp=None):
1029         tex = r"\overline{%s}" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"%s^{%s}" % (tex, exp)
1033         else:
1034             return tex
1035 
1036     def _print_polar_lift(self, expr, exp=None):
1037         func = r"\operatorname{polar\_lift}"
1038         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"%s^{%s}%s" % (func, exp, arg)
1042         else:
1043             return r"%s%s" % (func, arg)
1044 
1045     def _print_ExpBase(self, expr, exp=None):
1046         # TODO should exp_polar be printed differently?
1047         #      what about exp_polar(0), exp_polar(1)?
1048         tex = r"e^{%s}" % self._print(expr.args[0])
1049         return self._do_exponent(tex, exp)
1050 
1051     def _print_elliptic_k(self, expr, exp=None):
1052         tex = r"\left(%s\right)" % self._print(expr.args[0])
1053         if exp is not None:
1054             return r"K^{%s}%s" % (exp, tex)
1055         else:
1056             return r"K%s" % tex
1057 
1058     def _print_elliptic_f(self, expr, exp=None):
1059         tex = r"\left(%s\middle| %s\right)" % \
1060             (self._print(expr.args[0]), self._print(expr.args[1]))
1061         if exp is not None:
1062             return r"F^{%s}%s" % (exp, tex)
1063         else:
1064             return r"F%s" % tex
1065 
1066     def _print_elliptic_e(self, expr, exp=None):
1067         if len(expr.args) == 2:
1068             tex = r"\left(%s\middle| %s\right)" % \
1069                 (self._print(expr.args[0]), self._print(expr.args[1]))
1070         else:
1071             tex = r"\left(%s\right)" % self._print(expr.args[0])
1072         if exp is not None:
1073             return r"E^{%s}%s" % (exp, tex)
1074         else:
1075             return r"E%s" % tex
1076 
1077     def _print_elliptic_pi(self, expr, exp=None):
1078         if len(expr.args) == 3:
1079             tex = r"\left(%s; %s\middle| %s\right)" % \
1080                 (self._print(expr.args[0]), self._print(expr.args[1]),
1081                  self._print(expr.args[2]))
1082         else:
1083             tex = r"\left(%s\middle| %s\right)" % \
1084                 (self._print(expr.args[0]), self._print(expr.args[1]))
1085         if exp is not None:
1086             return r"\Pi^{%s}%s" % (exp, tex)
1087         else:
1088             return r"\Pi%s" % tex
1089 
1090     def _print_beta(self, expr, exp=None):
1091         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1092                                         self._print(expr.args[1]))
1093 
1094         if exp is not None:
1095             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1096         else:
1097             return r"\operatorname{B}%s" % tex
1098 
1099     def _print_uppergamma(self, expr, exp=None):
1100         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1101                                         self._print(expr.args[1]))
1102 
1103         if exp is not None:
1104             return r"\Gamma^{%s}%s" % (exp, tex)
1105         else:
1106             return r"\Gamma%s" % tex
1107 
1108     def _print_lowergamma(self, expr, exp=None):
1109         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1110                                         self._print(expr.args[1]))
1111 
1112         if exp is not None:
1113             return r"\gamma^{%s}%s" % (exp, tex)
1114         else:
1115             return r"\gamma%s" % tex
1116 
1117     def _hprint_one_arg_func(self, expr, exp=None):
1118         tex = r"\left(%s\right)" % self._print(expr.args[0])
1119 
1120         if exp is not None:
1121             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1122         else:
1123             return r"%s%s" % (self._print(expr.func), tex)
1124 
1125     _print_gamma = _hprint_one_arg_func
1126 
1127     def _print_Chi(self, expr, exp=None):
1128         tex = r"\left(%s\right)" % self._print(expr.args[0])
1129 
1130         if exp is not None:
1131             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1132         else:
1133             return r"\operatorname{Chi}%s" % tex
1134 
1135     def _print_expint(self, expr, exp=None):
1136         tex = r"\left(%s\right)" % self._print(expr.args[1])
1137         nu = self._print(expr.args[0])
1138 
1139         if exp is not None:
1140             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1141         else:
1142             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1143 
1144     def _print_fresnels(self, expr, exp=None):
1145         tex = r"\left(%s\right)" % self._print(expr.args[0])
1146 
1147         if exp is not None:
1148             return r"S^{%s}%s" % (exp, tex)
1149         else:
1150             return r"S%s" % tex
1151 
1152     def _print_fresnelc(self, expr, exp=None):
1153         tex = r"\left(%s\right)" % self._print(expr.args[0])
1154 
1155         if exp is not None:
1156             return r"C^{%s}%s" % (exp, tex)
1157         else:
1158             return r"C%s" % tex
1159 
1160     def _print_subfactorial(self, expr, exp=None):
1161         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1162 
1163         if exp is not None:
1164             return r"\left(%s\right)^{%s}" % (tex, exp)
1165         else:
1166             return tex
1167 
1168     def _print_factorial(self, expr, exp=None):
1169         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1170 
1171         if exp is not None:
1172             return r"%s^{%s}" % (tex, exp)
1173         else:
1174             return tex
1175 
1176     def _print_factorial2(self, expr, exp=None):
1177         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1178 
1179         if exp is not None:
1180             return r"%s^{%s}" % (tex, exp)
1181         else:
1182             return tex
1183 
1184     def _print_binomial(self, expr, exp=None):
1185         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1186                                      self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"%s^{%s}" % (tex, exp)
1190         else:
1191             return tex
1192 
1193     def _print_RisingFactorial(self, expr, exp=None):
1194         n, k = expr.args
1195         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1196 
1197         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1198 
1199         return self._do_exponent(tex, exp)
1200 
1201     def _print_FallingFactorial(self, expr, exp=None):
1202         n, k = expr.args
1203         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1204 
1205         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1206 
1207         return self._do_exponent(tex, exp)
1208 
1209     def _hprint_BesselBase(self, expr, exp, sym):
1210         tex = r"%s" % (sym)
1211 
1212         need_exp = False
1213         if exp is not None:
1214             if tex.find('^') == -1:
1215                 tex = r"%s^{%s}" % (tex, self._print(exp))
1216             else:
1217                 need_exp = True
1218 
1219         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1220                                            self._print(expr.argument))
1221 
1222         if need_exp:
1223             tex = self._do_exponent(tex, exp)
1224         return tex
1225 
1226     def _hprint_vec(self, vec):
1227         if not vec:
1228             return ""
1229         s = ""
1230         for i in vec[:-1]:
1231             s += "%s, " % self._print(i)
1232         s += self._print(vec[-1])
1233         return s
1234 
1235     def _print_besselj(self, expr, exp=None):
1236         return self._hprint_BesselBase(expr, exp, 'J')
1237 
1238     def _print_besseli(self, expr, exp=None):
1239         return self._hprint_BesselBase(expr, exp, 'I')
1240 
1241     def _print_besselk(self, expr, exp=None):
1242         return self._hprint_BesselBase(expr, exp, 'K')
1243 
1244     def _print_bessely(self, expr, exp=None):
1245         return self._hprint_BesselBase(expr, exp, 'Y')
1246 
1247     def _print_yn(self, expr, exp=None):
1248         return self._hprint_BesselBase(expr, exp, 'y')
1249 
1250     def _print_jn(self, expr, exp=None):
1251         return self._hprint_BesselBase(expr, exp, 'j')
1252 
1253     def _print_hankel1(self, expr, exp=None):
1254         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1255 
1256     def _print_hankel2(self, expr, exp=None):
1257         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1258 
1259     def _print_hn1(self, expr, exp=None):
1260         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1261 
1262     def _print_hn2(self, expr, exp=None):
1263         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1264 
1265     def _hprint_airy(self, expr, exp=None, notation=""):
1266         tex = r"\left(%s\right)" % self._print(expr.args[0])
1267 
1268         if exp is not None:
1269             return r"%s^{%s}%s" % (notation, exp, tex)
1270         else:
1271             return r"%s%s" % (notation, tex)
1272 
1273     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1274         tex = r"\left(%s\right)" % self._print(expr.args[0])
1275 
1276         if exp is not None:
1277             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1278         else:
1279             return r"%s^\prime%s" % (notation, tex)
1280 
1281     def _print_airyai(self, expr, exp=None):
1282         return self._hprint_airy(expr, exp, 'Ai')
1283 
1284     def _print_airybi(self, expr, exp=None):
1285         return self._hprint_airy(expr, exp, 'Bi')
1286 
1287     def _print_airyaiprime(self, expr, exp=None):
1288         return self._hprint_airy_prime(expr, exp, 'Ai')
1289 
1290     def _print_airybiprime(self, expr, exp=None):
1291         return self._hprint_airy_prime(expr, exp, 'Bi')
1292 
1293     def _print_hyper(self, expr, exp=None):
1294         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1295               r"\middle| {%s} \right)}" % \
1296             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1297               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1298               self._print(expr.argument))
1299 
1300         if exp is not None:
1301             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1302         return tex
1303 
1304     def _print_meijerg(self, expr, exp=None):
1305         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1306               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1307             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1308               self._print(len(expr.bm)), self._print(len(expr.an)),
1309               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1310               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1311               self._print(expr.argument))
1312 
1313         if exp is not None:
1314             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1315         return tex
1316 
1317     def _print_dirichlet_eta(self, expr, exp=None):
1318         tex = r"\left(%s\right)" % self._print(expr.args[0])
1319         if exp is not None:
1320             return r"\eta^{%s}%s" % (self._print(exp), tex)
1321         return r"\eta%s" % tex
1322 
1323     def _print_zeta(self, expr, exp=None):
1324         if len(expr.args) == 2:
1325             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1326         else:
1327             tex = r"\left(%s\right)" % self._print(expr.args[0])
1328         if exp is not None:
1329             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1330         return r"\zeta%s" % tex
1331 
1332     def _print_stieltjes(self, expr, exp=None):
1333         if len(expr.args) == 2:
1334             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1335         else:
1336             tex = r"_{%s}" % self._print(expr.args[0])
1337         if exp is not None:
1338             return r"\gamma%s^{%s}" % (tex, self._print(exp))
1339         return r"\gamma%s" % tex
1340 
1341     def _print_lerchphi(self, expr, exp=None):
1342         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1343         if exp is None:
1344             return r"\Phi%s" % tex
1345         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1346 
1347     def _print_polylog(self, expr, exp=None):
1348         s, z = map(self._print, expr.args)
1349         tex = r"\left(%s\right)" % z
1350         if exp is None:
1351             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1352         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1353 
1354     def _print_jacobi(self, expr, exp=None):
1355         n, a, b, x = map(self._print, expr.args)
1356         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1357         if exp is not None:
1358             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1359         return tex
1360 
1361     def _print_gegenbauer(self, expr, exp=None):
1362         n, a, x = map(self._print, expr.args)
1363         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1364         if exp is not None:
1365             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1366         return tex
1367 
1368     def _print_chebyshevt(self, expr, exp=None):
1369         n, x = map(self._print, expr.args)
1370         tex = r"T_{%s}\left(%s\right)" % (n, x)
1371         if exp is not None:
1372             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1373         return tex
1374 
1375     def _print_chebyshevu(self, expr, exp=None):
1376         n, x = map(self._print, expr.args)
1377         tex = r"U_{%s}\left(%s\right)" % (n, x)
1378         if exp is not None:
1379             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1380         return tex
1381 
1382     def _print_legendre(self, expr, exp=None):
1383         n, x = map(self._print, expr.args)
1384         tex = r"P_{%s}\left(%s\right)" % (n, x)
1385         if exp is not None:
1386             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1387         return tex
1388 
1389     def _print_assoc_legendre(self, expr, exp=None):
1390         n, a, x = map(self._print, expr.args)
1391         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1392         if exp is not None:
1393             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1394         return tex
1395 
1396     def _print_hermite(self, expr, exp=None):
1397         n, x = map(self._print, expr.args)
1398         tex = r"H_{%s}\left(%s\right)" % (n, x)
1399         if exp is not None:
1400             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1401         return tex
1402 
1403     def _print_laguerre(self, expr, exp=None):
1404         n, x = map(self._print, expr.args)
1405         tex = r"L_{%s}\left(%s\right)" % (n, x)
1406         if exp is not None:
1407             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1408         return tex
1409 
1410     def _print_assoc_laguerre(self, expr, exp=None):
1411         n, a, x = map(self._print, expr.args)
1412         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1413         if exp is not None:
1414             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1415         return tex
1416 
1417     def _print_Ynm(self, expr, exp=None):
1418         n, m, theta, phi = map(self._print, expr.args)
1419         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1420         if exp is not None:
1421             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1422         return tex
1423 
1424     def _print_Znm(self, expr, exp=None):
1425         n, m, theta, phi = map(self._print, expr.args)
1426         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1427         if exp is not None:
1428             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1429         return tex
1430 
1431     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1432         a, q, z = map(self._print, args)
1433         sup = r"^{\prime}" if prime else ""
1434         exp = "" if not exp else "^{%s}" % self._print(exp)
1435         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1436 
1437     def _print_mathieuc(self, expr, exp=None):
1438         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1439 
1440     def _print_mathieus(self, expr, exp=None):
1441         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1442 
1443     def _print_mathieucprime(self, expr, exp=None):
1444         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1445 
1446     def _print_mathieusprime(self, expr, exp=None):
1447         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1448 
1449     def _print_Rational(self, expr):
1450         if expr.q != 1:
1451             sign = ""
1452             p = expr.p
1453             if expr.p < 0:
1454                 sign = "- "
1455                 p = -p
1456             if self._settings['fold_short_frac']:
1457                 return r"%s%d / %d" % (sign, p, expr.q)
1458             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1459         else:
1460             return self._print(expr.p)
1461 
1462     def _print_Order(self, expr):
1463         s = self._print(expr.expr)
1464         if expr.point and any(p != S.Zero for p in expr.point) or \
1465            len(expr.variables) > 1:
1466             s += '; '
1467             if len(expr.variables) > 1:
1468                 s += self._print(expr.variables)
1469             elif expr.variables:
1470                 s += self._print(expr.variables[0])
1471             s += r'\rightarrow '
1472             if len(expr.point) > 1:
1473                 s += self._print(expr.point)
1474             else:
1475                 s += self._print(expr.point[0])
1476         return r"O\left(%s\right)" % s
1477 
1478     def _print_Symbol(self, expr, style='plain'):
1479         if expr in self._settings['symbol_names']:
1480             return self._settings['symbol_names'][expr]
1481 
1482         result = self._deal_with_super_sub(expr.name) if \
1483             '\\' not in expr.name else expr.name
1484 
1485         if style == 'bold':
1486             result = r"\mathbf{{{}}}".format(result)
1487 
1488         return result
1489 
1490     _print_RandomSymbol = _print_Symbol
1491 
1492     def _deal_with_super_sub(self, string):
1493         if '{' in string:
1494             return string
1495 
1496         name, supers, subs = split_super_sub(string)
1497 
1498         name = translate(name)
1499         supers = [translate(sup) for sup in supers]
1500         subs = [translate(sub) for sub in subs]
1501 
1502         # glue all items together:
1503         if supers:
1504             name += "^{%s}" % " ".join(supers)
1505         if subs:
1506             name += "_{%s}" % " ".join(subs)
1507 
1508         return name
1509 
1510     def _print_Relational(self, expr):
1511         if self._settings['itex']:
1512             gt = r"\gt"
1513             lt = r"\lt"
1514         else:
1515             gt = ">"
1516             lt = "<"
1517 
1518         charmap = {
1519             "==": "=",
1520             ">": gt,
1521             "<": lt,
1522             ">=": r"\geq",
1523             "<=": r"\leq",
1524             "!=": r"\neq",
1525         }
1526 
1527         return "%s %s %s" % (self._print(expr.lhs),
1528                              charmap[expr.rel_op], self._print(expr.rhs))
1529 
1530     def _print_Piecewise(self, expr):
1531         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1532                    for e, c in expr.args[:-1]]
1533         if expr.args[-1].cond == true:
1534             ecpairs.append(r"%s & \text{otherwise}" %
1535                            self._print(expr.args[-1].expr))
1536         else:
1537             ecpairs.append(r"%s & \text{for}\: %s" %
1538                            (self._print(expr.args[-1].expr),
1539                             self._print(expr.args[-1].cond)))
1540         tex = r"\begin{cases} %s \end{cases}"
1541         return tex % r" \\".join(ecpairs)
1542 
1543     def _print_MatrixBase(self, expr):
1544         lines = []
1545 
1546         for line in range(expr.rows):  # horrible, should be 'rows'
1547             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1548 
1549         mat_str = self._settings['mat_str']
1550         if mat_str is None:
1551             if self._settings['mode'] == 'inline':
1552                 mat_str = 'smallmatrix'
1553             else:
1554                 if (expr.cols <= 10) is True:
1555                     mat_str = 'matrix'
1556                 else:
1557                     mat_str = 'array'
1558 
1559         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1560         out_str = out_str.replace('%MATSTR%', mat_str)
1561         if mat_str == 'array':
1562             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1563         if self._settings['mat_delim']:
1564             left_delim = self._settings['mat_delim']
1565             right_delim = self._delim_dict[left_delim]
1566             out_str = r'\left' + left_delim + out_str + \
1567                       r'\right' + right_delim
1568         return out_str % r"\\".join(lines)
1569     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1570                            = _print_Matrix \
1571                            = _print_MatrixBase
1572 
1573     def _print_MatrixElement(self, expr):
1574         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1575             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1576 
1577     def _print_MatrixSlice(self, expr):
1578         def latexslice(x):
1579             x = list(x)
1580             if x[2] == 1:
1581                 del x[2]
1582             if x[1] == x[0] + 1:
1583                 del x[1]
1584             if x[0] == 0:
1585                 x[0] = ''
1586             return ':'.join(map(self._print, x))
1587         return (self._print(expr.parent) + r'\left[' +
1588                 latexslice(expr.rowslice) + ', ' +
1589                 latexslice(expr.colslice) + r'\right]')
1590 
1591     def _print_BlockMatrix(self, expr):
1592         return self._print(expr.blocks)
1593 
1594     def _print_Transpose(self, expr):
1595         mat = expr.arg
1596         from sympy.matrices import MatrixSymbol
1597         if not isinstance(mat, MatrixSymbol):
1598             return r"\left(%s\right)^{T}" % self._print(mat)
1599         else:
1600             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1601 
1602     def _print_Trace(self, expr):
1603         mat = expr.arg
1604         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1605 
1606     def _print_Adjoint(self, expr):
1607         mat = expr.arg
1608         from sympy.matrices import MatrixSymbol
1609         if not isinstance(mat, MatrixSymbol):
1610             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1611         else:
1612             return r"%s^{\dagger}" % self._print(mat)
1613 
1614     def _print_MatMul(self, expr):
1615         from sympy import MatMul, Mul
1616 
1617         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1618                                              False)
1619 
1620         args = expr.args
1621         if isinstance(args[0], Mul):
1622             args = args[0].as_ordered_factors() + list(args[1:])
1623         else:
1624             args = list(args)
1625 
1626         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1627             if args[0] == -1:
1628                 args = args[1:]
1629             else:
1630                 args[0] = -args[0]
1631             return '- ' + ' '.join(map(parens, args))
1632         else:
1633             return ' '.join(map(parens, args))
1634 
1635     def _print_Mod(self, expr, exp=None):
1636         if exp is not None:
1637             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1638                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1639                                    strict=True), self._print(expr.args[1]),
1640                  self._print(exp))
1641         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1642                                  PRECEDENCE['Mul'], strict=True),
1643                                  self._print(expr.args[1]))
1644 
1645     def _print_HadamardProduct(self, expr):
1646         args = expr.args
1647         prec = PRECEDENCE['Pow']
1648         parens = self.parenthesize
1649 
1650         return r' \circ '.join(
1651             map(lambda arg: parens(arg, prec, strict=True), args))
1652 
1653     def _print_HadamardPower(self, expr):
1654         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1655             template = r"%s^{\circ \left({%s}\right)}"
1656         else:
1657             template = r"%s^{\circ {%s}}"
1658         return self._helper_print_standard_power(expr, template)
1659 
1660     def _print_KroneckerProduct(self, expr):
1661         args = expr.args
1662         prec = PRECEDENCE['Pow']
1663         parens = self.parenthesize
1664 
1665         return r' \otimes '.join(
1666             map(lambda arg: parens(arg, prec, strict=True), args))
1667 
1668     def _print_MatPow(self, expr):
1669         base, exp = expr.base, expr.exp
1670         from sympy.matrices import MatrixSymbol
1671         if not isinstance(base, MatrixSymbol):
1672             return "\\left(%s\\right)^{%s}" % (self._print(base),
1673                                               self._print(exp))
1674         else:
1675             return "%s^{%s}" % (self._print(base), self._print(exp))
1676 
1677     def _print_MatrixSymbol(self, expr):
1678         return self._print_Symbol(expr, style=self._settings[
1679             'mat_symbol_style'])
1680 
1681     def _print_ZeroMatrix(self, Z):
1682         return r"\mathbb{0}" if self._settings[
1683             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1684 
1685     def _print_OneMatrix(self, O):
1686         return r"\mathbb{1}" if self._settings[
1687             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1688 
1689     def _print_Identity(self, I):
1690         return r"\mathbb{I}" if self._settings[
1691             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1692 
1693     def _print_PermutationMatrix(self, P):
1694         perm_str = self._print(P.args[0])
1695         return "P_{%s}" % perm_str
1696 
1697     def _print_NDimArray(self, expr):
1698 
1699         if expr.rank() == 0:
1700             return self._print(expr[()])
1701 
1702         mat_str = self._settings['mat_str']
1703         if mat_str is None:
1704             if self._settings['mode'] == 'inline':
1705                 mat_str = 'smallmatrix'
1706             else:
1707                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1708                     mat_str = 'matrix'
1709                 else:
1710                     mat_str = 'array'
1711         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1712         block_str = block_str.replace('%MATSTR%', mat_str)
1713         if self._settings['mat_delim']:
1714             left_delim = self._settings['mat_delim']
1715             right_delim = self._delim_dict[left_delim]
1716             block_str = r'\left' + left_delim + block_str + \
1717                         r'\right' + right_delim
1718 
1719         if expr.rank() == 0:
1720             return block_str % ""
1721 
1722         level_str = [[]] + [[] for i in range(expr.rank())]
1723         shape_ranges = [list(range(i)) for i in expr.shape]
1724         for outer_i in itertools.product(*shape_ranges):
1725             level_str[-1].append(self._print(expr[outer_i]))
1726             even = True
1727             for back_outer_i in range(expr.rank()-1, -1, -1):
1728                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1729                     break
1730                 if even:
1731                     level_str[back_outer_i].append(
1732                         r" & ".join(level_str[back_outer_i+1]))
1733                 else:
1734                     level_str[back_outer_i].append(
1735                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1736                     if len(level_str[back_outer_i+1]) == 1:
1737                         level_str[back_outer_i][-1] = r"\left[" + \
1738                             level_str[back_outer_i][-1] + r"\right]"
1739                 even = not even
1740                 level_str[back_outer_i+1] = []
1741 
1742         out_str = level_str[0][0]
1743 
1744         if expr.rank() % 2 == 1:
1745             out_str = block_str % out_str
1746 
1747         return out_str
1748 
1749     _print_ImmutableDenseNDimArray = _print_NDimArray
1750     _print_ImmutableSparseNDimArray = _print_NDimArray
1751     _print_MutableDenseNDimArray = _print_NDimArray
1752     _print_MutableSparseNDimArray = _print_NDimArray
1753 
1754     def _printer_tensor_indices(self, name, indices, index_map={}):
1755         out_str = self._print(name)
1756         last_valence = None
1757         prev_map = None
1758         for index in indices:
1759             new_valence = index.is_up
1760             if ((index in index_map) or prev_map) and \
1761                     last_valence == new_valence:
1762                 out_str += ","
1763             if last_valence != new_valence:
1764                 if last_valence is not None:
1765                     out_str += "}"
1766                 if index.is_up:
1767                     out_str += "{}^{"
1768                 else:
1769                     out_str += "{}_{"
1770             out_str += self._print(index.args[0])
1771             if index in index_map:
1772                 out_str += "="
1773                 out_str += self._print(index_map[index])
1774                 prev_map = True
1775             else:
1776                 prev_map = False
1777             last_valence = new_valence
1778         if last_valence is not None:
1779             out_str += "}"
1780         return out_str
1781 
1782     def _print_Tensor(self, expr):
1783         name = expr.args[0].args[0]
1784         indices = expr.get_indices()
1785         return self._printer_tensor_indices(name, indices)
1786 
1787     def _print_TensorElement(self, expr):
1788         name = expr.expr.args[0].args[0]
1789         indices = expr.expr.get_indices()
1790         index_map = expr.index_map
1791         return self._printer_tensor_indices(name, indices, index_map)
1792 
1793     def _print_TensMul(self, expr):
1794         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1795         sign, args = expr._get_args_for_traditional_printer()
1796         return sign + "".join(
1797             [self.parenthesize(arg, precedence(expr)) for arg in args]
1798         )
1799 
1800     def _print_TensAdd(self, expr):
1801         a = []
1802         args = expr.args
1803         for x in args:
1804             a.append(self.parenthesize(x, precedence(expr)))
1805         a.sort()
1806         s = ' + '.join(a)
1807         s = s.replace('+ -', '- ')
1808         return s
1809 
1810     def _print_TensorIndex(self, expr):
1811         return "{}%s{%s}" % (
1812             "^" if expr.is_up else "_",
1813             self._print(expr.args[0])
1814         )
1815 
1816     def _print_PartialDerivative(self, expr):
1817         if len(expr.variables) == 1:
1818             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1819                 self._print(expr.variables[0]),
1820                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1821             )
1822         else:
1823             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1824                 len(expr.variables),
1825                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1826                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1827             )
1828 
1829     def _print_UniversalSet(self, expr):
1830         return r"\mathbb{U}"
1831 
1832     def _print_frac(self, expr, exp=None):
1833         if exp is None:
1834             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1835         else:
1836             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1837                     self._print(expr.args[0]), self._print(exp))
1838 
1839     def _print_tuple(self, expr):
1840         if self._settings['decimal_separator'] =='comma':
1841             return r"\left( %s\right)" % \
1842                 r"; \  ".join([self._print(i) for i in expr])
1843         elif self._settings['decimal_separator'] =='period':
1844             return r"\left( %s\right)" % \
1845                 r", \  ".join([self._print(i) for i in expr])
1846         else:
1847             raise ValueError('Unknown Decimal Separator')
1848 
1849     def _print_TensorProduct(self, expr):
1850         elements = [self._print(a) for a in expr.args]
1851         return r' \otimes '.join(elements)
1852 
1853     def _print_WedgeProduct(self, expr):
1854         elements = [self._print(a) for a in expr.args]
1855         return r' \wedge '.join(elements)
1856 
1857     def _print_Tuple(self, expr):
1858         return self._print_tuple(expr)
1859 
1860     def _print_list(self, expr):
1861         if self._settings['decimal_separator'] == 'comma':
1862             return r"\left[ %s\right]" % \
1863                 r"; \  ".join([self._print(i) for i in expr])
1864         elif self._settings['decimal_separator'] == 'period':
1865             return r"\left[ %s\right]" % \
1866                 r", \  ".join([self._print(i) for i in expr])
1867         else:
1868             raise ValueError('Unknown Decimal Separator')
1869 
1870 
1871     def _print_dict(self, d):
1872         keys = sorted(d.keys(), key=default_sort_key)
1873         items = []
1874 
1875         for key in keys:
1876             val = d[key]
1877             items.append("%s : %s" % (self._print(key), self._print(val)))
1878 
1879         return r"\left\{ %s\right\}" % r", \  ".join(items)
1880 
1881     def _print_Dict(self, expr):
1882         return self._print_dict(expr)
1883 
1884     def _print_DiracDelta(self, expr, exp=None):
1885         if len(expr.args) == 1 or expr.args[1] == 0:
1886             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1887         else:
1888             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1889                 self._print(expr.args[1]), self._print(expr.args[0]))
1890         if exp:
1891             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1892         return tex
1893 
1894     def _print_SingularityFunction(self, expr):
1895         shift = self._print(expr.args[0] - expr.args[1])
1896         power = self._print(expr.args[2])
1897         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1898         return tex
1899 
1900     def _print_Heaviside(self, expr, exp=None):
1901         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1902         if exp:
1903             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1904         return tex
1905 
1906     def _print_KroneckerDelta(self, expr, exp=None):
1907         i = self._print(expr.args[0])
1908         j = self._print(expr.args[1])
1909         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1910             tex = r'\delta_{%s %s}' % (i, j)
1911         else:
1912             tex = r'\delta_{%s, %s}' % (i, j)
1913         if exp is not None:
1914             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1915         return tex
1916 
1917     def _print_LeviCivita(self, expr, exp=None):
1918         indices = map(self._print, expr.args)
1919         if all(x.is_Atom for x in expr.args):
1920             tex = r'\varepsilon_{%s}' % " ".join(indices)
1921         else:
1922             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1923         if exp:
1924             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1925         return tex
1926 
1927     def _print_RandomDomain(self, d):
1928         if hasattr(d, 'as_boolean'):
1929             return '\\text{Domain: }' + self._print(d.as_boolean())
1930         elif hasattr(d, 'set'):
1931             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1932                     self._print(d.set))
1933         elif hasattr(d, 'symbols'):
1934             return '\\text{Domain on }' + self._print(d.symbols)
1935         else:
1936             return self._print(None)
1937 
1938     def _print_FiniteSet(self, s):
1939         items = sorted(s.args, key=default_sort_key)
1940         return self._print_set(items)
1941 
1942     def _print_set(self, s):
1943         items = sorted(s, key=default_sort_key)
1944         if self._settings['decimal_separator'] == 'comma':
1945             items = "; ".join(map(self._print, items))
1946         elif self._settings['decimal_separator'] == 'period':
1947             items = ", ".join(map(self._print, items))
1948         else:
1949             raise ValueError('Unknown Decimal Separator')
1950         return r"\left\{%s\right\}" % items
1951 
1952 
1953     _print_frozenset = _print_set
1954 
1955     def _print_Range(self, s):
1956         dots = r'\ldots'
1957 
1958         if s.has(Symbol):
1959             return self._print_Basic(s)
1960 
1961         if s.start.is_infinite and s.stop.is_infinite:
1962             if s.step.is_positive:
1963                 printset = dots, -1, 0, 1, dots
1964             else:
1965                 printset = dots, 1, 0, -1, dots
1966         elif s.start.is_infinite:
1967             printset = dots, s[-1] - s.step, s[-1]
1968         elif s.stop.is_infinite:
1969             it = iter(s)
1970             printset = next(it), next(it), dots
1971         elif len(s) > 4:
1972             it = iter(s)
1973             printset = next(it), next(it), dots, s[-1]
1974         else:
1975             printset = tuple(s)
1976 
1977         return (r"\left\{" +
1978                 r", ".join(self._print(el) for el in printset) +
1979                 r"\right\}")
1980 
1981     def __print_number_polynomial(self, expr, letter, exp=None):
1982         if len(expr.args) == 2:
1983             if exp is not None:
1984                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
1985                             self._print(expr.args[0]), self._print(exp),
1986                             self._print(expr.args[1]))
1987             return r"%s_{%s}\left(%s\right)" % (letter,
1988                         self._print(expr.args[0]), self._print(expr.args[1]))
1989 
1990         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
1991         if exp is not None:
1992             tex = r"%s^{%s}" % (tex, self._print(exp))
1993         return tex
1994 
1995     def _print_bernoulli(self, expr, exp=None):
1996         return self.__print_number_polynomial(expr, "B", exp)
1997 
1998     def _print_bell(self, expr, exp=None):
1999         if len(expr.args) == 3:
2000             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2001                                 self._print(expr.args[1]))
2002             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2003                                                el in expr.args[2])
2004             if exp is not None:
2005                 tex = r"%s^{%s}%s" % (tex1, self._print(exp), tex2)
2006             else:
2007                 tex = tex1 + tex2
2008             return tex
2009         return self.__print_number_polynomial(expr, "B", exp)
2010 
2011 
2012     def _print_fibonacci(self, expr, exp=None):
2013         return self.__print_number_polynomial(expr, "F", exp)
2014 
2015     def _print_lucas(self, expr, exp=None):
2016         tex = r"L_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_tribonacci(self, expr, exp=None):
2022         return self.__print_number_polynomial(expr, "T", exp)
2023 
2024     def _print_SeqFormula(self, s):
2025         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2026             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2027                 self._print(s.formula),
2028                 self._print(s.variables[0]),
2029                 self._print(s.start),
2030                 self._print(s.stop)
2031             )
2032         if s.start is S.NegativeInfinity:
2033             stop = s.stop
2034             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
2035                         s.coeff(stop - 1), s.coeff(stop))
2036         elif s.stop is S.Infinity or s.length > 4:
2037             printset = s[:4]
2038             printset.append(r'\ldots')
2039         else:
2040             printset = tuple(s)
2041 
2042         return (r"\left[" +
2043                 r", ".join(self._print(el) for el in printset) +
2044                 r"\right]")
2045 
2046     _print_SeqPer = _print_SeqFormula
2047     _print_SeqAdd = _print_SeqFormula
2048     _print_SeqMul = _print_SeqFormula
2049 
2050     def _print_Interval(self, i):
2051         if i.start == i.end:
2052             return r"\left\{%s\right\}" % self._print(i.start)
2053 
2054         else:
2055             if i.left_open:
2056                 left = '('
2057             else:
2058                 left = '['
2059 
2060             if i.right_open:
2061                 right = ')'
2062             else:
2063                 right = ']'
2064 
2065             return r"\left%s%s, %s\right%s" % \
2066                    (left, self._print(i.start), self._print(i.end), right)
2067 
2068     def _print_AccumulationBounds(self, i):
2069         return r"\left\langle %s, %s\right\rangle" % \
2070                 (self._print(i.min), self._print(i.max))
2071 
2072     def _print_Union(self, u):
2073         prec = precedence_traditional(u)
2074         args_str = [self.parenthesize(i, prec) for i in u.args]
2075         return r" \cup ".join(args_str)
2076 
2077     def _print_Complement(self, u):
2078         prec = precedence_traditional(u)
2079         args_str = [self.parenthesize(i, prec) for i in u.args]
2080         return r" \setminus ".join(args_str)
2081 
2082     def _print_Intersection(self, u):
2083         prec = precedence_traditional(u)
2084         args_str = [self.parenthesize(i, prec) for i in u.args]
2085         return r" \cap ".join(args_str)
2086 
2087     def _print_SymmetricDifference(self, u):
2088         prec = precedence_traditional(u)
2089         args_str = [self.parenthesize(i, prec) for i in u.args]
2090         return r" \triangle ".join(args_str)
2091 
2092     def _print_ProductSet(self, p):
2093         prec = precedence_traditional(p)
2094         if len(p.sets) >= 1 and not has_variety(p.sets):
2095             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2096         return r" \times ".join(
2097             self.parenthesize(set, prec) for set in p.sets)
2098 
2099     def _print_EmptySet(self, e):
2100         return r"\emptyset"
2101 
2102     def _print_Naturals(self, n):
2103         return r"\mathbb{N}"
2104 
2105     def _print_Naturals0(self, n):
2106         return r"\mathbb{N}_0"
2107 
2108     def _print_Integers(self, i):
2109         return r"\mathbb{Z}"
2110 
2111     def _print_Rationals(self, i):
2112         return r"\mathbb{Q}"
2113 
2114     def _print_Reals(self, i):
2115         return r"\mathbb{R}"
2116 
2117     def _print_Complexes(self, i):
2118         return r"\mathbb{C}"
2119 
2120     def _print_ImageSet(self, s):
2121         expr = s.lamda.expr
2122         sig = s.lamda.signature
2123         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2124         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2125         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2126 
2127     def _print_ConditionSet(self, s):
2128         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2129         if s.base_set is S.UniversalSet:
2130             return r"\left\{%s \mid %s \right\}" % \
2131                 (vars_print, self._print(s.condition))
2132 
2133         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2134             vars_print,
2135             vars_print,
2136             self._print(s.base_set),
2137             self._print(s.condition))
2138 
2139     def _print_ComplexRegion(self, s):
2140         vars_print = ', '.join([self._print(var) for var in s.variables])
2141         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2142             self._print(s.expr),
2143             vars_print,
2144             self._print(s.sets))
2145 
2146     def _print_Contains(self, e):
2147         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2148 
2149     def _print_FourierSeries(self, s):
2150         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
2151 
2152     def _print_FormalPowerSeries(self, s):
2153         return self._print_Add(s.infinite)
2154 
2155     def _print_FiniteField(self, expr):
2156         return r"\mathbb{F}_{%s}" % expr.mod
2157 
2158     def _print_IntegerRing(self, expr):
2159         return r"\mathbb{Z}"
2160 
2161     def _print_RationalField(self, expr):
2162         return r"\mathbb{Q}"
2163 
2164     def _print_RealField(self, expr):
2165         return r"\mathbb{R}"
2166 
2167     def _print_ComplexField(self, expr):
2168         return r"\mathbb{C}"
2169 
2170     def _print_PolynomialRing(self, expr):
2171         domain = self._print(expr.domain)
2172         symbols = ", ".join(map(self._print, expr.symbols))
2173         return r"%s\left[%s\right]" % (domain, symbols)
2174 
2175     def _print_FractionField(self, expr):
2176         domain = self._print(expr.domain)
2177         symbols = ", ".join(map(self._print, expr.symbols))
2178         return r"%s\left(%s\right)" % (domain, symbols)
2179 
2180     def _print_PolynomialRingBase(self, expr):
2181         domain = self._print(expr.domain)
2182         symbols = ", ".join(map(self._print, expr.symbols))
2183         inv = ""
2184         if not expr.is_Poly:
2185             inv = r"S_<^{-1}"
2186         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2187 
2188     def _print_Poly(self, poly):
2189         cls = poly.__class__.__name__
2190         terms = []
2191         for monom, coeff in poly.terms():
2192             s_monom = ''
2193             for i, exp in enumerate(monom):
2194                 if exp > 0:
2195                     if exp == 1:
2196                         s_monom += self._print(poly.gens[i])
2197                     else:
2198                         s_monom += self._print(pow(poly.gens[i], exp))
2199 
2200             if coeff.is_Add:
2201                 if s_monom:
2202                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2203                 else:
2204                     s_coeff = self._print(coeff)
2205             else:
2206                 if s_monom:
2207                     if coeff is S.One:
2208                         terms.extend(['+', s_monom])
2209                         continue
2210 
2211                     if coeff is S.NegativeOne:
2212                         terms.extend(['-', s_monom])
2213                         continue
2214 
2215                 s_coeff = self._print(coeff)
2216 
2217             if not s_monom:
2218                 s_term = s_coeff
2219             else:
2220                 s_term = s_coeff + " " + s_monom
2221 
2222             if s_term.startswith('-'):
2223                 terms.extend(['-', s_term[1:]])
2224             else:
2225                 terms.extend(['+', s_term])
2226 
2227         if terms[0] in ['-', '+']:
2228             modifier = terms.pop(0)
2229 
2230             if modifier == '-':
2231                 terms[0] = '-' + terms[0]
2232 
2233         expr = ' '.join(terms)
2234         gens = list(map(self._print, poly.gens))
2235         domain = "domain=%s" % self._print(poly.get_domain())
2236 
2237         args = ", ".join([expr] + gens + [domain])
2238         if cls in accepted_latex_functions:
2239             tex = r"\%s {\left(%s \right)}" % (cls, args)
2240         else:
2241             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2242 
2243         return tex
2244 
2245     def _print_ComplexRootOf(self, root):
2246         cls = root.__class__.__name__
2247         if cls == "ComplexRootOf":
2248             cls = "CRootOf"
2249         expr = self._print(root.expr)
2250         index = root.index
2251         if cls in accepted_latex_functions:
2252             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2253         else:
2254             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2255                                                                  index)
2256 
2257     def _print_RootSum(self, expr):
2258         cls = expr.__class__.__name__
2259         args = [self._print(expr.expr)]
2260 
2261         if expr.fun is not S.IdentityFunction:
2262             args.append(self._print(expr.fun))
2263 
2264         if cls in accepted_latex_functions:
2265             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2266         else:
2267             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2268                                                              ", ".join(args))
2269 
2270     def _print_PolyElement(self, poly):
2271         mul_symbol = self._settings['mul_symbol_latex']
2272         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2273 
2274     def _print_FracElement(self, frac):
2275         if frac.denom == 1:
2276             return self._print(frac.numer)
2277         else:
2278             numer = self._print(frac.numer)
2279             denom = self._print(frac.denom)
2280             return r"\frac{%s}{%s}" % (numer, denom)
2281 
2282     def _print_euler(self, expr, exp=None):
2283         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2284         tex = r"E_{%s}" % self._print(m)
2285         if exp is not None:
2286             tex = r"%s^{%s}" % (tex, self._print(exp))
2287         if x is not None:
2288             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2289         return tex
2290 
2291     def _print_catalan(self, expr, exp=None):
2292         tex = r"C_{%s}" % self._print(expr.args[0])
2293         if exp is not None:
2294             tex = r"%s^{%s}" % (tex, self._print(exp))
2295         return tex
2296 
2297     def _print_UnifiedTransform(self, expr, s, inverse=False):
2298         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2299 
2300     def _print_MellinTransform(self, expr):
2301         return self._print_UnifiedTransform(expr, 'M')
2302 
2303     def _print_InverseMellinTransform(self, expr):
2304         return self._print_UnifiedTransform(expr, 'M', True)
2305 
2306     def _print_LaplaceTransform(self, expr):
2307         return self._print_UnifiedTransform(expr, 'L')
2308 
2309     def _print_InverseLaplaceTransform(self, expr):
2310         return self._print_UnifiedTransform(expr, 'L', True)
2311 
2312     def _print_FourierTransform(self, expr):
2313         return self._print_UnifiedTransform(expr, 'F')
2314 
2315     def _print_InverseFourierTransform(self, expr):
2316         return self._print_UnifiedTransform(expr, 'F', True)
2317 
2318     def _print_SineTransform(self, expr):
2319         return self._print_UnifiedTransform(expr, 'SIN')
2320 
2321     def _print_InverseSineTransform(self, expr):
2322         return self._print_UnifiedTransform(expr, 'SIN', True)
2323 
2324     def _print_CosineTransform(self, expr):
2325         return self._print_UnifiedTransform(expr, 'COS')
2326 
2327     def _print_InverseCosineTransform(self, expr):
2328         return self._print_UnifiedTransform(expr, 'COS', True)
2329 
2330     def _print_DMP(self, p):
2331         try:
2332             if p.ring is not None:
2333                 # TODO incorporate order
2334                 return self._print(p.ring.to_sympy(p))
2335         except SympifyError:
2336             pass
2337         return self._print(repr(p))
2338 
2339     def _print_DMF(self, p):
2340         return self._print_DMP(p)
2341 
2342     def _print_Object(self, object):
2343         return self._print(Symbol(object.name))
2344 
2345     def _print_LambertW(self, expr):
2346         if len(expr.args) == 1:
2347             return r"W\left(%s\right)" % self._print(expr.args[0])
2348         return r"W_{%s}\left(%s\right)" % \
2349             (self._print(expr.args[1]), self._print(expr.args[0]))
2350 
2351     def _print_Morphism(self, morphism):
2352         domain = self._print(morphism.domain)
2353         codomain = self._print(morphism.codomain)
2354         return "%s\\rightarrow %s" % (domain, codomain)
2355 
2356     def _print_NamedMorphism(self, morphism):
2357         pretty_name = self._print(Symbol(morphism.name))
2358         pretty_morphism = self._print_Morphism(morphism)
2359         return "%s:%s" % (pretty_name, pretty_morphism)
2360 
2361     def _print_IdentityMorphism(self, morphism):
2362         from sympy.categories import NamedMorphism
2363         return self._print_NamedMorphism(NamedMorphism(
2364             morphism.domain, morphism.codomain, "id"))
2365 
2366     def _print_CompositeMorphism(self, morphism):
2367         # All components of the morphism have names and it is thus
2368         # possible to build the name of the composite.
2369         component_names_list = [self._print(Symbol(component.name)) for
2370                                 component in morphism.components]
2371         component_names_list.reverse()
2372         component_names = "\\circ ".join(component_names_list) + ":"
2373 
2374         pretty_morphism = self._print_Morphism(morphism)
2375         return component_names + pretty_morphism
2376 
2377     def _print_Category(self, morphism):
2378         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2379 
2380     def _print_Diagram(self, diagram):
2381         if not diagram.premises:
2382             # This is an empty diagram.
2383             return self._print(S.EmptySet)
2384 
2385         latex_result = self._print(diagram.premises)
2386         if diagram.conclusions:
2387             latex_result += "\\Longrightarrow %s" % \
2388                             self._print(diagram.conclusions)
2389 
2390         return latex_result
2391 
2392     def _print_DiagramGrid(self, grid):
2393         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2394 
2395         for i in range(grid.height):
2396             for j in range(grid.width):
2397                 if grid[i, j]:
2398                     latex_result += latex(grid[i, j])
2399                 latex_result += " "
2400                 if j != grid.width - 1:
2401                     latex_result += "& "
2402 
2403             if i != grid.height - 1:
2404                 latex_result += "\\\\"
2405             latex_result += "\n"
2406 
2407         latex_result += "\\end{array}\n"
2408         return latex_result
2409 
2410     def _print_FreeModule(self, M):
2411         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2412 
2413     def _print_FreeModuleElement(self, m):
2414         # Print as row vector for convenience, for now.
2415         return r"\left[ {} \right]".format(",".join(
2416             '{' + self._print(x) + '}' for x in m))
2417 
2418     def _print_SubModule(self, m):
2419         return r"\left\langle {} \right\rangle".format(",".join(
2420             '{' + self._print(x) + '}' for x in m.gens))
2421 
2422     def _print_ModuleImplementedIdeal(self, m):
2423         return r"\left\langle {} \right\rangle".format(",".join(
2424             '{' + self._print(x) + '}' for [x] in m._module.gens))
2425 
2426     def _print_Quaternion(self, expr):
2427         # TODO: This expression is potentially confusing,
2428         # shall we print it as `Quaternion( ... )`?
2429         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2430              for i in expr.args]
2431         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2432         return " + ".join(a)
2433 
2434     def _print_QuotientRing(self, R):
2435         # TODO nicer fractions for few generators...
2436         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2437                  self._print(R.base_ideal))
2438 
2439     def _print_QuotientRingElement(self, x):
2440         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2441                  self._print(x.ring.base_ideal))
2442 
2443     def _print_QuotientModuleElement(self, m):
2444         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2445                  self._print(m.module.killed_module))
2446 
2447     def _print_QuotientModule(self, M):
2448         # TODO nicer fractions for few generators...
2449         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2450                  self._print(M.killed_module))
2451 
2452     def _print_MatrixHomomorphism(self, h):
2453         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2454             self._print(h.domain), self._print(h.codomain))
2455 
2456     def _print_BaseScalarField(self, field):
2457         string = field._coord_sys._names[field._index]
2458         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2459 
2460     def _print_BaseVectorField(self, field):
2461         string = field._coord_sys._names[field._index]
2462         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2463 
2464     def _print_Differential(self, diff):
2465         field = diff._form_field
2466         if hasattr(field, '_coord_sys'):
2467             string = field._coord_sys._names[field._index]
2468             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2469         else:
2470             string = self._print(field)
2471             return r'\operatorname{{d}}\left({}\right)'.format(string)
2472 
2473     def _print_Tr(self, p):
2474         # TODO: Handle indices
2475         contents = self._print(p.args[0])
2476         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2477 
2478     def _print_totient(self, expr, exp=None):
2479         if exp is not None:
2480             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2481                 (self._print(expr.args[0]), self._print(exp))
2482         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2483 
2484     def _print_reduced_totient(self, expr, exp=None):
2485         if exp is not None:
2486             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2487                 (self._print(expr.args[0]), self._print(exp))
2488         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2489 
2490     def _print_divisor_sigma(self, expr, exp=None):
2491         if len(expr.args) == 2:
2492             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2493                                                 (expr.args[1], expr.args[0])))
2494         else:
2495             tex = r"\left(%s\right)" % self._print(expr.args[0])
2496         if exp is not None:
2497             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2498         return r"\sigma%s" % tex
2499 
2500     def _print_udivisor_sigma(self, expr, exp=None):
2501         if len(expr.args) == 2:
2502             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2503                                                 (expr.args[1], expr.args[0])))
2504         else:
2505             tex = r"\left(%s\right)" % self._print(expr.args[0])
2506         if exp is not None:
2507             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2508         return r"\sigma^*%s" % tex
2509 
2510     def _print_primenu(self, expr, exp=None):
2511         if exp is not None:
2512             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2513                 (self._print(expr.args[0]), self._print(exp))
2514         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2515 
2516     def _print_primeomega(self, expr, exp=None):
2517         if exp is not None:
2518             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2519                 (self._print(expr.args[0]), self._print(exp))
2520         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 14:30:49.955 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 14:30:49.956 | INFO     | Search-only: skipping patch selection
2025-10-15 14:30:50.029 | INFO     | Task sympy__sympy-18477 completed successfully.
2025-10-15 14:30:50.030 | INFO     | No patch generated. You can try running ACR again.
