[
    {
        "rel_file_path": "sympy/physics/units/dimensions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.12/sympy/physics/units/dimensions.py",
        "start": 1,
        "end": 574,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Definition of physical dimensions.\n3 \n4 Unit systems will be constructed on top of these dimensions.\n5 \n6 Most of the examples in the doc use MKS system and are presented from the\n7 computer point of view: from a human point, adding length to time is not legal\n8 in MKS but it is in natural system; for a computer in natural system there is\n9 no time dimension (but a velocity dimension instead) - in the basis - so the\n10 question of adding time to length has no meaning.\n11 \"\"\"\n12 \n13 from typing import Dict as tDict\n14 \n15 import collections\n16 from functools import reduce\n17 \n18 from sympy.core.basic import Basic\n19 from sympy.core.containers import (Dict, Tuple)\n20 from sympy.core.singleton import S\n21 from sympy.core.sorting import default_sort_key\n22 from sympy.core.symbol import Symbol\n23 from sympy.core.sympify import sympify\n24 from sympy.matrices.dense import Matrix\n25 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n26 from sympy.core.expr import Expr\n27 from sympy.core.power import Pow\n28 \n29 \n30 class _QuantityMapper:\n31 \n32     _quantity_scale_factors_global = {}  # type: tDict[Expr, Expr]\n33     _quantity_dimensional_equivalence_map_global = {}  # type: tDict[Expr, Expr]\n34     _quantity_dimension_global = {}  # type: tDict[Expr, Expr]\n35 \n36     def __init__(self, *args, **kwargs):\n37         self._quantity_dimension_map = {}\n38         self._quantity_scale_factors = {}\n39 \n40     def set_quantity_dimension(self, unit, dimension):\n41         from sympy.physics.units import Quantity\n42         dimension = sympify(dimension)\n43         if not isinstance(dimension, Dimension):\n44             if dimension == 1:\n45                 dimension = Dimension(1)\n46             else:\n47                 raise ValueError(\"expected dimension or 1\")\n48         elif isinstance(dimension, Quantity):\n49             dimension = self.get_quantity_dimension(dimension)\n50         self._quantity_dimension_map[unit] = dimension\n51 \n52     def set_quantity_scale_factor(self, unit, scale_factor):\n53         from sympy.physics.units import Quantity\n54         from sympy.physics.units.prefixes import Prefix\n55         scale_factor = sympify(scale_factor)\n56         # replace all prefixes by their ratio to canonical units:\n57         scale_factor = scale_factor.replace(\n58             lambda x: isinstance(x, Prefix),\n59             lambda x: x.scale_factor\n60         )\n61         # replace all quantities by their ratio to canonical units:\n62         scale_factor = scale_factor.replace(\n63             lambda x: isinstance(x, Quantity),\n64             lambda x: self.get_quantity_scale_factor(x)\n65         )\n66         self._quantity_scale_factors[unit] = scale_factor\n67 \n68     def get_quantity_dimension(self, unit):\n69         from sympy.physics.units import Quantity\n70         # First look-up the local dimension map, then the global one:\n71         if unit in self._quantity_dimension_map:\n72             return self._quantity_dimension_map[unit]\n73         if unit in self._quantity_dimension_global:\n74             return self._quantity_dimension_global[unit]\n75         if unit in self._quantity_dimensional_equivalence_map_global:\n76             dep_unit = self._quantity_dimensional_equivalence_map_global[unit]\n77             if isinstance(dep_unit, Quantity):\n78                 return self.get_quantity_dimension(dep_unit)\n79             else:\n80                 return Dimension(self.get_dimensional_expr(dep_unit))\n81         if isinstance(unit, Quantity):\n82             return Dimension(unit.name)\n83         else:\n84             return Dimension(1)\n85 \n86     def get_quantity_scale_factor(self, unit):\n87         if unit in self._quantity_scale_factors:\n88             return self._quantity_scale_factors[unit]\n89         if unit in self._quantity_scale_factors_global:\n90             mul_factor, other_unit = self._quantity_scale_factors_global[unit]\n91             return mul_factor*self.get_quantity_scale_factor(other_unit)\n92         return S.One\n93 \n94 \n95 class Dimension(Expr):\n96     \"\"\"\n97     This class represent the dimension of a physical quantities.\n98 \n99     The ``Dimension`` constructor takes as parameters a name and an optional\n100     symbol.\n101 \n102     For example, in classical mechanics we know that time is different from\n103     temperature and dimensions make this difference (but they do not provide\n104     any measure of these quantites.\n105 \n106         >>> from sympy.physics.units import Dimension\n107         >>> length = Dimension('length')\n108         >>> length\n109         Dimension(length)\n110         >>> time = Dimension('time')\n111         >>> time\n112         Dimension(time)\n113 \n114     Dimensions can be composed using multiplication, division and\n115     exponentiation (by a number) to give new dimensions. Addition and\n116     subtraction is defined only when the two objects are the same dimension.\n117 \n118         >>> velocity = length / time\n119         >>> velocity\n120         Dimension(length/time)\n121 \n122     It is possible to use a dimension system object to get the dimensionsal\n123     dependencies of a dimension, for example the dimension system used by the\n124     SI units convention can be used:\n125 \n126         >>> from sympy.physics.units.systems.si import dimsys_SI\n127         >>> dimsys_SI.get_dimensional_dependencies(velocity)\n128         {Dimension(length, L): 1, Dimension(time, T): -1}\n129         >>> length + length\n130         Dimension(length)\n131         >>> l2 = length**2\n132         >>> l2\n133         Dimension(length**2)\n134         >>> dimsys_SI.get_dimensional_dependencies(l2)\n135         {Dimension(length, L): 2}\n136 \n137     \"\"\"\n138 \n139     _op_priority = 13.0\n140 \n141     # XXX: This doesn't seem to be used anywhere...\n142     _dimensional_dependencies = {}  # type: ignore\n143 \n144     is_commutative = True\n145     is_number = False\n146     # make sqrt(M**2) --> M\n147     is_positive = True\n148     is_real = True\n149 \n150     def __new__(cls, name, symbol=None):\n151 \n152         if isinstance(name, str):\n153             name = Symbol(name)\n154         else:\n155             name = sympify(name)\n156 \n157         if not isinstance(name, Expr):\n158             raise TypeError(\"Dimension name needs to be a valid math expression\")\n159 \n160         if isinstance(symbol, str):\n161             symbol = Symbol(symbol)\n162         elif symbol is not None:\n163             assert isinstance(symbol, Symbol)\n164 \n165         obj = Expr.__new__(cls, name)\n166 \n167         obj._name = name\n168         obj._symbol = symbol\n169         return obj\n170 \n171     @property\n172     def name(self):\n173         return self._name\n174 \n175     @property\n176     def symbol(self):\n177         return self._symbol\n178 \n179     def __str__(self):\n180         \"\"\"\n181         Display the string representation of the dimension.\n182         \"\"\"\n183         if self.symbol is None:\n184             return \"Dimension(%s)\" % (self.name)\n185         else:\n186             return \"Dimension(%s, %s)\" % (self.name, self.symbol)\n187 \n188     def __repr__(self):\n189         return self.__str__()\n190 \n191     def __neg__(self):\n192         return self\n193 \n194     def __add__(self, other):\n195         from sympy.physics.units.quantities import Quantity\n196         other = sympify(other)\n197         if isinstance(other, Basic):\n198             if other.has(Quantity):\n199                 raise TypeError(\"cannot sum dimension and quantity\")\n200             if isinstance(other, Dimension) and self == other:\n201                 return self\n202             return super().__add__(other)\n203         return self\n204 \n205     def __radd__(self, other):\n206         return self.__add__(other)\n207 \n208     def __sub__(self, other):\n209         # there is no notion of ordering (or magnitude) among dimension,\n210         # subtraction is equivalent to addition when the operation is legal\n211         return self + other\n212 \n213     def __rsub__(self, other):\n214         # there is no notion of ordering (or magnitude) among dimension,\n215         # subtraction is equivalent to addition when the operation is legal\n216         return self + other\n217 \n218     def __pow__(self, other):\n219         return self._eval_power(other)\n220 \n221     def _eval_power(self, other):\n222         other = sympify(other)\n223         return Dimension(self.name**other)\n224 \n225     def __mul__(self, other):\n226         from sympy.physics.units.quantities import Quantity\n227         if isinstance(other, Basic):\n228             if other.has(Quantity):\n229                 raise TypeError(\"cannot sum dimension and quantity\")\n230             if isinstance(other, Dimension):\n231                 return Dimension(self.name*other.name)\n232             if not other.free_symbols:  # other.is_number cannot be used\n233                 return self\n234             return super().__mul__(other)\n235         return self\n236 \n237     def __rmul__(self, other):\n238         return self.__mul__(other)\n239 \n240     def __truediv__(self, other):\n241         return self*Pow(other, -1)\n242 \n243     def __rtruediv__(self, other):\n244         return other * pow(self, -1)\n245 \n246     @classmethod\n247     def _from_dimensional_dependencies(cls, dependencies):\n248         return reduce(lambda x, y: x * y, (\n249             d**e for d, e in dependencies.items()\n250         ), 1)\n251 \n252     def has_integer_powers(self, dim_sys):\n253         \"\"\"\n254         Check if the dimension object has only integer powers.\n255 \n256         All the dimension powers should be integers, but rational powers may\n257         appear in intermediate steps. This method may be used to check that the\n258         final result is well-defined.\n259         \"\"\"\n260 \n261         return all(dpow.is_Integer for dpow in dim_sys.get_dimensional_dependencies(self).values())\n262 \n263 \n264 # Create dimensions according to the base units in MKSA.\n265 # For other unit systems, they can be derived by transforming the base\n266 # dimensional dependency dictionary.\n267 \n268 \n269 class DimensionSystem(Basic, _QuantityMapper):\n270     r\"\"\"\n271     DimensionSystem represents a coherent set of dimensions.\n272 \n273     The constructor takes three parameters:\n274 \n275     - base dimensions;\n276     - derived dimensions: these are defined in terms of the base dimensions\n277       (for example velocity is defined from the division of length by time);\n278     - dependency of dimensions: how the derived dimensions depend\n279       on the base dimensions.\n280 \n281     Optionally either the ``derived_dims`` or the ``dimensional_dependencies``\n282     may be omitted.\n283     \"\"\"\n284 \n285     def __new__(cls, base_dims, derived_dims=(), dimensional_dependencies={}):\n286         dimensional_dependencies = dict(dimensional_dependencies)\n287 \n288         def parse_dim(dim):\n289             if isinstance(dim, str):\n290                 dim = Dimension(Symbol(dim))\n291             elif isinstance(dim, Dimension):\n292                 pass\n293             elif isinstance(dim, Symbol):\n294                 dim = Dimension(dim)\n295             else:\n296                 raise TypeError(\"%s wrong type\" % dim)\n297             return dim\n298 \n299         base_dims = [parse_dim(i) for i in base_dims]\n300         derived_dims = [parse_dim(i) for i in derived_dims]\n301 \n302         for dim in base_dims:\n303             if (dim in dimensional_dependencies\n304                 and (len(dimensional_dependencies[dim]) != 1 or\n305                 dimensional_dependencies[dim].get(dim, None) != 1)):\n306                 raise IndexError(\"Repeated value in base dimensions\")\n307             dimensional_dependencies[dim] = Dict({dim: 1})\n308 \n309         def parse_dim_name(dim):\n310             if isinstance(dim, Dimension):\n311                 return dim\n312             elif isinstance(dim, str):\n313                 return Dimension(Symbol(dim))\n314             elif isinstance(dim, Symbol):\n315                 return Dimension(dim)\n316             else:\n317                 raise TypeError(\"unrecognized type %s for %s\" % (type(dim), dim))\n318 \n319         for dim in dimensional_dependencies.keys():\n320             dim = parse_dim(dim)\n321             if (dim not in derived_dims) and (dim not in base_dims):\n322                 derived_dims.append(dim)\n323 \n324         def parse_dict(d):\n325             return Dict({parse_dim_name(i): j for i, j in d.items()})\n326 \n327         # Make sure everything is a SymPy type:\n328         dimensional_dependencies = {parse_dim_name(i): parse_dict(j) for i, j in\n329                                     dimensional_dependencies.items()}\n330 \n331         for dim in derived_dims:\n332             if dim in base_dims:\n333                 raise ValueError(\"Dimension %s both in base and derived\" % dim)\n334             if dim not in dimensional_dependencies:\n335                 # TODO: should this raise a warning?\n336                 dimensional_dependencies[dim] = Dict({dim: 1})\n337 \n338         base_dims.sort(key=default_sort_key)\n339         derived_dims.sort(key=default_sort_key)\n340 \n341         base_dims = Tuple(*base_dims)\n342         derived_dims = Tuple(*derived_dims)\n343         dimensional_dependencies = Dict({i: Dict(j) for i, j in dimensional_dependencies.items()})\n344         obj = Basic.__new__(cls, base_dims, derived_dims, dimensional_dependencies)\n345         return obj\n346 \n347     @property\n348     def base_dims(self):\n349         return self.args[0]\n350 \n351     @property\n352     def derived_dims(self):\n353         return self.args[1]\n354 \n355     @property\n356     def dimensional_dependencies(self):\n357         return self.args[2]\n358 \n359     def _get_dimensional_dependencies_for_name(self, dimension):\n360         if isinstance(dimension, str):\n361             dimension = Dimension(Symbol(dimension))\n362         elif not isinstance(dimension, Dimension):\n363             dimension = Dimension(dimension)\n364 \n365         if dimension.name.is_Symbol:\n366             # Dimensions not included in the dependencies are considered\n367             # as base dimensions:\n368             return dict(self.dimensional_dependencies.get(dimension, {dimension: 1}))\n369 \n370         if dimension.name.is_number or dimension.name.is_NumberSymbol:\n371             return {}\n372 \n373         get_for_name = self._get_dimensional_dependencies_for_name\n374 \n375         if dimension.name.is_Mul:\n376             ret = collections.defaultdict(int)\n377             dicts = [get_for_name(i) for i in dimension.name.args]\n378             for d in dicts:\n379                 for k, v in d.items():\n380                     ret[k] += v\n381             return {k: v for (k, v) in ret.items() if v != 0}\n382 \n383         if dimension.name.is_Add:\n384             dicts = [get_for_name(i) for i in dimension.name.args]\n385             if all(d == dicts[0] for d in dicts[1:]):\n386                 return dicts[0]\n387             raise TypeError(\"Only equivalent dimensions can be added or subtracted.\")\n388 \n389         if dimension.name.is_Pow:\n390             dim_base = get_for_name(dimension.name.base)\n391             dim_exp = get_for_name(dimension.name.exp)\n392             if dim_exp == {} or dimension.name.exp.is_Symbol:\n393                 return {k: v * dimension.name.exp for (k, v) in dim_base.items()}\n394             else:\n395                 raise TypeError(\"The exponent for the power operator must be a Symbol or dimensionless.\")\n396 \n397         if dimension.name.is_Function:\n398             args = (Dimension._from_dimensional_dependencies(\n399                 get_for_name(arg)) for arg in dimension.name.args)\n400             result = dimension.name.func(*args)\n401 \n402             dicts = [get_for_name(i) for i in dimension.name.args]\n403 \n404             if isinstance(result, Dimension):\n405                 return self.get_dimensional_dependencies(result)\n406             elif result.func == dimension.name.func:\n407                 if isinstance(dimension.name, TrigonometricFunction):\n408                     if dicts[0] in ({}, {Dimension('angle'): 1}):\n409                         return {}\n410                     else:\n411                         raise TypeError(\"The input argument for the function {} must be dimensionless or have dimensions of angle.\".format(dimension.func))\n412                 else:\n413                     if all(item == {} for item in dicts):\n414                         return {}\n415                     else:\n416                         raise TypeError(\"The input arguments for the function {} must be dimensionless.\".format(dimension.func))\n417             else:\n418                 return get_for_name(result)\n419 \n420         raise TypeError(\"Type {} not implemented for get_dimensional_dependencies\".format(type(dimension.name)))\n421 \n422     def get_dimensional_dependencies(self, name, mark_dimensionless=False):\n423         dimdep = self._get_dimensional_dependencies_for_name(name)\n424         if mark_dimensionless and dimdep == {}:\n425             return {Dimension(1): 1}\n426         return {k: v for k, v in dimdep.items()}\n427 \n428     def equivalent_dims(self, dim1, dim2):\n429         deps1 = self.get_dimensional_dependencies(dim1)\n430         deps2 = self.get_dimensional_dependencies(dim2)\n431         return deps1 == deps2\n432 \n433     def extend(self, new_base_dims, new_derived_dims=(), new_dim_deps=None):\n434         deps = dict(self.dimensional_dependencies)\n435         if new_dim_deps:\n436             deps.update(new_dim_deps)\n437 \n438         new_dim_sys = DimensionSystem(\n439             tuple(self.base_dims) + tuple(new_base_dims),\n440             tuple(self.derived_dims) + tuple(new_derived_dims),\n441             deps\n442         )\n443         new_dim_sys._quantity_dimension_map.update(self._quantity_dimension_map)\n444         new_dim_sys._quantity_scale_factors.update(self._quantity_scale_factors)\n445         return new_dim_sys\n446 \n447     def is_dimensionless(self, dimension):\n448         \"\"\"\n449         Check if the dimension object really has a dimension.\n450 \n451         A dimension should have at least one component with non-zero power.\n452         \"\"\"\n453         if dimension.name == 1:\n454             return True\n455         return self.get_dimensional_dependencies(dimension) == {}\n456 \n457     @property\n458     def list_can_dims(self):\n459         \"\"\"\n460         Useless method, kept for compatibility with previous versions.\n461 \n462         DO NOT USE.\n463 \n464         List all canonical dimension names.\n465         \"\"\"\n466         dimset = set()\n467         for i in self.base_dims:\n468             dimset.update(set(self.get_dimensional_dependencies(i).keys()))\n469         return tuple(sorted(dimset, key=str))\n470 \n471     @property\n472     def inv_can_transf_matrix(self):\n473         \"\"\"\n474         Useless method, kept for compatibility with previous versions.\n475 \n476         DO NOT USE.\n477 \n478         Compute the inverse transformation matrix from the base to the\n479         canonical dimension basis.\n480 \n481         It corresponds to the matrix where columns are the vector of base\n482         dimensions in canonical basis.\n483 \n484         This matrix will almost never be used because dimensions are always\n485         defined with respect to the canonical basis, so no work has to be done\n486         to get them in this basis. Nonetheless if this matrix is not square\n487         (or not invertible) it means that we have chosen a bad basis.\n488         \"\"\"\n489         matrix = reduce(lambda x, y: x.row_join(y),\n490                         [self.dim_can_vector(d) for d in self.base_dims])\n491         return matrix\n492 \n493     @property\n494     def can_transf_matrix(self):\n495         \"\"\"\n496         Useless method, kept for compatibility with previous versions.\n497 \n498         DO NOT USE.\n499 \n500         Return the canonical transformation matrix from the canonical to the\n501         base dimension basis.\n502 \n503         It is the inverse of the matrix computed with inv_can_transf_matrix().\n504         \"\"\"\n505 \n506         #TODO: the inversion will fail if the system is inconsistent, for\n507         #      example if the matrix is not a square\n508         return reduce(lambda x, y: x.row_join(y),\n509                       [self.dim_can_vector(d) for d in sorted(self.base_dims, key=str)]\n510                       ).inv()\n511 \n512     def dim_can_vector(self, dim):\n513         \"\"\"\n514         Useless method, kept for compatibility with previous versions.\n515 \n516         DO NOT USE.\n517 \n518         Dimensional representation in terms of the canonical base dimensions.\n519         \"\"\"\n520 \n521         vec = []\n522         for d in self.list_can_dims:\n523             vec.append(self.get_dimensional_dependencies(dim).get(d, 0))\n524         return Matrix(vec)\n525 \n526     def dim_vector(self, dim):\n527         \"\"\"\n528         Useless method, kept for compatibility with previous versions.\n529 \n530         DO NOT USE.\n531 \n532 \n533         Vector representation in terms of the base dimensions.\n534         \"\"\"\n535         return self.can_transf_matrix * Matrix(self.dim_can_vector(dim))\n536 \n537     def print_dim_base(self, dim):\n538         \"\"\"\n539         Give the string expression of a dimension in term of the basis symbols.\n540         \"\"\"\n541         dims = self.dim_vector(dim)\n542         symbols = [i.symbol if i.symbol is not None else i.name for i in self.base_dims]\n543         res = S.One\n544         for (s, p) in zip(symbols, dims):\n545             res *= s**p\n546         return res\n547 \n548     @property\n549     def dim(self):\n550         \"\"\"\n551         Useless method, kept for compatibility with previous versions.\n552 \n553         DO NOT USE.\n554 \n555         Give the dimension of the system.\n556 \n557         That is return the number of dimensions forming the basis.\n558         \"\"\"\n559         return len(self.base_dims)\n560 \n561     @property\n562     def is_consistent(self):\n563         \"\"\"\n564         Useless method, kept for compatibility with previous versions.\n565 \n566         DO NOT USE.\n567 \n568         Check if the system is well defined.\n569         \"\"\"\n570 \n571         # not enough or too many base dimensions compared to independent\n572         # dimensions\n573         # in vector language: the set of vectors do not form a basis\n574         return self.inv_can_transf_matrix.is_square\n",
        "intended_behavior": "This code should ensure that expressions which are inherently dimensionless (or can be simplified to be dimensionless) are recognized as such before being passed to an exp function. Furthermore, it may require modification or enhancement to properly interact with exponential functions, possibly by preprocessing expressions to validate their dimensionality or by simplifying them to a recognizable dimensionless state. The key is to prevent passing dimensionally inconsistent arguments to exp."
    },
    {
        "rel_file_path": "sympy/physics/units/util.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.12/sympy/physics/units/util.py",
        "start": 1,
        "end": 256,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Several methods to simplify expressions involving unit objects.\n3 \"\"\"\n4 from functools import reduce\n5 from collections.abc import Iterable\n6 from typing import Optional\n7 \n8 from sympy import default_sort_key\n9 from sympy.core.add import Add\n10 from sympy.core.containers import Tuple\n11 from sympy.core.mul import Mul\n12 from sympy.core.power import Pow\n13 from sympy.core.sorting import ordered\n14 from sympy.core.sympify import sympify\n15 from sympy.matrices.common import NonInvertibleMatrixError\n16 from sympy.physics.units.dimensions import Dimension, DimensionSystem\n17 from sympy.physics.units.prefixes import Prefix\n18 from sympy.physics.units.quantities import Quantity\n19 from sympy.physics.units.unitsystem import UnitSystem\n20 from sympy.utilities.iterables import sift\n21 \n22 \n23 def _get_conversion_matrix_for_expr(expr, target_units, unit_system):\n24     from sympy.matrices.dense import Matrix\n25 \n26     dimension_system = unit_system.get_dimension_system()\n27 \n28     expr_dim = Dimension(unit_system.get_dimensional_expr(expr))\n29     dim_dependencies = dimension_system.get_dimensional_dependencies(expr_dim, mark_dimensionless=True)\n30     target_dims = [Dimension(unit_system.get_dimensional_expr(x)) for x in target_units]\n31     canon_dim_units = [i for x in target_dims for i in dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True)]\n32     canon_expr_units = {i for i in dim_dependencies}\n33 \n34     if not canon_expr_units.issubset(set(canon_dim_units)):\n35         return None\n36 \n37     seen = set()\n38     canon_dim_units = [i for i in canon_dim_units if not (i in seen or seen.add(i))]\n39 \n40     camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) for i in target_dims] for j in canon_dim_units])\n41     exprmat = Matrix([dim_dependencies.get(k, 0) for k in canon_dim_units])\n42 \n43     try:\n44         res_exponents = camat.solve(exprmat)\n45     except NonInvertibleMatrixError:\n46         return None\n47 \n48     return res_exponents\n49 \n50 \n51 def convert_to(expr, target_units, unit_system=\"SI\"):\n52     \"\"\"\n53     Convert ``expr`` to the same expression with all of its units and quantities\n54     represented as factors of ``target_units``, whenever the dimension is compatible.\n55 \n56     ``target_units`` may be a single unit/quantity, or a collection of\n57     units/quantities.\n58 \n59     Examples\n60     ========\n61 \n62     >>> from sympy.physics.units import speed_of_light, meter, gram, second, day\n63     >>> from sympy.physics.units import mile, newton, kilogram, atomic_mass_constant\n64     >>> from sympy.physics.units import kilometer, centimeter\n65     >>> from sympy.physics.units import gravitational_constant, hbar\n66     >>> from sympy.physics.units import convert_to\n67     >>> convert_to(mile, kilometer)\n68     25146*kilometer/15625\n69     >>> convert_to(mile, kilometer).n()\n70     1.609344*kilometer\n71     >>> convert_to(speed_of_light, meter/second)\n72     299792458*meter/second\n73     >>> convert_to(day, second)\n74     86400*second\n75     >>> 3*newton\n76     3*newton\n77     >>> convert_to(3*newton, kilogram*meter/second**2)\n78     3*kilogram*meter/second**2\n79     >>> convert_to(atomic_mass_constant, gram)\n80     1.660539060e-24*gram\n81 \n82     Conversion to multiple units:\n83 \n84     >>> convert_to(speed_of_light, [meter, second])\n85     299792458*meter/second\n86     >>> convert_to(3*newton, [centimeter, gram, second])\n87     300000*centimeter*gram/second**2\n88 \n89     Conversion to Planck units:\n90 \n91     >>> convert_to(atomic_mass_constant, [gravitational_constant, speed_of_light, hbar]).n()\n92     7.62963087839509e-20*hbar**0.5*speed_of_light**0.5/gravitational_constant**0.5\n93 \n94     \"\"\"\n95     from sympy.physics.units import UnitSystem\n96     unit_system = UnitSystem.get_unit_system(unit_system)\n97 \n98     if not isinstance(target_units, (Iterable, Tuple)):\n99         target_units = [target_units]\n100 \n101     if isinstance(expr, Add):\n102         return Add.fromiter(convert_to(i, target_units, unit_system)\n103             for i in expr.args)\n104 \n105     expr = sympify(expr)\n106     target_units = sympify(target_units)\n107 \n108     if not isinstance(expr, Quantity) and expr.has(Quantity):\n109         expr = expr.replace(lambda x: isinstance(x, Quantity),\n110             lambda x: x.convert_to(target_units, unit_system))\n111 \n112     def get_total_scale_factor(expr):\n113         if isinstance(expr, Mul):\n114             return reduce(lambda x, y: x * y,\n115                 [get_total_scale_factor(i) for i in expr.args])\n116         elif isinstance(expr, Pow):\n117             return get_total_scale_factor(expr.base) ** expr.exp\n118         elif isinstance(expr, Quantity):\n119             return unit_system.get_quantity_scale_factor(expr)\n120         return expr\n121 \n122     depmat = _get_conversion_matrix_for_expr(expr, target_units, unit_system)\n123     if depmat is None:\n124         return expr\n125 \n126     expr_scale_factor = get_total_scale_factor(expr)\n127     return expr_scale_factor * Mul.fromiter(\n128         (1/get_total_scale_factor(u)*u)**p for u, p in\n129         zip(target_units, depmat))\n130 \n131 \n132 def quantity_simplify(expr, across_dimensions: bool=False, unit_system=None):\n133     \"\"\"Return an equivalent expression in which prefixes are replaced\n134     with numerical values and all units of a given dimension are the\n135     unified in a canonical manner by default. `across_dimensions` allows\n136     for units of different dimensions to be simplified together.\n137 \n138     `unit_system` must be specified if `across_dimensions` is True.\n139 \n140     Examples\n141     ========\n142 \n143     >>> from sympy.physics.units.util import quantity_simplify\n144     >>> from sympy.physics.units.prefixes import kilo\n145     >>> from sympy.physics.units import foot, inch, joule, coulomb\n146     >>> quantity_simplify(kilo*foot*inch)\n147     250*foot**2/3\n148     >>> quantity_simplify(foot - 6*inch)\n149     foot/2\n150     >>> quantity_simplify(5*joule/coulomb, across_dimensions=True, unit_system=\"SI\")\n151     5*volt\n152     \"\"\"\n153 \n154     if expr.is_Atom or not expr.has(Prefix, Quantity):\n155         return expr\n156 \n157     # replace all prefixes with numerical values\n158     p = expr.atoms(Prefix)\n159     expr = expr.xreplace({p: p.scale_factor for p in p})\n160 \n161     # replace all quantities of given dimension with a canonical\n162     # quantity, chosen from those in the expression\n163     d = sift(expr.atoms(Quantity), lambda i: i.dimension)\n164     for k in d:\n165         if len(d[k]) == 1:\n166             continue\n167         v = list(ordered(d[k]))\n168         ref = v[0]/v[0].scale_factor\n169         expr = expr.xreplace({vi: ref*vi.scale_factor for vi in v[1:]})\n170 \n171     if across_dimensions:\n172         # combine quantities of different dimensions into a single\n173         # quantity that is equivalent to the original expression\n174 \n175         if unit_system is None:\n176             raise ValueError(\"unit_system must be specified if across_dimensions is True\")\n177 \n178         unit_system = UnitSystem.get_unit_system(unit_system)\n179         dimension_system: DimensionSystem = unit_system.get_dimension_system()\n180         dim_expr = unit_system.get_dimensional_expr(expr)\n181         dim_deps = dimension_system.get_dimensional_dependencies(dim_expr, mark_dimensionless=True)\n182 \n183         target_dimension: Optional[Dimension] = None\n184         for ds_dim, ds_dim_deps in dimension_system.dimensional_dependencies.items():\n185             if ds_dim_deps == dim_deps:\n186                 target_dimension = ds_dim\n187                 break\n188 \n189         if target_dimension is None:\n190             # if we can't find a target dimension, we can't do anything. unsure how to handle this case.\n191             return expr\n192 \n193         target_unit = unit_system.derived_units.get(target_dimension)\n194         if target_unit:\n195             expr = convert_to(expr, target_unit, unit_system)\n196 \n197     return expr\n198 \n199 \n200 def check_dimensions(expr, unit_system=\"SI\"):\n201     \"\"\"Return expr if units in addends have the same\n202     base dimensions, else raise a ValueError.\"\"\"\n203     # the case of adding a number to a dimensional quantity\n204     # is ignored for the sake of SymPy core routines, so this\n205     # function will raise an error now if such an addend is\n206     # found.\n207     # Also, when doing substitutions, multiplicative constants\n208     # might be introduced, so remove those now\n209 \n210     from sympy.physics.units import UnitSystem\n211     unit_system = UnitSystem.get_unit_system(unit_system)\n212 \n213     def addDict(dict1, dict2):\n214         \"\"\"Merge dictionaries by adding values of common keys and\n215         removing keys with value of 0.\"\"\"\n216         dict3 = {**dict1, **dict2}\n217         for key, value in dict3.items():\n218             if key in dict1 and key in dict2:\n219                    dict3[key] = value + dict1[key]\n220         return {key:val for key, val in dict3.items() if val != 0}\n221 \n222     adds = expr.atoms(Add)\n223     DIM_OF = unit_system.get_dimension_system().get_dimensional_dependencies\n224     for a in adds:\n225         deset = set()\n226         for ai in a.args:\n227             if ai.is_number:\n228                 deset.add(())\n229                 continue\n230             dims = []\n231             skip = False\n232             dimdict = {}\n233             for i in Mul.make_args(ai):\n234                 if i.has(Quantity):\n235                     i = Dimension(unit_system.get_dimensional_expr(i))\n236                 if i.has(Dimension):\n237                     dimdict = addDict(dimdict, DIM_OF(i))\n238                 elif i.free_symbols:\n239                     skip = True\n240                     break\n241             dims.extend(dimdict.items())\n242             if not skip:\n243                 deset.add(tuple(sorted(dims, key=default_sort_key)))\n244                 if len(deset) > 1:\n245                     raise ValueError(\n246                         \"addends have incompatible dimensions: {}\".format(deset))\n247 \n248     # clear multiplicative constants on Dimensions which may be\n249     # left after substitution\n250     reps = {}\n251     for m in expr.atoms(Mul):\n252         if any(isinstance(i, Dimension) for i in m.args):\n253             reps[m] = m.func(*[\n254                 i for i in m.args if not i.is_number])\n255 \n256     return expr.xreplace(reps)\n",
        "intended_behavior": "Enhance the utility functions to more robustly identify and handle expressions, particularly looking out for scenarios where operations could lead to dimensionally ambiguous results in exponential contexts. This includes better detection of dimensionless quantities or more aggressive simplification strategies to ensure that expressions going into exponential functions do not carry erroneous or incompatible dimensions."
    },
    {
        "rel_file_path": "sympy/physics/units/systems/si.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.12/sympy/physics/units/systems/si.py",
        "start": 1,
        "end": 373,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 SI unit system.\n3 Based on MKSA, which stands for \"meter, kilogram, second, ampere\".\n4 Added kelvin, candela and mole.\n5 \n6 \"\"\"\n7 \n8 from typing import List\n9 \n10 from sympy.physics.units import DimensionSystem, Dimension, dHg0\n11 \n12 from sympy.physics.units.quantities import Quantity\n13 \n14 from sympy.core.numbers import (Rational, pi)\n15 from sympy.core.singleton import S\n16 from sympy.functions.elementary.miscellaneous import sqrt\n17 from sympy.physics.units.definitions.dimension_definitions import (\n18     acceleration, action, current, impedance, length, mass, time, velocity,\n19     amount_of_substance, temperature, information, frequency, force, pressure,\n20     energy, power, charge, voltage, capacitance, conductance, magnetic_flux,\n21     magnetic_density, inductance, luminous_intensity\n22 )\n23 from sympy.physics.units.definitions import (\n24     kilogram, newton, second, meter, gram, cd, K, joule, watt, pascal, hertz,\n25     coulomb, volt, ohm, siemens, farad, henry, tesla, weber, dioptre, lux,\n26     katal, gray, becquerel, inch, liter, julian_year, gravitational_constant,\n27     speed_of_light, elementary_charge, planck, hbar, electronvolt,\n28     avogadro_number, avogadro_constant, boltzmann_constant,\n29     stefan_boltzmann_constant, Da, atomic_mass_constant, molar_gas_constant,\n30     faraday_constant, josephson_constant, von_klitzing_constant,\n31     acceleration_due_to_gravity, magnetic_constant, vacuum_permittivity,\n32     vacuum_impedance, coulomb_constant, atmosphere, bar, pound, psi, mmHg,\n33     milli_mass_unit, quart, lightyear, astronomical_unit, planck_mass,\n34     planck_time, planck_temperature, planck_length, planck_charge, planck_area,\n35     planck_volume, planck_momentum, planck_energy, planck_force, planck_power,\n36     planck_density, planck_energy_density, planck_intensity,\n37     planck_angular_frequency, planck_pressure, planck_current, planck_voltage,\n38     planck_impedance, planck_acceleration, bit, byte, kibibyte, mebibyte,\n39     gibibyte, tebibyte, pebibyte, exbibyte, curie, rutherford, radian, degree,\n40     steradian, angular_mil, atomic_mass_unit, gee, kPa, ampere, u0, c, kelvin,\n41     mol, mole, candela, m, kg, s, electric_constant, G, boltzmann\n42 )\n43 from sympy.physics.units.prefixes import PREFIXES, prefix_unit\n44 from sympy.physics.units.systems.mksa import MKSA, dimsys_MKSA\n45 \n46 derived_dims = (frequency, force, pressure, energy, power, charge, voltage,\n47                 capacitance, conductance, magnetic_flux,\n48                 magnetic_density, inductance, luminous_intensity)\n49 base_dims = (amount_of_substance, luminous_intensity, temperature)\n50 \n51 units = [mol, cd, K, lux, hertz, newton, pascal, joule, watt, coulomb, volt,\n52         farad, ohm, siemens, weber, tesla, henry, candela, lux, becquerel,\n53         gray, katal]\n54 \n55 all_units = []  # type: List[Quantity]\n56 for u in units:\n57     all_units.extend(prefix_unit(u, PREFIXES))\n58 \n59 all_units.extend(units)\n60 all_units.extend([mol, cd, K, lux])\n61 \n62 \n63 dimsys_SI = dimsys_MKSA.extend(\n64     [\n65         # Dimensional dependencies for other base dimensions:\n66         temperature,\n67         amount_of_substance,\n68         luminous_intensity,\n69     ])\n70 \n71 dimsys_default = dimsys_SI.extend(\n72     [information],\n73 )\n74 \n75 SI = MKSA.extend(base=(mol, cd, K), units=all_units, name='SI', dimension_system=dimsys_SI, derived_units={\n76     power: watt,\n77     magnetic_flux: weber,\n78     time: second,\n79     impedance: ohm,\n80     pressure: pascal,\n81     current: ampere,\n82     voltage: volt,\n83     length: meter,\n84     frequency: hertz,\n85     inductance: henry,\n86     temperature: kelvin,\n87     amount_of_substance: mole,\n88     luminous_intensity: candela,\n89     conductance: siemens,\n90     mass: kilogram,\n91     magnetic_density: tesla,\n92     charge: coulomb,\n93     force: newton,\n94     capacitance: farad,\n95     energy: joule,\n96     velocity: meter/second,\n97 })\n98 \n99 One = S.One\n100 \n101 SI.set_quantity_dimension(radian, One)\n102 \n103 SI.set_quantity_scale_factor(ampere, One)\n104 \n105 SI.set_quantity_scale_factor(kelvin, One)\n106 \n107 SI.set_quantity_scale_factor(mole, One)\n108 \n109 SI.set_quantity_scale_factor(candela, One)\n110 \n111 # MKSA extension to MKS: derived units\n112 \n113 SI.set_quantity_scale_factor(coulomb, One)\n114 \n115 SI.set_quantity_scale_factor(volt, joule/coulomb)\n116 \n117 SI.set_quantity_scale_factor(ohm, volt/ampere)\n118 \n119 SI.set_quantity_scale_factor(siemens, ampere/volt)\n120 \n121 SI.set_quantity_scale_factor(farad, coulomb/volt)\n122 \n123 SI.set_quantity_scale_factor(henry, volt*second/ampere)\n124 \n125 SI.set_quantity_scale_factor(tesla, volt*second/meter**2)\n126 \n127 SI.set_quantity_scale_factor(weber, joule/ampere)\n128 \n129 \n130 SI.set_quantity_dimension(lux, luminous_intensity / length ** 2)\n131 SI.set_quantity_scale_factor(lux, steradian*candela/meter**2)\n132 \n133 # katal is the SI unit of catalytic activity\n134 \n135 SI.set_quantity_dimension(katal, amount_of_substance / time)\n136 SI.set_quantity_scale_factor(katal, mol/second)\n137 \n138 # gray is the SI unit of absorbed dose\n139 \n140 SI.set_quantity_dimension(gray, energy / mass)\n141 SI.set_quantity_scale_factor(gray, meter**2/second**2)\n142 \n143 # becquerel is the SI unit of radioactivity\n144 \n145 SI.set_quantity_dimension(becquerel, 1 / time)\n146 SI.set_quantity_scale_factor(becquerel, 1/second)\n147 \n148 #### CONSTANTS ####\n149 \n150 # elementary charge\n151 # REF: NIST SP 959 (June 2019)\n152 \n153 SI.set_quantity_dimension(elementary_charge, charge)\n154 SI.set_quantity_scale_factor(elementary_charge, 1.602176634e-19*coulomb)\n155 \n156 # Electronvolt\n157 # REF: NIST SP 959 (June 2019)\n158 \n159 SI.set_quantity_dimension(electronvolt, energy)\n160 SI.set_quantity_scale_factor(electronvolt, 1.602176634e-19*joule)\n161 \n162 # Avogadro number\n163 # REF: NIST SP 959 (June 2019)\n164 \n165 SI.set_quantity_dimension(avogadro_number, One)\n166 SI.set_quantity_scale_factor(avogadro_number, 6.02214076e23)\n167 \n168 # Avogadro constant\n169 \n170 SI.set_quantity_dimension(avogadro_constant, amount_of_substance ** -1)\n171 SI.set_quantity_scale_factor(avogadro_constant, avogadro_number / mol)\n172 \n173 # Boltzmann constant\n174 # REF: NIST SP 959 (June 2019)\n175 \n176 SI.set_quantity_dimension(boltzmann_constant, energy / temperature)\n177 SI.set_quantity_scale_factor(boltzmann_constant, 1.380649e-23*joule/kelvin)\n178 \n179 # Stefan-Boltzmann constant\n180 # REF: NIST SP 959 (June 2019)\n181 \n182 SI.set_quantity_dimension(stefan_boltzmann_constant, energy * time ** -1 * length ** -2 * temperature ** -4)\n183 SI.set_quantity_scale_factor(stefan_boltzmann_constant, pi**2 * boltzmann_constant**4 / (60 * hbar**3 * speed_of_light ** 2))\n184 \n185 # Atomic mass\n186 # REF: NIST SP 959 (June 2019)\n187 \n188 SI.set_quantity_dimension(atomic_mass_constant, mass)\n189 SI.set_quantity_scale_factor(atomic_mass_constant, 1.66053906660e-24*gram)\n190 \n191 # Molar gas constant\n192 # REF: NIST SP 959 (June 2019)\n193 \n194 SI.set_quantity_dimension(molar_gas_constant, energy / (temperature * amount_of_substance))\n195 SI.set_quantity_scale_factor(molar_gas_constant, boltzmann_constant * avogadro_constant)\n196 \n197 # Faraday constant\n198 \n199 SI.set_quantity_dimension(faraday_constant, charge / amount_of_substance)\n200 SI.set_quantity_scale_factor(faraday_constant, elementary_charge * avogadro_constant)\n201 \n202 # Josephson constant\n203 \n204 SI.set_quantity_dimension(josephson_constant, frequency / voltage)\n205 SI.set_quantity_scale_factor(josephson_constant, 0.5 * planck / elementary_charge)\n206 \n207 # Von Klitzing constant\n208 \n209 SI.set_quantity_dimension(von_klitzing_constant, voltage / current)\n210 SI.set_quantity_scale_factor(von_klitzing_constant, hbar / elementary_charge ** 2)\n211 \n212 # Acceleration due to gravity (on the Earth surface)\n213 \n214 SI.set_quantity_dimension(acceleration_due_to_gravity, acceleration)\n215 SI.set_quantity_scale_factor(acceleration_due_to_gravity, 9.80665*meter/second**2)\n216 \n217 # magnetic constant:\n218 \n219 SI.set_quantity_dimension(magnetic_constant, force / current ** 2)\n220 SI.set_quantity_scale_factor(magnetic_constant, 4*pi/10**7 * newton/ampere**2)\n221 \n222 # electric constant:\n223 \n224 SI.set_quantity_dimension(vacuum_permittivity, capacitance / length)\n225 SI.set_quantity_scale_factor(vacuum_permittivity, 1/(u0 * c**2))\n226 \n227 # vacuum impedance:\n228 \n229 SI.set_quantity_dimension(vacuum_impedance, impedance)\n230 SI.set_quantity_scale_factor(vacuum_impedance, u0 * c)\n231 \n232 # Coulomb's constant:\n233 SI.set_quantity_dimension(coulomb_constant, force * length ** 2 / charge ** 2)\n234 SI.set_quantity_scale_factor(coulomb_constant, 1/(4*pi*vacuum_permittivity))\n235 \n236 SI.set_quantity_dimension(psi, pressure)\n237 SI.set_quantity_scale_factor(psi, pound * gee / inch ** 2)\n238 \n239 SI.set_quantity_dimension(mmHg, pressure)\n240 SI.set_quantity_scale_factor(mmHg, dHg0 * acceleration_due_to_gravity * kilogram / meter**2)\n241 \n242 SI.set_quantity_dimension(milli_mass_unit, mass)\n243 SI.set_quantity_scale_factor(milli_mass_unit, atomic_mass_unit/1000)\n244 \n245 SI.set_quantity_dimension(quart, length ** 3)\n246 SI.set_quantity_scale_factor(quart, Rational(231, 4) * inch**3)\n247 \n248 # Other convenient units and magnitudes\n249 \n250 SI.set_quantity_dimension(lightyear, length)\n251 SI.set_quantity_scale_factor(lightyear, speed_of_light*julian_year)\n252 \n253 SI.set_quantity_dimension(astronomical_unit, length)\n254 SI.set_quantity_scale_factor(astronomical_unit, 149597870691*meter)\n255 \n256 # Fundamental Planck units:\n257 \n258 SI.set_quantity_dimension(planck_mass, mass)\n259 SI.set_quantity_scale_factor(planck_mass, sqrt(hbar*speed_of_light/G))\n260 \n261 SI.set_quantity_dimension(planck_time, time)\n262 SI.set_quantity_scale_factor(planck_time, sqrt(hbar*G/speed_of_light**5))\n263 \n264 SI.set_quantity_dimension(planck_temperature, temperature)\n265 SI.set_quantity_scale_factor(planck_temperature, sqrt(hbar*speed_of_light**5/G/boltzmann**2))\n266 \n267 SI.set_quantity_dimension(planck_length, length)\n268 SI.set_quantity_scale_factor(planck_length, sqrt(hbar*G/speed_of_light**3))\n269 \n270 SI.set_quantity_dimension(planck_charge, charge)\n271 SI.set_quantity_scale_factor(planck_charge, sqrt(4*pi*electric_constant*hbar*speed_of_light))\n272 \n273 # Derived Planck units:\n274 \n275 SI.set_quantity_dimension(planck_area, length ** 2)\n276 SI.set_quantity_scale_factor(planck_area, planck_length**2)\n277 \n278 SI.set_quantity_dimension(planck_volume, length ** 3)\n279 SI.set_quantity_scale_factor(planck_volume, planck_length**3)\n280 \n281 SI.set_quantity_dimension(planck_momentum, mass * velocity)\n282 SI.set_quantity_scale_factor(planck_momentum, planck_mass * speed_of_light)\n283 \n284 SI.set_quantity_dimension(planck_energy, energy)\n285 SI.set_quantity_scale_factor(planck_energy, planck_mass * speed_of_light**2)\n286 \n287 SI.set_quantity_dimension(planck_force, force)\n288 SI.set_quantity_scale_factor(planck_force, planck_energy / planck_length)\n289 \n290 SI.set_quantity_dimension(planck_power, power)\n291 SI.set_quantity_scale_factor(planck_power, planck_energy / planck_time)\n292 \n293 SI.set_quantity_dimension(planck_density, mass / length ** 3)\n294 SI.set_quantity_scale_factor(planck_density, planck_mass / planck_length**3)\n295 \n296 SI.set_quantity_dimension(planck_energy_density, energy / length ** 3)\n297 SI.set_quantity_scale_factor(planck_energy_density, planck_energy / planck_length**3)\n298 \n299 SI.set_quantity_dimension(planck_intensity, mass * time ** (-3))\n300 SI.set_quantity_scale_factor(planck_intensity, planck_energy_density * speed_of_light)\n301 \n302 SI.set_quantity_dimension(planck_angular_frequency, 1 / time)\n303 SI.set_quantity_scale_factor(planck_angular_frequency, 1 / planck_time)\n304 \n305 SI.set_quantity_dimension(planck_pressure, pressure)\n306 SI.set_quantity_scale_factor(planck_pressure, planck_force / planck_length**2)\n307 \n308 SI.set_quantity_dimension(planck_current, current)\n309 SI.set_quantity_scale_factor(planck_current, planck_charge / planck_time)\n310 \n311 SI.set_quantity_dimension(planck_voltage, voltage)\n312 SI.set_quantity_scale_factor(planck_voltage, planck_energy / planck_charge)\n313 \n314 SI.set_quantity_dimension(planck_impedance, impedance)\n315 SI.set_quantity_scale_factor(planck_impedance, planck_voltage / planck_current)\n316 \n317 SI.set_quantity_dimension(planck_acceleration, acceleration)\n318 SI.set_quantity_scale_factor(planck_acceleration, speed_of_light / planck_time)\n319 \n320 # Older units for radioactivity\n321 \n322 SI.set_quantity_dimension(curie, 1 / time)\n323 SI.set_quantity_scale_factor(curie, 37000000000*becquerel)\n324 \n325 SI.set_quantity_dimension(rutherford, 1 / time)\n326 SI.set_quantity_scale_factor(rutherford, 1000000*becquerel)\n327 \n328 \n329 # check that scale factors are the right SI dimensions:\n330 for _scale_factor, _dimension in zip(\n331     SI._quantity_scale_factors.values(),\n332     SI._quantity_dimension_map.values()\n333 ):\n334     dimex = SI.get_dimensional_expr(_scale_factor)\n335     if dimex != 1:\n336         # XXX: equivalent_dims is an instance method taking two arguments in\n337         # addition to self so this can not work:\n338         if not DimensionSystem.equivalent_dims(_dimension, Dimension(dimex)):  # type: ignore\n339             raise ValueError(\"quantity value and dimension mismatch\")\n340 del _scale_factor, _dimension\n341 \n342 __all__ = [\n343     'mmHg', 'atmosphere', 'inductance', 'newton', 'meter',\n344     'vacuum_permittivity', 'pascal', 'magnetic_constant', 'voltage',\n345     'angular_mil', 'luminous_intensity', 'all_units',\n346     'julian_year', 'weber', 'exbibyte', 'liter',\n347     'molar_gas_constant', 'faraday_constant', 'avogadro_constant',\n348     'lightyear', 'planck_density', 'gee', 'mol', 'bit', 'gray',\n349     'planck_momentum', 'bar', 'magnetic_density', 'prefix_unit', 'PREFIXES',\n350     'planck_time', 'dimex', 'gram', 'candela', 'force', 'planck_intensity',\n351     'energy', 'becquerel', 'planck_acceleration', 'speed_of_light',\n352     'conductance', 'frequency', 'coulomb_constant', 'degree', 'lux', 'planck',\n353     'current', 'planck_current', 'tebibyte', 'planck_power', 'MKSA', 'power',\n354     'K', 'planck_volume', 'quart', 'pressure', 'amount_of_substance',\n355     'joule', 'boltzmann_constant', 'Dimension', 'c', 'planck_force', 'length',\n356     'watt', 'action', 'hbar', 'gibibyte', 'DimensionSystem', 'cd', 'volt',\n357     'planck_charge', 'dioptre', 'vacuum_impedance', 'dimsys_default', 'farad',\n358     'charge', 'gravitational_constant', 'temperature', 'u0', 'hertz',\n359     'capacitance', 'tesla', 'steradian', 'planck_mass', 'josephson_constant',\n360     'planck_area', 'stefan_boltzmann_constant', 'base_dims',\n361     'astronomical_unit', 'radian', 'planck_voltage', 'impedance',\n362     'planck_energy', 'Da', 'atomic_mass_constant', 'rutherford', 'second', 'inch',\n363     'elementary_charge', 'SI', 'electronvolt', 'dimsys_SI', 'henry',\n364     'planck_angular_frequency', 'ohm', 'pound', 'planck_pressure', 'G', 'psi',\n365     'dHg0', 'von_klitzing_constant', 'planck_length', 'avogadro_number',\n366     'mole', 'acceleration', 'information', 'planck_energy_density',\n367     'mebibyte', 's', 'acceleration_due_to_gravity',\n368     'planck_temperature', 'units', 'mass', 'dimsys_MKSA', 'kelvin', 'kPa',\n369     'boltzmann', 'milli_mass_unit', 'planck_impedance', 'electric_constant',\n370     'derived_dims', 'kg', 'coulomb', 'siemens', 'byte', 'magnetic_flux',\n371     'atomic_mass_unit', 'm', 'kibibyte', 'kilogram', 'One', 'curie', 'u',\n372     'time', 'pebibyte', 'velocity', 'ampere', 'katal',\n373 ]\n",
        "intended_behavior": "Ensure that the SI unit system's handling of dimensionality and unit operations conforms to mathematical standards, especially regarding exponentiation. This might involve specific checks or transformations when dealing with exponential operations to ensure that arguments are dimensionless when required."
    }
]