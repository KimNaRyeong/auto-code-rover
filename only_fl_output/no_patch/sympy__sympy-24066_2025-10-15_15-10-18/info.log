2025-10-15 15:10:18.996 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:10:28.373 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=233, output_tokens=12, cost=0.002690
2025-10-15 15:10:38.099 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=413, output_tokens=304, cost=0.013250
2025-10-15 15:10:40.138 | INFO     | registered non reproducing test 0
2025-10-15 15:10:52.479 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1152, output_tokens=443, cost=0.024810
2025-10-15 15:10:53.767 | INFO     | registered non reproducing test 1
2025-10-15 15:11:11.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1259, output_tokens=640, cost=0.031790
2025-10-15 15:11:13.098 | INFO     | registered non reproducing test 2
2025-10-15 15:11:13.098 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 15:11:13.104 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:11:22.876 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=542, output_tokens=249, cost=0.012890
2025-10-15 15:11:22.882 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:11:25.114 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=603, output_tokens=50, cost=0.007530
2025-10-15 15:11:25.116 | DEBUG    | Extracted a valid json.
2025-10-15 15:11:25.121 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"SI\")",
        "search_method_in_class(\"_collect_factor_and_dimension\", \"SI\")",
        "search_code(\"exp(\")"
    ],
    "bug_locations": []
}
2025-10-15 15:11:35.438 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:11:35.438 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:11:51.831 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4330, output_tokens=574, cost=0.060520
2025-10-15 15:11:51.837 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:12:08.041 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5120, output_tokens=609, cost=0.069470
2025-10-15 15:12:08.051 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:12:16.250 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=963, output_tokens=205, cost=0.015780
2025-10-15 15:12:16.251 | DEBUG    | Extracted a valid json.
2025-10-15 15:12:16.252 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"sympy.physics.units\")",
        "search_code(\"dimensionless\")",
        "search_code_in_file(\"exp(\", \"sympy/physics/units.py\")"
    ],
    "bug_locations": [
        {
            "file": "",
            "class": "",
            "method": "",
            "intended_behavior": "The code within this location should be adjusted to correctly handle expressions passed to exp() by either ensuring that the expression is dimensionally consistent (dimensionless) before attempting operations that require dimensionlessness or by implementing a more robust mechanism for handling units and dimensions in exponential functions. This involves enhancing the _collect_factor_and_dimension method (or equivalent functionality within the system) to correctly interpret and manage units in expressions passed to exponential functions, ensuring that any operations expecting dimensionless quantities are provided as such. Preserving the existing functionality of handling units and dimensions while introducing this more nuanced approach to dealing with exponential functions."
        }
    ]
}
2025-10-15 15:12:16.922 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:12:16.922 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:12:37.823 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6504, output_tokens=682, cost=0.085500
2025-10-15 15:12:37.830 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:12:55.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7402, output_tokens=586, cost=0.091600
2025-10-15 15:12:55.421 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:13:04.673 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=940, output_tokens=319, cost=0.018970
2025-10-15 15:13:04.674 | DEBUG    | Extracted a valid json.
2025-10-15 15:13:04.674 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/physics/units/dimensions.py",
            "class": "",
            "method": "",
            "intended_behavior": "This code should ensure that expressions which are inherently dimensionless (or can be simplified to be dimensionless) are recognized as such before being passed to an exp function. Furthermore, it may require modification or enhancement to properly interact with exponential functions, possibly by preprocessing expressions to validate their dimensionality or by simplifying them to a recognizable dimensionless state. The key is to prevent passing dimensionally inconsistent arguments to exp."
        },
        {
            "file": "sympy/physics/units/util.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance the utility functions to more robustly identify and handle expressions, particularly looking out for scenarios where operations could lead to dimensionally ambiguous results in exponential contexts. This includes better detection of dimensionless quantities or more aggressive simplification strategies to ensure that expressions going into exponential functions do not carry erroneous or incompatible dimensions."
        },
        {
            "file": "sympy/physics/units/systems/si.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the SI unit system's handling of dimensionality and unit operations conforms to mathematical standards, especially regarding exponentiation. This might involve specific checks or transformations when dealing with exponential operations to ensure that arguments are dimensionless when required."
        }
    ]
}
2025-10-15 15:13:04.681 | DEBUG    | Bug location extracted successfully: [<file>sympy/physics/units/dimensions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Definition of physical dimensions.
3 
4 Unit systems will be constructed on top of these dimensions.
5 
6 Most of the examples in the doc use MKS system and are presented from the
7 computer point of view: from a human point, adding length to time is not legal
8 in MKS but it is in natural system; for a computer in natural system there is
9 no time dimension (but a velocity dimension instead) - in the basis - so the
10 question of adding time to length has no meaning.
11 """
12 
13 from typing import Dict as tDict
14 
15 import collections
16 from functools import reduce
17 
18 from sympy.core.basic import Basic
19 from sympy.core.containers import (Dict, Tuple)
20 from sympy.core.singleton import S
21 from sympy.core.sorting import default_sort_key
22 from sympy.core.symbol import Symbol
23 from sympy.core.sympify import sympify
24 from sympy.matrices.dense import Matrix
25 from sympy.functions.elementary.trigonometric import TrigonometricFunction
26 from sympy.core.expr import Expr
27 from sympy.core.power import Pow
28 
29 
30 class _QuantityMapper:
31 
32     _quantity_scale_factors_global = {}  # type: tDict[Expr, Expr]
33     _quantity_dimensional_equivalence_map_global = {}  # type: tDict[Expr, Expr]
34     _quantity_dimension_global = {}  # type: tDict[Expr, Expr]
35 
36     def __init__(self, *args, **kwargs):
37         self._quantity_dimension_map = {}
38         self._quantity_scale_factors = {}
39 
40     def set_quantity_dimension(self, unit, dimension):
41         from sympy.physics.units import Quantity
42         dimension = sympify(dimension)
43         if not isinstance(dimension, Dimension):
44             if dimension == 1:
45                 dimension = Dimension(1)
46             else:
47                 raise ValueError("expected dimension or 1")
48         elif isinstance(dimension, Quantity):
49             dimension = self.get_quantity_dimension(dimension)
50         self._quantity_dimension_map[unit] = dimension
51 
52     def set_quantity_scale_factor(self, unit, scale_factor):
53         from sympy.physics.units import Quantity
54         from sympy.physics.units.prefixes import Prefix
55         scale_factor = sympify(scale_factor)
56         # replace all prefixes by their ratio to canonical units:
57         scale_factor = scale_factor.replace(
58             lambda x: isinstance(x, Prefix),
59             lambda x: x.scale_factor
60         )
61         # replace all quantities by their ratio to canonical units:
62         scale_factor = scale_factor.replace(
63             lambda x: isinstance(x, Quantity),
64             lambda x: self.get_quantity_scale_factor(x)
65         )
66         self._quantity_scale_factors[unit] = scale_factor
67 
68     def get_quantity_dimension(self, unit):
69         from sympy.physics.units import Quantity
70         # First look-up the local dimension map, then the global one:
71         if unit in self._quantity_dimension_map:
72             return self._quantity_dimension_map[unit]
73         if unit in self._quantity_dimension_global:
74             return self._quantity_dimension_global[unit]
75         if unit in self._quantity_dimensional_equivalence_map_global:
76             dep_unit = self._quantity_dimensional_equivalence_map_global[unit]
77             if isinstance(dep_unit, Quantity):
78                 return self.get_quantity_dimension(dep_unit)
79             else:
80                 return Dimension(self.get_dimensional_expr(dep_unit))
81         if isinstance(unit, Quantity):
82             return Dimension(unit.name)
83         else:
84             return Dimension(1)
85 
86     def get_quantity_scale_factor(self, unit):
87         if unit in self._quantity_scale_factors:
88             return self._quantity_scale_factors[unit]
89         if unit in self._quantity_scale_factors_global:
90             mul_factor, other_unit = self._quantity_scale_factors_global[unit]
91             return mul_factor*self.get_quantity_scale_factor(other_unit)
92         return S.One
93 
94 
95 class Dimension(Expr):
96     """
97     This class represent the dimension of a physical quantities.
98 
99     The ``Dimension`` constructor takes as parameters a name and an optional
100     symbol.
101 
102     For example, in classical mechanics we know that time is different from
103     temperature and dimensions make this difference (but they do not provide
104     any measure of these quantites.
105 
106         >>> from sympy.physics.units import Dimension
107         >>> length = Dimension('length')
108         >>> length
109         Dimension(length)
110         >>> time = Dimension('time')
111         >>> time
112         Dimension(time)
113 
114     Dimensions can be composed using multiplication, division and
115     exponentiation (by a number) to give new dimensions. Addition and
116     subtraction is defined only when the two objects are the same dimension.
117 
118         >>> velocity = length / time
119         >>> velocity
120         Dimension(length/time)
121 
122     It is possible to use a dimension system object to get the dimensionsal
123     dependencies of a dimension, for example the dimension system used by the
124     SI units convention can be used:
125 
126         >>> from sympy.physics.units.systems.si import dimsys_SI
127         >>> dimsys_SI.get_dimensional_dependencies(velocity)
128         {Dimension(length, L): 1, Dimension(time, T): -1}
129         >>> length + length
130         Dimension(length)
131         >>> l2 = length**2
132         >>> l2
133         Dimension(length**2)
134         >>> dimsys_SI.get_dimensional_dependencies(l2)
135         {Dimension(length, L): 2}
136 
137     """
138 
139     _op_priority = 13.0
140 
141     # XXX: This doesn't seem to be used anywhere...
142     _dimensional_dependencies = {}  # type: ignore
143 
144     is_commutative = True
145     is_number = False
146     # make sqrt(M**2) --> M
147     is_positive = True
148     is_real = True
149 
150     def __new__(cls, name, symbol=None):
151 
152         if isinstance(name, str):
153             name = Symbol(name)
154         else:
155             name = sympify(name)
156 
157         if not isinstance(name, Expr):
158             raise TypeError("Dimension name needs to be a valid math expression")
159 
160         if isinstance(symbol, str):
161             symbol = Symbol(symbol)
162         elif symbol is not None:
163             assert isinstance(symbol, Symbol)
164 
165         obj = Expr.__new__(cls, name)
166 
167         obj._name = name
168         obj._symbol = symbol
169         return obj
170 
171     @property
172     def name(self):
173         return self._name
174 
175     @property
176     def symbol(self):
177         return self._symbol
178 
179     def __str__(self):
180         """
181         Display the string representation of the dimension.
182         """
183         if self.symbol is None:
184             return "Dimension(%s)" % (self.name)
185         else:
186             return "Dimension(%s, %s)" % (self.name, self.symbol)
187 
188     def __repr__(self):
189         return self.__str__()
190 
191     def __neg__(self):
192         return self
193 
194     def __add__(self, other):
195         from sympy.physics.units.quantities import Quantity
196         other = sympify(other)
197         if isinstance(other, Basic):
198             if other.has(Quantity):
199                 raise TypeError("cannot sum dimension and quantity")
200             if isinstance(other, Dimension) and self == other:
201                 return self
202             return super().__add__(other)
203         return self
204 
205     def __radd__(self, other):
206         return self.__add__(other)
207 
208     def __sub__(self, other):
209         # there is no notion of ordering (or magnitude) among dimension,
210         # subtraction is equivalent to addition when the operation is legal
211         return self + other
212 
213     def __rsub__(self, other):
214         # there is no notion of ordering (or magnitude) among dimension,
215         # subtraction is equivalent to addition when the operation is legal
216         return self + other
217 
218     def __pow__(self, other):
219         return self._eval_power(other)
220 
221     def _eval_power(self, other):
222         other = sympify(other)
223         return Dimension(self.name**other)
224 
225     def __mul__(self, other):
226         from sympy.physics.units.quantities import Quantity
227         if isinstance(other, Basic):
228             if other.has(Quantity):
229                 raise TypeError("cannot sum dimension and quantity")
230             if isinstance(other, Dimension):
231                 return Dimension(self.name*other.name)
232             if not other.free_symbols:  # other.is_number cannot be used
233                 return self
234             return super().__mul__(other)
235         return self
236 
237     def __rmul__(self, other):
238         return self.__mul__(other)
239 
240     def __truediv__(self, other):
241         return self*Pow(other, -1)
242 
243     def __rtruediv__(self, other):
244         return other * pow(self, -1)
245 
246     @classmethod
247     def _from_dimensional_dependencies(cls, dependencies):
248         return reduce(lambda x, y: x * y, (
249             d**e for d, e in dependencies.items()
250         ), 1)
251 
252     def has_integer_powers(self, dim_sys):
253         """
254         Check if the dimension object has only integer powers.
255 
256         All the dimension powers should be integers, but rational powers may
257         appear in intermediate steps. This method may be used to check that the
258         final result is well-defined.
259         """
260 
261         return all(dpow.is_Integer for dpow in dim_sys.get_dimensional_dependencies(self).values())
262 
263 
264 # Create dimensions according to the base units in MKSA.
265 # For other unit systems, they can be derived by transforming the base
266 # dimensional dependency dictionary.
267 
268 
269 class DimensionSystem(Basic, _QuantityMapper):
270     r"""
271     DimensionSystem represents a coherent set of dimensions.
272 
273     The constructor takes three parameters:
274 
275     - base dimensions;
276     - derived dimensions: these are defined in terms of the base dimensions
277       (for example velocity is defined from the division of length by time);
278     - dependency of dimensions: how the derived dimensions depend
279       on the base dimensions.
280 
281     Optionally either the ``derived_dims`` or the ``dimensional_dependencies``
282     may be omitted.
283     """
284 
285     def __new__(cls, base_dims, derived_dims=(), dimensional_dependencies={}):
286         dimensional_dependencies = dict(dimensional_dependencies)
287 
288         def parse_dim(dim):
289             if isinstance(dim, str):
290                 dim = Dimension(Symbol(dim))
291             elif isinstance(dim, Dimension):
292                 pass
293             elif isinstance(dim, Symbol):
294                 dim = Dimension(dim)
295             else:
296                 raise TypeError("%s wrong type" % dim)
297             return dim
298 
299         base_dims = [parse_dim(i) for i in base_dims]
300         derived_dims = [parse_dim(i) for i in derived_dims]
301 
302         for dim in base_dims:
303             if (dim in dimensional_dependencies
304                 and (len(dimensional_dependencies[dim]) != 1 or
305                 dimensional_dependencies[dim].get(dim, None) != 1)):
306                 raise IndexError("Repeated value in base dimensions")
307             dimensional_dependencies[dim] = Dict({dim: 1})
308 
309         def parse_dim_name(dim):
310             if isinstance(dim, Dimension):
311                 return dim
312             elif isinstance(dim, str):
313                 return Dimension(Symbol(dim))
314             elif isinstance(dim, Symbol):
315                 return Dimension(dim)
316             else:
317                 raise TypeError("unrecognized type %s for %s" % (type(dim), dim))
318 
319         for dim in dimensional_dependencies.keys():
320             dim = parse_dim(dim)
321             if (dim not in derived_dims) and (dim not in base_dims):
322                 derived_dims.append(dim)
323 
324         def parse_dict(d):
325             return Dict({parse_dim_name(i): j for i, j in d.items()})
326 
327         # Make sure everything is a SymPy type:
328         dimensional_dependencies = {parse_dim_name(i): parse_dict(j) for i, j in
329                                     dimensional_dependencies.items()}
330 
331         for dim in derived_dims:
332             if dim in base_dims:
333                 raise ValueError("Dimension %s both in base and derived" % dim)
334             if dim not in dimensional_dependencies:
335                 # TODO: should this raise a warning?
336                 dimensional_dependencies[dim] = Dict({dim: 1})
337 
338         base_dims.sort(key=default_sort_key)
339         derived_dims.sort(key=default_sort_key)
340 
341         base_dims = Tuple(*base_dims)
342         derived_dims = Tuple(*derived_dims)
343         dimensional_dependencies = Dict({i: Dict(j) for i, j in dimensional_dependencies.items()})
344         obj = Basic.__new__(cls, base_dims, derived_dims, dimensional_dependencies)
345         return obj
346 
347     @property
348     def base_dims(self):
349         return self.args[0]
350 
351     @property
352     def derived_dims(self):
353         return self.args[1]
354 
355     @property
356     def dimensional_dependencies(self):
357         return self.args[2]
358 
359     def _get_dimensional_dependencies_for_name(self, dimension):
360         if isinstance(dimension, str):
361             dimension = Dimension(Symbol(dimension))
362         elif not isinstance(dimension, Dimension):
363             dimension = Dimension(dimension)
364 
365         if dimension.name.is_Symbol:
366             # Dimensions not included in the dependencies are considered
367             # as base dimensions:
368             return dict(self.dimensional_dependencies.get(dimension, {dimension: 1}))
369 
370         if dimension.name.is_number or dimension.name.is_NumberSymbol:
371             return {}
372 
373         get_for_name = self._get_dimensional_dependencies_for_name
374 
375         if dimension.name.is_Mul:
376             ret = collections.defaultdict(int)
377             dicts = [get_for_name(i) for i in dimension.name.args]
378             for d in dicts:
379                 for k, v in d.items():
380                     ret[k] += v
381             return {k: v for (k, v) in ret.items() if v != 0}
382 
383         if dimension.name.is_Add:
384             dicts = [get_for_name(i) for i in dimension.name.args]
385             if all(d == dicts[0] for d in dicts[1:]):
386                 return dicts[0]
387             raise TypeError("Only equivalent dimensions can be added or subtracted.")
388 
389         if dimension.name.is_Pow:
390             dim_base = get_for_name(dimension.name.base)
391             dim_exp = get_for_name(dimension.name.exp)
392             if dim_exp == {} or dimension.name.exp.is_Symbol:
393                 return {k: v * dimension.name.exp for (k, v) in dim_base.items()}
394             else:
395                 raise TypeError("The exponent for the power operator must be a Symbol or dimensionless.")
396 
397         if dimension.name.is_Function:
398             args = (Dimension._from_dimensional_dependencies(
399                 get_for_name(arg)) for arg in dimension.name.args)
400             result = dimension.name.func(*args)
401 
402             dicts = [get_for_name(i) for i in dimension.name.args]
403 
404             if isinstance(result, Dimension):
405                 return self.get_dimensional_dependencies(result)
406             elif result.func == dimension.name.func:
407                 if isinstance(dimension.name, TrigonometricFunction):
408                     if dicts[0] in ({}, {Dimension('angle'): 1}):
409                         return {}
410                     else:
411                         raise TypeError("The input argument for the function {} must be dimensionless or have dimensions of angle.".format(dimension.func))
412                 else:
413                     if all(item == {} for item in dicts):
414                         return {}
415                     else:
416                         raise TypeError("The input arguments for the function {} must be dimensionless.".format(dimension.func))
417             else:
418                 return get_for_name(result)
419 
420         raise TypeError("Type {} not implemented for get_dimensional_dependencies".format(type(dimension.name)))
421 
422     def get_dimensional_dependencies(self, name, mark_dimensionless=False):
423         dimdep = self._get_dimensional_dependencies_for_name(name)
424         if mark_dimensionless and dimdep == {}:
425             return {Dimension(1): 1}
426         return {k: v for k, v in dimdep.items()}
427 
428     def equivalent_dims(self, dim1, dim2):
429         deps1 = self.get_dimensional_dependencies(dim1)
430         deps2 = self.get_dimensional_dependencies(dim2)
431         return deps1 == deps2
432 
433     def extend(self, new_base_dims, new_derived_dims=(), new_dim_deps=None):
434         deps = dict(self.dimensional_dependencies)
435         if new_dim_deps:
436             deps.update(new_dim_deps)
437 
438         new_dim_sys = DimensionSystem(
439             tuple(self.base_dims) + tuple(new_base_dims),
440             tuple(self.derived_dims) + tuple(new_derived_dims),
441             deps
442         )
443         new_dim_sys._quantity_dimension_map.update(self._quantity_dimension_map)
444         new_dim_sys._quantity_scale_factors.update(self._quantity_scale_factors)
445         return new_dim_sys
446 
447     def is_dimensionless(self, dimension):
448         """
449         Check if the dimension object really has a dimension.
450 
451         A dimension should have at least one component with non-zero power.
452         """
453         if dimension.name == 1:
454             return True
455         return self.get_dimensional_dependencies(dimension) == {}
456 
457     @property
458     def list_can_dims(self):
459         """
460         Useless method, kept for compatibility with previous versions.
461 
462         DO NOT USE.
463 
464         List all canonical dimension names.
465         """
466         dimset = set()
467         for i in self.base_dims:
468             dimset.update(set(self.get_dimensional_dependencies(i).keys()))
469         return tuple(sorted(dimset, key=str))
470 
471     @property
472     def inv_can_transf_matrix(self):
473         """
474         Useless method, kept for compatibility with previous versions.
475 
476         DO NOT USE.
477 
478         Compute the inverse transformation matrix from the base to the
479         canonical dimension basis.
480 
481         It corresponds to the matrix where columns are the vector of base
482         dimensions in canonical basis.
483 
484         This matrix will almost never be used because dimensions are always
485         defined with respect to the canonical basis, so no work has to be done
486         to get them in this basis. Nonetheless if this matrix is not square
487         (or not invertible) it means that we have chosen a bad basis.
488         """
489         matrix = reduce(lambda x, y: x.row_join(y),
490                         [self.dim_can_vector(d) for d in self.base_dims])
491         return matrix
492 
493     @property
494     def can_transf_matrix(self):
495         """
496         Useless method, kept for compatibility with previous versions.
497 
498         DO NOT USE.
499 
500         Return the canonical transformation matrix from the canonical to the
501         base dimension basis.
502 
503         It is the inverse of the matrix computed with inv_can_transf_matrix().
504         """
505 
506         #TODO: the inversion will fail if the system is inconsistent, for
507         #      example if the matrix is not a square
508         return reduce(lambda x, y: x.row_join(y),
509                       [self.dim_can_vector(d) for d in sorted(self.base_dims, key=str)]
510                       ).inv()
511 
512     def dim_can_vector(self, dim):
513         """
514         Useless method, kept for compatibility with previous versions.
515 
516         DO NOT USE.
517 
518         Dimensional representation in terms of the canonical base dimensions.
519         """
520 
521         vec = []
522         for d in self.list_can_dims:
523             vec.append(self.get_dimensional_dependencies(dim).get(d, 0))
524         return Matrix(vec)
525 
526     def dim_vector(self, dim):
527         """
528         Useless method, kept for compatibility with previous versions.
529 
530         DO NOT USE.
531 
532 
533         Vector representation in terms of the base dimensions.
534         """
535         return self.can_transf_matrix * Matrix(self.dim_can_vector(dim))
536 
537     def print_dim_base(self, dim):
538         """
539         Give the string expression of a dimension in term of the basis symbols.
540         """
541         dims = self.dim_vector(dim)
542         symbols = [i.symbol if i.symbol is not None else i.name for i in self.base_dims]
543         res = S.One
544         for (s, p) in zip(symbols, dims):
545             res *= s**p
546         return res
547 
548     @property
549     def dim(self):
550         """
551         Useless method, kept for compatibility with previous versions.
552 
553         DO NOT USE.
554 
555         Give the dimension of the system.
556 
557         That is return the number of dimensions forming the basis.
558         """
559         return len(self.base_dims)
560 
561     @property
562     def is_consistent(self):
563         """
564         Useless method, kept for compatibility with previous versions.
565 
566         DO NOT USE.
567 
568         Check if the system is well defined.
569         """
570 
571         # not enough or too many base dimensions compared to independent
572         # dimensions
573         # in vector language: the set of vectors do not form a basis
574         return self.inv_can_transf_matrix.is_square

</code><intended_behavior>This code should ensure that expressions which are inherently dimensionless (or can be simplified to be dimensionless) are recognized as such before being passed to an exp function. Furthermore, it may require modification or enhancement to properly interact with exponential functions, possibly by preprocessing expressions to validate their dimensionality or by simplifying them to a recognizable dimensionless state. The key is to prevent passing dimensionally inconsistent arguments to exp.</intended_behavior>, <file>sympy/physics/units/util.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Several methods to simplify expressions involving unit objects.
3 """
4 from functools import reduce
5 from collections.abc import Iterable
6 from typing import Optional
7 
8 from sympy import default_sort_key
9 from sympy.core.add import Add
10 from sympy.core.containers import Tuple
11 from sympy.core.mul import Mul
12 from sympy.core.power import Pow
13 from sympy.core.sorting import ordered
14 from sympy.core.sympify import sympify
15 from sympy.matrices.common import NonInvertibleMatrixError
16 from sympy.physics.units.dimensions import Dimension, DimensionSystem
17 from sympy.physics.units.prefixes import Prefix
18 from sympy.physics.units.quantities import Quantity
19 from sympy.physics.units.unitsystem import UnitSystem
20 from sympy.utilities.iterables import sift
21 
22 
23 def _get_conversion_matrix_for_expr(expr, target_units, unit_system):
24     from sympy.matrices.dense import Matrix
25 
26     dimension_system = unit_system.get_dimension_system()
27 
28     expr_dim = Dimension(unit_system.get_dimensional_expr(expr))
29     dim_dependencies = dimension_system.get_dimensional_dependencies(expr_dim, mark_dimensionless=True)
30     target_dims = [Dimension(unit_system.get_dimensional_expr(x)) for x in target_units]
31     canon_dim_units = [i for x in target_dims for i in dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True)]
32     canon_expr_units = {i for i in dim_dependencies}
33 
34     if not canon_expr_units.issubset(set(canon_dim_units)):
35         return None
36 
37     seen = set()
38     canon_dim_units = [i for i in canon_dim_units if not (i in seen or seen.add(i))]
39 
40     camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) for i in target_dims] for j in canon_dim_units])
41     exprmat = Matrix([dim_dependencies.get(k, 0) for k in canon_dim_units])
42 
43     try:
44         res_exponents = camat.solve(exprmat)
45     except NonInvertibleMatrixError:
46         return None
47 
48     return res_exponents
49 
50 
51 def convert_to(expr, target_units, unit_system="SI"):
52     """
53     Convert ``expr`` to the same expression with all of its units and quantities
54     represented as factors of ``target_units``, whenever the dimension is compatible.
55 
56     ``target_units`` may be a single unit/quantity, or a collection of
57     units/quantities.
58 
59     Examples
60     ========
61 
62     >>> from sympy.physics.units import speed_of_light, meter, gram, second, day
63     >>> from sympy.physics.units import mile, newton, kilogram, atomic_mass_constant
64     >>> from sympy.physics.units import kilometer, centimeter
65     >>> from sympy.physics.units import gravitational_constant, hbar
66     >>> from sympy.physics.units import convert_to
67     >>> convert_to(mile, kilometer)
68     25146*kilometer/15625
69     >>> convert_to(mile, kilometer).n()
70     1.609344*kilometer
71     >>> convert_to(speed_of_light, meter/second)
72     299792458*meter/second
73     >>> convert_to(day, second)
74     86400*second
75     >>> 3*newton
76     3*newton
77     >>> convert_to(3*newton, kilogram*meter/second**2)
78     3*kilogram*meter/second**2
79     >>> convert_to(atomic_mass_constant, gram)
80     1.660539060e-24*gram
81 
82     Conversion to multiple units:
83 
84     >>> convert_to(speed_of_light, [meter, second])
85     299792458*meter/second
86     >>> convert_to(3*newton, [centimeter, gram, second])
87     300000*centimeter*gram/second**2
88 
89     Conversion to Planck units:
90 
91     >>> convert_to(atomic_mass_constant, [gravitational_constant, speed_of_light, hbar]).n()
92     7.62963087839509e-20*hbar**0.5*speed_of_light**0.5/gravitational_constant**0.5
93 
94     """
95     from sympy.physics.units import UnitSystem
96     unit_system = UnitSystem.get_unit_system(unit_system)
97 
98     if not isinstance(target_units, (Iterable, Tuple)):
99         target_units = [target_units]
100 
101     if isinstance(expr, Add):
102         return Add.fromiter(convert_to(i, target_units, unit_system)
103             for i in expr.args)
104 
105     expr = sympify(expr)
106     target_units = sympify(target_units)
107 
108     if not isinstance(expr, Quantity) and expr.has(Quantity):
109         expr = expr.replace(lambda x: isinstance(x, Quantity),
110             lambda x: x.convert_to(target_units, unit_system))
111 
112     def get_total_scale_factor(expr):
113         if isinstance(expr, Mul):
114             return reduce(lambda x, y: x * y,
115                 [get_total_scale_factor(i) for i in expr.args])
116         elif isinstance(expr, Pow):
117             return get_total_scale_factor(expr.base) ** expr.exp
118         elif isinstance(expr, Quantity):
119             return unit_system.get_quantity_scale_factor(expr)
120         return expr
121 
122     depmat = _get_conversion_matrix_for_expr(expr, target_units, unit_system)
123     if depmat is None:
124         return expr
125 
126     expr_scale_factor = get_total_scale_factor(expr)
127     return expr_scale_factor * Mul.fromiter(
128         (1/get_total_scale_factor(u)*u)**p for u, p in
129         zip(target_units, depmat))
130 
131 
132 def quantity_simplify(expr, across_dimensions: bool=False, unit_system=None):
133     """Return an equivalent expression in which prefixes are replaced
134     with numerical values and all units of a given dimension are the
135     unified in a canonical manner by default. `across_dimensions` allows
136     for units of different dimensions to be simplified together.
137 
138     `unit_system` must be specified if `across_dimensions` is True.
139 
140     Examples
141     ========
142 
143     >>> from sympy.physics.units.util import quantity_simplify
144     >>> from sympy.physics.units.prefixes import kilo
145     >>> from sympy.physics.units import foot, inch, joule, coulomb
146     >>> quantity_simplify(kilo*foot*inch)
147     250*foot**2/3
148     >>> quantity_simplify(foot - 6*inch)
149     foot/2
150     >>> quantity_simplify(5*joule/coulomb, across_dimensions=True, unit_system="SI")
151     5*volt
152     """
153 
154     if expr.is_Atom or not expr.has(Prefix, Quantity):
155         return expr
156 
157     # replace all prefixes with numerical values
158     p = expr.atoms(Prefix)
159     expr = expr.xreplace({p: p.scale_factor for p in p})
160 
161     # replace all quantities of given dimension with a canonical
162     # quantity, chosen from those in the expression
163     d = sift(expr.atoms(Quantity), lambda i: i.dimension)
164     for k in d:
165         if len(d[k]) == 1:
166             continue
167         v = list(ordered(d[k]))
168         ref = v[0]/v[0].scale_factor
169         expr = expr.xreplace({vi: ref*vi.scale_factor for vi in v[1:]})
170 
171     if across_dimensions:
172         # combine quantities of different dimensions into a single
173         # quantity that is equivalent to the original expression
174 
175         if unit_system is None:
176             raise ValueError("unit_system must be specified if across_dimensions is True")
177 
178         unit_system = UnitSystem.get_unit_system(unit_system)
179         dimension_system: DimensionSystem = unit_system.get_dimension_system()
180         dim_expr = unit_system.get_dimensional_expr(expr)
181         dim_deps = dimension_system.get_dimensional_dependencies(dim_expr, mark_dimensionless=True)
182 
183         target_dimension: Optional[Dimension] = None
184         for ds_dim, ds_dim_deps in dimension_system.dimensional_dependencies.items():
185             if ds_dim_deps == dim_deps:
186                 target_dimension = ds_dim
187                 break
188 
189         if target_dimension is None:
190             # if we can't find a target dimension, we can't do anything. unsure how to handle this case.
191             return expr
192 
193         target_unit = unit_system.derived_units.get(target_dimension)
194         if target_unit:
195             expr = convert_to(expr, target_unit, unit_system)
196 
197     return expr
198 
199 
200 def check_dimensions(expr, unit_system="SI"):
201     """Return expr if units in addends have the same
202     base dimensions, else raise a ValueError."""
203     # the case of adding a number to a dimensional quantity
204     # is ignored for the sake of SymPy core routines, so this
205     # function will raise an error now if such an addend is
206     # found.
207     # Also, when doing substitutions, multiplicative constants
208     # might be introduced, so remove those now
209 
210     from sympy.physics.units import UnitSystem
211     unit_system = UnitSystem.get_unit_system(unit_system)
212 
213     def addDict(dict1, dict2):
214         """Merge dictionaries by adding values of common keys and
215         removing keys with value of 0."""
216         dict3 = {**dict1, **dict2}
217         for key, value in dict3.items():
218             if key in dict1 and key in dict2:
219                    dict3[key] = value + dict1[key]
220         return {key:val for key, val in dict3.items() if val != 0}
221 
222     adds = expr.atoms(Add)
223     DIM_OF = unit_system.get_dimension_system().get_dimensional_dependencies
224     for a in adds:
225         deset = set()
226         for ai in a.args:
227             if ai.is_number:
228                 deset.add(())
229                 continue
230             dims = []
231             skip = False
232             dimdict = {}
233             for i in Mul.make_args(ai):
234                 if i.has(Quantity):
235                     i = Dimension(unit_system.get_dimensional_expr(i))
236                 if i.has(Dimension):
237                     dimdict = addDict(dimdict, DIM_OF(i))
238                 elif i.free_symbols:
239                     skip = True
240                     break
241             dims.extend(dimdict.items())
242             if not skip:
243                 deset.add(tuple(sorted(dims, key=default_sort_key)))
244                 if len(deset) > 1:
245                     raise ValueError(
246                         "addends have incompatible dimensions: {}".format(deset))
247 
248     # clear multiplicative constants on Dimensions which may be
249     # left after substitution
250     reps = {}
251     for m in expr.atoms(Mul):
252         if any(isinstance(i, Dimension) for i in m.args):
253             reps[m] = m.func(*[
254                 i for i in m.args if not i.is_number])
255 
256     return expr.xreplace(reps)

</code><intended_behavior>Enhance the utility functions to more robustly identify and handle expressions, particularly looking out for scenarios where operations could lead to dimensionally ambiguous results in exponential contexts. This includes better detection of dimensionless quantities or more aggressive simplification strategies to ensure that expressions going into exponential functions do not carry erroneous or incompatible dimensions.</intended_behavior>, <file>sympy/physics/units/systems/si.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SI unit system.
3 Based on MKSA, which stands for "meter, kilogram, second, ampere".
4 Added kelvin, candela and mole.
5 
6 """
7 
8 from typing import List
9 
10 from sympy.physics.units import DimensionSystem, Dimension, dHg0
11 
12 from sympy.physics.units.quantities import Quantity
13 
14 from sympy.core.numbers import (Rational, pi)
15 from sympy.core.singleton import S
16 from sympy.functions.elementary.miscellaneous import sqrt
17 from sympy.physics.units.definitions.dimension_definitions import (
18     acceleration, action, current, impedance, length, mass, time, velocity,
19     amount_of_substance, temperature, information, frequency, force, pressure,
20     energy, power, charge, voltage, capacitance, conductance, magnetic_flux,
21     magnetic_density, inductance, luminous_intensity
22 )
23 from sympy.physics.units.definitions import (
24     kilogram, newton, second, meter, gram, cd, K, joule, watt, pascal, hertz,
25     coulomb, volt, ohm, siemens, farad, henry, tesla, weber, dioptre, lux,
26     katal, gray, becquerel, inch, liter, julian_year, gravitational_constant,
27     speed_of_light, elementary_charge, planck, hbar, electronvolt,
28     avogadro_number, avogadro_constant, boltzmann_constant,
29     stefan_boltzmann_constant, Da, atomic_mass_constant, molar_gas_constant,
30     faraday_constant, josephson_constant, von_klitzing_constant,
31     acceleration_due_to_gravity, magnetic_constant, vacuum_permittivity,
32     vacuum_impedance, coulomb_constant, atmosphere, bar, pound, psi, mmHg,
33     milli_mass_unit, quart, lightyear, astronomical_unit, planck_mass,
34     planck_time, planck_temperature, planck_length, planck_charge, planck_area,
35     planck_volume, planck_momentum, planck_energy, planck_force, planck_power,
36     planck_density, planck_energy_density, planck_intensity,
37     planck_angular_frequency, planck_pressure, planck_current, planck_voltage,
38     planck_impedance, planck_acceleration, bit, byte, kibibyte, mebibyte,
39     gibibyte, tebibyte, pebibyte, exbibyte, curie, rutherford, radian, degree,
40     steradian, angular_mil, atomic_mass_unit, gee, kPa, ampere, u0, c, kelvin,
41     mol, mole, candela, m, kg, s, electric_constant, G, boltzmann
42 )
43 from sympy.physics.units.prefixes import PREFIXES, prefix_unit
44 from sympy.physics.units.systems.mksa import MKSA, dimsys_MKSA
45 
46 derived_dims = (frequency, force, pressure, energy, power, charge, voltage,
47                 capacitance, conductance, magnetic_flux,
48                 magnetic_density, inductance, luminous_intensity)
49 base_dims = (amount_of_substance, luminous_intensity, temperature)
50 
51 units = [mol, cd, K, lux, hertz, newton, pascal, joule, watt, coulomb, volt,
52         farad, ohm, siemens, weber, tesla, henry, candela, lux, becquerel,
53         gray, katal]
54 
55 all_units = []  # type: List[Quantity]
56 for u in units:
57     all_units.extend(prefix_unit(u, PREFIXES))
58 
59 all_units.extend(units)
60 all_units.extend([mol, cd, K, lux])
61 
62 
63 dimsys_SI = dimsys_MKSA.extend(
64     [
65         # Dimensional dependencies for other base dimensions:
66         temperature,
67         amount_of_substance,
68         luminous_intensity,
69     ])
70 
71 dimsys_default = dimsys_SI.extend(
72     [information],
73 )
74 
75 SI = MKSA.extend(base=(mol, cd, K), units=all_units, name='SI', dimension_system=dimsys_SI, derived_units={
76     power: watt,
77     magnetic_flux: weber,
78     time: second,
79     impedance: ohm,
80     pressure: pascal,
81     current: ampere,
82     voltage: volt,
83     length: meter,
84     frequency: hertz,
85     inductance: henry,
86     temperature: kelvin,
87     amount_of_substance: mole,
88     luminous_intensity: candela,
89     conductance: siemens,
90     mass: kilogram,
91     magnetic_density: tesla,
92     charge: coulomb,
93     force: newton,
94     capacitance: farad,
95     energy: joule,
96     velocity: meter/second,
97 })
98 
99 One = S.One
100 
101 SI.set_quantity_dimension(radian, One)
102 
103 SI.set_quantity_scale_factor(ampere, One)
104 
105 SI.set_quantity_scale_factor(kelvin, One)
106 
107 SI.set_quantity_scale_factor(mole, One)
108 
109 SI.set_quantity_scale_factor(candela, One)
110 
111 # MKSA extension to MKS: derived units
112 
113 SI.set_quantity_scale_factor(coulomb, One)
114 
115 SI.set_quantity_scale_factor(volt, joule/coulomb)
116 
117 SI.set_quantity_scale_factor(ohm, volt/ampere)
118 
119 SI.set_quantity_scale_factor(siemens, ampere/volt)
120 
121 SI.set_quantity_scale_factor(farad, coulomb/volt)
122 
123 SI.set_quantity_scale_factor(henry, volt*second/ampere)
124 
125 SI.set_quantity_scale_factor(tesla, volt*second/meter**2)
126 
127 SI.set_quantity_scale_factor(weber, joule/ampere)
128 
129 
130 SI.set_quantity_dimension(lux, luminous_intensity / length ** 2)
131 SI.set_quantity_scale_factor(lux, steradian*candela/meter**2)
132 
133 # katal is the SI unit of catalytic activity
134 
135 SI.set_quantity_dimension(katal, amount_of_substance / time)
136 SI.set_quantity_scale_factor(katal, mol/second)
137 
138 # gray is the SI unit of absorbed dose
139 
140 SI.set_quantity_dimension(gray, energy / mass)
141 SI.set_quantity_scale_factor(gray, meter**2/second**2)
142 
143 # becquerel is the SI unit of radioactivity
144 
145 SI.set_quantity_dimension(becquerel, 1 / time)
146 SI.set_quantity_scale_factor(becquerel, 1/second)
147 
148 #### CONSTANTS ####
149 
150 # elementary charge
151 # REF: NIST SP 959 (June 2019)
152 
153 SI.set_quantity_dimension(elementary_charge, charge)
154 SI.set_quantity_scale_factor(elementary_charge, 1.602176634e-19*coulomb)
155 
156 # Electronvolt
157 # REF: NIST SP 959 (June 2019)
158 
159 SI.set_quantity_dimension(electronvolt, energy)
160 SI.set_quantity_scale_factor(electronvolt, 1.602176634e-19*joule)
161 
162 # Avogadro number
163 # REF: NIST SP 959 (June 2019)
164 
165 SI.set_quantity_dimension(avogadro_number, One)
166 SI.set_quantity_scale_factor(avogadro_number, 6.02214076e23)
167 
168 # Avogadro constant
169 
170 SI.set_quantity_dimension(avogadro_constant, amount_of_substance ** -1)
171 SI.set_quantity_scale_factor(avogadro_constant, avogadro_number / mol)
172 
173 # Boltzmann constant
174 # REF: NIST SP 959 (June 2019)
175 
176 SI.set_quantity_dimension(boltzmann_constant, energy / temperature)
177 SI.set_quantity_scale_factor(boltzmann_constant, 1.380649e-23*joule/kelvin)
178 
179 # Stefan-Boltzmann constant
180 # REF: NIST SP 959 (June 2019)
181 
182 SI.set_quantity_dimension(stefan_boltzmann_constant, energy * time ** -1 * length ** -2 * temperature ** -4)
183 SI.set_quantity_scale_factor(stefan_boltzmann_constant, pi**2 * boltzmann_constant**4 / (60 * hbar**3 * speed_of_light ** 2))
184 
185 # Atomic mass
186 # REF: NIST SP 959 (June 2019)
187 
188 SI.set_quantity_dimension(atomic_mass_constant, mass)
189 SI.set_quantity_scale_factor(atomic_mass_constant, 1.66053906660e-24*gram)
190 
191 # Molar gas constant
192 # REF: NIST SP 959 (June 2019)
193 
194 SI.set_quantity_dimension(molar_gas_constant, energy / (temperature * amount_of_substance))
195 SI.set_quantity_scale_factor(molar_gas_constant, boltzmann_constant * avogadro_constant)
196 
197 # Faraday constant
198 
199 SI.set_quantity_dimension(faraday_constant, charge / amount_of_substance)
200 SI.set_quantity_scale_factor(faraday_constant, elementary_charge * avogadro_constant)
201 
202 # Josephson constant
203 
204 SI.set_quantity_dimension(josephson_constant, frequency / voltage)
205 SI.set_quantity_scale_factor(josephson_constant, 0.5 * planck / elementary_charge)
206 
207 # Von Klitzing constant
208 
209 SI.set_quantity_dimension(von_klitzing_constant, voltage / current)
210 SI.set_quantity_scale_factor(von_klitzing_constant, hbar / elementary_charge ** 2)
211 
212 # Acceleration due to gravity (on the Earth surface)
213 
214 SI.set_quantity_dimension(acceleration_due_to_gravity, acceleration)
215 SI.set_quantity_scale_factor(acceleration_due_to_gravity, 9.80665*meter/second**2)
216 
217 # magnetic constant:
218 
219 SI.set_quantity_dimension(magnetic_constant, force / current ** 2)
220 SI.set_quantity_scale_factor(magnetic_constant, 4*pi/10**7 * newton/ampere**2)
221 
222 # electric constant:
223 
224 SI.set_quantity_dimension(vacuum_permittivity, capacitance / length)
225 SI.set_quantity_scale_factor(vacuum_permittivity, 1/(u0 * c**2))
226 
227 # vacuum impedance:
228 
229 SI.set_quantity_dimension(vacuum_impedance, impedance)
230 SI.set_quantity_scale_factor(vacuum_impedance, u0 * c)
231 
232 # Coulomb's constant:
233 SI.set_quantity_dimension(coulomb_constant, force * length ** 2 / charge ** 2)
234 SI.set_quantity_scale_factor(coulomb_constant, 1/(4*pi*vacuum_permittivity))
235 
236 SI.set_quantity_dimension(psi, pressure)
237 SI.set_quantity_scale_factor(psi, pound * gee / inch ** 2)
238 
239 SI.set_quantity_dimension(mmHg, pressure)
240 SI.set_quantity_scale_factor(mmHg, dHg0 * acceleration_due_to_gravity * kilogram / meter**2)
241 
242 SI.set_quantity_dimension(milli_mass_unit, mass)
243 SI.set_quantity_scale_factor(milli_mass_unit, atomic_mass_unit/1000)
244 
245 SI.set_quantity_dimension(quart, length ** 3)
246 SI.set_quantity_scale_factor(quart, Rational(231, 4) * inch**3)
247 
248 # Other convenient units and magnitudes
249 
250 SI.set_quantity_dimension(lightyear, length)
251 SI.set_quantity_scale_factor(lightyear, speed_of_light*julian_year)
252 
253 SI.set_quantity_dimension(astronomical_unit, length)
254 SI.set_quantity_scale_factor(astronomical_unit, 149597870691*meter)
255 
256 # Fundamental Planck units:
257 
258 SI.set_quantity_dimension(planck_mass, mass)
259 SI.set_quantity_scale_factor(planck_mass, sqrt(hbar*speed_of_light/G))
260 
261 SI.set_quantity_dimension(planck_time, time)
262 SI.set_quantity_scale_factor(planck_time, sqrt(hbar*G/speed_of_light**5))
263 
264 SI.set_quantity_dimension(planck_temperature, temperature)
265 SI.set_quantity_scale_factor(planck_temperature, sqrt(hbar*speed_of_light**5/G/boltzmann**2))
266 
267 SI.set_quantity_dimension(planck_length, length)
268 SI.set_quantity_scale_factor(planck_length, sqrt(hbar*G/speed_of_light**3))
269 
270 SI.set_quantity_dimension(planck_charge, charge)
271 SI.set_quantity_scale_factor(planck_charge, sqrt(4*pi*electric_constant*hbar*speed_of_light))
272 
273 # Derived Planck units:
274 
275 SI.set_quantity_dimension(planck_area, length ** 2)
276 SI.set_quantity_scale_factor(planck_area, planck_length**2)
277 
278 SI.set_quantity_dimension(planck_volume, length ** 3)
279 SI.set_quantity_scale_factor(planck_volume, planck_length**3)
280 
281 SI.set_quantity_dimension(planck_momentum, mass * velocity)
282 SI.set_quantity_scale_factor(planck_momentum, planck_mass * speed_of_light)
283 
284 SI.set_quantity_dimension(planck_energy, energy)
285 SI.set_quantity_scale_factor(planck_energy, planck_mass * speed_of_light**2)
286 
287 SI.set_quantity_dimension(planck_force, force)
288 SI.set_quantity_scale_factor(planck_force, planck_energy / planck_length)
289 
290 SI.set_quantity_dimension(planck_power, power)
291 SI.set_quantity_scale_factor(planck_power, planck_energy / planck_time)
292 
293 SI.set_quantity_dimension(planck_density, mass / length ** 3)
294 SI.set_quantity_scale_factor(planck_density, planck_mass / planck_length**3)
295 
296 SI.set_quantity_dimension(planck_energy_density, energy / length ** 3)
297 SI.set_quantity_scale_factor(planck_energy_density, planck_energy / planck_length**3)
298 
299 SI.set_quantity_dimension(planck_intensity, mass * time ** (-3))
300 SI.set_quantity_scale_factor(planck_intensity, planck_energy_density * speed_of_light)
301 
302 SI.set_quantity_dimension(planck_angular_frequency, 1 / time)
303 SI.set_quantity_scale_factor(planck_angular_frequency, 1 / planck_time)
304 
305 SI.set_quantity_dimension(planck_pressure, pressure)
306 SI.set_quantity_scale_factor(planck_pressure, planck_force / planck_length**2)
307 
308 SI.set_quantity_dimension(planck_current, current)
309 SI.set_quantity_scale_factor(planck_current, planck_charge / planck_time)
310 
311 SI.set_quantity_dimension(planck_voltage, voltage)
312 SI.set_quantity_scale_factor(planck_voltage, planck_energy / planck_charge)
313 
314 SI.set_quantity_dimension(planck_impedance, impedance)
315 SI.set_quantity_scale_factor(planck_impedance, planck_voltage / planck_current)
316 
317 SI.set_quantity_dimension(planck_acceleration, acceleration)
318 SI.set_quantity_scale_factor(planck_acceleration, speed_of_light / planck_time)
319 
320 # Older units for radioactivity
321 
322 SI.set_quantity_dimension(curie, 1 / time)
323 SI.set_quantity_scale_factor(curie, 37000000000*becquerel)
324 
325 SI.set_quantity_dimension(rutherford, 1 / time)
326 SI.set_quantity_scale_factor(rutherford, 1000000*becquerel)
327 
328 
329 # check that scale factors are the right SI dimensions:
330 for _scale_factor, _dimension in zip(
331     SI._quantity_scale_factors.values(),
332     SI._quantity_dimension_map.values()
333 ):
334     dimex = SI.get_dimensional_expr(_scale_factor)
335     if dimex != 1:
336         # XXX: equivalent_dims is an instance method taking two arguments in
337         # addition to self so this can not work:
338         if not DimensionSystem.equivalent_dims(_dimension, Dimension(dimex)):  # type: ignore
339             raise ValueError("quantity value and dimension mismatch")
340 del _scale_factor, _dimension
341 
342 __all__ = [
343     'mmHg', 'atmosphere', 'inductance', 'newton', 'meter',
344     'vacuum_permittivity', 'pascal', 'magnetic_constant', 'voltage',
345     'angular_mil', 'luminous_intensity', 'all_units',
346     'julian_year', 'weber', 'exbibyte', 'liter',
347     'molar_gas_constant', 'faraday_constant', 'avogadro_constant',
348     'lightyear', 'planck_density', 'gee', 'mol', 'bit', 'gray',
349     'planck_momentum', 'bar', 'magnetic_density', 'prefix_unit', 'PREFIXES',
350     'planck_time', 'dimex', 'gram', 'candela', 'force', 'planck_intensity',
351     'energy', 'becquerel', 'planck_acceleration', 'speed_of_light',
352     'conductance', 'frequency', 'coulomb_constant', 'degree', 'lux', 'planck',
353     'current', 'planck_current', 'tebibyte', 'planck_power', 'MKSA', 'power',
354     'K', 'planck_volume', 'quart', 'pressure', 'amount_of_substance',
355     'joule', 'boltzmann_constant', 'Dimension', 'c', 'planck_force', 'length',
356     'watt', 'action', 'hbar', 'gibibyte', 'DimensionSystem', 'cd', 'volt',
357     'planck_charge', 'dioptre', 'vacuum_impedance', 'dimsys_default', 'farad',
358     'charge', 'gravitational_constant', 'temperature', 'u0', 'hertz',
359     'capacitance', 'tesla', 'steradian', 'planck_mass', 'josephson_constant',
360     'planck_area', 'stefan_boltzmann_constant', 'base_dims',
361     'astronomical_unit', 'radian', 'planck_voltage', 'impedance',
362     'planck_energy', 'Da', 'atomic_mass_constant', 'rutherford', 'second', 'inch',
363     'elementary_charge', 'SI', 'electronvolt', 'dimsys_SI', 'henry',
364     'planck_angular_frequency', 'ohm', 'pound', 'planck_pressure', 'G', 'psi',
365     'dHg0', 'von_klitzing_constant', 'planck_length', 'avogadro_number',
366     'mole', 'acceleration', 'information', 'planck_energy_density',
367     'mebibyte', 's', 'acceleration_due_to_gravity',
368     'planck_temperature', 'units', 'mass', 'dimsys_MKSA', 'kelvin', 'kPa',
369     'boltzmann', 'milli_mass_unit', 'planck_impedance', 'electric_constant',
370     'derived_dims', 'kg', 'coulomb', 'siemens', 'byte', 'magnetic_flux',
371     'atomic_mass_unit', 'm', 'kibibyte', 'kilogram', 'One', 'curie', 'u',
372     'time', 'pebibyte', 'velocity', 'ampere', 'katal',
373 ]

</code><intended_behavior>Ensure that the SI unit system's handling of dimensionality and unit operations conforms to mathematical standards, especially regarding exponentiation. This might involve specific checks or transformations when dealing with exponential operations to ensure that arguments are dimensionless when required.</intended_behavior>]
2025-10-15 15:13:04.681 | INFO     | Search completed. Bug locations: [<file>sympy/physics/units/dimensions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Definition of physical dimensions.
3 
4 Unit systems will be constructed on top of these dimensions.
5 
6 Most of the examples in the doc use MKS system and are presented from the
7 computer point of view: from a human point, adding length to time is not legal
8 in MKS but it is in natural system; for a computer in natural system there is
9 no time dimension (but a velocity dimension instead) - in the basis - so the
10 question of adding time to length has no meaning.
11 """
12 
13 from typing import Dict as tDict
14 
15 import collections
16 from functools import reduce
17 
18 from sympy.core.basic import Basic
19 from sympy.core.containers import (Dict, Tuple)
20 from sympy.core.singleton import S
21 from sympy.core.sorting import default_sort_key
22 from sympy.core.symbol import Symbol
23 from sympy.core.sympify import sympify
24 from sympy.matrices.dense import Matrix
25 from sympy.functions.elementary.trigonometric import TrigonometricFunction
26 from sympy.core.expr import Expr
27 from sympy.core.power import Pow
28 
29 
30 class _QuantityMapper:
31 
32     _quantity_scale_factors_global = {}  # type: tDict[Expr, Expr]
33     _quantity_dimensional_equivalence_map_global = {}  # type: tDict[Expr, Expr]
34     _quantity_dimension_global = {}  # type: tDict[Expr, Expr]
35 
36     def __init__(self, *args, **kwargs):
37         self._quantity_dimension_map = {}
38         self._quantity_scale_factors = {}
39 
40     def set_quantity_dimension(self, unit, dimension):
41         from sympy.physics.units import Quantity
42         dimension = sympify(dimension)
43         if not isinstance(dimension, Dimension):
44             if dimension == 1:
45                 dimension = Dimension(1)
46             else:
47                 raise ValueError("expected dimension or 1")
48         elif isinstance(dimension, Quantity):
49             dimension = self.get_quantity_dimension(dimension)
50         self._quantity_dimension_map[unit] = dimension
51 
52     def set_quantity_scale_factor(self, unit, scale_factor):
53         from sympy.physics.units import Quantity
54         from sympy.physics.units.prefixes import Prefix
55         scale_factor = sympify(scale_factor)
56         # replace all prefixes by their ratio to canonical units:
57         scale_factor = scale_factor.replace(
58             lambda x: isinstance(x, Prefix),
59             lambda x: x.scale_factor
60         )
61         # replace all quantities by their ratio to canonical units:
62         scale_factor = scale_factor.replace(
63             lambda x: isinstance(x, Quantity),
64             lambda x: self.get_quantity_scale_factor(x)
65         )
66         self._quantity_scale_factors[unit] = scale_factor
67 
68     def get_quantity_dimension(self, unit):
69         from sympy.physics.units import Quantity
70         # First look-up the local dimension map, then the global one:
71         if unit in self._quantity_dimension_map:
72             return self._quantity_dimension_map[unit]
73         if unit in self._quantity_dimension_global:
74             return self._quantity_dimension_global[unit]
75         if unit in self._quantity_dimensional_equivalence_map_global:
76             dep_unit = self._quantity_dimensional_equivalence_map_global[unit]
77             if isinstance(dep_unit, Quantity):
78                 return self.get_quantity_dimension(dep_unit)
79             else:
80                 return Dimension(self.get_dimensional_expr(dep_unit))
81         if isinstance(unit, Quantity):
82             return Dimension(unit.name)
83         else:
84             return Dimension(1)
85 
86     def get_quantity_scale_factor(self, unit):
87         if unit in self._quantity_scale_factors:
88             return self._quantity_scale_factors[unit]
89         if unit in self._quantity_scale_factors_global:
90             mul_factor, other_unit = self._quantity_scale_factors_global[unit]
91             return mul_factor*self.get_quantity_scale_factor(other_unit)
92         return S.One
93 
94 
95 class Dimension(Expr):
96     """
97     This class represent the dimension of a physical quantities.
98 
99     The ``Dimension`` constructor takes as parameters a name and an optional
100     symbol.
101 
102     For example, in classical mechanics we know that time is different from
103     temperature and dimensions make this difference (but they do not provide
104     any measure of these quantites.
105 
106         >>> from sympy.physics.units import Dimension
107         >>> length = Dimension('length')
108         >>> length
109         Dimension(length)
110         >>> time = Dimension('time')
111         >>> time
112         Dimension(time)
113 
114     Dimensions can be composed using multiplication, division and
115     exponentiation (by a number) to give new dimensions. Addition and
116     subtraction is defined only when the two objects are the same dimension.
117 
118         >>> velocity = length / time
119         >>> velocity
120         Dimension(length/time)
121 
122     It is possible to use a dimension system object to get the dimensionsal
123     dependencies of a dimension, for example the dimension system used by the
124     SI units convention can be used:
125 
126         >>> from sympy.physics.units.systems.si import dimsys_SI
127         >>> dimsys_SI.get_dimensional_dependencies(velocity)
128         {Dimension(length, L): 1, Dimension(time, T): -1}
129         >>> length + length
130         Dimension(length)
131         >>> l2 = length**2
132         >>> l2
133         Dimension(length**2)
134         >>> dimsys_SI.get_dimensional_dependencies(l2)
135         {Dimension(length, L): 2}
136 
137     """
138 
139     _op_priority = 13.0
140 
141     # XXX: This doesn't seem to be used anywhere...
142     _dimensional_dependencies = {}  # type: ignore
143 
144     is_commutative = True
145     is_number = False
146     # make sqrt(M**2) --> M
147     is_positive = True
148     is_real = True
149 
150     def __new__(cls, name, symbol=None):
151 
152         if isinstance(name, str):
153             name = Symbol(name)
154         else:
155             name = sympify(name)
156 
157         if not isinstance(name, Expr):
158             raise TypeError("Dimension name needs to be a valid math expression")
159 
160         if isinstance(symbol, str):
161             symbol = Symbol(symbol)
162         elif symbol is not None:
163             assert isinstance(symbol, Symbol)
164 
165         obj = Expr.__new__(cls, name)
166 
167         obj._name = name
168         obj._symbol = symbol
169         return obj
170 
171     @property
172     def name(self):
173         return self._name
174 
175     @property
176     def symbol(self):
177         return self._symbol
178 
179     def __str__(self):
180         """
181         Display the string representation of the dimension.
182         """
183         if self.symbol is None:
184             return "Dimension(%s)" % (self.name)
185         else:
186             return "Dimension(%s, %s)" % (self.name, self.symbol)
187 
188     def __repr__(self):
189         return self.__str__()
190 
191     def __neg__(self):
192         return self
193 
194     def __add__(self, other):
195         from sympy.physics.units.quantities import Quantity
196         other = sympify(other)
197         if isinstance(other, Basic):
198             if other.has(Quantity):
199                 raise TypeError("cannot sum dimension and quantity")
200             if isinstance(other, Dimension) and self == other:
201                 return self
202             return super().__add__(other)
203         return self
204 
205     def __radd__(self, other):
206         return self.__add__(other)
207 
208     def __sub__(self, other):
209         # there is no notion of ordering (or magnitude) among dimension,
210         # subtraction is equivalent to addition when the operation is legal
211         return self + other
212 
213     def __rsub__(self, other):
214         # there is no notion of ordering (or magnitude) among dimension,
215         # subtraction is equivalent to addition when the operation is legal
216         return self + other
217 
218     def __pow__(self, other):
219         return self._eval_power(other)
220 
221     def _eval_power(self, other):
222         other = sympify(other)
223         return Dimension(self.name**other)
224 
225     def __mul__(self, other):
226         from sympy.physics.units.quantities import Quantity
227         if isinstance(other, Basic):
228             if other.has(Quantity):
229                 raise TypeError("cannot sum dimension and quantity")
230             if isinstance(other, Dimension):
231                 return Dimension(self.name*other.name)
232             if not other.free_symbols:  # other.is_number cannot be used
233                 return self
234             return super().__mul__(other)
235         return self
236 
237     def __rmul__(self, other):
238         return self.__mul__(other)
239 
240     def __truediv__(self, other):
241         return self*Pow(other, -1)
242 
243     def __rtruediv__(self, other):
244         return other * pow(self, -1)
245 
246     @classmethod
247     def _from_dimensional_dependencies(cls, dependencies):
248         return reduce(lambda x, y: x * y, (
249             d**e for d, e in dependencies.items()
250         ), 1)
251 
252     def has_integer_powers(self, dim_sys):
253         """
254         Check if the dimension object has only integer powers.
255 
256         All the dimension powers should be integers, but rational powers may
257         appear in intermediate steps. This method may be used to check that the
258         final result is well-defined.
259         """
260 
261         return all(dpow.is_Integer for dpow in dim_sys.get_dimensional_dependencies(self).values())
262 
263 
264 # Create dimensions according to the base units in MKSA.
265 # For other unit systems, they can be derived by transforming the base
266 # dimensional dependency dictionary.
267 
268 
269 class DimensionSystem(Basic, _QuantityMapper):
270     r"""
271     DimensionSystem represents a coherent set of dimensions.
272 
273     The constructor takes three parameters:
274 
275     - base dimensions;
276     - derived dimensions: these are defined in terms of the base dimensions
277       (for example velocity is defined from the division of length by time);
278     - dependency of dimensions: how the derived dimensions depend
279       on the base dimensions.
280 
281     Optionally either the ``derived_dims`` or the ``dimensional_dependencies``
282     may be omitted.
283     """
284 
285     def __new__(cls, base_dims, derived_dims=(), dimensional_dependencies={}):
286         dimensional_dependencies = dict(dimensional_dependencies)
287 
288         def parse_dim(dim):
289             if isinstance(dim, str):
290                 dim = Dimension(Symbol(dim))
291             elif isinstance(dim, Dimension):
292                 pass
293             elif isinstance(dim, Symbol):
294                 dim = Dimension(dim)
295             else:
296                 raise TypeError("%s wrong type" % dim)
297             return dim
298 
299         base_dims = [parse_dim(i) for i in base_dims]
300         derived_dims = [parse_dim(i) for i in derived_dims]
301 
302         for dim in base_dims:
303             if (dim in dimensional_dependencies
304                 and (len(dimensional_dependencies[dim]) != 1 or
305                 dimensional_dependencies[dim].get(dim, None) != 1)):
306                 raise IndexError("Repeated value in base dimensions")
307             dimensional_dependencies[dim] = Dict({dim: 1})
308 
309         def parse_dim_name(dim):
310             if isinstance(dim, Dimension):
311                 return dim
312             elif isinstance(dim, str):
313                 return Dimension(Symbol(dim))
314             elif isinstance(dim, Symbol):
315                 return Dimension(dim)
316             else:
317                 raise TypeError("unrecognized type %s for %s" % (type(dim), dim))
318 
319         for dim in dimensional_dependencies.keys():
320             dim = parse_dim(dim)
321             if (dim not in derived_dims) and (dim not in base_dims):
322                 derived_dims.append(dim)
323 
324         def parse_dict(d):
325             return Dict({parse_dim_name(i): j for i, j in d.items()})
326 
327         # Make sure everything is a SymPy type:
328         dimensional_dependencies = {parse_dim_name(i): parse_dict(j) for i, j in
329                                     dimensional_dependencies.items()}
330 
331         for dim in derived_dims:
332             if dim in base_dims:
333                 raise ValueError("Dimension %s both in base and derived" % dim)
334             if dim not in dimensional_dependencies:
335                 # TODO: should this raise a warning?
336                 dimensional_dependencies[dim] = Dict({dim: 1})
337 
338         base_dims.sort(key=default_sort_key)
339         derived_dims.sort(key=default_sort_key)
340 
341         base_dims = Tuple(*base_dims)
342         derived_dims = Tuple(*derived_dims)
343         dimensional_dependencies = Dict({i: Dict(j) for i, j in dimensional_dependencies.items()})
344         obj = Basic.__new__(cls, base_dims, derived_dims, dimensional_dependencies)
345         return obj
346 
347     @property
348     def base_dims(self):
349         return self.args[0]
350 
351     @property
352     def derived_dims(self):
353         return self.args[1]
354 
355     @property
356     def dimensional_dependencies(self):
357         return self.args[2]
358 
359     def _get_dimensional_dependencies_for_name(self, dimension):
360         if isinstance(dimension, str):
361             dimension = Dimension(Symbol(dimension))
362         elif not isinstance(dimension, Dimension):
363             dimension = Dimension(dimension)
364 
365         if dimension.name.is_Symbol:
366             # Dimensions not included in the dependencies are considered
367             # as base dimensions:
368             return dict(self.dimensional_dependencies.get(dimension, {dimension: 1}))
369 
370         if dimension.name.is_number or dimension.name.is_NumberSymbol:
371             return {}
372 
373         get_for_name = self._get_dimensional_dependencies_for_name
374 
375         if dimension.name.is_Mul:
376             ret = collections.defaultdict(int)
377             dicts = [get_for_name(i) for i in dimension.name.args]
378             for d in dicts:
379                 for k, v in d.items():
380                     ret[k] += v
381             return {k: v for (k, v) in ret.items() if v != 0}
382 
383         if dimension.name.is_Add:
384             dicts = [get_for_name(i) for i in dimension.name.args]
385             if all(d == dicts[0] for d in dicts[1:]):
386                 return dicts[0]
387             raise TypeError("Only equivalent dimensions can be added or subtracted.")
388 
389         if dimension.name.is_Pow:
390             dim_base = get_for_name(dimension.name.base)
391             dim_exp = get_for_name(dimension.name.exp)
392             if dim_exp == {} or dimension.name.exp.is_Symbol:
393                 return {k: v * dimension.name.exp for (k, v) in dim_base.items()}
394             else:
395                 raise TypeError("The exponent for the power operator must be a Symbol or dimensionless.")
396 
397         if dimension.name.is_Function:
398             args = (Dimension._from_dimensional_dependencies(
399                 get_for_name(arg)) for arg in dimension.name.args)
400             result = dimension.name.func(*args)
401 
402             dicts = [get_for_name(i) for i in dimension.name.args]
403 
404             if isinstance(result, Dimension):
405                 return self.get_dimensional_dependencies(result)
406             elif result.func == dimension.name.func:
407                 if isinstance(dimension.name, TrigonometricFunction):
408                     if dicts[0] in ({}, {Dimension('angle'): 1}):
409                         return {}
410                     else:
411                         raise TypeError("The input argument for the function {} must be dimensionless or have dimensions of angle.".format(dimension.func))
412                 else:
413                     if all(item == {} for item in dicts):
414                         return {}
415                     else:
416                         raise TypeError("The input arguments for the function {} must be dimensionless.".format(dimension.func))
417             else:
418                 return get_for_name(result)
419 
420         raise TypeError("Type {} not implemented for get_dimensional_dependencies".format(type(dimension.name)))
421 
422     def get_dimensional_dependencies(self, name, mark_dimensionless=False):
423         dimdep = self._get_dimensional_dependencies_for_name(name)
424         if mark_dimensionless and dimdep == {}:
425             return {Dimension(1): 1}
426         return {k: v for k, v in dimdep.items()}
427 
428     def equivalent_dims(self, dim1, dim2):
429         deps1 = self.get_dimensional_dependencies(dim1)
430         deps2 = self.get_dimensional_dependencies(dim2)
431         return deps1 == deps2
432 
433     def extend(self, new_base_dims, new_derived_dims=(), new_dim_deps=None):
434         deps = dict(self.dimensional_dependencies)
435         if new_dim_deps:
436             deps.update(new_dim_deps)
437 
438         new_dim_sys = DimensionSystem(
439             tuple(self.base_dims) + tuple(new_base_dims),
440             tuple(self.derived_dims) + tuple(new_derived_dims),
441             deps
442         )
443         new_dim_sys._quantity_dimension_map.update(self._quantity_dimension_map)
444         new_dim_sys._quantity_scale_factors.update(self._quantity_scale_factors)
445         return new_dim_sys
446 
447     def is_dimensionless(self, dimension):
448         """
449         Check if the dimension object really has a dimension.
450 
451         A dimension should have at least one component with non-zero power.
452         """
453         if dimension.name == 1:
454             return True
455         return self.get_dimensional_dependencies(dimension) == {}
456 
457     @property
458     def list_can_dims(self):
459         """
460         Useless method, kept for compatibility with previous versions.
461 
462         DO NOT USE.
463 
464         List all canonical dimension names.
465         """
466         dimset = set()
467         for i in self.base_dims:
468             dimset.update(set(self.get_dimensional_dependencies(i).keys()))
469         return tuple(sorted(dimset, key=str))
470 
471     @property
472     def inv_can_transf_matrix(self):
473         """
474         Useless method, kept for compatibility with previous versions.
475 
476         DO NOT USE.
477 
478         Compute the inverse transformation matrix from the base to the
479         canonical dimension basis.
480 
481         It corresponds to the matrix where columns are the vector of base
482         dimensions in canonical basis.
483 
484         This matrix will almost never be used because dimensions are always
485         defined with respect to the canonical basis, so no work has to be done
486         to get them in this basis. Nonetheless if this matrix is not square
487         (or not invertible) it means that we have chosen a bad basis.
488         """
489         matrix = reduce(lambda x, y: x.row_join(y),
490                         [self.dim_can_vector(d) for d in self.base_dims])
491         return matrix
492 
493     @property
494     def can_transf_matrix(self):
495         """
496         Useless method, kept for compatibility with previous versions.
497 
498         DO NOT USE.
499 
500         Return the canonical transformation matrix from the canonical to the
501         base dimension basis.
502 
503         It is the inverse of the matrix computed with inv_can_transf_matrix().
504         """
505 
506         #TODO: the inversion will fail if the system is inconsistent, for
507         #      example if the matrix is not a square
508         return reduce(lambda x, y: x.row_join(y),
509                       [self.dim_can_vector(d) for d in sorted(self.base_dims, key=str)]
510                       ).inv()
511 
512     def dim_can_vector(self, dim):
513         """
514         Useless method, kept for compatibility with previous versions.
515 
516         DO NOT USE.
517 
518         Dimensional representation in terms of the canonical base dimensions.
519         """
520 
521         vec = []
522         for d in self.list_can_dims:
523             vec.append(self.get_dimensional_dependencies(dim).get(d, 0))
524         return Matrix(vec)
525 
526     def dim_vector(self, dim):
527         """
528         Useless method, kept for compatibility with previous versions.
529 
530         DO NOT USE.
531 
532 
533         Vector representation in terms of the base dimensions.
534         """
535         return self.can_transf_matrix * Matrix(self.dim_can_vector(dim))
536 
537     def print_dim_base(self, dim):
538         """
539         Give the string expression of a dimension in term of the basis symbols.
540         """
541         dims = self.dim_vector(dim)
542         symbols = [i.symbol if i.symbol is not None else i.name for i in self.base_dims]
543         res = S.One
544         for (s, p) in zip(symbols, dims):
545             res *= s**p
546         return res
547 
548     @property
549     def dim(self):
550         """
551         Useless method, kept for compatibility with previous versions.
552 
553         DO NOT USE.
554 
555         Give the dimension of the system.
556 
557         That is return the number of dimensions forming the basis.
558         """
559         return len(self.base_dims)
560 
561     @property
562     def is_consistent(self):
563         """
564         Useless method, kept for compatibility with previous versions.
565 
566         DO NOT USE.
567 
568         Check if the system is well defined.
569         """
570 
571         # not enough or too many base dimensions compared to independent
572         # dimensions
573         # in vector language: the set of vectors do not form a basis
574         return self.inv_can_transf_matrix.is_square

</code><intended_behavior>This code should ensure that expressions which are inherently dimensionless (or can be simplified to be dimensionless) are recognized as such before being passed to an exp function. Furthermore, it may require modification or enhancement to properly interact with exponential functions, possibly by preprocessing expressions to validate their dimensionality or by simplifying them to a recognizable dimensionless state. The key is to prevent passing dimensionally inconsistent arguments to exp.</intended_behavior>, <file>sympy/physics/units/util.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Several methods to simplify expressions involving unit objects.
3 """
4 from functools import reduce
5 from collections.abc import Iterable
6 from typing import Optional
7 
8 from sympy import default_sort_key
9 from sympy.core.add import Add
10 from sympy.core.containers import Tuple
11 from sympy.core.mul import Mul
12 from sympy.core.power import Pow
13 from sympy.core.sorting import ordered
14 from sympy.core.sympify import sympify
15 from sympy.matrices.common import NonInvertibleMatrixError
16 from sympy.physics.units.dimensions import Dimension, DimensionSystem
17 from sympy.physics.units.prefixes import Prefix
18 from sympy.physics.units.quantities import Quantity
19 from sympy.physics.units.unitsystem import UnitSystem
20 from sympy.utilities.iterables import sift
21 
22 
23 def _get_conversion_matrix_for_expr(expr, target_units, unit_system):
24     from sympy.matrices.dense import Matrix
25 
26     dimension_system = unit_system.get_dimension_system()
27 
28     expr_dim = Dimension(unit_system.get_dimensional_expr(expr))
29     dim_dependencies = dimension_system.get_dimensional_dependencies(expr_dim, mark_dimensionless=True)
30     target_dims = [Dimension(unit_system.get_dimensional_expr(x)) for x in target_units]
31     canon_dim_units = [i for x in target_dims for i in dimension_system.get_dimensional_dependencies(x, mark_dimensionless=True)]
32     canon_expr_units = {i for i in dim_dependencies}
33 
34     if not canon_expr_units.issubset(set(canon_dim_units)):
35         return None
36 
37     seen = set()
38     canon_dim_units = [i for i in canon_dim_units if not (i in seen or seen.add(i))]
39 
40     camat = Matrix([[dimension_system.get_dimensional_dependencies(i, mark_dimensionless=True).get(j, 0) for i in target_dims] for j in canon_dim_units])
41     exprmat = Matrix([dim_dependencies.get(k, 0) for k in canon_dim_units])
42 
43     try:
44         res_exponents = camat.solve(exprmat)
45     except NonInvertibleMatrixError:
46         return None
47 
48     return res_exponents
49 
50 
51 def convert_to(expr, target_units, unit_system="SI"):
52     """
53     Convert ``expr`` to the same expression with all of its units and quantities
54     represented as factors of ``target_units``, whenever the dimension is compatible.
55 
56     ``target_units`` may be a single unit/quantity, or a collection of
57     units/quantities.
58 
59     Examples
60     ========
61 
62     >>> from sympy.physics.units import speed_of_light, meter, gram, second, day
63     >>> from sympy.physics.units import mile, newton, kilogram, atomic_mass_constant
64     >>> from sympy.physics.units import kilometer, centimeter
65     >>> from sympy.physics.units import gravitational_constant, hbar
66     >>> from sympy.physics.units import convert_to
67     >>> convert_to(mile, kilometer)
68     25146*kilometer/15625
69     >>> convert_to(mile, kilometer).n()
70     1.609344*kilometer
71     >>> convert_to(speed_of_light, meter/second)
72     299792458*meter/second
73     >>> convert_to(day, second)
74     86400*second
75     >>> 3*newton
76     3*newton
77     >>> convert_to(3*newton, kilogram*meter/second**2)
78     3*kilogram*meter/second**2
79     >>> convert_to(atomic_mass_constant, gram)
80     1.660539060e-24*gram
81 
82     Conversion to multiple units:
83 
84     >>> convert_to(speed_of_light, [meter, second])
85     299792458*meter/second
86     >>> convert_to(3*newton, [centimeter, gram, second])
87     300000*centimeter*gram/second**2
88 
89     Conversion to Planck units:
90 
91     >>> convert_to(atomic_mass_constant, [gravitational_constant, speed_of_light, hbar]).n()
92     7.62963087839509e-20*hbar**0.5*speed_of_light**0.5/gravitational_constant**0.5
93 
94     """
95     from sympy.physics.units import UnitSystem
96     unit_system = UnitSystem.get_unit_system(unit_system)
97 
98     if not isinstance(target_units, (Iterable, Tuple)):
99         target_units = [target_units]
100 
101     if isinstance(expr, Add):
102         return Add.fromiter(convert_to(i, target_units, unit_system)
103             for i in expr.args)
104 
105     expr = sympify(expr)
106     target_units = sympify(target_units)
107 
108     if not isinstance(expr, Quantity) and expr.has(Quantity):
109         expr = expr.replace(lambda x: isinstance(x, Quantity),
110             lambda x: x.convert_to(target_units, unit_system))
111 
112     def get_total_scale_factor(expr):
113         if isinstance(expr, Mul):
114             return reduce(lambda x, y: x * y,
115                 [get_total_scale_factor(i) for i in expr.args])
116         elif isinstance(expr, Pow):
117             return get_total_scale_factor(expr.base) ** expr.exp
118         elif isinstance(expr, Quantity):
119             return unit_system.get_quantity_scale_factor(expr)
120         return expr
121 
122     depmat = _get_conversion_matrix_for_expr(expr, target_units, unit_system)
123     if depmat is None:
124         return expr
125 
126     expr_scale_factor = get_total_scale_factor(expr)
127     return expr_scale_factor * Mul.fromiter(
128         (1/get_total_scale_factor(u)*u)**p for u, p in
129         zip(target_units, depmat))
130 
131 
132 def quantity_simplify(expr, across_dimensions: bool=False, unit_system=None):
133     """Return an equivalent expression in which prefixes are replaced
134     with numerical values and all units of a given dimension are the
135     unified in a canonical manner by default. `across_dimensions` allows
136     for units of different dimensions to be simplified together.
137 
138     `unit_system` must be specified if `across_dimensions` is True.
139 
140     Examples
141     ========
142 
143     >>> from sympy.physics.units.util import quantity_simplify
144     >>> from sympy.physics.units.prefixes import kilo
145     >>> from sympy.physics.units import foot, inch, joule, coulomb
146     >>> quantity_simplify(kilo*foot*inch)
147     250*foot**2/3
148     >>> quantity_simplify(foot - 6*inch)
149     foot/2
150     >>> quantity_simplify(5*joule/coulomb, across_dimensions=True, unit_system="SI")
151     5*volt
152     """
153 
154     if expr.is_Atom or not expr.has(Prefix, Quantity):
155         return expr
156 
157     # replace all prefixes with numerical values
158     p = expr.atoms(Prefix)
159     expr = expr.xreplace({p: p.scale_factor for p in p})
160 
161     # replace all quantities of given dimension with a canonical
162     # quantity, chosen from those in the expression
163     d = sift(expr.atoms(Quantity), lambda i: i.dimension)
164     for k in d:
165         if len(d[k]) == 1:
166             continue
167         v = list(ordered(d[k]))
168         ref = v[0]/v[0].scale_factor
169         expr = expr.xreplace({vi: ref*vi.scale_factor for vi in v[1:]})
170 
171     if across_dimensions:
172         # combine quantities of different dimensions into a single
173         # quantity that is equivalent to the original expression
174 
175         if unit_system is None:
176             raise ValueError("unit_system must be specified if across_dimensions is True")
177 
178         unit_system = UnitSystem.get_unit_system(unit_system)
179         dimension_system: DimensionSystem = unit_system.get_dimension_system()
180         dim_expr = unit_system.get_dimensional_expr(expr)
181         dim_deps = dimension_system.get_dimensional_dependencies(dim_expr, mark_dimensionless=True)
182 
183         target_dimension: Optional[Dimension] = None
184         for ds_dim, ds_dim_deps in dimension_system.dimensional_dependencies.items():
185             if ds_dim_deps == dim_deps:
186                 target_dimension = ds_dim
187                 break
188 
189         if target_dimension is None:
190             # if we can't find a target dimension, we can't do anything. unsure how to handle this case.
191             return expr
192 
193         target_unit = unit_system.derived_units.get(target_dimension)
194         if target_unit:
195             expr = convert_to(expr, target_unit, unit_system)
196 
197     return expr
198 
199 
200 def check_dimensions(expr, unit_system="SI"):
201     """Return expr if units in addends have the same
202     base dimensions, else raise a ValueError."""
203     # the case of adding a number to a dimensional quantity
204     # is ignored for the sake of SymPy core routines, so this
205     # function will raise an error now if such an addend is
206     # found.
207     # Also, when doing substitutions, multiplicative constants
208     # might be introduced, so remove those now
209 
210     from sympy.physics.units import UnitSystem
211     unit_system = UnitSystem.get_unit_system(unit_system)
212 
213     def addDict(dict1, dict2):
214         """Merge dictionaries by adding values of common keys and
215         removing keys with value of 0."""
216         dict3 = {**dict1, **dict2}
217         for key, value in dict3.items():
218             if key in dict1 and key in dict2:
219                    dict3[key] = value + dict1[key]
220         return {key:val for key, val in dict3.items() if val != 0}
221 
222     adds = expr.atoms(Add)
223     DIM_OF = unit_system.get_dimension_system().get_dimensional_dependencies
224     for a in adds:
225         deset = set()
226         for ai in a.args:
227             if ai.is_number:
228                 deset.add(())
229                 continue
230             dims = []
231             skip = False
232             dimdict = {}
233             for i in Mul.make_args(ai):
234                 if i.has(Quantity):
235                     i = Dimension(unit_system.get_dimensional_expr(i))
236                 if i.has(Dimension):
237                     dimdict = addDict(dimdict, DIM_OF(i))
238                 elif i.free_symbols:
239                     skip = True
240                     break
241             dims.extend(dimdict.items())
242             if not skip:
243                 deset.add(tuple(sorted(dims, key=default_sort_key)))
244                 if len(deset) > 1:
245                     raise ValueError(
246                         "addends have incompatible dimensions: {}".format(deset))
247 
248     # clear multiplicative constants on Dimensions which may be
249     # left after substitution
250     reps = {}
251     for m in expr.atoms(Mul):
252         if any(isinstance(i, Dimension) for i in m.args):
253             reps[m] = m.func(*[
254                 i for i in m.args if not i.is_number])
255 
256     return expr.xreplace(reps)

</code><intended_behavior>Enhance the utility functions to more robustly identify and handle expressions, particularly looking out for scenarios where operations could lead to dimensionally ambiguous results in exponential contexts. This includes better detection of dimensionless quantities or more aggressive simplification strategies to ensure that expressions going into exponential functions do not carry erroneous or incompatible dimensions.</intended_behavior>, <file>sympy/physics/units/systems/si.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SI unit system.
3 Based on MKSA, which stands for "meter, kilogram, second, ampere".
4 Added kelvin, candela and mole.
5 
6 """
7 
8 from typing import List
9 
10 from sympy.physics.units import DimensionSystem, Dimension, dHg0
11 
12 from sympy.physics.units.quantities import Quantity
13 
14 from sympy.core.numbers import (Rational, pi)
15 from sympy.core.singleton import S
16 from sympy.functions.elementary.miscellaneous import sqrt
17 from sympy.physics.units.definitions.dimension_definitions import (
18     acceleration, action, current, impedance, length, mass, time, velocity,
19     amount_of_substance, temperature, information, frequency, force, pressure,
20     energy, power, charge, voltage, capacitance, conductance, magnetic_flux,
21     magnetic_density, inductance, luminous_intensity
22 )
23 from sympy.physics.units.definitions import (
24     kilogram, newton, second, meter, gram, cd, K, joule, watt, pascal, hertz,
25     coulomb, volt, ohm, siemens, farad, henry, tesla, weber, dioptre, lux,
26     katal, gray, becquerel, inch, liter, julian_year, gravitational_constant,
27     speed_of_light, elementary_charge, planck, hbar, electronvolt,
28     avogadro_number, avogadro_constant, boltzmann_constant,
29     stefan_boltzmann_constant, Da, atomic_mass_constant, molar_gas_constant,
30     faraday_constant, josephson_constant, von_klitzing_constant,
31     acceleration_due_to_gravity, magnetic_constant, vacuum_permittivity,
32     vacuum_impedance, coulomb_constant, atmosphere, bar, pound, psi, mmHg,
33     milli_mass_unit, quart, lightyear, astronomical_unit, planck_mass,
34     planck_time, planck_temperature, planck_length, planck_charge, planck_area,
35     planck_volume, planck_momentum, planck_energy, planck_force, planck_power,
36     planck_density, planck_energy_density, planck_intensity,
37     planck_angular_frequency, planck_pressure, planck_current, planck_voltage,
38     planck_impedance, planck_acceleration, bit, byte, kibibyte, mebibyte,
39     gibibyte, tebibyte, pebibyte, exbibyte, curie, rutherford, radian, degree,
40     steradian, angular_mil, atomic_mass_unit, gee, kPa, ampere, u0, c, kelvin,
41     mol, mole, candela, m, kg, s, electric_constant, G, boltzmann
42 )
43 from sympy.physics.units.prefixes import PREFIXES, prefix_unit
44 from sympy.physics.units.systems.mksa import MKSA, dimsys_MKSA
45 
46 derived_dims = (frequency, force, pressure, energy, power, charge, voltage,
47                 capacitance, conductance, magnetic_flux,
48                 magnetic_density, inductance, luminous_intensity)
49 base_dims = (amount_of_substance, luminous_intensity, temperature)
50 
51 units = [mol, cd, K, lux, hertz, newton, pascal, joule, watt, coulomb, volt,
52         farad, ohm, siemens, weber, tesla, henry, candela, lux, becquerel,
53         gray, katal]
54 
55 all_units = []  # type: List[Quantity]
56 for u in units:
57     all_units.extend(prefix_unit(u, PREFIXES))
58 
59 all_units.extend(units)
60 all_units.extend([mol, cd, K, lux])
61 
62 
63 dimsys_SI = dimsys_MKSA.extend(
64     [
65         # Dimensional dependencies for other base dimensions:
66         temperature,
67         amount_of_substance,
68         luminous_intensity,
69     ])
70 
71 dimsys_default = dimsys_SI.extend(
72     [information],
73 )
74 
75 SI = MKSA.extend(base=(mol, cd, K), units=all_units, name='SI', dimension_system=dimsys_SI, derived_units={
76     power: watt,
77     magnetic_flux: weber,
78     time: second,
79     impedance: ohm,
80     pressure: pascal,
81     current: ampere,
82     voltage: volt,
83     length: meter,
84     frequency: hertz,
85     inductance: henry,
86     temperature: kelvin,
87     amount_of_substance: mole,
88     luminous_intensity: candela,
89     conductance: siemens,
90     mass: kilogram,
91     magnetic_density: tesla,
92     charge: coulomb,
93     force: newton,
94     capacitance: farad,
95     energy: joule,
96     velocity: meter/second,
97 })
98 
99 One = S.One
100 
101 SI.set_quantity_dimension(radian, One)
102 
103 SI.set_quantity_scale_factor(ampere, One)
104 
105 SI.set_quantity_scale_factor(kelvin, One)
106 
107 SI.set_quantity_scale_factor(mole, One)
108 
109 SI.set_quantity_scale_factor(candela, One)
110 
111 # MKSA extension to MKS: derived units
112 
113 SI.set_quantity_scale_factor(coulomb, One)
114 
115 SI.set_quantity_scale_factor(volt, joule/coulomb)
116 
117 SI.set_quantity_scale_factor(ohm, volt/ampere)
118 
119 SI.set_quantity_scale_factor(siemens, ampere/volt)
120 
121 SI.set_quantity_scale_factor(farad, coulomb/volt)
122 
123 SI.set_quantity_scale_factor(henry, volt*second/ampere)
124 
125 SI.set_quantity_scale_factor(tesla, volt*second/meter**2)
126 
127 SI.set_quantity_scale_factor(weber, joule/ampere)
128 
129 
130 SI.set_quantity_dimension(lux, luminous_intensity / length ** 2)
131 SI.set_quantity_scale_factor(lux, steradian*candela/meter**2)
132 
133 # katal is the SI unit of catalytic activity
134 
135 SI.set_quantity_dimension(katal, amount_of_substance / time)
136 SI.set_quantity_scale_factor(katal, mol/second)
137 
138 # gray is the SI unit of absorbed dose
139 
140 SI.set_quantity_dimension(gray, energy / mass)
141 SI.set_quantity_scale_factor(gray, meter**2/second**2)
142 
143 # becquerel is the SI unit of radioactivity
144 
145 SI.set_quantity_dimension(becquerel, 1 / time)
146 SI.set_quantity_scale_factor(becquerel, 1/second)
147 
148 #### CONSTANTS ####
149 
150 # elementary charge
151 # REF: NIST SP 959 (June 2019)
152 
153 SI.set_quantity_dimension(elementary_charge, charge)
154 SI.set_quantity_scale_factor(elementary_charge, 1.602176634e-19*coulomb)
155 
156 # Electronvolt
157 # REF: NIST SP 959 (June 2019)
158 
159 SI.set_quantity_dimension(electronvolt, energy)
160 SI.set_quantity_scale_factor(electronvolt, 1.602176634e-19*joule)
161 
162 # Avogadro number
163 # REF: NIST SP 959 (June 2019)
164 
165 SI.set_quantity_dimension(avogadro_number, One)
166 SI.set_quantity_scale_factor(avogadro_number, 6.02214076e23)
167 
168 # Avogadro constant
169 
170 SI.set_quantity_dimension(avogadro_constant, amount_of_substance ** -1)
171 SI.set_quantity_scale_factor(avogadro_constant, avogadro_number / mol)
172 
173 # Boltzmann constant
174 # REF: NIST SP 959 (June 2019)
175 
176 SI.set_quantity_dimension(boltzmann_constant, energy / temperature)
177 SI.set_quantity_scale_factor(boltzmann_constant, 1.380649e-23*joule/kelvin)
178 
179 # Stefan-Boltzmann constant
180 # REF: NIST SP 959 (June 2019)
181 
182 SI.set_quantity_dimension(stefan_boltzmann_constant, energy * time ** -1 * length ** -2 * temperature ** -4)
183 SI.set_quantity_scale_factor(stefan_boltzmann_constant, pi**2 * boltzmann_constant**4 / (60 * hbar**3 * speed_of_light ** 2))
184 
185 # Atomic mass
186 # REF: NIST SP 959 (June 2019)
187 
188 SI.set_quantity_dimension(atomic_mass_constant, mass)
189 SI.set_quantity_scale_factor(atomic_mass_constant, 1.66053906660e-24*gram)
190 
191 # Molar gas constant
192 # REF: NIST SP 959 (June 2019)
193 
194 SI.set_quantity_dimension(molar_gas_constant, energy / (temperature * amount_of_substance))
195 SI.set_quantity_scale_factor(molar_gas_constant, boltzmann_constant * avogadro_constant)
196 
197 # Faraday constant
198 
199 SI.set_quantity_dimension(faraday_constant, charge / amount_of_substance)
200 SI.set_quantity_scale_factor(faraday_constant, elementary_charge * avogadro_constant)
201 
202 # Josephson constant
203 
204 SI.set_quantity_dimension(josephson_constant, frequency / voltage)
205 SI.set_quantity_scale_factor(josephson_constant, 0.5 * planck / elementary_charge)
206 
207 # Von Klitzing constant
208 
209 SI.set_quantity_dimension(von_klitzing_constant, voltage / current)
210 SI.set_quantity_scale_factor(von_klitzing_constant, hbar / elementary_charge ** 2)
211 
212 # Acceleration due to gravity (on the Earth surface)
213 
214 SI.set_quantity_dimension(acceleration_due_to_gravity, acceleration)
215 SI.set_quantity_scale_factor(acceleration_due_to_gravity, 9.80665*meter/second**2)
216 
217 # magnetic constant:
218 
219 SI.set_quantity_dimension(magnetic_constant, force / current ** 2)
220 SI.set_quantity_scale_factor(magnetic_constant, 4*pi/10**7 * newton/ampere**2)
221 
222 # electric constant:
223 
224 SI.set_quantity_dimension(vacuum_permittivity, capacitance / length)
225 SI.set_quantity_scale_factor(vacuum_permittivity, 1/(u0 * c**2))
226 
227 # vacuum impedance:
228 
229 SI.set_quantity_dimension(vacuum_impedance, impedance)
230 SI.set_quantity_scale_factor(vacuum_impedance, u0 * c)
231 
232 # Coulomb's constant:
233 SI.set_quantity_dimension(coulomb_constant, force * length ** 2 / charge ** 2)
234 SI.set_quantity_scale_factor(coulomb_constant, 1/(4*pi*vacuum_permittivity))
235 
236 SI.set_quantity_dimension(psi, pressure)
237 SI.set_quantity_scale_factor(psi, pound * gee / inch ** 2)
238 
239 SI.set_quantity_dimension(mmHg, pressure)
240 SI.set_quantity_scale_factor(mmHg, dHg0 * acceleration_due_to_gravity * kilogram / meter**2)
241 
242 SI.set_quantity_dimension(milli_mass_unit, mass)
243 SI.set_quantity_scale_factor(milli_mass_unit, atomic_mass_unit/1000)
244 
245 SI.set_quantity_dimension(quart, length ** 3)
246 SI.set_quantity_scale_factor(quart, Rational(231, 4) * inch**3)
247 
248 # Other convenient units and magnitudes
249 
250 SI.set_quantity_dimension(lightyear, length)
251 SI.set_quantity_scale_factor(lightyear, speed_of_light*julian_year)
252 
253 SI.set_quantity_dimension(astronomical_unit, length)
254 SI.set_quantity_scale_factor(astronomical_unit, 149597870691*meter)
255 
256 # Fundamental Planck units:
257 
258 SI.set_quantity_dimension(planck_mass, mass)
259 SI.set_quantity_scale_factor(planck_mass, sqrt(hbar*speed_of_light/G))
260 
261 SI.set_quantity_dimension(planck_time, time)
262 SI.set_quantity_scale_factor(planck_time, sqrt(hbar*G/speed_of_light**5))
263 
264 SI.set_quantity_dimension(planck_temperature, temperature)
265 SI.set_quantity_scale_factor(planck_temperature, sqrt(hbar*speed_of_light**5/G/boltzmann**2))
266 
267 SI.set_quantity_dimension(planck_length, length)
268 SI.set_quantity_scale_factor(planck_length, sqrt(hbar*G/speed_of_light**3))
269 
270 SI.set_quantity_dimension(planck_charge, charge)
271 SI.set_quantity_scale_factor(planck_charge, sqrt(4*pi*electric_constant*hbar*speed_of_light))
272 
273 # Derived Planck units:
274 
275 SI.set_quantity_dimension(planck_area, length ** 2)
276 SI.set_quantity_scale_factor(planck_area, planck_length**2)
277 
278 SI.set_quantity_dimension(planck_volume, length ** 3)
279 SI.set_quantity_scale_factor(planck_volume, planck_length**3)
280 
281 SI.set_quantity_dimension(planck_momentum, mass * velocity)
282 SI.set_quantity_scale_factor(planck_momentum, planck_mass * speed_of_light)
283 
284 SI.set_quantity_dimension(planck_energy, energy)
285 SI.set_quantity_scale_factor(planck_energy, planck_mass * speed_of_light**2)
286 
287 SI.set_quantity_dimension(planck_force, force)
288 SI.set_quantity_scale_factor(planck_force, planck_energy / planck_length)
289 
290 SI.set_quantity_dimension(planck_power, power)
291 SI.set_quantity_scale_factor(planck_power, planck_energy / planck_time)
292 
293 SI.set_quantity_dimension(planck_density, mass / length ** 3)
294 SI.set_quantity_scale_factor(planck_density, planck_mass / planck_length**3)
295 
296 SI.set_quantity_dimension(planck_energy_density, energy / length ** 3)
297 SI.set_quantity_scale_factor(planck_energy_density, planck_energy / planck_length**3)
298 
299 SI.set_quantity_dimension(planck_intensity, mass * time ** (-3))
300 SI.set_quantity_scale_factor(planck_intensity, planck_energy_density * speed_of_light)
301 
302 SI.set_quantity_dimension(planck_angular_frequency, 1 / time)
303 SI.set_quantity_scale_factor(planck_angular_frequency, 1 / planck_time)
304 
305 SI.set_quantity_dimension(planck_pressure, pressure)
306 SI.set_quantity_scale_factor(planck_pressure, planck_force / planck_length**2)
307 
308 SI.set_quantity_dimension(planck_current, current)
309 SI.set_quantity_scale_factor(planck_current, planck_charge / planck_time)
310 
311 SI.set_quantity_dimension(planck_voltage, voltage)
312 SI.set_quantity_scale_factor(planck_voltage, planck_energy / planck_charge)
313 
314 SI.set_quantity_dimension(planck_impedance, impedance)
315 SI.set_quantity_scale_factor(planck_impedance, planck_voltage / planck_current)
316 
317 SI.set_quantity_dimension(planck_acceleration, acceleration)
318 SI.set_quantity_scale_factor(planck_acceleration, speed_of_light / planck_time)
319 
320 # Older units for radioactivity
321 
322 SI.set_quantity_dimension(curie, 1 / time)
323 SI.set_quantity_scale_factor(curie, 37000000000*becquerel)
324 
325 SI.set_quantity_dimension(rutherford, 1 / time)
326 SI.set_quantity_scale_factor(rutherford, 1000000*becquerel)
327 
328 
329 # check that scale factors are the right SI dimensions:
330 for _scale_factor, _dimension in zip(
331     SI._quantity_scale_factors.values(),
332     SI._quantity_dimension_map.values()
333 ):
334     dimex = SI.get_dimensional_expr(_scale_factor)
335     if dimex != 1:
336         # XXX: equivalent_dims is an instance method taking two arguments in
337         # addition to self so this can not work:
338         if not DimensionSystem.equivalent_dims(_dimension, Dimension(dimex)):  # type: ignore
339             raise ValueError("quantity value and dimension mismatch")
340 del _scale_factor, _dimension
341 
342 __all__ = [
343     'mmHg', 'atmosphere', 'inductance', 'newton', 'meter',
344     'vacuum_permittivity', 'pascal', 'magnetic_constant', 'voltage',
345     'angular_mil', 'luminous_intensity', 'all_units',
346     'julian_year', 'weber', 'exbibyte', 'liter',
347     'molar_gas_constant', 'faraday_constant', 'avogadro_constant',
348     'lightyear', 'planck_density', 'gee', 'mol', 'bit', 'gray',
349     'planck_momentum', 'bar', 'magnetic_density', 'prefix_unit', 'PREFIXES',
350     'planck_time', 'dimex', 'gram', 'candela', 'force', 'planck_intensity',
351     'energy', 'becquerel', 'planck_acceleration', 'speed_of_light',
352     'conductance', 'frequency', 'coulomb_constant', 'degree', 'lux', 'planck',
353     'current', 'planck_current', 'tebibyte', 'planck_power', 'MKSA', 'power',
354     'K', 'planck_volume', 'quart', 'pressure', 'amount_of_substance',
355     'joule', 'boltzmann_constant', 'Dimension', 'c', 'planck_force', 'length',
356     'watt', 'action', 'hbar', 'gibibyte', 'DimensionSystem', 'cd', 'volt',
357     'planck_charge', 'dioptre', 'vacuum_impedance', 'dimsys_default', 'farad',
358     'charge', 'gravitational_constant', 'temperature', 'u0', 'hertz',
359     'capacitance', 'tesla', 'steradian', 'planck_mass', 'josephson_constant',
360     'planck_area', 'stefan_boltzmann_constant', 'base_dims',
361     'astronomical_unit', 'radian', 'planck_voltage', 'impedance',
362     'planck_energy', 'Da', 'atomic_mass_constant', 'rutherford', 'second', 'inch',
363     'elementary_charge', 'SI', 'electronvolt', 'dimsys_SI', 'henry',
364     'planck_angular_frequency', 'ohm', 'pound', 'planck_pressure', 'G', 'psi',
365     'dHg0', 'von_klitzing_constant', 'planck_length', 'avogadro_number',
366     'mole', 'acceleration', 'information', 'planck_energy_density',
367     'mebibyte', 's', 'acceleration_due_to_gravity',
368     'planck_temperature', 'units', 'mass', 'dimsys_MKSA', 'kelvin', 'kPa',
369     'boltzmann', 'milli_mass_unit', 'planck_impedance', 'electric_constant',
370     'derived_dims', 'kg', 'coulomb', 'siemens', 'byte', 'magnetic_flux',
371     'atomic_mass_unit', 'm', 'kibibyte', 'kilogram', 'One', 'curie', 'u',
372     'time', 'pebibyte', 'velocity', 'ampere', 'katal',
373 ]

</code><intended_behavior>Ensure that the SI unit system's handling of dimensionality and unit operations conforms to mathematical standards, especially regarding exponentiation. This might involve specific checks or transformations when dealing with exponential operations to ensure that arguments are dimensionless when required.</intended_behavior>]
2025-10-15 15:13:04.682 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:13:04.682 | INFO     | Search-only: skipping patch selection
2025-10-15 15:13:04.942 | INFO     | Task sympy__sympy-24066 completed successfully.
2025-10-15 15:13:04.943 | INFO     | No patch generated. You can try running ACR again.
