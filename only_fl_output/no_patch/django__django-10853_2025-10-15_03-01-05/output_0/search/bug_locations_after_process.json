[
    {
        "rel_file_path": "django/db/backends/sqlite3/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/sqlite3/base.py",
        "start": 77,
        "end": 367,
        "class_name": "DatabaseWrapper",
        "method_name": null,
        "code": "77 class DatabaseWrapper(BaseDatabaseWrapper):\n78     vendor = 'sqlite'\n79     display_name = 'SQLite'\n80     # SQLite doesn't actually support most of these types, but it \"does the right\n81     # thing\" given more verbose field definitions, so leave them as is so that\n82     # schema inspection is more useful.\n83     data_types = {\n84         'AutoField': 'integer',\n85         'BigAutoField': 'integer',\n86         'BinaryField': 'BLOB',\n87         'BooleanField': 'bool',\n88         'CharField': 'varchar(%(max_length)s)',\n89         'DateField': 'date',\n90         'DateTimeField': 'datetime',\n91         'DecimalField': 'decimal',\n92         'DurationField': 'bigint',\n93         'FileField': 'varchar(%(max_length)s)',\n94         'FilePathField': 'varchar(%(max_length)s)',\n95         'FloatField': 'real',\n96         'IntegerField': 'integer',\n97         'BigIntegerField': 'bigint',\n98         'IPAddressField': 'char(15)',\n99         'GenericIPAddressField': 'char(39)',\n100         'NullBooleanField': 'bool',\n101         'OneToOneField': 'integer',\n102         'PositiveIntegerField': 'integer unsigned',\n103         'PositiveSmallIntegerField': 'smallint unsigned',\n104         'SlugField': 'varchar(%(max_length)s)',\n105         'SmallIntegerField': 'smallint',\n106         'TextField': 'text',\n107         'TimeField': 'time',\n108         'UUIDField': 'char(32)',\n109     }\n110     data_type_check_constraints = {\n111         'PositiveIntegerField': '\"%(column)s\" >= 0',\n112         'PositiveSmallIntegerField': '\"%(column)s\" >= 0',\n113     }\n114     data_types_suffix = {\n115         'AutoField': 'AUTOINCREMENT',\n116         'BigAutoField': 'AUTOINCREMENT',\n117     }\n118     # SQLite requires LIKE statements to include an ESCAPE clause if the value\n119     # being escaped has a percent or underscore in it.\n120     # See https://www.sqlite.org/lang_expr.html for an explanation.\n121     operators = {\n122         'exact': '= %s',\n123         'iexact': \"LIKE %s ESCAPE '\\\\'\",\n124         'contains': \"LIKE %s ESCAPE '\\\\'\",\n125         'icontains': \"LIKE %s ESCAPE '\\\\'\",\n126         'regex': 'REGEXP %s',\n127         'iregex': \"REGEXP '(?i)' || %s\",\n128         'gt': '> %s',\n129         'gte': '>= %s',\n130         'lt': '< %s',\n131         'lte': '<= %s',\n132         'startswith': \"LIKE %s ESCAPE '\\\\'\",\n133         'endswith': \"LIKE %s ESCAPE '\\\\'\",\n134         'istartswith': \"LIKE %s ESCAPE '\\\\'\",\n135         'iendswith': \"LIKE %s ESCAPE '\\\\'\",\n136     }\n137 \n138     # The patterns below are used to generate SQL pattern lookup clauses when\n139     # the right-hand side of the lookup isn't a raw string (it might be an expression\n140     # or the result of a bilateral transformation).\n141     # In those cases, special characters for LIKE operators (e.g. \\, *, _) should be\n142     # escaped on database side.\n143     #\n144     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n145     # the LIKE operator.\n146     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, '\\', '\\\\'), '%%', '\\%%'), '_', '\\_')\"\n147     pattern_ops = {\n148         'contains': r\"LIKE '%%' || {} || '%%' ESCAPE '\\'\",\n149         'icontains': r\"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\\'\",\n150         'startswith': r\"LIKE {} || '%%' ESCAPE '\\'\",\n151         'istartswith': r\"LIKE UPPER({}) || '%%' ESCAPE '\\'\",\n152         'endswith': r\"LIKE '%%' || {} ESCAPE '\\'\",\n153         'iendswith': r\"LIKE '%%' || UPPER({}) ESCAPE '\\'\",\n154     }\n155 \n156     Database = Database\n157     SchemaEditorClass = DatabaseSchemaEditor\n158     # Classes instantiated in __init__().\n159     client_class = DatabaseClient\n160     creation_class = DatabaseCreation\n161     features_class = DatabaseFeatures\n162     introspection_class = DatabaseIntrospection\n163     ops_class = DatabaseOperations\n164 \n165     def get_connection_params(self):\n166         settings_dict = self.settings_dict\n167         if not settings_dict['NAME']:\n168             raise ImproperlyConfigured(\n169                 \"settings.DATABASES is improperly configured. \"\n170                 \"Please supply the NAME value.\")\n171         kwargs = {\n172             'database': settings_dict['NAME'],\n173             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n174             **settings_dict['OPTIONS'],\n175         }\n176         # Always allow the underlying SQLite connection to be shareable\n177         # between multiple threads. The safe-guarding will be handled at a\n178         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n179         # property. This is necessary as the shareability is disabled by\n180         # default in pysqlite and it cannot be changed once a connection is\n181         # opened.\n182         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n183             warnings.warn(\n184                 'The `check_same_thread` option was provided and set to '\n185                 'True. It will be overridden with False. Use the '\n186                 '`DatabaseWrapper.allow_thread_sharing` property instead '\n187                 'for controlling thread shareability.',\n188                 RuntimeWarning\n189             )\n190         kwargs.update({'check_same_thread': False, 'uri': True})\n191         return kwargs\n192 \n193     def get_new_connection(self, conn_params):\n194         conn = Database.connect(**conn_params)\n195         conn.create_function(\"django_date_extract\", 2, _sqlite_datetime_extract)\n196         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n197         conn.create_function(\"django_datetime_cast_date\", 2, _sqlite_datetime_cast_date)\n198         conn.create_function(\"django_datetime_cast_time\", 2, _sqlite_datetime_cast_time)\n199         conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)\n200         conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)\n201         conn.create_function(\"django_time_extract\", 2, _sqlite_time_extract)\n202         conn.create_function(\"django_time_trunc\", 2, _sqlite_time_trunc)\n203         conn.create_function(\"django_time_diff\", 2, _sqlite_time_diff)\n204         conn.create_function(\"django_timestamp_diff\", 2, _sqlite_timestamp_diff)\n205         conn.create_function(\"django_format_dtdelta\", 3, _sqlite_format_dtdelta)\n206         conn.create_function('regexp', 2, _sqlite_regexp)\n207         conn.create_function('ACOS', 1, none_guard(math.acos))\n208         conn.create_function('ASIN', 1, none_guard(math.asin))\n209         conn.create_function('ATAN', 1, none_guard(math.atan))\n210         conn.create_function('ATAN2', 2, none_guard(math.atan2))\n211         conn.create_function('CEILING', 1, none_guard(math.ceil))\n212         conn.create_function('COS', 1, none_guard(math.cos))\n213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))\n214         conn.create_function('DEGREES', 1, none_guard(math.degrees))\n215         conn.create_function('EXP', 1, none_guard(math.exp))\n216         conn.create_function('FLOOR', 1, none_guard(math.floor))\n217         conn.create_function('LN', 1, none_guard(math.log))\n218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))\n219         conn.create_function('LPAD', 3, _sqlite_lpad)\n220         conn.create_function('MOD', 2, none_guard(math.fmod))\n221         conn.create_function('PI', 0, lambda: math.pi)\n222         conn.create_function('POWER', 2, none_guard(operator.pow))\n223         conn.create_function('RADIANS', 1, none_guard(math.radians))\n224         conn.create_function('REPEAT', 2, none_guard(operator.mul))\n225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))\n226         conn.create_function('RPAD', 3, _sqlite_rpad)\n227         conn.create_function('SIN', 1, none_guard(math.sin))\n228         conn.create_function('SQRT', 1, none_guard(math.sqrt))\n229         conn.create_function('TAN', 1, none_guard(math.tan))\n230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))\n231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))\n232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))\n233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))\n234         conn.execute('PRAGMA foreign_keys = ON')\n235         return conn\n236 \n237     def init_connection_state(self):\n238         pass\n239 \n240     def create_cursor(self, name=None):\n241         return self.connection.cursor(factory=SQLiteCursorWrapper)\n242 \n243     def close(self):\n244         self.validate_thread_sharing()\n245         # If database is in memory, closing the connection destroys the\n246         # database. To prevent accidental data loss, ignore close requests on\n247         # an in-memory db.\n248         if not self.is_in_memory_db():\n249             BaseDatabaseWrapper.close(self)\n250 \n251     def _savepoint_allowed(self):\n252         # When 'isolation_level' is not None, sqlite3 commits before each\n253         # savepoint; it's a bug. When it is None, savepoints don't make sense\n254         # because autocommit is enabled. The only exception is inside 'atomic'\n255         # blocks. To work around that bug, on SQLite, 'atomic' starts a\n256         # transaction explicitly rather than simply disable autocommit.\n257         return self.in_atomic_block\n258 \n259     def _set_autocommit(self, autocommit):\n260         if autocommit:\n261             level = None\n262         else:\n263             # sqlite3's internal default is ''. It's different from None.\n264             # See Modules/_sqlite/connection.c.\n265             level = ''\n266         # 'isolation_level' is a misleading API.\n267         # SQLite always runs at the SERIALIZABLE isolation level.\n268         with self.wrap_database_errors:\n269             self.connection.isolation_level = level\n270 \n271     def disable_constraint_checking(self):\n272         with self.cursor() as cursor:\n273             cursor.execute('PRAGMA foreign_keys = OFF')\n274             # Foreign key constraints cannot be turned off while in a multi-\n275             # statement transaction. Fetch the current state of the pragma\n276             # to determine if constraints are effectively disabled.\n277             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]\n278         return not bool(enabled)\n279 \n280     def enable_constraint_checking(self):\n281         self.cursor().execute('PRAGMA foreign_keys = ON')\n282 \n283     def check_constraints(self, table_names=None):\n284         \"\"\"\n285         Check each table name in `table_names` for rows with invalid foreign\n286         key references. This method is intended to be used in conjunction with\n287         `disable_constraint_checking()` and `enable_constraint_checking()`, to\n288         determine if rows with invalid references were entered while constraint\n289         checks were off.\n290         \"\"\"\n291         if self.features.supports_pragma_foreign_key_check:\n292             with self.cursor() as cursor:\n293                 if table_names is None:\n294                     violations = self.cursor().execute('PRAGMA foreign_key_check').fetchall()\n295                 else:\n296                     violations = chain.from_iterable(\n297                         cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n298                         for table_name in table_names\n299                     )\n300                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n301                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n302                     foreign_key = cursor.execute(\n303                         'PRAGMA foreign_key_list(%s)' % table_name\n304                     ).fetchall()[foreign_key_index]\n305                     column_name, referenced_column_name = foreign_key[3:5]\n306                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n307                     primary_key_value, bad_value = cursor.execute(\n308                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n309                             primary_key_column_name, column_name, table_name\n310                         ),\n311                         (rowid,),\n312                     ).fetchone()\n313                     raise utils.IntegrityError(\n314                         \"The row in table '%s' with primary key '%s' has an \"\n315                         \"invalid foreign key: %s.%s contains a value '%s' that \"\n316                         \"does not have a corresponding value in %s.%s.\" % (\n317                             table_name, primary_key_value, table_name, column_name,\n318                             bad_value, referenced_table_name, referenced_column_name\n319                         )\n320                     )\n321         else:\n322             with self.cursor() as cursor:\n323                 if table_names is None:\n324                     table_names = self.introspection.table_names(cursor)\n325                 for table_name in table_names:\n326                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n327                     if not primary_key_column_name:\n328                         continue\n329                     key_columns = self.introspection.get_key_columns(cursor, table_name)\n330                     for column_name, referenced_table_name, referenced_column_name in key_columns:\n331                         cursor.execute(\n332                             \"\"\"\n333                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n334                             LEFT JOIN `%s` as REFERRED\n335                             ON (REFERRING.`%s` = REFERRED.`%s`)\n336                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\n337                             \"\"\"\n338                             % (\n339                                 primary_key_column_name, column_name, table_name,\n340                                 referenced_table_name, column_name, referenced_column_name,\n341                                 column_name, referenced_column_name,\n342                             )\n343                         )\n344                         for bad_row in cursor.fetchall():\n345                             raise utils.IntegrityError(\n346                                 \"The row in table '%s' with primary key '%s' has an \"\n347                                 \"invalid foreign key: %s.%s contains a value '%s' that \"\n348                                 \"does not have a corresponding value in %s.%s.\" % (\n349                                     table_name, bad_row[0], table_name, column_name,\n350                                     bad_row[1], referenced_table_name, referenced_column_name,\n351                                 )\n352                             )\n353 \n354     def is_usable(self):\n355         return True\n356 \n357     def _start_transaction_under_autocommit(self):\n358         \"\"\"\n359         Start a transaction explicitly in autocommit mode.\n360 \n361         Staying in autocommit mode works around a bug of sqlite3 that breaks\n362         savepoints when autocommit is disabled.\n363         \"\"\"\n364         self.cursor().execute(\"BEGIN\")\n365 \n366     def is_in_memory_db(self):\n367         return self.creation.is_in_memory_db(self.settings_dict['NAME'])\n",
        "intended_behavior": "This class should include a method to check the SQLite version at the connection time and store this information as an attribute of the `DatabaseWrapper` instance. This method should be called during the initialization of the database connection. This information should then be leveraged to determine feature support compatibility throughout Django's ORM operations, specifically for features like window functions that depend on the database version."
    },
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/models/expressions.py",
        "start": 1193,
        "end": 1282,
        "class_name": "Window",
        "method_name": null,
        "code": "1193 class Window(Expression):\n1194     template = '%(expression)s OVER (%(window)s)'\n1195     # Although the main expression may either be an aggregate or an\n1196     # expression with an aggregate function, the GROUP BY that will\n1197     # be introduced in the query as a result is not desired.\n1198     contains_aggregate = False\n1199     contains_over_clause = True\n1200     filterable = False\n1201 \n1202     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1203         self.partition_by = partition_by\n1204         self.order_by = order_by\n1205         self.frame = frame\n1206 \n1207         if not getattr(expression, 'window_compatible', False):\n1208             raise ValueError(\n1209                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1210                 expression.__class__.__name__\n1211             )\n1212 \n1213         if self.partition_by is not None:\n1214             if not isinstance(self.partition_by, (tuple, list)):\n1215                 self.partition_by = (self.partition_by,)\n1216             self.partition_by = ExpressionList(*self.partition_by)\n1217 \n1218         if self.order_by is not None:\n1219             if isinstance(self.order_by, (list, tuple)):\n1220                 self.order_by = ExpressionList(*self.order_by)\n1221             elif not isinstance(self.order_by, BaseExpression):\n1222                 raise ValueError(\n1223                     'order_by must be either an Expression or a sequence of '\n1224                     'expressions.'\n1225                 )\n1226         super().__init__(output_field=output_field)\n1227         self.source_expression = self._parse_expressions(expression)[0]\n1228 \n1229     def _resolve_output_field(self):\n1230         return self.source_expression.output_field\n1231 \n1232     def get_source_expressions(self):\n1233         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1234 \n1235     def set_source_expressions(self, exprs):\n1236         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1237 \n1238     def as_sql(self, compiler, connection, template=None):\n1239         connection.ops.check_expression_support(self)\n1240         expr_sql, params = compiler.compile(self.source_expression)\n1241         window_sql, window_params = [], []\n1242 \n1243         if self.partition_by is not None:\n1244             sql_expr, sql_params = self.partition_by.as_sql(\n1245                 compiler=compiler, connection=connection,\n1246                 template='PARTITION BY %(expressions)s',\n1247             )\n1248             window_sql.extend(sql_expr)\n1249             window_params.extend(sql_params)\n1250 \n1251         if self.order_by is not None:\n1252             window_sql.append(' ORDER BY ')\n1253             order_sql, order_params = compiler.compile(self.order_by)\n1254             window_sql.extend(order_sql)\n1255             window_params.extend(order_params)\n1256 \n1257         if self.frame:\n1258             frame_sql, frame_params = compiler.compile(self.frame)\n1259             window_sql.append(' ' + frame_sql)\n1260             window_params.extend(frame_params)\n1261 \n1262         params.extend(window_params)\n1263         template = template or self.template\n1264 \n1265         return template % {\n1266             'expression': expr_sql,\n1267             'window': ''.join(window_sql).strip()\n1268         }, params\n1269 \n1270     def __str__(self):\n1271         return '{} OVER ({}{}{})'.format(\n1272             str(self.source_expression),\n1273             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1274             'ORDER BY ' + str(self.order_by) if self.order_by else '',\n1275             str(self.frame or ''),\n1276         )\n1277 \n1278     def __repr__(self):\n1279         return '<%s: %s>' % (self.__class__.__name__, self)\n1280 \n1281     def get_group_by_cols(self):\n1282         return []\n",
        "intended_behavior": "Before generating the SQL for window functions, the `Window` class or the mechanism that compiles `Window` expressions into SQL should query the database version compatibility (using the information stored in the `DatabaseWrapper` during connection initialization). If the SQLite version is detected to be less than 3.25.0, the method should raise a `NotSupportedError` (or a similar custom exception) that clearly indicates window functions are not supported on the connected SQLite version. This behavior should preserve the existing functionality by allowing window function usage on supported database versions while providing clear error handling for unsupported versions."
    }
]