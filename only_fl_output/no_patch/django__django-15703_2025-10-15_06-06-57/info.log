2025-10-15 06:06:57.390 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 06:07:00.679 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=120, output_tokens=13, cost=0.001590
2025-10-15 06:07:00.680 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 06:07:00.688 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:07:13.270 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=429, output_tokens=424, cost=0.017010
2025-10-15 06:07:13.279 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:07:15.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=778, output_tokens=29, cost=0.008650
2025-10-15 06:07:15.235 | DEBUG    | Extracted a valid json.
2025-10-15 06:07:15.235 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"index_together\")", "search_code(\"Index\")"],
    "bug_locations": []
}
2025-10-15 06:07:15.549 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 06:07:15.549 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 06:07:32.760 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2254, output_tokens=650, cost=0.042040
2025-10-15 06:07:32.767 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 06:07:46.251 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3120, output_tokens=581, cost=0.048630
2025-10-15 06:07:46.257 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 06:07:53.776 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=935, output_tokens=294, cost=0.018170
2025-10-15 06:07:53.776 | DEBUG    | Extracted a valid json.
2025-10-15 06:07:53.776 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/options.py",
            "class": "Options",
            "method": "",
            "intended_behavior": "The handling of `index_together` should be deprecated in favor of directly using `Index` instances in the `indexes` list, ensuring seamless functionality with no change to the resulting database schema."
        },
        {
            "file": "django/db/models/base.py",
            "class": "Model",
            "method": "",
            "intended_behavior": "Ensure construction of model indexes using `Index` instances from the `indexes` list without relying on `index_together`. Legacy handling of `index_together` should be migrated internally to use `Index` instances for backward compatibility."
        },
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "Code that identifies changes to `index_together` for generating migration operations should shift towards detecting changes in `indexes`, offering precise migration generation."
        },
        {
            "file": "django/db/migrations/operations/models.py",
            "class": "",
            "method": "",
            "intended_behavior": "Support full operations for adding, removing, or altering indexes using `Index` instances, ensuring migrations are accurately generated and applied."
        }
    ]
}
2025-10-15 06:07:53.789 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/options.py</file>
<class>Options</class>
<method>None</method>
<code>
83 class Options:
84     FORWARD_PROPERTIES = {
85         "fields",
86         "many_to_many",
87         "concrete_fields",
88         "local_concrete_fields",
89         "_forward_fields_map",
90         "managers",
91         "managers_map",
92         "base_manager",
93         "default_manager",
94     }
95     REVERSE_PROPERTIES = {"related_objects", "fields_map", "_relation_tree"}
96 
97     default_apps = apps
98 
99     def __init__(self, meta, app_label=None):
100         self._get_fields_cache = {}
101         self.local_fields = []
102         self.local_many_to_many = []
103         self.private_fields = []
104         self.local_managers = []
105         self.base_manager_name = None
106         self.default_manager_name = None
107         self.model_name = None
108         self.verbose_name = None
109         self.verbose_name_plural = None
110         self.db_table = ""
111         self.ordering = []
112         self._ordering_clash = False
113         self.indexes = []
114         self.constraints = []
115         self.unique_together = []
116         self.index_together = []
117         self.select_on_save = False
118         self.default_permissions = ("add", "change", "delete", "view")
119         self.permissions = []
120         self.object_name = None
121         self.app_label = app_label
122         self.get_latest_by = None
123         self.order_with_respect_to = None
124         self.db_tablespace = settings.DEFAULT_TABLESPACE
125         self.required_db_features = []
126         self.required_db_vendor = None
127         self.meta = meta
128         self.pk = None
129         self.auto_field = None
130         self.abstract = False
131         self.managed = True
132         self.proxy = False
133         # For any class that is a proxy (including automatically created
134         # classes for deferred object loading), proxy_for_model tells us
135         # which class this model is proxying. Note that proxy_for_model
136         # can create a chain of proxy models. For non-proxy models, the
137         # variable is always None.
138         self.proxy_for_model = None
139         # For any non-abstract class, the concrete class is the model
140         # in the end of the proxy_for_model chain. In particular, for
141         # concrete models, the concrete_model is always the class itself.
142         self.concrete_model = None
143         self.swappable = None
144         self.parents = {}
145         self.auto_created = False
146 
147         # List of all lookups defined in ForeignKey 'limit_choices_to' options
148         # from *other* models. Needed for some admin checks. Internal use only.
149         self.related_fkey_lookups = []
150 
151         # A custom app registry to use, if you're making a separate model set.
152         self.apps = self.default_apps
153 
154         self.default_related_name = None
155 
156     @property
157     def label(self):
158         return "%s.%s" % (self.app_label, self.object_name)
159 
160     @property
161     def label_lower(self):
162         return "%s.%s" % (self.app_label, self.model_name)
163 
164     @property
165     def app_config(self):
166         # Don't go through get_app_config to avoid triggering imports.
167         return self.apps.app_configs.get(self.app_label)
168 
169     def contribute_to_class(self, cls, name):
170         from django.db import connection
171         from django.db.backends.utils import truncate_name
172 
173         cls._meta = self
174         self.model = cls
175         # First, construct the default values for these options.
176         self.object_name = cls.__name__
177         self.model_name = self.object_name.lower()
178         self.verbose_name = camel_case_to_spaces(self.object_name)
179 
180         # Store the original user-defined values for each option,
181         # for use when serializing the model definition
182         self.original_attrs = {}
183 
184         # Next, apply any overridden values from 'class Meta'.
185         if self.meta:
186             meta_attrs = self.meta.__dict__.copy()
187             for name in self.meta.__dict__:
188                 # Ignore any private attributes that Django doesn't care about.
189                 # NOTE: We can't modify a dictionary's contents while looping
190                 # over it, so we loop over the *original* dictionary instead.
191                 if name.startswith("_"):
192                     del meta_attrs[name]
193             for attr_name in DEFAULT_NAMES:
194                 if attr_name in meta_attrs:
195                     setattr(self, attr_name, meta_attrs.pop(attr_name))
196                     self.original_attrs[attr_name] = getattr(self, attr_name)
197                 elif hasattr(self.meta, attr_name):
198                     setattr(self, attr_name, getattr(self.meta, attr_name))
199                     self.original_attrs[attr_name] = getattr(self, attr_name)
200 
201             self.unique_together = normalize_together(self.unique_together)
202             self.index_together = normalize_together(self.index_together)
203             # App label/class name interpolation for names of constraints and
204             # indexes.
205             if not getattr(cls._meta, "abstract", False):
206                 for attr_name in {"constraints", "indexes"}:
207                     objs = getattr(self, attr_name, [])
208                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
209 
210             # verbose_name_plural is a special case because it uses a 's'
211             # by default.
212             if self.verbose_name_plural is None:
213                 self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
214 
215             # order_with_respect_and ordering are mutually exclusive.
216             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
217 
218             # Any leftover attributes must be invalid.
219             if meta_attrs != {}:
220                 raise TypeError(
221                     "'class Meta' got invalid attribute(s): %s" % ",".join(meta_attrs)
222                 )
223         else:
224             self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
225         del self.meta
226 
227         # If the db_table wasn't provided, use the app_label + model_name.
228         if not self.db_table:
229             self.db_table = "%s_%s" % (self.app_label, self.model_name)
230             self.db_table = truncate_name(
231                 self.db_table, connection.ops.max_name_length()
232             )
233 
234     def _format_names_with_class(self, cls, objs):
235         """App label/class name interpolation for object names."""
236         new_objs = []
237         for obj in objs:
238             obj = obj.clone()
239             obj.name = obj.name % {
240                 "app_label": cls._meta.app_label.lower(),
241                 "class": cls.__name__.lower(),
242             }
243             new_objs.append(obj)
244         return new_objs
245 
246     def _get_default_pk_class(self):
247         pk_class_path = getattr(
248             self.app_config,
249             "default_auto_field",
250             settings.DEFAULT_AUTO_FIELD,
251         )
252         if self.app_config and self.app_config._is_default_auto_field_overridden:
253             app_config_class = type(self.app_config)
254             source = (
255                 f"{app_config_class.__module__}."
256                 f"{app_config_class.__qualname__}.default_auto_field"
257             )
258         else:
259             source = "DEFAULT_AUTO_FIELD"
260         if not pk_class_path:
261             raise ImproperlyConfigured(f"{source} must not be empty.")
262         try:
263             pk_class = import_string(pk_class_path)
264         except ImportError as e:
265             msg = (
266                 f"{source} refers to the module '{pk_class_path}' that could "
267                 f"not be imported."
268             )
269             raise ImproperlyConfigured(msg) from e
270         if not issubclass(pk_class, AutoField):
271             raise ValueError(
272                 f"Primary key '{pk_class_path}' referred by {source} must "
273                 f"subclass AutoField."
274             )
275         return pk_class
276 
277     def _prepare(self, model):
278         if self.order_with_respect_to:
279             # The app registry will not be ready at this point, so we cannot
280             # use get_field().
281             query = self.order_with_respect_to
282             try:
283                 self.order_with_respect_to = next(
284                     f
285                     for f in self._get_fields(reverse=False)
286                     if f.name == query or f.attname == query
287                 )
288             except StopIteration:
289                 raise FieldDoesNotExist(
290                     "%s has no field named '%s'" % (self.object_name, query)
291                 )
292 
293             self.ordering = ("_order",)
294             if not any(
295                 isinstance(field, OrderWrt) for field in model._meta.local_fields
296             ):
297                 model.add_to_class("_order", OrderWrt())
298         else:
299             self.order_with_respect_to = None
300 
301         if self.pk is None:
302             if self.parents:
303                 # Promote the first parent link in lieu of adding yet another
304                 # field.
305                 field = next(iter(self.parents.values()))
306                 # Look for a local field with the same name as the
307                 # first parent link. If a local field has already been
308                 # created, use it instead of promoting the parent
309                 already_created = [
310                     fld for fld in self.local_fields if fld.name == field.name
311                 ]
312                 if already_created:
313                     field = already_created[0]
314                 field.primary_key = True
315                 self.setup_pk(field)
316             else:
317                 pk_class = self._get_default_pk_class()
318                 auto = pk_class(verbose_name="ID", primary_key=True, auto_created=True)
319                 model.add_to_class("id", auto)
320 
321     def add_manager(self, manager):
322         self.local_managers.append(manager)
323         self._expire_cache()
324 
325     def add_field(self, field, private=False):
326         # Insert the given field in the order in which it was created, using
327         # the "creation_counter" attribute of the field.
328         # Move many-to-many related fields from self.fields into
329         # self.many_to_many.
330         if private:
331             self.private_fields.append(field)
332         elif field.is_relation and field.many_to_many:
333             bisect.insort(self.local_many_to_many, field)
334         else:
335             bisect.insort(self.local_fields, field)
336             self.setup_pk(field)
337 
338         # If the field being added is a relation to another known field,
339         # expire the cache on this field and the forward cache on the field
340         # being referenced, because there will be new relationships in the
341         # cache. Otherwise, expire the cache of references *to* this field.
342         # The mechanism for getting at the related model is slightly odd -
343         # ideally, we'd just ask for field.related_model. However, related_model
344         # is a cached property, and all the models haven't been loaded yet, so
345         # we need to make sure we don't cache a string reference.
346         if (
347             field.is_relation
348             and hasattr(field.remote_field, "model")
349             and field.remote_field.model
350         ):
351             try:
352                 field.remote_field.model._meta._expire_cache(forward=False)
353             except AttributeError:
354                 pass
355             self._expire_cache()
356         else:
357             self._expire_cache(reverse=False)
358 
359     def setup_pk(self, field):
360         if not self.pk and field.primary_key:
361             self.pk = field
362             field.serialize = False
363 
364     def setup_proxy(self, target):
365         """
366         Do the internal setup so that the current model is a proxy for
367         "target".
368         """
369         self.pk = target._meta.pk
370         self.proxy_for_model = target
371         self.db_table = target._meta.db_table
372 
373     def __repr__(self):
374         return "<Options for %s>" % self.object_name
375 
376     def __str__(self):
377         return self.label_lower
378 
379     def can_migrate(self, connection):
380         """
381         Return True if the model can/should be migrated on the `connection`.
382         `connection` can be either a real connection or a connection alias.
383         """
384         if self.proxy or self.swapped or not self.managed:
385             return False
386         if isinstance(connection, str):
387             connection = connections[connection]
388         if self.required_db_vendor:
389             return self.required_db_vendor == connection.vendor
390         if self.required_db_features:
391             return all(
392                 getattr(connection.features, feat, False)
393                 for feat in self.required_db_features
394             )
395         return True
396 
397     @property
398     def verbose_name_raw(self):
399         """Return the untranslated verbose name."""
400         with override(None):
401             return str(self.verbose_name)
402 
403     @property
404     def swapped(self):
405         """
406         Has this model been swapped out for another? If so, return the model
407         name of the replacement; otherwise, return None.
408 
409         For historical reasons, model name lookups using get_model() are
410         case insensitive, so we make sure we are case insensitive here.
411         """
412         if self.swappable:
413             swapped_for = getattr(settings, self.swappable, None)
414             if swapped_for:
415                 try:
416                     swapped_label, swapped_object = swapped_for.split(".")
417                 except ValueError:
418                     # setting not in the format app_label.model_name
419                     # raising ImproperlyConfigured here causes problems with
420                     # test cleanup code - instead it is raised in get_user_model
421                     # or as part of validation.
422                     return swapped_for
423 
424                 if (
425                     "%s.%s" % (swapped_label, swapped_object.lower())
426                     != self.label_lower
427                 ):
428                     return swapped_for
429         return None
430 
431     @cached_property
432     def managers(self):
433         managers = []
434         seen_managers = set()
435         bases = (b for b in self.model.mro() if hasattr(b, "_meta"))
436         for depth, base in enumerate(bases):
437             for manager in base._meta.local_managers:
438                 if manager.name in seen_managers:
439                     continue
440 
441                 manager = copy.copy(manager)
442                 manager.model = self.model
443                 seen_managers.add(manager.name)
444                 managers.append((depth, manager.creation_counter, manager))
445 
446         return make_immutable_fields_list(
447             "managers",
448             (m[2] for m in sorted(managers)),
449         )
450 
451     @cached_property
452     def managers_map(self):
453         return {manager.name: manager for manager in self.managers}
454 
455     @cached_property
456     def base_manager(self):
457         base_manager_name = self.base_manager_name
458         if not base_manager_name:
459             # Get the first parent's base_manager_name if there's one.
460             for parent in self.model.mro()[1:]:
461                 if hasattr(parent, "_meta"):
462                     if parent._base_manager.name != "_base_manager":
463                         base_manager_name = parent._base_manager.name
464                     break
465 
466         if base_manager_name:
467             try:
468                 return self.managers_map[base_manager_name]
469             except KeyError:
470                 raise ValueError(
471                     "%s has no manager named %r"
472                     % (
473                         self.object_name,
474                         base_manager_name,
475                     )
476                 )
477 
478         manager = Manager()
479         manager.name = "_base_manager"
480         manager.model = self.model
481         manager.auto_created = True
482         return manager
483 
484     @cached_property
485     def default_manager(self):
486         default_manager_name = self.default_manager_name
487         if not default_manager_name and not self.local_managers:
488             # Get the first parent's default_manager_name if there's one.
489             for parent in self.model.mro()[1:]:
490                 if hasattr(parent, "_meta"):
491                     default_manager_name = parent._meta.default_manager_name
492                     break
493 
494         if default_manager_name:
495             try:
496                 return self.managers_map[default_manager_name]
497             except KeyError:
498                 raise ValueError(
499                     "%s has no manager named %r"
500                     % (
501                         self.object_name,
502                         default_manager_name,
503                     )
504                 )
505 
506         if self.managers:
507             return self.managers[0]
508 
509     @cached_property
510     def fields(self):
511         """
512         Return a list of all forward fields on the model and its parents,
513         excluding ManyToManyFields.
514 
515         Private API intended only to be used by Django itself; get_fields()
516         combined with filtering of field properties is the public API for
517         obtaining this field list.
518         """
519         # For legacy reasons, the fields property should only contain forward
520         # fields that are not private or with a m2m cardinality. Therefore we
521         # pass these three filters as filters to the generator.
522         # The third lambda is a longwinded way of checking f.related_model - we don't
523         # use that property directly because related_model is a cached property,
524         # and all the models may not have been loaded yet; we don't want to cache
525         # the string reference to the related_model.
526         def is_not_an_m2m_field(f):
527             return not (f.is_relation and f.many_to_many)
528 
529         def is_not_a_generic_relation(f):
530             return not (f.is_relation and f.one_to_many)
531 
532         def is_not_a_generic_foreign_key(f):
533             return not (
534                 f.is_relation
535                 and f.many_to_one
536                 and not (hasattr(f.remote_field, "model") and f.remote_field.model)
537             )
538 
539         return make_immutable_fields_list(
540             "fields",
541             (
542                 f
543                 for f in self._get_fields(reverse=False)
544                 if is_not_an_m2m_field(f)
545                 and is_not_a_generic_relation(f)
546                 and is_not_a_generic_foreign_key(f)
547             ),
548         )
549 
550     @cached_property
551     def concrete_fields(self):
552         """
553         Return a list of all concrete fields on the model and its parents.
554 
555         Private API intended only to be used by Django itself; get_fields()
556         combined with filtering of field properties is the public API for
557         obtaining this field list.
558         """
559         return make_immutable_fields_list(
560             "concrete_fields", (f for f in self.fields if f.concrete)
561         )
562 
563     @cached_property
564     def local_concrete_fields(self):
565         """
566         Return a list of all concrete fields on the model.
567 
568         Private API intended only to be used by Django itself; get_fields()
569         combined with filtering of field properties is the public API for
570         obtaining this field list.
571         """
572         return make_immutable_fields_list(
573             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
574         )
575 
576     @cached_property
577     def many_to_many(self):
578         """
579         Return a list of all many to many fields on the model and its parents.
580 
581         Private API intended only to be used by Django itself; get_fields()
582         combined with filtering of field properties is the public API for
583         obtaining this list.
584         """
585         return make_immutable_fields_list(
586             "many_to_many",
587             (
588                 f
589                 for f in self._get_fields(reverse=False)
590                 if f.is_relation and f.many_to_many
591             ),
592         )
593 
594     @cached_property
595     def related_objects(self):
596         """
597         Return all related objects pointing to the current model. The related
598         objects can come from a one-to-one, one-to-many, or many-to-many field
599         relation type.
600 
601         Private API intended only to be used by Django itself; get_fields()
602         combined with filtering of field properties is the public API for
603         obtaining this field list.
604         """
605         all_related_fields = self._get_fields(
606             forward=False, reverse=True, include_hidden=True
607         )
608         return make_immutable_fields_list(
609             "related_objects",
610             (
611                 obj
612                 for obj in all_related_fields
613                 if not obj.hidden or obj.field.many_to_many
614             ),
615         )
616 
617     @cached_property
618     def _forward_fields_map(self):
619         res = {}
620         fields = self._get_fields(reverse=False)
621         for field in fields:
622             res[field.name] = field
623             # Due to the way Django's internals work, get_field() should also
624             # be able to fetch a field by attname. In the case of a concrete
625             # field with relation, includes the *_id name too
626             try:
627                 res[field.attname] = field
628             except AttributeError:
629                 pass
630         return res
631 
632     @cached_property
633     def fields_map(self):
634         res = {}
635         fields = self._get_fields(forward=False, include_hidden=True)
636         for field in fields:
637             res[field.name] = field
638             # Due to the way Django's internals work, get_field() should also
639             # be able to fetch a field by attname. In the case of a concrete
640             # field with relation, includes the *_id name too
641             try:
642                 res[field.attname] = field
643             except AttributeError:
644                 pass
645         return res
646 
647     def get_field(self, field_name):
648         """
649         Return a field instance given the name of a forward or reverse field.
650         """
651         try:
652             # In order to avoid premature loading of the relation tree
653             # (expensive) we prefer checking if the field is a forward field.
654             return self._forward_fields_map[field_name]
655         except KeyError:
656             # If the app registry is not ready, reverse fields are
657             # unavailable, therefore we throw a FieldDoesNotExist exception.
658             if not self.apps.models_ready:
659                 raise FieldDoesNotExist(
660                     "%s has no field named '%s'. The app cache isn't ready yet, "
661                     "so if this is an auto-created related field, it won't "
662                     "be available yet." % (self.object_name, field_name)
663                 )
664 
665         try:
666             # Retrieve field instance by name from cached or just-computed
667             # field map.
668             return self.fields_map[field_name]
669         except KeyError:
670             raise FieldDoesNotExist(
671                 "%s has no field named '%s'" % (self.object_name, field_name)
672             )
673 
674     def get_base_chain(self, model):
675         """
676         Return a list of parent classes leading to `model` (ordered from
677         closest to most distant ancestor). This has to handle the case where
678         `model` is a grandparent or even more distant relation.
679         """
680         if not self.parents:
681             return []
682         if model in self.parents:
683             return [model]
684         for parent in self.parents:
685             res = parent._meta.get_base_chain(model)
686             if res:
687                 res.insert(0, parent)
688                 return res
689         return []
690 
691     def get_parent_list(self):
692         """
693         Return all the ancestors of this model as a list ordered by MRO.
694         Useful for determining if something is an ancestor, regardless of lineage.
695         """
696         result = OrderedSet(self.parents)
697         for parent in self.parents:
698             for ancestor in parent._meta.get_parent_list():
699                 result.add(ancestor)
700         return list(result)
701 
702     def get_ancestor_link(self, ancestor):
703         """
704         Return the field on the current model which points to the given
705         "ancestor". This is possible an indirect link (a pointer to a parent
706         model, which points, eventually, to the ancestor). Used when
707         constructing table joins for model inheritance.
708 
709         Return None if the model isn't an ancestor of this one.
710         """
711         if ancestor in self.parents:
712             return self.parents[ancestor]
713         for parent in self.parents:
714             # Tries to get a link field from the immediate parent
715             parent_link = parent._meta.get_ancestor_link(ancestor)
716             if parent_link:
717                 # In case of a proxied model, the first link
718                 # of the chain to the ancestor is that parent
719                 # links
720                 return self.parents[parent] or parent_link
721 
722     def get_path_to_parent(self, parent):
723         """
724         Return a list of PathInfos containing the path from the current
725         model to the parent model, or an empty list if parent is not a
726         parent of the current model.
727         """
728         if self.model is parent:
729             return []
730         # Skip the chain of proxy to the concrete proxied model.
731         proxied_model = self.concrete_model
732         path = []
733         opts = self
734         for int_model in self.get_base_chain(parent):
735             if int_model is proxied_model:
736                 opts = int_model._meta
737             else:
738                 final_field = opts.parents[int_model]
739                 targets = (final_field.remote_field.get_related_field(),)
740                 opts = int_model._meta
741                 path.append(
742                     PathInfo(
743                         from_opts=final_field.model._meta,
744                         to_opts=opts,
745                         target_fields=targets,
746                         join_field=final_field,
747                         m2m=False,
748                         direct=True,
749                         filtered_relation=None,
750                     )
751                 )
752         return path
753 
754     def get_path_from_parent(self, parent):
755         """
756         Return a list of PathInfos containing the path from the parent
757         model to the current model, or an empty list if parent is not a
758         parent of the current model.
759         """
760         if self.model is parent:
761             return []
762         model = self.concrete_model
763         # Get a reversed base chain including both the current and parent
764         # models.
765         chain = model._meta.get_base_chain(parent)
766         chain.reverse()
767         chain.append(model)
768         # Construct a list of the PathInfos between models in chain.
769         path = []
770         for i, ancestor in enumerate(chain[:-1]):
771             child = chain[i + 1]
772             link = child._meta.get_ancestor_link(ancestor)
773             path.extend(link.reverse_path_infos)
774         return path
775 
776     def _populate_directed_relation_graph(self):
777         """
778         This method is used by each model to find its reverse objects. As this
779         method is very expensive and is accessed frequently (it looks up every
780         field in a model, in every app), it is computed on first access and then
781         is set as a property on every model.
782         """
783         related_objects_graph = defaultdict(list)
784 
785         all_models = self.apps.get_models(include_auto_created=True)
786         for model in all_models:
787             opts = model._meta
788             # Abstract model's fields are copied to child models, hence we will
789             # see the fields from the child models.
790             if opts.abstract:
791                 continue
792             fields_with_relations = (
793                 f
794                 for f in opts._get_fields(reverse=False, include_parents=False)
795                 if f.is_relation and f.related_model is not None
796             )
797             for f in fields_with_relations:
798                 if not isinstance(f.remote_field.model, str):
799                     remote_label = f.remote_field.model._meta.concrete_model._meta.label
800                     related_objects_graph[remote_label].append(f)
801 
802         for model in all_models:
803             # Set the relation_tree using the internal __dict__. In this way
804             # we avoid calling the cached property. In attribute lookup,
805             # __dict__ takes precedence over a data descriptor (such as
806             # @cached_property). This means that the _meta._relation_tree is
807             # only called if related_objects is not in __dict__.
808             related_objects = related_objects_graph[
809                 model._meta.concrete_model._meta.label
810             ]
811             model._meta.__dict__["_relation_tree"] = related_objects
812         # It seems it is possible that self is not in all_models, so guard
813         # against that with default for get().
814         return self.__dict__.get("_relation_tree", EMPTY_RELATION_TREE)
815 
816     @cached_property
817     def _relation_tree(self):
818         return self._populate_directed_relation_graph()
819 
820     def _expire_cache(self, forward=True, reverse=True):
821         # This method is usually called by apps.cache_clear(), when the
822         # registry is finalized, or when a new field is added.
823         if forward:
824             for cache_key in self.FORWARD_PROPERTIES:
825                 if cache_key in self.__dict__:
826                     delattr(self, cache_key)
827         if reverse and not self.abstract:
828             for cache_key in self.REVERSE_PROPERTIES:
829                 if cache_key in self.__dict__:
830                     delattr(self, cache_key)
831         self._get_fields_cache = {}
832 
833     def get_fields(self, include_parents=True, include_hidden=False):
834         """
835         Return a list of fields associated to the model. By default, include
836         forward and reverse fields, fields derived from inheritance, but not
837         hidden fields. The returned fields can be changed using the parameters:
838 
839         - include_parents: include fields derived from inheritance
840         - include_hidden:  include fields that have a related_name that
841                            starts with a "+"
842         """
843         if include_parents is False:
844             include_parents = PROXY_PARENTS
845         return self._get_fields(
846             include_parents=include_parents, include_hidden=include_hidden
847         )
848 
849     def _get_fields(
850         self,
851         forward=True,
852         reverse=True,
853         include_parents=True,
854         include_hidden=False,
855         seen_models=None,
856     ):
857         """
858         Internal helper function to return fields of the model.
859         * If forward=True, then fields defined on this model are returned.
860         * If reverse=True, then relations pointing to this model are returned.
861         * If include_hidden=True, then fields with is_hidden=True are returned.
862         * The include_parents argument toggles if fields from parent models
863           should be included. It has three values: True, False, and
864           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
865           fields defined for the current model or any of its parents in the
866           parent chain to the model's concrete model.
867         """
868         if include_parents not in (True, False, PROXY_PARENTS):
869             raise TypeError(
870                 "Invalid argument for include_parents: %s" % (include_parents,)
871             )
872         # This helper function is used to allow recursion in ``get_fields()``
873         # implementation and to provide a fast way for Django's internals to
874         # access specific subsets of fields.
875 
876         # We must keep track of which models we have already seen. Otherwise we
877         # could include the same field multiple times from different models.
878         topmost_call = seen_models is None
879         if topmost_call:
880             seen_models = set()
881         seen_models.add(self.model)
882 
883         # Creates a cache key composed of all arguments
884         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
885 
886         try:
887             # In order to avoid list manipulation. Always return a shallow copy
888             # of the results.
889             return self._get_fields_cache[cache_key]
890         except KeyError:
891             pass
892 
893         fields = []
894         # Recursively call _get_fields() on each parent, with the same
895         # options provided in this call.
896         if include_parents is not False:
897             for parent in self.parents:
898                 # In diamond inheritance it is possible that we see the same
899                 # model from two different routes. In that case, avoid adding
900                 # fields from the same parent again.
901                 if parent in seen_models:
902                     continue
903                 if (
904                     parent._meta.concrete_model != self.concrete_model
905                     and include_parents == PROXY_PARENTS
906                 ):
907                     continue
908                 for obj in parent._meta._get_fields(
909                     forward=forward,
910                     reverse=reverse,
911                     include_parents=include_parents,
912                     include_hidden=include_hidden,
913                     seen_models=seen_models,
914                 ):
915                     if (
916                         not getattr(obj, "parent_link", False)
917                         or obj.model == self.concrete_model
918                     ):
919                         fields.append(obj)
920         if reverse and not self.proxy:
921             # Tree is computed once and cached until the app cache is expired.
922             # It is composed of a list of fields pointing to the current model
923             # from other models.
924             all_fields = self._relation_tree
925             for field in all_fields:
926                 # If hidden fields should be included or the relation is not
927                 # intentionally hidden, add to the fields dict.
928                 if include_hidden or not field.remote_field.hidden:
929                     fields.append(field.remote_field)
930 
931         if forward:
932             fields += self.local_fields
933             fields += self.local_many_to_many
934             # Private fields are recopied to each child model, and they get a
935             # different model as field.model in each child. Hence we have to
936             # add the private fields separately from the topmost call. If we
937             # did this recursively similar to local_fields, we would get field
938             # instances with field.model != self.model.
939             if topmost_call:
940                 fields += self.private_fields
941 
942         # In order to avoid list manipulation. Always
943         # return a shallow copy of the results
944         fields = make_immutable_fields_list("get_fields()", fields)
945 
946         # Store result into cache for later access
947         self._get_fields_cache[cache_key] = fields
948         return fields
949 
950     @cached_property
951     def total_unique_constraints(self):
952         """
953         Return a list of total unique constraints. Useful for determining set
954         of fields guaranteed to be unique for all rows.
955         """
956         return [
957             constraint
958             for constraint in self.constraints
959             if (
960                 isinstance(constraint, UniqueConstraint)
961                 and constraint.condition is None
962                 and not constraint.contains_expressions
963             )
964         ]
965 
966     @cached_property
967     def _property_names(self):
968         """Return a set of the names of the properties defined on the model."""
969         names = []
970         for name in dir(self.model):
971             attr = inspect.getattr_static(self.model, name)
972             if isinstance(attr, property):
973                 names.append(name)
974         return frozenset(names)
975 
976     @cached_property
977     def db_returning_fields(self):
978         """
979         Private API intended only to be used by Django itself.
980         Fields to be returned after a database insert.
981         """
982         return [
983             field
984             for field in self._get_fields(
985                 forward=True, reverse=False, include_parents=PROXY_PARENTS
986             )
987             if getattr(field, "db_returning", False)
988         ]

</code><intended_behavior>The handling of `index_together` should be deprecated in favor of directly using `Index` instances in the `indexes` list, ensuring seamless functionality with no change to the resulting database schema.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
477 class Model(metaclass=ModelBase):
478     def __init__(self, *args, **kwargs):
479         # Alias some things as locals to avoid repeat global lookups
480         cls = self.__class__
481         opts = self._meta
482         _setattr = setattr
483         _DEFERRED = DEFERRED
484         if opts.abstract:
485             raise TypeError("Abstract models cannot be instantiated.")
486 
487         pre_init.send(sender=cls, args=args, kwargs=kwargs)
488 
489         # Set up the storage for instance state
490         self._state = ModelState()
491 
492         # There is a rather weird disparity here; if kwargs, it's set, then args
493         # overrides it. It should be one or the other; don't duplicate the work
494         # The reason for the kwargs check is that standard iterator passes in by
495         # args, and instantiation for iteration is 33% faster.
496         if len(args) > len(opts.concrete_fields):
497             # Daft, but matches old exception sans the err msg.
498             raise IndexError("Number of args exceeds number of fields")
499 
500         if not kwargs:
501             fields_iter = iter(opts.concrete_fields)
502             # The ordering of the zip calls matter - zip throws StopIteration
503             # when an iter throws it. So if the first iter throws it, the second
504             # is *not* consumed. We rely on this, so don't change the order
505             # without changing the logic.
506             for val, field in zip(args, fields_iter):
507                 if val is _DEFERRED:
508                     continue
509                 _setattr(self, field.attname, val)
510         else:
511             # Slower, kwargs-ready version.
512             fields_iter = iter(opts.fields)
513             for val, field in zip(args, fields_iter):
514                 if val is _DEFERRED:
515                     continue
516                 _setattr(self, field.attname, val)
517                 if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
518                     raise TypeError(
519                         f"{cls.__qualname__}() got both positional and "
520                         f"keyword arguments for field '{field.name}'."
521                     )
522 
523         # Now we're left with the unprocessed fields that *must* come from
524         # keywords, or default.
525 
526         for field in fields_iter:
527             is_related_object = False
528             # Virtual field
529             if field.attname not in kwargs and field.column is None:
530                 continue
531             if kwargs:
532                 if isinstance(field.remote_field, ForeignObjectRel):
533                     try:
534                         # Assume object instance was passed in.
535                         rel_obj = kwargs.pop(field.name)
536                         is_related_object = True
537                     except KeyError:
538                         try:
539                             # Object instance wasn't passed in -- must be an ID.
540                             val = kwargs.pop(field.attname)
541                         except KeyError:
542                             val = field.get_default()
543                 else:
544                     try:
545                         val = kwargs.pop(field.attname)
546                     except KeyError:
547                         # This is done with an exception rather than the
548                         # default argument on pop because we don't want
549                         # get_default() to be evaluated, and then not used.
550                         # Refs #12057.
551                         val = field.get_default()
552             else:
553                 val = field.get_default()
554 
555             if is_related_object:
556                 # If we are passed a related instance, set it using the
557                 # field.name instead of field.attname (e.g. "user" instead of
558                 # "user_id") so that the object gets properly cached (and type
559                 # checked) by the RelatedObjectDescriptor.
560                 if rel_obj is not _DEFERRED:
561                     _setattr(self, field.name, rel_obj)
562             else:
563                 if val is not _DEFERRED:
564                     _setattr(self, field.attname, val)
565 
566         if kwargs:
567             property_names = opts._property_names
568             unexpected = ()
569             for prop, value in kwargs.items():
570                 # Any remaining kwargs must correspond to properties or virtual
571                 # fields.
572                 if prop in property_names:
573                     if value is not _DEFERRED:
574                         _setattr(self, prop, value)
575                 else:
576                     try:
577                         opts.get_field(prop)
578                     except FieldDoesNotExist:
579                         unexpected += (prop,)
580                     else:
581                         if value is not _DEFERRED:
582                             _setattr(self, prop, value)
583             if unexpected:
584                 unexpected_names = ", ".join(repr(n) for n in unexpected)
585                 raise TypeError(
586                     f"{cls.__name__}() got unexpected keyword arguments: "
587                     f"{unexpected_names}"
588                 )
589         super().__init__()
590         post_init.send(sender=cls, instance=self)
591 
592     @classmethod
593     def from_db(cls, db, field_names, values):
594         if len(values) != len(cls._meta.concrete_fields):
595             values_iter = iter(values)
596             values = [
597                 next(values_iter) if f.attname in field_names else DEFERRED
598                 for f in cls._meta.concrete_fields
599             ]
600         new = cls(*values)
601         new._state.adding = False
602         new._state.db = db
603         return new
604 
605     def __repr__(self):
606         return "<%s: %s>" % (self.__class__.__name__, self)
607 
608     def __str__(self):
609         return "%s object (%s)" % (self.__class__.__name__, self.pk)
610 
611     def __eq__(self, other):
612         if not isinstance(other, Model):
613             return NotImplemented
614         if self._meta.concrete_model != other._meta.concrete_model:
615             return False
616         my_pk = self.pk
617         if my_pk is None:
618             return self is other
619         return my_pk == other.pk
620 
621     def __hash__(self):
622         if self.pk is None:
623             raise TypeError("Model instances without primary key value are unhashable")
624         return hash(self.pk)
625 
626     def __reduce__(self):
627         data = self.__getstate__()
628         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
629         class_id = self._meta.app_label, self._meta.object_name
630         return model_unpickle, (class_id,), data
631 
632     def __getstate__(self):
633         """Hook to allow choosing the attributes to pickle."""
634         state = self.__dict__.copy()
635         state["_state"] = copy.copy(state["_state"])
636         # memoryview cannot be pickled, so cast it to bytes and store
637         # separately.
638         _memoryview_attrs = []
639         for attr, value in state.items():
640             if isinstance(value, memoryview):
641                 _memoryview_attrs.append((attr, bytes(value)))
642         if _memoryview_attrs:
643             state["_memoryview_attrs"] = _memoryview_attrs
644             for attr, value in _memoryview_attrs:
645                 state.pop(attr)
646         return state
647 
648     def __setstate__(self, state):
649         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
650         if pickled_version:
651             if pickled_version != django.__version__:
652                 warnings.warn(
653                     "Pickled model instance's Django version %s does not "
654                     "match the current version %s."
655                     % (pickled_version, django.__version__),
656                     RuntimeWarning,
657                     stacklevel=2,
658                 )
659         else:
660             warnings.warn(
661                 "Pickled model instance's Django version is not specified.",
662                 RuntimeWarning,
663                 stacklevel=2,
664             )
665         if "_memoryview_attrs" in state:
666             for attr, value in state.pop("_memoryview_attrs"):
667                 state[attr] = memoryview(value)
668         self.__dict__.update(state)
669 
670     def _get_pk_val(self, meta=None):
671         meta = meta or self._meta
672         return getattr(self, meta.pk.attname)
673 
674     def _set_pk_val(self, value):
675         for parent_link in self._meta.parents.values():
676             if parent_link and parent_link != self._meta.pk:
677                 setattr(self, parent_link.target_field.attname, value)
678         return setattr(self, self._meta.pk.attname, value)
679 
680     pk = property(_get_pk_val, _set_pk_val)
681 
682     def get_deferred_fields(self):
683         """
684         Return a set containing names of deferred fields for this instance.
685         """
686         return {
687             f.attname
688             for f in self._meta.concrete_fields
689             if f.attname not in self.__dict__
690         }
691 
692     def refresh_from_db(self, using=None, fields=None):
693         """
694         Reload field values from the database.
695 
696         By default, the reloading happens from the database this instance was
697         loaded from, or by the read router if this instance wasn't loaded from
698         any database. The using parameter will override the default.
699 
700         Fields can be used to specify which fields to reload. The fields
701         should be an iterable of field attnames. If fields is None, then
702         all non-deferred fields are reloaded.
703 
704         When accessing deferred fields of an instance, the deferred loading
705         of the field will call this method.
706         """
707         if fields is None:
708             self._prefetched_objects_cache = {}
709         else:
710             prefetched_objects_cache = getattr(self, "_prefetched_objects_cache", ())
711             for field in fields:
712                 if field in prefetched_objects_cache:
713                     del prefetched_objects_cache[field]
714                     fields.remove(field)
715             if not fields:
716                 return
717             if any(LOOKUP_SEP in f for f in fields):
718                 raise ValueError(
719                     'Found "%s" in fields argument. Relations and transforms '
720                     "are not allowed in fields." % LOOKUP_SEP
721                 )
722 
723         hints = {"instance": self}
724         db_instance_qs = self.__class__._base_manager.db_manager(
725             using, hints=hints
726         ).filter(pk=self.pk)
727 
728         # Use provided fields, if not set then reload all non-deferred fields.
729         deferred_fields = self.get_deferred_fields()
730         if fields is not None:
731             fields = list(fields)
732             db_instance_qs = db_instance_qs.only(*fields)
733         elif deferred_fields:
734             fields = [
735                 f.attname
736                 for f in self._meta.concrete_fields
737                 if f.attname not in deferred_fields
738             ]
739             db_instance_qs = db_instance_qs.only(*fields)
740 
741         db_instance = db_instance_qs.get()
742         non_loaded_fields = db_instance.get_deferred_fields()
743         for field in self._meta.concrete_fields:
744             if field.attname in non_loaded_fields:
745                 # This field wasn't refreshed - skip ahead.
746                 continue
747             setattr(self, field.attname, getattr(db_instance, field.attname))
748             # Clear cached foreign keys.
749             if field.is_relation and field.is_cached(self):
750                 field.delete_cached_value(self)
751 
752         # Clear cached relations.
753         for field in self._meta.related_objects:
754             if field.is_cached(self):
755                 field.delete_cached_value(self)
756 
757         self._state.db = db_instance._state.db
758 
759     def serializable_value(self, field_name):
760         """
761         Return the value of the field name for this instance. If the field is
762         a foreign key, return the id value instead of the object. If there's
763         no Field object with this name on the model, return the model
764         attribute's value.
765 
766         Used to serialize a field's value (in the serializer, or form output,
767         for example). Normally, you would just access the attribute directly
768         and not use this method.
769         """
770         try:
771             field = self._meta.get_field(field_name)
772         except FieldDoesNotExist:
773             return getattr(self, field_name)
774         return getattr(self, field.attname)
775 
776     def save(
777         self, force_insert=False, force_update=False, using=None, update_fields=None
778     ):
779         """
780         Save the current instance. Override this in a subclass if you want to
781         control the saving process.
782 
783         The 'force_insert' and 'force_update' parameters can be used to insist
784         that the "save" must be an SQL insert or update (or equivalent for
785         non-SQL backends), respectively. Normally, they should not be set.
786         """
787         self._prepare_related_fields_for_save(operation_name="save")
788 
789         using = using or router.db_for_write(self.__class__, instance=self)
790         if force_insert and (force_update or update_fields):
791             raise ValueError("Cannot force both insert and updating in model saving.")
792 
793         deferred_fields = self.get_deferred_fields()
794         if update_fields is not None:
795             # If update_fields is empty, skip the save. We do also check for
796             # no-op saves later on for inheritance cases. This bailout is
797             # still needed for skipping signal sending.
798             if not update_fields:
799                 return
800 
801             update_fields = frozenset(update_fields)
802             field_names = set()
803 
804             for field in self._meta.concrete_fields:
805                 if not field.primary_key:
806                     field_names.add(field.name)
807 
808                     if field.name != field.attname:
809                         field_names.add(field.attname)
810 
811             non_model_fields = update_fields.difference(field_names)
812 
813             if non_model_fields:
814                 raise ValueError(
815                     "The following fields do not exist in this model, are m2m "
816                     "fields, or are non-concrete fields: %s"
817                     % ", ".join(non_model_fields)
818                 )
819 
820         # If saving to the same database, and this model is deferred, then
821         # automatically do an "update_fields" save on the loaded fields.
822         elif not force_insert and deferred_fields and using == self._state.db:
823             field_names = set()
824             for field in self._meta.concrete_fields:
825                 if not field.primary_key and not hasattr(field, "through"):
826                     field_names.add(field.attname)
827             loaded_fields = field_names.difference(deferred_fields)
828             if loaded_fields:
829                 update_fields = frozenset(loaded_fields)
830 
831         self.save_base(
832             using=using,
833             force_insert=force_insert,
834             force_update=force_update,
835             update_fields=update_fields,
836         )
837 
838     save.alters_data = True
839 
840     def save_base(
841         self,
842         raw=False,
843         force_insert=False,
844         force_update=False,
845         using=None,
846         update_fields=None,
847     ):
848         """
849         Handle the parts of saving which should be done only once per save,
850         yet need to be done in raw saves, too. This includes some sanity
851         checks and signal sending.
852 
853         The 'raw' argument is telling save_base not to save any parent
854         models and not to do any changes to the values before save. This
855         is used by fixture loading.
856         """
857         using = using or router.db_for_write(self.__class__, instance=self)
858         assert not (force_insert and (force_update or update_fields))
859         assert update_fields is None or update_fields
860         cls = origin = self.__class__
861         # Skip proxies, but keep the origin as the proxy model.
862         if cls._meta.proxy:
863             cls = cls._meta.concrete_model
864         meta = cls._meta
865         if not meta.auto_created:
866             pre_save.send(
867                 sender=origin,
868                 instance=self,
869                 raw=raw,
870                 using=using,
871                 update_fields=update_fields,
872             )
873         # A transaction isn't needed if one query is issued.
874         if meta.parents:
875             context_manager = transaction.atomic(using=using, savepoint=False)
876         else:
877             context_manager = transaction.mark_for_rollback_on_error(using=using)
878         with context_manager:
879             parent_inserted = False
880             if not raw:
881                 parent_inserted = self._save_parents(cls, using, update_fields)
882             updated = self._save_table(
883                 raw,
884                 cls,
885                 force_insert or parent_inserted,
886                 force_update,
887                 using,
888                 update_fields,
889             )
890         # Store the database on which the object was saved
891         self._state.db = using
892         # Once saved, this is no longer a to-be-added instance.
893         self._state.adding = False
894 
895         # Signal that the save is complete
896         if not meta.auto_created:
897             post_save.send(
898                 sender=origin,
899                 instance=self,
900                 created=(not updated),
901                 update_fields=update_fields,
902                 raw=raw,
903                 using=using,
904             )
905 
906     save_base.alters_data = True
907 
908     def _save_parents(self, cls, using, update_fields):
909         """Save all the parents of cls using values from self."""
910         meta = cls._meta
911         inserted = False
912         for parent, field in meta.parents.items():
913             # Make sure the link fields are synced between parent and self.
914             if (
915                 field
916                 and getattr(self, parent._meta.pk.attname) is None
917                 and getattr(self, field.attname) is not None
918             ):
919                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
920             parent_inserted = self._save_parents(
921                 cls=parent, using=using, update_fields=update_fields
922             )
923             updated = self._save_table(
924                 cls=parent,
925                 using=using,
926                 update_fields=update_fields,
927                 force_insert=parent_inserted,
928             )
929             if not updated:
930                 inserted = True
931             # Set the parent's PK value to self.
932             if field:
933                 setattr(self, field.attname, self._get_pk_val(parent._meta))
934                 # Since we didn't have an instance of the parent handy set
935                 # attname directly, bypassing the descriptor. Invalidate
936                 # the related object cache, in case it's been accidentally
937                 # populated. A fresh instance will be re-built from the
938                 # database if necessary.
939                 if field.is_cached(self):
940                     field.delete_cached_value(self)
941         return inserted
942 
943     def _save_table(
944         self,
945         raw=False,
946         cls=None,
947         force_insert=False,
948         force_update=False,
949         using=None,
950         update_fields=None,
951     ):
952         """
953         Do the heavy-lifting involved in saving. Update or insert the data
954         for a single table.
955         """
956         meta = cls._meta
957         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
958 
959         if update_fields:
960             non_pks = [
961                 f
962                 for f in non_pks
963                 if f.name in update_fields or f.attname in update_fields
964             ]
965 
966         pk_val = self._get_pk_val(meta)
967         if pk_val is None:
968             pk_val = meta.pk.get_pk_value_on_save(self)
969             setattr(self, meta.pk.attname, pk_val)
970         pk_set = pk_val is not None
971         if not pk_set and (force_update or update_fields):
972             raise ValueError("Cannot force an update in save() with no primary key.")
973         updated = False
974         # Skip an UPDATE when adding an instance and primary key has a default.
975         if (
976             not raw
977             and not force_insert
978             and self._state.adding
979             and meta.pk.default
980             and meta.pk.default is not NOT_PROVIDED
981         ):
982             force_insert = True
983         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
984         if pk_set and not force_insert:
985             base_qs = cls._base_manager.using(using)
986             values = [
987                 (
988                     f,
989                     None,
990                     (getattr(self, f.attname) if raw else f.pre_save(self, False)),
991                 )
992                 for f in non_pks
993             ]
994             forced_update = update_fields or force_update
995             updated = self._do_update(
996                 base_qs, using, pk_val, values, update_fields, forced_update
997             )
998             if force_update and not updated:
999                 raise DatabaseError("Forced update did not affect any rows.")
1000             if update_fields and not updated:
1001                 raise DatabaseError("Save with update_fields did not affect any rows.")
1002         if not updated:
1003             if meta.order_with_respect_to:
1004                 # If this is a model with an order_with_respect_to
1005                 # autopopulate the _order field
1006                 field = meta.order_with_respect_to
1007                 filter_args = field.get_filter_kwargs_for_object(self)
1008                 self._order = (
1009                     cls._base_manager.using(using)
1010                     .filter(**filter_args)
1011                     .aggregate(
1012                         _order__max=Coalesce(
1013                             ExpressionWrapper(
1014                                 Max("_order") + Value(1), output_field=IntegerField()
1015                             ),
1016                             Value(0),
1017                         ),
1018                     )["_order__max"]
1019                 )
1020             fields = meta.local_concrete_fields
1021             if not pk_set:
1022                 fields = [f for f in fields if f is not meta.auto_field]
1023 
1024             returning_fields = meta.db_returning_fields
1025             results = self._do_insert(
1026                 cls._base_manager, using, fields, returning_fields, raw
1027             )
1028             if results:
1029                 for value, field in zip(results[0], returning_fields):
1030                     setattr(self, field.attname, value)
1031         return updated
1032 
1033     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
1034         """
1035         Try to update the model. Return True if the model was updated (if an
1036         update query was done and a matching row was found in the DB).
1037         """
1038         filtered = base_qs.filter(pk=pk_val)
1039         if not values:
1040             # We can end up here when saving a model in inheritance chain where
1041             # update_fields doesn't target any field in current model. In that
1042             # case we just say the update succeeded. Another case ending up here
1043             # is a model with just PK - in that case check that the PK still
1044             # exists.
1045             return update_fields is not None or filtered.exists()
1046         if self._meta.select_on_save and not forced_update:
1047             return (
1048                 filtered.exists()
1049                 and
1050                 # It may happen that the object is deleted from the DB right after
1051                 # this check, causing the subsequent UPDATE to return zero matching
1052                 # rows. The same result can occur in some rare cases when the
1053                 # database returns zero despite the UPDATE being executed
1054                 # successfully (a row is matched and updated). In order to
1055                 # distinguish these two cases, the object's existence in the
1056                 # database is again checked for if the UPDATE query returns 0.
1057                 (filtered._update(values) > 0 or filtered.exists())
1058             )
1059         return filtered._update(values) > 0
1060 
1061     def _do_insert(self, manager, using, fields, returning_fields, raw):
1062         """
1063         Do an INSERT. If returning_fields is defined then this method should
1064         return the newly created data for the model.
1065         """
1066         return manager._insert(
1067             [self],
1068             fields=fields,
1069             returning_fields=returning_fields,
1070             using=using,
1071             raw=raw,
1072         )
1073 
1074     def _prepare_related_fields_for_save(self, operation_name, fields=None):
1075         # Ensure that a model instance without a PK hasn't been assigned to
1076         # a ForeignKey, GenericForeignKey or OneToOneField on this model. If
1077         # the field is nullable, allowing the save would result in silent data
1078         # loss.
1079         for field in self._meta.concrete_fields:
1080             if fields and field not in fields:
1081                 continue
1082             # If the related field isn't cached, then an instance hasn't been
1083             # assigned and there's no need to worry about this check.
1084             if field.is_relation and field.is_cached(self):
1085                 obj = getattr(self, field.name, None)
1086                 if not obj:
1087                     continue
1088                 # A pk may have been assigned manually to a model instance not
1089                 # saved to the database (or auto-generated in a case like
1090                 # UUIDField), but we allow the save to proceed and rely on the
1091                 # database to raise an IntegrityError if applicable. If
1092                 # constraints aren't supported by the database, there's the
1093                 # unavoidable risk of data corruption.
1094                 if obj.pk is None:
1095                     # Remove the object from a related instance cache.
1096                     if not field.remote_field.multiple:
1097                         field.remote_field.delete_cached_value(obj)
1098                     raise ValueError(
1099                         "%s() prohibited to prevent data loss due to unsaved "
1100                         "related object '%s'." % (operation_name, field.name)
1101                     )
1102                 elif getattr(self, field.attname) in field.empty_values:
1103                     # Set related object if it has been saved after an
1104                     # assignment.
1105                     setattr(self, field.name, obj)
1106                 # If the relationship's pk/to_field was changed, clear the
1107                 # cached relationship.
1108                 if getattr(obj, field.target_field.attname) != getattr(
1109                     self, field.attname
1110                 ):
1111                     field.delete_cached_value(self)
1112         # GenericForeignKeys are private.
1113         for field in self._meta.private_fields:
1114             if fields and field not in fields:
1115                 continue
1116             if (
1117                 field.is_relation
1118                 and field.is_cached(self)
1119                 and hasattr(field, "fk_field")
1120             ):
1121                 obj = field.get_cached_value(self, default=None)
1122                 if obj and obj.pk is None:
1123                     raise ValueError(
1124                         f"{operation_name}() prohibited to prevent data loss due to "
1125                         f"unsaved related object '{field.name}'."
1126                     )
1127 
1128     def delete(self, using=None, keep_parents=False):
1129         if self.pk is None:
1130             raise ValueError(
1131                 "%s object can't be deleted because its %s attribute is set "
1132                 "to None." % (self._meta.object_name, self._meta.pk.attname)
1133             )
1134         using = using or router.db_for_write(self.__class__, instance=self)
1135         collector = Collector(using=using, origin=self)
1136         collector.collect([self], keep_parents=keep_parents)
1137         return collector.delete()
1138 
1139     delete.alters_data = True
1140 
1141     def _get_FIELD_display(self, field):
1142         value = getattr(self, field.attname)
1143         choices_dict = dict(make_hashable(field.flatchoices))
1144         # force_str() to coerce lazy strings.
1145         return force_str(
1146             choices_dict.get(make_hashable(value), value), strings_only=True
1147         )
1148 
1149     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
1150         if not self.pk:
1151             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
1152         op = "gt" if is_next else "lt"
1153         order = "" if is_next else "-"
1154         param = getattr(self, field.attname)
1155         q = Q((field.name, param), (f"pk__{op}", self.pk), _connector=Q.AND)
1156         q = Q(q, (f"{field.name}__{op}", param), _connector=Q.OR)
1157         qs = (
1158             self.__class__._default_manager.using(self._state.db)
1159             .filter(**kwargs)
1160             .filter(q)
1161             .order_by("%s%s" % (order, field.name), "%spk" % order)
1162         )
1163         try:
1164             return qs[0]
1165         except IndexError:
1166             raise self.DoesNotExist(
1167                 "%s matching query does not exist." % self.__class__._meta.object_name
1168             )
1169 
1170     def _get_next_or_previous_in_order(self, is_next):
1171         cachename = "__%s_order_cache" % is_next
1172         if not hasattr(self, cachename):
1173             op = "gt" if is_next else "lt"
1174             order = "_order" if is_next else "-_order"
1175             order_field = self._meta.order_with_respect_to
1176             filter_args = order_field.get_filter_kwargs_for_object(self)
1177             obj = (
1178                 self.__class__._default_manager.filter(**filter_args)
1179                 .filter(
1180                     **{
1181                         "_order__%s"
1182                         % op: self.__class__._default_manager.values("_order").filter(
1183                             **{self._meta.pk.name: self.pk}
1184                         )
1185                     }
1186                 )
1187                 .order_by(order)[:1]
1188                 .get()
1189             )
1190             setattr(self, cachename, obj)
1191         return getattr(self, cachename)
1192 
1193     def _get_field_value_map(self, meta, exclude=None):
1194         if exclude is None:
1195             exclude = set()
1196         meta = meta or self._meta
1197         return {
1198             field.name: Value(getattr(self, field.attname), field)
1199             for field in meta.local_concrete_fields
1200             if field.name not in exclude
1201         }
1202 
1203     def prepare_database_save(self, field):
1204         if self.pk is None:
1205             raise ValueError(
1206                 "Unsaved model instance %r cannot be used in an ORM query." % self
1207             )
1208         return getattr(self, field.remote_field.get_related_field().attname)
1209 
1210     def clean(self):
1211         """
1212         Hook for doing any extra model-wide validation after clean() has been
1213         called on every field by self.clean_fields. Any ValidationError raised
1214         by this method will not be associated with a particular field; it will
1215         have a special-case association with the field defined by NON_FIELD_ERRORS.
1216         """
1217         pass
1218 
1219     def validate_unique(self, exclude=None):
1220         """
1221         Check unique constraints on the model and raise ValidationError if any
1222         failed.
1223         """
1224         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1225 
1226         errors = self._perform_unique_checks(unique_checks)
1227         date_errors = self._perform_date_checks(date_checks)
1228 
1229         for k, v in date_errors.items():
1230             errors.setdefault(k, []).extend(v)
1231 
1232         if errors:
1233             raise ValidationError(errors)
1234 
1235     def _get_unique_checks(self, exclude=None, include_meta_constraints=False):
1236         """
1237         Return a list of checks to perform. Since validate_unique() could be
1238         called from a ModelForm, some fields may have been excluded; we can't
1239         perform a unique check on a model that is missing fields involved
1240         in that check. Fields that did not validate should also be excluded,
1241         but they need to be passed in via the exclude argument.
1242         """
1243         if exclude is None:
1244             exclude = set()
1245         unique_checks = []
1246 
1247         unique_togethers = [(self.__class__, self._meta.unique_together)]
1248         constraints = []
1249         if include_meta_constraints:
1250             constraints = [(self.__class__, self._meta.total_unique_constraints)]
1251         for parent_class in self._meta.get_parent_list():
1252             if parent_class._meta.unique_together:
1253                 unique_togethers.append(
1254                     (parent_class, parent_class._meta.unique_together)
1255                 )
1256             if include_meta_constraints and parent_class._meta.total_unique_constraints:
1257                 constraints.append(
1258                     (parent_class, parent_class._meta.total_unique_constraints)
1259                 )
1260 
1261         for model_class, unique_together in unique_togethers:
1262             for check in unique_together:
1263                 if not any(name in exclude for name in check):
1264                     # Add the check if the field isn't excluded.
1265                     unique_checks.append((model_class, tuple(check)))
1266 
1267         if include_meta_constraints:
1268             for model_class, model_constraints in constraints:
1269                 for constraint in model_constraints:
1270                     if not any(name in exclude for name in constraint.fields):
1271                         unique_checks.append((model_class, constraint.fields))
1272 
1273         # These are checks for the unique_for_<date/year/month>.
1274         date_checks = []
1275 
1276         # Gather a list of checks for fields declared as unique and add them to
1277         # the list of checks.
1278 
1279         fields_with_class = [(self.__class__, self._meta.local_fields)]
1280         for parent_class in self._meta.get_parent_list():
1281             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1282 
1283         for model_class, fields in fields_with_class:
1284             for f in fields:
1285                 name = f.name
1286                 if name in exclude:
1287                     continue
1288                 if f.unique:
1289                     unique_checks.append((model_class, (name,)))
1290                 if f.unique_for_date and f.unique_for_date not in exclude:
1291                     date_checks.append((model_class, "date", name, f.unique_for_date))
1292                 if f.unique_for_year and f.unique_for_year not in exclude:
1293                     date_checks.append((model_class, "year", name, f.unique_for_year))
1294                 if f.unique_for_month and f.unique_for_month not in exclude:
1295                     date_checks.append((model_class, "month", name, f.unique_for_month))
1296         return unique_checks, date_checks
1297 
1298     def _perform_unique_checks(self, unique_checks):
1299         errors = {}
1300 
1301         for model_class, unique_check in unique_checks:
1302             # Try to look up an existing object with the same values as this
1303             # object's values for all the unique field.
1304 
1305             lookup_kwargs = {}
1306             for field_name in unique_check:
1307                 f = self._meta.get_field(field_name)
1308                 lookup_value = getattr(self, f.attname)
1309                 # TODO: Handle multiple backends with different feature flags.
1310                 if lookup_value is None or (
1311                     lookup_value == ""
1312                     and connection.features.interprets_empty_strings_as_nulls
1313                 ):
1314                     # no value, skip the lookup
1315                     continue
1316                 if f.primary_key and not self._state.adding:
1317                     # no need to check for unique primary key when editing
1318                     continue
1319                 lookup_kwargs[str(field_name)] = lookup_value
1320 
1321             # some fields were skipped, no reason to do the check
1322             if len(unique_check) != len(lookup_kwargs):
1323                 continue
1324 
1325             qs = model_class._default_manager.filter(**lookup_kwargs)
1326 
1327             # Exclude the current object from the query if we are editing an
1328             # instance (as opposed to creating a new one)
1329             # Note that we need to use the pk as defined by model_class, not
1330             # self.pk. These can be different fields because model inheritance
1331             # allows single model to have effectively multiple primary keys.
1332             # Refs #17615.
1333             model_class_pk = self._get_pk_val(model_class._meta)
1334             if not self._state.adding and model_class_pk is not None:
1335                 qs = qs.exclude(pk=model_class_pk)
1336             if qs.exists():
1337                 if len(unique_check) == 1:
1338                     key = unique_check[0]
1339                 else:
1340                     key = NON_FIELD_ERRORS
1341                 errors.setdefault(key, []).append(
1342                     self.unique_error_message(model_class, unique_check)
1343                 )
1344 
1345         return errors
1346 
1347     def _perform_date_checks(self, date_checks):
1348         errors = {}
1349         for model_class, lookup_type, field, unique_for in date_checks:
1350             lookup_kwargs = {}
1351             # there's a ticket to add a date lookup, we can remove this special
1352             # case if that makes it's way in
1353             date = getattr(self, unique_for)
1354             if date is None:
1355                 continue
1356             if lookup_type == "date":
1357                 lookup_kwargs["%s__day" % unique_for] = date.day
1358                 lookup_kwargs["%s__month" % unique_for] = date.month
1359                 lookup_kwargs["%s__year" % unique_for] = date.year
1360             else:
1361                 lookup_kwargs["%s__%s" % (unique_for, lookup_type)] = getattr(
1362                     date, lookup_type
1363                 )
1364             lookup_kwargs[field] = getattr(self, field)
1365 
1366             qs = model_class._default_manager.filter(**lookup_kwargs)
1367             # Exclude the current object from the query if we are editing an
1368             # instance (as opposed to creating a new one)
1369             if not self._state.adding and self.pk is not None:
1370                 qs = qs.exclude(pk=self.pk)
1371 
1372             if qs.exists():
1373                 errors.setdefault(field, []).append(
1374                     self.date_error_message(lookup_type, field, unique_for)
1375                 )
1376         return errors
1377 
1378     def date_error_message(self, lookup_type, field_name, unique_for):
1379         opts = self._meta
1380         field = opts.get_field(field_name)
1381         return ValidationError(
1382             message=field.error_messages["unique_for_date"],
1383             code="unique_for_date",
1384             params={
1385                 "model": self,
1386                 "model_name": capfirst(opts.verbose_name),
1387                 "lookup_type": lookup_type,
1388                 "field": field_name,
1389                 "field_label": capfirst(field.verbose_name),
1390                 "date_field": unique_for,
1391                 "date_field_label": capfirst(opts.get_field(unique_for).verbose_name),
1392             },
1393         )
1394 
1395     def unique_error_message(self, model_class, unique_check):
1396         opts = model_class._meta
1397 
1398         params = {
1399             "model": self,
1400             "model_class": model_class,
1401             "model_name": capfirst(opts.verbose_name),
1402             "unique_check": unique_check,
1403         }
1404 
1405         # A unique field
1406         if len(unique_check) == 1:
1407             field = opts.get_field(unique_check[0])
1408             params["field_label"] = capfirst(field.verbose_name)
1409             return ValidationError(
1410                 message=field.error_messages["unique"],
1411                 code="unique",
1412                 params=params,
1413             )
1414 
1415         # unique_together
1416         else:
1417             field_labels = [
1418                 capfirst(opts.get_field(f).verbose_name) for f in unique_check
1419             ]
1420             params["field_labels"] = get_text_list(field_labels, _("and"))
1421             return ValidationError(
1422                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1423                 code="unique_together",
1424                 params=params,
1425             )
1426 
1427     def get_constraints(self):
1428         constraints = [(self.__class__, self._meta.constraints)]
1429         for parent_class in self._meta.get_parent_list():
1430             if parent_class._meta.constraints:
1431                 constraints.append((parent_class, parent_class._meta.constraints))
1432         return constraints
1433 
1434     def validate_constraints(self, exclude=None):
1435         constraints = self.get_constraints()
1436         using = router.db_for_write(self.__class__, instance=self)
1437 
1438         errors = {}
1439         for model_class, model_constraints in constraints:
1440             for constraint in model_constraints:
1441                 try:
1442                     constraint.validate(model_class, self, exclude=exclude, using=using)
1443                 except ValidationError as e:
1444                     if e.code == "unique" and len(constraint.fields) == 1:
1445                         errors.setdefault(constraint.fields[0], []).append(e)
1446                     else:
1447                         errors = e.update_error_dict(errors)
1448         if errors:
1449             raise ValidationError(errors)
1450 
1451     def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
1452         """
1453         Call clean_fields(), clean(), validate_unique(), and
1454         validate_constraints() on the model. Raise a ValidationError for any
1455         errors that occur.
1456         """
1457         errors = {}
1458         if exclude is None:
1459             exclude = set()
1460         else:
1461             exclude = set(exclude)
1462 
1463         try:
1464             self.clean_fields(exclude=exclude)
1465         except ValidationError as e:
1466             errors = e.update_error_dict(errors)
1467 
1468         # Form.clean() is run even if other validation fails, so do the
1469         # same with Model.clean() for consistency.
1470         try:
1471             self.clean()
1472         except ValidationError as e:
1473             errors = e.update_error_dict(errors)
1474 
1475         # Run unique checks, but only for fields that passed validation.
1476         if validate_unique:
1477             for name in errors:
1478                 if name != NON_FIELD_ERRORS and name not in exclude:
1479                     exclude.add(name)
1480             try:
1481                 self.validate_unique(exclude=exclude)
1482             except ValidationError as e:
1483                 errors = e.update_error_dict(errors)
1484 
1485         # Run constraints checks, but only for fields that passed validation.
1486         if validate_constraints:
1487             for name in errors:
1488                 if name != NON_FIELD_ERRORS and name not in exclude:
1489                     exclude.add(name)
1490             try:
1491                 self.validate_constraints(exclude=exclude)
1492             except ValidationError as e:
1493                 errors = e.update_error_dict(errors)
1494 
1495         if errors:
1496             raise ValidationError(errors)
1497 
1498     def clean_fields(self, exclude=None):
1499         """
1500         Clean all fields and raise a ValidationError containing a dict
1501         of all validation errors if any occur.
1502         """
1503         if exclude is None:
1504             exclude = set()
1505 
1506         errors = {}
1507         for f in self._meta.fields:
1508             if f.name in exclude:
1509                 continue
1510             # Skip validation for empty fields with blank=True. The developer
1511             # is responsible for making sure they have a valid value.
1512             raw_value = getattr(self, f.attname)
1513             if f.blank and raw_value in f.empty_values:
1514                 continue
1515             try:
1516                 setattr(self, f.attname, f.clean(raw_value, self))
1517             except ValidationError as e:
1518                 errors[f.name] = e.error_list
1519 
1520         if errors:
1521             raise ValidationError(errors)
1522 
1523     @classmethod
1524     def check(cls, **kwargs):
1525         errors = [
1526             *cls._check_swappable(),
1527             *cls._check_model(),
1528             *cls._check_managers(**kwargs),
1529         ]
1530         if not cls._meta.swapped:
1531             databases = kwargs.get("databases") or []
1532             errors += [
1533                 *cls._check_fields(**kwargs),
1534                 *cls._check_m2m_through_same_relationship(),
1535                 *cls._check_long_column_names(databases),
1536             ]
1537             clash_errors = (
1538                 *cls._check_id_field(),
1539                 *cls._check_field_name_clashes(),
1540                 *cls._check_model_name_db_lookup_clashes(),
1541                 *cls._check_property_name_related_field_accessor_clashes(),
1542                 *cls._check_single_primary_key(),
1543             )
1544             errors.extend(clash_errors)
1545             # If there are field name clashes, hide consequent column name
1546             # clashes.
1547             if not clash_errors:
1548                 errors.extend(cls._check_column_name_clashes())
1549             errors += [
1550                 *cls._check_index_together(),
1551                 *cls._check_unique_together(),
1552                 *cls._check_indexes(databases),
1553                 *cls._check_ordering(),
1554                 *cls._check_constraints(databases),
1555                 *cls._check_default_pk(),
1556             ]
1557 
1558         return errors
1559 
1560     @classmethod
1561     def _check_default_pk(cls):
1562         if (
1563             not cls._meta.abstract
1564             and cls._meta.pk.auto_created
1565             and
1566             # Inherited PKs are checked in parents models.
1567             not (
1568                 isinstance(cls._meta.pk, OneToOneField)
1569                 and cls._meta.pk.remote_field.parent_link
1570             )
1571             and not settings.is_overridden("DEFAULT_AUTO_FIELD")
1572             and cls._meta.app_config
1573             and not cls._meta.app_config._is_default_auto_field_overridden
1574         ):
1575             return [
1576                 checks.Warning(
1577                     f"Auto-created primary key used when not defining a "
1578                     f"primary key type, by default "
1579                     f"'{settings.DEFAULT_AUTO_FIELD}'.",
1580                     hint=(
1581                         f"Configure the DEFAULT_AUTO_FIELD setting or the "
1582                         f"{cls._meta.app_config.__class__.__qualname__}."
1583                         f"default_auto_field attribute to point to a subclass "
1584                         f"of AutoField, e.g. 'django.db.models.BigAutoField'."
1585                     ),
1586                     obj=cls,
1587                     id="models.W042",
1588                 ),
1589             ]
1590         return []
1591 
1592     @classmethod
1593     def _check_swappable(cls):
1594         """Check if the swapped model exists."""
1595         errors = []
1596         if cls._meta.swapped:
1597             try:
1598                 apps.get_model(cls._meta.swapped)
1599             except ValueError:
1600                 errors.append(
1601                     checks.Error(
1602                         "'%s' is not of the form 'app_label.app_name'."
1603                         % cls._meta.swappable,
1604                         id="models.E001",
1605                     )
1606                 )
1607             except LookupError:
1608                 app_label, model_name = cls._meta.swapped.split(".")
1609                 errors.append(
1610                     checks.Error(
1611                         "'%s' references '%s.%s', which has not been "
1612                         "installed, or is abstract."
1613                         % (cls._meta.swappable, app_label, model_name),
1614                         id="models.E002",
1615                     )
1616                 )
1617         return errors
1618 
1619     @classmethod
1620     def _check_model(cls):
1621         errors = []
1622         if cls._meta.proxy:
1623             if cls._meta.local_fields or cls._meta.local_many_to_many:
1624                 errors.append(
1625                     checks.Error(
1626                         "Proxy model '%s' contains model fields." % cls.__name__,
1627                         id="models.E017",
1628                     )
1629                 )
1630         return errors
1631 
1632     @classmethod
1633     def _check_managers(cls, **kwargs):
1634         """Perform all manager checks."""
1635         errors = []
1636         for manager in cls._meta.managers:
1637             errors.extend(manager.check(**kwargs))
1638         return errors
1639 
1640     @classmethod
1641     def _check_fields(cls, **kwargs):
1642         """Perform all field checks."""
1643         errors = []
1644         for field in cls._meta.local_fields:
1645             errors.extend(field.check(**kwargs))
1646         for field in cls._meta.local_many_to_many:
1647             errors.extend(field.check(from_model=cls, **kwargs))
1648         return errors
1649 
1650     @classmethod
1651     def _check_m2m_through_same_relationship(cls):
1652         """Check if no relationship model is used by more than one m2m field."""
1653 
1654         errors = []
1655         seen_intermediary_signatures = []
1656 
1657         fields = cls._meta.local_many_to_many
1658 
1659         # Skip when the target model wasn't found.
1660         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1661 
1662         # Skip when the relationship model wasn't found.
1663         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1664 
1665         for f in fields:
1666             signature = (
1667                 f.remote_field.model,
1668                 cls,
1669                 f.remote_field.through,
1670                 f.remote_field.through_fields,
1671             )
1672             if signature in seen_intermediary_signatures:
1673                 errors.append(
1674                     checks.Error(
1675                         "The model has two identical many-to-many relations "
1676                         "through the intermediate model '%s'."
1677                         % f.remote_field.through._meta.label,
1678                         obj=cls,
1679                         id="models.E003",
1680                     )
1681                 )
1682             else:
1683                 seen_intermediary_signatures.append(signature)
1684         return errors
1685 
1686     @classmethod
1687     def _check_id_field(cls):
1688         """Check if `id` field is a primary key."""
1689         fields = [
1690             f for f in cls._meta.local_fields if f.name == "id" and f != cls._meta.pk
1691         ]
1692         # fields is empty or consists of the invalid "id" field
1693         if fields and not fields[0].primary_key and cls._meta.pk.name == "id":
1694             return [
1695                 checks.Error(
1696                     "'id' can only be used as a field name if the field also "
1697                     "sets 'primary_key=True'.",
1698                     obj=cls,
1699                     id="models.E004",
1700                 )
1701             ]
1702         else:
1703             return []
1704 
1705     @classmethod
1706     def _check_field_name_clashes(cls):
1707         """Forbid field shadowing in multi-table inheritance."""
1708         errors = []
1709         used_fields = {}  # name or attname -> field
1710 
1711         # Check that multi-inheritance doesn't cause field name shadowing.
1712         for parent in cls._meta.get_parent_list():
1713             for f in parent._meta.local_fields:
1714                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1715                 if clash:
1716                     errors.append(
1717                         checks.Error(
1718                             "The field '%s' from parent model "
1719                             "'%s' clashes with the field '%s' "
1720                             "from parent model '%s'."
1721                             % (clash.name, clash.model._meta, f.name, f.model._meta),
1722                             obj=cls,
1723                             id="models.E005",
1724                         )
1725                     )
1726                 used_fields[f.name] = f
1727                 used_fields[f.attname] = f
1728 
1729         # Check that fields defined in the model don't clash with fields from
1730         # parents, including auto-generated fields like multi-table inheritance
1731         # child accessors.
1732         for parent in cls._meta.get_parent_list():
1733             for f in parent._meta.get_fields():
1734                 if f not in used_fields:
1735                     used_fields[f.name] = f
1736 
1737         for f in cls._meta.local_fields:
1738             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1739             # Note that we may detect clash between user-defined non-unique
1740             # field "id" and automatically added unique field "id", both
1741             # defined at the same model. This special case is considered in
1742             # _check_id_field and here we ignore it.
1743             id_conflict = (
1744                 f.name == "id" and clash and clash.name == "id" and clash.model == cls
1745             )
1746             if clash and not id_conflict:
1747                 errors.append(
1748                     checks.Error(
1749                         "The field '%s' clashes with the field '%s' "
1750                         "from model '%s'." % (f.name, clash.name, clash.model._meta),
1751                         obj=f,
1752                         id="models.E006",
1753                     )
1754                 )
1755             used_fields[f.name] = f
1756             used_fields[f.attname] = f
1757 
1758         return errors
1759 
1760     @classmethod
1761     def _check_column_name_clashes(cls):
1762         # Store a list of column names which have already been used by other fields.
1763         used_column_names = []
1764         errors = []
1765 
1766         for f in cls._meta.local_fields:
1767             _, column_name = f.get_attname_column()
1768 
1769             # Ensure the column name is not already in use.
1770             if column_name and column_name in used_column_names:
1771                 errors.append(
1772                     checks.Error(
1773                         "Field '%s' has column name '%s' that is used by "
1774                         "another field." % (f.name, column_name),
1775                         hint="Specify a 'db_column' for the field.",
1776                         obj=cls,
1777                         id="models.E007",
1778                     )
1779                 )
1780             else:
1781                 used_column_names.append(column_name)
1782 
1783         return errors
1784 
1785     @classmethod
1786     def _check_model_name_db_lookup_clashes(cls):
1787         errors = []
1788         model_name = cls.__name__
1789         if model_name.startswith("_") or model_name.endswith("_"):
1790             errors.append(
1791                 checks.Error(
1792                     "The model name '%s' cannot start or end with an underscore "
1793                     "as it collides with the query lookup syntax." % model_name,
1794                     obj=cls,
1795                     id="models.E023",
1796                 )
1797             )
1798         elif LOOKUP_SEP in model_name:
1799             errors.append(
1800                 checks.Error(
1801                     "The model name '%s' cannot contain double underscores as "
1802                     "it collides with the query lookup syntax." % model_name,
1803                     obj=cls,
1804                     id="models.E024",
1805                 )
1806             )
1807         return errors
1808 
1809     @classmethod
1810     def _check_property_name_related_field_accessor_clashes(cls):
1811         errors = []
1812         property_names = cls._meta._property_names
1813         related_field_accessors = (
1814             f.get_attname()
1815             for f in cls._meta._get_fields(reverse=False)
1816             if f.is_relation and f.related_model is not None
1817         )
1818         for accessor in related_field_accessors:
1819             if accessor in property_names:
1820                 errors.append(
1821                     checks.Error(
1822                         "The property '%s' clashes with a related field "
1823                         "accessor." % accessor,
1824                         obj=cls,
1825                         id="models.E025",
1826                     )
1827                 )
1828         return errors
1829 
1830     @classmethod
1831     def _check_single_primary_key(cls):
1832         errors = []
1833         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1834             errors.append(
1835                 checks.Error(
1836                     "The model cannot have more than one field with "
1837                     "'primary_key=True'.",
1838                     obj=cls,
1839                     id="models.E026",
1840                 )
1841             )
1842         return errors
1843 
1844     @classmethod
1845     def _check_index_together(cls):
1846         """Check the value of "index_together" option."""
1847         if not isinstance(cls._meta.index_together, (tuple, list)):
1848             return [
1849                 checks.Error(
1850                     "'index_together' must be a list or tuple.",
1851                     obj=cls,
1852                     id="models.E008",
1853                 )
1854             ]
1855 
1856         elif any(
1857             not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together
1858         ):
1859             return [
1860                 checks.Error(
1861                     "All 'index_together' elements must be lists or tuples.",
1862                     obj=cls,
1863                     id="models.E009",
1864                 )
1865             ]
1866 
1867         else:
1868             errors = []
1869             for fields in cls._meta.index_together:
1870                 errors.extend(cls._check_local_fields(fields, "index_together"))
1871             return errors
1872 
1873     @classmethod
1874     def _check_unique_together(cls):
1875         """Check the value of "unique_together" option."""
1876         if not isinstance(cls._meta.unique_together, (tuple, list)):
1877             return [
1878                 checks.Error(
1879                     "'unique_together' must be a list or tuple.",
1880                     obj=cls,
1881                     id="models.E010",
1882                 )
1883             ]
1884 
1885         elif any(
1886             not isinstance(fields, (tuple, list))
1887             for fields in cls._meta.unique_together
1888         ):
1889             return [
1890                 checks.Error(
1891                     "All 'unique_together' elements must be lists or tuples.",
1892                     obj=cls,
1893                     id="models.E011",
1894                 )
1895             ]
1896 
1897         else:
1898             errors = []
1899             for fields in cls._meta.unique_together:
1900                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1901             return errors
1902 
1903     @classmethod
1904     def _check_indexes(cls, databases):
1905         """Check fields, names, and conditions of indexes."""
1906         errors = []
1907         references = set()
1908         for index in cls._meta.indexes:
1909             # Index name can't start with an underscore or a number, restricted
1910             # for cross-database compatibility with Oracle.
1911             if index.name[0] == "_" or index.name[0].isdigit():
1912                 errors.append(
1913                     checks.Error(
1914                         "The index name '%s' cannot start with an underscore "
1915                         "or a number." % index.name,
1916                         obj=cls,
1917                         id="models.E033",
1918                     ),
1919                 )
1920             if len(index.name) > index.max_name_length:
1921                 errors.append(
1922                     checks.Error(
1923                         "The index name '%s' cannot be longer than %d "
1924                         "characters." % (index.name, index.max_name_length),
1925                         obj=cls,
1926                         id="models.E034",
1927                     ),
1928                 )
1929             if index.contains_expressions:
1930                 for expression in index.expressions:
1931                     references.update(
1932                         ref[0] for ref in cls._get_expr_references(expression)
1933                     )
1934         for db in databases:
1935             if not router.allow_migrate_model(db, cls):
1936                 continue
1937             connection = connections[db]
1938             if not (
1939                 connection.features.supports_partial_indexes
1940                 or "supports_partial_indexes" in cls._meta.required_db_features
1941             ) and any(index.condition is not None for index in cls._meta.indexes):
1942                 errors.append(
1943                     checks.Warning(
1944                         "%s does not support indexes with conditions."
1945                         % connection.display_name,
1946                         hint=(
1947                             "Conditions will be ignored. Silence this warning "
1948                             "if you don't care about it."
1949                         ),
1950                         obj=cls,
1951                         id="models.W037",
1952                     )
1953                 )
1954             if not (
1955                 connection.features.supports_covering_indexes
1956                 or "supports_covering_indexes" in cls._meta.required_db_features
1957             ) and any(index.include for index in cls._meta.indexes):
1958                 errors.append(
1959                     checks.Warning(
1960                         "%s does not support indexes with non-key columns."
1961                         % connection.display_name,
1962                         hint=(
1963                             "Non-key columns will be ignored. Silence this "
1964                             "warning if you don't care about it."
1965                         ),
1966                         obj=cls,
1967                         id="models.W040",
1968                     )
1969                 )
1970             if not (
1971                 connection.features.supports_expression_indexes
1972                 or "supports_expression_indexes" in cls._meta.required_db_features
1973             ) and any(index.contains_expressions for index in cls._meta.indexes):
1974                 errors.append(
1975                     checks.Warning(
1976                         "%s does not support indexes on expressions."
1977                         % connection.display_name,
1978                         hint=(
1979                             "An index won't be created. Silence this warning "
1980                             "if you don't care about it."
1981                         ),
1982                         obj=cls,
1983                         id="models.W043",
1984                     )
1985                 )
1986         fields = [
1987             field for index in cls._meta.indexes for field, _ in index.fields_orders
1988         ]
1989         fields += [include for index in cls._meta.indexes for include in index.include]
1990         fields += references
1991         errors.extend(cls._check_local_fields(fields, "indexes"))
1992         return errors
1993 
1994     @classmethod
1995     def _check_local_fields(cls, fields, option):
1996         from django.db import models
1997 
1998         # In order to avoid hitting the relation tree prematurely, we use our
1999         # own fields_map instead of using get_field()
2000         forward_fields_map = {}
2001         for field in cls._meta._get_fields(reverse=False):
2002             forward_fields_map[field.name] = field
2003             if hasattr(field, "attname"):
2004                 forward_fields_map[field.attname] = field
2005 
2006         errors = []
2007         for field_name in fields:
2008             try:
2009                 field = forward_fields_map[field_name]
2010             except KeyError:
2011                 errors.append(
2012                     checks.Error(
2013                         "'%s' refers to the nonexistent field '%s'."
2014                         % (
2015                             option,
2016                             field_name,
2017                         ),
2018                         obj=cls,
2019                         id="models.E012",
2020                     )
2021                 )
2022             else:
2023                 if isinstance(field.remote_field, models.ManyToManyRel):
2024                     errors.append(
2025                         checks.Error(
2026                             "'%s' refers to a ManyToManyField '%s', but "
2027                             "ManyToManyFields are not permitted in '%s'."
2028                             % (
2029                                 option,
2030                                 field_name,
2031                                 option,
2032                             ),
2033                             obj=cls,
2034                             id="models.E013",
2035                         )
2036                     )
2037                 elif field not in cls._meta.local_fields:
2038                     errors.append(
2039                         checks.Error(
2040                             "'%s' refers to field '%s' which is not local to model "
2041                             "'%s'." % (option, field_name, cls._meta.object_name),
2042                             hint="This issue may be caused by multi-table inheritance.",
2043                             obj=cls,
2044                             id="models.E016",
2045                         )
2046                     )
2047         return errors
2048 
2049     @classmethod
2050     def _check_ordering(cls):
2051         """
2052         Check "ordering" option -- is it a list of strings and do all fields
2053         exist?
2054         """
2055         if cls._meta._ordering_clash:
2056             return [
2057                 checks.Error(
2058                     "'ordering' and 'order_with_respect_to' cannot be used together.",
2059                     obj=cls,
2060                     id="models.E021",
2061                 ),
2062             ]
2063 
2064         if cls._meta.order_with_respect_to or not cls._meta.ordering:
2065             return []
2066 
2067         if not isinstance(cls._meta.ordering, (list, tuple)):
2068             return [
2069                 checks.Error(
2070                     "'ordering' must be a tuple or list (even if you want to order by "
2071                     "only one field).",
2072                     obj=cls,
2073                     id="models.E014",
2074                 )
2075             ]
2076 
2077         errors = []
2078         fields = cls._meta.ordering
2079 
2080         # Skip expressions and '?' fields.
2081         fields = (f for f in fields if isinstance(f, str) and f != "?")
2082 
2083         # Convert "-field" to "field".
2084         fields = ((f[1:] if f.startswith("-") else f) for f in fields)
2085 
2086         # Separate related fields and non-related fields.
2087         _fields = []
2088         related_fields = []
2089         for f in fields:
2090             if LOOKUP_SEP in f:
2091                 related_fields.append(f)
2092             else:
2093                 _fields.append(f)
2094         fields = _fields
2095 
2096         # Check related fields.
2097         for field in related_fields:
2098             _cls = cls
2099             fld = None
2100             for part in field.split(LOOKUP_SEP):
2101                 try:
2102                     # pk is an alias that won't be found by opts.get_field.
2103                     if part == "pk":
2104                         fld = _cls._meta.pk
2105                     else:
2106                         fld = _cls._meta.get_field(part)
2107                     if fld.is_relation:
2108                         _cls = fld.path_infos[-1].to_opts.model
2109                     else:
2110                         _cls = None
2111                 except (FieldDoesNotExist, AttributeError):
2112                     if fld is None or (
2113                         fld.get_transform(part) is None and fld.get_lookup(part) is None
2114                     ):
2115                         errors.append(
2116                             checks.Error(
2117                                 "'ordering' refers to the nonexistent field, "
2118                                 "related field, or lookup '%s'." % field,
2119                                 obj=cls,
2120                                 id="models.E015",
2121                             )
2122                         )
2123 
2124         # Skip ordering on pk. This is always a valid order_by field
2125         # but is an alias and therefore won't be found by opts.get_field.
2126         fields = {f for f in fields if f != "pk"}
2127 
2128         # Check for invalid or nonexistent fields in ordering.
2129         invalid_fields = []
2130 
2131         # Any field name that is not present in field_names does not exist.
2132         # Also, ordering by m2m fields is not allowed.
2133         opts = cls._meta
2134         valid_fields = set(
2135             chain.from_iterable(
2136                 (f.name, f.attname)
2137                 if not (f.auto_created and not f.concrete)
2138                 else (f.field.related_query_name(),)
2139                 for f in chain(opts.fields, opts.related_objects)
2140             )
2141         )
2142 
2143         invalid_fields.extend(fields - valid_fields)
2144 
2145         for invalid_field in invalid_fields:
2146             errors.append(
2147                 checks.Error(
2148                     "'ordering' refers to the nonexistent field, related "
2149                     "field, or lookup '%s'." % invalid_field,
2150                     obj=cls,
2151                     id="models.E015",
2152                 )
2153             )
2154         return errors
2155 
2156     @classmethod
2157     def _check_long_column_names(cls, databases):
2158         """
2159         Check that any auto-generated column names are shorter than the limits
2160         for each database in which the model will be created.
2161         """
2162         if not databases:
2163             return []
2164         errors = []
2165         allowed_len = None
2166         db_alias = None
2167 
2168         # Find the minimum max allowed length among all specified db_aliases.
2169         for db in databases:
2170             # skip databases where the model won't be created
2171             if not router.allow_migrate_model(db, cls):
2172                 continue
2173             connection = connections[db]
2174             max_name_length = connection.ops.max_name_length()
2175             if max_name_length is None or connection.features.truncates_names:
2176                 continue
2177             else:
2178                 if allowed_len is None:
2179                     allowed_len = max_name_length
2180                     db_alias = db
2181                 elif max_name_length < allowed_len:
2182                     allowed_len = max_name_length
2183                     db_alias = db
2184 
2185         if allowed_len is None:
2186             return errors
2187 
2188         for f in cls._meta.local_fields:
2189             _, column_name = f.get_attname_column()
2190 
2191             # Check if auto-generated name for the field is too long
2192             # for the database.
2193             if (
2194                 f.db_column is None
2195                 and column_name is not None
2196                 and len(column_name) > allowed_len
2197             ):
2198                 errors.append(
2199                     checks.Error(
2200                         'Autogenerated column name too long for field "%s". '
2201                         'Maximum length is "%s" for database "%s".'
2202                         % (column_name, allowed_len, db_alias),
2203                         hint="Set the column name manually using 'db_column'.",
2204                         obj=cls,
2205                         id="models.E018",
2206                     )
2207                 )
2208 
2209         for f in cls._meta.local_many_to_many:
2210             # Skip nonexistent models.
2211             if isinstance(f.remote_field.through, str):
2212                 continue
2213 
2214             # Check if auto-generated name for the M2M field is too long
2215             # for the database.
2216             for m2m in f.remote_field.through._meta.local_fields:
2217                 _, rel_name = m2m.get_attname_column()
2218                 if (
2219                     m2m.db_column is None
2220                     and rel_name is not None
2221                     and len(rel_name) > allowed_len
2222                 ):
2223                     errors.append(
2224                         checks.Error(
2225                             "Autogenerated column name too long for M2M field "
2226                             '"%s". Maximum length is "%s" for database "%s".'
2227                             % (rel_name, allowed_len, db_alias),
2228                             hint=(
2229                                 "Use 'through' to create a separate model for "
2230                                 "M2M and then set column_name using 'db_column'."
2231                             ),
2232                             obj=cls,
2233                             id="models.E019",
2234                         )
2235                     )
2236 
2237         return errors
2238 
2239     @classmethod
2240     def _get_expr_references(cls, expr):
2241         if isinstance(expr, Q):
2242             for child in expr.children:
2243                 if isinstance(child, tuple):
2244                     lookup, value = child
2245                     yield tuple(lookup.split(LOOKUP_SEP))
2246                     yield from cls._get_expr_references(value)
2247                 else:
2248                     yield from cls._get_expr_references(child)
2249         elif isinstance(expr, F):
2250             yield tuple(expr.name.split(LOOKUP_SEP))
2251         elif hasattr(expr, "get_source_expressions"):
2252             for src_expr in expr.get_source_expressions():
2253                 yield from cls._get_expr_references(src_expr)
2254 
2255     @classmethod
2256     def _check_constraints(cls, databases):
2257         errors = []
2258         for db in databases:
2259             if not router.allow_migrate_model(db, cls):
2260                 continue
2261             connection = connections[db]
2262             if not (
2263                 connection.features.supports_table_check_constraints
2264                 or "supports_table_check_constraints" in cls._meta.required_db_features
2265             ) and any(
2266                 isinstance(constraint, CheckConstraint)
2267                 for constraint in cls._meta.constraints
2268             ):
2269                 errors.append(
2270                     checks.Warning(
2271                         "%s does not support check constraints."
2272                         % connection.display_name,
2273                         hint=(
2274                             "A constraint won't be created. Silence this "
2275                             "warning if you don't care about it."
2276                         ),
2277                         obj=cls,
2278                         id="models.W027",
2279                     )
2280                 )
2281             if not (
2282                 connection.features.supports_partial_indexes
2283                 or "supports_partial_indexes" in cls._meta.required_db_features
2284             ) and any(
2285                 isinstance(constraint, UniqueConstraint)
2286                 and constraint.condition is not None
2287                 for constraint in cls._meta.constraints
2288             ):
2289                 errors.append(
2290                     checks.Warning(
2291                         "%s does not support unique constraints with "
2292                         "conditions." % connection.display_name,
2293                         hint=(
2294                             "A constraint won't be created. Silence this "
2295                             "warning if you don't care about it."
2296                         ),
2297                         obj=cls,
2298                         id="models.W036",
2299                     )
2300                 )
2301             if not (
2302                 connection.features.supports_deferrable_unique_constraints
2303                 or "supports_deferrable_unique_constraints"
2304                 in cls._meta.required_db_features
2305             ) and any(
2306                 isinstance(constraint, UniqueConstraint)
2307                 and constraint.deferrable is not None
2308                 for constraint in cls._meta.constraints
2309             ):
2310                 errors.append(
2311                     checks.Warning(
2312                         "%s does not support deferrable unique constraints."
2313                         % connection.display_name,
2314                         hint=(
2315                             "A constraint won't be created. Silence this "
2316                             "warning if you don't care about it."
2317                         ),
2318                         obj=cls,
2319                         id="models.W038",
2320                     )
2321                 )
2322             if not (
2323                 connection.features.supports_covering_indexes
2324                 or "supports_covering_indexes" in cls._meta.required_db_features
2325             ) and any(
2326                 isinstance(constraint, UniqueConstraint) and constraint.include
2327                 for constraint in cls._meta.constraints
2328             ):
2329                 errors.append(
2330                     checks.Warning(
2331                         "%s does not support unique constraints with non-key "
2332                         "columns." % connection.display_name,
2333                         hint=(
2334                             "A constraint won't be created. Silence this "
2335                             "warning if you don't care about it."
2336                         ),
2337                         obj=cls,
2338                         id="models.W039",
2339                     )
2340                 )
2341             if not (
2342                 connection.features.supports_expression_indexes
2343                 or "supports_expression_indexes" in cls._meta.required_db_features
2344             ) and any(
2345                 isinstance(constraint, UniqueConstraint)
2346                 and constraint.contains_expressions
2347                 for constraint in cls._meta.constraints
2348             ):
2349                 errors.append(
2350                     checks.Warning(
2351                         "%s does not support unique constraints on "
2352                         "expressions." % connection.display_name,
2353                         hint=(
2354                             "A constraint won't be created. Silence this "
2355                             "warning if you don't care about it."
2356                         ),
2357                         obj=cls,
2358                         id="models.W044",
2359                     )
2360                 )
2361             fields = set(
2362                 chain.from_iterable(
2363                     (*constraint.fields, *constraint.include)
2364                     for constraint in cls._meta.constraints
2365                     if isinstance(constraint, UniqueConstraint)
2366                 )
2367             )
2368             references = set()
2369             for constraint in cls._meta.constraints:
2370                 if isinstance(constraint, UniqueConstraint):
2371                     if (
2372                         connection.features.supports_partial_indexes
2373                         or "supports_partial_indexes"
2374                         not in cls._meta.required_db_features
2375                     ) and isinstance(constraint.condition, Q):
2376                         references.update(
2377                             cls._get_expr_references(constraint.condition)
2378                         )
2379                     if (
2380                         connection.features.supports_expression_indexes
2381                         or "supports_expression_indexes"
2382                         not in cls._meta.required_db_features
2383                     ) and constraint.contains_expressions:
2384                         for expression in constraint.expressions:
2385                             references.update(cls._get_expr_references(expression))
2386                 elif isinstance(constraint, CheckConstraint):
2387                     if (
2388                         connection.features.supports_table_check_constraints
2389                         or "supports_table_check_constraints"
2390                         not in cls._meta.required_db_features
2391                     ):
2392                         if isinstance(constraint.check, Q):
2393                             references.update(
2394                                 cls._get_expr_references(constraint.check)
2395                             )
2396                         if any(
2397                             isinstance(expr, RawSQL)
2398                             for expr in constraint.check.flatten()
2399                         ):
2400                             errors.append(
2401                                 checks.Warning(
2402                                     f"Check constraint {constraint.name!r} contains "
2403                                     f"RawSQL() expression and won't be validated "
2404                                     f"during the model full_clean().",
2405                                     hint=(
2406                                         "Silence this warning if you don't care about "
2407                                         "it."
2408                                     ),
2409                                     obj=cls,
2410                                     id="models.W045",
2411                                 ),
2412                             )
2413             for field_name, *lookups in references:
2414                 # pk is an alias that won't be found by opts.get_field.
2415                 if field_name != "pk":
2416                     fields.add(field_name)
2417                 if not lookups:
2418                     # If it has no lookups it cannot result in a JOIN.
2419                     continue
2420                 try:
2421                     if field_name == "pk":
2422                         field = cls._meta.pk
2423                     else:
2424                         field = cls._meta.get_field(field_name)
2425                     if not field.is_relation or field.many_to_many or field.one_to_many:
2426                         continue
2427                 except FieldDoesNotExist:
2428                     continue
2429                 # JOIN must happen at the first lookup.
2430                 first_lookup = lookups[0]
2431                 if (
2432                     hasattr(field, "get_transform")
2433                     and hasattr(field, "get_lookup")
2434                     and field.get_transform(first_lookup) is None
2435                     and field.get_lookup(first_lookup) is None
2436                 ):
2437                     errors.append(
2438                         checks.Error(
2439                             "'constraints' refers to the joined field '%s'."
2440                             % LOOKUP_SEP.join([field_name] + lookups),
2441                             obj=cls,
2442                             id="models.E041",
2443                         )
2444                     )
2445             errors.extend(cls._check_local_fields(fields, "constraints"))
2446         return errors

</code><intended_behavior>Ensure construction of model indexes using `Index` instances from the `indexes` list without relying on `index_together`. Legacy handling of `index_together` should be migrated internally to use `Index` instances for backward compatibility.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             index_together = model_state.options.pop("index_together", None)
620             order_with_respect_to = model_state.options.pop(
621                 "order_with_respect_to", None
622             )
623             # Depend on the deletion of any possible proxy version of us
624             dependencies = [
625                 (app_label, model_name, None, False),
626             ]
627             # Depend on all bases
628             for base in model_state.bases:
629                 if isinstance(base, str) and "." in base:
630                     base_app_label, base_name = base.split(".", 1)
631                     dependencies.append((base_app_label, base_name, None, True))
632                     # Depend on the removal of base fields if the new model has
633                     # a field with the same name.
634                     old_base_model_state = self.from_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     new_base_model_state = self.to_state.models.get(
638                         (base_app_label, base_name)
639                     )
640                     if old_base_model_state and new_base_model_state:
641                         removed_base_fields = (
642                             set(old_base_model_state.fields)
643                             .difference(
644                                 new_base_model_state.fields,
645                             )
646                             .intersection(model_state.fields)
647                         )
648                         for removed_base_field in removed_base_fields:
649                             dependencies.append(
650                                 (base_app_label, base_name, removed_base_field, False)
651                             )
652             # Depend on the other end of the primary key if it's a relation
653             if primary_key_rel:
654                 dependencies.append(
655                     resolve_relation(
656                         primary_key_rel,
657                         app_label,
658                         model_name,
659                     )
660                     + (None, True)
661                 )
662             # Generate creation operation
663             self.add_operation(
664                 app_label,
665                 operations.CreateModel(
666                     name=model_state.name,
667                     fields=[
668                         d
669                         for d in model_state.fields.items()
670                         if d[0] not in related_fields
671                     ],
672                     options=model_state.options,
673                     bases=model_state.bases,
674                     managers=model_state.managers,
675                 ),
676                 dependencies=dependencies,
677                 beginning=True,
678             )
679 
680             # Don't add operations which modify the database for unmanaged models
681             if not model_state.options.get("managed", True):
682                 continue
683 
684             # Generate operations for each related field
685             for name, field in sorted(related_fields.items()):
686                 dependencies = self._get_dependencies_for_foreign_key(
687                     app_label,
688                     model_name,
689                     field,
690                     self.to_state,
691                 )
692                 # Depend on our own model being created
693                 dependencies.append((app_label, model_name, None, True))
694                 # Make operation
695                 self.add_operation(
696                     app_label,
697                     operations.AddField(
698                         model_name=model_name,
699                         name=name,
700                         field=field,
701                     ),
702                     dependencies=list(set(dependencies)),
703                 )
704             # Generate other opns
705             if order_with_respect_to:
706                 self.add_operation(
707                     app_label,
708                     operations.AlterOrderWithRespectTo(
709                         name=model_name,
710                         order_with_respect_to=order_with_respect_to,
711                     ),
712                     dependencies=[
713                         (app_label, model_name, order_with_respect_to, True),
714                         (app_label, model_name, None, True),
715                     ],
716                 )
717             related_dependencies = [
718                 (app_label, model_name, name, True) for name in sorted(related_fields)
719             ]
720             related_dependencies.append((app_label, model_name, None, True))
721             for index in indexes:
722                 self.add_operation(
723                     app_label,
724                     operations.AddIndex(
725                         model_name=model_name,
726                         index=index,
727                     ),
728                     dependencies=related_dependencies,
729                 )
730             for constraint in constraints:
731                 self.add_operation(
732                     app_label,
733                     operations.AddConstraint(
734                         model_name=model_name,
735                         constraint=constraint,
736                     ),
737                     dependencies=related_dependencies,
738                 )
739             if unique_together:
740                 self.add_operation(
741                     app_label,
742                     operations.AlterUniqueTogether(
743                         name=model_name,
744                         unique_together=unique_together,
745                     ),
746                     dependencies=related_dependencies,
747                 )
748             if index_together:
749                 self.add_operation(
750                     app_label,
751                     operations.AlterIndexTogether(
752                         name=model_name,
753                         index_together=index_together,
754                     ),
755                     dependencies=related_dependencies,
756                 )
757             # Fix relationships if the model changed from a proxy model to a
758             # concrete model.
759             relations = self.to_state.relations
760             if (app_label, model_name) in self.old_proxy_keys:
761                 for related_model_key, related_fields in relations[
762                     app_label, model_name
763                 ].items():
764                     related_model_state = self.to_state.models[related_model_key]
765                     for related_field_name, related_field in related_fields.items():
766                         self.add_operation(
767                             related_model_state.app_label,
768                             operations.AlterField(
769                                 model_name=related_model_state.name,
770                                 name=related_field_name,
771                                 field=related_field,
772                             ),
773                             dependencies=[(app_label, model_name, None, True)],
774                         )
775 
776     def generate_created_proxies(self):
777         """
778         Make CreateModel statements for proxy models. Use the same statements
779         as that way there's less code duplication, but for proxy models it's
780         safe to skip all the pointless field stuff and chuck out an operation.
781         """
782         added = self.new_proxy_keys - self.old_proxy_keys
783         for app_label, model_name in sorted(added):
784             model_state = self.to_state.models[app_label, model_name]
785             assert model_state.options.get("proxy")
786             # Depend on the deletion of any possible non-proxy version of us
787             dependencies = [
788                 (app_label, model_name, None, False),
789             ]
790             # Depend on all bases
791             for base in model_state.bases:
792                 if isinstance(base, str) and "." in base:
793                     base_app_label, base_name = base.split(".", 1)
794                     dependencies.append((base_app_label, base_name, None, True))
795             # Generate creation operation
796             self.add_operation(
797                 app_label,
798                 operations.CreateModel(
799                     name=model_state.name,
800                     fields=[],
801                     options=model_state.options,
802                     bases=model_state.bases,
803                     managers=model_state.managers,
804                 ),
805                 # Depend on the deletion of any possible non-proxy version of us
806                 dependencies=dependencies,
807             )
808 
809     def generate_deleted_models(self):
810         """
811         Find all deleted models (managed and unmanaged) and make delete
812         operations for them as well as separate operations to delete any
813         foreign key or M2M relationships (these are optimized later, if
814         possible).
815 
816         Also bring forward removal of any model options that refer to
817         collections of fields - the inverse of generate_created_models().
818         """
819         new_keys = self.new_model_keys | self.new_unmanaged_keys
820         deleted_models = self.old_model_keys - new_keys
821         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
822         all_deleted_models = chain(
823             sorted(deleted_models), sorted(deleted_unmanaged_models)
824         )
825         for app_label, model_name in all_deleted_models:
826             model_state = self.from_state.models[app_label, model_name]
827             # Gather related fields
828             related_fields = {}
829             for field_name, field in model_state.fields.items():
830                 if field.remote_field:
831                     if field.remote_field.model:
832                         related_fields[field_name] = field
833                     if getattr(field.remote_field, "through", None):
834                         related_fields[field_name] = field
835             # Generate option removal first
836             unique_together = model_state.options.pop("unique_together", None)
837             index_together = model_state.options.pop("index_together", None)
838             if unique_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterUniqueTogether(
842                         name=model_name,
843                         unique_together=None,
844                     ),
845                 )
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 remote_field_model,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     def generate_removed_altered_index_together(self):
1504         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1505 
1506     def _generate_altered_foo_together(self, operation):
1507         for (
1508             old_value,
1509             new_value,
1510             app_label,
1511             model_name,
1512             dependencies,
1513         ) in self._get_altered_foo_together_operations(operation.option_name):
1514             removal_value = new_value.intersection(old_value)
1515             if new_value != removal_value:
1516                 self.add_operation(
1517                     app_label,
1518                     operation(name=model_name, **{operation.option_name: new_value}),
1519                     dependencies=dependencies,
1520                 )
1521 
1522     def generate_altered_unique_together(self):
1523         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1524 
1525     def generate_altered_index_together(self):
1526         self._generate_altered_foo_together(operations.AlterIndexTogether)
1527 
1528     def generate_altered_db_table(self):
1529         models_to_check = self.kept_model_keys.union(
1530             self.kept_proxy_keys, self.kept_unmanaged_keys
1531         )
1532         for app_label, model_name in sorted(models_to_check):
1533             old_model_name = self.renamed_models.get(
1534                 (app_label, model_name), model_name
1535             )
1536             old_model_state = self.from_state.models[app_label, old_model_name]
1537             new_model_state = self.to_state.models[app_label, model_name]
1538             old_db_table_name = old_model_state.options.get("db_table")
1539             new_db_table_name = new_model_state.options.get("db_table")
1540             if old_db_table_name != new_db_table_name:
1541                 self.add_operation(
1542                     app_label,
1543                     operations.AlterModelTable(
1544                         name=model_name,
1545                         table=new_db_table_name,
1546                     ),
1547                 )
1548 
1549     def generate_altered_options(self):
1550         """
1551         Work out if any non-schema-affecting options have changed and make an
1552         operation to represent them in state changes (in case Python code in
1553         migrations needs them).
1554         """
1555         models_to_check = self.kept_model_keys.union(
1556             self.kept_proxy_keys,
1557             self.kept_unmanaged_keys,
1558             # unmanaged converted to managed
1559             self.old_unmanaged_keys & self.new_model_keys,
1560             # managed converted to unmanaged
1561             self.old_model_keys & self.new_unmanaged_keys,
1562         )
1563 
1564         for app_label, model_name in sorted(models_to_check):
1565             old_model_name = self.renamed_models.get(
1566                 (app_label, model_name), model_name
1567             )
1568             old_model_state = self.from_state.models[app_label, old_model_name]
1569             new_model_state = self.to_state.models[app_label, model_name]
1570             old_options = {
1571                 key: value
1572                 for key, value in old_model_state.options.items()
1573                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1574             }
1575             new_options = {
1576                 key: value
1577                 for key, value in new_model_state.options.items()
1578                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1579             }
1580             if old_options != new_options:
1581                 self.add_operation(
1582                     app_label,
1583                     operations.AlterModelOptions(
1584                         name=model_name,
1585                         options=new_options,
1586                     ),
1587                 )
1588 
1589     def generate_altered_order_with_respect_to(self):
1590         for app_label, model_name in sorted(self.kept_model_keys):
1591             old_model_name = self.renamed_models.get(
1592                 (app_label, model_name), model_name
1593             )
1594             old_model_state = self.from_state.models[app_label, old_model_name]
1595             new_model_state = self.to_state.models[app_label, model_name]
1596             if old_model_state.options.get(
1597                 "order_with_respect_to"
1598             ) != new_model_state.options.get("order_with_respect_to"):
1599                 # Make sure it comes second if we're adding
1600                 # (removal dependency is part of RemoveField)
1601                 dependencies = []
1602                 if new_model_state.options.get("order_with_respect_to"):
1603                     dependencies.append(
1604                         (
1605                             app_label,
1606                             model_name,
1607                             new_model_state.options["order_with_respect_to"],
1608                             True,
1609                         )
1610                     )
1611                 # Actually generate the operation
1612                 self.add_operation(
1613                     app_label,
1614                     operations.AlterOrderWithRespectTo(
1615                         name=model_name,
1616                         order_with_respect_to=new_model_state.options.get(
1617                             "order_with_respect_to"
1618                         ),
1619                     ),
1620                     dependencies=dependencies,
1621                 )
1622 
1623     def generate_altered_managers(self):
1624         for app_label, model_name in sorted(self.kept_model_keys):
1625             old_model_name = self.renamed_models.get(
1626                 (app_label, model_name), model_name
1627             )
1628             old_model_state = self.from_state.models[app_label, old_model_name]
1629             new_model_state = self.to_state.models[app_label, model_name]
1630             if old_model_state.managers != new_model_state.managers:
1631                 self.add_operation(
1632                     app_label,
1633                     operations.AlterModelManagers(
1634                         name=model_name,
1635                         managers=new_model_state.managers,
1636                     ),
1637                 )
1638 
1639     def arrange_for_graph(self, changes, graph, migration_name=None):
1640         """
1641         Take a result from changes() and a MigrationGraph, and fix the names
1642         and dependencies of the changes so they extend the graph from the leaf
1643         nodes for each app.
1644         """
1645         leaves = graph.leaf_nodes()
1646         name_map = {}
1647         for app_label, migrations in list(changes.items()):
1648             if not migrations:
1649                 continue
1650             # Find the app label's current leaf node
1651             app_leaf = None
1652             for leaf in leaves:
1653                 if leaf[0] == app_label:
1654                     app_leaf = leaf
1655                     break
1656             # Do they want an initial migration for this app?
1657             if app_leaf is None and not self.questioner.ask_initial(app_label):
1658                 # They don't.
1659                 for migration in migrations:
1660                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1661                 del changes[app_label]
1662                 continue
1663             # Work out the next number in the sequence
1664             if app_leaf is None:
1665                 next_number = 1
1666             else:
1667                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1668             # Name each migration
1669             for i, migration in enumerate(migrations):
1670                 if i == 0 and app_leaf:
1671                     migration.dependencies.append(app_leaf)
1672                 new_name_parts = ["%04i" % next_number]
1673                 if migration_name:
1674                     new_name_parts.append(migration_name)
1675                 elif i == 0 and not app_leaf:
1676                     new_name_parts.append("initial")
1677                 else:
1678                     new_name_parts.append(migration.suggest_name()[:100])
1679                 new_name = "_".join(new_name_parts)
1680                 name_map[(app_label, migration.name)] = (app_label, new_name)
1681                 next_number += 1
1682                 migration.name = new_name
1683         # Now fix dependencies
1684         for migrations in changes.values():
1685             for migration in migrations:
1686                 migration.dependencies = [
1687                     name_map.get(d, d) for d in migration.dependencies
1688                 ]
1689         return changes
1690 
1691     def _trim_to_apps(self, changes, app_labels):
1692         """
1693         Take changes from arrange_for_graph() and set of app labels, and return
1694         a modified set of changes which trims out as many migrations that are
1695         not in app_labels as possible. Note that some other migrations may
1696         still be present as they may be required dependencies.
1697         """
1698         # Gather other app dependencies in a first pass
1699         app_dependencies = {}
1700         for app_label, migrations in changes.items():
1701             for migration in migrations:
1702                 for dep_app_label, name in migration.dependencies:
1703                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1704         required_apps = set(app_labels)
1705         # Keep resolving till there's no change
1706         old_required_apps = None
1707         while old_required_apps != required_apps:
1708             old_required_apps = set(required_apps)
1709             required_apps.update(
1710                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1711             )
1712         # Remove all migrations that aren't needed
1713         for app_label in list(changes):
1714             if app_label not in required_apps:
1715                 del changes[app_label]
1716         return changes
1717 
1718     @classmethod
1719     def parse_number(cls, name):
1720         """
1721         Given a migration name, try to extract a number from the beginning of
1722         it. For a squashed migration such as '0001_squashed_0004', return the
1723         second number. If no number is found, return None.
1724         """
1725         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1726             return int(squashed_match[1])
1727         match = re.match(r"^\d+", name)
1728         if match:
1729             return int(match[0])
1730         return None

</code><intended_behavior>Code that identifies changes to `index_together` for generating migration operations should shift towards detecting changes in `indexes`, offering precise migration generation.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.migrations.utils import field_references, resolve_relation
5 from django.db.models.options import normalize_together
6 from django.utils.functional import cached_property
7 
8 from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField
9 
10 
11 def _check_for_duplicates(arg_name, objs):
12     used_vals = set()
13     for val in objs:
14         if val in used_vals:
15             raise ValueError(
16                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
17             )
18         used_vals.add(val)
19 
20 
21 class ModelOperation(Operation):
22     def __init__(self, name):
23         self.name = name
24 
25     @cached_property
26     def name_lower(self):
27         return self.name.lower()
28 
29     def references_model(self, name, app_label):
30         return name.lower() == self.name_lower
31 
32     def reduce(self, operation, app_label):
33         return super().reduce(operation, app_label) or self.can_reduce_through(
34             operation, app_label
35         )
36 
37     def can_reduce_through(self, operation, app_label):
38         return not operation.references_model(self.name, app_label)
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ["fields", "options", "managers"]
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates("fields", (name for name, _ in self.fields))
55         _check_for_duplicates(
56             "bases",
57             (
58                 base._meta.label_lower
59                 if hasattr(base, "_meta")
60                 else base.lower()
61                 if isinstance(base, str)
62                 else base
63                 for base in self.bases
64             ),
65         )
66         _check_for_duplicates("managers", (name for name, _ in self.managers))
67 
68     def deconstruct(self):
69         kwargs = {
70             "name": self.name,
71             "fields": self.fields,
72         }
73         if self.options:
74             kwargs["options"] = self.options
75         if self.bases and self.bases != (models.Model,):
76             kwargs["bases"] = self.bases
77         if self.managers and self.managers != [("objects", models.Manager())]:
78             kwargs["managers"] = self.managers
79         return (self.__class__.__qualname__, [], kwargs)
80 
81     def state_forwards(self, app_label, state):
82         state.add_model(
83             ModelState(
84                 app_label,
85                 self.name,
86                 list(self.fields),
87                 dict(self.options),
88                 tuple(self.bases),
89                 list(self.managers),
90             )
91         )
92 
93     def database_forwards(self, app_label, schema_editor, from_state, to_state):
94         model = to_state.apps.get_model(app_label, self.name)
95         if self.allow_migrate_model(schema_editor.connection.alias, model):
96             schema_editor.create_model(model)
97 
98     def database_backwards(self, app_label, schema_editor, from_state, to_state):
99         model = from_state.apps.get_model(app_label, self.name)
100         if self.allow_migrate_model(schema_editor.connection.alias, model):
101             schema_editor.delete_model(model)
102 
103     def describe(self):
104         return "Create %smodel %s" % (
105             "proxy " if self.options.get("proxy", False) else "",
106             self.name,
107         )
108 
109     @property
110     def migration_name_fragment(self):
111         return self.name_lower
112 
113     def references_model(self, name, app_label):
114         name_lower = name.lower()
115         if name_lower == self.name_lower:
116             return True
117 
118         # Check we didn't inherit from the model
119         reference_model_tuple = (app_label, name_lower)
120         for base in self.bases:
121             if (
122                 base is not models.Model
123                 and isinstance(base, (models.base.ModelBase, str))
124                 and resolve_relation(base, app_label) == reference_model_tuple
125             ):
126                 return True
127 
128         # Check we have no FKs/M2Ms with it
129         for _name, field in self.fields:
130             if field_references(
131                 (app_label, self.name_lower), field, reference_model_tuple
132             ):
133                 return True
134         return False
135 
136     def reduce(self, operation, app_label):
137         if (
138             isinstance(operation, DeleteModel)
139             and self.name_lower == operation.name_lower
140             and not self.options.get("proxy", False)
141         ):
142             return []
143         elif (
144             isinstance(operation, RenameModel)
145             and self.name_lower == operation.old_name_lower
146         ):
147             return [
148                 CreateModel(
149                     operation.new_name,
150                     fields=self.fields,
151                     options=self.options,
152                     bases=self.bases,
153                     managers=self.managers,
154                 ),
155             ]
156         elif (
157             isinstance(operation, AlterModelOptions)
158             and self.name_lower == operation.name_lower
159         ):
160             options = {**self.options, **operation.options}
161             for key in operation.ALTER_OPTION_KEYS:
162                 if key not in operation.options:
163                     options.pop(key, None)
164             return [
165                 CreateModel(
166                     self.name,
167                     fields=self.fields,
168                     options=options,
169                     bases=self.bases,
170                     managers=self.managers,
171                 ),
172             ]
173         elif (
174             isinstance(operation, AlterModelManagers)
175             and self.name_lower == operation.name_lower
176         ):
177             return [
178                 CreateModel(
179                     self.name,
180                     fields=self.fields,
181                     options=self.options,
182                     bases=self.bases,
183                     managers=operation.managers,
184                 ),
185             ]
186         elif (
187             isinstance(operation, AlterTogetherOptionOperation)
188             and self.name_lower == operation.name_lower
189         ):
190             return [
191                 CreateModel(
192                     self.name,
193                     fields=self.fields,
194                     options={
195                         **self.options,
196                         **{operation.option_name: operation.option_value},
197                     },
198                     bases=self.bases,
199                     managers=self.managers,
200                 ),
201             ]
202         elif (
203             isinstance(operation, AlterOrderWithRespectTo)
204             and self.name_lower == operation.name_lower
205         ):
206             return [
207                 CreateModel(
208                     self.name,
209                     fields=self.fields,
210                     options={
211                         **self.options,
212                         "order_with_respect_to": operation.order_with_respect_to,
213                     },
214                     bases=self.bases,
215                     managers=self.managers,
216                 ),
217             ]
218         elif (
219             isinstance(operation, FieldOperation)
220             and self.name_lower == operation.model_name_lower
221         ):
222             if isinstance(operation, AddField):
223                 return [
224                     CreateModel(
225                         self.name,
226                         fields=self.fields + [(operation.name, operation.field)],
227                         options=self.options,
228                         bases=self.bases,
229                         managers=self.managers,
230                     ),
231                 ]
232             elif isinstance(operation, AlterField):
233                 return [
234                     CreateModel(
235                         self.name,
236                         fields=[
237                             (n, operation.field if n == operation.name else v)
238                             for n, v in self.fields
239                         ],
240                         options=self.options,
241                         bases=self.bases,
242                         managers=self.managers,
243                     ),
244                 ]
245             elif isinstance(operation, RemoveField):
246                 options = self.options.copy()
247                 for option_name in ("unique_together", "index_together"):
248                     option = options.pop(option_name, None)
249                     if option:
250                         option = set(
251                             filter(
252                                 bool,
253                                 (
254                                     tuple(
255                                         f for f in fields if f != operation.name_lower
256                                     )
257                                     for fields in option
258                                 ),
259                             )
260                         )
261                         if option:
262                             options[option_name] = option
263                 order_with_respect_to = options.get("order_with_respect_to")
264                 if order_with_respect_to == operation.name_lower:
265                     del options["order_with_respect_to"]
266                 return [
267                     CreateModel(
268                         self.name,
269                         fields=[
270                             (n, v)
271                             for n, v in self.fields
272                             if n.lower() != operation.name_lower
273                         ],
274                         options=options,
275                         bases=self.bases,
276                         managers=self.managers,
277                     ),
278                 ]
279             elif isinstance(operation, RenameField):
280                 options = self.options.copy()
281                 for option_name in ("unique_together", "index_together"):
282                     option = options.get(option_name)
283                     if option:
284                         options[option_name] = {
285                             tuple(
286                                 operation.new_name if f == operation.old_name else f
287                                 for f in fields
288                             )
289                             for fields in option
290                         }
291                 order_with_respect_to = options.get("order_with_respect_to")
292                 if order_with_respect_to == operation.old_name:
293                     options["order_with_respect_to"] = operation.new_name
294                 return [
295                     CreateModel(
296                         self.name,
297                         fields=[
298                             (operation.new_name if n == operation.old_name else n, v)
299                             for n, v in self.fields
300                         ],
301                         options=options,
302                         bases=self.bases,
303                         managers=self.managers,
304                     ),
305                 ]
306         return super().reduce(operation, app_label)
307 
308 
309 class DeleteModel(ModelOperation):
310     """Drop a model's table."""
311 
312     def deconstruct(self):
313         kwargs = {
314             "name": self.name,
315         }
316         return (self.__class__.__qualname__, [], kwargs)
317 
318     def state_forwards(self, app_label, state):
319         state.remove_model(app_label, self.name_lower)
320 
321     def database_forwards(self, app_label, schema_editor, from_state, to_state):
322         model = from_state.apps.get_model(app_label, self.name)
323         if self.allow_migrate_model(schema_editor.connection.alias, model):
324             schema_editor.delete_model(model)
325 
326     def database_backwards(self, app_label, schema_editor, from_state, to_state):
327         model = to_state.apps.get_model(app_label, self.name)
328         if self.allow_migrate_model(schema_editor.connection.alias, model):
329             schema_editor.create_model(model)
330 
331     def references_model(self, name, app_label):
332         # The deleted model could be referencing the specified model through
333         # related fields.
334         return True
335 
336     def describe(self):
337         return "Delete model %s" % self.name
338 
339     @property
340     def migration_name_fragment(self):
341         return "delete_%s" % self.name_lower
342 
343 
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             old_db_table = old_model._meta.db_table
375             new_db_table = new_model._meta.db_table
376             # Don't alter when a table name is not changed.
377             if old_db_table == new_db_table:
378                 return
379             # Move the main table
380             schema_editor.alter_db_table(new_model, old_db_table, new_db_table)
381             # Alter the fields pointing to us
382             for related_object in old_model._meta.related_objects:
383                 if related_object.related_model == old_model:
384                     model = new_model
385                     related_key = (app_label, self.new_name_lower)
386                 else:
387                     model = related_object.related_model
388                     related_key = (
389                         related_object.related_model._meta.app_label,
390                         related_object.related_model._meta.model_name,
391                     )
392                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
393                     related_object.field.name
394                 )
395                 schema_editor.alter_field(
396                     model,
397                     related_object.field,
398                     to_field,
399                 )
400             # Rename M2M fields whose name is based on this model's name.
401             fields = zip(
402                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
403             )
404             for (old_field, new_field) in fields:
405                 # Skip self-referential fields as these are renamed above.
406                 if (
407                     new_field.model == new_field.related_model
408                     or not new_field.remote_field.through._meta.auto_created
409                 ):
410                     continue
411                 # Rename the M2M table that's based on this model's name.
412                 old_m2m_model = old_field.remote_field.through
413                 new_m2m_model = new_field.remote_field.through
414                 schema_editor.alter_db_table(
415                     new_m2m_model,
416                     old_m2m_model._meta.db_table,
417                     new_m2m_model._meta.db_table,
418                 )
419                 # Rename the column in the M2M table that's based on this
420                 # model's name.
421                 schema_editor.alter_field(
422                     new_m2m_model,
423                     old_m2m_model._meta.get_field(old_model._meta.model_name),
424                     new_m2m_model._meta.get_field(new_model._meta.model_name),
425                 )
426 
427     def database_backwards(self, app_label, schema_editor, from_state, to_state):
428         self.new_name_lower, self.old_name_lower = (
429             self.old_name_lower,
430             self.new_name_lower,
431         )
432         self.new_name, self.old_name = self.old_name, self.new_name
433 
434         self.database_forwards(app_label, schema_editor, from_state, to_state)
435 
436         self.new_name_lower, self.old_name_lower = (
437             self.old_name_lower,
438             self.new_name_lower,
439         )
440         self.new_name, self.old_name = self.old_name, self.new_name
441 
442     def references_model(self, name, app_label):
443         return (
444             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
445         )
446 
447     def describe(self):
448         return "Rename model %s to %s" % (self.old_name, self.new_name)
449 
450     @property
451     def migration_name_fragment(self):
452         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
453 
454     def reduce(self, operation, app_label):
455         if (
456             isinstance(operation, RenameModel)
457             and self.new_name_lower == operation.old_name_lower
458         ):
459             return [
460                 RenameModel(
461                     self.old_name,
462                     operation.new_name,
463                 ),
464             ]
465         # Skip `ModelOperation.reduce` as we want to run `references_model`
466         # against self.new_name.
467         return super(ModelOperation, self).reduce(
468             operation, app_label
469         ) or not operation.references_model(self.new_name, app_label)
470 
471 
472 class ModelOptionOperation(ModelOperation):
473     def reduce(self, operation, app_label):
474         if (
475             isinstance(operation, (self.__class__, DeleteModel))
476             and self.name_lower == operation.name_lower
477         ):
478             return [operation]
479         return super().reduce(operation, app_label)
480 
481 
482 class AlterModelTable(ModelOptionOperation):
483     """Rename a model's table."""
484 
485     def __init__(self, name, table):
486         self.table = table
487         super().__init__(name)
488 
489     def deconstruct(self):
490         kwargs = {
491             "name": self.name,
492             "table": self.table,
493         }
494         return (self.__class__.__qualname__, [], kwargs)
495 
496     def state_forwards(self, app_label, state):
497         state.alter_model_options(app_label, self.name_lower, {"db_table": self.table})
498 
499     def database_forwards(self, app_label, schema_editor, from_state, to_state):
500         new_model = to_state.apps.get_model(app_label, self.name)
501         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
502             old_model = from_state.apps.get_model(app_label, self.name)
503             schema_editor.alter_db_table(
504                 new_model,
505                 old_model._meta.db_table,
506                 new_model._meta.db_table,
507             )
508             # Rename M2M fields whose name is based on this model's db_table
509             for (old_field, new_field) in zip(
510                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
511             ):
512                 if new_field.remote_field.through._meta.auto_created:
513                     schema_editor.alter_db_table(
514                         new_field.remote_field.through,
515                         old_field.remote_field.through._meta.db_table,
516                         new_field.remote_field.through._meta.db_table,
517                     )
518 
519     def database_backwards(self, app_label, schema_editor, from_state, to_state):
520         return self.database_forwards(app_label, schema_editor, from_state, to_state)
521 
522     def describe(self):
523         return "Rename table for %s to %s" % (
524             self.name,
525             self.table if self.table is not None else "(default)",
526         )
527 
528     @property
529     def migration_name_fragment(self):
530         return "alter_%s_table" % self.name_lower
531 
532 
533 class AlterTogetherOptionOperation(ModelOptionOperation):
534     option_name = None
535 
536     def __init__(self, name, option_value):
537         if option_value:
538             option_value = set(normalize_together(option_value))
539         setattr(self, self.option_name, option_value)
540         super().__init__(name)
541 
542     @cached_property
543     def option_value(self):
544         return getattr(self, self.option_name)
545 
546     def deconstruct(self):
547         kwargs = {
548             "name": self.name,
549             self.option_name: self.option_value,
550         }
551         return (self.__class__.__qualname__, [], kwargs)
552 
553     def state_forwards(self, app_label, state):
554         state.alter_model_options(
555             app_label,
556             self.name_lower,
557             {self.option_name: self.option_value},
558         )
559 
560     def database_forwards(self, app_label, schema_editor, from_state, to_state):
561         new_model = to_state.apps.get_model(app_label, self.name)
562         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
563             old_model = from_state.apps.get_model(app_label, self.name)
564             alter_together = getattr(schema_editor, "alter_%s" % self.option_name)
565             alter_together(
566                 new_model,
567                 getattr(old_model._meta, self.option_name, set()),
568                 getattr(new_model._meta, self.option_name, set()),
569             )
570 
571     def database_backwards(self, app_label, schema_editor, from_state, to_state):
572         return self.database_forwards(app_label, schema_editor, from_state, to_state)
573 
574     def references_field(self, model_name, name, app_label):
575         return self.references_model(model_name, app_label) and (
576             not self.option_value
577             or any((name in fields) for fields in self.option_value)
578         )
579 
580     def describe(self):
581         return "Alter %s for %s (%s constraint(s))" % (
582             self.option_name,
583             self.name,
584             len(self.option_value or ""),
585         )
586 
587     @property
588     def migration_name_fragment(self):
589         return "alter_%s_%s" % (self.name_lower, self.option_name)
590 
591     def can_reduce_through(self, operation, app_label):
592         return super().can_reduce_through(operation, app_label) or (
593             isinstance(operation, AlterTogetherOptionOperation)
594             and type(operation) is not type(self)
595         )
596 
597 
598 class AlterUniqueTogether(AlterTogetherOptionOperation):
599     """
600     Change the value of unique_together to the target one.
601     Input value of unique_together must be a set of tuples.
602     """
603 
604     option_name = "unique_together"
605 
606     def __init__(self, name, unique_together):
607         super().__init__(name, unique_together)
608 
609 
610 class AlterIndexTogether(AlterTogetherOptionOperation):
611     """
612     Change the value of index_together to the target one.
613     Input value of index_together must be a set of tuples.
614     """
615 
616     option_name = "index_together"
617 
618     def __init__(self, name, index_together):
619         super().__init__(name, index_together)
620 
621 
622 class AlterOrderWithRespectTo(ModelOptionOperation):
623     """Represent a change with the order_with_respect_to option."""
624 
625     option_name = "order_with_respect_to"
626 
627     def __init__(self, name, order_with_respect_to):
628         self.order_with_respect_to = order_with_respect_to
629         super().__init__(name)
630 
631     def deconstruct(self):
632         kwargs = {
633             "name": self.name,
634             "order_with_respect_to": self.order_with_respect_to,
635         }
636         return (self.__class__.__qualname__, [], kwargs)
637 
638     def state_forwards(self, app_label, state):
639         state.alter_model_options(
640             app_label,
641             self.name_lower,
642             {self.option_name: self.order_with_respect_to},
643         )
644 
645     def database_forwards(self, app_label, schema_editor, from_state, to_state):
646         to_model = to_state.apps.get_model(app_label, self.name)
647         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
648             from_model = from_state.apps.get_model(app_label, self.name)
649             # Remove a field if we need to
650             if (
651                 from_model._meta.order_with_respect_to
652                 and not to_model._meta.order_with_respect_to
653             ):
654                 schema_editor.remove_field(
655                     from_model, from_model._meta.get_field("_order")
656                 )
657             # Add a field if we need to (altering the column is untouched as
658             # it's likely a rename)
659             elif (
660                 to_model._meta.order_with_respect_to
661                 and not from_model._meta.order_with_respect_to
662             ):
663                 field = to_model._meta.get_field("_order")
664                 if not field.has_default():
665                     field.default = 0
666                 schema_editor.add_field(
667                     from_model,
668                     field,
669                 )
670 
671     def database_backwards(self, app_label, schema_editor, from_state, to_state):
672         self.database_forwards(app_label, schema_editor, from_state, to_state)
673 
674     def references_field(self, model_name, name, app_label):
675         return self.references_model(model_name, app_label) and (
676             self.order_with_respect_to is None or name == self.order_with_respect_to
677         )
678 
679     def describe(self):
680         return "Set order_with_respect_to on %s to %s" % (
681             self.name,
682             self.order_with_respect_to,
683         )
684 
685     @property
686     def migration_name_fragment(self):
687         return "alter_%s_order_with_respect_to" % self.name_lower
688 
689 
690 class AlterModelOptions(ModelOptionOperation):
691     """
692     Set new model options that don't directly affect the database schema
693     (like verbose_name, permissions, ordering). Python code in migrations
694     may still need them.
695     """
696 
697     # Model options we want to compare and preserve in an AlterModelOptions op
698     ALTER_OPTION_KEYS = [
699         "base_manager_name",
700         "default_manager_name",
701         "default_related_name",
702         "get_latest_by",
703         "managed",
704         "ordering",
705         "permissions",
706         "default_permissions",
707         "select_on_save",
708         "verbose_name",
709         "verbose_name_plural",
710     ]
711 
712     def __init__(self, name, options):
713         self.options = options
714         super().__init__(name)
715 
716     def deconstruct(self):
717         kwargs = {
718             "name": self.name,
719             "options": self.options,
720         }
721         return (self.__class__.__qualname__, [], kwargs)
722 
723     def state_forwards(self, app_label, state):
724         state.alter_model_options(
725             app_label,
726             self.name_lower,
727             self.options,
728             self.ALTER_OPTION_KEYS,
729         )
730 
731     def database_forwards(self, app_label, schema_editor, from_state, to_state):
732         pass
733 
734     def database_backwards(self, app_label, schema_editor, from_state, to_state):
735         pass
736 
737     def describe(self):
738         return "Change Meta options on %s" % self.name
739 
740     @property
741     def migration_name_fragment(self):
742         return "alter_%s_options" % self.name_lower
743 
744 
745 class AlterModelManagers(ModelOptionOperation):
746     """Alter the model's managers."""
747 
748     serialization_expand_args = ["managers"]
749 
750     def __init__(self, name, managers):
751         self.managers = managers
752         super().__init__(name)
753 
754     def deconstruct(self):
755         return (self.__class__.__qualname__, [self.name, self.managers], {})
756 
757     def state_forwards(self, app_label, state):
758         state.alter_model_managers(app_label, self.name_lower, self.managers)
759 
760     def database_forwards(self, app_label, schema_editor, from_state, to_state):
761         pass
762 
763     def database_backwards(self, app_label, schema_editor, from_state, to_state):
764         pass
765 
766     def describe(self):
767         return "Change managers on %s" % self.name
768 
769     @property
770     def migration_name_fragment(self):
771         return "alter_%s_managers" % self.name_lower
772 
773 
774 class IndexOperation(Operation):
775     option_name = "indexes"
776 
777     @cached_property
778     def model_name_lower(self):
779         return self.model_name.lower()
780 
781 
782 class AddIndex(IndexOperation):
783     """Add an index on a model."""
784 
785     def __init__(self, model_name, index):
786         self.model_name = model_name
787         if not index.name:
788             raise ValueError(
789                 "Indexes passed to AddIndex operations require a name "
790                 "argument. %r doesn't have one." % index
791             )
792         self.index = index
793 
794     def state_forwards(self, app_label, state):
795         state.add_index(app_label, self.model_name_lower, self.index)
796 
797     def database_forwards(self, app_label, schema_editor, from_state, to_state):
798         model = to_state.apps.get_model(app_label, self.model_name)
799         if self.allow_migrate_model(schema_editor.connection.alias, model):
800             schema_editor.add_index(model, self.index)
801 
802     def database_backwards(self, app_label, schema_editor, from_state, to_state):
803         model = from_state.apps.get_model(app_label, self.model_name)
804         if self.allow_migrate_model(schema_editor.connection.alias, model):
805             schema_editor.remove_index(model, self.index)
806 
807     def deconstruct(self):
808         kwargs = {
809             "model_name": self.model_name,
810             "index": self.index,
811         }
812         return (
813             self.__class__.__qualname__,
814             [],
815             kwargs,
816         )
817 
818     def describe(self):
819         if self.index.expressions:
820             return "Create index %s on %s on model %s" % (
821                 self.index.name,
822                 ", ".join([str(expression) for expression in self.index.expressions]),
823                 self.model_name,
824             )
825         return "Create index %s on field(s) %s of model %s" % (
826             self.index.name,
827             ", ".join(self.index.fields),
828             self.model_name,
829         )
830 
831     @property
832     def migration_name_fragment(self):
833         return "%s_%s" % (self.model_name_lower, self.index.name.lower())
834 
835 
836 class RemoveIndex(IndexOperation):
837     """Remove an index from a model."""
838 
839     def __init__(self, model_name, name):
840         self.model_name = model_name
841         self.name = name
842 
843     def state_forwards(self, app_label, state):
844         state.remove_index(app_label, self.model_name_lower, self.name)
845 
846     def database_forwards(self, app_label, schema_editor, from_state, to_state):
847         model = from_state.apps.get_model(app_label, self.model_name)
848         if self.allow_migrate_model(schema_editor.connection.alias, model):
849             from_model_state = from_state.models[app_label, self.model_name_lower]
850             index = from_model_state.get_index_by_name(self.name)
851             schema_editor.remove_index(model, index)
852 
853     def database_backwards(self, app_label, schema_editor, from_state, to_state):
854         model = to_state.apps.get_model(app_label, self.model_name)
855         if self.allow_migrate_model(schema_editor.connection.alias, model):
856             to_model_state = to_state.models[app_label, self.model_name_lower]
857             index = to_model_state.get_index_by_name(self.name)
858             schema_editor.add_index(model, index)
859 
860     def deconstruct(self):
861         kwargs = {
862             "model_name": self.model_name,
863             "name": self.name,
864         }
865         return (
866             self.__class__.__qualname__,
867             [],
868             kwargs,
869         )
870 
871     def describe(self):
872         return "Remove index %s from %s" % (self.name, self.model_name)
873 
874     @property
875     def migration_name_fragment(self):
876         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())
877 
878 
879 class RenameIndex(IndexOperation):
880     """Rename an index."""
881 
882     def __init__(self, model_name, new_name, old_name=None, old_fields=None):
883         if not old_name and not old_fields:
884             raise ValueError(
885                 "RenameIndex requires one of old_name and old_fields arguments to be "
886                 "set."
887             )
888         if old_name and old_fields:
889             raise ValueError(
890                 "RenameIndex.old_name and old_fields are mutually exclusive."
891             )
892         self.model_name = model_name
893         self.new_name = new_name
894         self.old_name = old_name
895         self.old_fields = old_fields
896 
897     @cached_property
898     def old_name_lower(self):
899         return self.old_name.lower()
900 
901     @cached_property
902     def new_name_lower(self):
903         return self.new_name.lower()
904 
905     def deconstruct(self):
906         kwargs = {
907             "model_name": self.model_name,
908             "new_name": self.new_name,
909         }
910         if self.old_name:
911             kwargs["old_name"] = self.old_name
912         if self.old_fields:
913             kwargs["old_fields"] = self.old_fields
914         return (self.__class__.__qualname__, [], kwargs)
915 
916     def state_forwards(self, app_label, state):
917         if self.old_fields:
918             state.add_index(
919                 app_label,
920                 self.model_name_lower,
921                 models.Index(fields=self.old_fields, name=self.new_name),
922             )
923             state.remove_model_options(
924                 app_label,
925                 self.model_name_lower,
926                 AlterIndexTogether.option_name,
927                 self.old_fields,
928             )
929         else:
930             state.rename_index(
931                 app_label, self.model_name_lower, self.old_name, self.new_name
932             )
933 
934     def database_forwards(self, app_label, schema_editor, from_state, to_state):
935         model = to_state.apps.get_model(app_label, self.model_name)
936         if not self.allow_migrate_model(schema_editor.connection.alias, model):
937             return
938 
939         if self.old_fields:
940             from_model = from_state.apps.get_model(app_label, self.model_name)
941             columns = [
942                 from_model._meta.get_field(field).column for field in self.old_fields
943             ]
944             matching_index_name = schema_editor._constraint_names(
945                 from_model, column_names=columns, index=True
946             )
947             if len(matching_index_name) != 1:
948                 raise ValueError(
949                     "Found wrong number (%s) of indexes for %s(%s)."
950                     % (
951                         len(matching_index_name),
952                         from_model._meta.db_table,
953                         ", ".join(columns),
954                     )
955                 )
956             old_index = models.Index(
957                 fields=self.old_fields,
958                 name=matching_index_name[0],
959             )
960         else:
961             from_model_state = from_state.models[app_label, self.model_name_lower]
962             old_index = from_model_state.get_index_by_name(self.old_name)
963         # Don't alter when the index name is not changed.
964         if old_index.name == self.new_name:
965             return
966 
967         to_model_state = to_state.models[app_label, self.model_name_lower]
968         new_index = to_model_state.get_index_by_name(self.new_name)
969         schema_editor.rename_index(model, old_index, new_index)
970 
971     def database_backwards(self, app_label, schema_editor, from_state, to_state):
972         if self.old_fields:
973             # Backward operation with unnamed index is a no-op.
974             return
975 
976         self.new_name_lower, self.old_name_lower = (
977             self.old_name_lower,
978             self.new_name_lower,
979         )
980         self.new_name, self.old_name = self.old_name, self.new_name
981 
982         self.database_forwards(app_label, schema_editor, from_state, to_state)
983 
984         self.new_name_lower, self.old_name_lower = (
985             self.old_name_lower,
986             self.new_name_lower,
987         )
988         self.new_name, self.old_name = self.old_name, self.new_name
989 
990     def describe(self):
991         if self.old_name:
992             return (
993                 f"Rename index {self.old_name} on {self.model_name} to {self.new_name}"
994             )
995         return (
996             f"Rename unnamed index for {self.old_fields} on {self.model_name} to "
997             f"{self.new_name}"
998         )
999 
1000     @property
1001     def migration_name_fragment(self):
1002         if self.old_name:
1003             return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
1004         return "rename_%s_%s_%s" % (
1005             self.model_name_lower,
1006             "_".join(self.old_fields),
1007             self.new_name_lower,
1008         )
1009 
1010     def reduce(self, operation, app_label):
1011         if (
1012             isinstance(operation, RenameIndex)
1013             and self.model_name_lower == operation.model_name_lower
1014             and operation.old_name
1015             and self.new_name_lower == operation.old_name_lower
1016         ):
1017             return [
1018                 RenameIndex(
1019                     self.model_name,
1020                     new_name=operation.new_name,
1021                     old_name=self.old_name,
1022                     old_fields=self.old_fields,
1023                 )
1024             ]
1025         return super().reduce(operation, app_label)
1026 
1027 
1028 class AddConstraint(IndexOperation):
1029     option_name = "constraints"
1030 
1031     def __init__(self, model_name, constraint):
1032         self.model_name = model_name
1033         self.constraint = constraint
1034 
1035     def state_forwards(self, app_label, state):
1036         state.add_constraint(app_label, self.model_name_lower, self.constraint)
1037 
1038     def database_forwards(self, app_label, schema_editor, from_state, to_state):
1039         model = to_state.apps.get_model(app_label, self.model_name)
1040         if self.allow_migrate_model(schema_editor.connection.alias, model):
1041             schema_editor.add_constraint(model, self.constraint)
1042 
1043     def database_backwards(self, app_label, schema_editor, from_state, to_state):
1044         model = to_state.apps.get_model(app_label, self.model_name)
1045         if self.allow_migrate_model(schema_editor.connection.alias, model):
1046             schema_editor.remove_constraint(model, self.constraint)
1047 
1048     def deconstruct(self):
1049         return (
1050             self.__class__.__name__,
1051             [],
1052             {
1053                 "model_name": self.model_name,
1054                 "constraint": self.constraint,
1055             },
1056         )
1057 
1058     def describe(self):
1059         return "Create constraint %s on model %s" % (
1060             self.constraint.name,
1061             self.model_name,
1062         )
1063 
1064     @property
1065     def migration_name_fragment(self):
1066         return "%s_%s" % (self.model_name_lower, self.constraint.name.lower())
1067 
1068 
1069 class RemoveConstraint(IndexOperation):
1070     option_name = "constraints"
1071 
1072     def __init__(self, model_name, name):
1073         self.model_name = model_name
1074         self.name = name
1075 
1076     def state_forwards(self, app_label, state):
1077         state.remove_constraint(app_label, self.model_name_lower, self.name)
1078 
1079     def database_forwards(self, app_label, schema_editor, from_state, to_state):
1080         model = to_state.apps.get_model(app_label, self.model_name)
1081         if self.allow_migrate_model(schema_editor.connection.alias, model):
1082             from_model_state = from_state.models[app_label, self.model_name_lower]
1083             constraint = from_model_state.get_constraint_by_name(self.name)
1084             schema_editor.remove_constraint(model, constraint)
1085 
1086     def database_backwards(self, app_label, schema_editor, from_state, to_state):
1087         model = to_state.apps.get_model(app_label, self.model_name)
1088         if self.allow_migrate_model(schema_editor.connection.alias, model):
1089             to_model_state = to_state.models[app_label, self.model_name_lower]
1090             constraint = to_model_state.get_constraint_by_name(self.name)
1091             schema_editor.add_constraint(model, constraint)
1092 
1093     def deconstruct(self):
1094         return (
1095             self.__class__.__name__,
1096             [],
1097             {
1098                 "model_name": self.model_name,
1099                 "name": self.name,
1100             },
1101         )
1102 
1103     def describe(self):
1104         return "Remove constraint %s from model %s" % (self.name, self.model_name)
1105 
1106     @property
1107     def migration_name_fragment(self):
1108         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())

</code><intended_behavior>Support full operations for adding, removing, or altering indexes using `Index` instances, ensuring migrations are accurately generated and applied.</intended_behavior>]
2025-10-15 06:07:53.790 | INFO     | Search completed. Bug locations: [<file>django/db/models/options.py</file>
<class>Options</class>
<method>None</method>
<code>
83 class Options:
84     FORWARD_PROPERTIES = {
85         "fields",
86         "many_to_many",
87         "concrete_fields",
88         "local_concrete_fields",
89         "_forward_fields_map",
90         "managers",
91         "managers_map",
92         "base_manager",
93         "default_manager",
94     }
95     REVERSE_PROPERTIES = {"related_objects", "fields_map", "_relation_tree"}
96 
97     default_apps = apps
98 
99     def __init__(self, meta, app_label=None):
100         self._get_fields_cache = {}
101         self.local_fields = []
102         self.local_many_to_many = []
103         self.private_fields = []
104         self.local_managers = []
105         self.base_manager_name = None
106         self.default_manager_name = None
107         self.model_name = None
108         self.verbose_name = None
109         self.verbose_name_plural = None
110         self.db_table = ""
111         self.ordering = []
112         self._ordering_clash = False
113         self.indexes = []
114         self.constraints = []
115         self.unique_together = []
116         self.index_together = []
117         self.select_on_save = False
118         self.default_permissions = ("add", "change", "delete", "view")
119         self.permissions = []
120         self.object_name = None
121         self.app_label = app_label
122         self.get_latest_by = None
123         self.order_with_respect_to = None
124         self.db_tablespace = settings.DEFAULT_TABLESPACE
125         self.required_db_features = []
126         self.required_db_vendor = None
127         self.meta = meta
128         self.pk = None
129         self.auto_field = None
130         self.abstract = False
131         self.managed = True
132         self.proxy = False
133         # For any class that is a proxy (including automatically created
134         # classes for deferred object loading), proxy_for_model tells us
135         # which class this model is proxying. Note that proxy_for_model
136         # can create a chain of proxy models. For non-proxy models, the
137         # variable is always None.
138         self.proxy_for_model = None
139         # For any non-abstract class, the concrete class is the model
140         # in the end of the proxy_for_model chain. In particular, for
141         # concrete models, the concrete_model is always the class itself.
142         self.concrete_model = None
143         self.swappable = None
144         self.parents = {}
145         self.auto_created = False
146 
147         # List of all lookups defined in ForeignKey 'limit_choices_to' options
148         # from *other* models. Needed for some admin checks. Internal use only.
149         self.related_fkey_lookups = []
150 
151         # A custom app registry to use, if you're making a separate model set.
152         self.apps = self.default_apps
153 
154         self.default_related_name = None
155 
156     @property
157     def label(self):
158         return "%s.%s" % (self.app_label, self.object_name)
159 
160     @property
161     def label_lower(self):
162         return "%s.%s" % (self.app_label, self.model_name)
163 
164     @property
165     def app_config(self):
166         # Don't go through get_app_config to avoid triggering imports.
167         return self.apps.app_configs.get(self.app_label)
168 
169     def contribute_to_class(self, cls, name):
170         from django.db import connection
171         from django.db.backends.utils import truncate_name
172 
173         cls._meta = self
174         self.model = cls
175         # First, construct the default values for these options.
176         self.object_name = cls.__name__
177         self.model_name = self.object_name.lower()
178         self.verbose_name = camel_case_to_spaces(self.object_name)
179 
180         # Store the original user-defined values for each option,
181         # for use when serializing the model definition
182         self.original_attrs = {}
183 
184         # Next, apply any overridden values from 'class Meta'.
185         if self.meta:
186             meta_attrs = self.meta.__dict__.copy()
187             for name in self.meta.__dict__:
188                 # Ignore any private attributes that Django doesn't care about.
189                 # NOTE: We can't modify a dictionary's contents while looping
190                 # over it, so we loop over the *original* dictionary instead.
191                 if name.startswith("_"):
192                     del meta_attrs[name]
193             for attr_name in DEFAULT_NAMES:
194                 if attr_name in meta_attrs:
195                     setattr(self, attr_name, meta_attrs.pop(attr_name))
196                     self.original_attrs[attr_name] = getattr(self, attr_name)
197                 elif hasattr(self.meta, attr_name):
198                     setattr(self, attr_name, getattr(self.meta, attr_name))
199                     self.original_attrs[attr_name] = getattr(self, attr_name)
200 
201             self.unique_together = normalize_together(self.unique_together)
202             self.index_together = normalize_together(self.index_together)
203             # App label/class name interpolation for names of constraints and
204             # indexes.
205             if not getattr(cls._meta, "abstract", False):
206                 for attr_name in {"constraints", "indexes"}:
207                     objs = getattr(self, attr_name, [])
208                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
209 
210             # verbose_name_plural is a special case because it uses a 's'
211             # by default.
212             if self.verbose_name_plural is None:
213                 self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
214 
215             # order_with_respect_and ordering are mutually exclusive.
216             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
217 
218             # Any leftover attributes must be invalid.
219             if meta_attrs != {}:
220                 raise TypeError(
221                     "'class Meta' got invalid attribute(s): %s" % ",".join(meta_attrs)
222                 )
223         else:
224             self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
225         del self.meta
226 
227         # If the db_table wasn't provided, use the app_label + model_name.
228         if not self.db_table:
229             self.db_table = "%s_%s" % (self.app_label, self.model_name)
230             self.db_table = truncate_name(
231                 self.db_table, connection.ops.max_name_length()
232             )
233 
234     def _format_names_with_class(self, cls, objs):
235         """App label/class name interpolation for object names."""
236         new_objs = []
237         for obj in objs:
238             obj = obj.clone()
239             obj.name = obj.name % {
240                 "app_label": cls._meta.app_label.lower(),
241                 "class": cls.__name__.lower(),
242             }
243             new_objs.append(obj)
244         return new_objs
245 
246     def _get_default_pk_class(self):
247         pk_class_path = getattr(
248             self.app_config,
249             "default_auto_field",
250             settings.DEFAULT_AUTO_FIELD,
251         )
252         if self.app_config and self.app_config._is_default_auto_field_overridden:
253             app_config_class = type(self.app_config)
254             source = (
255                 f"{app_config_class.__module__}."
256                 f"{app_config_class.__qualname__}.default_auto_field"
257             )
258         else:
259             source = "DEFAULT_AUTO_FIELD"
260         if not pk_class_path:
261             raise ImproperlyConfigured(f"{source} must not be empty.")
262         try:
263             pk_class = import_string(pk_class_path)
264         except ImportError as e:
265             msg = (
266                 f"{source} refers to the module '{pk_class_path}' that could "
267                 f"not be imported."
268             )
269             raise ImproperlyConfigured(msg) from e
270         if not issubclass(pk_class, AutoField):
271             raise ValueError(
272                 f"Primary key '{pk_class_path}' referred by {source} must "
273                 f"subclass AutoField."
274             )
275         return pk_class
276 
277     def _prepare(self, model):
278         if self.order_with_respect_to:
279             # The app registry will not be ready at this point, so we cannot
280             # use get_field().
281             query = self.order_with_respect_to
282             try:
283                 self.order_with_respect_to = next(
284                     f
285                     for f in self._get_fields(reverse=False)
286                     if f.name == query or f.attname == query
287                 )
288             except StopIteration:
289                 raise FieldDoesNotExist(
290                     "%s has no field named '%s'" % (self.object_name, query)
291                 )
292 
293             self.ordering = ("_order",)
294             if not any(
295                 isinstance(field, OrderWrt) for field in model._meta.local_fields
296             ):
297                 model.add_to_class("_order", OrderWrt())
298         else:
299             self.order_with_respect_to = None
300 
301         if self.pk is None:
302             if self.parents:
303                 # Promote the first parent link in lieu of adding yet another
304                 # field.
305                 field = next(iter(self.parents.values()))
306                 # Look for a local field with the same name as the
307                 # first parent link. If a local field has already been
308                 # created, use it instead of promoting the parent
309                 already_created = [
310                     fld for fld in self.local_fields if fld.name == field.name
311                 ]
312                 if already_created:
313                     field = already_created[0]
314                 field.primary_key = True
315                 self.setup_pk(field)
316             else:
317                 pk_class = self._get_default_pk_class()
318                 auto = pk_class(verbose_name="ID", primary_key=True, auto_created=True)
319                 model.add_to_class("id", auto)
320 
321     def add_manager(self, manager):
322         self.local_managers.append(manager)
323         self._expire_cache()
324 
325     def add_field(self, field, private=False):
326         # Insert the given field in the order in which it was created, using
327         # the "creation_counter" attribute of the field.
328         # Move many-to-many related fields from self.fields into
329         # self.many_to_many.
330         if private:
331             self.private_fields.append(field)
332         elif field.is_relation and field.many_to_many:
333             bisect.insort(self.local_many_to_many, field)
334         else:
335             bisect.insort(self.local_fields, field)
336             self.setup_pk(field)
337 
338         # If the field being added is a relation to another known field,
339         # expire the cache on this field and the forward cache on the field
340         # being referenced, because there will be new relationships in the
341         # cache. Otherwise, expire the cache of references *to* this field.
342         # The mechanism for getting at the related model is slightly odd -
343         # ideally, we'd just ask for field.related_model. However, related_model
344         # is a cached property, and all the models haven't been loaded yet, so
345         # we need to make sure we don't cache a string reference.
346         if (
347             field.is_relation
348             and hasattr(field.remote_field, "model")
349             and field.remote_field.model
350         ):
351             try:
352                 field.remote_field.model._meta._expire_cache(forward=False)
353             except AttributeError:
354                 pass
355             self._expire_cache()
356         else:
357             self._expire_cache(reverse=False)
358 
359     def setup_pk(self, field):
360         if not self.pk and field.primary_key:
361             self.pk = field
362             field.serialize = False
363 
364     def setup_proxy(self, target):
365         """
366         Do the internal setup so that the current model is a proxy for
367         "target".
368         """
369         self.pk = target._meta.pk
370         self.proxy_for_model = target
371         self.db_table = target._meta.db_table
372 
373     def __repr__(self):
374         return "<Options for %s>" % self.object_name
375 
376     def __str__(self):
377         return self.label_lower
378 
379     def can_migrate(self, connection):
380         """
381         Return True if the model can/should be migrated on the `connection`.
382         `connection` can be either a real connection or a connection alias.
383         """
384         if self.proxy or self.swapped or not self.managed:
385             return False
386         if isinstance(connection, str):
387             connection = connections[connection]
388         if self.required_db_vendor:
389             return self.required_db_vendor == connection.vendor
390         if self.required_db_features:
391             return all(
392                 getattr(connection.features, feat, False)
393                 for feat in self.required_db_features
394             )
395         return True
396 
397     @property
398     def verbose_name_raw(self):
399         """Return the untranslated verbose name."""
400         with override(None):
401             return str(self.verbose_name)
402 
403     @property
404     def swapped(self):
405         """
406         Has this model been swapped out for another? If so, return the model
407         name of the replacement; otherwise, return None.
408 
409         For historical reasons, model name lookups using get_model() are
410         case insensitive, so we make sure we are case insensitive here.
411         """
412         if self.swappable:
413             swapped_for = getattr(settings, self.swappable, None)
414             if swapped_for:
415                 try:
416                     swapped_label, swapped_object = swapped_for.split(".")
417                 except ValueError:
418                     # setting not in the format app_label.model_name
419                     # raising ImproperlyConfigured here causes problems with
420                     # test cleanup code - instead it is raised in get_user_model
421                     # or as part of validation.
422                     return swapped_for
423 
424                 if (
425                     "%s.%s" % (swapped_label, swapped_object.lower())
426                     != self.label_lower
427                 ):
428                     return swapped_for
429         return None
430 
431     @cached_property
432     def managers(self):
433         managers = []
434         seen_managers = set()
435         bases = (b for b in self.model.mro() if hasattr(b, "_meta"))
436         for depth, base in enumerate(bases):
437             for manager in base._meta.local_managers:
438                 if manager.name in seen_managers:
439                     continue
440 
441                 manager = copy.copy(manager)
442                 manager.model = self.model
443                 seen_managers.add(manager.name)
444                 managers.append((depth, manager.creation_counter, manager))
445 
446         return make_immutable_fields_list(
447             "managers",
448             (m[2] for m in sorted(managers)),
449         )
450 
451     @cached_property
452     def managers_map(self):
453         return {manager.name: manager for manager in self.managers}
454 
455     @cached_property
456     def base_manager(self):
457         base_manager_name = self.base_manager_name
458         if not base_manager_name:
459             # Get the first parent's base_manager_name if there's one.
460             for parent in self.model.mro()[1:]:
461                 if hasattr(parent, "_meta"):
462                     if parent._base_manager.name != "_base_manager":
463                         base_manager_name = parent._base_manager.name
464                     break
465 
466         if base_manager_name:
467             try:
468                 return self.managers_map[base_manager_name]
469             except KeyError:
470                 raise ValueError(
471                     "%s has no manager named %r"
472                     % (
473                         self.object_name,
474                         base_manager_name,
475                     )
476                 )
477 
478         manager = Manager()
479         manager.name = "_base_manager"
480         manager.model = self.model
481         manager.auto_created = True
482         return manager
483 
484     @cached_property
485     def default_manager(self):
486         default_manager_name = self.default_manager_name
487         if not default_manager_name and not self.local_managers:
488             # Get the first parent's default_manager_name if there's one.
489             for parent in self.model.mro()[1:]:
490                 if hasattr(parent, "_meta"):
491                     default_manager_name = parent._meta.default_manager_name
492                     break
493 
494         if default_manager_name:
495             try:
496                 return self.managers_map[default_manager_name]
497             except KeyError:
498                 raise ValueError(
499                     "%s has no manager named %r"
500                     % (
501                         self.object_name,
502                         default_manager_name,
503                     )
504                 )
505 
506         if self.managers:
507             return self.managers[0]
508 
509     @cached_property
510     def fields(self):
511         """
512         Return a list of all forward fields on the model and its parents,
513         excluding ManyToManyFields.
514 
515         Private API intended only to be used by Django itself; get_fields()
516         combined with filtering of field properties is the public API for
517         obtaining this field list.
518         """
519         # For legacy reasons, the fields property should only contain forward
520         # fields that are not private or with a m2m cardinality. Therefore we
521         # pass these three filters as filters to the generator.
522         # The third lambda is a longwinded way of checking f.related_model - we don't
523         # use that property directly because related_model is a cached property,
524         # and all the models may not have been loaded yet; we don't want to cache
525         # the string reference to the related_model.
526         def is_not_an_m2m_field(f):
527             return not (f.is_relation and f.many_to_many)
528 
529         def is_not_a_generic_relation(f):
530             return not (f.is_relation and f.one_to_many)
531 
532         def is_not_a_generic_foreign_key(f):
533             return not (
534                 f.is_relation
535                 and f.many_to_one
536                 and not (hasattr(f.remote_field, "model") and f.remote_field.model)
537             )
538 
539         return make_immutable_fields_list(
540             "fields",
541             (
542                 f
543                 for f in self._get_fields(reverse=False)
544                 if is_not_an_m2m_field(f)
545                 and is_not_a_generic_relation(f)
546                 and is_not_a_generic_foreign_key(f)
547             ),
548         )
549 
550     @cached_property
551     def concrete_fields(self):
552         """
553         Return a list of all concrete fields on the model and its parents.
554 
555         Private API intended only to be used by Django itself; get_fields()
556         combined with filtering of field properties is the public API for
557         obtaining this field list.
558         """
559         return make_immutable_fields_list(
560             "concrete_fields", (f for f in self.fields if f.concrete)
561         )
562 
563     @cached_property
564     def local_concrete_fields(self):
565         """
566         Return a list of all concrete fields on the model.
567 
568         Private API intended only to be used by Django itself; get_fields()
569         combined with filtering of field properties is the public API for
570         obtaining this field list.
571         """
572         return make_immutable_fields_list(
573             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
574         )
575 
576     @cached_property
577     def many_to_many(self):
578         """
579         Return a list of all many to many fields on the model and its parents.
580 
581         Private API intended only to be used by Django itself; get_fields()
582         combined with filtering of field properties is the public API for
583         obtaining this list.
584         """
585         return make_immutable_fields_list(
586             "many_to_many",
587             (
588                 f
589                 for f in self._get_fields(reverse=False)
590                 if f.is_relation and f.many_to_many
591             ),
592         )
593 
594     @cached_property
595     def related_objects(self):
596         """
597         Return all related objects pointing to the current model. The related
598         objects can come from a one-to-one, one-to-many, or many-to-many field
599         relation type.
600 
601         Private API intended only to be used by Django itself; get_fields()
602         combined with filtering of field properties is the public API for
603         obtaining this field list.
604         """
605         all_related_fields = self._get_fields(
606             forward=False, reverse=True, include_hidden=True
607         )
608         return make_immutable_fields_list(
609             "related_objects",
610             (
611                 obj
612                 for obj in all_related_fields
613                 if not obj.hidden or obj.field.many_to_many
614             ),
615         )
616 
617     @cached_property
618     def _forward_fields_map(self):
619         res = {}
620         fields = self._get_fields(reverse=False)
621         for field in fields:
622             res[field.name] = field
623             # Due to the way Django's internals work, get_field() should also
624             # be able to fetch a field by attname. In the case of a concrete
625             # field with relation, includes the *_id name too
626             try:
627                 res[field.attname] = field
628             except AttributeError:
629                 pass
630         return res
631 
632     @cached_property
633     def fields_map(self):
634         res = {}
635         fields = self._get_fields(forward=False, include_hidden=True)
636         for field in fields:
637             res[field.name] = field
638             # Due to the way Django's internals work, get_field() should also
639             # be able to fetch a field by attname. In the case of a concrete
640             # field with relation, includes the *_id name too
641             try:
642                 res[field.attname] = field
643             except AttributeError:
644                 pass
645         return res
646 
647     def get_field(self, field_name):
648         """
649         Return a field instance given the name of a forward or reverse field.
650         """
651         try:
652             # In order to avoid premature loading of the relation tree
653             # (expensive) we prefer checking if the field is a forward field.
654             return self._forward_fields_map[field_name]
655         except KeyError:
656             # If the app registry is not ready, reverse fields are
657             # unavailable, therefore we throw a FieldDoesNotExist exception.
658             if not self.apps.models_ready:
659                 raise FieldDoesNotExist(
660                     "%s has no field named '%s'. The app cache isn't ready yet, "
661                     "so if this is an auto-created related field, it won't "
662                     "be available yet." % (self.object_name, field_name)
663                 )
664 
665         try:
666             # Retrieve field instance by name from cached or just-computed
667             # field map.
668             return self.fields_map[field_name]
669         except KeyError:
670             raise FieldDoesNotExist(
671                 "%s has no field named '%s'" % (self.object_name, field_name)
672             )
673 
674     def get_base_chain(self, model):
675         """
676         Return a list of parent classes leading to `model` (ordered from
677         closest to most distant ancestor). This has to handle the case where
678         `model` is a grandparent or even more distant relation.
679         """
680         if not self.parents:
681             return []
682         if model in self.parents:
683             return [model]
684         for parent in self.parents:
685             res = parent._meta.get_base_chain(model)
686             if res:
687                 res.insert(0, parent)
688                 return res
689         return []
690 
691     def get_parent_list(self):
692         """
693         Return all the ancestors of this model as a list ordered by MRO.
694         Useful for determining if something is an ancestor, regardless of lineage.
695         """
696         result = OrderedSet(self.parents)
697         for parent in self.parents:
698             for ancestor in parent._meta.get_parent_list():
699                 result.add(ancestor)
700         return list(result)
701 
702     def get_ancestor_link(self, ancestor):
703         """
704         Return the field on the current model which points to the given
705         "ancestor". This is possible an indirect link (a pointer to a parent
706         model, which points, eventually, to the ancestor). Used when
707         constructing table joins for model inheritance.
708 
709         Return None if the model isn't an ancestor of this one.
710         """
711         if ancestor in self.parents:
712             return self.parents[ancestor]
713         for parent in self.parents:
714             # Tries to get a link field from the immediate parent
715             parent_link = parent._meta.get_ancestor_link(ancestor)
716             if parent_link:
717                 # In case of a proxied model, the first link
718                 # of the chain to the ancestor is that parent
719                 # links
720                 return self.parents[parent] or parent_link
721 
722     def get_path_to_parent(self, parent):
723         """
724         Return a list of PathInfos containing the path from the current
725         model to the parent model, or an empty list if parent is not a
726         parent of the current model.
727         """
728         if self.model is parent:
729             return []
730         # Skip the chain of proxy to the concrete proxied model.
731         proxied_model = self.concrete_model
732         path = []
733         opts = self
734         for int_model in self.get_base_chain(parent):
735             if int_model is proxied_model:
736                 opts = int_model._meta
737             else:
738                 final_field = opts.parents[int_model]
739                 targets = (final_field.remote_field.get_related_field(),)
740                 opts = int_model._meta
741                 path.append(
742                     PathInfo(
743                         from_opts=final_field.model._meta,
744                         to_opts=opts,
745                         target_fields=targets,
746                         join_field=final_field,
747                         m2m=False,
748                         direct=True,
749                         filtered_relation=None,
750                     )
751                 )
752         return path
753 
754     def get_path_from_parent(self, parent):
755         """
756         Return a list of PathInfos containing the path from the parent
757         model to the current model, or an empty list if parent is not a
758         parent of the current model.
759         """
760         if self.model is parent:
761             return []
762         model = self.concrete_model
763         # Get a reversed base chain including both the current and parent
764         # models.
765         chain = model._meta.get_base_chain(parent)
766         chain.reverse()
767         chain.append(model)
768         # Construct a list of the PathInfos between models in chain.
769         path = []
770         for i, ancestor in enumerate(chain[:-1]):
771             child = chain[i + 1]
772             link = child._meta.get_ancestor_link(ancestor)
773             path.extend(link.reverse_path_infos)
774         return path
775 
776     def _populate_directed_relation_graph(self):
777         """
778         This method is used by each model to find its reverse objects. As this
779         method is very expensive and is accessed frequently (it looks up every
780         field in a model, in every app), it is computed on first access and then
781         is set as a property on every model.
782         """
783         related_objects_graph = defaultdict(list)
784 
785         all_models = self.apps.get_models(include_auto_created=True)
786         for model in all_models:
787             opts = model._meta
788             # Abstract model's fields are copied to child models, hence we will
789             # see the fields from the child models.
790             if opts.abstract:
791                 continue
792             fields_with_relations = (
793                 f
794                 for f in opts._get_fields(reverse=False, include_parents=False)
795                 if f.is_relation and f.related_model is not None
796             )
797             for f in fields_with_relations:
798                 if not isinstance(f.remote_field.model, str):
799                     remote_label = f.remote_field.model._meta.concrete_model._meta.label
800                     related_objects_graph[remote_label].append(f)
801 
802         for model in all_models:
803             # Set the relation_tree using the internal __dict__. In this way
804             # we avoid calling the cached property. In attribute lookup,
805             # __dict__ takes precedence over a data descriptor (such as
806             # @cached_property). This means that the _meta._relation_tree is
807             # only called if related_objects is not in __dict__.
808             related_objects = related_objects_graph[
809                 model._meta.concrete_model._meta.label
810             ]
811             model._meta.__dict__["_relation_tree"] = related_objects
812         # It seems it is possible that self is not in all_models, so guard
813         # against that with default for get().
814         return self.__dict__.get("_relation_tree", EMPTY_RELATION_TREE)
815 
816     @cached_property
817     def _relation_tree(self):
818         return self._populate_directed_relation_graph()
819 
820     def _expire_cache(self, forward=True, reverse=True):
821         # This method is usually called by apps.cache_clear(), when the
822         # registry is finalized, or when a new field is added.
823         if forward:
824             for cache_key in self.FORWARD_PROPERTIES:
825                 if cache_key in self.__dict__:
826                     delattr(self, cache_key)
827         if reverse and not self.abstract:
828             for cache_key in self.REVERSE_PROPERTIES:
829                 if cache_key in self.__dict__:
830                     delattr(self, cache_key)
831         self._get_fields_cache = {}
832 
833     def get_fields(self, include_parents=True, include_hidden=False):
834         """
835         Return a list of fields associated to the model. By default, include
836         forward and reverse fields, fields derived from inheritance, but not
837         hidden fields. The returned fields can be changed using the parameters:
838 
839         - include_parents: include fields derived from inheritance
840         - include_hidden:  include fields that have a related_name that
841                            starts with a "+"
842         """
843         if include_parents is False:
844             include_parents = PROXY_PARENTS
845         return self._get_fields(
846             include_parents=include_parents, include_hidden=include_hidden
847         )
848 
849     def _get_fields(
850         self,
851         forward=True,
852         reverse=True,
853         include_parents=True,
854         include_hidden=False,
855         seen_models=None,
856     ):
857         """
858         Internal helper function to return fields of the model.
859         * If forward=True, then fields defined on this model are returned.
860         * If reverse=True, then relations pointing to this model are returned.
861         * If include_hidden=True, then fields with is_hidden=True are returned.
862         * The include_parents argument toggles if fields from parent models
863           should be included. It has three values: True, False, and
864           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
865           fields defined for the current model or any of its parents in the
866           parent chain to the model's concrete model.
867         """
868         if include_parents not in (True, False, PROXY_PARENTS):
869             raise TypeError(
870                 "Invalid argument for include_parents: %s" % (include_parents,)
871             )
872         # This helper function is used to allow recursion in ``get_fields()``
873         # implementation and to provide a fast way for Django's internals to
874         # access specific subsets of fields.
875 
876         # We must keep track of which models we have already seen. Otherwise we
877         # could include the same field multiple times from different models.
878         topmost_call = seen_models is None
879         if topmost_call:
880             seen_models = set()
881         seen_models.add(self.model)
882 
883         # Creates a cache key composed of all arguments
884         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
885 
886         try:
887             # In order to avoid list manipulation. Always return a shallow copy
888             # of the results.
889             return self._get_fields_cache[cache_key]
890         except KeyError:
891             pass
892 
893         fields = []
894         # Recursively call _get_fields() on each parent, with the same
895         # options provided in this call.
896         if include_parents is not False:
897             for parent in self.parents:
898                 # In diamond inheritance it is possible that we see the same
899                 # model from two different routes. In that case, avoid adding
900                 # fields from the same parent again.
901                 if parent in seen_models:
902                     continue
903                 if (
904                     parent._meta.concrete_model != self.concrete_model
905                     and include_parents == PROXY_PARENTS
906                 ):
907                     continue
908                 for obj in parent._meta._get_fields(
909                     forward=forward,
910                     reverse=reverse,
911                     include_parents=include_parents,
912                     include_hidden=include_hidden,
913                     seen_models=seen_models,
914                 ):
915                     if (
916                         not getattr(obj, "parent_link", False)
917                         or obj.model == self.concrete_model
918                     ):
919                         fields.append(obj)
920         if reverse and not self.proxy:
921             # Tree is computed once and cached until the app cache is expired.
922             # It is composed of a list of fields pointing to the current model
923             # from other models.
924             all_fields = self._relation_tree
925             for field in all_fields:
926                 # If hidden fields should be included or the relation is not
927                 # intentionally hidden, add to the fields dict.
928                 if include_hidden or not field.remote_field.hidden:
929                     fields.append(field.remote_field)
930 
931         if forward:
932             fields += self.local_fields
933             fields += self.local_many_to_many
934             # Private fields are recopied to each child model, and they get a
935             # different model as field.model in each child. Hence we have to
936             # add the private fields separately from the topmost call. If we
937             # did this recursively similar to local_fields, we would get field
938             # instances with field.model != self.model.
939             if topmost_call:
940                 fields += self.private_fields
941 
942         # In order to avoid list manipulation. Always
943         # return a shallow copy of the results
944         fields = make_immutable_fields_list("get_fields()", fields)
945 
946         # Store result into cache for later access
947         self._get_fields_cache[cache_key] = fields
948         return fields
949 
950     @cached_property
951     def total_unique_constraints(self):
952         """
953         Return a list of total unique constraints. Useful for determining set
954         of fields guaranteed to be unique for all rows.
955         """
956         return [
957             constraint
958             for constraint in self.constraints
959             if (
960                 isinstance(constraint, UniqueConstraint)
961                 and constraint.condition is None
962                 and not constraint.contains_expressions
963             )
964         ]
965 
966     @cached_property
967     def _property_names(self):
968         """Return a set of the names of the properties defined on the model."""
969         names = []
970         for name in dir(self.model):
971             attr = inspect.getattr_static(self.model, name)
972             if isinstance(attr, property):
973                 names.append(name)
974         return frozenset(names)
975 
976     @cached_property
977     def db_returning_fields(self):
978         """
979         Private API intended only to be used by Django itself.
980         Fields to be returned after a database insert.
981         """
982         return [
983             field
984             for field in self._get_fields(
985                 forward=True, reverse=False, include_parents=PROXY_PARENTS
986             )
987             if getattr(field, "db_returning", False)
988         ]

</code><intended_behavior>The handling of `index_together` should be deprecated in favor of directly using `Index` instances in the `indexes` list, ensuring seamless functionality with no change to the resulting database schema.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
477 class Model(metaclass=ModelBase):
478     def __init__(self, *args, **kwargs):
479         # Alias some things as locals to avoid repeat global lookups
480         cls = self.__class__
481         opts = self._meta
482         _setattr = setattr
483         _DEFERRED = DEFERRED
484         if opts.abstract:
485             raise TypeError("Abstract models cannot be instantiated.")
486 
487         pre_init.send(sender=cls, args=args, kwargs=kwargs)
488 
489         # Set up the storage for instance state
490         self._state = ModelState()
491 
492         # There is a rather weird disparity here; if kwargs, it's set, then args
493         # overrides it. It should be one or the other; don't duplicate the work
494         # The reason for the kwargs check is that standard iterator passes in by
495         # args, and instantiation for iteration is 33% faster.
496         if len(args) > len(opts.concrete_fields):
497             # Daft, but matches old exception sans the err msg.
498             raise IndexError("Number of args exceeds number of fields")
499 
500         if not kwargs:
501             fields_iter = iter(opts.concrete_fields)
502             # The ordering of the zip calls matter - zip throws StopIteration
503             # when an iter throws it. So if the first iter throws it, the second
504             # is *not* consumed. We rely on this, so don't change the order
505             # without changing the logic.
506             for val, field in zip(args, fields_iter):
507                 if val is _DEFERRED:
508                     continue
509                 _setattr(self, field.attname, val)
510         else:
511             # Slower, kwargs-ready version.
512             fields_iter = iter(opts.fields)
513             for val, field in zip(args, fields_iter):
514                 if val is _DEFERRED:
515                     continue
516                 _setattr(self, field.attname, val)
517                 if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
518                     raise TypeError(
519                         f"{cls.__qualname__}() got both positional and "
520                         f"keyword arguments for field '{field.name}'."
521                     )
522 
523         # Now we're left with the unprocessed fields that *must* come from
524         # keywords, or default.
525 
526         for field in fields_iter:
527             is_related_object = False
528             # Virtual field
529             if field.attname not in kwargs and field.column is None:
530                 continue
531             if kwargs:
532                 if isinstance(field.remote_field, ForeignObjectRel):
533                     try:
534                         # Assume object instance was passed in.
535                         rel_obj = kwargs.pop(field.name)
536                         is_related_object = True
537                     except KeyError:
538                         try:
539                             # Object instance wasn't passed in -- must be an ID.
540                             val = kwargs.pop(field.attname)
541                         except KeyError:
542                             val = field.get_default()
543                 else:
544                     try:
545                         val = kwargs.pop(field.attname)
546                     except KeyError:
547                         # This is done with an exception rather than the
548                         # default argument on pop because we don't want
549                         # get_default() to be evaluated, and then not used.
550                         # Refs #12057.
551                         val = field.get_default()
552             else:
553                 val = field.get_default()
554 
555             if is_related_object:
556                 # If we are passed a related instance, set it using the
557                 # field.name instead of field.attname (e.g. "user" instead of
558                 # "user_id") so that the object gets properly cached (and type
559                 # checked) by the RelatedObjectDescriptor.
560                 if rel_obj is not _DEFERRED:
561                     _setattr(self, field.name, rel_obj)
562             else:
563                 if val is not _DEFERRED:
564                     _setattr(self, field.attname, val)
565 
566         if kwargs:
567             property_names = opts._property_names
568             unexpected = ()
569             for prop, value in kwargs.items():
570                 # Any remaining kwargs must correspond to properties or virtual
571                 # fields.
572                 if prop in property_names:
573                     if value is not _DEFERRED:
574                         _setattr(self, prop, value)
575                 else:
576                     try:
577                         opts.get_field(prop)
578                     except FieldDoesNotExist:
579                         unexpected += (prop,)
580                     else:
581                         if value is not _DEFERRED:
582                             _setattr(self, prop, value)
583             if unexpected:
584                 unexpected_names = ", ".join(repr(n) for n in unexpected)
585                 raise TypeError(
586                     f"{cls.__name__}() got unexpected keyword arguments: "
587                     f"{unexpected_names}"
588                 )
589         super().__init__()
590         post_init.send(sender=cls, instance=self)
591 
592     @classmethod
593     def from_db(cls, db, field_names, values):
594         if len(values) != len(cls._meta.concrete_fields):
595             values_iter = iter(values)
596             values = [
597                 next(values_iter) if f.attname in field_names else DEFERRED
598                 for f in cls._meta.concrete_fields
599             ]
600         new = cls(*values)
601         new._state.adding = False
602         new._state.db = db
603         return new
604 
605     def __repr__(self):
606         return "<%s: %s>" % (self.__class__.__name__, self)
607 
608     def __str__(self):
609         return "%s object (%s)" % (self.__class__.__name__, self.pk)
610 
611     def __eq__(self, other):
612         if not isinstance(other, Model):
613             return NotImplemented
614         if self._meta.concrete_model != other._meta.concrete_model:
615             return False
616         my_pk = self.pk
617         if my_pk is None:
618             return self is other
619         return my_pk == other.pk
620 
621     def __hash__(self):
622         if self.pk is None:
623             raise TypeError("Model instances without primary key value are unhashable")
624         return hash(self.pk)
625 
626     def __reduce__(self):
627         data = self.__getstate__()
628         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
629         class_id = self._meta.app_label, self._meta.object_name
630         return model_unpickle, (class_id,), data
631 
632     def __getstate__(self):
633         """Hook to allow choosing the attributes to pickle."""
634         state = self.__dict__.copy()
635         state["_state"] = copy.copy(state["_state"])
636         # memoryview cannot be pickled, so cast it to bytes and store
637         # separately.
638         _memoryview_attrs = []
639         for attr, value in state.items():
640             if isinstance(value, memoryview):
641                 _memoryview_attrs.append((attr, bytes(value)))
642         if _memoryview_attrs:
643             state["_memoryview_attrs"] = _memoryview_attrs
644             for attr, value in _memoryview_attrs:
645                 state.pop(attr)
646         return state
647 
648     def __setstate__(self, state):
649         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
650         if pickled_version:
651             if pickled_version != django.__version__:
652                 warnings.warn(
653                     "Pickled model instance's Django version %s does not "
654                     "match the current version %s."
655                     % (pickled_version, django.__version__),
656                     RuntimeWarning,
657                     stacklevel=2,
658                 )
659         else:
660             warnings.warn(
661                 "Pickled model instance's Django version is not specified.",
662                 RuntimeWarning,
663                 stacklevel=2,
664             )
665         if "_memoryview_attrs" in state:
666             for attr, value in state.pop("_memoryview_attrs"):
667                 state[attr] = memoryview(value)
668         self.__dict__.update(state)
669 
670     def _get_pk_val(self, meta=None):
671         meta = meta or self._meta
672         return getattr(self, meta.pk.attname)
673 
674     def _set_pk_val(self, value):
675         for parent_link in self._meta.parents.values():
676             if parent_link and parent_link != self._meta.pk:
677                 setattr(self, parent_link.target_field.attname, value)
678         return setattr(self, self._meta.pk.attname, value)
679 
680     pk = property(_get_pk_val, _set_pk_val)
681 
682     def get_deferred_fields(self):
683         """
684         Return a set containing names of deferred fields for this instance.
685         """
686         return {
687             f.attname
688             for f in self._meta.concrete_fields
689             if f.attname not in self.__dict__
690         }
691 
692     def refresh_from_db(self, using=None, fields=None):
693         """
694         Reload field values from the database.
695 
696         By default, the reloading happens from the database this instance was
697         loaded from, or by the read router if this instance wasn't loaded from
698         any database. The using parameter will override the default.
699 
700         Fields can be used to specify which fields to reload. The fields
701         should be an iterable of field attnames. If fields is None, then
702         all non-deferred fields are reloaded.
703 
704         When accessing deferred fields of an instance, the deferred loading
705         of the field will call this method.
706         """
707         if fields is None:
708             self._prefetched_objects_cache = {}
709         else:
710             prefetched_objects_cache = getattr(self, "_prefetched_objects_cache", ())
711             for field in fields:
712                 if field in prefetched_objects_cache:
713                     del prefetched_objects_cache[field]
714                     fields.remove(field)
715             if not fields:
716                 return
717             if any(LOOKUP_SEP in f for f in fields):
718                 raise ValueError(
719                     'Found "%s" in fields argument. Relations and transforms '
720                     "are not allowed in fields." % LOOKUP_SEP
721                 )
722 
723         hints = {"instance": self}
724         db_instance_qs = self.__class__._base_manager.db_manager(
725             using, hints=hints
726         ).filter(pk=self.pk)
727 
728         # Use provided fields, if not set then reload all non-deferred fields.
729         deferred_fields = self.get_deferred_fields()
730         if fields is not None:
731             fields = list(fields)
732             db_instance_qs = db_instance_qs.only(*fields)
733         elif deferred_fields:
734             fields = [
735                 f.attname
736                 for f in self._meta.concrete_fields
737                 if f.attname not in deferred_fields
738             ]
739             db_instance_qs = db_instance_qs.only(*fields)
740 
741         db_instance = db_instance_qs.get()
742         non_loaded_fields = db_instance.get_deferred_fields()
743         for field in self._meta.concrete_fields:
744             if field.attname in non_loaded_fields:
745                 # This field wasn't refreshed - skip ahead.
746                 continue
747             setattr(self, field.attname, getattr(db_instance, field.attname))
748             # Clear cached foreign keys.
749             if field.is_relation and field.is_cached(self):
750                 field.delete_cached_value(self)
751 
752         # Clear cached relations.
753         for field in self._meta.related_objects:
754             if field.is_cached(self):
755                 field.delete_cached_value(self)
756 
757         self._state.db = db_instance._state.db
758 
759     def serializable_value(self, field_name):
760         """
761         Return the value of the field name for this instance. If the field is
762         a foreign key, return the id value instead of the object. If there's
763         no Field object with this name on the model, return the model
764         attribute's value.
765 
766         Used to serialize a field's value (in the serializer, or form output,
767         for example). Normally, you would just access the attribute directly
768         and not use this method.
769         """
770         try:
771             field = self._meta.get_field(field_name)
772         except FieldDoesNotExist:
773             return getattr(self, field_name)
774         return getattr(self, field.attname)
775 
776     def save(
777         self, force_insert=False, force_update=False, using=None, update_fields=None
778     ):
779         """
780         Save the current instance. Override this in a subclass if you want to
781         control the saving process.
782 
783         The 'force_insert' and 'force_update' parameters can be used to insist
784         that the "save" must be an SQL insert or update (or equivalent for
785         non-SQL backends), respectively. Normally, they should not be set.
786         """
787         self._prepare_related_fields_for_save(operation_name="save")
788 
789         using = using or router.db_for_write(self.__class__, instance=self)
790         if force_insert and (force_update or update_fields):
791             raise ValueError("Cannot force both insert and updating in model saving.")
792 
793         deferred_fields = self.get_deferred_fields()
794         if update_fields is not None:
795             # If update_fields is empty, skip the save. We do also check for
796             # no-op saves later on for inheritance cases. This bailout is
797             # still needed for skipping signal sending.
798             if not update_fields:
799                 return
800 
801             update_fields = frozenset(update_fields)
802             field_names = set()
803 
804             for field in self._meta.concrete_fields:
805                 if not field.primary_key:
806                     field_names.add(field.name)
807 
808                     if field.name != field.attname:
809                         field_names.add(field.attname)
810 
811             non_model_fields = update_fields.difference(field_names)
812 
813             if non_model_fields:
814                 raise ValueError(
815                     "The following fields do not exist in this model, are m2m "
816                     "fields, or are non-concrete fields: %s"
817                     % ", ".join(non_model_fields)
818                 )
819 
820         # If saving to the same database, and this model is deferred, then
821         # automatically do an "update_fields" save on the loaded fields.
822         elif not force_insert and deferred_fields and using == self._state.db:
823             field_names = set()
824             for field in self._meta.concrete_fields:
825                 if not field.primary_key and not hasattr(field, "through"):
826                     field_names.add(field.attname)
827             loaded_fields = field_names.difference(deferred_fields)
828             if loaded_fields:
829                 update_fields = frozenset(loaded_fields)
830 
831         self.save_base(
832             using=using,
833             force_insert=force_insert,
834             force_update=force_update,
835             update_fields=update_fields,
836         )
837 
838     save.alters_data = True
839 
840     def save_base(
841         self,
842         raw=False,
843         force_insert=False,
844         force_update=False,
845         using=None,
846         update_fields=None,
847     ):
848         """
849         Handle the parts of saving which should be done only once per save,
850         yet need to be done in raw saves, too. This includes some sanity
851         checks and signal sending.
852 
853         The 'raw' argument is telling save_base not to save any parent
854         models and not to do any changes to the values before save. This
855         is used by fixture loading.
856         """
857         using = using or router.db_for_write(self.__class__, instance=self)
858         assert not (force_insert and (force_update or update_fields))
859         assert update_fields is None or update_fields
860         cls = origin = self.__class__
861         # Skip proxies, but keep the origin as the proxy model.
862         if cls._meta.proxy:
863             cls = cls._meta.concrete_model
864         meta = cls._meta
865         if not meta.auto_created:
866             pre_save.send(
867                 sender=origin,
868                 instance=self,
869                 raw=raw,
870                 using=using,
871                 update_fields=update_fields,
872             )
873         # A transaction isn't needed if one query is issued.
874         if meta.parents:
875             context_manager = transaction.atomic(using=using, savepoint=False)
876         else:
877             context_manager = transaction.mark_for_rollback_on_error(using=using)
878         with context_manager:
879             parent_inserted = False
880             if not raw:
881                 parent_inserted = self._save_parents(cls, using, update_fields)
882             updated = self._save_table(
883                 raw,
884                 cls,
885                 force_insert or parent_inserted,
886                 force_update,
887                 using,
888                 update_fields,
889             )
890         # Store the database on which the object was saved
891         self._state.db = using
892         # Once saved, this is no longer a to-be-added instance.
893         self._state.adding = False
894 
895         # Signal that the save is complete
896         if not meta.auto_created:
897             post_save.send(
898                 sender=origin,
899                 instance=self,
900                 created=(not updated),
901                 update_fields=update_fields,
902                 raw=raw,
903                 using=using,
904             )
905 
906     save_base.alters_data = True
907 
908     def _save_parents(self, cls, using, update_fields):
909         """Save all the parents of cls using values from self."""
910         meta = cls._meta
911         inserted = False
912         for parent, field in meta.parents.items():
913             # Make sure the link fields are synced between parent and self.
914             if (
915                 field
916                 and getattr(self, parent._meta.pk.attname) is None
917                 and getattr(self, field.attname) is not None
918             ):
919                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
920             parent_inserted = self._save_parents(
921                 cls=parent, using=using, update_fields=update_fields
922             )
923             updated = self._save_table(
924                 cls=parent,
925                 using=using,
926                 update_fields=update_fields,
927                 force_insert=parent_inserted,
928             )
929             if not updated:
930                 inserted = True
931             # Set the parent's PK value to self.
932             if field:
933                 setattr(self, field.attname, self._get_pk_val(parent._meta))
934                 # Since we didn't have an instance of the parent handy set
935                 # attname directly, bypassing the descriptor. Invalidate
936                 # the related object cache, in case it's been accidentally
937                 # populated. A fresh instance will be re-built from the
938                 # database if necessary.
939                 if field.is_cached(self):
940                     field.delete_cached_value(self)
941         return inserted
942 
943     def _save_table(
944         self,
945         raw=False,
946         cls=None,
947         force_insert=False,
948         force_update=False,
949         using=None,
950         update_fields=None,
951     ):
952         """
953         Do the heavy-lifting involved in saving. Update or insert the data
954         for a single table.
955         """
956         meta = cls._meta
957         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
958 
959         if update_fields:
960             non_pks = [
961                 f
962                 for f in non_pks
963                 if f.name in update_fields or f.attname in update_fields
964             ]
965 
966         pk_val = self._get_pk_val(meta)
967         if pk_val is None:
968             pk_val = meta.pk.get_pk_value_on_save(self)
969             setattr(self, meta.pk.attname, pk_val)
970         pk_set = pk_val is not None
971         if not pk_set and (force_update or update_fields):
972             raise ValueError("Cannot force an update in save() with no primary key.")
973         updated = False
974         # Skip an UPDATE when adding an instance and primary key has a default.
975         if (
976             not raw
977             and not force_insert
978             and self._state.adding
979             and meta.pk.default
980             and meta.pk.default is not NOT_PROVIDED
981         ):
982             force_insert = True
983         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
984         if pk_set and not force_insert:
985             base_qs = cls._base_manager.using(using)
986             values = [
987                 (
988                     f,
989                     None,
990                     (getattr(self, f.attname) if raw else f.pre_save(self, False)),
991                 )
992                 for f in non_pks
993             ]
994             forced_update = update_fields or force_update
995             updated = self._do_update(
996                 base_qs, using, pk_val, values, update_fields, forced_update
997             )
998             if force_update and not updated:
999                 raise DatabaseError("Forced update did not affect any rows.")
1000             if update_fields and not updated:
1001                 raise DatabaseError("Save with update_fields did not affect any rows.")
1002         if not updated:
1003             if meta.order_with_respect_to:
1004                 # If this is a model with an order_with_respect_to
1005                 # autopopulate the _order field
1006                 field = meta.order_with_respect_to
1007                 filter_args = field.get_filter_kwargs_for_object(self)
1008                 self._order = (
1009                     cls._base_manager.using(using)
1010                     .filter(**filter_args)
1011                     .aggregate(
1012                         _order__max=Coalesce(
1013                             ExpressionWrapper(
1014                                 Max("_order") + Value(1), output_field=IntegerField()
1015                             ),
1016                             Value(0),
1017                         ),
1018                     )["_order__max"]
1019                 )
1020             fields = meta.local_concrete_fields
1021             if not pk_set:
1022                 fields = [f for f in fields if f is not meta.auto_field]
1023 
1024             returning_fields = meta.db_returning_fields
1025             results = self._do_insert(
1026                 cls._base_manager, using, fields, returning_fields, raw
1027             )
1028             if results:
1029                 for value, field in zip(results[0], returning_fields):
1030                     setattr(self, field.attname, value)
1031         return updated
1032 
1033     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
1034         """
1035         Try to update the model. Return True if the model was updated (if an
1036         update query was done and a matching row was found in the DB).
1037         """
1038         filtered = base_qs.filter(pk=pk_val)
1039         if not values:
1040             # We can end up here when saving a model in inheritance chain where
1041             # update_fields doesn't target any field in current model. In that
1042             # case we just say the update succeeded. Another case ending up here
1043             # is a model with just PK - in that case check that the PK still
1044             # exists.
1045             return update_fields is not None or filtered.exists()
1046         if self._meta.select_on_save and not forced_update:
1047             return (
1048                 filtered.exists()
1049                 and
1050                 # It may happen that the object is deleted from the DB right after
1051                 # this check, causing the subsequent UPDATE to return zero matching
1052                 # rows. The same result can occur in some rare cases when the
1053                 # database returns zero despite the UPDATE being executed
1054                 # successfully (a row is matched and updated). In order to
1055                 # distinguish these two cases, the object's existence in the
1056                 # database is again checked for if the UPDATE query returns 0.
1057                 (filtered._update(values) > 0 or filtered.exists())
1058             )
1059         return filtered._update(values) > 0
1060 
1061     def _do_insert(self, manager, using, fields, returning_fields, raw):
1062         """
1063         Do an INSERT. If returning_fields is defined then this method should
1064         return the newly created data for the model.
1065         """
1066         return manager._insert(
1067             [self],
1068             fields=fields,
1069             returning_fields=returning_fields,
1070             using=using,
1071             raw=raw,
1072         )
1073 
1074     def _prepare_related_fields_for_save(self, operation_name, fields=None):
1075         # Ensure that a model instance without a PK hasn't been assigned to
1076         # a ForeignKey, GenericForeignKey or OneToOneField on this model. If
1077         # the field is nullable, allowing the save would result in silent data
1078         # loss.
1079         for field in self._meta.concrete_fields:
1080             if fields and field not in fields:
1081                 continue
1082             # If the related field isn't cached, then an instance hasn't been
1083             # assigned and there's no need to worry about this check.
1084             if field.is_relation and field.is_cached(self):
1085                 obj = getattr(self, field.name, None)
1086                 if not obj:
1087                     continue
1088                 # A pk may have been assigned manually to a model instance not
1089                 # saved to the database (or auto-generated in a case like
1090                 # UUIDField), but we allow the save to proceed and rely on the
1091                 # database to raise an IntegrityError if applicable. If
1092                 # constraints aren't supported by the database, there's the
1093                 # unavoidable risk of data corruption.
1094                 if obj.pk is None:
1095                     # Remove the object from a related instance cache.
1096                     if not field.remote_field.multiple:
1097                         field.remote_field.delete_cached_value(obj)
1098                     raise ValueError(
1099                         "%s() prohibited to prevent data loss due to unsaved "
1100                         "related object '%s'." % (operation_name, field.name)
1101                     )
1102                 elif getattr(self, field.attname) in field.empty_values:
1103                     # Set related object if it has been saved after an
1104                     # assignment.
1105                     setattr(self, field.name, obj)
1106                 # If the relationship's pk/to_field was changed, clear the
1107                 # cached relationship.
1108                 if getattr(obj, field.target_field.attname) != getattr(
1109                     self, field.attname
1110                 ):
1111                     field.delete_cached_value(self)
1112         # GenericForeignKeys are private.
1113         for field in self._meta.private_fields:
1114             if fields and field not in fields:
1115                 continue
1116             if (
1117                 field.is_relation
1118                 and field.is_cached(self)
1119                 and hasattr(field, "fk_field")
1120             ):
1121                 obj = field.get_cached_value(self, default=None)
1122                 if obj and obj.pk is None:
1123                     raise ValueError(
1124                         f"{operation_name}() prohibited to prevent data loss due to "
1125                         f"unsaved related object '{field.name}'."
1126                     )
1127 
1128     def delete(self, using=None, keep_parents=False):
1129         if self.pk is None:
1130             raise ValueError(
1131                 "%s object can't be deleted because its %s attribute is set "
1132                 "to None." % (self._meta.object_name, self._meta.pk.attname)
1133             )
1134         using = using or router.db_for_write(self.__class__, instance=self)
1135         collector = Collector(using=using, origin=self)
1136         collector.collect([self], keep_parents=keep_parents)
1137         return collector.delete()
1138 
1139     delete.alters_data = True
1140 
1141     def _get_FIELD_display(self, field):
1142         value = getattr(self, field.attname)
1143         choices_dict = dict(make_hashable(field.flatchoices))
1144         # force_str() to coerce lazy strings.
1145         return force_str(
1146             choices_dict.get(make_hashable(value), value), strings_only=True
1147         )
1148 
1149     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
1150         if not self.pk:
1151             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
1152         op = "gt" if is_next else "lt"
1153         order = "" if is_next else "-"
1154         param = getattr(self, field.attname)
1155         q = Q((field.name, param), (f"pk__{op}", self.pk), _connector=Q.AND)
1156         q = Q(q, (f"{field.name}__{op}", param), _connector=Q.OR)
1157         qs = (
1158             self.__class__._default_manager.using(self._state.db)
1159             .filter(**kwargs)
1160             .filter(q)
1161             .order_by("%s%s" % (order, field.name), "%spk" % order)
1162         )
1163         try:
1164             return qs[0]
1165         except IndexError:
1166             raise self.DoesNotExist(
1167                 "%s matching query does not exist." % self.__class__._meta.object_name
1168             )
1169 
1170     def _get_next_or_previous_in_order(self, is_next):
1171         cachename = "__%s_order_cache" % is_next
1172         if not hasattr(self, cachename):
1173             op = "gt" if is_next else "lt"
1174             order = "_order" if is_next else "-_order"
1175             order_field = self._meta.order_with_respect_to
1176             filter_args = order_field.get_filter_kwargs_for_object(self)
1177             obj = (
1178                 self.__class__._default_manager.filter(**filter_args)
1179                 .filter(
1180                     **{
1181                         "_order__%s"
1182                         % op: self.__class__._default_manager.values("_order").filter(
1183                             **{self._meta.pk.name: self.pk}
1184                         )
1185                     }
1186                 )
1187                 .order_by(order)[:1]
1188                 .get()
1189             )
1190             setattr(self, cachename, obj)
1191         return getattr(self, cachename)
1192 
1193     def _get_field_value_map(self, meta, exclude=None):
1194         if exclude is None:
1195             exclude = set()
1196         meta = meta or self._meta
1197         return {
1198             field.name: Value(getattr(self, field.attname), field)
1199             for field in meta.local_concrete_fields
1200             if field.name not in exclude
1201         }
1202 
1203     def prepare_database_save(self, field):
1204         if self.pk is None:
1205             raise ValueError(
1206                 "Unsaved model instance %r cannot be used in an ORM query." % self
1207             )
1208         return getattr(self, field.remote_field.get_related_field().attname)
1209 
1210     def clean(self):
1211         """
1212         Hook for doing any extra model-wide validation after clean() has been
1213         called on every field by self.clean_fields. Any ValidationError raised
1214         by this method will not be associated with a particular field; it will
1215         have a special-case association with the field defined by NON_FIELD_ERRORS.
1216         """
1217         pass
1218 
1219     def validate_unique(self, exclude=None):
1220         """
1221         Check unique constraints on the model and raise ValidationError if any
1222         failed.
1223         """
1224         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1225 
1226         errors = self._perform_unique_checks(unique_checks)
1227         date_errors = self._perform_date_checks(date_checks)
1228 
1229         for k, v in date_errors.items():
1230             errors.setdefault(k, []).extend(v)
1231 
1232         if errors:
1233             raise ValidationError(errors)
1234 
1235     def _get_unique_checks(self, exclude=None, include_meta_constraints=False):
1236         """
1237         Return a list of checks to perform. Since validate_unique() could be
1238         called from a ModelForm, some fields may have been excluded; we can't
1239         perform a unique check on a model that is missing fields involved
1240         in that check. Fields that did not validate should also be excluded,
1241         but they need to be passed in via the exclude argument.
1242         """
1243         if exclude is None:
1244             exclude = set()
1245         unique_checks = []
1246 
1247         unique_togethers = [(self.__class__, self._meta.unique_together)]
1248         constraints = []
1249         if include_meta_constraints:
1250             constraints = [(self.__class__, self._meta.total_unique_constraints)]
1251         for parent_class in self._meta.get_parent_list():
1252             if parent_class._meta.unique_together:
1253                 unique_togethers.append(
1254                     (parent_class, parent_class._meta.unique_together)
1255                 )
1256             if include_meta_constraints and parent_class._meta.total_unique_constraints:
1257                 constraints.append(
1258                     (parent_class, parent_class._meta.total_unique_constraints)
1259                 )
1260 
1261         for model_class, unique_together in unique_togethers:
1262             for check in unique_together:
1263                 if not any(name in exclude for name in check):
1264                     # Add the check if the field isn't excluded.
1265                     unique_checks.append((model_class, tuple(check)))
1266 
1267         if include_meta_constraints:
1268             for model_class, model_constraints in constraints:
1269                 for constraint in model_constraints:
1270                     if not any(name in exclude for name in constraint.fields):
1271                         unique_checks.append((model_class, constraint.fields))
1272 
1273         # These are checks for the unique_for_<date/year/month>.
1274         date_checks = []
1275 
1276         # Gather a list of checks for fields declared as unique and add them to
1277         # the list of checks.
1278 
1279         fields_with_class = [(self.__class__, self._meta.local_fields)]
1280         for parent_class in self._meta.get_parent_list():
1281             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1282 
1283         for model_class, fields in fields_with_class:
1284             for f in fields:
1285                 name = f.name
1286                 if name in exclude:
1287                     continue
1288                 if f.unique:
1289                     unique_checks.append((model_class, (name,)))
1290                 if f.unique_for_date and f.unique_for_date not in exclude:
1291                     date_checks.append((model_class, "date", name, f.unique_for_date))
1292                 if f.unique_for_year and f.unique_for_year not in exclude:
1293                     date_checks.append((model_class, "year", name, f.unique_for_year))
1294                 if f.unique_for_month and f.unique_for_month not in exclude:
1295                     date_checks.append((model_class, "month", name, f.unique_for_month))
1296         return unique_checks, date_checks
1297 
1298     def _perform_unique_checks(self, unique_checks):
1299         errors = {}
1300 
1301         for model_class, unique_check in unique_checks:
1302             # Try to look up an existing object with the same values as this
1303             # object's values for all the unique field.
1304 
1305             lookup_kwargs = {}
1306             for field_name in unique_check:
1307                 f = self._meta.get_field(field_name)
1308                 lookup_value = getattr(self, f.attname)
1309                 # TODO: Handle multiple backends with different feature flags.
1310                 if lookup_value is None or (
1311                     lookup_value == ""
1312                     and connection.features.interprets_empty_strings_as_nulls
1313                 ):
1314                     # no value, skip the lookup
1315                     continue
1316                 if f.primary_key and not self._state.adding:
1317                     # no need to check for unique primary key when editing
1318                     continue
1319                 lookup_kwargs[str(field_name)] = lookup_value
1320 
1321             # some fields were skipped, no reason to do the check
1322             if len(unique_check) != len(lookup_kwargs):
1323                 continue
1324 
1325             qs = model_class._default_manager.filter(**lookup_kwargs)
1326 
1327             # Exclude the current object from the query if we are editing an
1328             # instance (as opposed to creating a new one)
1329             # Note that we need to use the pk as defined by model_class, not
1330             # self.pk. These can be different fields because model inheritance
1331             # allows single model to have effectively multiple primary keys.
1332             # Refs #17615.
1333             model_class_pk = self._get_pk_val(model_class._meta)
1334             if not self._state.adding and model_class_pk is not None:
1335                 qs = qs.exclude(pk=model_class_pk)
1336             if qs.exists():
1337                 if len(unique_check) == 1:
1338                     key = unique_check[0]
1339                 else:
1340                     key = NON_FIELD_ERRORS
1341                 errors.setdefault(key, []).append(
1342                     self.unique_error_message(model_class, unique_check)
1343                 )
1344 
1345         return errors
1346 
1347     def _perform_date_checks(self, date_checks):
1348         errors = {}
1349         for model_class, lookup_type, field, unique_for in date_checks:
1350             lookup_kwargs = {}
1351             # there's a ticket to add a date lookup, we can remove this special
1352             # case if that makes it's way in
1353             date = getattr(self, unique_for)
1354             if date is None:
1355                 continue
1356             if lookup_type == "date":
1357                 lookup_kwargs["%s__day" % unique_for] = date.day
1358                 lookup_kwargs["%s__month" % unique_for] = date.month
1359                 lookup_kwargs["%s__year" % unique_for] = date.year
1360             else:
1361                 lookup_kwargs["%s__%s" % (unique_for, lookup_type)] = getattr(
1362                     date, lookup_type
1363                 )
1364             lookup_kwargs[field] = getattr(self, field)
1365 
1366             qs = model_class._default_manager.filter(**lookup_kwargs)
1367             # Exclude the current object from the query if we are editing an
1368             # instance (as opposed to creating a new one)
1369             if not self._state.adding and self.pk is not None:
1370                 qs = qs.exclude(pk=self.pk)
1371 
1372             if qs.exists():
1373                 errors.setdefault(field, []).append(
1374                     self.date_error_message(lookup_type, field, unique_for)
1375                 )
1376         return errors
1377 
1378     def date_error_message(self, lookup_type, field_name, unique_for):
1379         opts = self._meta
1380         field = opts.get_field(field_name)
1381         return ValidationError(
1382             message=field.error_messages["unique_for_date"],
1383             code="unique_for_date",
1384             params={
1385                 "model": self,
1386                 "model_name": capfirst(opts.verbose_name),
1387                 "lookup_type": lookup_type,
1388                 "field": field_name,
1389                 "field_label": capfirst(field.verbose_name),
1390                 "date_field": unique_for,
1391                 "date_field_label": capfirst(opts.get_field(unique_for).verbose_name),
1392             },
1393         )
1394 
1395     def unique_error_message(self, model_class, unique_check):
1396         opts = model_class._meta
1397 
1398         params = {
1399             "model": self,
1400             "model_class": model_class,
1401             "model_name": capfirst(opts.verbose_name),
1402             "unique_check": unique_check,
1403         }
1404 
1405         # A unique field
1406         if len(unique_check) == 1:
1407             field = opts.get_field(unique_check[0])
1408             params["field_label"] = capfirst(field.verbose_name)
1409             return ValidationError(
1410                 message=field.error_messages["unique"],
1411                 code="unique",
1412                 params=params,
1413             )
1414 
1415         # unique_together
1416         else:
1417             field_labels = [
1418                 capfirst(opts.get_field(f).verbose_name) for f in unique_check
1419             ]
1420             params["field_labels"] = get_text_list(field_labels, _("and"))
1421             return ValidationError(
1422                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1423                 code="unique_together",
1424                 params=params,
1425             )
1426 
1427     def get_constraints(self):
1428         constraints = [(self.__class__, self._meta.constraints)]
1429         for parent_class in self._meta.get_parent_list():
1430             if parent_class._meta.constraints:
1431                 constraints.append((parent_class, parent_class._meta.constraints))
1432         return constraints
1433 
1434     def validate_constraints(self, exclude=None):
1435         constraints = self.get_constraints()
1436         using = router.db_for_write(self.__class__, instance=self)
1437 
1438         errors = {}
1439         for model_class, model_constraints in constraints:
1440             for constraint in model_constraints:
1441                 try:
1442                     constraint.validate(model_class, self, exclude=exclude, using=using)
1443                 except ValidationError as e:
1444                     if e.code == "unique" and len(constraint.fields) == 1:
1445                         errors.setdefault(constraint.fields[0], []).append(e)
1446                     else:
1447                         errors = e.update_error_dict(errors)
1448         if errors:
1449             raise ValidationError(errors)
1450 
1451     def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
1452         """
1453         Call clean_fields(), clean(), validate_unique(), and
1454         validate_constraints() on the model. Raise a ValidationError for any
1455         errors that occur.
1456         """
1457         errors = {}
1458         if exclude is None:
1459             exclude = set()
1460         else:
1461             exclude = set(exclude)
1462 
1463         try:
1464             self.clean_fields(exclude=exclude)
1465         except ValidationError as e:
1466             errors = e.update_error_dict(errors)
1467 
1468         # Form.clean() is run even if other validation fails, so do the
1469         # same with Model.clean() for consistency.
1470         try:
1471             self.clean()
1472         except ValidationError as e:
1473             errors = e.update_error_dict(errors)
1474 
1475         # Run unique checks, but only for fields that passed validation.
1476         if validate_unique:
1477             for name in errors:
1478                 if name != NON_FIELD_ERRORS and name not in exclude:
1479                     exclude.add(name)
1480             try:
1481                 self.validate_unique(exclude=exclude)
1482             except ValidationError as e:
1483                 errors = e.update_error_dict(errors)
1484 
1485         # Run constraints checks, but only for fields that passed validation.
1486         if validate_constraints:
1487             for name in errors:
1488                 if name != NON_FIELD_ERRORS and name not in exclude:
1489                     exclude.add(name)
1490             try:
1491                 self.validate_constraints(exclude=exclude)
1492             except ValidationError as e:
1493                 errors = e.update_error_dict(errors)
1494 
1495         if errors:
1496             raise ValidationError(errors)
1497 
1498     def clean_fields(self, exclude=None):
1499         """
1500         Clean all fields and raise a ValidationError containing a dict
1501         of all validation errors if any occur.
1502         """
1503         if exclude is None:
1504             exclude = set()
1505 
1506         errors = {}
1507         for f in self._meta.fields:
1508             if f.name in exclude:
1509                 continue
1510             # Skip validation for empty fields with blank=True. The developer
1511             # is responsible for making sure they have a valid value.
1512             raw_value = getattr(self, f.attname)
1513             if f.blank and raw_value in f.empty_values:
1514                 continue
1515             try:
1516                 setattr(self, f.attname, f.clean(raw_value, self))
1517             except ValidationError as e:
1518                 errors[f.name] = e.error_list
1519 
1520         if errors:
1521             raise ValidationError(errors)
1522 
1523     @classmethod
1524     def check(cls, **kwargs):
1525         errors = [
1526             *cls._check_swappable(),
1527             *cls._check_model(),
1528             *cls._check_managers(**kwargs),
1529         ]
1530         if not cls._meta.swapped:
1531             databases = kwargs.get("databases") or []
1532             errors += [
1533                 *cls._check_fields(**kwargs),
1534                 *cls._check_m2m_through_same_relationship(),
1535                 *cls._check_long_column_names(databases),
1536             ]
1537             clash_errors = (
1538                 *cls._check_id_field(),
1539                 *cls._check_field_name_clashes(),
1540                 *cls._check_model_name_db_lookup_clashes(),
1541                 *cls._check_property_name_related_field_accessor_clashes(),
1542                 *cls._check_single_primary_key(),
1543             )
1544             errors.extend(clash_errors)
1545             # If there are field name clashes, hide consequent column name
1546             # clashes.
1547             if not clash_errors:
1548                 errors.extend(cls._check_column_name_clashes())
1549             errors += [
1550                 *cls._check_index_together(),
1551                 *cls._check_unique_together(),
1552                 *cls._check_indexes(databases),
1553                 *cls._check_ordering(),
1554                 *cls._check_constraints(databases),
1555                 *cls._check_default_pk(),
1556             ]
1557 
1558         return errors
1559 
1560     @classmethod
1561     def _check_default_pk(cls):
1562         if (
1563             not cls._meta.abstract
1564             and cls._meta.pk.auto_created
1565             and
1566             # Inherited PKs are checked in parents models.
1567             not (
1568                 isinstance(cls._meta.pk, OneToOneField)
1569                 and cls._meta.pk.remote_field.parent_link
1570             )
1571             and not settings.is_overridden("DEFAULT_AUTO_FIELD")
1572             and cls._meta.app_config
1573             and not cls._meta.app_config._is_default_auto_field_overridden
1574         ):
1575             return [
1576                 checks.Warning(
1577                     f"Auto-created primary key used when not defining a "
1578                     f"primary key type, by default "
1579                     f"'{settings.DEFAULT_AUTO_FIELD}'.",
1580                     hint=(
1581                         f"Configure the DEFAULT_AUTO_FIELD setting or the "
1582                         f"{cls._meta.app_config.__class__.__qualname__}."
1583                         f"default_auto_field attribute to point to a subclass "
1584                         f"of AutoField, e.g. 'django.db.models.BigAutoField'."
1585                     ),
1586                     obj=cls,
1587                     id="models.W042",
1588                 ),
1589             ]
1590         return []
1591 
1592     @classmethod
1593     def _check_swappable(cls):
1594         """Check if the swapped model exists."""
1595         errors = []
1596         if cls._meta.swapped:
1597             try:
1598                 apps.get_model(cls._meta.swapped)
1599             except ValueError:
1600                 errors.append(
1601                     checks.Error(
1602                         "'%s' is not of the form 'app_label.app_name'."
1603                         % cls._meta.swappable,
1604                         id="models.E001",
1605                     )
1606                 )
1607             except LookupError:
1608                 app_label, model_name = cls._meta.swapped.split(".")
1609                 errors.append(
1610                     checks.Error(
1611                         "'%s' references '%s.%s', which has not been "
1612                         "installed, or is abstract."
1613                         % (cls._meta.swappable, app_label, model_name),
1614                         id="models.E002",
1615                     )
1616                 )
1617         return errors
1618 
1619     @classmethod
1620     def _check_model(cls):
1621         errors = []
1622         if cls._meta.proxy:
1623             if cls._meta.local_fields or cls._meta.local_many_to_many:
1624                 errors.append(
1625                     checks.Error(
1626                         "Proxy model '%s' contains model fields." % cls.__name__,
1627                         id="models.E017",
1628                     )
1629                 )
1630         return errors
1631 
1632     @classmethod
1633     def _check_managers(cls, **kwargs):
1634         """Perform all manager checks."""
1635         errors = []
1636         for manager in cls._meta.managers:
1637             errors.extend(manager.check(**kwargs))
1638         return errors
1639 
1640     @classmethod
1641     def _check_fields(cls, **kwargs):
1642         """Perform all field checks."""
1643         errors = []
1644         for field in cls._meta.local_fields:
1645             errors.extend(field.check(**kwargs))
1646         for field in cls._meta.local_many_to_many:
1647             errors.extend(field.check(from_model=cls, **kwargs))
1648         return errors
1649 
1650     @classmethod
1651     def _check_m2m_through_same_relationship(cls):
1652         """Check if no relationship model is used by more than one m2m field."""
1653 
1654         errors = []
1655         seen_intermediary_signatures = []
1656 
1657         fields = cls._meta.local_many_to_many
1658 
1659         # Skip when the target model wasn't found.
1660         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1661 
1662         # Skip when the relationship model wasn't found.
1663         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1664 
1665         for f in fields:
1666             signature = (
1667                 f.remote_field.model,
1668                 cls,
1669                 f.remote_field.through,
1670                 f.remote_field.through_fields,
1671             )
1672             if signature in seen_intermediary_signatures:
1673                 errors.append(
1674                     checks.Error(
1675                         "The model has two identical many-to-many relations "
1676                         "through the intermediate model '%s'."
1677                         % f.remote_field.through._meta.label,
1678                         obj=cls,
1679                         id="models.E003",
1680                     )
1681                 )
1682             else:
1683                 seen_intermediary_signatures.append(signature)
1684         return errors
1685 
1686     @classmethod
1687     def _check_id_field(cls):
1688         """Check if `id` field is a primary key."""
1689         fields = [
1690             f for f in cls._meta.local_fields if f.name == "id" and f != cls._meta.pk
1691         ]
1692         # fields is empty or consists of the invalid "id" field
1693         if fields and not fields[0].primary_key and cls._meta.pk.name == "id":
1694             return [
1695                 checks.Error(
1696                     "'id' can only be used as a field name if the field also "
1697                     "sets 'primary_key=True'.",
1698                     obj=cls,
1699                     id="models.E004",
1700                 )
1701             ]
1702         else:
1703             return []
1704 
1705     @classmethod
1706     def _check_field_name_clashes(cls):
1707         """Forbid field shadowing in multi-table inheritance."""
1708         errors = []
1709         used_fields = {}  # name or attname -> field
1710 
1711         # Check that multi-inheritance doesn't cause field name shadowing.
1712         for parent in cls._meta.get_parent_list():
1713             for f in parent._meta.local_fields:
1714                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1715                 if clash:
1716                     errors.append(
1717                         checks.Error(
1718                             "The field '%s' from parent model "
1719                             "'%s' clashes with the field '%s' "
1720                             "from parent model '%s'."
1721                             % (clash.name, clash.model._meta, f.name, f.model._meta),
1722                             obj=cls,
1723                             id="models.E005",
1724                         )
1725                     )
1726                 used_fields[f.name] = f
1727                 used_fields[f.attname] = f
1728 
1729         # Check that fields defined in the model don't clash with fields from
1730         # parents, including auto-generated fields like multi-table inheritance
1731         # child accessors.
1732         for parent in cls._meta.get_parent_list():
1733             for f in parent._meta.get_fields():
1734                 if f not in used_fields:
1735                     used_fields[f.name] = f
1736 
1737         for f in cls._meta.local_fields:
1738             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1739             # Note that we may detect clash between user-defined non-unique
1740             # field "id" and automatically added unique field "id", both
1741             # defined at the same model. This special case is considered in
1742             # _check_id_field and here we ignore it.
1743             id_conflict = (
1744                 f.name == "id" and clash and clash.name == "id" and clash.model == cls
1745             )
1746             if clash and not id_conflict:
1747                 errors.append(
1748                     checks.Error(
1749                         "The field '%s' clashes with the field '%s' "
1750                         "from model '%s'." % (f.name, clash.name, clash.model._meta),
1751                         obj=f,
1752                         id="models.E006",
1753                     )
1754                 )
1755             used_fields[f.name] = f
1756             used_fields[f.attname] = f
1757 
1758         return errors
1759 
1760     @classmethod
1761     def _check_column_name_clashes(cls):
1762         # Store a list of column names which have already been used by other fields.
1763         used_column_names = []
1764         errors = []
1765 
1766         for f in cls._meta.local_fields:
1767             _, column_name = f.get_attname_column()
1768 
1769             # Ensure the column name is not already in use.
1770             if column_name and column_name in used_column_names:
1771                 errors.append(
1772                     checks.Error(
1773                         "Field '%s' has column name '%s' that is used by "
1774                         "another field." % (f.name, column_name),
1775                         hint="Specify a 'db_column' for the field.",
1776                         obj=cls,
1777                         id="models.E007",
1778                     )
1779                 )
1780             else:
1781                 used_column_names.append(column_name)
1782 
1783         return errors
1784 
1785     @classmethod
1786     def _check_model_name_db_lookup_clashes(cls):
1787         errors = []
1788         model_name = cls.__name__
1789         if model_name.startswith("_") or model_name.endswith("_"):
1790             errors.append(
1791                 checks.Error(
1792                     "The model name '%s' cannot start or end with an underscore "
1793                     "as it collides with the query lookup syntax." % model_name,
1794                     obj=cls,
1795                     id="models.E023",
1796                 )
1797             )
1798         elif LOOKUP_SEP in model_name:
1799             errors.append(
1800                 checks.Error(
1801                     "The model name '%s' cannot contain double underscores as "
1802                     "it collides with the query lookup syntax." % model_name,
1803                     obj=cls,
1804                     id="models.E024",
1805                 )
1806             )
1807         return errors
1808 
1809     @classmethod
1810     def _check_property_name_related_field_accessor_clashes(cls):
1811         errors = []
1812         property_names = cls._meta._property_names
1813         related_field_accessors = (
1814             f.get_attname()
1815             for f in cls._meta._get_fields(reverse=False)
1816             if f.is_relation and f.related_model is not None
1817         )
1818         for accessor in related_field_accessors:
1819             if accessor in property_names:
1820                 errors.append(
1821                     checks.Error(
1822                         "The property '%s' clashes with a related field "
1823                         "accessor." % accessor,
1824                         obj=cls,
1825                         id="models.E025",
1826                     )
1827                 )
1828         return errors
1829 
1830     @classmethod
1831     def _check_single_primary_key(cls):
1832         errors = []
1833         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1834             errors.append(
1835                 checks.Error(
1836                     "The model cannot have more than one field with "
1837                     "'primary_key=True'.",
1838                     obj=cls,
1839                     id="models.E026",
1840                 )
1841             )
1842         return errors
1843 
1844     @classmethod
1845     def _check_index_together(cls):
1846         """Check the value of "index_together" option."""
1847         if not isinstance(cls._meta.index_together, (tuple, list)):
1848             return [
1849                 checks.Error(
1850                     "'index_together' must be a list or tuple.",
1851                     obj=cls,
1852                     id="models.E008",
1853                 )
1854             ]
1855 
1856         elif any(
1857             not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together
1858         ):
1859             return [
1860                 checks.Error(
1861                     "All 'index_together' elements must be lists or tuples.",
1862                     obj=cls,
1863                     id="models.E009",
1864                 )
1865             ]
1866 
1867         else:
1868             errors = []
1869             for fields in cls._meta.index_together:
1870                 errors.extend(cls._check_local_fields(fields, "index_together"))
1871             return errors
1872 
1873     @classmethod
1874     def _check_unique_together(cls):
1875         """Check the value of "unique_together" option."""
1876         if not isinstance(cls._meta.unique_together, (tuple, list)):
1877             return [
1878                 checks.Error(
1879                     "'unique_together' must be a list or tuple.",
1880                     obj=cls,
1881                     id="models.E010",
1882                 )
1883             ]
1884 
1885         elif any(
1886             not isinstance(fields, (tuple, list))
1887             for fields in cls._meta.unique_together
1888         ):
1889             return [
1890                 checks.Error(
1891                     "All 'unique_together' elements must be lists or tuples.",
1892                     obj=cls,
1893                     id="models.E011",
1894                 )
1895             ]
1896 
1897         else:
1898             errors = []
1899             for fields in cls._meta.unique_together:
1900                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1901             return errors
1902 
1903     @classmethod
1904     def _check_indexes(cls, databases):
1905         """Check fields, names, and conditions of indexes."""
1906         errors = []
1907         references = set()
1908         for index in cls._meta.indexes:
1909             # Index name can't start with an underscore or a number, restricted
1910             # for cross-database compatibility with Oracle.
1911             if index.name[0] == "_" or index.name[0].isdigit():
1912                 errors.append(
1913                     checks.Error(
1914                         "The index name '%s' cannot start with an underscore "
1915                         "or a number." % index.name,
1916                         obj=cls,
1917                         id="models.E033",
1918                     ),
1919                 )
1920             if len(index.name) > index.max_name_length:
1921                 errors.append(
1922                     checks.Error(
1923                         "The index name '%s' cannot be longer than %d "
1924                         "characters." % (index.name, index.max_name_length),
1925                         obj=cls,
1926                         id="models.E034",
1927                     ),
1928                 )
1929             if index.contains_expressions:
1930                 for expression in index.expressions:
1931                     references.update(
1932                         ref[0] for ref in cls._get_expr_references(expression)
1933                     )
1934         for db in databases:
1935             if not router.allow_migrate_model(db, cls):
1936                 continue
1937             connection = connections[db]
1938             if not (
1939                 connection.features.supports_partial_indexes
1940                 or "supports_partial_indexes" in cls._meta.required_db_features
1941             ) and any(index.condition is not None for index in cls._meta.indexes):
1942                 errors.append(
1943                     checks.Warning(
1944                         "%s does not support indexes with conditions."
1945                         % connection.display_name,
1946                         hint=(
1947                             "Conditions will be ignored. Silence this warning "
1948                             "if you don't care about it."
1949                         ),
1950                         obj=cls,
1951                         id="models.W037",
1952                     )
1953                 )
1954             if not (
1955                 connection.features.supports_covering_indexes
1956                 or "supports_covering_indexes" in cls._meta.required_db_features
1957             ) and any(index.include for index in cls._meta.indexes):
1958                 errors.append(
1959                     checks.Warning(
1960                         "%s does not support indexes with non-key columns."
1961                         % connection.display_name,
1962                         hint=(
1963                             "Non-key columns will be ignored. Silence this "
1964                             "warning if you don't care about it."
1965                         ),
1966                         obj=cls,
1967                         id="models.W040",
1968                     )
1969                 )
1970             if not (
1971                 connection.features.supports_expression_indexes
1972                 or "supports_expression_indexes" in cls._meta.required_db_features
1973             ) and any(index.contains_expressions for index in cls._meta.indexes):
1974                 errors.append(
1975                     checks.Warning(
1976                         "%s does not support indexes on expressions."
1977                         % connection.display_name,
1978                         hint=(
1979                             "An index won't be created. Silence this warning "
1980                             "if you don't care about it."
1981                         ),
1982                         obj=cls,
1983                         id="models.W043",
1984                     )
1985                 )
1986         fields = [
1987             field for index in cls._meta.indexes for field, _ in index.fields_orders
1988         ]
1989         fields += [include for index in cls._meta.indexes for include in index.include]
1990         fields += references
1991         errors.extend(cls._check_local_fields(fields, "indexes"))
1992         return errors
1993 
1994     @classmethod
1995     def _check_local_fields(cls, fields, option):
1996         from django.db import models
1997 
1998         # In order to avoid hitting the relation tree prematurely, we use our
1999         # own fields_map instead of using get_field()
2000         forward_fields_map = {}
2001         for field in cls._meta._get_fields(reverse=False):
2002             forward_fields_map[field.name] = field
2003             if hasattr(field, "attname"):
2004                 forward_fields_map[field.attname] = field
2005 
2006         errors = []
2007         for field_name in fields:
2008             try:
2009                 field = forward_fields_map[field_name]
2010             except KeyError:
2011                 errors.append(
2012                     checks.Error(
2013                         "'%s' refers to the nonexistent field '%s'."
2014                         % (
2015                             option,
2016                             field_name,
2017                         ),
2018                         obj=cls,
2019                         id="models.E012",
2020                     )
2021                 )
2022             else:
2023                 if isinstance(field.remote_field, models.ManyToManyRel):
2024                     errors.append(
2025                         checks.Error(
2026                             "'%s' refers to a ManyToManyField '%s', but "
2027                             "ManyToManyFields are not permitted in '%s'."
2028                             % (
2029                                 option,
2030                                 field_name,
2031                                 option,
2032                             ),
2033                             obj=cls,
2034                             id="models.E013",
2035                         )
2036                     )
2037                 elif field not in cls._meta.local_fields:
2038                     errors.append(
2039                         checks.Error(
2040                             "'%s' refers to field '%s' which is not local to model "
2041                             "'%s'." % (option, field_name, cls._meta.object_name),
2042                             hint="This issue may be caused by multi-table inheritance.",
2043                             obj=cls,
2044                             id="models.E016",
2045                         )
2046                     )
2047         return errors
2048 
2049     @classmethod
2050     def _check_ordering(cls):
2051         """
2052         Check "ordering" option -- is it a list of strings and do all fields
2053         exist?
2054         """
2055         if cls._meta._ordering_clash:
2056             return [
2057                 checks.Error(
2058                     "'ordering' and 'order_with_respect_to' cannot be used together.",
2059                     obj=cls,
2060                     id="models.E021",
2061                 ),
2062             ]
2063 
2064         if cls._meta.order_with_respect_to or not cls._meta.ordering:
2065             return []
2066 
2067         if not isinstance(cls._meta.ordering, (list, tuple)):
2068             return [
2069                 checks.Error(
2070                     "'ordering' must be a tuple or list (even if you want to order by "
2071                     "only one field).",
2072                     obj=cls,
2073                     id="models.E014",
2074                 )
2075             ]
2076 
2077         errors = []
2078         fields = cls._meta.ordering
2079 
2080         # Skip expressions and '?' fields.
2081         fields = (f for f in fields if isinstance(f, str) and f != "?")
2082 
2083         # Convert "-field" to "field".
2084         fields = ((f[1:] if f.startswith("-") else f) for f in fields)
2085 
2086         # Separate related fields and non-related fields.
2087         _fields = []
2088         related_fields = []
2089         for f in fields:
2090             if LOOKUP_SEP in f:
2091                 related_fields.append(f)
2092             else:
2093                 _fields.append(f)
2094         fields = _fields
2095 
2096         # Check related fields.
2097         for field in related_fields:
2098             _cls = cls
2099             fld = None
2100             for part in field.split(LOOKUP_SEP):
2101                 try:
2102                     # pk is an alias that won't be found by opts.get_field.
2103                     if part == "pk":
2104                         fld = _cls._meta.pk
2105                     else:
2106                         fld = _cls._meta.get_field(part)
2107                     if fld.is_relation:
2108                         _cls = fld.path_infos[-1].to_opts.model
2109                     else:
2110                         _cls = None
2111                 except (FieldDoesNotExist, AttributeError):
2112                     if fld is None or (
2113                         fld.get_transform(part) is None and fld.get_lookup(part) is None
2114                     ):
2115                         errors.append(
2116                             checks.Error(
2117                                 "'ordering' refers to the nonexistent field, "
2118                                 "related field, or lookup '%s'." % field,
2119                                 obj=cls,
2120                                 id="models.E015",
2121                             )
2122                         )
2123 
2124         # Skip ordering on pk. This is always a valid order_by field
2125         # but is an alias and therefore won't be found by opts.get_field.
2126         fields = {f for f in fields if f != "pk"}
2127 
2128         # Check for invalid or nonexistent fields in ordering.
2129         invalid_fields = []
2130 
2131         # Any field name that is not present in field_names does not exist.
2132         # Also, ordering by m2m fields is not allowed.
2133         opts = cls._meta
2134         valid_fields = set(
2135             chain.from_iterable(
2136                 (f.name, f.attname)
2137                 if not (f.auto_created and not f.concrete)
2138                 else (f.field.related_query_name(),)
2139                 for f in chain(opts.fields, opts.related_objects)
2140             )
2141         )
2142 
2143         invalid_fields.extend(fields - valid_fields)
2144 
2145         for invalid_field in invalid_fields:
2146             errors.append(
2147                 checks.Error(
2148                     "'ordering' refers to the nonexistent field, related "
2149                     "field, or lookup '%s'." % invalid_field,
2150                     obj=cls,
2151                     id="models.E015",
2152                 )
2153             )
2154         return errors
2155 
2156     @classmethod
2157     def _check_long_column_names(cls, databases):
2158         """
2159         Check that any auto-generated column names are shorter than the limits
2160         for each database in which the model will be created.
2161         """
2162         if not databases:
2163             return []
2164         errors = []
2165         allowed_len = None
2166         db_alias = None
2167 
2168         # Find the minimum max allowed length among all specified db_aliases.
2169         for db in databases:
2170             # skip databases where the model won't be created
2171             if not router.allow_migrate_model(db, cls):
2172                 continue
2173             connection = connections[db]
2174             max_name_length = connection.ops.max_name_length()
2175             if max_name_length is None or connection.features.truncates_names:
2176                 continue
2177             else:
2178                 if allowed_len is None:
2179                     allowed_len = max_name_length
2180                     db_alias = db
2181                 elif max_name_length < allowed_len:
2182                     allowed_len = max_name_length
2183                     db_alias = db
2184 
2185         if allowed_len is None:
2186             return errors
2187 
2188         for f in cls._meta.local_fields:
2189             _, column_name = f.get_attname_column()
2190 
2191             # Check if auto-generated name for the field is too long
2192             # for the database.
2193             if (
2194                 f.db_column is None
2195                 and column_name is not None
2196                 and len(column_name) > allowed_len
2197             ):
2198                 errors.append(
2199                     checks.Error(
2200                         'Autogenerated column name too long for field "%s". '
2201                         'Maximum length is "%s" for database "%s".'
2202                         % (column_name, allowed_len, db_alias),
2203                         hint="Set the column name manually using 'db_column'.",
2204                         obj=cls,
2205                         id="models.E018",
2206                     )
2207                 )
2208 
2209         for f in cls._meta.local_many_to_many:
2210             # Skip nonexistent models.
2211             if isinstance(f.remote_field.through, str):
2212                 continue
2213 
2214             # Check if auto-generated name for the M2M field is too long
2215             # for the database.
2216             for m2m in f.remote_field.through._meta.local_fields:
2217                 _, rel_name = m2m.get_attname_column()
2218                 if (
2219                     m2m.db_column is None
2220                     and rel_name is not None
2221                     and len(rel_name) > allowed_len
2222                 ):
2223                     errors.append(
2224                         checks.Error(
2225                             "Autogenerated column name too long for M2M field "
2226                             '"%s". Maximum length is "%s" for database "%s".'
2227                             % (rel_name, allowed_len, db_alias),
2228                             hint=(
2229                                 "Use 'through' to create a separate model for "
2230                                 "M2M and then set column_name using 'db_column'."
2231                             ),
2232                             obj=cls,
2233                             id="models.E019",
2234                         )
2235                     )
2236 
2237         return errors
2238 
2239     @classmethod
2240     def _get_expr_references(cls, expr):
2241         if isinstance(expr, Q):
2242             for child in expr.children:
2243                 if isinstance(child, tuple):
2244                     lookup, value = child
2245                     yield tuple(lookup.split(LOOKUP_SEP))
2246                     yield from cls._get_expr_references(value)
2247                 else:
2248                     yield from cls._get_expr_references(child)
2249         elif isinstance(expr, F):
2250             yield tuple(expr.name.split(LOOKUP_SEP))
2251         elif hasattr(expr, "get_source_expressions"):
2252             for src_expr in expr.get_source_expressions():
2253                 yield from cls._get_expr_references(src_expr)
2254 
2255     @classmethod
2256     def _check_constraints(cls, databases):
2257         errors = []
2258         for db in databases:
2259             if not router.allow_migrate_model(db, cls):
2260                 continue
2261             connection = connections[db]
2262             if not (
2263                 connection.features.supports_table_check_constraints
2264                 or "supports_table_check_constraints" in cls._meta.required_db_features
2265             ) and any(
2266                 isinstance(constraint, CheckConstraint)
2267                 for constraint in cls._meta.constraints
2268             ):
2269                 errors.append(
2270                     checks.Warning(
2271                         "%s does not support check constraints."
2272                         % connection.display_name,
2273                         hint=(
2274                             "A constraint won't be created. Silence this "
2275                             "warning if you don't care about it."
2276                         ),
2277                         obj=cls,
2278                         id="models.W027",
2279                     )
2280                 )
2281             if not (
2282                 connection.features.supports_partial_indexes
2283                 or "supports_partial_indexes" in cls._meta.required_db_features
2284             ) and any(
2285                 isinstance(constraint, UniqueConstraint)
2286                 and constraint.condition is not None
2287                 for constraint in cls._meta.constraints
2288             ):
2289                 errors.append(
2290                     checks.Warning(
2291                         "%s does not support unique constraints with "
2292                         "conditions." % connection.display_name,
2293                         hint=(
2294                             "A constraint won't be created. Silence this "
2295                             "warning if you don't care about it."
2296                         ),
2297                         obj=cls,
2298                         id="models.W036",
2299                     )
2300                 )
2301             if not (
2302                 connection.features.supports_deferrable_unique_constraints
2303                 or "supports_deferrable_unique_constraints"
2304                 in cls._meta.required_db_features
2305             ) and any(
2306                 isinstance(constraint, UniqueConstraint)
2307                 and constraint.deferrable is not None
2308                 for constraint in cls._meta.constraints
2309             ):
2310                 errors.append(
2311                     checks.Warning(
2312                         "%s does not support deferrable unique constraints."
2313                         % connection.display_name,
2314                         hint=(
2315                             "A constraint won't be created. Silence this "
2316                             "warning if you don't care about it."
2317                         ),
2318                         obj=cls,
2319                         id="models.W038",
2320                     )
2321                 )
2322             if not (
2323                 connection.features.supports_covering_indexes
2324                 or "supports_covering_indexes" in cls._meta.required_db_features
2325             ) and any(
2326                 isinstance(constraint, UniqueConstraint) and constraint.include
2327                 for constraint in cls._meta.constraints
2328             ):
2329                 errors.append(
2330                     checks.Warning(
2331                         "%s does not support unique constraints with non-key "
2332                         "columns." % connection.display_name,
2333                         hint=(
2334                             "A constraint won't be created. Silence this "
2335                             "warning if you don't care about it."
2336                         ),
2337                         obj=cls,
2338                         id="models.W039",
2339                     )
2340                 )
2341             if not (
2342                 connection.features.supports_expression_indexes
2343                 or "supports_expression_indexes" in cls._meta.required_db_features
2344             ) and any(
2345                 isinstance(constraint, UniqueConstraint)
2346                 and constraint.contains_expressions
2347                 for constraint in cls._meta.constraints
2348             ):
2349                 errors.append(
2350                     checks.Warning(
2351                         "%s does not support unique constraints on "
2352                         "expressions." % connection.display_name,
2353                         hint=(
2354                             "A constraint won't be created. Silence this "
2355                             "warning if you don't care about it."
2356                         ),
2357                         obj=cls,
2358                         id="models.W044",
2359                     )
2360                 )
2361             fields = set(
2362                 chain.from_iterable(
2363                     (*constraint.fields, *constraint.include)
2364                     for constraint in cls._meta.constraints
2365                     if isinstance(constraint, UniqueConstraint)
2366                 )
2367             )
2368             references = set()
2369             for constraint in cls._meta.constraints:
2370                 if isinstance(constraint, UniqueConstraint):
2371                     if (
2372                         connection.features.supports_partial_indexes
2373                         or "supports_partial_indexes"
2374                         not in cls._meta.required_db_features
2375                     ) and isinstance(constraint.condition, Q):
2376                         references.update(
2377                             cls._get_expr_references(constraint.condition)
2378                         )
2379                     if (
2380                         connection.features.supports_expression_indexes
2381                         or "supports_expression_indexes"
2382                         not in cls._meta.required_db_features
2383                     ) and constraint.contains_expressions:
2384                         for expression in constraint.expressions:
2385                             references.update(cls._get_expr_references(expression))
2386                 elif isinstance(constraint, CheckConstraint):
2387                     if (
2388                         connection.features.supports_table_check_constraints
2389                         or "supports_table_check_constraints"
2390                         not in cls._meta.required_db_features
2391                     ):
2392                         if isinstance(constraint.check, Q):
2393                             references.update(
2394                                 cls._get_expr_references(constraint.check)
2395                             )
2396                         if any(
2397                             isinstance(expr, RawSQL)
2398                             for expr in constraint.check.flatten()
2399                         ):
2400                             errors.append(
2401                                 checks.Warning(
2402                                     f"Check constraint {constraint.name!r} contains "
2403                                     f"RawSQL() expression and won't be validated "
2404                                     f"during the model full_clean().",
2405                                     hint=(
2406                                         "Silence this warning if you don't care about "
2407                                         "it."
2408                                     ),
2409                                     obj=cls,
2410                                     id="models.W045",
2411                                 ),
2412                             )
2413             for field_name, *lookups in references:
2414                 # pk is an alias that won't be found by opts.get_field.
2415                 if field_name != "pk":
2416                     fields.add(field_name)
2417                 if not lookups:
2418                     # If it has no lookups it cannot result in a JOIN.
2419                     continue
2420                 try:
2421                     if field_name == "pk":
2422                         field = cls._meta.pk
2423                     else:
2424                         field = cls._meta.get_field(field_name)
2425                     if not field.is_relation or field.many_to_many or field.one_to_many:
2426                         continue
2427                 except FieldDoesNotExist:
2428                     continue
2429                 # JOIN must happen at the first lookup.
2430                 first_lookup = lookups[0]
2431                 if (
2432                     hasattr(field, "get_transform")
2433                     and hasattr(field, "get_lookup")
2434                     and field.get_transform(first_lookup) is None
2435                     and field.get_lookup(first_lookup) is None
2436                 ):
2437                     errors.append(
2438                         checks.Error(
2439                             "'constraints' refers to the joined field '%s'."
2440                             % LOOKUP_SEP.join([field_name] + lookups),
2441                             obj=cls,
2442                             id="models.E041",
2443                         )
2444                     )
2445             errors.extend(cls._check_local_fields(fields, "constraints"))
2446         return errors

</code><intended_behavior>Ensure construction of model indexes using `Index` instances from the `indexes` list without relying on `index_together`. Legacy handling of `index_together` should be migrated internally to use `Index` instances for backward compatibility.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             index_together = model_state.options.pop("index_together", None)
620             order_with_respect_to = model_state.options.pop(
621                 "order_with_respect_to", None
622             )
623             # Depend on the deletion of any possible proxy version of us
624             dependencies = [
625                 (app_label, model_name, None, False),
626             ]
627             # Depend on all bases
628             for base in model_state.bases:
629                 if isinstance(base, str) and "." in base:
630                     base_app_label, base_name = base.split(".", 1)
631                     dependencies.append((base_app_label, base_name, None, True))
632                     # Depend on the removal of base fields if the new model has
633                     # a field with the same name.
634                     old_base_model_state = self.from_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     new_base_model_state = self.to_state.models.get(
638                         (base_app_label, base_name)
639                     )
640                     if old_base_model_state and new_base_model_state:
641                         removed_base_fields = (
642                             set(old_base_model_state.fields)
643                             .difference(
644                                 new_base_model_state.fields,
645                             )
646                             .intersection(model_state.fields)
647                         )
648                         for removed_base_field in removed_base_fields:
649                             dependencies.append(
650                                 (base_app_label, base_name, removed_base_field, False)
651                             )
652             # Depend on the other end of the primary key if it's a relation
653             if primary_key_rel:
654                 dependencies.append(
655                     resolve_relation(
656                         primary_key_rel,
657                         app_label,
658                         model_name,
659                     )
660                     + (None, True)
661                 )
662             # Generate creation operation
663             self.add_operation(
664                 app_label,
665                 operations.CreateModel(
666                     name=model_state.name,
667                     fields=[
668                         d
669                         for d in model_state.fields.items()
670                         if d[0] not in related_fields
671                     ],
672                     options=model_state.options,
673                     bases=model_state.bases,
674                     managers=model_state.managers,
675                 ),
676                 dependencies=dependencies,
677                 beginning=True,
678             )
679 
680             # Don't add operations which modify the database for unmanaged models
681             if not model_state.options.get("managed", True):
682                 continue
683 
684             # Generate operations for each related field
685             for name, field in sorted(related_fields.items()):
686                 dependencies = self._get_dependencies_for_foreign_key(
687                     app_label,
688                     model_name,
689                     field,
690                     self.to_state,
691                 )
692                 # Depend on our own model being created
693                 dependencies.append((app_label, model_name, None, True))
694                 # Make operation
695                 self.add_operation(
696                     app_label,
697                     operations.AddField(
698                         model_name=model_name,
699                         name=name,
700                         field=field,
701                     ),
702                     dependencies=list(set(dependencies)),
703                 )
704             # Generate other opns
705             if order_with_respect_to:
706                 self.add_operation(
707                     app_label,
708                     operations.AlterOrderWithRespectTo(
709                         name=model_name,
710                         order_with_respect_to=order_with_respect_to,
711                     ),
712                     dependencies=[
713                         (app_label, model_name, order_with_respect_to, True),
714                         (app_label, model_name, None, True),
715                     ],
716                 )
717             related_dependencies = [
718                 (app_label, model_name, name, True) for name in sorted(related_fields)
719             ]
720             related_dependencies.append((app_label, model_name, None, True))
721             for index in indexes:
722                 self.add_operation(
723                     app_label,
724                     operations.AddIndex(
725                         model_name=model_name,
726                         index=index,
727                     ),
728                     dependencies=related_dependencies,
729                 )
730             for constraint in constraints:
731                 self.add_operation(
732                     app_label,
733                     operations.AddConstraint(
734                         model_name=model_name,
735                         constraint=constraint,
736                     ),
737                     dependencies=related_dependencies,
738                 )
739             if unique_together:
740                 self.add_operation(
741                     app_label,
742                     operations.AlterUniqueTogether(
743                         name=model_name,
744                         unique_together=unique_together,
745                     ),
746                     dependencies=related_dependencies,
747                 )
748             if index_together:
749                 self.add_operation(
750                     app_label,
751                     operations.AlterIndexTogether(
752                         name=model_name,
753                         index_together=index_together,
754                     ),
755                     dependencies=related_dependencies,
756                 )
757             # Fix relationships if the model changed from a proxy model to a
758             # concrete model.
759             relations = self.to_state.relations
760             if (app_label, model_name) in self.old_proxy_keys:
761                 for related_model_key, related_fields in relations[
762                     app_label, model_name
763                 ].items():
764                     related_model_state = self.to_state.models[related_model_key]
765                     for related_field_name, related_field in related_fields.items():
766                         self.add_operation(
767                             related_model_state.app_label,
768                             operations.AlterField(
769                                 model_name=related_model_state.name,
770                                 name=related_field_name,
771                                 field=related_field,
772                             ),
773                             dependencies=[(app_label, model_name, None, True)],
774                         )
775 
776     def generate_created_proxies(self):
777         """
778         Make CreateModel statements for proxy models. Use the same statements
779         as that way there's less code duplication, but for proxy models it's
780         safe to skip all the pointless field stuff and chuck out an operation.
781         """
782         added = self.new_proxy_keys - self.old_proxy_keys
783         for app_label, model_name in sorted(added):
784             model_state = self.to_state.models[app_label, model_name]
785             assert model_state.options.get("proxy")
786             # Depend on the deletion of any possible non-proxy version of us
787             dependencies = [
788                 (app_label, model_name, None, False),
789             ]
790             # Depend on all bases
791             for base in model_state.bases:
792                 if isinstance(base, str) and "." in base:
793                     base_app_label, base_name = base.split(".", 1)
794                     dependencies.append((base_app_label, base_name, None, True))
795             # Generate creation operation
796             self.add_operation(
797                 app_label,
798                 operations.CreateModel(
799                     name=model_state.name,
800                     fields=[],
801                     options=model_state.options,
802                     bases=model_state.bases,
803                     managers=model_state.managers,
804                 ),
805                 # Depend on the deletion of any possible non-proxy version of us
806                 dependencies=dependencies,
807             )
808 
809     def generate_deleted_models(self):
810         """
811         Find all deleted models (managed and unmanaged) and make delete
812         operations for them as well as separate operations to delete any
813         foreign key or M2M relationships (these are optimized later, if
814         possible).
815 
816         Also bring forward removal of any model options that refer to
817         collections of fields - the inverse of generate_created_models().
818         """
819         new_keys = self.new_model_keys | self.new_unmanaged_keys
820         deleted_models = self.old_model_keys - new_keys
821         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
822         all_deleted_models = chain(
823             sorted(deleted_models), sorted(deleted_unmanaged_models)
824         )
825         for app_label, model_name in all_deleted_models:
826             model_state = self.from_state.models[app_label, model_name]
827             # Gather related fields
828             related_fields = {}
829             for field_name, field in model_state.fields.items():
830                 if field.remote_field:
831                     if field.remote_field.model:
832                         related_fields[field_name] = field
833                     if getattr(field.remote_field, "through", None):
834                         related_fields[field_name] = field
835             # Generate option removal first
836             unique_together = model_state.options.pop("unique_together", None)
837             index_together = model_state.options.pop("index_together", None)
838             if unique_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterUniqueTogether(
842                         name=model_name,
843                         unique_together=None,
844                     ),
845                 )
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 remote_field_model,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     def generate_removed_altered_index_together(self):
1504         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1505 
1506     def _generate_altered_foo_together(self, operation):
1507         for (
1508             old_value,
1509             new_value,
1510             app_label,
1511             model_name,
1512             dependencies,
1513         ) in self._get_altered_foo_together_operations(operation.option_name):
1514             removal_value = new_value.intersection(old_value)
1515             if new_value != removal_value:
1516                 self.add_operation(
1517                     app_label,
1518                     operation(name=model_name, **{operation.option_name: new_value}),
1519                     dependencies=dependencies,
1520                 )
1521 
1522     def generate_altered_unique_together(self):
1523         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1524 
1525     def generate_altered_index_together(self):
1526         self._generate_altered_foo_together(operations.AlterIndexTogether)
1527 
1528     def generate_altered_db_table(self):
1529         models_to_check = self.kept_model_keys.union(
1530             self.kept_proxy_keys, self.kept_unmanaged_keys
1531         )
1532         for app_label, model_name in sorted(models_to_check):
1533             old_model_name = self.renamed_models.get(
1534                 (app_label, model_name), model_name
1535             )
1536             old_model_state = self.from_state.models[app_label, old_model_name]
1537             new_model_state = self.to_state.models[app_label, model_name]
1538             old_db_table_name = old_model_state.options.get("db_table")
1539             new_db_table_name = new_model_state.options.get("db_table")
1540             if old_db_table_name != new_db_table_name:
1541                 self.add_operation(
1542                     app_label,
1543                     operations.AlterModelTable(
1544                         name=model_name,
1545                         table=new_db_table_name,
1546                     ),
1547                 )
1548 
1549     def generate_altered_options(self):
1550         """
1551         Work out if any non-schema-affecting options have changed and make an
1552         operation to represent them in state changes (in case Python code in
1553         migrations needs them).
1554         """
1555         models_to_check = self.kept_model_keys.union(
1556             self.kept_proxy_keys,
1557             self.kept_unmanaged_keys,
1558             # unmanaged converted to managed
1559             self.old_unmanaged_keys & self.new_model_keys,
1560             # managed converted to unmanaged
1561             self.old_model_keys & self.new_unmanaged_keys,
1562         )
1563 
1564         for app_label, model_name in sorted(models_to_check):
1565             old_model_name = self.renamed_models.get(
1566                 (app_label, model_name), model_name
1567             )
1568             old_model_state = self.from_state.models[app_label, old_model_name]
1569             new_model_state = self.to_state.models[app_label, model_name]
1570             old_options = {
1571                 key: value
1572                 for key, value in old_model_state.options.items()
1573                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1574             }
1575             new_options = {
1576                 key: value
1577                 for key, value in new_model_state.options.items()
1578                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1579             }
1580             if old_options != new_options:
1581                 self.add_operation(
1582                     app_label,
1583                     operations.AlterModelOptions(
1584                         name=model_name,
1585                         options=new_options,
1586                     ),
1587                 )
1588 
1589     def generate_altered_order_with_respect_to(self):
1590         for app_label, model_name in sorted(self.kept_model_keys):
1591             old_model_name = self.renamed_models.get(
1592                 (app_label, model_name), model_name
1593             )
1594             old_model_state = self.from_state.models[app_label, old_model_name]
1595             new_model_state = self.to_state.models[app_label, model_name]
1596             if old_model_state.options.get(
1597                 "order_with_respect_to"
1598             ) != new_model_state.options.get("order_with_respect_to"):
1599                 # Make sure it comes second if we're adding
1600                 # (removal dependency is part of RemoveField)
1601                 dependencies = []
1602                 if new_model_state.options.get("order_with_respect_to"):
1603                     dependencies.append(
1604                         (
1605                             app_label,
1606                             model_name,
1607                             new_model_state.options["order_with_respect_to"],
1608                             True,
1609                         )
1610                     )
1611                 # Actually generate the operation
1612                 self.add_operation(
1613                     app_label,
1614                     operations.AlterOrderWithRespectTo(
1615                         name=model_name,
1616                         order_with_respect_to=new_model_state.options.get(
1617                             "order_with_respect_to"
1618                         ),
1619                     ),
1620                     dependencies=dependencies,
1621                 )
1622 
1623     def generate_altered_managers(self):
1624         for app_label, model_name in sorted(self.kept_model_keys):
1625             old_model_name = self.renamed_models.get(
1626                 (app_label, model_name), model_name
1627             )
1628             old_model_state = self.from_state.models[app_label, old_model_name]
1629             new_model_state = self.to_state.models[app_label, model_name]
1630             if old_model_state.managers != new_model_state.managers:
1631                 self.add_operation(
1632                     app_label,
1633                     operations.AlterModelManagers(
1634                         name=model_name,
1635                         managers=new_model_state.managers,
1636                     ),
1637                 )
1638 
1639     def arrange_for_graph(self, changes, graph, migration_name=None):
1640         """
1641         Take a result from changes() and a MigrationGraph, and fix the names
1642         and dependencies of the changes so they extend the graph from the leaf
1643         nodes for each app.
1644         """
1645         leaves = graph.leaf_nodes()
1646         name_map = {}
1647         for app_label, migrations in list(changes.items()):
1648             if not migrations:
1649                 continue
1650             # Find the app label's current leaf node
1651             app_leaf = None
1652             for leaf in leaves:
1653                 if leaf[0] == app_label:
1654                     app_leaf = leaf
1655                     break
1656             # Do they want an initial migration for this app?
1657             if app_leaf is None and not self.questioner.ask_initial(app_label):
1658                 # They don't.
1659                 for migration in migrations:
1660                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1661                 del changes[app_label]
1662                 continue
1663             # Work out the next number in the sequence
1664             if app_leaf is None:
1665                 next_number = 1
1666             else:
1667                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1668             # Name each migration
1669             for i, migration in enumerate(migrations):
1670                 if i == 0 and app_leaf:
1671                     migration.dependencies.append(app_leaf)
1672                 new_name_parts = ["%04i" % next_number]
1673                 if migration_name:
1674                     new_name_parts.append(migration_name)
1675                 elif i == 0 and not app_leaf:
1676                     new_name_parts.append("initial")
1677                 else:
1678                     new_name_parts.append(migration.suggest_name()[:100])
1679                 new_name = "_".join(new_name_parts)
1680                 name_map[(app_label, migration.name)] = (app_label, new_name)
1681                 next_number += 1
1682                 migration.name = new_name
1683         # Now fix dependencies
1684         for migrations in changes.values():
1685             for migration in migrations:
1686                 migration.dependencies = [
1687                     name_map.get(d, d) for d in migration.dependencies
1688                 ]
1689         return changes
1690 
1691     def _trim_to_apps(self, changes, app_labels):
1692         """
1693         Take changes from arrange_for_graph() and set of app labels, and return
1694         a modified set of changes which trims out as many migrations that are
1695         not in app_labels as possible. Note that some other migrations may
1696         still be present as they may be required dependencies.
1697         """
1698         # Gather other app dependencies in a first pass
1699         app_dependencies = {}
1700         for app_label, migrations in changes.items():
1701             for migration in migrations:
1702                 for dep_app_label, name in migration.dependencies:
1703                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1704         required_apps = set(app_labels)
1705         # Keep resolving till there's no change
1706         old_required_apps = None
1707         while old_required_apps != required_apps:
1708             old_required_apps = set(required_apps)
1709             required_apps.update(
1710                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1711             )
1712         # Remove all migrations that aren't needed
1713         for app_label in list(changes):
1714             if app_label not in required_apps:
1715                 del changes[app_label]
1716         return changes
1717 
1718     @classmethod
1719     def parse_number(cls, name):
1720         """
1721         Given a migration name, try to extract a number from the beginning of
1722         it. For a squashed migration such as '0001_squashed_0004', return the
1723         second number. If no number is found, return None.
1724         """
1725         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1726             return int(squashed_match[1])
1727         match = re.match(r"^\d+", name)
1728         if match:
1729             return int(match[0])
1730         return None

</code><intended_behavior>Code that identifies changes to `index_together` for generating migration operations should shift towards detecting changes in `indexes`, offering precise migration generation.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.migrations.utils import field_references, resolve_relation
5 from django.db.models.options import normalize_together
6 from django.utils.functional import cached_property
7 
8 from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField
9 
10 
11 def _check_for_duplicates(arg_name, objs):
12     used_vals = set()
13     for val in objs:
14         if val in used_vals:
15             raise ValueError(
16                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
17             )
18         used_vals.add(val)
19 
20 
21 class ModelOperation(Operation):
22     def __init__(self, name):
23         self.name = name
24 
25     @cached_property
26     def name_lower(self):
27         return self.name.lower()
28 
29     def references_model(self, name, app_label):
30         return name.lower() == self.name_lower
31 
32     def reduce(self, operation, app_label):
33         return super().reduce(operation, app_label) or self.can_reduce_through(
34             operation, app_label
35         )
36 
37     def can_reduce_through(self, operation, app_label):
38         return not operation.references_model(self.name, app_label)
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ["fields", "options", "managers"]
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates("fields", (name for name, _ in self.fields))
55         _check_for_duplicates(
56             "bases",
57             (
58                 base._meta.label_lower
59                 if hasattr(base, "_meta")
60                 else base.lower()
61                 if isinstance(base, str)
62                 else base
63                 for base in self.bases
64             ),
65         )
66         _check_for_duplicates("managers", (name for name, _ in self.managers))
67 
68     def deconstruct(self):
69         kwargs = {
70             "name": self.name,
71             "fields": self.fields,
72         }
73         if self.options:
74             kwargs["options"] = self.options
75         if self.bases and self.bases != (models.Model,):
76             kwargs["bases"] = self.bases
77         if self.managers and self.managers != [("objects", models.Manager())]:
78             kwargs["managers"] = self.managers
79         return (self.__class__.__qualname__, [], kwargs)
80 
81     def state_forwards(self, app_label, state):
82         state.add_model(
83             ModelState(
84                 app_label,
85                 self.name,
86                 list(self.fields),
87                 dict(self.options),
88                 tuple(self.bases),
89                 list(self.managers),
90             )
91         )
92 
93     def database_forwards(self, app_label, schema_editor, from_state, to_state):
94         model = to_state.apps.get_model(app_label, self.name)
95         if self.allow_migrate_model(schema_editor.connection.alias, model):
96             schema_editor.create_model(model)
97 
98     def database_backwards(self, app_label, schema_editor, from_state, to_state):
99         model = from_state.apps.get_model(app_label, self.name)
100         if self.allow_migrate_model(schema_editor.connection.alias, model):
101             schema_editor.delete_model(model)
102 
103     def describe(self):
104         return "Create %smodel %s" % (
105             "proxy " if self.options.get("proxy", False) else "",
106             self.name,
107         )
108 
109     @property
110     def migration_name_fragment(self):
111         return self.name_lower
112 
113     def references_model(self, name, app_label):
114         name_lower = name.lower()
115         if name_lower == self.name_lower:
116             return True
117 
118         # Check we didn't inherit from the model
119         reference_model_tuple = (app_label, name_lower)
120         for base in self.bases:
121             if (
122                 base is not models.Model
123                 and isinstance(base, (models.base.ModelBase, str))
124                 and resolve_relation(base, app_label) == reference_model_tuple
125             ):
126                 return True
127 
128         # Check we have no FKs/M2Ms with it
129         for _name, field in self.fields:
130             if field_references(
131                 (app_label, self.name_lower), field, reference_model_tuple
132             ):
133                 return True
134         return False
135 
136     def reduce(self, operation, app_label):
137         if (
138             isinstance(operation, DeleteModel)
139             and self.name_lower == operation.name_lower
140             and not self.options.get("proxy", False)
141         ):
142             return []
143         elif (
144             isinstance(operation, RenameModel)
145             and self.name_lower == operation.old_name_lower
146         ):
147             return [
148                 CreateModel(
149                     operation.new_name,
150                     fields=self.fields,
151                     options=self.options,
152                     bases=self.bases,
153                     managers=self.managers,
154                 ),
155             ]
156         elif (
157             isinstance(operation, AlterModelOptions)
158             and self.name_lower == operation.name_lower
159         ):
160             options = {**self.options, **operation.options}
161             for key in operation.ALTER_OPTION_KEYS:
162                 if key not in operation.options:
163                     options.pop(key, None)
164             return [
165                 CreateModel(
166                     self.name,
167                     fields=self.fields,
168                     options=options,
169                     bases=self.bases,
170                     managers=self.managers,
171                 ),
172             ]
173         elif (
174             isinstance(operation, AlterModelManagers)
175             and self.name_lower == operation.name_lower
176         ):
177             return [
178                 CreateModel(
179                     self.name,
180                     fields=self.fields,
181                     options=self.options,
182                     bases=self.bases,
183                     managers=operation.managers,
184                 ),
185             ]
186         elif (
187             isinstance(operation, AlterTogetherOptionOperation)
188             and self.name_lower == operation.name_lower
189         ):
190             return [
191                 CreateModel(
192                     self.name,
193                     fields=self.fields,
194                     options={
195                         **self.options,
196                         **{operation.option_name: operation.option_value},
197                     },
198                     bases=self.bases,
199                     managers=self.managers,
200                 ),
201             ]
202         elif (
203             isinstance(operation, AlterOrderWithRespectTo)
204             and self.name_lower == operation.name_lower
205         ):
206             return [
207                 CreateModel(
208                     self.name,
209                     fields=self.fields,
210                     options={
211                         **self.options,
212                         "order_with_respect_to": operation.order_with_respect_to,
213                     },
214                     bases=self.bases,
215                     managers=self.managers,
216                 ),
217             ]
218         elif (
219             isinstance(operation, FieldOperation)
220             and self.name_lower == operation.model_name_lower
221         ):
222             if isinstance(operation, AddField):
223                 return [
224                     CreateModel(
225                         self.name,
226                         fields=self.fields + [(operation.name, operation.field)],
227                         options=self.options,
228                         bases=self.bases,
229                         managers=self.managers,
230                     ),
231                 ]
232             elif isinstance(operation, AlterField):
233                 return [
234                     CreateModel(
235                         self.name,
236                         fields=[
237                             (n, operation.field if n == operation.name else v)
238                             for n, v in self.fields
239                         ],
240                         options=self.options,
241                         bases=self.bases,
242                         managers=self.managers,
243                     ),
244                 ]
245             elif isinstance(operation, RemoveField):
246                 options = self.options.copy()
247                 for option_name in ("unique_together", "index_together"):
248                     option = options.pop(option_name, None)
249                     if option:
250                         option = set(
251                             filter(
252                                 bool,
253                                 (
254                                     tuple(
255                                         f for f in fields if f != operation.name_lower
256                                     )
257                                     for fields in option
258                                 ),
259                             )
260                         )
261                         if option:
262                             options[option_name] = option
263                 order_with_respect_to = options.get("order_with_respect_to")
264                 if order_with_respect_to == operation.name_lower:
265                     del options["order_with_respect_to"]
266                 return [
267                     CreateModel(
268                         self.name,
269                         fields=[
270                             (n, v)
271                             for n, v in self.fields
272                             if n.lower() != operation.name_lower
273                         ],
274                         options=options,
275                         bases=self.bases,
276                         managers=self.managers,
277                     ),
278                 ]
279             elif isinstance(operation, RenameField):
280                 options = self.options.copy()
281                 for option_name in ("unique_together", "index_together"):
282                     option = options.get(option_name)
283                     if option:
284                         options[option_name] = {
285                             tuple(
286                                 operation.new_name if f == operation.old_name else f
287                                 for f in fields
288                             )
289                             for fields in option
290                         }
291                 order_with_respect_to = options.get("order_with_respect_to")
292                 if order_with_respect_to == operation.old_name:
293                     options["order_with_respect_to"] = operation.new_name
294                 return [
295                     CreateModel(
296                         self.name,
297                         fields=[
298                             (operation.new_name if n == operation.old_name else n, v)
299                             for n, v in self.fields
300                         ],
301                         options=options,
302                         bases=self.bases,
303                         managers=self.managers,
304                     ),
305                 ]
306         return super().reduce(operation, app_label)
307 
308 
309 class DeleteModel(ModelOperation):
310     """Drop a model's table."""
311 
312     def deconstruct(self):
313         kwargs = {
314             "name": self.name,
315         }
316         return (self.__class__.__qualname__, [], kwargs)
317 
318     def state_forwards(self, app_label, state):
319         state.remove_model(app_label, self.name_lower)
320 
321     def database_forwards(self, app_label, schema_editor, from_state, to_state):
322         model = from_state.apps.get_model(app_label, self.name)
323         if self.allow_migrate_model(schema_editor.connection.alias, model):
324             schema_editor.delete_model(model)
325 
326     def database_backwards(self, app_label, schema_editor, from_state, to_state):
327         model = to_state.apps.get_model(app_label, self.name)
328         if self.allow_migrate_model(schema_editor.connection.alias, model):
329             schema_editor.create_model(model)
330 
331     def references_model(self, name, app_label):
332         # The deleted model could be referencing the specified model through
333         # related fields.
334         return True
335 
336     def describe(self):
337         return "Delete model %s" % self.name
338 
339     @property
340     def migration_name_fragment(self):
341         return "delete_%s" % self.name_lower
342 
343 
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             old_db_table = old_model._meta.db_table
375             new_db_table = new_model._meta.db_table
376             # Don't alter when a table name is not changed.
377             if old_db_table == new_db_table:
378                 return
379             # Move the main table
380             schema_editor.alter_db_table(new_model, old_db_table, new_db_table)
381             # Alter the fields pointing to us
382             for related_object in old_model._meta.related_objects:
383                 if related_object.related_model == old_model:
384                     model = new_model
385                     related_key = (app_label, self.new_name_lower)
386                 else:
387                     model = related_object.related_model
388                     related_key = (
389                         related_object.related_model._meta.app_label,
390                         related_object.related_model._meta.model_name,
391                     )
392                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
393                     related_object.field.name
394                 )
395                 schema_editor.alter_field(
396                     model,
397                     related_object.field,
398                     to_field,
399                 )
400             # Rename M2M fields whose name is based on this model's name.
401             fields = zip(
402                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
403             )
404             for (old_field, new_field) in fields:
405                 # Skip self-referential fields as these are renamed above.
406                 if (
407                     new_field.model == new_field.related_model
408                     or not new_field.remote_field.through._meta.auto_created
409                 ):
410                     continue
411                 # Rename the M2M table that's based on this model's name.
412                 old_m2m_model = old_field.remote_field.through
413                 new_m2m_model = new_field.remote_field.through
414                 schema_editor.alter_db_table(
415                     new_m2m_model,
416                     old_m2m_model._meta.db_table,
417                     new_m2m_model._meta.db_table,
418                 )
419                 # Rename the column in the M2M table that's based on this
420                 # model's name.
421                 schema_editor.alter_field(
422                     new_m2m_model,
423                     old_m2m_model._meta.get_field(old_model._meta.model_name),
424                     new_m2m_model._meta.get_field(new_model._meta.model_name),
425                 )
426 
427     def database_backwards(self, app_label, schema_editor, from_state, to_state):
428         self.new_name_lower, self.old_name_lower = (
429             self.old_name_lower,
430             self.new_name_lower,
431         )
432         self.new_name, self.old_name = self.old_name, self.new_name
433 
434         self.database_forwards(app_label, schema_editor, from_state, to_state)
435 
436         self.new_name_lower, self.old_name_lower = (
437             self.old_name_lower,
438             self.new_name_lower,
439         )
440         self.new_name, self.old_name = self.old_name, self.new_name
441 
442     def references_model(self, name, app_label):
443         return (
444             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
445         )
446 
447     def describe(self):
448         return "Rename model %s to %s" % (self.old_name, self.new_name)
449 
450     @property
451     def migration_name_fragment(self):
452         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
453 
454     def reduce(self, operation, app_label):
455         if (
456             isinstance(operation, RenameModel)
457             and self.new_name_lower == operation.old_name_lower
458         ):
459             return [
460                 RenameModel(
461                     self.old_name,
462                     operation.new_name,
463                 ),
464             ]
465         # Skip `ModelOperation.reduce` as we want to run `references_model`
466         # against self.new_name.
467         return super(ModelOperation, self).reduce(
468             operation, app_label
469         ) or not operation.references_model(self.new_name, app_label)
470 
471 
472 class ModelOptionOperation(ModelOperation):
473     def reduce(self, operation, app_label):
474         if (
475             isinstance(operation, (self.__class__, DeleteModel))
476             and self.name_lower == operation.name_lower
477         ):
478             return [operation]
479         return super().reduce(operation, app_label)
480 
481 
482 class AlterModelTable(ModelOptionOperation):
483     """Rename a model's table."""
484 
485     def __init__(self, name, table):
486         self.table = table
487         super().__init__(name)
488 
489     def deconstruct(self):
490         kwargs = {
491             "name": self.name,
492             "table": self.table,
493         }
494         return (self.__class__.__qualname__, [], kwargs)
495 
496     def state_forwards(self, app_label, state):
497         state.alter_model_options(app_label, self.name_lower, {"db_table": self.table})
498 
499     def database_forwards(self, app_label, schema_editor, from_state, to_state):
500         new_model = to_state.apps.get_model(app_label, self.name)
501         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
502             old_model = from_state.apps.get_model(app_label, self.name)
503             schema_editor.alter_db_table(
504                 new_model,
505                 old_model._meta.db_table,
506                 new_model._meta.db_table,
507             )
508             # Rename M2M fields whose name is based on this model's db_table
509             for (old_field, new_field) in zip(
510                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
511             ):
512                 if new_field.remote_field.through._meta.auto_created:
513                     schema_editor.alter_db_table(
514                         new_field.remote_field.through,
515                         old_field.remote_field.through._meta.db_table,
516                         new_field.remote_field.through._meta.db_table,
517                     )
518 
519     def database_backwards(self, app_label, schema_editor, from_state, to_state):
520         return self.database_forwards(app_label, schema_editor, from_state, to_state)
521 
522     def describe(self):
523         return "Rename table for %s to %s" % (
524             self.name,
525             self.table if self.table is not None else "(default)",
526         )
527 
528     @property
529     def migration_name_fragment(self):
530         return "alter_%s_table" % self.name_lower
531 
532 
533 class AlterTogetherOptionOperation(ModelOptionOperation):
534     option_name = None
535 
536     def __init__(self, name, option_value):
537         if option_value:
538             option_value = set(normalize_together(option_value))
539         setattr(self, self.option_name, option_value)
540         super().__init__(name)
541 
542     @cached_property
543     def option_value(self):
544         return getattr(self, self.option_name)
545 
546     def deconstruct(self):
547         kwargs = {
548             "name": self.name,
549             self.option_name: self.option_value,
550         }
551         return (self.__class__.__qualname__, [], kwargs)
552 
553     def state_forwards(self, app_label, state):
554         state.alter_model_options(
555             app_label,
556             self.name_lower,
557             {self.option_name: self.option_value},
558         )
559 
560     def database_forwards(self, app_label, schema_editor, from_state, to_state):
561         new_model = to_state.apps.get_model(app_label, self.name)
562         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
563             old_model = from_state.apps.get_model(app_label, self.name)
564             alter_together = getattr(schema_editor, "alter_%s" % self.option_name)
565             alter_together(
566                 new_model,
567                 getattr(old_model._meta, self.option_name, set()),
568                 getattr(new_model._meta, self.option_name, set()),
569             )
570 
571     def database_backwards(self, app_label, schema_editor, from_state, to_state):
572         return self.database_forwards(app_label, schema_editor, from_state, to_state)
573 
574     def references_field(self, model_name, name, app_label):
575         return self.references_model(model_name, app_label) and (
576             not self.option_value
577             or any((name in fields) for fields in self.option_value)
578         )
579 
580     def describe(self):
581         return "Alter %s for %s (%s constraint(s))" % (
582             self.option_name,
583             self.name,
584             len(self.option_value or ""),
585         )
586 
587     @property
588     def migration_name_fragment(self):
589         return "alter_%s_%s" % (self.name_lower, self.option_name)
590 
591     def can_reduce_through(self, operation, app_label):
592         return super().can_reduce_through(operation, app_label) or (
593             isinstance(operation, AlterTogetherOptionOperation)
594             and type(operation) is not type(self)
595         )
596 
597 
598 class AlterUniqueTogether(AlterTogetherOptionOperation):
599     """
600     Change the value of unique_together to the target one.
601     Input value of unique_together must be a set of tuples.
602     """
603 
604     option_name = "unique_together"
605 
606     def __init__(self, name, unique_together):
607         super().__init__(name, unique_together)
608 
609 
610 class AlterIndexTogether(AlterTogetherOptionOperation):
611     """
612     Change the value of index_together to the target one.
613     Input value of index_together must be a set of tuples.
614     """
615 
616     option_name = "index_together"
617 
618     def __init__(self, name, index_together):
619         super().__init__(name, index_together)
620 
621 
622 class AlterOrderWithRespectTo(ModelOptionOperation):
623     """Represent a change with the order_with_respect_to option."""
624 
625     option_name = "order_with_respect_to"
626 
627     def __init__(self, name, order_with_respect_to):
628         self.order_with_respect_to = order_with_respect_to
629         super().__init__(name)
630 
631     def deconstruct(self):
632         kwargs = {
633             "name": self.name,
634             "order_with_respect_to": self.order_with_respect_to,
635         }
636         return (self.__class__.__qualname__, [], kwargs)
637 
638     def state_forwards(self, app_label, state):
639         state.alter_model_options(
640             app_label,
641             self.name_lower,
642             {self.option_name: self.order_with_respect_to},
643         )
644 
645     def database_forwards(self, app_label, schema_editor, from_state, to_state):
646         to_model = to_state.apps.get_model(app_label, self.name)
647         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
648             from_model = from_state.apps.get_model(app_label, self.name)
649             # Remove a field if we need to
650             if (
651                 from_model._meta.order_with_respect_to
652                 and not to_model._meta.order_with_respect_to
653             ):
654                 schema_editor.remove_field(
655                     from_model, from_model._meta.get_field("_order")
656                 )
657             # Add a field if we need to (altering the column is untouched as
658             # it's likely a rename)
659             elif (
660                 to_model._meta.order_with_respect_to
661                 and not from_model._meta.order_with_respect_to
662             ):
663                 field = to_model._meta.get_field("_order")
664                 if not field.has_default():
665                     field.default = 0
666                 schema_editor.add_field(
667                     from_model,
668                     field,
669                 )
670 
671     def database_backwards(self, app_label, schema_editor, from_state, to_state):
672         self.database_forwards(app_label, schema_editor, from_state, to_state)
673 
674     def references_field(self, model_name, name, app_label):
675         return self.references_model(model_name, app_label) and (
676             self.order_with_respect_to is None or name == self.order_with_respect_to
677         )
678 
679     def describe(self):
680         return "Set order_with_respect_to on %s to %s" % (
681             self.name,
682             self.order_with_respect_to,
683         )
684 
685     @property
686     def migration_name_fragment(self):
687         return "alter_%s_order_with_respect_to" % self.name_lower
688 
689 
690 class AlterModelOptions(ModelOptionOperation):
691     """
692     Set new model options that don't directly affect the database schema
693     (like verbose_name, permissions, ordering). Python code in migrations
694     may still need them.
695     """
696 
697     # Model options we want to compare and preserve in an AlterModelOptions op
698     ALTER_OPTION_KEYS = [
699         "base_manager_name",
700         "default_manager_name",
701         "default_related_name",
702         "get_latest_by",
703         "managed",
704         "ordering",
705         "permissions",
706         "default_permissions",
707         "select_on_save",
708         "verbose_name",
709         "verbose_name_plural",
710     ]
711 
712     def __init__(self, name, options):
713         self.options = options
714         super().__init__(name)
715 
716     def deconstruct(self):
717         kwargs = {
718             "name": self.name,
719             "options": self.options,
720         }
721         return (self.__class__.__qualname__, [], kwargs)
722 
723     def state_forwards(self, app_label, state):
724         state.alter_model_options(
725             app_label,
726             self.name_lower,
727             self.options,
728             self.ALTER_OPTION_KEYS,
729         )
730 
731     def database_forwards(self, app_label, schema_editor, from_state, to_state):
732         pass
733 
734     def database_backwards(self, app_label, schema_editor, from_state, to_state):
735         pass
736 
737     def describe(self):
738         return "Change Meta options on %s" % self.name
739 
740     @property
741     def migration_name_fragment(self):
742         return "alter_%s_options" % self.name_lower
743 
744 
745 class AlterModelManagers(ModelOptionOperation):
746     """Alter the model's managers."""
747 
748     serialization_expand_args = ["managers"]
749 
750     def __init__(self, name, managers):
751         self.managers = managers
752         super().__init__(name)
753 
754     def deconstruct(self):
755         return (self.__class__.__qualname__, [self.name, self.managers], {})
756 
757     def state_forwards(self, app_label, state):
758         state.alter_model_managers(app_label, self.name_lower, self.managers)
759 
760     def database_forwards(self, app_label, schema_editor, from_state, to_state):
761         pass
762 
763     def database_backwards(self, app_label, schema_editor, from_state, to_state):
764         pass
765 
766     def describe(self):
767         return "Change managers on %s" % self.name
768 
769     @property
770     def migration_name_fragment(self):
771         return "alter_%s_managers" % self.name_lower
772 
773 
774 class IndexOperation(Operation):
775     option_name = "indexes"
776 
777     @cached_property
778     def model_name_lower(self):
779         return self.model_name.lower()
780 
781 
782 class AddIndex(IndexOperation):
783     """Add an index on a model."""
784 
785     def __init__(self, model_name, index):
786         self.model_name = model_name
787         if not index.name:
788             raise ValueError(
789                 "Indexes passed to AddIndex operations require a name "
790                 "argument. %r doesn't have one." % index
791             )
792         self.index = index
793 
794     def state_forwards(self, app_label, state):
795         state.add_index(app_label, self.model_name_lower, self.index)
796 
797     def database_forwards(self, app_label, schema_editor, from_state, to_state):
798         model = to_state.apps.get_model(app_label, self.model_name)
799         if self.allow_migrate_model(schema_editor.connection.alias, model):
800             schema_editor.add_index(model, self.index)
801 
802     def database_backwards(self, app_label, schema_editor, from_state, to_state):
803         model = from_state.apps.get_model(app_label, self.model_name)
804         if self.allow_migrate_model(schema_editor.connection.alias, model):
805             schema_editor.remove_index(model, self.index)
806 
807     def deconstruct(self):
808         kwargs = {
809             "model_name": self.model_name,
810             "index": self.index,
811         }
812         return (
813             self.__class__.__qualname__,
814             [],
815             kwargs,
816         )
817 
818     def describe(self):
819         if self.index.expressions:
820             return "Create index %s on %s on model %s" % (
821                 self.index.name,
822                 ", ".join([str(expression) for expression in self.index.expressions]),
823                 self.model_name,
824             )
825         return "Create index %s on field(s) %s of model %s" % (
826             self.index.name,
827             ", ".join(self.index.fields),
828             self.model_name,
829         )
830 
831     @property
832     def migration_name_fragment(self):
833         return "%s_%s" % (self.model_name_lower, self.index.name.lower())
834 
835 
836 class RemoveIndex(IndexOperation):
837     """Remove an index from a model."""
838 
839     def __init__(self, model_name, name):
840         self.model_name = model_name
841         self.name = name
842 
843     def state_forwards(self, app_label, state):
844         state.remove_index(app_label, self.model_name_lower, self.name)
845 
846     def database_forwards(self, app_label, schema_editor, from_state, to_state):
847         model = from_state.apps.get_model(app_label, self.model_name)
848         if self.allow_migrate_model(schema_editor.connection.alias, model):
849             from_model_state = from_state.models[app_label, self.model_name_lower]
850             index = from_model_state.get_index_by_name(self.name)
851             schema_editor.remove_index(model, index)
852 
853     def database_backwards(self, app_label, schema_editor, from_state, to_state):
854         model = to_state.apps.get_model(app_label, self.model_name)
855         if self.allow_migrate_model(schema_editor.connection.alias, model):
856             to_model_state = to_state.models[app_label, self.model_name_lower]
857             index = to_model_state.get_index_by_name(self.name)
858             schema_editor.add_index(model, index)
859 
860     def deconstruct(self):
861         kwargs = {
862             "model_name": self.model_name,
863             "name": self.name,
864         }
865         return (
866             self.__class__.__qualname__,
867             [],
868             kwargs,
869         )
870 
871     def describe(self):
872         return "Remove index %s from %s" % (self.name, self.model_name)
873 
874     @property
875     def migration_name_fragment(self):
876         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())
877 
878 
879 class RenameIndex(IndexOperation):
880     """Rename an index."""
881 
882     def __init__(self, model_name, new_name, old_name=None, old_fields=None):
883         if not old_name and not old_fields:
884             raise ValueError(
885                 "RenameIndex requires one of old_name and old_fields arguments to be "
886                 "set."
887             )
888         if old_name and old_fields:
889             raise ValueError(
890                 "RenameIndex.old_name and old_fields are mutually exclusive."
891             )
892         self.model_name = model_name
893         self.new_name = new_name
894         self.old_name = old_name
895         self.old_fields = old_fields
896 
897     @cached_property
898     def old_name_lower(self):
899         return self.old_name.lower()
900 
901     @cached_property
902     def new_name_lower(self):
903         return self.new_name.lower()
904 
905     def deconstruct(self):
906         kwargs = {
907             "model_name": self.model_name,
908             "new_name": self.new_name,
909         }
910         if self.old_name:
911             kwargs["old_name"] = self.old_name
912         if self.old_fields:
913             kwargs["old_fields"] = self.old_fields
914         return (self.__class__.__qualname__, [], kwargs)
915 
916     def state_forwards(self, app_label, state):
917         if self.old_fields:
918             state.add_index(
919                 app_label,
920                 self.model_name_lower,
921                 models.Index(fields=self.old_fields, name=self.new_name),
922             )
923             state.remove_model_options(
924                 app_label,
925                 self.model_name_lower,
926                 AlterIndexTogether.option_name,
927                 self.old_fields,
928             )
929         else:
930             state.rename_index(
931                 app_label, self.model_name_lower, self.old_name, self.new_name
932             )
933 
934     def database_forwards(self, app_label, schema_editor, from_state, to_state):
935         model = to_state.apps.get_model(app_label, self.model_name)
936         if not self.allow_migrate_model(schema_editor.connection.alias, model):
937             return
938 
939         if self.old_fields:
940             from_model = from_state.apps.get_model(app_label, self.model_name)
941             columns = [
942                 from_model._meta.get_field(field).column for field in self.old_fields
943             ]
944             matching_index_name = schema_editor._constraint_names(
945                 from_model, column_names=columns, index=True
946             )
947             if len(matching_index_name) != 1:
948                 raise ValueError(
949                     "Found wrong number (%s) of indexes for %s(%s)."
950                     % (
951                         len(matching_index_name),
952                         from_model._meta.db_table,
953                         ", ".join(columns),
954                     )
955                 )
956             old_index = models.Index(
957                 fields=self.old_fields,
958                 name=matching_index_name[0],
959             )
960         else:
961             from_model_state = from_state.models[app_label, self.model_name_lower]
962             old_index = from_model_state.get_index_by_name(self.old_name)
963         # Don't alter when the index name is not changed.
964         if old_index.name == self.new_name:
965             return
966 
967         to_model_state = to_state.models[app_label, self.model_name_lower]
968         new_index = to_model_state.get_index_by_name(self.new_name)
969         schema_editor.rename_index(model, old_index, new_index)
970 
971     def database_backwards(self, app_label, schema_editor, from_state, to_state):
972         if self.old_fields:
973             # Backward operation with unnamed index is a no-op.
974             return
975 
976         self.new_name_lower, self.old_name_lower = (
977             self.old_name_lower,
978             self.new_name_lower,
979         )
980         self.new_name, self.old_name = self.old_name, self.new_name
981 
982         self.database_forwards(app_label, schema_editor, from_state, to_state)
983 
984         self.new_name_lower, self.old_name_lower = (
985             self.old_name_lower,
986             self.new_name_lower,
987         )
988         self.new_name, self.old_name = self.old_name, self.new_name
989 
990     def describe(self):
991         if self.old_name:
992             return (
993                 f"Rename index {self.old_name} on {self.model_name} to {self.new_name}"
994             )
995         return (
996             f"Rename unnamed index for {self.old_fields} on {self.model_name} to "
997             f"{self.new_name}"
998         )
999 
1000     @property
1001     def migration_name_fragment(self):
1002         if self.old_name:
1003             return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
1004         return "rename_%s_%s_%s" % (
1005             self.model_name_lower,
1006             "_".join(self.old_fields),
1007             self.new_name_lower,
1008         )
1009 
1010     def reduce(self, operation, app_label):
1011         if (
1012             isinstance(operation, RenameIndex)
1013             and self.model_name_lower == operation.model_name_lower
1014             and operation.old_name
1015             and self.new_name_lower == operation.old_name_lower
1016         ):
1017             return [
1018                 RenameIndex(
1019                     self.model_name,
1020                     new_name=operation.new_name,
1021                     old_name=self.old_name,
1022                     old_fields=self.old_fields,
1023                 )
1024             ]
1025         return super().reduce(operation, app_label)
1026 
1027 
1028 class AddConstraint(IndexOperation):
1029     option_name = "constraints"
1030 
1031     def __init__(self, model_name, constraint):
1032         self.model_name = model_name
1033         self.constraint = constraint
1034 
1035     def state_forwards(self, app_label, state):
1036         state.add_constraint(app_label, self.model_name_lower, self.constraint)
1037 
1038     def database_forwards(self, app_label, schema_editor, from_state, to_state):
1039         model = to_state.apps.get_model(app_label, self.model_name)
1040         if self.allow_migrate_model(schema_editor.connection.alias, model):
1041             schema_editor.add_constraint(model, self.constraint)
1042 
1043     def database_backwards(self, app_label, schema_editor, from_state, to_state):
1044         model = to_state.apps.get_model(app_label, self.model_name)
1045         if self.allow_migrate_model(schema_editor.connection.alias, model):
1046             schema_editor.remove_constraint(model, self.constraint)
1047 
1048     def deconstruct(self):
1049         return (
1050             self.__class__.__name__,
1051             [],
1052             {
1053                 "model_name": self.model_name,
1054                 "constraint": self.constraint,
1055             },
1056         )
1057 
1058     def describe(self):
1059         return "Create constraint %s on model %s" % (
1060             self.constraint.name,
1061             self.model_name,
1062         )
1063 
1064     @property
1065     def migration_name_fragment(self):
1066         return "%s_%s" % (self.model_name_lower, self.constraint.name.lower())
1067 
1068 
1069 class RemoveConstraint(IndexOperation):
1070     option_name = "constraints"
1071 
1072     def __init__(self, model_name, name):
1073         self.model_name = model_name
1074         self.name = name
1075 
1076     def state_forwards(self, app_label, state):
1077         state.remove_constraint(app_label, self.model_name_lower, self.name)
1078 
1079     def database_forwards(self, app_label, schema_editor, from_state, to_state):
1080         model = to_state.apps.get_model(app_label, self.model_name)
1081         if self.allow_migrate_model(schema_editor.connection.alias, model):
1082             from_model_state = from_state.models[app_label, self.model_name_lower]
1083             constraint = from_model_state.get_constraint_by_name(self.name)
1084             schema_editor.remove_constraint(model, constraint)
1085 
1086     def database_backwards(self, app_label, schema_editor, from_state, to_state):
1087         model = to_state.apps.get_model(app_label, self.model_name)
1088         if self.allow_migrate_model(schema_editor.connection.alias, model):
1089             to_model_state = to_state.models[app_label, self.model_name_lower]
1090             constraint = to_model_state.get_constraint_by_name(self.name)
1091             schema_editor.add_constraint(model, constraint)
1092 
1093     def deconstruct(self):
1094         return (
1095             self.__class__.__name__,
1096             [],
1097             {
1098                 "model_name": self.model_name,
1099                 "name": self.name,
1100             },
1101         )
1102 
1103     def describe(self):
1104         return "Remove constraint %s from model %s" % (self.name, self.model_name)
1105 
1106     @property
1107     def migration_name_fragment(self):
1108         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())

</code><intended_behavior>Support full operations for adding, removing, or altering indexes using `Index` instances, ensuring migrations are accurately generated and applied.</intended_behavior>]
2025-10-15 06:07:53.790 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 06:07:53.790 | INFO     | Search-only: skipping patch selection
2025-10-15 06:07:53.947 | INFO     | Task django__django-15703 completed successfully.
2025-10-15 06:07:53.948 | INFO     | No patch generated. You can try running ACR again.
