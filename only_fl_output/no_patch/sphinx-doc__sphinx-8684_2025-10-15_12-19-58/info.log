2025-10-15 12:19:58.388 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 12:20:01.788 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=158, output_tokens=12, cost=0.001940
2025-10-15 12:20:01.789 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 12:20:01.793 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:20:10.064 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=467, output_tokens=258, cost=0.012410
2025-10-15 12:20:10.069 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:20:11.928 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=612, output_tokens=45, cost=0.007470
2025-10-15 12:20:11.929 | DEBUG    | Extracted a valid json.
2025-10-15 12:20:11.929 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"code-block\")",
        "search_method(\"literalinclude\")",
        "search_code(\":dedent:\")"
    ],
    "bug_locations": []
}
2025-10-15 12:20:11.944 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 12:20:11.945 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 12:20:21.144 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=898, output_tokens=358, cost=0.019720
2025-10-15 12:20:21.156 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:20:24.336 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1472, output_tokens=57, cost=0.016430
2025-10-15 12:20:24.343 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:20:27.257 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=411, output_tokens=80, cost=0.006510
2025-10-15 12:20:27.259 | DEBUG    | Extracted a valid json.
2025-10-15 12:20:27.259 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Directive\")",
        "search_class(\"DocumentProcessor\")",
        "search_class(\"TextProcessor\")",
        "search_method(\"process_directive\")",
        "search_method(\"handle_directive\")",
        "search_code(\"indentation\")",
        "search_code(\"remove_indent\")"
    ],
    "bug_locations": []
}
2025-10-15 12:20:27.304 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 12:20:27.305 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 12:20:41.922 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1876, output_tokens=694, cost=0.039580
2025-10-15 12:20:41.935 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:20:53.630 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2786, output_tokens=432, cost=0.040820
2025-10-15 12:20:53.639 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:21:04.768 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=786, output_tokens=431, cost=0.020790
2025-10-15 12:21:04.769 | DEBUG    | Extracted a valid json.
2025-10-15 12:21:04.769 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/pycode/parser.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file possibly contains logic for parsing and analyzing Python code within the documentation. To resolve the issue, the parser's handling of code blocks should be extended to automatically dedent them unless a specific `:dedent:` value is given. This will allow for easier inclusion of code samples without manually adjusting indentation."
        },
        {
            "file": "sphinx/domains/std.py",
            "class": "",
            "method": "",
            "intended_behavior": "As this file likely includes directive processing logic for the standard domain, it should be ensured that the `:dedent:` option for `code-block` and `literalinclude` directives automatically removes common leading whitespace from all lines in the absence of an explicit dedent value. The change should maintain backward compatibility, allowing users to still specify a dedent value when desired."
        },
        {
            "file": "sphinx/util/docstrings.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file is probably responsible for processing docstring content. Enhancements should be made to apply the automatic dedentation logic for code blocks and literal includes within docstrings, applying a universal dedent if no `:dedent:` value is specified. This modifies the docstring handling to better format embedded code snippets."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file's functionality includes automatically documenting Python source code files. The modification needed here involves ensuring that when extracting docstrings that include `code-block` or `literalinclude` directives, an automatic dedent is applied to these blocks if they lack a specific `:dedent:` value. This change should gracefully handle existing documentation and new inclusions alike, promoting ease of documentation writing and consistency in documentation appearance."
        }
    ]
}
2025-10-15 12:21:04.785 | DEBUG    | Bug location extracted successfully: [<file>sphinx/pycode/parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.pycode.parser
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities parsing and analyzing Python code.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 import inspect
11 import itertools
12 import re
13 import sys
14 import tokenize
15 from collections import OrderedDict
16 from inspect import Signature
17 from token import DEDENT, INDENT, NAME, NEWLINE, NUMBER, OP, STRING
18 from tokenize import COMMENT, NL
19 from typing import Any, Dict, List, Optional, Tuple
20 
21 from sphinx.pycode.ast import ast  # for py37 or older
22 from sphinx.pycode.ast import parse, unparse
23 
24 comment_re = re.compile('^\\s*#: ?(.*)\r?\n?$')
25 indent_re = re.compile('^\\s*$')
26 emptyline_re = re.compile('^\\s*(#.*)?$')
27 
28 
29 if sys.version_info >= (3, 6):
30     ASSIGN_NODES = (ast.Assign, ast.AnnAssign)
31 else:
32     ASSIGN_NODES = (ast.Assign)
33 
34 
35 def filter_whitespace(code: str) -> str:
36     return code.replace('\f', ' ')  # replace FF (form feed) with whitespace
37 
38 
39 def get_assign_targets(node: ast.AST) -> List[ast.expr]:
40     """Get list of targets from Assign and AnnAssign node."""
41     if isinstance(node, ast.Assign):
42         return node.targets
43     else:
44         return [node.target]  # type: ignore
45 
46 
47 def get_lvar_names(node: ast.AST, self: ast.arg = None) -> List[str]:
48     """Convert assignment-AST to variable names.
49 
50     This raises `TypeError` if the assignment does not create new variable::
51 
52         ary[0] = 'foo'
53         dic["bar"] = 'baz'
54         # => TypeError
55     """
56     if self:
57         self_id = self.arg
58 
59     node_name = node.__class__.__name__
60     if node_name in ('Index', 'Num', 'Slice', 'Str', 'Subscript'):
61         raise TypeError('%r does not create new variable' % node)
62     elif node_name == 'Name':
63         if self is None or node.id == self_id:  # type: ignore
64             return [node.id]  # type: ignore
65         else:
66             raise TypeError('The assignment %r is not instance variable' % node)
67     elif node_name in ('Tuple', 'List'):
68         members = []
69         for elt in node.elts:  # type: ignore
70             try:
71                 members.extend(get_lvar_names(elt, self))
72             except TypeError:
73                 pass
74         return members
75     elif node_name == 'Attribute':
76         if node.value.__class__.__name__ == 'Name' and self and node.value.id == self_id:  # type: ignore  # NOQA
77             # instance variable
78             return ["%s" % get_lvar_names(node.attr, self)[0]]  # type: ignore
79         else:
80             raise TypeError('The assignment %r is not instance variable' % node)
81     elif node_name == 'str':
82         return [node]  # type: ignore
83     elif node_name == 'Starred':
84         return get_lvar_names(node.value, self)  # type: ignore
85     else:
86         raise NotImplementedError('Unexpected node name %r' % node_name)
87 
88 
89 def dedent_docstring(s: str) -> str:
90     """Remove common leading indentation from docstring."""
91     def dummy() -> None:
92         # dummy function to mock `inspect.getdoc`.
93         pass
94 
95     dummy.__doc__ = s
96     docstring = inspect.getdoc(dummy)
97     return docstring.lstrip("\r\n").rstrip("\r\n")
98 
99 
100 class Token:
101     """Better token wrapper for tokenize module."""
102 
103     def __init__(self, kind: int, value: Any, start: Tuple[int, int], end: Tuple[int, int],
104                  source: str) -> None:
105         self.kind = kind
106         self.value = value
107         self.start = start
108         self.end = end
109         self.source = source
110 
111     def __eq__(self, other: Any) -> bool:
112         if isinstance(other, int):
113             return self.kind == other
114         elif isinstance(other, str):
115             return self.value == other
116         elif isinstance(other, (list, tuple)):
117             return [self.kind, self.value] == list(other)
118         elif other is None:
119             return False
120         else:
121             raise ValueError('Unknown value: %r' % other)
122 
123     def match(self, *conditions: Any) -> bool:
124         return any(self == candidate for candidate in conditions)
125 
126     def __repr__(self) -> str:
127         return '<Token kind=%r value=%r>' % (tokenize.tok_name[self.kind],
128                                              self.value.strip())
129 
130 
131 class TokenProcessor:
132     def __init__(self, buffers: List[str]) -> None:
133         lines = iter(buffers)
134         self.buffers = buffers
135         self.tokens = tokenize.generate_tokens(lambda: next(lines))
136         self.current = None     # type: Token
137         self.previous = None    # type: Token
138 
139     def get_line(self, lineno: int) -> str:
140         """Returns specified line."""
141         return self.buffers[lineno - 1]
142 
143     def fetch_token(self) -> Token:
144         """Fetch a next token from source code.
145 
146         Returns ``None`` if sequence finished.
147         """
148         try:
149             self.previous = self.current
150             self.current = Token(*next(self.tokens))
151         except StopIteration:
152             self.current = None
153 
154         return self.current
155 
156     def fetch_until(self, condition: Any) -> List[Token]:
157         """Fetch tokens until specified token appeared.
158 
159         .. note:: This also handles parenthesis well.
160         """
161         tokens = []
162         while self.fetch_token():
163             tokens.append(self.current)
164             if self.current == condition:
165                 break
166             elif self.current == [OP, '(']:
167                 tokens += self.fetch_until([OP, ')'])
168             elif self.current == [OP, '{']:
169                 tokens += self.fetch_until([OP, '}'])
170             elif self.current == [OP, '[']:
171                 tokens += self.fetch_until([OP, ']'])
172 
173         return tokens
174 
175 
176 class AfterCommentParser(TokenProcessor):
177     """Python source code parser to pick up comment after assignment.
178 
179     This parser takes a python code starts with assignment statement,
180     and returns the comments for variable if exists.
181     """
182 
183     def __init__(self, lines: List[str]) -> None:
184         super().__init__(lines)
185         self.comment = None  # type: str
186 
187     def fetch_rvalue(self) -> List[Token]:
188         """Fetch right-hand value of assignment."""
189         tokens = []
190         while self.fetch_token():
191             tokens.append(self.current)
192             if self.current == [OP, '(']:
193                 tokens += self.fetch_until([OP, ')'])
194             elif self.current == [OP, '{']:
195                 tokens += self.fetch_until([OP, '}'])
196             elif self.current == [OP, '[']:
197                 tokens += self.fetch_until([OP, ']'])
198             elif self.current == INDENT:
199                 tokens += self.fetch_until(DEDENT)
200             elif self.current == [OP, ';']:
201                 break
202             elif self.current.kind not in (OP, NAME, NUMBER, STRING):
203                 break
204 
205         return tokens
206 
207     def parse(self) -> None:
208         """Parse the code and obtain comment after assignment."""
209         # skip lvalue (or whole of AnnAssign)
210         while not self.fetch_token().match([OP, '='], NEWLINE, COMMENT):
211             assert self.current
212 
213         # skip rvalue (if exists)
214         if self.current == [OP, '=']:
215             self.fetch_rvalue()
216 
217         if self.current == COMMENT:
218             self.comment = self.current.value
219 
220 
221 class VariableCommentPicker(ast.NodeVisitor):
222     """Python source code parser to pick up variable comments."""
223 
224     def __init__(self, buffers: List[str], encoding: str) -> None:
225         self.counter = itertools.count()
226         self.buffers = buffers
227         self.encoding = encoding
228         self.context = []               # type: List[str]
229         self.current_classes = []       # type: List[str]
230         self.current_function = None    # type: ast.FunctionDef
231         self.comments = OrderedDict()   # type: Dict[Tuple[str, str], str]
232         self.annotations = {}           # type: Dict[Tuple[str, str], str]
233         self.previous = None            # type: ast.AST
234         self.deforders = {}             # type: Dict[str, int]
235         self.finals = []                # type: List[str]
236         self.overloads = {}             # type: Dict[str, List[Signature]]
237         self.typing = None              # type: str
238         self.typing_final = None        # type: str
239         self.typing_overload = None     # type: str
240         super().__init__()
241 
242     def get_qualname_for(self, name: str) -> Optional[List[str]]:
243         """Get qualified name for given object as a list of string."""
244         if self.current_function:
245             if self.current_classes and self.context[-1] == "__init__":
246                 # store variable comments inside __init__ method of classes
247                 return self.context[:-1] + [name]
248             else:
249                 return None
250         else:
251             return self.context + [name]
252 
253     def add_entry(self, name: str) -> None:
254         qualname = self.get_qualname_for(name)
255         if qualname:
256             self.deforders[".".join(qualname)] = next(self.counter)
257 
258     def add_final_entry(self, name: str) -> None:
259         qualname = self.get_qualname_for(name)
260         if qualname:
261             self.finals.append(".".join(qualname))
262 
263     def add_overload_entry(self, func: ast.FunctionDef) -> None:
264         # avoid circular import problem
265         from sphinx.util.inspect import signature_from_ast
266         qualname = self.get_qualname_for(func.name)
267         if qualname:
268             overloads = self.overloads.setdefault(".".join(qualname), [])
269             overloads.append(signature_from_ast(func))
270 
271     def add_variable_comment(self, name: str, comment: str) -> None:
272         qualname = self.get_qualname_for(name)
273         if qualname:
274             basename = ".".join(qualname[:-1])
275             self.comments[(basename, name)] = comment
276 
277     def add_variable_annotation(self, name: str, annotation: ast.AST) -> None:
278         qualname = self.get_qualname_for(name)
279         if qualname:
280             basename = ".".join(qualname[:-1])
281             self.annotations[(basename, name)] = unparse(annotation)
282 
283     def is_final(self, decorators: List[ast.expr]) -> bool:
284         final = []
285         if self.typing:
286             final.append('%s.final' % self.typing)
287         if self.typing_final:
288             final.append(self.typing_final)
289 
290         for decorator in decorators:
291             try:
292                 if unparse(decorator) in final:
293                     return True
294             except NotImplementedError:
295                 pass
296 
297         return False
298 
299     def is_overload(self, decorators: List[ast.expr]) -> bool:
300         overload = []
301         if self.typing:
302             overload.append('%s.overload' % self.typing)
303         if self.typing_overload:
304             overload.append(self.typing_overload)
305 
306         for decorator in decorators:
307             try:
308                 if unparse(decorator) in overload:
309                     return True
310             except NotImplementedError:
311                 pass
312 
313         return False
314 
315     def get_self(self) -> ast.arg:
316         """Returns the name of first argument if in function."""
317         if self.current_function and self.current_function.args.args:
318             return self.current_function.args.args[0]
319         else:
320             return None
321 
322     def get_line(self, lineno: int) -> str:
323         """Returns specified line."""
324         return self.buffers[lineno - 1]
325 
326     def visit(self, node: ast.AST) -> None:
327         """Updates self.previous to ."""
328         super().visit(node)
329         self.previous = node
330 
331     def visit_Import(self, node: ast.Import) -> None:
332         """Handles Import node and record it to definition orders."""
333         for name in node.names:
334             self.add_entry(name.asname or name.name)
335 
336             if name.name == 'typing':
337                 self.typing = name.asname or name.name
338             elif name.name == 'typing.final':
339                 self.typing_final = name.asname or name.name
340             elif name.name == 'typing.overload':
341                 self.typing_overload = name.asname or name.name
342 
343     def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
344         """Handles Import node and record it to definition orders."""
345         for name in node.names:
346             self.add_entry(name.asname or name.name)
347 
348             if node.module == 'typing' and name.name == 'final':
349                 self.typing_final = name.asname or name.name
350             elif node.module == 'typing' and name.name == 'overload':
351                 self.typing_overload = name.asname or name.name
352 
353     def visit_Assign(self, node: ast.Assign) -> None:
354         """Handles Assign node and pick up a variable comment."""
355         try:
356             targets = get_assign_targets(node)
357             varnames = sum([get_lvar_names(t, self=self.get_self()) for t in targets], [])  # type: List[str]  # NOQA
358             current_line = self.get_line(node.lineno)
359         except TypeError:
360             return  # this assignment is not new definition!
361 
362         # record annotation
363         if hasattr(node, 'annotation') and node.annotation:  # type: ignore
364             for varname in varnames:
365                 self.add_variable_annotation(varname, node.annotation)  # type: ignore
366         elif hasattr(node, 'type_comment') and node.type_comment:
367             for varname in varnames:
368                 self.add_variable_annotation(varname, node.type_comment)  # type: ignore
369 
370         # check comments after assignment
371         parser = AfterCommentParser([current_line[node.col_offset:]] +
372                                     self.buffers[node.lineno:])
373         parser.parse()
374         if parser.comment and comment_re.match(parser.comment):
375             for varname in varnames:
376                 self.add_variable_comment(varname, comment_re.sub('\\1', parser.comment))
377                 self.add_entry(varname)
378             return
379 
380         # check comments before assignment
381         if indent_re.match(current_line[:node.col_offset]):
382             comment_lines = []
383             for i in range(node.lineno - 1):
384                 before_line = self.get_line(node.lineno - 1 - i)
385                 if comment_re.match(before_line):
386                     comment_lines.append(comment_re.sub('\\1', before_line))
387                 else:
388                     break
389 
390             if comment_lines:
391                 comment = dedent_docstring('\n'.join(reversed(comment_lines)))
392                 for varname in varnames:
393                     self.add_variable_comment(varname, comment)
394                     self.add_entry(varname)
395                 return
396 
397         # not commented (record deforders only)
398         for varname in varnames:
399             self.add_entry(varname)
400 
401     def visit_AnnAssign(self, node: ast.AST) -> None:  # Note: ast.AnnAssign not found in py35
402         """Handles AnnAssign node and pick up a variable comment."""
403         self.visit_Assign(node)  # type: ignore
404 
405     def visit_Expr(self, node: ast.Expr) -> None:
406         """Handles Expr node and pick up a comment if string."""
407         if (isinstance(self.previous, ASSIGN_NODES) and isinstance(node.value, ast.Str)):
408             try:
409                 targets = get_assign_targets(self.previous)
410                 varnames = get_lvar_names(targets[0], self.get_self())
411                 for varname in varnames:
412                     if isinstance(node.value.s, str):
413                         docstring = node.value.s
414                     else:
415                         docstring = node.value.s.decode(self.encoding or 'utf-8')
416 
417                     self.add_variable_comment(varname, dedent_docstring(docstring))
418                     self.add_entry(varname)
419             except TypeError:
420                 pass  # this assignment is not new definition!
421 
422     def visit_Try(self, node: ast.Try) -> None:
423         """Handles Try node and processes body and else-clause.
424 
425         .. note:: pycode parser ignores objects definition in except-clause.
426         """
427         for subnode in node.body:
428             self.visit(subnode)
429         for subnode in node.orelse:
430             self.visit(subnode)
431 
432     def visit_ClassDef(self, node: ast.ClassDef) -> None:
433         """Handles ClassDef node and set context."""
434         self.current_classes.append(node.name)
435         self.add_entry(node.name)
436         if self.is_final(node.decorator_list):
437             self.add_final_entry(node.name)
438         self.context.append(node.name)
439         self.previous = node
440         for child in node.body:
441             self.visit(child)
442         self.context.pop()
443         self.current_classes.pop()
444 
445     def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
446         """Handles FunctionDef node and set context."""
447         if self.current_function is None:
448             self.add_entry(node.name)  # should be called before setting self.current_function
449             if self.is_final(node.decorator_list):
450                 self.add_final_entry(node.name)
451             if self.is_overload(node.decorator_list):
452                 self.add_overload_entry(node)
453             self.context.append(node.name)
454             self.current_function = node
455             for child in node.body:
456                 self.visit(child)
457             self.context.pop()
458             self.current_function = None
459 
460     def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:
461         """Handles AsyncFunctionDef node and set context."""
462         self.visit_FunctionDef(node)  # type: ignore
463 
464 
465 class DefinitionFinder(TokenProcessor):
466     """Python source code parser to detect location of functions,
467     classes and methods.
468     """
469 
470     def __init__(self, lines: List[str]) -> None:
471         super().__init__(lines)
472         self.decorator = None   # type: Token
473         self.context = []       # type: List[str]
474         self.indents = []       # type: List
475         self.definitions = {}   # type: Dict[str, Tuple[str, int, int]]
476 
477     def add_definition(self, name: str, entry: Tuple[str, int, int]) -> None:
478         """Add a location of definition."""
479         if self.indents and self.indents[-1][0] == 'def' and entry[0] == 'def':
480             # ignore definition of inner function
481             pass
482         else:
483             self.definitions[name] = entry
484 
485     def parse(self) -> None:
486         """Parse the code to obtain location of definitions."""
487         while True:
488             token = self.fetch_token()
489             if token is None:
490                 break
491             elif token == COMMENT:
492                 pass
493             elif token == [OP, '@'] and (self.previous is None or
494                                          self.previous.match(NEWLINE, NL, INDENT, DEDENT)):
495                 if self.decorator is None:
496                     self.decorator = token
497             elif token.match([NAME, 'class']):
498                 self.parse_definition('class')
499             elif token.match([NAME, 'def']):
500                 self.parse_definition('def')
501             elif token == INDENT:
502                 self.indents.append(('other', None, None))
503             elif token == DEDENT:
504                 self.finalize_block()
505 
506     def parse_definition(self, typ: str) -> None:
507         """Parse AST of definition."""
508         name = self.fetch_token()
509         self.context.append(name.value)
510         funcname = '.'.join(self.context)
511 
512         if self.decorator:
513             start_pos = self.decorator.start[0]
514             self.decorator = None
515         else:
516             start_pos = name.start[0]
517 
518         self.fetch_until([OP, ':'])
519         if self.fetch_token().match(COMMENT, NEWLINE):
520             self.fetch_until(INDENT)
521             self.indents.append((typ, funcname, start_pos))
522         else:
523             # one-liner
524             self.add_definition(funcname, (typ, start_pos, name.end[0]))
525             self.context.pop()
526 
527     def finalize_block(self) -> None:
528         """Finalize definition block."""
529         definition = self.indents.pop()
530         if definition[0] != 'other':
531             typ, funcname, start_pos = definition
532             end_pos = self.current.end[0] - 1
533             while emptyline_re.match(self.get_line(end_pos)):
534                 end_pos -= 1
535 
536             self.add_definition(funcname, (typ, start_pos, end_pos))
537             self.context.pop()
538 
539 
540 class Parser:
541     """Python source code parser to pick up variable comments.
542 
543     This is a better wrapper for ``VariableCommentPicker``.
544     """
545 
546     def __init__(self, code: str, encoding: str = 'utf-8') -> None:
547         self.code = filter_whitespace(code)
548         self.encoding = encoding
549         self.annotations = {}       # type: Dict[Tuple[str, str], str]
550         self.comments = {}          # type: Dict[Tuple[str, str], str]
551         self.deforders = {}         # type: Dict[str, int]
552         self.definitions = {}       # type: Dict[str, Tuple[str, int, int]]
553         self.finals = []            # type: List[str]
554         self.overloads = {}         # type: Dict[str, List[Signature]]
555 
556     def parse(self) -> None:
557         """Parse the source code."""
558         self.parse_comments()
559         self.parse_definition()
560 
561     def parse_comments(self) -> None:
562         """Parse the code and pick up comments."""
563         tree = parse(self.code)
564         picker = VariableCommentPicker(self.code.splitlines(True), self.encoding)
565         picker.visit(tree)
566         self.annotations = picker.annotations
567         self.comments = picker.comments
568         self.deforders = picker.deforders
569         self.finals = picker.finals
570         self.overloads = picker.overloads
571 
572     def parse_definition(self) -> None:
573         """Parse the location of definitions from the code."""
574         parser = DefinitionFinder(self.code.splitlines(True))
575         parser.parse()
576         self.definitions = parser.definitions

</code><intended_behavior>This file possibly contains logic for parsing and analyzing Python code within the documentation. To resolve the issue, the parser's handling of code blocks should be extended to automatically dedent them unless a specific `:dedent:` value is given. This will allow for easier inclusion of code samples without manually adjusting indentation.</intended_behavior>, <file>sphinx/domains/std.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.std
3     ~~~~~~~~~~~~~~~~~~
4 
5     The standard domain.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 import warnings
14 from copy import copy
15 from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union, cast
16 
17 from docutils import nodes
18 from docutils.nodes import Element, Node, system_message
19 from docutils.parsers.rst import Directive, directives
20 from docutils.statemachine import StringList
21 
22 from sphinx import addnodes
23 from sphinx.addnodes import desc_signature, pending_xref
24 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
25 from sphinx.directives import ObjectDescription
26 from sphinx.domains import Domain, ObjType
27 from sphinx.locale import _, __
28 from sphinx.roles import XRefRole
29 from sphinx.util import docname_join, logging, ws_re
30 from sphinx.util.docutils import SphinxDirective
31 from sphinx.util.nodes import clean_astext, make_id, make_refnode
32 from sphinx.util.typing import RoleFunction
33 
34 if False:
35     # For type annotation
36     from typing import Type  # for python3.5.1
37 
38     from sphinx.application import Sphinx
39     from sphinx.builders import Builder
40     from sphinx.environment import BuildEnvironment
41 
42 logger = logging.getLogger(__name__)
43 
44 
45 # RE for option descriptions
46 option_desc_re = re.compile(r'((?:/|--|-|\+)?[^\s=]+)(=?\s*.*)')
47 # RE for grammar tokens
48 token_re = re.compile(r'`(\w+)`', re.U)
49 
50 
51 class GenericObject(ObjectDescription[str]):
52     """
53     A generic x-ref directive registered with Sphinx.add_object_type().
54     """
55     indextemplate = ''
56     parse_node = None  # type: Callable[[GenericObject, BuildEnvironment, str, desc_signature], str]  # NOQA
57 
58     def handle_signature(self, sig: str, signode: desc_signature) -> str:
59         if self.parse_node:
60             name = self.parse_node(self.env, sig, signode)
61         else:
62             signode.clear()
63             signode += addnodes.desc_name(sig, sig)
64             # normalize whitespace like XRefRole does
65             name = ws_re.sub(' ', sig)
66         return name
67 
68     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:
69         node_id = make_id(self.env, self.state.document, self.objtype, name)
70         signode['ids'].append(node_id)
71 
72         # Assign old styled node_id not to break old hyperlinks (if possible)
73         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
74         old_node_id = self.make_old_id(name)
75         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:
76             signode['ids'].append(old_node_id)
77 
78         self.state.document.note_explicit_target(signode)
79 
80         if self.indextemplate:
81             colon = self.indextemplate.find(':')
82             if colon != -1:
83                 indextype = self.indextemplate[:colon].strip()
84                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)
85             else:
86                 indextype = 'single'
87                 indexentry = self.indextemplate % (name,)
88             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))
89 
90         std = cast(StandardDomain, self.env.get_domain('std'))
91         std.note_object(self.objtype, name, node_id, location=signode)
92 
93     def make_old_id(self, name: str) -> str:
94         """Generate old styled node_id for generic objects.
95 
96         .. note:: Old Styled node_id was used until Sphinx-3.0.
97                   This will be removed in Sphinx-5.0.
98         """
99         return self.objtype + '-' + name
100 
101 
102 class EnvVar(GenericObject):
103     indextemplate = _('environment variable; %s')
104 
105 
106 class EnvVarXRefRole(XRefRole):
107     """
108     Cross-referencing role for environment variables (adds an index entry).
109     """
110 
111     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
112                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
113         if not is_ref:
114             return [node], []
115         varname = node['reftarget']
116         tgtid = 'index-%s' % env.new_serialno('index')
117         indexnode = addnodes.index()
118         indexnode['entries'] = [
119             ('single', varname, tgtid, '', None),
120             ('single', _('environment variable; %s') % varname, tgtid, '', None)
121         ]
122         targetnode = nodes.target('', '', ids=[tgtid])
123         document.note_explicit_target(targetnode)
124         return [indexnode, targetnode, node], []
125 
126 
127 class Target(SphinxDirective):
128     """
129     Generic target for user-defined cross-reference types.
130     """
131     indextemplate = ''
132 
133     has_content = False
134     required_arguments = 1
135     optional_arguments = 0
136     final_argument_whitespace = True
137     option_spec = {}  # type: Dict
138 
139     def run(self) -> List[Node]:
140         # normalize whitespace in fullname like XRefRole does
141         fullname = ws_re.sub(' ', self.arguments[0].strip())
142         node_id = make_id(self.env, self.state.document, self.name, fullname)
143         node = nodes.target('', '', ids=[node_id])
144         self.set_source_info(node)
145 
146         # Assign old styled node_id not to break old hyperlinks (if possible)
147         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
148         old_node_id = self.make_old_id(fullname)
149         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:
150             node['ids'].append(old_node_id)
151 
152         self.state.document.note_explicit_target(node)
153         ret = [node]  # type: List[Node]
154         if self.indextemplate:
155             indexentry = self.indextemplate % (fullname,)
156             indextype = 'single'
157             colon = indexentry.find(':')
158             if colon != -1:
159                 indextype = indexentry[:colon].strip()
160                 indexentry = indexentry[colon + 1:].strip()
161             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])
162             ret.insert(0, inode)
163         name = self.name
164         if ':' in self.name:
165             _, name = self.name.split(':', 1)
166 
167         std = cast(StandardDomain, self.env.get_domain('std'))
168         std.note_object(name, fullname, node_id, location=node)
169 
170         return ret
171 
172     def make_old_id(self, name: str) -> str:
173         """Generate old styled node_id for targets.
174 
175         .. note:: Old Styled node_id was used until Sphinx-3.0.
176                   This will be removed in Sphinx-5.0.
177         """
178         return self.name + '-' + name
179 
180 
181 class Cmdoption(ObjectDescription[str]):
182     """
183     Description of a command-line option (.. option).
184     """
185 
186     def handle_signature(self, sig: str, signode: desc_signature) -> str:
187         """Transform an option description into RST nodes."""
188         count = 0
189         firstname = ''
190         for potential_option in sig.split(', '):
191             potential_option = potential_option.strip()
192             m = option_desc_re.match(potential_option)
193             if not m:
194                 logger.warning(__('Malformed option description %r, should '
195                                   'look like "opt", "-opt args", "--opt args", '
196                                   '"/opt args" or "+opt args"'), potential_option,
197                                location=signode)
198                 continue
199             optname, args = m.groups()
200             if optname.endswith('[') and args.endswith(']'):
201                 # optional value surrounded by brackets (ex. foo[=bar])
202                 optname = optname[:-1]
203                 args = '[' + args
204 
205             if count:
206                 signode += addnodes.desc_addname(', ', ', ')
207             signode += addnodes.desc_name(optname, optname)
208             signode += addnodes.desc_addname(args, args)
209             if not count:
210                 firstname = optname
211                 signode['allnames'] = [optname]
212             else:
213                 signode['allnames'].append(optname)
214             count += 1
215         if not firstname:
216             raise ValueError
217         return firstname
218 
219     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:
220         currprogram = self.env.ref_context.get('std:program')
221         for optname in signode.get('allnames', []):
222             prefixes = ['cmdoption']
223             if currprogram:
224                 prefixes.append(currprogram)
225             if not optname.startswith(('-', '/')):
226                 prefixes.append('arg')
227             prefix = '-'.join(prefixes)
228             node_id = make_id(self.env, self.state.document, prefix, optname)
229             signode['ids'].append(node_id)
230 
231             old_node_id = self.make_old_id(prefix, optname)
232             if old_node_id not in self.state.document.ids and \
233                old_node_id not in signode['ids']:
234                 signode['ids'].append(old_node_id)
235 
236         self.state.document.note_explicit_target(signode)
237 
238         domain = cast(StandardDomain, self.env.get_domain('std'))
239         for optname in signode.get('allnames', []):
240             domain.add_program_option(currprogram, optname,
241                                       self.env.docname, signode['ids'][0])
242 
243         # create an index entry
244         if currprogram:
245             descr = _('%s command line option') % currprogram
246         else:
247             descr = _('command line option')
248         for option in sig.split(', '):
249             entry = '; '.join([descr, option])
250             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))
251 
252     def make_old_id(self, prefix: str, optname: str) -> str:
253         """Generate old styled node_id for cmdoption.
254 
255         .. note:: Old Styled node_id was used until Sphinx-3.0.
256                   This will be removed in Sphinx-5.0.
257         """
258         return nodes.make_id(prefix + '-' + optname)
259 
260 
261 class Program(SphinxDirective):
262     """
263     Directive to name the program for which options are documented.
264     """
265 
266     has_content = False
267     required_arguments = 1
268     optional_arguments = 0
269     final_argument_whitespace = True
270     option_spec = {}  # type: Dict
271 
272     def run(self) -> List[Node]:
273         program = ws_re.sub('-', self.arguments[0].strip())
274         if program == 'None':
275             self.env.ref_context.pop('std:program', None)
276         else:
277             self.env.ref_context['std:program'] = program
278         return []
279 
280 
281 class OptionXRefRole(XRefRole):
282     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
283                      title: str, target: str) -> Tuple[str, str]:
284         refnode['std:program'] = env.ref_context.get('std:program')
285         return title, target
286 
287 
288 def split_term_classifiers(line: str) -> List[Optional[str]]:
289     # split line into a term and classifiers. if no classifier, None is used..
290     parts = re.split(' +: +', line) + [None]
291     return parts
292 
293 
294 def make_glossary_term(env: "BuildEnvironment", textnodes: Iterable[Node], index_key: str,
295                        source: str, lineno: int, node_id: str = None,
296                        document: nodes.document = None) -> nodes.term:
297     # get a text-only representation of the term and register it
298     # as a cross-reference target
299     term = nodes.term('', '', *textnodes)
300     term.source = source
301     term.line = lineno
302     termtext = term.astext()
303 
304     if node_id:
305         # node_id is given from outside (mainly i18n module), use it forcedly
306         term['ids'].append(node_id)
307     elif document:
308         node_id = make_id(env, document, 'term', termtext)
309         term['ids'].append(node_id)
310         document.note_explicit_target(term)
311     else:
312         warnings.warn('make_glossary_term() expects document is passed as an argument.',
313                       RemovedInSphinx40Warning, stacklevel=2)
314         gloss_entries = env.temp_data.setdefault('gloss_entries', set())
315         node_id = nodes.make_id('term-' + termtext)
316         if node_id == 'term':
317             # "term" is not good for node_id.  Generate it by sequence number instead.
318             node_id = 'term-%d' % env.new_serialno('glossary')
319 
320         while node_id in gloss_entries:
321             node_id = 'term-%d' % env.new_serialno('glossary')
322         gloss_entries.add(node_id)
323         term['ids'].append(node_id)
324 
325     std = cast(StandardDomain, env.get_domain('std'))
326     std.note_object('term', termtext, node_id, location=term)
327 
328     # add an index entry too
329     indexnode = addnodes.index()
330     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]
331     indexnode.source, indexnode.line = term.source, term.line
332     term.append(indexnode)
333 
334     return term
335 
336 
337 class Glossary(SphinxDirective):
338     """
339     Directive to create a glossary with cross-reference targets for :term:
340     roles.
341     """
342 
343     has_content = True
344     required_arguments = 0
345     optional_arguments = 0
346     final_argument_whitespace = False
347     option_spec = {
348         'sorted': directives.flag,
349     }
350 
351     def run(self) -> List[Node]:
352         node = addnodes.glossary()
353         node.document = self.state.document
354 
355         # This directive implements a custom format of the reST definition list
356         # that allows multiple lines of terms before the definition.  This is
357         # easy to parse since we know that the contents of the glossary *must
358         # be* a definition list.
359 
360         # first, collect single entries
361         entries = []  # type: List[Tuple[List[Tuple[str, str, int]], StringList]]
362         in_definition = True
363         in_comment = False
364         was_empty = True
365         messages = []  # type: List[Node]
366         for line, (source, lineno) in zip(self.content, self.content.items):
367             # empty line -> add to last definition
368             if not line:
369                 if in_definition and entries:
370                     entries[-1][1].append('', source, lineno)
371                 was_empty = True
372                 continue
373             # unindented line -> a term
374             if line and not line[0].isspace():
375                 # enable comments
376                 if line.startswith('.. '):
377                     in_comment = True
378                     continue
379                 else:
380                     in_comment = False
381 
382                 # first term of definition
383                 if in_definition:
384                     if not was_empty:
385                         messages.append(self.state.reporter.warning(
386                             _('glossary term must be preceded by empty line'),
387                             source=source, line=lineno))
388                     entries.append(([(line, source, lineno)], StringList()))
389                     in_definition = False
390                 # second term and following
391                 else:
392                     if was_empty:
393                         messages.append(self.state.reporter.warning(
394                             _('glossary terms must not be separated by empty lines'),
395                             source=source, line=lineno))
396                     if entries:
397                         entries[-1][0].append((line, source, lineno))
398                     else:
399                         messages.append(self.state.reporter.warning(
400                             _('glossary seems to be misformatted, check indentation'),
401                             source=source, line=lineno))
402             elif in_comment:
403                 pass
404             else:
405                 if not in_definition:
406                     # first line of definition, determines indentation
407                     in_definition = True
408                     indent_len = len(line) - len(line.lstrip())
409                 if entries:
410                     entries[-1][1].append(line[indent_len:], source, lineno)
411                 else:
412                     messages.append(self.state.reporter.warning(
413                         _('glossary seems to be misformatted, check indentation'),
414                         source=source, line=lineno))
415             was_empty = False
416 
417         # now, parse all the entries into a big definition list
418         items = []
419         for terms, definition in entries:
420             termtexts = []          # type: List[str]
421             termnodes = []          # type: List[Node]
422             system_messages = []    # type: List[Node]
423             for line, source, lineno in terms:
424                 parts = split_term_classifiers(line)
425                 # parse the term with inline markup
426                 # classifiers (parts[1:]) will not be shown on doctree
427                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)
428 
429                 # use first classifier as a index key
430                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,
431                                           document=self.state.document)
432                 term.rawsource = line
433                 system_messages.extend(sysmsg)
434                 termtexts.append(term.astext())
435                 termnodes.append(term)
436 
437             termnodes.extend(system_messages)
438 
439             defnode = nodes.definition()
440             if definition:
441                 self.state.nested_parse(definition, definition.items[0][1],
442                                         defnode)
443             termnodes.append(defnode)
444             items.append((termtexts,
445                           nodes.definition_list_item('', *termnodes)))
446 
447         if 'sorted' in self.options:
448             items.sort(key=lambda x:
449                        unicodedata.normalize('NFD', x[0][0].lower()))
450 
451         dlist = nodes.definition_list()
452         dlist['classes'].append('glossary')
453         dlist.extend(item[1] for item in items)
454         node += dlist
455         return messages + [node]
456 
457 
458 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:
459     if len(productionGroup) != 0:
460         productionGroup += ':'
461     retnodes = []  # type: List[Node]
462     pos = 0
463     for m in token_re.finditer(text):
464         if m.start() > pos:
465             txt = text[pos:m.start()]
466             retnodes.append(nodes.Text(txt, txt))
467         refnode = pending_xref(m.group(1), reftype='token', refdomain='std',
468                                reftarget=productionGroup + m.group(1))
469         refnode += nodes.literal(m.group(1), m.group(1), classes=['xref'])
470         retnodes.append(refnode)
471         pos = m.end()
472     if pos < len(text):
473         retnodes.append(nodes.Text(text[pos:], text[pos:]))
474     return retnodes
475 
476 
477 class ProductionList(SphinxDirective):
478     """
479     Directive to list grammar productions.
480     """
481 
482     has_content = False
483     required_arguments = 1
484     optional_arguments = 0
485     final_argument_whitespace = True
486     option_spec = {}  # type: Dict
487 
488     def run(self) -> List[Node]:
489         domain = cast(StandardDomain, self.env.get_domain('std'))
490         node = addnodes.productionlist()  # type: Element
491         self.set_source_info(node)
492         # The backslash handling is from ObjectDescription.get_signatures
493         nl_escape_re = re.compile(r'\\\n')
494         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
495 
496         productionGroup = ""
497         i = 0
498         for rule in lines:
499             if i == 0 and ':' not in rule:
500                 productionGroup = rule.strip()
501                 continue
502             i += 1
503             try:
504                 name, tokens = rule.split(':', 1)
505             except ValueError:
506                 break
507             subnode = addnodes.production(rule)
508             name = name.strip()
509             subnode['tokenname'] = name
510             if subnode['tokenname']:
511                 prefix = 'grammar-token-%s' % productionGroup
512                 node_id = make_id(self.env, self.state.document, prefix, name)
513                 subnode['ids'].append(node_id)
514 
515                 # Assign old styled node_id not to break old hyperlinks (if possible)
516                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
517                 old_node_id = self.make_old_id(name)
518                 if (old_node_id not in self.state.document.ids and
519                         old_node_id not in subnode['ids']):
520                     subnode['ids'].append(old_node_id)
521 
522                 self.state.document.note_implicit_target(subnode, subnode)
523 
524                 if len(productionGroup) != 0:
525                     objName = "%s:%s" % (productionGroup, name)
526                 else:
527                     objName = name
528                 domain.note_object('token', objName, node_id, location=node)
529             subnode.extend(token_xrefs(tokens, productionGroup))
530             node.append(subnode)
531         return [node]
532 
533     def make_old_id(self, token: str) -> str:
534         """Generate old styled node_id for tokens.
535 
536         .. note:: Old Styled node_id was used until Sphinx-3.0.
537                   This will be removed in Sphinx-5.0.
538         """
539         return nodes.make_id('grammar-token-' + token)
540 
541 
542 class TokenXRefRole(XRefRole):
543     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
544                      title: str, target: str) -> Tuple[str, str]:
545         target = target.lstrip('~')  # a title-specific thing
546         if not self.has_explicit_title and title[0] == '~':
547             if ':' in title:
548                 _, title = title.split(':')
549             else:
550                 title = title[1:]
551         return title, target
552 
553 
554 class StandardDomain(Domain):
555     """
556     Domain for all objects that don't fit into another domain or are added
557     via the application interface.
558     """
559 
560     name = 'std'
561     label = 'Default'
562 
563     object_types = {
564         'term': ObjType(_('glossary term'), 'term', searchprio=-1),
565         'token': ObjType(_('grammar token'), 'token', searchprio=-1),
566         'label': ObjType(_('reference label'), 'ref', 'keyword',
567                          searchprio=-1),
568         'envvar': ObjType(_('environment variable'), 'envvar'),
569         'cmdoption': ObjType(_('program option'), 'option'),
570         'doc': ObjType(_('document'), 'doc', searchprio=-1)
571     }  # type: Dict[str, ObjType]
572 
573     directives = {
574         'program': Program,
575         'cmdoption': Cmdoption,  # old name for backwards compatibility
576         'option': Cmdoption,
577         'envvar': EnvVar,
578         'glossary': Glossary,
579         'productionlist': ProductionList,
580     }  # type: Dict[str, Type[Directive]]
581     roles = {
582         'option':  OptionXRefRole(warn_dangling=True),
583         'envvar':  EnvVarXRefRole(),
584         # links to tokens in grammar productions
585         'token':   TokenXRefRole(),
586         # links to terms in glossary
587         'term':    XRefRole(innernodeclass=nodes.inline,
588                             warn_dangling=True),
589         # links to headings or arbitrary labels
590         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,
591                             warn_dangling=True),
592         # links to labels of numbered figures, tables and code-blocks
593         'numref':  XRefRole(lowercase=True,
594                             warn_dangling=True),
595         # links to labels, without a different title
596         'keyword': XRefRole(warn_dangling=True),
597         # links to documents
598         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),
599     }  # type: Dict[str, Union[RoleFunction, XRefRole]]
600 
601     initial_data = {
602         'progoptions': {},      # (program, name) -> docname, labelid
603         'objects': {},          # (type, name) -> docname, labelid
604         'labels': {             # labelname -> docname, labelid, sectionname
605             'genindex': ('genindex', '', _('Index')),
606             'modindex': ('py-modindex', '', _('Module Index')),
607             'search':   ('search', '', _('Search Page')),
608         },
609         'anonlabels': {         # labelname -> docname, labelid
610             'genindex': ('genindex', ''),
611             'modindex': ('py-modindex', ''),
612             'search':   ('search', ''),
613         },
614     }
615 
616     dangling_warnings = {
617         'term': 'term not in glossary: %(target)s',
618         'numref':  'undefined label: %(target)s',
619         'keyword': 'unknown keyword: %(target)s',
620         'doc': 'unknown document: %(target)s',
621         'option': 'unknown option: %(target)s',
622     }
623 
624     enumerable_nodes = {  # node_class -> (figtype, title_getter)
625         nodes.figure: ('figure', None),
626         nodes.table: ('table', None),
627         nodes.container: ('code-block', None),
628     }  # type: Dict[Type[Node], Tuple[str, Callable]]
629 
630     def __init__(self, env: "BuildEnvironment") -> None:
631         super().__init__(env)
632 
633         # set up enumerable nodes
634         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance
635         for node, settings in env.app.registry.enumerable_nodes.items():
636             self.enumerable_nodes[node] = settings
637 
638     def note_hyperlink_target(self, name: str, docname: str, node_id: str,
639                               title: str = '') -> None:
640         """Add a hyperlink target for cross reference.
641 
642         .. warning::
643 
644            This is only for internal use.  Please don't use this from your extension.
645            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to
646            add a hyperlink target to the document.
647 
648            This only adds a hyperlink target to the StandardDomain.  And this does not add a
649            node_id to node.  Therefore, it is very fragile to calling this without
650            understanding hyperlink target framework in both docutils and Sphinx.
651 
652         .. versionadded:: 3.0
653         """
654         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):
655             logger.warning(__('duplicate label %s, other instance in %s'),
656                            name, self.env.doc2path(self.anonlabels[name][0]))
657 
658         self.anonlabels[name] = (docname, node_id)
659         if title:
660             self.labels[name] = (docname, node_id, title)
661 
662     @property
663     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
664         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid
665 
666     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None
667                     ) -> None:
668         """Note a generic object for cross reference.
669 
670         .. versionadded:: 3.0
671         """
672         if (objtype, name) in self.objects:
673             docname = self.objects[objtype, name][0]
674             logger.warning(__('duplicate %s description of %s, other instance in %s'),
675                            objtype, name, docname, location=location)
676         self.objects[objtype, name] = (self.env.docname, labelid)
677 
678     def add_object(self, objtype: str, name: str, docname: str, labelid: str) -> None:
679         warnings.warn('StandardDomain.add_object() is deprecated.',
680                       RemovedInSphinx50Warning, stacklevel=2)
681         self.objects[objtype, name] = (docname, labelid)
682 
683     @property
684     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
685         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid
686 
687     @property
688     def labels(self) -> Dict[str, Tuple[str, str, str]]:
689         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname
690 
691     @property
692     def anonlabels(self) -> Dict[str, Tuple[str, str]]:
693         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid
694 
695     def clear_doc(self, docname: str) -> None:
696         key = None  # type: Any
697         for key, (fn, _l) in list(self.progoptions.items()):
698             if fn == docname:
699                 del self.progoptions[key]
700         for key, (fn, _l) in list(self.objects.items()):
701             if fn == docname:
702                 del self.objects[key]
703         for key, (fn, _l, _l) in list(self.labels.items()):
704             if fn == docname:
705                 del self.labels[key]
706         for key, (fn, _l) in list(self.anonlabels.items()):
707             if fn == docname:
708                 del self.anonlabels[key]
709 
710     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
711         # XXX duplicates?
712         for key, data in otherdata['progoptions'].items():
713             if data[0] in docnames:
714                 self.progoptions[key] = data
715         for key, data in otherdata['objects'].items():
716             if data[0] in docnames:
717                 self.objects[key] = data
718         for key, data in otherdata['labels'].items():
719             if data[0] in docnames:
720                 self.labels[key] = data
721         for key, data in otherdata['anonlabels'].items():
722             if data[0] in docnames:
723                 self.anonlabels[key] = data
724 
725     def process_doc(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
726         for name, explicit in document.nametypes.items():
727             if not explicit:
728                 continue
729             labelid = document.nameids[name]
730             if labelid is None:
731                 continue
732             node = document.ids[labelid]
733             if isinstance(node, nodes.target) and 'refid' in node:
734                 # indirect hyperlink targets
735                 node = document.ids.get(node['refid'])
736                 labelid = node['names'][0]
737             if (node.tagname == 'footnote' or
738                     'refuri' in node or
739                     node.tagname.startswith('desc_')):
740                 # ignore footnote labels, labels automatically generated from a
741                 # link and object descriptions
742                 continue
743             if name in self.labels:
744                 logger.warning(__('duplicate label %s, other instance in %s'),
745                                name, env.doc2path(self.labels[name][0]),
746                                location=node)
747             self.anonlabels[name] = docname, labelid
748             if node.tagname == 'section':
749                 title = cast(nodes.title, node[0])
750                 sectname = clean_astext(title)
751             elif node.tagname == 'rubric':
752                 sectname = clean_astext(node)
753             elif self.is_enumerable_node(node):
754                 sectname = self.get_numfig_title(node)
755                 if not sectname:
756                     continue
757             else:
758                 toctree = next(iter(node.traverse(addnodes.toctree)), None)
759                 if toctree and toctree.get('caption'):
760                     sectname = toctree.get('caption')
761                 else:
762                     # anonymous-only labels
763                     continue
764             self.labels[name] = docname, labelid, sectname
765 
766     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:
767         self.progoptions[program, name] = (docname, labelid)
768 
769     def build_reference_node(self, fromdocname: str, builder: "Builder", docname: str,
770                              labelid: str, sectname: str, rolename: str, **options: Any
771                              ) -> Element:
772         nodeclass = options.pop('nodeclass', nodes.reference)
773         newnode = nodeclass('', '', internal=True, **options)
774         innernode = nodes.inline(sectname, sectname)
775         if innernode.get('classes') is not None:
776             innernode['classes'].append('std')
777             innernode['classes'].append('std-' + rolename)
778         if docname == fromdocname:
779             newnode['refid'] = labelid
780         else:
781             # set more info in contnode; in case the
782             # get_relative_uri call raises NoUri,
783             # the builder will then have to resolve these
784             contnode = pending_xref('')
785             contnode['refdocname'] = docname
786             contnode['refsectname'] = sectname
787             newnode['refuri'] = builder.get_relative_uri(
788                 fromdocname, docname)
789             if labelid:
790                 newnode['refuri'] += '#' + labelid
791         newnode.append(innernode)
792         return newnode
793 
794     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
795                      typ: str, target: str, node: pending_xref, contnode: Element) -> Element:
796         if typ == 'ref':
797             resolver = self._resolve_ref_xref
798         elif typ == 'numref':
799             resolver = self._resolve_numref_xref
800         elif typ == 'keyword':
801             resolver = self._resolve_keyword_xref
802         elif typ == 'doc':
803             resolver = self._resolve_doc_xref
804         elif typ == 'option':
805             resolver = self._resolve_option_xref
806         elif typ == 'citation':
807             warnings.warn('pending_xref(domain=std, type=citation) is deprecated: %r' % node,
808                           RemovedInSphinx40Warning, stacklevel=2)
809             domain = env.get_domain('citation')
810             return domain.resolve_xref(env, fromdocname, builder, typ, target, node, contnode)
811         elif typ == 'term':
812             resolver = self._resolve_term_xref
813         else:
814             resolver = self._resolve_obj_xref
815 
816         return resolver(env, fromdocname, builder, typ, target, node, contnode)
817 
818     def _resolve_ref_xref(self, env: "BuildEnvironment", fromdocname: str,
819                           builder: "Builder", typ: str, target: str, node: pending_xref,
820                           contnode: Element) -> Element:
821         if node['refexplicit']:
822             # reference to anonymous label; the reference uses
823             # the supplied link caption
824             docname, labelid = self.anonlabels.get(target, ('', ''))
825             sectname = node.astext()
826         else:
827             # reference to named label; the final node will
828             # contain the section name after the label
829             docname, labelid, sectname = self.labels.get(target, ('', '', ''))
830         if not docname:
831             return None
832 
833         return self.build_reference_node(fromdocname, builder,
834                                          docname, labelid, sectname, 'ref')
835 
836     def _resolve_numref_xref(self, env: "BuildEnvironment", fromdocname: str,
837                              builder: "Builder", typ: str, target: str,
838                              node: pending_xref, contnode: Element) -> Element:
839         if target in self.labels:
840             docname, labelid, figname = self.labels.get(target, ('', '', ''))
841         else:
842             docname, labelid = self.anonlabels.get(target, ('', ''))
843             figname = None
844 
845         if not docname:
846             return None
847 
848         target_node = env.get_doctree(docname).ids.get(labelid)
849         figtype = self.get_enumerable_node_type(target_node)
850         if figtype is None:
851             return None
852 
853         if figtype != 'section' and env.config.numfig is False:
854             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)
855             return contnode
856 
857         try:
858             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)
859             if fignumber is None:
860                 return contnode
861         except ValueError:
862             logger.warning(__("Failed to create a cross reference. Any number is not "
863                               "assigned: %s"),
864                            labelid, location=node)
865             return contnode
866 
867         try:
868             if node['refexplicit']:
869                 title = contnode.astext()
870             else:
871                 title = env.config.numfig_format.get(figtype, '')
872 
873             if figname is None and '{name}' in title:
874                 logger.warning(__('the link has no caption: %s'), title, location=node)
875                 return contnode
876             else:
877                 fignum = '.'.join(map(str, fignumber))
878                 if '{name}' in title or 'number' in title:
879                     # new style format (cf. "Fig.{number}")
880                     if figname:
881                         newtitle = title.format(name=figname, number=fignum)
882                     else:
883                         newtitle = title.format(number=fignum)
884                 else:
885                     # old style format (cf. "Fig.%s")
886                     newtitle = title % fignum
887         except KeyError as exc:
888             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)
889             return contnode
890         except TypeError:
891             logger.warning(__('invalid numfig_format: %s'), title, location=node)
892             return contnode
893 
894         return self.build_reference_node(fromdocname, builder,
895                                          docname, labelid, newtitle, 'numref',
896                                          nodeclass=addnodes.number_reference,
897                                          title=title)
898 
899     def _resolve_keyword_xref(self, env: "BuildEnvironment", fromdocname: str,
900                               builder: "Builder", typ: str, target: str,
901                               node: pending_xref, contnode: Element) -> Element:
902         # keywords are oddballs: they are referenced by named labels
903         docname, labelid, _ = self.labels.get(target, ('', '', ''))
904         if not docname:
905             return None
906         return make_refnode(builder, fromdocname, docname,
907                             labelid, contnode)
908 
909     def _resolve_doc_xref(self, env: "BuildEnvironment", fromdocname: str,
910                           builder: "Builder", typ: str, target: str,
911                           node: pending_xref, contnode: Element) -> Element:
912         # directly reference to document by source name; can be absolute or relative
913         refdoc = node.get('refdoc', fromdocname)
914         docname = docname_join(refdoc, node['reftarget'])
915         if docname not in env.all_docs:
916             return None
917         else:
918             if node['refexplicit']:
919                 # reference with explicit title
920                 caption = node.astext()
921             else:
922                 caption = clean_astext(env.titles[docname])
923             innernode = nodes.inline(caption, caption, classes=['doc'])
924             return make_refnode(builder, fromdocname, docname, None, innernode)
925 
926     def _resolve_option_xref(self, env: "BuildEnvironment", fromdocname: str,
927                              builder: "Builder", typ: str, target: str,
928                              node: pending_xref, contnode: Element) -> Element:
929         progname = node.get('std:program')
930         target = target.strip()
931         docname, labelid = self.progoptions.get((progname, target), ('', ''))
932         if not docname:
933             commands = []
934             while ws_re.search(target):
935                 subcommand, target = ws_re.split(target, 1)
936                 commands.append(subcommand)
937                 progname = "-".join(commands)
938 
939                 docname, labelid = self.progoptions.get((progname, target), ('', ''))
940                 if docname:
941                     break
942             else:
943                 return None
944 
945         return make_refnode(builder, fromdocname, docname,
946                             labelid, contnode)
947 
948     def _resolve_term_xref(self, env: "BuildEnvironment", fromdocname: str,
949                            builder: "Builder", typ: str, target: str,
950                            node: pending_xref, contnode: Element) -> Element:
951         result = self._resolve_obj_xref(env, fromdocname, builder, typ,
952                                         target, node, contnode)
953         if result:
954             return result
955         else:
956             for objtype, term in self.objects:
957                 if objtype == 'term' and term.lower() == target.lower():
958                     docname, labelid = self.objects[objtype, term]
959                     logger.warning(__('term %s not found in case sensitive match.'
960                                       'made a reference to %s instead.'),
961                                    target, term, location=node, type='ref', subtype='term')
962                     break
963             else:
964                 docname, labelid = '', ''
965             if not docname:
966                 return None
967             return make_refnode(builder, fromdocname, docname,
968                                 labelid, contnode)
969 
970     def _resolve_obj_xref(self, env: "BuildEnvironment", fromdocname: str,
971                           builder: "Builder", typ: str, target: str,
972                           node: pending_xref, contnode: Element) -> Element:
973         objtypes = self.objtypes_for_role(typ) or []
974         for objtype in objtypes:
975             if (objtype, target) in self.objects:
976                 docname, labelid = self.objects[objtype, target]
977                 break
978         else:
979             docname, labelid = '', ''
980         if not docname:
981             return None
982         return make_refnode(builder, fromdocname, docname,
983                             labelid, contnode)
984 
985     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str,
986                          builder: "Builder", target: str, node: pending_xref,
987                          contnode: Element) -> List[Tuple[str, Element]]:
988         results = []  # type: List[Tuple[str, Element]]
989         ltarget = target.lower()  # :ref: lowercases its target automatically
990         for role in ('ref', 'option'):  # do not try "keyword"
991             res = self.resolve_xref(env, fromdocname, builder, role,
992                                     ltarget if role == 'ref' else target,
993                                     node, contnode)
994             if res:
995                 results.append(('std:' + role, res))
996         # all others
997         for objtype in self.object_types:
998             key = (objtype, target)
999             if objtype == 'term':
1000                 key = (objtype, ltarget)
1001             if key in self.objects:
1002                 docname, labelid = self.objects[key]
1003                 results.append(('std:' + self.role_for_objtype(objtype),
1004                                 make_refnode(builder, fromdocname, docname,
1005                                              labelid, contnode)))
1006         return results
1007 
1008     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1009         # handle the special 'doc' reference here
1010         for doc in self.env.all_docs:
1011             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)
1012         for (prog, option), info in self.progoptions.items():
1013             if prog:
1014                 fullname = ".".join([prog, option])
1015                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)
1016             else:
1017                 yield (option, option, 'cmdoption', info[0], info[1], 1)
1018         for (type, name), info in self.objects.items():
1019             yield (name, name, type, info[0], info[1],
1020                    self.object_types[type].attrs['searchprio'])
1021         for name, (docname, labelid, sectionname) in self.labels.items():
1022             yield (name, sectionname, 'label', docname, labelid, -1)
1023         # add anonymous-only labels as well
1024         non_anon_labels = set(self.labels)
1025         for name, (docname, labelid) in self.anonlabels.items():
1026             if name not in non_anon_labels:
1027                 yield (name, name, 'label', docname, labelid, -1)
1028 
1029     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
1030         # never prepend "Default"
1031         return type.lname
1032 
1033     def is_enumerable_node(self, node: Node) -> bool:
1034         return node.__class__ in self.enumerable_nodes
1035 
1036     def get_numfig_title(self, node: Node) -> str:
1037         """Get the title of enumerable nodes to refer them using its title"""
1038         if self.is_enumerable_node(node):
1039             elem = cast(Element, node)
1040             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))
1041             if title_getter:
1042                 return title_getter(elem)
1043             else:
1044                 for subnode in elem:
1045                     if isinstance(subnode, (nodes.caption, nodes.title)):
1046                         return clean_astext(subnode)
1047 
1048         return None
1049 
1050     def get_enumerable_node_type(self, node: Node) -> str:
1051         """Get type of enumerable nodes."""
1052         def has_child(node: Element, cls: "Type") -> bool:
1053             return any(isinstance(child, cls) for child in node)
1054 
1055         if isinstance(node, nodes.section):
1056             return 'section'
1057         elif (isinstance(node, nodes.container) and
1058               'literal_block' in node and
1059               has_child(node, nodes.literal_block)):
1060             # given node is a code-block having caption
1061             return 'code-block'
1062         else:
1063             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))
1064             return figtype
1065 
1066     def get_fignumber(self, env: "BuildEnvironment", builder: "Builder",
1067                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:
1068         if figtype == 'section':
1069             if builder.name == 'latex':
1070                 return tuple()
1071             elif docname not in env.toc_secnumbers:
1072                 raise ValueError  # no number assigned
1073             else:
1074                 anchorname = '#' + target_node['ids'][0]
1075                 if anchorname not in env.toc_secnumbers[docname]:
1076                     # try first heading which has no anchor
1077                     return env.toc_secnumbers[docname].get('')
1078                 else:
1079                     return env.toc_secnumbers[docname].get(anchorname)
1080         else:
1081             try:
1082                 figure_id = target_node['ids'][0]
1083                 return env.toc_fignumbers[docname][figtype][figure_id]
1084             except (KeyError, IndexError) as exc:
1085                 # target_node is found, but fignumber is not assigned.
1086                 # Maybe it is defined in orphaned document.
1087                 raise ValueError from exc
1088 
1089     def get_full_qualified_name(self, node: Element) -> str:
1090         if node.get('reftype') == 'option':
1091             progname = node.get('std:program')
1092             command = ws_re.split(node.get('reftarget'))
1093             if progname:
1094                 command.insert(0, progname)
1095             option = command.pop()
1096             if command:
1097                 return '.'.join(['-'.join(command), option])
1098             else:
1099                 return None
1100         else:
1101             return None
1102 
1103     def note_citations(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1104         warnings.warn('StandardDomain.note_citations() is deprecated.',
1105                       RemovedInSphinx40Warning, stacklevel=2)
1106 
1107     def note_citation_refs(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1108         warnings.warn('StandardDomain.note_citation_refs() is deprecated.',
1109                       RemovedInSphinx40Warning, stacklevel=2)
1110 
1111     def note_labels(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1112         warnings.warn('StandardDomain.note_labels() is deprecated.',
1113                       RemovedInSphinx40Warning, stacklevel=2)
1114 
1115 
1116 def warn_missing_reference(app: "Sphinx", domain: Domain, node: pending_xref) -> bool:
1117     if (domain and domain.name != 'std') or node['reftype'] != 'ref':
1118         return None
1119     else:
1120         target = node['reftarget']
1121         if target not in domain.anonlabels:  # type: ignore
1122             msg = __('undefined label: %s')
1123         else:
1124             msg = __('Failed to create a cross reference. A title or caption not found: %s')
1125 
1126         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])
1127         return True
1128 
1129 
1130 def setup(app: "Sphinx") -> Dict[str, Any]:
1131     app.add_domain(StandardDomain)
1132     app.connect('warn-missing-reference', warn_missing_reference)
1133 
1134     return {
1135         'version': 'builtin',
1136         'env_version': 1,
1137         'parallel_read_safe': True,
1138         'parallel_write_safe': True,
1139     }

</code><intended_behavior>As this file likely includes directive processing logic for the standard domain, it should be ensured that the `:dedent:` option for `code-block` and `literalinclude` directives automatically removes common leading whitespace from all lines in the absence of an explicit dedent value. The change should maintain backward compatibility, allowing users to still specify a dedent value when desired.</intended_behavior>, <file>sphinx/util/docstrings.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docstrings
3     ~~~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities for docstring processing.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import sys
13 import warnings
14 from typing import Dict, List
15 
16 from docutils.parsers.rst.states import Body
17 
18 from sphinx.deprecation import RemovedInSphinx50Warning
19 
20 field_list_item_re = re.compile(Body.patterns['field_marker'])
21 
22 
23 def extract_metadata(s: str) -> Dict[str, str]:
24     """Extract metadata from docstring."""
25     in_other_element = False
26     metadata = {}  # type: Dict[str, str]
27 
28     if not s:
29         return metadata
30 
31     for line in prepare_docstring(s):
32         if line.strip() == '':
33             in_other_element = False
34         else:
35             matched = field_list_item_re.match(line)
36             if matched and not in_other_element:
37                 field_name = matched.group()[1:].split(':', 1)[0]
38                 if field_name.startswith('meta '):
39                     name = field_name[5:].strip()
40                     metadata[name] = line[matched.end():].strip()
41             else:
42                 in_other_element = True
43 
44     return metadata
45 
46 
47 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:
48     """Convert a docstring into lines of parseable reST.  Remove common leading
49     indentation, where the indentation of a given number of lines (usually just
50     one) is ignored.
51 
52     Return the docstring as a list of lines usable for inserting into a docutils
53     ViewList (used as argument of nested_parse().)  An empty line is added to
54     act as a separator between this docstring and following content.
55     """
56     if ignore is None:
57         ignore = 1
58     else:
59         warnings.warn("The 'ignore' argument to prepare_docstring() is deprecated.",
60                       RemovedInSphinx50Warning, stacklevel=2)
61 
62     lines = s.expandtabs(tabsize).splitlines()
63     # Find minimum indentation of any non-blank lines after ignored lines.
64     margin = sys.maxsize
65     for line in lines[ignore:]:
66         content = len(line.lstrip())
67         if content:
68             indent = len(line) - content
69             margin = min(margin, indent)
70     # Remove indentation from ignored lines.
71     for i in range(ignore):
72         if i < len(lines):
73             lines[i] = lines[i].lstrip()
74     if margin < sys.maxsize:
75         for i in range(ignore, len(lines)):
76             lines[i] = lines[i][margin:]
77     # Remove any leading blank lines.
78     while lines and not lines[0]:
79         lines.pop(0)
80     # make sure there is an empty line at the end
81     if lines and lines[-1]:
82         lines.append('')
83     return lines
84 
85 
86 def prepare_commentdoc(s: str) -> List[str]:
87     """Extract documentation comment lines (starting with #:) and return them
88     as a list of lines.  Returns an empty list if there is no documentation.
89     """
90     result = []
91     lines = [line.strip() for line in s.expandtabs().splitlines()]
92     for line in lines:
93         if line.startswith('#:'):
94             line = line[2:]
95             # the first space after the comment is ignored
96             if line and line[0] == ' ':
97                 line = line[1:]
98             result.append(line)
99     if result and result[-1]:
100         result.append('')
101     return result

</code><intended_behavior>This file is probably responsible for processing docstring content. Enhancements should be made to apply the automatic dedentation logic for code blocks and literal includes within docstrings, applying a universal dedent if no `:dedent:` value is specified. This modifies the docstring handling to better format embedded code snippets.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,
18                     TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,
26                                 RemovedInSphinx60Warning)
27 from sphinx.environment import BuildEnvironment
28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
29                                          import_object)
30 from sphinx.ext.autodoc.mock import ismock, mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect, logging
34 from sphinx.util.docstrings import extract_metadata, prepare_docstring
35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
36                                  stringify_signature)
37 from sphinx.util.typing import get_type_hints, restify
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43 
44     from sphinx.ext.autodoc.directive import DocumenterBridge
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # This type isn't exposed directly in any modules, but can be found
51 # here in most Python versions
52 MethodDescriptorType = type(type.__subclasses__)
53 
54 
55 #: extended signature RE: with explicit module name separated by ::
56 py_ext_sig_re = re.compile(
57     r'''^ ([\w.]+::)?            # explicit module name
58           ([\w.]+\.)?            # module and/or class name(s)
59           (\w+)  \s*             # thing name
60           (?: \((.*)\)           # optional: arguments
61            (?:\s* -> \s* (.*))?  #           return annotation
62           )? $                   # and nothing more
63           ''', re.VERBOSE)
64 special_member_re = re.compile(r'^__\S+__$')
65 
66 
67 def identity(x: Any) -> Any:
68     return x
69 
70 
71 class _All:
72     """A special value for :*-members: that matches to any member."""
73 
74     def __contains__(self, item: Any) -> bool:
75         return True
76 
77 
78 class _Empty:
79     """A special value for :exclude-members: that never matches to any member."""
80 
81     def __contains__(self, item: Any) -> bool:
82         return False
83 
84 
85 ALL = _All()
86 EMPTY = _Empty()
87 UNINITIALIZED_ATTR = object()
88 INSTANCEATTR = object()
89 SLOTSATTR = object()
90 
91 
92 def members_option(arg: Any) -> Union[object, List[str]]:
93     """Used to convert the :members: option to auto directives."""
94     if arg in (None, True):
95         return ALL
96     elif arg is False:
97         return None
98     else:
99         return [x.strip() for x in arg.split(',') if x.strip()]
100 
101 
102 def members_set_option(arg: Any) -> Union[object, Set[str]]:
103     """Used to convert the :members: option to auto directives."""
104     warnings.warn("members_set_option() is deprecated.",
105                   RemovedInSphinx50Warning, stacklevel=2)
106     if arg is None:
107         return ALL
108     return {x.strip() for x in arg.split(',') if x.strip()}
109 
110 
111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
112     """Used to convert the :exclude-members: option."""
113     if arg in (None, True):
114         return EMPTY
115     return {x.strip() for x in arg.split(',') if x.strip()}
116 
117 
118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
119     """Used to convert the :members: option to auto directives."""
120     if arg in (None, True):
121         return 'object'
122     else:
123         return arg
124 
125 
126 def member_order_option(arg: Any) -> Optional[str]:
127     """Used to convert the :members: option to auto directives."""
128     if arg in (None, True):
129         return None
130     elif arg in ('alphabetical', 'bysource', 'groupwise'):
131         return arg
132     else:
133         raise ValueError(__('invalid value for member-order option: %s') % arg)
134 
135 
136 SUPPRESS = object()
137 
138 
139 def annotation_option(arg: Any) -> Any:
140     if arg in (None, True):
141         # suppress showing the representation of the object
142         return SUPPRESS
143     else:
144         return arg
145 
146 
147 def bool_option(arg: Any) -> bool:
148     """Used to convert flag options to auto directives.  (Instead of
149     directives.flag(), which returns None).
150     """
151     return True
152 
153 
154 def merge_special_members_option(options: Dict) -> None:
155     """Merge :special-members: option to :members: option."""
156     warnings.warn("merge_special_members_option() is deprecated.",
157                   RemovedInSphinx50Warning, stacklevel=2)
158     if 'special-members' in options and options['special-members'] is not ALL:
159         if options.get('members') is ALL:
160             pass
161         elif options.get('members'):
162             for member in options['special-members']:
163                 if member not in options['members']:
164                     options['members'].append(member)
165         else:
166             options['members'] = options['special-members']
167 
168 
169 def merge_members_option(options: Dict) -> None:
170     """Merge :*-members: option to the :members: option."""
171     if options.get('members') is ALL:
172         # merging is not needed when members: ALL
173         return
174 
175     members = options.setdefault('members', [])
176     for key in {'private-members', 'special-members'}:
177         if key in options and options[key] not in (ALL, None):
178             for member in options[key]:
179                 if member not in members:
180                     members.append(member)
181 
182 
183 # Some useful event listener factories for autodoc-process-docstring.
184 
185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
186     """Return a listener that removes the first *pre* and last *post*
187     lines of every docstring.  If *what* is a sequence of strings,
188     only docstrings of a type in *what* will be processed.
189 
190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
191 
192        from sphinx.ext.autodoc import cut_lines
193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
194 
195     This can (and should) be used in place of :confval:`automodule_skip_lines`.
196     """
197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
198                 ) -> None:
199         if what and what_ not in what:
200             return
201         del lines[:pre]
202         if post:
203             # remove one trailing blank line.
204             if lines and not lines[-1]:
205                 lines.pop(-1)
206             del lines[-post:]
207         # make sure there is a blank line at the end
208         if lines and lines[-1]:
209             lines.append('')
210     return process
211 
212 
213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
214             exclude: bool = False) -> Callable:
215     """Return a listener that either keeps, or if *exclude* is True excludes,
216     lines between lines that match the *marker* regular expression.  If no line
217     matches, the resulting docstring would be empty, so no change will be made
218     unless *keepempty* is true.
219 
220     If *what* is a sequence of strings, only docstrings of a type in *what* will
221     be processed.
222     """
223     marker_re = re.compile(marker)
224 
225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
226                 ) -> None:
227         if what and what_ not in what:
228             return
229         deleted = 0
230         delete = not exclude
231         orig_lines = lines[:]
232         for i, line in enumerate(orig_lines):
233             if delete:
234                 lines.pop(i - deleted)
235                 deleted += 1
236             if marker_re.match(line):
237                 delete = not delete
238                 if delete:
239                     lines.pop(i - deleted)
240                     deleted += 1
241         if not lines and not keepempty:
242             lines[:] = orig_lines
243         # make sure there is a blank line at the end
244         if lines and lines[-1]:
245             lines.append('')
246     return process
247 
248 
249 # This class is used only in ``sphinx.ext.autodoc.directive``,
250 # But we define this class here to keep compatibility (see #4538)
251 class Options(dict):
252     """A dict/attribute hybrid that returns None on nonexisting keys."""
253     def __getattr__(self, name: str) -> Any:
254         try:
255             return self[name.replace('_', '-')]
256         except KeyError:
257             return None
258 
259 
260 class ObjectMember(tuple):
261     """A member of object.
262 
263     This is used for the result of `Documenter.get_object_members()` to
264     represent each member of the object.
265 
266     .. Note::
267 
268        An instance of this class behaves as a tuple of (name, object)
269        for compatibility to old Sphinx.  The behavior will be dropped
270        in the future.  Therefore extensions should not use the tuple
271        interface.
272     """
273 
274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
275         return super().__new__(cls, (name, obj))  # type: ignore
276 
277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
278                  class_: Any = None, skipped: bool = False) -> None:
279         self.__name__ = name
280         self.object = obj
281         self.docstring = docstring
282         self.skipped = skipped
283         self.class_ = class_
284 
285 
286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
287 
288 
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 return True
426             except ImportError as exc:
427                 if raiseerror:
428                     raise
429                 else:
430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
431                     self.env.note_reread()
432                     return False
433 
434     def get_real_modname(self) -> str:
435         """Get the real module name of an object to document.
436 
437         It can differ from the name of the module through which the object was
438         imported.
439         """
440         return self.get_attr(self.object, '__module__', None) or self.modname
441 
442     def check_module(self) -> bool:
443         """Check if *self.object* is really defined in the module given by
444         *self.modname*.
445         """
446         if self.options.imported_members:
447             return True
448 
449         subject = inspect.unpartial(self.object)
450         modname = self.get_attr(subject, '__module__', None)
451         if modname and modname != self.modname:
452             return False
453         return True
454 
455     def format_args(self, **kwargs: Any) -> str:
456         """Format the argument signature of *self.object*.
457 
458         Should return None if the object does not have a signature.
459         """
460         return None
461 
462     def format_name(self) -> str:
463         """Format the name of *self.object*.
464 
465         This normally should be something that can be parsed by the generated
466         directive, but doesn't need to be (Sphinx will display it unparsed
467         then).
468         """
469         # normally the name doesn't contain the module (except for module
470         # directives of course)
471         return '.'.join(self.objpath) or self.modname
472 
473     def _call_format_args(self, **kwargs: Any) -> str:
474         if kwargs:
475             try:
476                 return self.format_args(**kwargs)
477             except TypeError:
478                 # avoid chaining exceptions, by putting nothing here
479                 pass
480 
481         # retry without arguments for old documenters
482         return self.format_args()
483 
484     def format_signature(self, **kwargs: Any) -> str:
485         """Format the signature (arguments and return annotation) of the object.
486 
487         Let the user process it via the ``autodoc-process-signature`` event.
488         """
489         if self.args is not None:
490             # signature given explicitly
491             args = "(%s)" % self.args
492             retann = self.retann
493         else:
494             # try to introspect the signature
495             try:
496                 retann = None
497                 args = self._call_format_args(**kwargs)
498                 if args:
499                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
500                     if matched:
501                         args = matched.group(1)
502                         retann = matched.group(2)
503             except Exception as exc:
504                 logger.warning(__('error while formatting arguments for %s: %s'),
505                                self.fullname, exc, type='autodoc')
506                 args = None
507 
508         result = self.env.events.emit_firstresult('autodoc-process-signature',
509                                                   self.objtype, self.fullname,
510                                                   self.object, self.options, args, retann)
511         if result:
512             args, retann = result
513 
514         if args is not None:
515             return args + ((' -> %s' % retann) if retann else '')
516         else:
517             return ''
518 
519     def add_directive_header(self, sig: str) -> None:
520         """Add the directive header and options to the generated content."""
521         domain = getattr(self, 'domain', 'py')
522         directive = getattr(self, 'directivetype', self.objtype)
523         name = self.format_name()
524         sourcename = self.get_sourcename()
525 
526         # one signature per line, indented by column
527         prefix = '.. %s:%s:: ' % (domain, directive)
528         for i, sig_line in enumerate(sig.split("\n")):
529             self.add_line('%s%s%s' % (prefix, name, sig_line),
530                           sourcename)
531             if i == 0:
532                 prefix = " " * len(prefix)
533 
534         if self.options.noindex:
535             self.add_line('   :noindex:', sourcename)
536         if self.objpath:
537             # Be explicit about the module, this is necessary since .. class::
538             # etc. don't support a prepended module name
539             self.add_line('   :module: %s' % self.modname, sourcename)
540 
541     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
542         """Decode and return lines of the docstring(s) for the object.
543 
544         When it returns None value, autodoc-process-docstring will not be called for this
545         object.
546         """
547         if encoding is not None:
548             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
549                           % self.__class__.__name__,
550                           RemovedInSphinx40Warning, stacklevel=2)
551         if ignore is not None:
552             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
553                           % self.__class__.__name__,
554                           RemovedInSphinx50Warning, stacklevel=2)
555         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
556                            self.parent, self.object_name)
557         if docstring:
558             tab_width = self.directive.state.document.settings.tab_width
559             return [prepare_docstring(docstring, ignore, tab_width)]
560         return []
561 
562     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
563         """Let the user process the docstrings before adding them."""
564         for docstringlines in docstrings:
565             if self.env.app:
566                 # let extensions preprocess docstrings
567                 self.env.app.emit('autodoc-process-docstring',
568                                   self.objtype, self.fullname, self.object,
569                                   self.options, docstringlines)
570 
571                 if docstringlines and docstringlines[-1] != '':
572                     # append a blank line to the end of the docstring
573                     docstringlines.append('')
574 
575             yield from docstringlines
576 
577     def get_sourcename(self) -> str:
578         if (getattr(self.object, '__module__', None) and
579                 getattr(self.object, '__qualname__', None)):
580             # Get the correct location of docstring from self.object
581             # to support inherited methods
582             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
583         else:
584             fullname = self.fullname
585 
586         if self.analyzer:
587             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
588         else:
589             return 'docstring of %s' % fullname
590 
591     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
592                     ) -> None:
593         """Add content from docstrings, attribute documentation and user."""
594         if no_docstring:
595             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
596                           % self.__class__.__name__,
597                           RemovedInSphinx50Warning, stacklevel=2)
598 
599         # set sourcename and add content from attribute documentation
600         sourcename = self.get_sourcename()
601         if self.analyzer:
602             attr_docs = self.analyzer.find_attr_docs()
603             if self.objpath:
604                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
605                 if key in attr_docs:
606                     no_docstring = True
607                     # make a copy of docstring for attributes to avoid cache
608                     # the change of autodoc-process-docstring event.
609                     docstrings = [list(attr_docs[key])]
610 
611                     for i, line in enumerate(self.process_doc(docstrings)):
612                         self.add_line(line, sourcename, i)
613 
614         # add content from docstrings
615         if not no_docstring:
616             docstrings = self.get_doc()
617             if docstrings is None:
618                 # Do not call autodoc-process-docstring on get_doc() returns None.
619                 pass
620             else:
621                 if not docstrings:
622                     # append at least a dummy docstring, so that the event
623                     # autodoc-process-docstring is fired and can add some
624                     # content if desired
625                     docstrings.append([])
626                 for i, line in enumerate(self.process_doc(docstrings)):
627                     self.add_line(line, sourcename, i)
628 
629         # add additional content (e.g. from document), if present
630         if more_content:
631             for line, src in zip(more_content.data, more_content.items):
632                 self.add_line(line, src[0], src[1])
633 
634     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
635         """Return `(members_check_module, members)` where `members` is a
636         list of `(membername, member)` pairs of the members of *self.object*.
637 
638         If *want_all* is True, return all members.  Else, only return those
639         members given by *self.options.members* (which may also be none).
640         """
641         warnings.warn('The implementation of Documenter.get_object_members() will be '
642                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
643         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
644         if not want_all:
645             if not self.options.members:
646                 return False, []  # type: ignore
647             # specific members given
648             selected = []
649             for name in self.options.members:  # type: str
650                 if name in members:
651                     selected.append((name, members[name].value))
652                 else:
653                     logger.warning(__('missing attribute %s in object %s') %
654                                    (name, self.fullname), type='autodoc')
655             return False, selected
656         elif self.options.inherited_members:
657             return False, [(m.name, m.value) for m in members.values()]
658         else:
659             return False, [(m.name, m.value) for m in members.values()
660                            if m.directly_defined]
661 
662     def filter_members(self, members: ObjectMembers, want_all: bool
663                        ) -> List[Tuple[str, Any, bool]]:
664         """Filter the given member list.
665 
666         Members are skipped if
667 
668         - they are private (except if given explicitly or the private-members
669           option is set)
670         - they are special methods (except if given explicitly or the
671           special-members option is set)
672         - they are undocumented (except if the undoc-members option is set)
673 
674         The user can override the skipping decision by connecting to the
675         ``autodoc-skip-member`` event.
676         """
677         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
678             if inspect.isclass(self.object):
679                 for cls in self.object.__mro__:
680                     if cls.__name__ == self.options.inherited_members and cls != self.object:
681                         # given member is a member of specified *super class*
682                         return True
683                     elif name in cls.__dict__:
684                         return False
685                     elif name in self.get_attr(cls, '__annotations__', {}):
686                         return False
687                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
688                         return False
689 
690             return False
691 
692         ret = []
693 
694         # search for members in source code too
695         namespace = '.'.join(self.objpath)  # will be empty for modules
696 
697         if self.analyzer:
698             attr_docs = self.analyzer.find_attr_docs()
699         else:
700             attr_docs = {}
701 
702         # process members and determine which to skip
703         for obj in members:
704             membername, member = obj
705             # if isattr is True, the member is documented as an attribute
706             if member is INSTANCEATTR:
707                 isattr = True
708             else:
709                 isattr = False
710 
711             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
712                          self.parent, self.object_name)
713             if not isinstance(doc, str):
714                 # Ignore non-string __doc__
715                 doc = None
716 
717             # if the member __doc__ is the same as self's __doc__, it's just
718             # inherited and therefore not the member's doc
719             cls = self.get_attr(member, '__class__', None)
720             if cls:
721                 cls_doc = self.get_attr(cls, '__doc__', None)
722                 if cls_doc == doc:
723                     doc = None
724 
725             if isinstance(obj, ObjectMember) and obj.docstring:
726                 # hack for ClassDocumenter to inject docstring via ObjectMember
727                 doc = obj.docstring
728 
729             has_doc = bool(doc)
730 
731             metadata = extract_metadata(doc)
732             if 'private' in metadata:
733                 # consider a member private if docstring has "private" metadata
734                 isprivate = True
735             elif 'public' in metadata:
736                 # consider a member public if docstring has "public" metadata
737                 isprivate = False
738             else:
739                 isprivate = membername.startswith('_')
740 
741             keep = False
742             if ismock(member):
743                 # mocked module or object
744                 pass
745             elif self.options.exclude_members and membername in self.options.exclude_members:
746                 # remove members given by exclude-members
747                 keep = False
748             elif want_all and special_member_re.match(membername):
749                 # special __methods__
750                 if self.options.special_members and membername in self.options.special_members:
751                     if membername == '__doc__':
752                         keep = False
753                     elif is_filtered_inherited_member(membername, obj):
754                         keep = False
755                     else:
756                         keep = has_doc or self.options.undoc_members
757                 else:
758                     keep = False
759             elif (namespace, membername) in attr_docs:
760                 if want_all and isprivate:
761                     if self.options.private_members is None:
762                         keep = False
763                     else:
764                         keep = membername in self.options.private_members
765                 else:
766                     # keep documented attributes
767                     keep = True
768                 isattr = True
769             elif want_all and isprivate:
770                 if has_doc or self.options.undoc_members:
771                     if self.options.private_members is None:
772                         keep = False
773                     elif is_filtered_inherited_member(membername, obj):
774                         keep = False
775                     else:
776                         keep = membername in self.options.private_members
777                 else:
778                     keep = False
779             else:
780                 if (self.options.members is ALL and
781                         is_filtered_inherited_member(membername, obj)):
782                     keep = False
783                 else:
784                     # ignore undocumented members if :undoc-members: is not given
785                     keep = has_doc or self.options.undoc_members
786 
787             if isinstance(obj, ObjectMember) and obj.skipped:
788                 # forcedly skipped member (ex. a module attribute not defined in __all__)
789                 keep = False
790 
791             # give the user a chance to decide whether this member
792             # should be skipped
793             if self.env.app:
794                 # let extensions preprocess docstrings
795                 try:
796                     skip_user = self.env.app.emit_firstresult(
797                         'autodoc-skip-member', self.objtype, membername, member,
798                         not keep, self.options)
799                     if skip_user is not None:
800                         keep = not skip_user
801                 except Exception as exc:
802                     logger.warning(__('autodoc: failed to determine %r to be documented, '
803                                       'the following exception was raised:\n%s'),
804                                    member, exc, type='autodoc')
805                     keep = False
806 
807             if keep:
808                 ret.append((membername, member, isattr))
809 
810         return ret
811 
812     def document_members(self, all_members: bool = False) -> None:
813         """Generate reST for member documentation.
814 
815         If *all_members* is True, do all members, else those given by
816         *self.options.members*.
817         """
818         # set current namespace for finding members
819         self.env.temp_data['autodoc:module'] = self.modname
820         if self.objpath:
821             self.env.temp_data['autodoc:class'] = self.objpath[0]
822 
823         want_all = all_members or self.options.inherited_members or \
824             self.options.members is ALL
825         # find out which members are documentable
826         members_check_module, members = self.get_object_members(want_all)
827 
828         # document non-skipped members
829         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
830         for (mname, member, isattr) in self.filter_members(members, want_all):
831             classes = [cls for cls in self.documenters.values()
832                        if cls.can_document_member(member, mname, isattr, self)]
833             if not classes:
834                 # don't know how to document this member
835                 continue
836             # prefer the documenter with the highest priority
837             classes.sort(key=lambda cls: cls.priority)
838             # give explicitly separated module name, so that members
839             # of inner classes can be documented
840             full_mname = self.modname + '::' + \
841                 '.'.join(self.objpath + [mname])
842             documenter = classes[-1](self.directive, full_mname, self.indent)
843             memberdocumenters.append((documenter, isattr))
844 
845         member_order = self.options.member_order or self.config.autodoc_member_order
846         memberdocumenters = self.sort_members(memberdocumenters, member_order)
847 
848         for documenter, isattr in memberdocumenters:
849             documenter.generate(
850                 all_members=True, real_modname=self.real_modname,
851                 check_module=members_check_module and not isattr)
852 
853         # reset current objects
854         self.env.temp_data['autodoc:module'] = None
855         self.env.temp_data['autodoc:class'] = None
856 
857     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
858                      order: str) -> List[Tuple["Documenter", bool]]:
859         """Sort the given member list."""
860         if order == 'groupwise':
861             # sort by group; alphabetically within groups
862             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
863         elif order == 'bysource':
864             if self.analyzer:
865                 # sort by source order, by virtue of the module analyzer
866                 tagorder = self.analyzer.tagorder
867 
868                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
869                     fullname = entry[0].name.split('::')[1]
870                     return tagorder.get(fullname, len(tagorder))
871                 documenters.sort(key=keyfunc)
872             else:
873                 # Assume that member discovery order matches source order.
874                 # This is a reasonable assumption in Python 3.6 and up, where
875                 # module.__dict__ is insertion-ordered.
876                 pass
877         else:  # alphabetical
878             documenters.sort(key=lambda e: e[0].name)
879 
880         return documenters
881 
882     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
883                  check_module: bool = False, all_members: bool = False) -> None:
884         """Generate reST for the object given by *self.name*, and possibly for
885         its members.
886 
887         If *more_content* is given, include that content. If *real_modname* is
888         given, use that module name to find attribute docs. If *check_module* is
889         True, only generate if the object is defined in the module name it is
890         imported from. If *all_members* is True, document all members.
891         """
892         if not self.parse_name():
893             # need a module to import
894             logger.warning(
895                 __('don\'t know which module to import for autodocumenting '
896                    '%r (try placing a "module" or "currentmodule" directive '
897                    'in the document, or giving an explicit module name)') %
898                 self.name, type='autodoc')
899             return
900 
901         # now, import the module and get object to document
902         if not self.import_object():
903             return
904 
905         # If there is no real module defined, figure out which to use.
906         # The real module is used in the module analyzer to look up the module
907         # where the attribute documentation would actually be found in.
908         # This is used for situations where you have a module that collects the
909         # functions and classes of internal submodules.
910         guess_modname = self.get_real_modname()
911         self.real_modname = real_modname or guess_modname
912 
913         # try to also get a source code analyzer for attribute docs
914         try:
915             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
916             # parse right now, to get PycodeErrors on parsing (results will
917             # be cached anyway)
918             self.analyzer.find_attr_docs()
919         except PycodeError as exc:
920             logger.debug('[autodoc] module analyzer failed: %s', exc)
921             # no source file -- e.g. for builtin and C modules
922             self.analyzer = None
923             # at least add the module.__file__ as a dependency
924             if hasattr(self.module, '__file__') and self.module.__file__:
925                 self.directive.filename_set.add(self.module.__file__)
926         else:
927             self.directive.filename_set.add(self.analyzer.srcname)
928 
929         if self.real_modname != guess_modname:
930             # Add module to dependency list if target object is defined in other module.
931             try:
932                 analyzer = ModuleAnalyzer.for_module(guess_modname)
933                 self.directive.filename_set.add(analyzer.srcname)
934             except PycodeError:
935                 pass
936 
937         # check __module__ of object (for members not given explicitly)
938         if check_module:
939             if not self.check_module():
940                 return
941 
942         sourcename = self.get_sourcename()
943 
944         # make sure that the result starts with an empty line.  This is
945         # necessary for some situations where another directive preprocesses
946         # reST and no starting newline is present
947         self.add_line('', sourcename)
948 
949         # format the object's signature, if any
950         try:
951             sig = self.format_signature()
952         except Exception as exc:
953             logger.warning(__('error while formatting signature for %s: %s'),
954                            self.fullname, exc, type='autodoc')
955             return
956 
957         # generate the directive header and options, if applicable
958         self.add_directive_header(sig)
959         self.add_line('', sourcename)
960 
961         # e.g. the module directive doesn't have content
962         self.indent += self.content_indent
963 
964         # add all content (from docstrings, attribute docs etc.)
965         self.add_content(more_content)
966 
967         # document members, if possible
968         self.document_members(all_members)
969 
970 
971 class ModuleDocumenter(Documenter):
972     """
973     Specialized Documenter subclass for modules.
974     """
975     objtype = 'module'
976     content_indent = ''
977     titles_allowed = True
978 
979     option_spec = {
980         'members': members_option, 'undoc-members': bool_option,
981         'noindex': bool_option, 'inherited-members': inherited_members_option,
982         'show-inheritance': bool_option, 'synopsis': identity,
983         'platform': identity, 'deprecated': bool_option,
984         'member-order': member_order_option, 'exclude-members': exclude_members_option,
985         'private-members': members_option, 'special-members': members_option,
986         'imported-members': bool_option, 'ignore-module-all': bool_option
987     }  # type: Dict[str, Callable]
988 
989     def __init__(self, *args: Any) -> None:
990         super().__init__(*args)
991         merge_members_option(self.options)
992         self.__all__ = None  # type: Optional[Sequence[str]]
993 
994     @classmethod
995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
996                             ) -> bool:
997         # don't document submodules automatically
998         return False
999 
1000     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1001                      ) -> Tuple[str, List[str]]:
1002         if modname is not None:
1003             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1004                            type='autodoc')
1005         return (path or '') + base, []
1006 
1007     def parse_name(self) -> bool:
1008         ret = super().parse_name()
1009         if self.args or self.retann:
1010             logger.warning(__('signature arguments or return annotation '
1011                               'given for automodule %s') % self.fullname,
1012                            type='autodoc')
1013         return ret
1014 
1015     def import_object(self, raiseerror: bool = False) -> bool:
1016         ret = super().import_object(raiseerror)
1017 
1018         try:
1019             if not self.options.ignore_module_all:
1020                 self.__all__ = inspect.getall(self.object)
1021         except AttributeError as exc:
1022             # __all__ raises an error.
1023             logger.warning(__('%s.__all__ raises an error. Ignored: %r'),
1024                            (self.fullname, exc), type='autodoc')
1025         except ValueError as exc:
1026             # invalid __all__ found.
1027             logger.warning(__('__all__ should be a list of strings, not %r '
1028                               '(in module %s) -- ignoring __all__') %
1029                            (exc.args[0], self.fullname), type='autodoc')
1030 
1031         return ret
1032 
1033     def add_directive_header(self, sig: str) -> None:
1034         Documenter.add_directive_header(self, sig)
1035 
1036         sourcename = self.get_sourcename()
1037 
1038         # add some module-specific options
1039         if self.options.synopsis:
1040             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1041         if self.options.platform:
1042             self.add_line('   :platform: ' + self.options.platform, sourcename)
1043         if self.options.deprecated:
1044             self.add_line('   :deprecated:', sourcename)
1045 
1046     def get_module_members(self) -> Dict[str, ObjectMember]:
1047         """Get members of target module."""
1048         if self.analyzer:
1049             attr_docs = self.analyzer.attr_docs
1050         else:
1051             attr_docs = {}
1052 
1053         members = {}  # type: Dict[str, ObjectMember]
1054         for name in dir(self.object):
1055             try:
1056                 value = safe_getattr(self.object, name, None)
1057                 docstring = attr_docs.get(('', name), [])
1058                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1059             except AttributeError:
1060                 continue
1061 
1062         # annotation only member (ex. attr: int)
1063         try:
1064             for name in inspect.getannotations(self.object):
1065                 if name not in members:
1066                     docstring = attr_docs.get(('', name), [])
1067                     members[name] = ObjectMember(name, INSTANCEATTR,
1068                                                  docstring="\n".join(docstring))
1069         except AttributeError:
1070             pass
1071 
1072         return members
1073 
1074     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1075         members = self.get_module_members()
1076         if want_all:
1077             if self.__all__ is None:
1078                 # for implicit module members, check __module__ to avoid
1079                 # documenting imported objects
1080                 return True, list(members.values())
1081             else:
1082                 for member in members.values():
1083                     if member.__name__ not in self.__all__:
1084                         member.skipped = True
1085 
1086                 return False, list(members.values())
1087         else:
1088             memberlist = self.options.members or []
1089             ret = []
1090             for name in memberlist:
1091                 if name in members:
1092                     ret.append(members[name])
1093                 else:
1094                     logger.warning(__('missing attribute mentioned in :members: option: '
1095                                       'module %s, attribute %s') %
1096                                    (safe_getattr(self.object, '__name__', '???'), name),
1097                                    type='autodoc')
1098             return False, ret
1099 
1100     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1101                      order: str) -> List[Tuple["Documenter", bool]]:
1102         if order == 'bysource' and self.__all__:
1103             # Sort alphabetically first (for members not listed on the __all__)
1104             documenters.sort(key=lambda e: e[0].name)
1105 
1106             # Sort by __all__
1107             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1108                 name = entry[0].name.split('::')[1]
1109                 if name in self.__all__:
1110                     return self.__all__.index(name)
1111                 else:
1112                     return len(self.__all__)
1113             documenters.sort(key=keyfunc)
1114 
1115             return documenters
1116         else:
1117             return super().sort_members(documenters, order)
1118 
1119 
1120 class ModuleLevelDocumenter(Documenter):
1121     """
1122     Specialized Documenter subclass for objects on module level (functions,
1123     classes, data/constants).
1124     """
1125     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1126                      ) -> Tuple[str, List[str]]:
1127         if modname is None:
1128             if path:
1129                 modname = path.rstrip('.')
1130             else:
1131                 # if documenting a toplevel object without explicit module,
1132                 # it can be contained in another auto directive ...
1133                 modname = self.env.temp_data.get('autodoc:module')
1134                 # ... or in the scope of a module directive
1135                 if not modname:
1136                     modname = self.env.ref_context.get('py:module')
1137                 # ... else, it stays None, which means invalid
1138         return modname, parents + [base]
1139 
1140 
1141 class ClassLevelDocumenter(Documenter):
1142     """
1143     Specialized Documenter subclass for objects on class level (methods,
1144     attributes).
1145     """
1146     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1147                      ) -> Tuple[str, List[str]]:
1148         if modname is None:
1149             if path:
1150                 mod_cls = path.rstrip('.')
1151             else:
1152                 mod_cls = None
1153                 # if documenting a class-level object without path,
1154                 # there must be a current class, either from a parent
1155                 # auto directive ...
1156                 mod_cls = self.env.temp_data.get('autodoc:class')
1157                 # ... or from a class directive
1158                 if mod_cls is None:
1159                     mod_cls = self.env.ref_context.get('py:class')
1160                 # ... if still None, there's no way to know
1161                 if mod_cls is None:
1162                     return None, []
1163             modname, sep, cls = mod_cls.rpartition('.')
1164             parents = [cls]
1165             # if the module name is still missing, get it like above
1166             if not modname:
1167                 modname = self.env.temp_data.get('autodoc:module')
1168             if not modname:
1169                 modname = self.env.ref_context.get('py:module')
1170             # ... else, it stays None, which means invalid
1171         return modname, parents + [base]
1172 
1173 
1174 class DocstringSignatureMixin:
1175     """
1176     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1177     feature of reading the signature from the docstring.
1178     """
1179     _new_docstrings = None  # type: List[List[str]]
1180     _signatures = None      # type: List[str]
1181 
1182     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1183         if encoding is not None:
1184             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1185                           "deprecated." % self.__class__.__name__,
1186                           RemovedInSphinx40Warning, stacklevel=2)
1187 
1188         # candidates of the object name
1189         valid_names = [self.objpath[-1]]  # type: ignore
1190         if isinstance(self, ClassDocumenter):
1191             valid_names.append('__init__')
1192             if hasattr(self.object, '__mro__'):
1193                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1194 
1195         docstrings = self.get_doc()
1196         if docstrings is None:
1197             return None, None
1198         self._new_docstrings = docstrings[:]
1199         self._signatures = []
1200         result = None
1201         for i, doclines in enumerate(docstrings):
1202             for j, line in enumerate(doclines):
1203                 if not line:
1204                     # no lines in docstring, no match
1205                     break
1206 
1207                 if line.endswith('\\'):
1208                     multiline = True
1209                     line = line.rstrip('\\').rstrip()
1210                 else:
1211                     multiline = False
1212 
1213                 # match first line of docstring against signature RE
1214                 match = py_ext_sig_re.match(line)
1215                 if not match:
1216                     continue
1217                 exmod, path, base, args, retann = match.groups()
1218 
1219                 # the base name must match ours
1220                 if base not in valid_names:
1221                     continue
1222 
1223                 # re-prepare docstring to ignore more leading indentation
1224                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1225                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1226                                                             tabsize=tab_width)
1227 
1228                 if result is None:
1229                     # first signature
1230                     result = args, retann
1231                 else:
1232                     # subsequent signatures
1233                     self._signatures.append("(%s) -> %s" % (args, retann))
1234 
1235                 if multiline:
1236                     # the signature have multiple signatures on docstring
1237                     continue
1238                 else:
1239                     # don't look any further
1240                     break
1241 
1242             if result:
1243                 # finish the loop when signature found
1244                 break
1245 
1246         return result
1247 
1248     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1249         if encoding is not None:
1250             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1251                           % self.__class__.__name__,
1252                           RemovedInSphinx40Warning, stacklevel=2)
1253         if self._new_docstrings is not None:
1254             return self._new_docstrings
1255         return super().get_doc(None, ignore)  # type: ignore
1256 
1257     def format_signature(self, **kwargs: Any) -> str:
1258         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1259             # only act if a signature is not explicitly given already, and if
1260             # the feature is enabled
1261             result = self._find_signature()
1262             if result is not None:
1263                 self.args, self.retann = result
1264         sig = super().format_signature(**kwargs)  # type: ignore
1265         if self._signatures:
1266             return "\n".join([sig] + self._signatures)
1267         else:
1268             return sig
1269 
1270 
1271 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1272     """
1273     Mixin for AttributeDocumenter to provide the
1274     feature of stripping any function signature from the docstring.
1275     """
1276     def format_signature(self, **kwargs: Any) -> str:
1277         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1278             # only act if a signature is not explicitly given already, and if
1279             # the feature is enabled
1280             result = self._find_signature()
1281             if result is not None:
1282                 # Discarding _args is a only difference with
1283                 # DocstringSignatureMixin.format_signature.
1284                 # Documenter.format_signature use self.args value to format.
1285                 _args, self.retann = result
1286         return super().format_signature(**kwargs)
1287 
1288 
1289 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1290     """
1291     Specialized Documenter subclass for functions.
1292     """
1293     objtype = 'function'
1294     member_order = 30
1295 
1296     @classmethod
1297     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1298                             ) -> bool:
1299         # supports functions, builtins and bound methods exported at the module level
1300         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1301                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1302 
1303     def format_args(self, **kwargs: Any) -> str:
1304         if self.config.autodoc_typehints in ('none', 'description'):
1305             kwargs.setdefault('show_annotation', False)
1306 
1307         try:
1308             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1309             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1310             args = stringify_signature(sig, **kwargs)
1311         except TypeError as exc:
1312             logger.warning(__("Failed to get a function signature for %s: %s"),
1313                            self.fullname, exc)
1314             return None
1315         except ValueError:
1316             args = ''
1317 
1318         if self.config.strip_signature_backslash:
1319             # escape backslashes for reST
1320             args = args.replace('\\', '\\\\')
1321         return args
1322 
1323     def document_members(self, all_members: bool = False) -> None:
1324         pass
1325 
1326     def add_directive_header(self, sig: str) -> None:
1327         sourcename = self.get_sourcename()
1328         super().add_directive_header(sig)
1329 
1330         if inspect.iscoroutinefunction(self.object):
1331             self.add_line('   :async:', sourcename)
1332 
1333     def format_signature(self, **kwargs: Any) -> str:
1334         sigs = []
1335         if (self.analyzer and
1336                 '.'.join(self.objpath) in self.analyzer.overloads and
1337                 self.config.autodoc_typehints == 'signature'):
1338             # Use signatures for overloaded functions instead of the implementation function.
1339             overloaded = True
1340         else:
1341             overloaded = False
1342             sig = super().format_signature(**kwargs)
1343             sigs.append(sig)
1344 
1345         if inspect.is_singledispatch_function(self.object):
1346             # append signature of singledispatch'ed functions
1347             for typ, func in self.object.registry.items():
1348                 if typ is object:
1349                     pass  # default implementation. skipped.
1350                 else:
1351                     self.annotate_to_first_argument(func, typ)
1352 
1353                     documenter = FunctionDocumenter(self.directive, '')
1354                     documenter.object = func
1355                     documenter.objpath = [None]
1356                     sigs.append(documenter.format_signature())
1357         if overloaded:
1358             __globals__ = safe_getattr(self.object, '__globals__', {})
1359             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1360                 overload = evaluate_signature(overload, __globals__,
1361                                               self.config.autodoc_type_aliases)
1362 
1363                 sig = stringify_signature(overload, **kwargs)
1364                 sigs.append(sig)
1365 
1366         return "\n".join(sigs)
1367 
1368     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1369         """Annotate type hint to the first argument of function if needed."""
1370         try:
1371             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1372         except TypeError as exc:
1373             logger.warning(__("Failed to get a function signature for %s: %s"),
1374                            self.fullname, exc)
1375             return
1376         except ValueError:
1377             return
1378 
1379         if len(sig.parameters) == 0:
1380             return
1381 
1382         params = list(sig.parameters.values())
1383         if params[0].annotation is Parameter.empty:
1384             params[0] = params[0].replace(annotation=typ)
1385             try:
1386                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1387             except TypeError:
1388                 # failed to update signature (ex. built-in or extension types)
1389                 return
1390 
1391 
1392 class DecoratorDocumenter(FunctionDocumenter):
1393     """
1394     Specialized Documenter subclass for decorator functions.
1395     """
1396     objtype = 'decorator'
1397 
1398     # must be lower than FunctionDocumenter
1399     priority = -1
1400 
1401     def format_args(self, **kwargs: Any) -> Any:
1402         args = super().format_args(**kwargs)
1403         if ',' in args:
1404             return args
1405         else:
1406             return None
1407 
1408 
1409 # Types which have confusing metaclass signatures it would be best not to show.
1410 # These are listed by name, rather than storing the objects themselves, to avoid
1411 # needing to import the modules.
1412 _METACLASS_CALL_BLACKLIST = [
1413     'enum.EnumMeta.__call__',
1414 ]
1415 
1416 
1417 # Types whose __new__ signature is a pass-thru.
1418 _CLASS_NEW_BLACKLIST = [
1419     'typing.Generic.__new__',
1420 ]
1421 
1422 
1423 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1424     """
1425     Specialized Documenter subclass for classes.
1426     """
1427     objtype = 'class'
1428     member_order = 20
1429     option_spec = {
1430         'members': members_option, 'undoc-members': bool_option,
1431         'noindex': bool_option, 'inherited-members': inherited_members_option,
1432         'show-inheritance': bool_option, 'member-order': member_order_option,
1433         'exclude-members': exclude_members_option,
1434         'private-members': members_option, 'special-members': members_option,
1435     }  # type: Dict[str, Callable]
1436 
1437     _signature_class = None  # type: Any
1438     _signature_method_name = None  # type: str
1439 
1440     def __init__(self, *args: Any) -> None:
1441         super().__init__(*args)
1442         merge_members_option(self.options)
1443 
1444     @classmethod
1445     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1446                             ) -> bool:
1447         return isinstance(member, type)
1448 
1449     def import_object(self, raiseerror: bool = False) -> bool:
1450         ret = super().import_object(raiseerror)
1451         # if the class is documented under another name, document it
1452         # as data/attribute
1453         if ret:
1454             if hasattr(self.object, '__name__'):
1455                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1456             else:
1457                 self.doc_as_attr = True
1458         return ret
1459 
1460     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1461         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1462             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1463             if inspect.is_builtin_class_method(obj, attr):
1464                 return None
1465             attr = self.get_attr(obj, attr, None)
1466             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1467                 return None
1468             return attr
1469 
1470         # This sequence is copied from inspect._signature_from_callable.
1471         # ValueError means that no signature could be found, so we keep going.
1472 
1473         # First, we check the obj has a __signature__ attribute
1474         if (hasattr(self.object, '__signature__') and
1475                 isinstance(self.object.__signature__, Signature)):
1476             return None, None, self.object.__signature__
1477 
1478         # Next, let's see if it has an overloaded __call__ defined
1479         # in its metaclass
1480         call = get_user_defined_function_or_method(type(self.object), '__call__')
1481 
1482         if call is not None:
1483             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1484                 call = None
1485 
1486         if call is not None:
1487             self.env.app.emit('autodoc-before-process-signature', call, True)
1488             try:
1489                 sig = inspect.signature(call, bound_method=True,
1490                                         type_aliases=self.config.autodoc_type_aliases)
1491                 return type(self.object), '__call__', sig
1492             except ValueError:
1493                 pass
1494 
1495         # Now we check if the 'obj' class has a '__new__' method
1496         new = get_user_defined_function_or_method(self.object, '__new__')
1497 
1498         if new is not None:
1499             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1500                 new = None
1501 
1502         if new is not None:
1503             self.env.app.emit('autodoc-before-process-signature', new, True)
1504             try:
1505                 sig = inspect.signature(new, bound_method=True,
1506                                         type_aliases=self.config.autodoc_type_aliases)
1507                 return self.object, '__new__', sig
1508             except ValueError:
1509                 pass
1510 
1511         # Finally, we should have at least __init__ implemented
1512         init = get_user_defined_function_or_method(self.object, '__init__')
1513         if init is not None:
1514             self.env.app.emit('autodoc-before-process-signature', init, True)
1515             try:
1516                 sig = inspect.signature(init, bound_method=True,
1517                                         type_aliases=self.config.autodoc_type_aliases)
1518                 return self.object, '__init__', sig
1519             except ValueError:
1520                 pass
1521 
1522         # None of the attributes are user-defined, so fall back to let inspect
1523         # handle it.
1524         # We don't know the exact method that inspect.signature will read
1525         # the signature from, so just pass the object itself to our hook.
1526         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1527         try:
1528             sig = inspect.signature(self.object, bound_method=False,
1529                                     type_aliases=self.config.autodoc_type_aliases)
1530             return None, None, sig
1531         except ValueError:
1532             pass
1533 
1534         # Still no signature: happens e.g. for old-style classes
1535         # with __init__ in C and no `__text_signature__`.
1536         return None, None, None
1537 
1538     def format_args(self, **kwargs: Any) -> str:
1539         if self.config.autodoc_typehints in ('none', 'description'):
1540             kwargs.setdefault('show_annotation', False)
1541 
1542         try:
1543             self._signature_class, self._signature_method_name, sig = self._get_signature()
1544         except TypeError as exc:
1545             # __signature__ attribute contained junk
1546             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1547                            self.fullname, exc)
1548             return None
1549 
1550         if sig is None:
1551             return None
1552 
1553         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1554 
1555     def format_signature(self, **kwargs: Any) -> str:
1556         if self.doc_as_attr:
1557             return ''
1558 
1559         sig = super().format_signature()
1560         sigs = []
1561 
1562         overloads = self.get_overloaded_signatures()
1563         if overloads and self.config.autodoc_typehints == 'signature':
1564             # Use signatures for overloaded methods instead of the implementation method.
1565             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1566             __globals__ = safe_getattr(method, '__globals__', {})
1567             for overload in overloads:
1568                 overload = evaluate_signature(overload, __globals__,
1569                                               self.config.autodoc_type_aliases)
1570 
1571                 parameters = list(overload.parameters.values())
1572                 overload = overload.replace(parameters=parameters[1:],
1573                                             return_annotation=Parameter.empty)
1574                 sig = stringify_signature(overload, **kwargs)
1575                 sigs.append(sig)
1576         else:
1577             sigs.append(sig)
1578 
1579         return "\n".join(sigs)
1580 
1581     def get_overloaded_signatures(self) -> List[Signature]:
1582         if self._signature_class and self._signature_method_name:
1583             for cls in self._signature_class.__mro__:
1584                 try:
1585                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1586                     analyzer.analyze()
1587                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1588                     if qualname in analyzer.overloads:
1589                         return analyzer.overloads.get(qualname)
1590                     elif qualname in analyzer.tagorder:
1591                         # the constructor is defined in the class, but not overrided.
1592                         return []
1593                 except PycodeError:
1594                     pass
1595 
1596         return []
1597 
1598     def add_directive_header(self, sig: str) -> None:
1599         sourcename = self.get_sourcename()
1600 
1601         if self.doc_as_attr:
1602             self.directivetype = 'attribute'
1603         super().add_directive_header(sig)
1604 
1605         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1606             self.add_line('   :final:', sourcename)
1607 
1608         # add inheritance info, if wanted
1609         if not self.doc_as_attr and self.options.show_inheritance:
1610             sourcename = self.get_sourcename()
1611             self.add_line('', sourcename)
1612 
1613             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1614                 # A subclass of generic types
1615                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1616                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1617                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1618             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1619                 # A normal class
1620                 bases = [restify(cls) for cls in self.object.__bases__]
1621                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1622 
1623     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1624         members = get_class_members(self.object, self.objpath, self.get_attr)
1625         if not want_all:
1626             if not self.options.members:
1627                 return False, []  # type: ignore
1628             # specific members given
1629             selected = []
1630             for name in self.options.members:  # type: str
1631                 if name in members:
1632                     selected.append(members[name])
1633                 else:
1634                     logger.warning(__('missing attribute %s in object %s') %
1635                                    (name, self.fullname), type='autodoc')
1636             return False, selected
1637         elif self.options.inherited_members:
1638             return False, list(members.values())
1639         else:
1640             return False, [m for m in members.values() if m.class_ == self.object]
1641 
1642     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1643         if encoding is not None:
1644             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1645                           % self.__class__.__name__,
1646                           RemovedInSphinx40Warning, stacklevel=2)
1647         if self.doc_as_attr:
1648             # Don't show the docstring of the class when it is an alias.
1649             return None
1650 
1651         lines = getattr(self, '_new_docstrings', None)
1652         if lines is not None:
1653             return lines
1654 
1655         content = self.config.autoclass_content
1656 
1657         docstrings = []
1658         attrdocstring = self.get_attr(self.object, '__doc__', None)
1659         if attrdocstring:
1660             docstrings.append(attrdocstring)
1661 
1662         # for classes, what the "docstring" is can be controlled via a
1663         # config value; the default is only the class docstring
1664         if content in ('both', 'init'):
1665             __init__ = self.get_attr(self.object, '__init__', None)
1666             initdocstring = getdoc(__init__, self.get_attr,
1667                                    self.config.autodoc_inherit_docstrings,
1668                                    self.parent, self.object_name)
1669             # for new-style classes, no __init__ means default __init__
1670             if (initdocstring is not None and
1671                 (initdocstring == object.__init__.__doc__ or  # for pypy
1672                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1673                 initdocstring = None
1674             if not initdocstring:
1675                 # try __new__
1676                 __new__ = self.get_attr(self.object, '__new__', None)
1677                 initdocstring = getdoc(__new__, self.get_attr,
1678                                        self.config.autodoc_inherit_docstrings,
1679                                        self.parent, self.object_name)
1680                 # for new-style classes, no __new__ means default __new__
1681                 if (initdocstring is not None and
1682                     (initdocstring == object.__new__.__doc__ or  # for pypy
1683                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1684                     initdocstring = None
1685             if initdocstring:
1686                 if content == 'init':
1687                     docstrings = [initdocstring]
1688                 else:
1689                     docstrings.append(initdocstring)
1690 
1691         tab_width = self.directive.state.document.settings.tab_width
1692         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1693 
1694     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1695                     ) -> None:
1696         if self.doc_as_attr:
1697             try:
1698                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1699             except AttributeError:
1700                 pass  # Invalid class object is passed.
1701 
1702         super().add_content(more_content)
1703 
1704     def document_members(self, all_members: bool = False) -> None:
1705         if self.doc_as_attr:
1706             return
1707         super().document_members(all_members)
1708 
1709     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1710                  check_module: bool = False, all_members: bool = False) -> None:
1711         # Do not pass real_modname and use the name from the __module__
1712         # attribute of the class.
1713         # If a class gets imported into the module real_modname
1714         # the analyzer won't find the source of the class, if
1715         # it looks in real_modname.
1716         return super().generate(more_content=more_content,
1717                                 check_module=check_module,
1718                                 all_members=all_members)
1719 
1720 
1721 class ExceptionDocumenter(ClassDocumenter):
1722     """
1723     Specialized ClassDocumenter subclass for exceptions.
1724     """
1725     objtype = 'exception'
1726     member_order = 10
1727 
1728     # needs a higher priority than ClassDocumenter
1729     priority = 10
1730 
1731     @classmethod
1732     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1733                             ) -> bool:
1734         return isinstance(member, type) and issubclass(member, BaseException)
1735 
1736 
1737 class DataDocumenterMixinBase:
1738     # define types of instance variables
1739     config = None  # type: Config
1740     env = None  # type: BuildEnvironment
1741     modname = None  # type: str
1742     parent = None  # type: Any
1743     object = None  # type: Any
1744     objpath = None  # type: List[str]
1745 
1746     def should_suppress_directive_header(self) -> bool:
1747         """Check directive header should be suppressed."""
1748         return False
1749 
1750     def should_suppress_value_header(self) -> bool:
1751         """Check :value: header should be suppressed."""
1752         return False
1753 
1754     def update_content(self, more_content: StringList) -> None:
1755         """Update docstring for the NewType object."""
1756         pass
1757 
1758 
1759 class GenericAliasMixin(DataDocumenterMixinBase):
1760     """
1761     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1762     supporting GenericAliases.
1763     """
1764 
1765     def should_suppress_directive_header(self) -> bool:
1766         return (inspect.isgenericalias(self.object) or
1767                 super().should_suppress_directive_header())
1768 
1769     def update_content(self, more_content: StringList) -> None:
1770         if inspect.isgenericalias(self.object):
1771             alias = stringify_typehint(self.object)
1772             more_content.append(_('alias of %s') % alias, '')
1773             more_content.append('', '')
1774 
1775         super().update_content(more_content)
1776 
1777 
1778 class NewTypeMixin(DataDocumenterMixinBase):
1779     """
1780     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1781     supporting NewTypes.
1782     """
1783 
1784     def should_suppress_directive_header(self) -> bool:
1785         return (inspect.isNewType(self.object) or
1786                 super().should_suppress_directive_header())
1787 
1788     def update_content(self, more_content: StringList) -> None:
1789         if inspect.isNewType(self.object):
1790             supertype = restify(self.object.__supertype__)
1791             more_content.append(_('alias of %s') % supertype, '')
1792             more_content.append('', '')
1793 
1794         super().update_content(more_content)
1795 
1796 
1797 class TypeVarMixin(DataDocumenterMixinBase):
1798     """
1799     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1800     supporting TypeVars.
1801     """
1802 
1803     def should_suppress_directive_header(self) -> bool:
1804         return (isinstance(self.object, TypeVar) or
1805                 super().should_suppress_directive_header())
1806 
1807     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1808         if ignore is not None:
1809             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1810                           % self.__class__.__name__,
1811                           RemovedInSphinx50Warning, stacklevel=2)
1812 
1813         if isinstance(self.object, TypeVar):
1814             if self.object.__doc__ != TypeVar.__doc__:
1815                 return super().get_doc()  # type: ignore
1816             else:
1817                 return []
1818         else:
1819             return super().get_doc()  # type: ignore
1820 
1821     def update_content(self, more_content: StringList) -> None:
1822         if isinstance(self.object, TypeVar):
1823             attrs = [repr(self.object.__name__)]
1824             for constraint in self.object.__constraints__:
1825                 attrs.append(stringify_typehint(constraint))
1826             if self.object.__covariant__:
1827                 attrs.append("covariant=True")
1828             if self.object.__contravariant__:
1829                 attrs.append("contravariant=True")
1830 
1831             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1832             more_content.append('', '')
1833 
1834         super().update_content(more_content)
1835 
1836 
1837 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1838     """
1839     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1840     (type annotation only) global variables.
1841     """
1842 
1843     def import_object(self, raiseerror: bool = False) -> bool:
1844         try:
1845             return super().import_object(raiseerror=True)  # type: ignore
1846         except ImportError as exc:
1847             # annotation only instance variable (PEP-526)
1848             try:
1849                 with mock(self.config.autodoc_mock_imports):
1850                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1851                     annotations = get_type_hints(parent, None,
1852                                                  self.config.autodoc_type_aliases)
1853                     if self.objpath[-1] in annotations:
1854                         self.object = UNINITIALIZED_ATTR
1855                         self.parent = parent
1856                         return True
1857             except ImportError:
1858                 pass
1859 
1860             if raiseerror:
1861                 raise
1862             else:
1863                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1864                 self.env.note_reread()
1865                 return False
1866 
1867     def should_suppress_value_header(self) -> bool:
1868         return (self.object is UNINITIALIZED_ATTR or
1869                 super().should_suppress_value_header())
1870 
1871     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1872         if self.object is UNINITIALIZED_ATTR:
1873             return []
1874         else:
1875             return super().get_doc(encoding, ignore)  # type: ignore
1876 
1877 
1878 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1879                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1880     """
1881     Specialized Documenter subclass for data items.
1882     """
1883     objtype = 'data'
1884     member_order = 40
1885     priority = -10
1886     option_spec = dict(ModuleLevelDocumenter.option_spec)
1887     option_spec["annotation"] = annotation_option
1888     option_spec["no-value"] = bool_option
1889 
1890     @classmethod
1891     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1892                             ) -> bool:
1893         return isinstance(parent, ModuleDocumenter) and isattr
1894 
1895     def update_annotations(self, parent: Any) -> None:
1896         """Update __annotations__ to support type_comment and so on."""
1897         try:
1898             annotations = dict(inspect.getannotations(parent))
1899             parent.__annotations__ = annotations
1900 
1901             analyzer = ModuleAnalyzer.for_module(self.modname)
1902             analyzer.analyze()
1903             for (classname, attrname), annotation in analyzer.annotations.items():
1904                 if classname == '' and attrname not in annotations:
1905                     annotations[attrname] = annotation
1906         except AttributeError:
1907             pass
1908 
1909     def import_object(self, raiseerror: bool = False) -> bool:
1910         ret = super().import_object(raiseerror)
1911         if self.parent:
1912             self.update_annotations(self.parent)
1913 
1914         return ret
1915 
1916     def should_suppress_value_header(self) -> bool:
1917         if super().should_suppress_value_header():
1918             return True
1919         else:
1920             doc = self.get_doc()
1921             metadata = extract_metadata('\n'.join(sum(doc, [])))
1922             if 'hide-value' in metadata:
1923                 return True
1924 
1925         return False
1926 
1927     def add_directive_header(self, sig: str) -> None:
1928         super().add_directive_header(sig)
1929         sourcename = self.get_sourcename()
1930         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1931             pass
1932         elif self.options.annotation:
1933             self.add_line('   :annotation: %s' % self.options.annotation,
1934                           sourcename)
1935         else:
1936             # obtain annotation for this data
1937             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1938             if self.objpath[-1] in annotations:
1939                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1940                 self.add_line('   :type: ' + objrepr, sourcename)
1941 
1942             try:
1943                 if self.options.no_value or self.should_suppress_value_header():
1944                     pass
1945                 else:
1946                     objrepr = object_description(self.object)
1947                     self.add_line('   :value: ' + objrepr, sourcename)
1948             except ValueError:
1949                 pass
1950 
1951     def document_members(self, all_members: bool = False) -> None:
1952         pass
1953 
1954     def get_real_modname(self) -> str:
1955         return self.get_attr(self.parent or self.object, '__module__', None) \
1956             or self.modname
1957 
1958     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1959         try:
1960             analyzer = ModuleAnalyzer.for_module(self.modname)
1961             analyzer.analyze()
1962             key = ('', attrname)
1963             if key in analyzer.attr_docs:
1964                 return list(analyzer.attr_docs[key])
1965         except PycodeError:
1966             pass
1967 
1968         return None
1969 
1970     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1971         # Check the variable has a docstring-comment
1972         comment = self.get_module_comment(self.objpath[-1])
1973         if comment:
1974             return [comment]
1975         else:
1976             return super().get_doc(encoding, ignore)
1977 
1978     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1979                     ) -> None:
1980         # Disable analyzing variable comment on Documenter.add_content() to control it on
1981         # DataDocumenter.add_content()
1982         self.analyzer = None
1983 
1984         if not more_content:
1985             more_content = StringList()
1986 
1987         self.update_content(more_content)
1988         super().add_content(more_content, no_docstring=no_docstring)
1989 
1990 
1991 class NewTypeDataDocumenter(DataDocumenter):
1992     """
1993     Specialized Documenter subclass for NewTypes.
1994 
1995     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
1996     function object.
1997     """
1998 
1999     objtype = 'newtypedata'
2000     directivetype = 'data'
2001     priority = FunctionDocumenter.priority + 1
2002 
2003     @classmethod
2004     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2005                             ) -> bool:
2006         return inspect.isNewType(member) and isattr
2007 
2008 
2009 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2010     """
2011     Specialized Documenter subclass for methods (normal, static and class).
2012     """
2013     objtype = 'method'
2014     directivetype = 'method'
2015     member_order = 50
2016     priority = 1  # must be more than FunctionDocumenter
2017 
2018     @classmethod
2019     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2020                             ) -> bool:
2021         return inspect.isroutine(member) and \
2022             not isinstance(parent, ModuleDocumenter)
2023 
2024     def import_object(self, raiseerror: bool = False) -> bool:
2025         ret = super().import_object(raiseerror)
2026         if not ret:
2027             return ret
2028 
2029         # to distinguish classmethod/staticmethod
2030         obj = self.parent.__dict__.get(self.object_name)
2031         if obj is None:
2032             obj = self.object
2033 
2034         if (inspect.isclassmethod(obj) or
2035                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2036             # document class and static members before ordinary ones
2037             self.member_order = self.member_order - 1
2038 
2039         return ret
2040 
2041     def format_args(self, **kwargs: Any) -> str:
2042         if self.config.autodoc_typehints in ('none', 'description'):
2043             kwargs.setdefault('show_annotation', False)
2044 
2045         try:
2046             if self.object == object.__init__ and self.parent != object:
2047                 # Classes not having own __init__() method are shown as no arguments.
2048                 #
2049                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2050                 #       But it makes users confused.
2051                 args = '()'
2052             else:
2053                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2054                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2055                     sig = inspect.signature(self.object, bound_method=False,
2056                                             type_aliases=self.config.autodoc_type_aliases)
2057                 else:
2058                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2059                     sig = inspect.signature(self.object, bound_method=True,
2060                                             type_aliases=self.config.autodoc_type_aliases)
2061                 args = stringify_signature(sig, **kwargs)
2062         except TypeError as exc:
2063             logger.warning(__("Failed to get a method signature for %s: %s"),
2064                            self.fullname, exc)
2065             return None
2066         except ValueError:
2067             args = ''
2068 
2069         if self.config.strip_signature_backslash:
2070             # escape backslashes for reST
2071             args = args.replace('\\', '\\\\')
2072         return args
2073 
2074     def add_directive_header(self, sig: str) -> None:
2075         super().add_directive_header(sig)
2076 
2077         sourcename = self.get_sourcename()
2078         obj = self.parent.__dict__.get(self.object_name, self.object)
2079         if inspect.isabstractmethod(obj):
2080             self.add_line('   :abstractmethod:', sourcename)
2081         if inspect.iscoroutinefunction(obj):
2082             self.add_line('   :async:', sourcename)
2083         if inspect.isclassmethod(obj):
2084             self.add_line('   :classmethod:', sourcename)
2085         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2086             self.add_line('   :staticmethod:', sourcename)
2087         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2088             self.add_line('   :final:', sourcename)
2089 
2090     def document_members(self, all_members: bool = False) -> None:
2091         pass
2092 
2093     def format_signature(self, **kwargs: Any) -> str:
2094         sigs = []
2095         if (self.analyzer and
2096                 '.'.join(self.objpath) in self.analyzer.overloads and
2097                 self.config.autodoc_typehints == 'signature'):
2098             # Use signatures for overloaded methods instead of the implementation method.
2099             overloaded = True
2100         else:
2101             overloaded = False
2102             sig = super().format_signature(**kwargs)
2103             sigs.append(sig)
2104 
2105         meth = self.parent.__dict__.get(self.objpath[-1])
2106         if inspect.is_singledispatch_method(meth):
2107             # append signature of singledispatch'ed functions
2108             for typ, func in meth.dispatcher.registry.items():
2109                 if typ is object:
2110                     pass  # default implementation. skipped.
2111                 else:
2112                     self.annotate_to_first_argument(func, typ)
2113 
2114                     documenter = MethodDocumenter(self.directive, '')
2115                     documenter.parent = self.parent
2116                     documenter.object = func
2117                     documenter.objpath = [None]
2118                     sigs.append(documenter.format_signature())
2119         if overloaded:
2120             __globals__ = safe_getattr(self.object, '__globals__', {})
2121             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2122                 overload = evaluate_signature(overload, __globals__,
2123                                               self.config.autodoc_type_aliases)
2124 
2125                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2126                                               name=self.object_name):
2127                     parameters = list(overload.parameters.values())
2128                     overload = overload.replace(parameters=parameters[1:])
2129                 sig = stringify_signature(overload, **kwargs)
2130                 sigs.append(sig)
2131 
2132         return "\n".join(sigs)
2133 
2134     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2135         """Annotate type hint to the first argument of function if needed."""
2136         try:
2137             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2138         except TypeError as exc:
2139             logger.warning(__("Failed to get a method signature for %s: %s"),
2140                            self.fullname, exc)
2141             return
2142         except ValueError:
2143             return
2144         if len(sig.parameters) == 1:
2145             return
2146 
2147         params = list(sig.parameters.values())
2148         if params[1].annotation is Parameter.empty:
2149             params[1] = params[1].replace(annotation=typ)
2150             try:
2151                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2152             except TypeError:
2153                 # failed to update signature (ex. built-in or extension types)
2154                 return
2155 
2156 
2157 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2158     """
2159     Mixin for AttributeDocumenter to provide the feature for supporting non
2160     data-descriptors.
2161 
2162     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2163               and :value: header will be suppressed unexpectedly.
2164     """
2165 
2166     def import_object(self, raiseerror: bool = False) -> bool:
2167         ret = super().import_object(raiseerror)  # type: ignore
2168         if ret and not inspect.isattributedescriptor(self.object):
2169             self.non_data_descriptor = True
2170         else:
2171             self.non_data_descriptor = False
2172 
2173         return ret
2174 
2175     def should_suppress_value_header(self) -> bool:
2176         return (not getattr(self, 'non_data_descriptor', False) or
2177                 super().should_suppress_directive_header())
2178 
2179     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2180         if getattr(self, 'non_data_descriptor', False):
2181             # the docstring of non datadescriptor is very probably the wrong thing
2182             # to display
2183             return None
2184         else:
2185             return super().get_doc(encoding, ignore)  # type: ignore
2186 
2187 
2188 class SlotsMixin(DataDocumenterMixinBase):
2189     """
2190     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2191     """
2192 
2193     def isslotsattribute(self) -> bool:
2194         """Check the subject is an attribute in __slots__."""
2195         try:
2196             __slots__ = inspect.getslots(self.parent)
2197             if __slots__ and self.objpath[-1] in __slots__:
2198                 return True
2199             else:
2200                 return False
2201         except (AttributeError, ValueError, TypeError):
2202             return False
2203 
2204     def import_object(self, raiseerror: bool = False) -> bool:
2205         ret = super().import_object(raiseerror)  # type: ignore
2206         if self.isslotsattribute():
2207             self.object = SLOTSATTR
2208 
2209         return ret
2210 
2211     def should_suppress_directive_header(self) -> bool:
2212         if self.object is SLOTSATTR:
2213             self._datadescriptor = True
2214             return True
2215         else:
2216             return super().should_suppress_directive_header()
2217 
2218     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2219         if self.object is SLOTSATTR:
2220             try:
2221                 __slots__ = inspect.getslots(self.parent)
2222                 if __slots__ and __slots__.get(self.objpath[-1]):
2223                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2224                     return [docstring]
2225                 else:
2226                     return []
2227             except (AttributeError, ValueError) as exc:
2228                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2229                                (self.parent.__qualname__, exc), type='autodoc')
2230                 return []
2231         else:
2232             return super().get_doc(encoding, ignore)  # type: ignore
2233 
2234 
2235 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2236     """
2237     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2238     instance attributes (that are defined in __init__() methods with doc-comments).
2239 
2240     Example:
2241 
2242         class Foo:
2243             def __init__(self):
2244                 self.attr = None  #: This is a target of this mix-in.
2245     """
2246 
2247     RUNTIME_INSTANCE_ATTRIBUTE = object()
2248 
2249     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2250         """Check the subject is an attribute defined in __init__()."""
2251         # An instance variable defined in __init__().
2252         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2253             return True
2254         else:
2255             return False
2256 
2257     def import_object(self, raiseerror: bool = False) -> bool:
2258         """Check the existence of runtime instance attribute when failed to import the
2259         attribute."""
2260         try:
2261             return super().import_object(raiseerror=True)  # type: ignore
2262         except ImportError as exc:
2263             try:
2264                 with mock(self.config.autodoc_mock_imports):
2265                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2266                                         attrgetter=self.get_attr,  # type: ignore
2267                                         warningiserror=self.config.autodoc_warningiserror)
2268                     parent = ret[3]
2269                     if self.is_runtime_instance_attribute(parent):
2270                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2271                         self.parent = parent
2272                         return True
2273             except ImportError:
2274                 pass
2275 
2276             if raiseerror:
2277                 raise
2278             else:
2279                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2280                 self.env.note_reread()
2281                 return False
2282 
2283     def should_suppress_value_header(self) -> bool:
2284         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2285                 super().should_suppress_value_header())
2286 
2287 
2288 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2289     """
2290     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2291     instance attributes (PEP-526 styled, annotation only attributes).
2292 
2293     Example:
2294 
2295         class Foo:
2296             attr: int  #: This is a target of this mix-in.
2297     """
2298 
2299     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2300         """Check the subject is an annotation only attribute."""
2301         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2302         if self.objpath[-1] in annotations:
2303             return True
2304         else:
2305             return False
2306 
2307     def import_object(self, raiseerror: bool = False) -> bool:
2308         """Check the exisitence of uninitialized instance attribute when failed to import
2309         the attribute."""
2310         try:
2311             return super().import_object(raiseerror=True)  # type: ignore
2312         except ImportError as exc:
2313             try:
2314                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2315                                     attrgetter=self.get_attr,  # type: ignore
2316                                     warningiserror=self.config.autodoc_warningiserror)
2317                 parent = ret[3]
2318                 if self.is_uninitialized_instance_attribute(parent):
2319                     self.object = UNINITIALIZED_ATTR
2320                     self.parent = parent
2321                     return True
2322             except ImportError:
2323                 pass
2324 
2325             if raiseerror:
2326                 raise
2327             else:
2328                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2329                 self.env.note_reread()
2330                 return False
2331 
2332     def should_suppress_value_header(self) -> bool:
2333         return (self.object is UNINITIALIZED_ATTR or
2334                 super().should_suppress_value_header())
2335 
2336     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2337         if self.object is UNINITIALIZED_ATTR:
2338             return None
2339         else:
2340             return super().get_doc(encoding, ignore)  # type: ignore
2341 
2342 
2343 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2344                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2345                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2346                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2347     """
2348     Specialized Documenter subclass for attributes.
2349     """
2350     objtype = 'attribute'
2351     member_order = 60
2352     option_spec = dict(ModuleLevelDocumenter.option_spec)
2353     option_spec["annotation"] = annotation_option
2354     option_spec["no-value"] = bool_option
2355 
2356     # must be higher than the MethodDocumenter, else it will recognize
2357     # some non-data descriptors as methods
2358     priority = 10
2359 
2360     @staticmethod
2361     def is_function_or_method(obj: Any) -> bool:
2362         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2363 
2364     @classmethod
2365     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2366                             ) -> bool:
2367         if inspect.isattributedescriptor(member):
2368             return True
2369         elif (not isinstance(parent, ModuleDocumenter) and
2370               not inspect.isroutine(member) and
2371               not isinstance(member, type)):
2372             return True
2373         else:
2374             return False
2375 
2376     def document_members(self, all_members: bool = False) -> None:
2377         pass
2378 
2379     def isinstanceattribute(self) -> bool:
2380         """Check the subject is an instance attribute."""
2381         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2382                       RemovedInSphinx50Warning)
2383         # uninitialized instance variable (PEP-526)
2384         with mock(self.config.autodoc_mock_imports):
2385             try:
2386                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2387                                     attrgetter=self.get_attr,
2388                                     warningiserror=self.config.autodoc_warningiserror)
2389                 self.parent = ret[3]
2390                 annotations = get_type_hints(self.parent, None,
2391                                              self.config.autodoc_type_aliases)
2392                 if self.objpath[-1] in annotations:
2393                     self.object = UNINITIALIZED_ATTR
2394                     return True
2395             except ImportError:
2396                 pass
2397 
2398         return False
2399 
2400     def update_annotations(self, parent: Any) -> None:
2401         """Update __annotations__ to support type_comment and so on."""
2402         try:
2403             annotations = dict(inspect.getannotations(parent))
2404             parent.__annotations__ = annotations
2405 
2406             for cls in inspect.getmro(parent):
2407                 try:
2408                     module = safe_getattr(cls, '__module__')
2409                     qualname = safe_getattr(cls, '__qualname__')
2410 
2411                     analyzer = ModuleAnalyzer.for_module(module)
2412                     analyzer.analyze()
2413                     for (classname, attrname), annotation in analyzer.annotations.items():
2414                         if classname == qualname and attrname not in annotations:
2415                             annotations[attrname] = annotation
2416                 except (AttributeError, PycodeError):
2417                     pass
2418         except AttributeError:
2419             pass
2420         except TypeError:
2421             # Failed to set __annotations__ (built-in, extensions, etc.)
2422             pass
2423 
2424     def import_object(self, raiseerror: bool = False) -> bool:
2425         ret = super().import_object(raiseerror)
2426         if inspect.isenumattribute(self.object):
2427             self.object = self.object.value
2428         if self.parent:
2429             self.update_annotations(self.parent)
2430 
2431         return ret
2432 
2433     def get_real_modname(self) -> str:
2434         return self.get_attr(self.parent or self.object, '__module__', None) \
2435             or self.modname
2436 
2437     def should_suppress_value_header(self) -> bool:
2438         if super().should_suppress_value_header():
2439             return True
2440         else:
2441             doc = self.get_doc()
2442             if doc:
2443                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2444                 if 'hide-value' in metadata:
2445                     return True
2446 
2447         return False
2448 
2449     def add_directive_header(self, sig: str) -> None:
2450         super().add_directive_header(sig)
2451         sourcename = self.get_sourcename()
2452         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2453             pass
2454         elif self.options.annotation:
2455             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2456         else:
2457             # obtain type annotation for this attribute
2458             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2459             if self.objpath[-1] in annotations:
2460                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2461                 self.add_line('   :type: ' + objrepr, sourcename)
2462 
2463             try:
2464                 if self.options.no_value or self.should_suppress_value_header():
2465                     pass
2466                 else:
2467                     objrepr = object_description(self.object)
2468                     self.add_line('   :value: ' + objrepr, sourcename)
2469             except ValueError:
2470                 pass
2471 
2472     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2473         try:
2474             for cls in inspect.getmro(parent):
2475                 try:
2476                     module = safe_getattr(cls, '__module__')
2477                     qualname = safe_getattr(cls, '__qualname__')
2478 
2479                     analyzer = ModuleAnalyzer.for_module(module)
2480                     analyzer.analyze()
2481                     if qualname and self.objpath:
2482                         key = (qualname, attrname)
2483                         if key in analyzer.attr_docs:
2484                             return list(analyzer.attr_docs[key])
2485                 except (AttributeError, PycodeError):
2486                     pass
2487         except (AttributeError, PycodeError):
2488             pass
2489 
2490         return None
2491 
2492     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2493         # Check the attribute has a docstring-comment
2494         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2495         if comment:
2496             return [comment]
2497 
2498         try:
2499             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2500             # a docstring from the value which descriptor returns unexpectedly.
2501             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2502             orig = self.config.autodoc_inherit_docstrings
2503             self.config.autodoc_inherit_docstrings = False  # type: ignore
2504             return super().get_doc(encoding, ignore)
2505         finally:
2506             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2507 
2508     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2509                     ) -> None:
2510         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2511         # AttributeDocumenter.add_content()
2512         self.analyzer = None
2513 
2514         if more_content is None:
2515             more_content = StringList()
2516         self.update_content(more_content)
2517         super().add_content(more_content, no_docstring)
2518 
2519 
2520 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2521     """
2522     Specialized Documenter subclass for properties.
2523     """
2524     objtype = 'property'
2525     directivetype = 'method'
2526     member_order = 60
2527 
2528     # before AttributeDocumenter
2529     priority = AttributeDocumenter.priority + 1
2530 
2531     @classmethod
2532     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2533                             ) -> bool:
2534         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2535 
2536     def document_members(self, all_members: bool = False) -> None:
2537         pass
2538 
2539     def get_real_modname(self) -> str:
2540         return self.get_attr(self.parent or self.object, '__module__', None) \
2541             or self.modname
2542 
2543     def add_directive_header(self, sig: str) -> None:
2544         super().add_directive_header(sig)
2545         sourcename = self.get_sourcename()
2546         if inspect.isabstractmethod(self.object):
2547             self.add_line('   :abstractmethod:', sourcename)
2548         self.add_line('   :property:', sourcename)
2549 
2550 
2551 class NewTypeAttributeDocumenter(AttributeDocumenter):
2552     """
2553     Specialized Documenter subclass for NewTypes.
2554 
2555     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2556     function object.
2557     """
2558 
2559     objtype = 'newvarattribute'
2560     directivetype = 'attribute'
2561     priority = MethodDocumenter.priority + 1
2562 
2563     @classmethod
2564     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2565                             ) -> bool:
2566         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2567 
2568 
2569 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2570     """Returns registered Documenter classes"""
2571     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2572     return app.registry.documenters
2573 
2574 
2575 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2576     """Alternative getattr() for types"""
2577     for typ, func in app.registry.autodoc_attrgettrs.items():
2578         if isinstance(obj, typ):
2579             return func(obj, name, *defargs)
2580 
2581     return safe_getattr(obj, name, *defargs)
2582 
2583 
2584 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2585     if config.autodoc_member_order == 'alphabetic':
2586         # RemovedInSphinx50Warning
2587         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2588                           'instead of "alphabetic". Please update your setting.'))
2589         config.autodoc_member_order = 'alphabetical'  # type: ignore
2590 
2591 
2592 # for compatibility
2593 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2594 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2595 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2596 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2597 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2598 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2599 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2600 
2601 
2602 def setup(app: Sphinx) -> Dict[str, Any]:
2603     app.add_autodocumenter(ModuleDocumenter)
2604     app.add_autodocumenter(ClassDocumenter)
2605     app.add_autodocumenter(ExceptionDocumenter)
2606     app.add_autodocumenter(DataDocumenter)
2607     app.add_autodocumenter(NewTypeDataDocumenter)
2608     app.add_autodocumenter(FunctionDocumenter)
2609     app.add_autodocumenter(DecoratorDocumenter)
2610     app.add_autodocumenter(MethodDocumenter)
2611     app.add_autodocumenter(AttributeDocumenter)
2612     app.add_autodocumenter(PropertyDocumenter)
2613     app.add_autodocumenter(NewTypeAttributeDocumenter)
2614 
2615     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2616     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2617                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2618     app.add_config_value('autodoc_default_options', {}, True)
2619     app.add_config_value('autodoc_docstring_signature', True, True)
2620     app.add_config_value('autodoc_mock_imports', [], True)
2621     app.add_config_value('autodoc_typehints', "signature", True,
2622                          ENUM("signature", "description", "none"))
2623     app.add_config_value('autodoc_type_aliases', {}, True)
2624     app.add_config_value('autodoc_warningiserror', True, True)
2625     app.add_config_value('autodoc_inherit_docstrings', True, True)
2626     app.add_event('autodoc-before-process-signature')
2627     app.add_event('autodoc-process-docstring')
2628     app.add_event('autodoc-process-signature')
2629     app.add_event('autodoc-skip-member')
2630 
2631     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2632 
2633     app.setup_extension('sphinx.ext.autodoc.type_comment')
2634     app.setup_extension('sphinx.ext.autodoc.typehints')
2635 
2636     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>This file's functionality includes automatically documenting Python source code files. The modification needed here involves ensuring that when extracting docstrings that include `code-block` or `literalinclude` directives, an automatic dedent is applied to these blocks if they lack a specific `:dedent:` value. This change should gracefully handle existing documentation and new inclusions alike, promoting ease of documentation writing and consistency in documentation appearance.</intended_behavior>]
2025-10-15 12:21:04.785 | INFO     | Search completed. Bug locations: [<file>sphinx/pycode/parser.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.pycode.parser
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities parsing and analyzing Python code.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 import inspect
11 import itertools
12 import re
13 import sys
14 import tokenize
15 from collections import OrderedDict
16 from inspect import Signature
17 from token import DEDENT, INDENT, NAME, NEWLINE, NUMBER, OP, STRING
18 from tokenize import COMMENT, NL
19 from typing import Any, Dict, List, Optional, Tuple
20 
21 from sphinx.pycode.ast import ast  # for py37 or older
22 from sphinx.pycode.ast import parse, unparse
23 
24 comment_re = re.compile('^\\s*#: ?(.*)\r?\n?$')
25 indent_re = re.compile('^\\s*$')
26 emptyline_re = re.compile('^\\s*(#.*)?$')
27 
28 
29 if sys.version_info >= (3, 6):
30     ASSIGN_NODES = (ast.Assign, ast.AnnAssign)
31 else:
32     ASSIGN_NODES = (ast.Assign)
33 
34 
35 def filter_whitespace(code: str) -> str:
36     return code.replace('\f', ' ')  # replace FF (form feed) with whitespace
37 
38 
39 def get_assign_targets(node: ast.AST) -> List[ast.expr]:
40     """Get list of targets from Assign and AnnAssign node."""
41     if isinstance(node, ast.Assign):
42         return node.targets
43     else:
44         return [node.target]  # type: ignore
45 
46 
47 def get_lvar_names(node: ast.AST, self: ast.arg = None) -> List[str]:
48     """Convert assignment-AST to variable names.
49 
50     This raises `TypeError` if the assignment does not create new variable::
51 
52         ary[0] = 'foo'
53         dic["bar"] = 'baz'
54         # => TypeError
55     """
56     if self:
57         self_id = self.arg
58 
59     node_name = node.__class__.__name__
60     if node_name in ('Index', 'Num', 'Slice', 'Str', 'Subscript'):
61         raise TypeError('%r does not create new variable' % node)
62     elif node_name == 'Name':
63         if self is None or node.id == self_id:  # type: ignore
64             return [node.id]  # type: ignore
65         else:
66             raise TypeError('The assignment %r is not instance variable' % node)
67     elif node_name in ('Tuple', 'List'):
68         members = []
69         for elt in node.elts:  # type: ignore
70             try:
71                 members.extend(get_lvar_names(elt, self))
72             except TypeError:
73                 pass
74         return members
75     elif node_name == 'Attribute':
76         if node.value.__class__.__name__ == 'Name' and self and node.value.id == self_id:  # type: ignore  # NOQA
77             # instance variable
78             return ["%s" % get_lvar_names(node.attr, self)[0]]  # type: ignore
79         else:
80             raise TypeError('The assignment %r is not instance variable' % node)
81     elif node_name == 'str':
82         return [node]  # type: ignore
83     elif node_name == 'Starred':
84         return get_lvar_names(node.value, self)  # type: ignore
85     else:
86         raise NotImplementedError('Unexpected node name %r' % node_name)
87 
88 
89 def dedent_docstring(s: str) -> str:
90     """Remove common leading indentation from docstring."""
91     def dummy() -> None:
92         # dummy function to mock `inspect.getdoc`.
93         pass
94 
95     dummy.__doc__ = s
96     docstring = inspect.getdoc(dummy)
97     return docstring.lstrip("\r\n").rstrip("\r\n")
98 
99 
100 class Token:
101     """Better token wrapper for tokenize module."""
102 
103     def __init__(self, kind: int, value: Any, start: Tuple[int, int], end: Tuple[int, int],
104                  source: str) -> None:
105         self.kind = kind
106         self.value = value
107         self.start = start
108         self.end = end
109         self.source = source
110 
111     def __eq__(self, other: Any) -> bool:
112         if isinstance(other, int):
113             return self.kind == other
114         elif isinstance(other, str):
115             return self.value == other
116         elif isinstance(other, (list, tuple)):
117             return [self.kind, self.value] == list(other)
118         elif other is None:
119             return False
120         else:
121             raise ValueError('Unknown value: %r' % other)
122 
123     def match(self, *conditions: Any) -> bool:
124         return any(self == candidate for candidate in conditions)
125 
126     def __repr__(self) -> str:
127         return '<Token kind=%r value=%r>' % (tokenize.tok_name[self.kind],
128                                              self.value.strip())
129 
130 
131 class TokenProcessor:
132     def __init__(self, buffers: List[str]) -> None:
133         lines = iter(buffers)
134         self.buffers = buffers
135         self.tokens = tokenize.generate_tokens(lambda: next(lines))
136         self.current = None     # type: Token
137         self.previous = None    # type: Token
138 
139     def get_line(self, lineno: int) -> str:
140         """Returns specified line."""
141         return self.buffers[lineno - 1]
142 
143     def fetch_token(self) -> Token:
144         """Fetch a next token from source code.
145 
146         Returns ``None`` if sequence finished.
147         """
148         try:
149             self.previous = self.current
150             self.current = Token(*next(self.tokens))
151         except StopIteration:
152             self.current = None
153 
154         return self.current
155 
156     def fetch_until(self, condition: Any) -> List[Token]:
157         """Fetch tokens until specified token appeared.
158 
159         .. note:: This also handles parenthesis well.
160         """
161         tokens = []
162         while self.fetch_token():
163             tokens.append(self.current)
164             if self.current == condition:
165                 break
166             elif self.current == [OP, '(']:
167                 tokens += self.fetch_until([OP, ')'])
168             elif self.current == [OP, '{']:
169                 tokens += self.fetch_until([OP, '}'])
170             elif self.current == [OP, '[']:
171                 tokens += self.fetch_until([OP, ']'])
172 
173         return tokens
174 
175 
176 class AfterCommentParser(TokenProcessor):
177     """Python source code parser to pick up comment after assignment.
178 
179     This parser takes a python code starts with assignment statement,
180     and returns the comments for variable if exists.
181     """
182 
183     def __init__(self, lines: List[str]) -> None:
184         super().__init__(lines)
185         self.comment = None  # type: str
186 
187     def fetch_rvalue(self) -> List[Token]:
188         """Fetch right-hand value of assignment."""
189         tokens = []
190         while self.fetch_token():
191             tokens.append(self.current)
192             if self.current == [OP, '(']:
193                 tokens += self.fetch_until([OP, ')'])
194             elif self.current == [OP, '{']:
195                 tokens += self.fetch_until([OP, '}'])
196             elif self.current == [OP, '[']:
197                 tokens += self.fetch_until([OP, ']'])
198             elif self.current == INDENT:
199                 tokens += self.fetch_until(DEDENT)
200             elif self.current == [OP, ';']:
201                 break
202             elif self.current.kind not in (OP, NAME, NUMBER, STRING):
203                 break
204 
205         return tokens
206 
207     def parse(self) -> None:
208         """Parse the code and obtain comment after assignment."""
209         # skip lvalue (or whole of AnnAssign)
210         while not self.fetch_token().match([OP, '='], NEWLINE, COMMENT):
211             assert self.current
212 
213         # skip rvalue (if exists)
214         if self.current == [OP, '=']:
215             self.fetch_rvalue()
216 
217         if self.current == COMMENT:
218             self.comment = self.current.value
219 
220 
221 class VariableCommentPicker(ast.NodeVisitor):
222     """Python source code parser to pick up variable comments."""
223 
224     def __init__(self, buffers: List[str], encoding: str) -> None:
225         self.counter = itertools.count()
226         self.buffers = buffers
227         self.encoding = encoding
228         self.context = []               # type: List[str]
229         self.current_classes = []       # type: List[str]
230         self.current_function = None    # type: ast.FunctionDef
231         self.comments = OrderedDict()   # type: Dict[Tuple[str, str], str]
232         self.annotations = {}           # type: Dict[Tuple[str, str], str]
233         self.previous = None            # type: ast.AST
234         self.deforders = {}             # type: Dict[str, int]
235         self.finals = []                # type: List[str]
236         self.overloads = {}             # type: Dict[str, List[Signature]]
237         self.typing = None              # type: str
238         self.typing_final = None        # type: str
239         self.typing_overload = None     # type: str
240         super().__init__()
241 
242     def get_qualname_for(self, name: str) -> Optional[List[str]]:
243         """Get qualified name for given object as a list of string."""
244         if self.current_function:
245             if self.current_classes and self.context[-1] == "__init__":
246                 # store variable comments inside __init__ method of classes
247                 return self.context[:-1] + [name]
248             else:
249                 return None
250         else:
251             return self.context + [name]
252 
253     def add_entry(self, name: str) -> None:
254         qualname = self.get_qualname_for(name)
255         if qualname:
256             self.deforders[".".join(qualname)] = next(self.counter)
257 
258     def add_final_entry(self, name: str) -> None:
259         qualname = self.get_qualname_for(name)
260         if qualname:
261             self.finals.append(".".join(qualname))
262 
263     def add_overload_entry(self, func: ast.FunctionDef) -> None:
264         # avoid circular import problem
265         from sphinx.util.inspect import signature_from_ast
266         qualname = self.get_qualname_for(func.name)
267         if qualname:
268             overloads = self.overloads.setdefault(".".join(qualname), [])
269             overloads.append(signature_from_ast(func))
270 
271     def add_variable_comment(self, name: str, comment: str) -> None:
272         qualname = self.get_qualname_for(name)
273         if qualname:
274             basename = ".".join(qualname[:-1])
275             self.comments[(basename, name)] = comment
276 
277     def add_variable_annotation(self, name: str, annotation: ast.AST) -> None:
278         qualname = self.get_qualname_for(name)
279         if qualname:
280             basename = ".".join(qualname[:-1])
281             self.annotations[(basename, name)] = unparse(annotation)
282 
283     def is_final(self, decorators: List[ast.expr]) -> bool:
284         final = []
285         if self.typing:
286             final.append('%s.final' % self.typing)
287         if self.typing_final:
288             final.append(self.typing_final)
289 
290         for decorator in decorators:
291             try:
292                 if unparse(decorator) in final:
293                     return True
294             except NotImplementedError:
295                 pass
296 
297         return False
298 
299     def is_overload(self, decorators: List[ast.expr]) -> bool:
300         overload = []
301         if self.typing:
302             overload.append('%s.overload' % self.typing)
303         if self.typing_overload:
304             overload.append(self.typing_overload)
305 
306         for decorator in decorators:
307             try:
308                 if unparse(decorator) in overload:
309                     return True
310             except NotImplementedError:
311                 pass
312 
313         return False
314 
315     def get_self(self) -> ast.arg:
316         """Returns the name of first argument if in function."""
317         if self.current_function and self.current_function.args.args:
318             return self.current_function.args.args[0]
319         else:
320             return None
321 
322     def get_line(self, lineno: int) -> str:
323         """Returns specified line."""
324         return self.buffers[lineno - 1]
325 
326     def visit(self, node: ast.AST) -> None:
327         """Updates self.previous to ."""
328         super().visit(node)
329         self.previous = node
330 
331     def visit_Import(self, node: ast.Import) -> None:
332         """Handles Import node and record it to definition orders."""
333         for name in node.names:
334             self.add_entry(name.asname or name.name)
335 
336             if name.name == 'typing':
337                 self.typing = name.asname or name.name
338             elif name.name == 'typing.final':
339                 self.typing_final = name.asname or name.name
340             elif name.name == 'typing.overload':
341                 self.typing_overload = name.asname or name.name
342 
343     def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
344         """Handles Import node and record it to definition orders."""
345         for name in node.names:
346             self.add_entry(name.asname or name.name)
347 
348             if node.module == 'typing' and name.name == 'final':
349                 self.typing_final = name.asname or name.name
350             elif node.module == 'typing' and name.name == 'overload':
351                 self.typing_overload = name.asname or name.name
352 
353     def visit_Assign(self, node: ast.Assign) -> None:
354         """Handles Assign node and pick up a variable comment."""
355         try:
356             targets = get_assign_targets(node)
357             varnames = sum([get_lvar_names(t, self=self.get_self()) for t in targets], [])  # type: List[str]  # NOQA
358             current_line = self.get_line(node.lineno)
359         except TypeError:
360             return  # this assignment is not new definition!
361 
362         # record annotation
363         if hasattr(node, 'annotation') and node.annotation:  # type: ignore
364             for varname in varnames:
365                 self.add_variable_annotation(varname, node.annotation)  # type: ignore
366         elif hasattr(node, 'type_comment') and node.type_comment:
367             for varname in varnames:
368                 self.add_variable_annotation(varname, node.type_comment)  # type: ignore
369 
370         # check comments after assignment
371         parser = AfterCommentParser([current_line[node.col_offset:]] +
372                                     self.buffers[node.lineno:])
373         parser.parse()
374         if parser.comment and comment_re.match(parser.comment):
375             for varname in varnames:
376                 self.add_variable_comment(varname, comment_re.sub('\\1', parser.comment))
377                 self.add_entry(varname)
378             return
379 
380         # check comments before assignment
381         if indent_re.match(current_line[:node.col_offset]):
382             comment_lines = []
383             for i in range(node.lineno - 1):
384                 before_line = self.get_line(node.lineno - 1 - i)
385                 if comment_re.match(before_line):
386                     comment_lines.append(comment_re.sub('\\1', before_line))
387                 else:
388                     break
389 
390             if comment_lines:
391                 comment = dedent_docstring('\n'.join(reversed(comment_lines)))
392                 for varname in varnames:
393                     self.add_variable_comment(varname, comment)
394                     self.add_entry(varname)
395                 return
396 
397         # not commented (record deforders only)
398         for varname in varnames:
399             self.add_entry(varname)
400 
401     def visit_AnnAssign(self, node: ast.AST) -> None:  # Note: ast.AnnAssign not found in py35
402         """Handles AnnAssign node and pick up a variable comment."""
403         self.visit_Assign(node)  # type: ignore
404 
405     def visit_Expr(self, node: ast.Expr) -> None:
406         """Handles Expr node and pick up a comment if string."""
407         if (isinstance(self.previous, ASSIGN_NODES) and isinstance(node.value, ast.Str)):
408             try:
409                 targets = get_assign_targets(self.previous)
410                 varnames = get_lvar_names(targets[0], self.get_self())
411                 for varname in varnames:
412                     if isinstance(node.value.s, str):
413                         docstring = node.value.s
414                     else:
415                         docstring = node.value.s.decode(self.encoding or 'utf-8')
416 
417                     self.add_variable_comment(varname, dedent_docstring(docstring))
418                     self.add_entry(varname)
419             except TypeError:
420                 pass  # this assignment is not new definition!
421 
422     def visit_Try(self, node: ast.Try) -> None:
423         """Handles Try node and processes body and else-clause.
424 
425         .. note:: pycode parser ignores objects definition in except-clause.
426         """
427         for subnode in node.body:
428             self.visit(subnode)
429         for subnode in node.orelse:
430             self.visit(subnode)
431 
432     def visit_ClassDef(self, node: ast.ClassDef) -> None:
433         """Handles ClassDef node and set context."""
434         self.current_classes.append(node.name)
435         self.add_entry(node.name)
436         if self.is_final(node.decorator_list):
437             self.add_final_entry(node.name)
438         self.context.append(node.name)
439         self.previous = node
440         for child in node.body:
441             self.visit(child)
442         self.context.pop()
443         self.current_classes.pop()
444 
445     def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
446         """Handles FunctionDef node and set context."""
447         if self.current_function is None:
448             self.add_entry(node.name)  # should be called before setting self.current_function
449             if self.is_final(node.decorator_list):
450                 self.add_final_entry(node.name)
451             if self.is_overload(node.decorator_list):
452                 self.add_overload_entry(node)
453             self.context.append(node.name)
454             self.current_function = node
455             for child in node.body:
456                 self.visit(child)
457             self.context.pop()
458             self.current_function = None
459 
460     def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:
461         """Handles AsyncFunctionDef node and set context."""
462         self.visit_FunctionDef(node)  # type: ignore
463 
464 
465 class DefinitionFinder(TokenProcessor):
466     """Python source code parser to detect location of functions,
467     classes and methods.
468     """
469 
470     def __init__(self, lines: List[str]) -> None:
471         super().__init__(lines)
472         self.decorator = None   # type: Token
473         self.context = []       # type: List[str]
474         self.indents = []       # type: List
475         self.definitions = {}   # type: Dict[str, Tuple[str, int, int]]
476 
477     def add_definition(self, name: str, entry: Tuple[str, int, int]) -> None:
478         """Add a location of definition."""
479         if self.indents and self.indents[-1][0] == 'def' and entry[0] == 'def':
480             # ignore definition of inner function
481             pass
482         else:
483             self.definitions[name] = entry
484 
485     def parse(self) -> None:
486         """Parse the code to obtain location of definitions."""
487         while True:
488             token = self.fetch_token()
489             if token is None:
490                 break
491             elif token == COMMENT:
492                 pass
493             elif token == [OP, '@'] and (self.previous is None or
494                                          self.previous.match(NEWLINE, NL, INDENT, DEDENT)):
495                 if self.decorator is None:
496                     self.decorator = token
497             elif token.match([NAME, 'class']):
498                 self.parse_definition('class')
499             elif token.match([NAME, 'def']):
500                 self.parse_definition('def')
501             elif token == INDENT:
502                 self.indents.append(('other', None, None))
503             elif token == DEDENT:
504                 self.finalize_block()
505 
506     def parse_definition(self, typ: str) -> None:
507         """Parse AST of definition."""
508         name = self.fetch_token()
509         self.context.append(name.value)
510         funcname = '.'.join(self.context)
511 
512         if self.decorator:
513             start_pos = self.decorator.start[0]
514             self.decorator = None
515         else:
516             start_pos = name.start[0]
517 
518         self.fetch_until([OP, ':'])
519         if self.fetch_token().match(COMMENT, NEWLINE):
520             self.fetch_until(INDENT)
521             self.indents.append((typ, funcname, start_pos))
522         else:
523             # one-liner
524             self.add_definition(funcname, (typ, start_pos, name.end[0]))
525             self.context.pop()
526 
527     def finalize_block(self) -> None:
528         """Finalize definition block."""
529         definition = self.indents.pop()
530         if definition[0] != 'other':
531             typ, funcname, start_pos = definition
532             end_pos = self.current.end[0] - 1
533             while emptyline_re.match(self.get_line(end_pos)):
534                 end_pos -= 1
535 
536             self.add_definition(funcname, (typ, start_pos, end_pos))
537             self.context.pop()
538 
539 
540 class Parser:
541     """Python source code parser to pick up variable comments.
542 
543     This is a better wrapper for ``VariableCommentPicker``.
544     """
545 
546     def __init__(self, code: str, encoding: str = 'utf-8') -> None:
547         self.code = filter_whitespace(code)
548         self.encoding = encoding
549         self.annotations = {}       # type: Dict[Tuple[str, str], str]
550         self.comments = {}          # type: Dict[Tuple[str, str], str]
551         self.deforders = {}         # type: Dict[str, int]
552         self.definitions = {}       # type: Dict[str, Tuple[str, int, int]]
553         self.finals = []            # type: List[str]
554         self.overloads = {}         # type: Dict[str, List[Signature]]
555 
556     def parse(self) -> None:
557         """Parse the source code."""
558         self.parse_comments()
559         self.parse_definition()
560 
561     def parse_comments(self) -> None:
562         """Parse the code and pick up comments."""
563         tree = parse(self.code)
564         picker = VariableCommentPicker(self.code.splitlines(True), self.encoding)
565         picker.visit(tree)
566         self.annotations = picker.annotations
567         self.comments = picker.comments
568         self.deforders = picker.deforders
569         self.finals = picker.finals
570         self.overloads = picker.overloads
571 
572     def parse_definition(self) -> None:
573         """Parse the location of definitions from the code."""
574         parser = DefinitionFinder(self.code.splitlines(True))
575         parser.parse()
576         self.definitions = parser.definitions

</code><intended_behavior>This file possibly contains logic for parsing and analyzing Python code within the documentation. To resolve the issue, the parser's handling of code blocks should be extended to automatically dedent them unless a specific `:dedent:` value is given. This will allow for easier inclusion of code samples without manually adjusting indentation.</intended_behavior>, <file>sphinx/domains/std.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.std
3     ~~~~~~~~~~~~~~~~~~
4 
5     The standard domain.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 import warnings
14 from copy import copy
15 from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union, cast
16 
17 from docutils import nodes
18 from docutils.nodes import Element, Node, system_message
19 from docutils.parsers.rst import Directive, directives
20 from docutils.statemachine import StringList
21 
22 from sphinx import addnodes
23 from sphinx.addnodes import desc_signature, pending_xref
24 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
25 from sphinx.directives import ObjectDescription
26 from sphinx.domains import Domain, ObjType
27 from sphinx.locale import _, __
28 from sphinx.roles import XRefRole
29 from sphinx.util import docname_join, logging, ws_re
30 from sphinx.util.docutils import SphinxDirective
31 from sphinx.util.nodes import clean_astext, make_id, make_refnode
32 from sphinx.util.typing import RoleFunction
33 
34 if False:
35     # For type annotation
36     from typing import Type  # for python3.5.1
37 
38     from sphinx.application import Sphinx
39     from sphinx.builders import Builder
40     from sphinx.environment import BuildEnvironment
41 
42 logger = logging.getLogger(__name__)
43 
44 
45 # RE for option descriptions
46 option_desc_re = re.compile(r'((?:/|--|-|\+)?[^\s=]+)(=?\s*.*)')
47 # RE for grammar tokens
48 token_re = re.compile(r'`(\w+)`', re.U)
49 
50 
51 class GenericObject(ObjectDescription[str]):
52     """
53     A generic x-ref directive registered with Sphinx.add_object_type().
54     """
55     indextemplate = ''
56     parse_node = None  # type: Callable[[GenericObject, BuildEnvironment, str, desc_signature], str]  # NOQA
57 
58     def handle_signature(self, sig: str, signode: desc_signature) -> str:
59         if self.parse_node:
60             name = self.parse_node(self.env, sig, signode)
61         else:
62             signode.clear()
63             signode += addnodes.desc_name(sig, sig)
64             # normalize whitespace like XRefRole does
65             name = ws_re.sub(' ', sig)
66         return name
67 
68     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:
69         node_id = make_id(self.env, self.state.document, self.objtype, name)
70         signode['ids'].append(node_id)
71 
72         # Assign old styled node_id not to break old hyperlinks (if possible)
73         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
74         old_node_id = self.make_old_id(name)
75         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:
76             signode['ids'].append(old_node_id)
77 
78         self.state.document.note_explicit_target(signode)
79 
80         if self.indextemplate:
81             colon = self.indextemplate.find(':')
82             if colon != -1:
83                 indextype = self.indextemplate[:colon].strip()
84                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)
85             else:
86                 indextype = 'single'
87                 indexentry = self.indextemplate % (name,)
88             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))
89 
90         std = cast(StandardDomain, self.env.get_domain('std'))
91         std.note_object(self.objtype, name, node_id, location=signode)
92 
93     def make_old_id(self, name: str) -> str:
94         """Generate old styled node_id for generic objects.
95 
96         .. note:: Old Styled node_id was used until Sphinx-3.0.
97                   This will be removed in Sphinx-5.0.
98         """
99         return self.objtype + '-' + name
100 
101 
102 class EnvVar(GenericObject):
103     indextemplate = _('environment variable; %s')
104 
105 
106 class EnvVarXRefRole(XRefRole):
107     """
108     Cross-referencing role for environment variables (adds an index entry).
109     """
110 
111     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
112                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
113         if not is_ref:
114             return [node], []
115         varname = node['reftarget']
116         tgtid = 'index-%s' % env.new_serialno('index')
117         indexnode = addnodes.index()
118         indexnode['entries'] = [
119             ('single', varname, tgtid, '', None),
120             ('single', _('environment variable; %s') % varname, tgtid, '', None)
121         ]
122         targetnode = nodes.target('', '', ids=[tgtid])
123         document.note_explicit_target(targetnode)
124         return [indexnode, targetnode, node], []
125 
126 
127 class Target(SphinxDirective):
128     """
129     Generic target for user-defined cross-reference types.
130     """
131     indextemplate = ''
132 
133     has_content = False
134     required_arguments = 1
135     optional_arguments = 0
136     final_argument_whitespace = True
137     option_spec = {}  # type: Dict
138 
139     def run(self) -> List[Node]:
140         # normalize whitespace in fullname like XRefRole does
141         fullname = ws_re.sub(' ', self.arguments[0].strip())
142         node_id = make_id(self.env, self.state.document, self.name, fullname)
143         node = nodes.target('', '', ids=[node_id])
144         self.set_source_info(node)
145 
146         # Assign old styled node_id not to break old hyperlinks (if possible)
147         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
148         old_node_id = self.make_old_id(fullname)
149         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:
150             node['ids'].append(old_node_id)
151 
152         self.state.document.note_explicit_target(node)
153         ret = [node]  # type: List[Node]
154         if self.indextemplate:
155             indexentry = self.indextemplate % (fullname,)
156             indextype = 'single'
157             colon = indexentry.find(':')
158             if colon != -1:
159                 indextype = indexentry[:colon].strip()
160                 indexentry = indexentry[colon + 1:].strip()
161             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])
162             ret.insert(0, inode)
163         name = self.name
164         if ':' in self.name:
165             _, name = self.name.split(':', 1)
166 
167         std = cast(StandardDomain, self.env.get_domain('std'))
168         std.note_object(name, fullname, node_id, location=node)
169 
170         return ret
171 
172     def make_old_id(self, name: str) -> str:
173         """Generate old styled node_id for targets.
174 
175         .. note:: Old Styled node_id was used until Sphinx-3.0.
176                   This will be removed in Sphinx-5.0.
177         """
178         return self.name + '-' + name
179 
180 
181 class Cmdoption(ObjectDescription[str]):
182     """
183     Description of a command-line option (.. option).
184     """
185 
186     def handle_signature(self, sig: str, signode: desc_signature) -> str:
187         """Transform an option description into RST nodes."""
188         count = 0
189         firstname = ''
190         for potential_option in sig.split(', '):
191             potential_option = potential_option.strip()
192             m = option_desc_re.match(potential_option)
193             if not m:
194                 logger.warning(__('Malformed option description %r, should '
195                                   'look like "opt", "-opt args", "--opt args", '
196                                   '"/opt args" or "+opt args"'), potential_option,
197                                location=signode)
198                 continue
199             optname, args = m.groups()
200             if optname.endswith('[') and args.endswith(']'):
201                 # optional value surrounded by brackets (ex. foo[=bar])
202                 optname = optname[:-1]
203                 args = '[' + args
204 
205             if count:
206                 signode += addnodes.desc_addname(', ', ', ')
207             signode += addnodes.desc_name(optname, optname)
208             signode += addnodes.desc_addname(args, args)
209             if not count:
210                 firstname = optname
211                 signode['allnames'] = [optname]
212             else:
213                 signode['allnames'].append(optname)
214             count += 1
215         if not firstname:
216             raise ValueError
217         return firstname
218 
219     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:
220         currprogram = self.env.ref_context.get('std:program')
221         for optname in signode.get('allnames', []):
222             prefixes = ['cmdoption']
223             if currprogram:
224                 prefixes.append(currprogram)
225             if not optname.startswith(('-', '/')):
226                 prefixes.append('arg')
227             prefix = '-'.join(prefixes)
228             node_id = make_id(self.env, self.state.document, prefix, optname)
229             signode['ids'].append(node_id)
230 
231             old_node_id = self.make_old_id(prefix, optname)
232             if old_node_id not in self.state.document.ids and \
233                old_node_id not in signode['ids']:
234                 signode['ids'].append(old_node_id)
235 
236         self.state.document.note_explicit_target(signode)
237 
238         domain = cast(StandardDomain, self.env.get_domain('std'))
239         for optname in signode.get('allnames', []):
240             domain.add_program_option(currprogram, optname,
241                                       self.env.docname, signode['ids'][0])
242 
243         # create an index entry
244         if currprogram:
245             descr = _('%s command line option') % currprogram
246         else:
247             descr = _('command line option')
248         for option in sig.split(', '):
249             entry = '; '.join([descr, option])
250             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))
251 
252     def make_old_id(self, prefix: str, optname: str) -> str:
253         """Generate old styled node_id for cmdoption.
254 
255         .. note:: Old Styled node_id was used until Sphinx-3.0.
256                   This will be removed in Sphinx-5.0.
257         """
258         return nodes.make_id(prefix + '-' + optname)
259 
260 
261 class Program(SphinxDirective):
262     """
263     Directive to name the program for which options are documented.
264     """
265 
266     has_content = False
267     required_arguments = 1
268     optional_arguments = 0
269     final_argument_whitespace = True
270     option_spec = {}  # type: Dict
271 
272     def run(self) -> List[Node]:
273         program = ws_re.sub('-', self.arguments[0].strip())
274         if program == 'None':
275             self.env.ref_context.pop('std:program', None)
276         else:
277             self.env.ref_context['std:program'] = program
278         return []
279 
280 
281 class OptionXRefRole(XRefRole):
282     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
283                      title: str, target: str) -> Tuple[str, str]:
284         refnode['std:program'] = env.ref_context.get('std:program')
285         return title, target
286 
287 
288 def split_term_classifiers(line: str) -> List[Optional[str]]:
289     # split line into a term and classifiers. if no classifier, None is used..
290     parts = re.split(' +: +', line) + [None]
291     return parts
292 
293 
294 def make_glossary_term(env: "BuildEnvironment", textnodes: Iterable[Node], index_key: str,
295                        source: str, lineno: int, node_id: str = None,
296                        document: nodes.document = None) -> nodes.term:
297     # get a text-only representation of the term and register it
298     # as a cross-reference target
299     term = nodes.term('', '', *textnodes)
300     term.source = source
301     term.line = lineno
302     termtext = term.astext()
303 
304     if node_id:
305         # node_id is given from outside (mainly i18n module), use it forcedly
306         term['ids'].append(node_id)
307     elif document:
308         node_id = make_id(env, document, 'term', termtext)
309         term['ids'].append(node_id)
310         document.note_explicit_target(term)
311     else:
312         warnings.warn('make_glossary_term() expects document is passed as an argument.',
313                       RemovedInSphinx40Warning, stacklevel=2)
314         gloss_entries = env.temp_data.setdefault('gloss_entries', set())
315         node_id = nodes.make_id('term-' + termtext)
316         if node_id == 'term':
317             # "term" is not good for node_id.  Generate it by sequence number instead.
318             node_id = 'term-%d' % env.new_serialno('glossary')
319 
320         while node_id in gloss_entries:
321             node_id = 'term-%d' % env.new_serialno('glossary')
322         gloss_entries.add(node_id)
323         term['ids'].append(node_id)
324 
325     std = cast(StandardDomain, env.get_domain('std'))
326     std.note_object('term', termtext, node_id, location=term)
327 
328     # add an index entry too
329     indexnode = addnodes.index()
330     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]
331     indexnode.source, indexnode.line = term.source, term.line
332     term.append(indexnode)
333 
334     return term
335 
336 
337 class Glossary(SphinxDirective):
338     """
339     Directive to create a glossary with cross-reference targets for :term:
340     roles.
341     """
342 
343     has_content = True
344     required_arguments = 0
345     optional_arguments = 0
346     final_argument_whitespace = False
347     option_spec = {
348         'sorted': directives.flag,
349     }
350 
351     def run(self) -> List[Node]:
352         node = addnodes.glossary()
353         node.document = self.state.document
354 
355         # This directive implements a custom format of the reST definition list
356         # that allows multiple lines of terms before the definition.  This is
357         # easy to parse since we know that the contents of the glossary *must
358         # be* a definition list.
359 
360         # first, collect single entries
361         entries = []  # type: List[Tuple[List[Tuple[str, str, int]], StringList]]
362         in_definition = True
363         in_comment = False
364         was_empty = True
365         messages = []  # type: List[Node]
366         for line, (source, lineno) in zip(self.content, self.content.items):
367             # empty line -> add to last definition
368             if not line:
369                 if in_definition and entries:
370                     entries[-1][1].append('', source, lineno)
371                 was_empty = True
372                 continue
373             # unindented line -> a term
374             if line and not line[0].isspace():
375                 # enable comments
376                 if line.startswith('.. '):
377                     in_comment = True
378                     continue
379                 else:
380                     in_comment = False
381 
382                 # first term of definition
383                 if in_definition:
384                     if not was_empty:
385                         messages.append(self.state.reporter.warning(
386                             _('glossary term must be preceded by empty line'),
387                             source=source, line=lineno))
388                     entries.append(([(line, source, lineno)], StringList()))
389                     in_definition = False
390                 # second term and following
391                 else:
392                     if was_empty:
393                         messages.append(self.state.reporter.warning(
394                             _('glossary terms must not be separated by empty lines'),
395                             source=source, line=lineno))
396                     if entries:
397                         entries[-1][0].append((line, source, lineno))
398                     else:
399                         messages.append(self.state.reporter.warning(
400                             _('glossary seems to be misformatted, check indentation'),
401                             source=source, line=lineno))
402             elif in_comment:
403                 pass
404             else:
405                 if not in_definition:
406                     # first line of definition, determines indentation
407                     in_definition = True
408                     indent_len = len(line) - len(line.lstrip())
409                 if entries:
410                     entries[-1][1].append(line[indent_len:], source, lineno)
411                 else:
412                     messages.append(self.state.reporter.warning(
413                         _('glossary seems to be misformatted, check indentation'),
414                         source=source, line=lineno))
415             was_empty = False
416 
417         # now, parse all the entries into a big definition list
418         items = []
419         for terms, definition in entries:
420             termtexts = []          # type: List[str]
421             termnodes = []          # type: List[Node]
422             system_messages = []    # type: List[Node]
423             for line, source, lineno in terms:
424                 parts = split_term_classifiers(line)
425                 # parse the term with inline markup
426                 # classifiers (parts[1:]) will not be shown on doctree
427                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)
428 
429                 # use first classifier as a index key
430                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,
431                                           document=self.state.document)
432                 term.rawsource = line
433                 system_messages.extend(sysmsg)
434                 termtexts.append(term.astext())
435                 termnodes.append(term)
436 
437             termnodes.extend(system_messages)
438 
439             defnode = nodes.definition()
440             if definition:
441                 self.state.nested_parse(definition, definition.items[0][1],
442                                         defnode)
443             termnodes.append(defnode)
444             items.append((termtexts,
445                           nodes.definition_list_item('', *termnodes)))
446 
447         if 'sorted' in self.options:
448             items.sort(key=lambda x:
449                        unicodedata.normalize('NFD', x[0][0].lower()))
450 
451         dlist = nodes.definition_list()
452         dlist['classes'].append('glossary')
453         dlist.extend(item[1] for item in items)
454         node += dlist
455         return messages + [node]
456 
457 
458 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:
459     if len(productionGroup) != 0:
460         productionGroup += ':'
461     retnodes = []  # type: List[Node]
462     pos = 0
463     for m in token_re.finditer(text):
464         if m.start() > pos:
465             txt = text[pos:m.start()]
466             retnodes.append(nodes.Text(txt, txt))
467         refnode = pending_xref(m.group(1), reftype='token', refdomain='std',
468                                reftarget=productionGroup + m.group(1))
469         refnode += nodes.literal(m.group(1), m.group(1), classes=['xref'])
470         retnodes.append(refnode)
471         pos = m.end()
472     if pos < len(text):
473         retnodes.append(nodes.Text(text[pos:], text[pos:]))
474     return retnodes
475 
476 
477 class ProductionList(SphinxDirective):
478     """
479     Directive to list grammar productions.
480     """
481 
482     has_content = False
483     required_arguments = 1
484     optional_arguments = 0
485     final_argument_whitespace = True
486     option_spec = {}  # type: Dict
487 
488     def run(self) -> List[Node]:
489         domain = cast(StandardDomain, self.env.get_domain('std'))
490         node = addnodes.productionlist()  # type: Element
491         self.set_source_info(node)
492         # The backslash handling is from ObjectDescription.get_signatures
493         nl_escape_re = re.compile(r'\\\n')
494         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
495 
496         productionGroup = ""
497         i = 0
498         for rule in lines:
499             if i == 0 and ':' not in rule:
500                 productionGroup = rule.strip()
501                 continue
502             i += 1
503             try:
504                 name, tokens = rule.split(':', 1)
505             except ValueError:
506                 break
507             subnode = addnodes.production(rule)
508             name = name.strip()
509             subnode['tokenname'] = name
510             if subnode['tokenname']:
511                 prefix = 'grammar-token-%s' % productionGroup
512                 node_id = make_id(self.env, self.state.document, prefix, name)
513                 subnode['ids'].append(node_id)
514 
515                 # Assign old styled node_id not to break old hyperlinks (if possible)
516                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
517                 old_node_id = self.make_old_id(name)
518                 if (old_node_id not in self.state.document.ids and
519                         old_node_id not in subnode['ids']):
520                     subnode['ids'].append(old_node_id)
521 
522                 self.state.document.note_implicit_target(subnode, subnode)
523 
524                 if len(productionGroup) != 0:
525                     objName = "%s:%s" % (productionGroup, name)
526                 else:
527                     objName = name
528                 domain.note_object('token', objName, node_id, location=node)
529             subnode.extend(token_xrefs(tokens, productionGroup))
530             node.append(subnode)
531         return [node]
532 
533     def make_old_id(self, token: str) -> str:
534         """Generate old styled node_id for tokens.
535 
536         .. note:: Old Styled node_id was used until Sphinx-3.0.
537                   This will be removed in Sphinx-5.0.
538         """
539         return nodes.make_id('grammar-token-' + token)
540 
541 
542 class TokenXRefRole(XRefRole):
543     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
544                      title: str, target: str) -> Tuple[str, str]:
545         target = target.lstrip('~')  # a title-specific thing
546         if not self.has_explicit_title and title[0] == '~':
547             if ':' in title:
548                 _, title = title.split(':')
549             else:
550                 title = title[1:]
551         return title, target
552 
553 
554 class StandardDomain(Domain):
555     """
556     Domain for all objects that don't fit into another domain or are added
557     via the application interface.
558     """
559 
560     name = 'std'
561     label = 'Default'
562 
563     object_types = {
564         'term': ObjType(_('glossary term'), 'term', searchprio=-1),
565         'token': ObjType(_('grammar token'), 'token', searchprio=-1),
566         'label': ObjType(_('reference label'), 'ref', 'keyword',
567                          searchprio=-1),
568         'envvar': ObjType(_('environment variable'), 'envvar'),
569         'cmdoption': ObjType(_('program option'), 'option'),
570         'doc': ObjType(_('document'), 'doc', searchprio=-1)
571     }  # type: Dict[str, ObjType]
572 
573     directives = {
574         'program': Program,
575         'cmdoption': Cmdoption,  # old name for backwards compatibility
576         'option': Cmdoption,
577         'envvar': EnvVar,
578         'glossary': Glossary,
579         'productionlist': ProductionList,
580     }  # type: Dict[str, Type[Directive]]
581     roles = {
582         'option':  OptionXRefRole(warn_dangling=True),
583         'envvar':  EnvVarXRefRole(),
584         # links to tokens in grammar productions
585         'token':   TokenXRefRole(),
586         # links to terms in glossary
587         'term':    XRefRole(innernodeclass=nodes.inline,
588                             warn_dangling=True),
589         # links to headings or arbitrary labels
590         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,
591                             warn_dangling=True),
592         # links to labels of numbered figures, tables and code-blocks
593         'numref':  XRefRole(lowercase=True,
594                             warn_dangling=True),
595         # links to labels, without a different title
596         'keyword': XRefRole(warn_dangling=True),
597         # links to documents
598         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),
599     }  # type: Dict[str, Union[RoleFunction, XRefRole]]
600 
601     initial_data = {
602         'progoptions': {},      # (program, name) -> docname, labelid
603         'objects': {},          # (type, name) -> docname, labelid
604         'labels': {             # labelname -> docname, labelid, sectionname
605             'genindex': ('genindex', '', _('Index')),
606             'modindex': ('py-modindex', '', _('Module Index')),
607             'search':   ('search', '', _('Search Page')),
608         },
609         'anonlabels': {         # labelname -> docname, labelid
610             'genindex': ('genindex', ''),
611             'modindex': ('py-modindex', ''),
612             'search':   ('search', ''),
613         },
614     }
615 
616     dangling_warnings = {
617         'term': 'term not in glossary: %(target)s',
618         'numref':  'undefined label: %(target)s',
619         'keyword': 'unknown keyword: %(target)s',
620         'doc': 'unknown document: %(target)s',
621         'option': 'unknown option: %(target)s',
622     }
623 
624     enumerable_nodes = {  # node_class -> (figtype, title_getter)
625         nodes.figure: ('figure', None),
626         nodes.table: ('table', None),
627         nodes.container: ('code-block', None),
628     }  # type: Dict[Type[Node], Tuple[str, Callable]]
629 
630     def __init__(self, env: "BuildEnvironment") -> None:
631         super().__init__(env)
632 
633         # set up enumerable nodes
634         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance
635         for node, settings in env.app.registry.enumerable_nodes.items():
636             self.enumerable_nodes[node] = settings
637 
638     def note_hyperlink_target(self, name: str, docname: str, node_id: str,
639                               title: str = '') -> None:
640         """Add a hyperlink target for cross reference.
641 
642         .. warning::
643 
644            This is only for internal use.  Please don't use this from your extension.
645            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to
646            add a hyperlink target to the document.
647 
648            This only adds a hyperlink target to the StandardDomain.  And this does not add a
649            node_id to node.  Therefore, it is very fragile to calling this without
650            understanding hyperlink target framework in both docutils and Sphinx.
651 
652         .. versionadded:: 3.0
653         """
654         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):
655             logger.warning(__('duplicate label %s, other instance in %s'),
656                            name, self.env.doc2path(self.anonlabels[name][0]))
657 
658         self.anonlabels[name] = (docname, node_id)
659         if title:
660             self.labels[name] = (docname, node_id, title)
661 
662     @property
663     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
664         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid
665 
666     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None
667                     ) -> None:
668         """Note a generic object for cross reference.
669 
670         .. versionadded:: 3.0
671         """
672         if (objtype, name) in self.objects:
673             docname = self.objects[objtype, name][0]
674             logger.warning(__('duplicate %s description of %s, other instance in %s'),
675                            objtype, name, docname, location=location)
676         self.objects[objtype, name] = (self.env.docname, labelid)
677 
678     def add_object(self, objtype: str, name: str, docname: str, labelid: str) -> None:
679         warnings.warn('StandardDomain.add_object() is deprecated.',
680                       RemovedInSphinx50Warning, stacklevel=2)
681         self.objects[objtype, name] = (docname, labelid)
682 
683     @property
684     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
685         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid
686 
687     @property
688     def labels(self) -> Dict[str, Tuple[str, str, str]]:
689         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname
690 
691     @property
692     def anonlabels(self) -> Dict[str, Tuple[str, str]]:
693         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid
694 
695     def clear_doc(self, docname: str) -> None:
696         key = None  # type: Any
697         for key, (fn, _l) in list(self.progoptions.items()):
698             if fn == docname:
699                 del self.progoptions[key]
700         for key, (fn, _l) in list(self.objects.items()):
701             if fn == docname:
702                 del self.objects[key]
703         for key, (fn, _l, _l) in list(self.labels.items()):
704             if fn == docname:
705                 del self.labels[key]
706         for key, (fn, _l) in list(self.anonlabels.items()):
707             if fn == docname:
708                 del self.anonlabels[key]
709 
710     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
711         # XXX duplicates?
712         for key, data in otherdata['progoptions'].items():
713             if data[0] in docnames:
714                 self.progoptions[key] = data
715         for key, data in otherdata['objects'].items():
716             if data[0] in docnames:
717                 self.objects[key] = data
718         for key, data in otherdata['labels'].items():
719             if data[0] in docnames:
720                 self.labels[key] = data
721         for key, data in otherdata['anonlabels'].items():
722             if data[0] in docnames:
723                 self.anonlabels[key] = data
724 
725     def process_doc(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
726         for name, explicit in document.nametypes.items():
727             if not explicit:
728                 continue
729             labelid = document.nameids[name]
730             if labelid is None:
731                 continue
732             node = document.ids[labelid]
733             if isinstance(node, nodes.target) and 'refid' in node:
734                 # indirect hyperlink targets
735                 node = document.ids.get(node['refid'])
736                 labelid = node['names'][0]
737             if (node.tagname == 'footnote' or
738                     'refuri' in node or
739                     node.tagname.startswith('desc_')):
740                 # ignore footnote labels, labels automatically generated from a
741                 # link and object descriptions
742                 continue
743             if name in self.labels:
744                 logger.warning(__('duplicate label %s, other instance in %s'),
745                                name, env.doc2path(self.labels[name][0]),
746                                location=node)
747             self.anonlabels[name] = docname, labelid
748             if node.tagname == 'section':
749                 title = cast(nodes.title, node[0])
750                 sectname = clean_astext(title)
751             elif node.tagname == 'rubric':
752                 sectname = clean_astext(node)
753             elif self.is_enumerable_node(node):
754                 sectname = self.get_numfig_title(node)
755                 if not sectname:
756                     continue
757             else:
758                 toctree = next(iter(node.traverse(addnodes.toctree)), None)
759                 if toctree and toctree.get('caption'):
760                     sectname = toctree.get('caption')
761                 else:
762                     # anonymous-only labels
763                     continue
764             self.labels[name] = docname, labelid, sectname
765 
766     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:
767         self.progoptions[program, name] = (docname, labelid)
768 
769     def build_reference_node(self, fromdocname: str, builder: "Builder", docname: str,
770                              labelid: str, sectname: str, rolename: str, **options: Any
771                              ) -> Element:
772         nodeclass = options.pop('nodeclass', nodes.reference)
773         newnode = nodeclass('', '', internal=True, **options)
774         innernode = nodes.inline(sectname, sectname)
775         if innernode.get('classes') is not None:
776             innernode['classes'].append('std')
777             innernode['classes'].append('std-' + rolename)
778         if docname == fromdocname:
779             newnode['refid'] = labelid
780         else:
781             # set more info in contnode; in case the
782             # get_relative_uri call raises NoUri,
783             # the builder will then have to resolve these
784             contnode = pending_xref('')
785             contnode['refdocname'] = docname
786             contnode['refsectname'] = sectname
787             newnode['refuri'] = builder.get_relative_uri(
788                 fromdocname, docname)
789             if labelid:
790                 newnode['refuri'] += '#' + labelid
791         newnode.append(innernode)
792         return newnode
793 
794     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
795                      typ: str, target: str, node: pending_xref, contnode: Element) -> Element:
796         if typ == 'ref':
797             resolver = self._resolve_ref_xref
798         elif typ == 'numref':
799             resolver = self._resolve_numref_xref
800         elif typ == 'keyword':
801             resolver = self._resolve_keyword_xref
802         elif typ == 'doc':
803             resolver = self._resolve_doc_xref
804         elif typ == 'option':
805             resolver = self._resolve_option_xref
806         elif typ == 'citation':
807             warnings.warn('pending_xref(domain=std, type=citation) is deprecated: %r' % node,
808                           RemovedInSphinx40Warning, stacklevel=2)
809             domain = env.get_domain('citation')
810             return domain.resolve_xref(env, fromdocname, builder, typ, target, node, contnode)
811         elif typ == 'term':
812             resolver = self._resolve_term_xref
813         else:
814             resolver = self._resolve_obj_xref
815 
816         return resolver(env, fromdocname, builder, typ, target, node, contnode)
817 
818     def _resolve_ref_xref(self, env: "BuildEnvironment", fromdocname: str,
819                           builder: "Builder", typ: str, target: str, node: pending_xref,
820                           contnode: Element) -> Element:
821         if node['refexplicit']:
822             # reference to anonymous label; the reference uses
823             # the supplied link caption
824             docname, labelid = self.anonlabels.get(target, ('', ''))
825             sectname = node.astext()
826         else:
827             # reference to named label; the final node will
828             # contain the section name after the label
829             docname, labelid, sectname = self.labels.get(target, ('', '', ''))
830         if not docname:
831             return None
832 
833         return self.build_reference_node(fromdocname, builder,
834                                          docname, labelid, sectname, 'ref')
835 
836     def _resolve_numref_xref(self, env: "BuildEnvironment", fromdocname: str,
837                              builder: "Builder", typ: str, target: str,
838                              node: pending_xref, contnode: Element) -> Element:
839         if target in self.labels:
840             docname, labelid, figname = self.labels.get(target, ('', '', ''))
841         else:
842             docname, labelid = self.anonlabels.get(target, ('', ''))
843             figname = None
844 
845         if not docname:
846             return None
847 
848         target_node = env.get_doctree(docname).ids.get(labelid)
849         figtype = self.get_enumerable_node_type(target_node)
850         if figtype is None:
851             return None
852 
853         if figtype != 'section' and env.config.numfig is False:
854             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)
855             return contnode
856 
857         try:
858             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)
859             if fignumber is None:
860                 return contnode
861         except ValueError:
862             logger.warning(__("Failed to create a cross reference. Any number is not "
863                               "assigned: %s"),
864                            labelid, location=node)
865             return contnode
866 
867         try:
868             if node['refexplicit']:
869                 title = contnode.astext()
870             else:
871                 title = env.config.numfig_format.get(figtype, '')
872 
873             if figname is None and '{name}' in title:
874                 logger.warning(__('the link has no caption: %s'), title, location=node)
875                 return contnode
876             else:
877                 fignum = '.'.join(map(str, fignumber))
878                 if '{name}' in title or 'number' in title:
879                     # new style format (cf. "Fig.{number}")
880                     if figname:
881                         newtitle = title.format(name=figname, number=fignum)
882                     else:
883                         newtitle = title.format(number=fignum)
884                 else:
885                     # old style format (cf. "Fig.%s")
886                     newtitle = title % fignum
887         except KeyError as exc:
888             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)
889             return contnode
890         except TypeError:
891             logger.warning(__('invalid numfig_format: %s'), title, location=node)
892             return contnode
893 
894         return self.build_reference_node(fromdocname, builder,
895                                          docname, labelid, newtitle, 'numref',
896                                          nodeclass=addnodes.number_reference,
897                                          title=title)
898 
899     def _resolve_keyword_xref(self, env: "BuildEnvironment", fromdocname: str,
900                               builder: "Builder", typ: str, target: str,
901                               node: pending_xref, contnode: Element) -> Element:
902         # keywords are oddballs: they are referenced by named labels
903         docname, labelid, _ = self.labels.get(target, ('', '', ''))
904         if not docname:
905             return None
906         return make_refnode(builder, fromdocname, docname,
907                             labelid, contnode)
908 
909     def _resolve_doc_xref(self, env: "BuildEnvironment", fromdocname: str,
910                           builder: "Builder", typ: str, target: str,
911                           node: pending_xref, contnode: Element) -> Element:
912         # directly reference to document by source name; can be absolute or relative
913         refdoc = node.get('refdoc', fromdocname)
914         docname = docname_join(refdoc, node['reftarget'])
915         if docname not in env.all_docs:
916             return None
917         else:
918             if node['refexplicit']:
919                 # reference with explicit title
920                 caption = node.astext()
921             else:
922                 caption = clean_astext(env.titles[docname])
923             innernode = nodes.inline(caption, caption, classes=['doc'])
924             return make_refnode(builder, fromdocname, docname, None, innernode)
925 
926     def _resolve_option_xref(self, env: "BuildEnvironment", fromdocname: str,
927                              builder: "Builder", typ: str, target: str,
928                              node: pending_xref, contnode: Element) -> Element:
929         progname = node.get('std:program')
930         target = target.strip()
931         docname, labelid = self.progoptions.get((progname, target), ('', ''))
932         if not docname:
933             commands = []
934             while ws_re.search(target):
935                 subcommand, target = ws_re.split(target, 1)
936                 commands.append(subcommand)
937                 progname = "-".join(commands)
938 
939                 docname, labelid = self.progoptions.get((progname, target), ('', ''))
940                 if docname:
941                     break
942             else:
943                 return None
944 
945         return make_refnode(builder, fromdocname, docname,
946                             labelid, contnode)
947 
948     def _resolve_term_xref(self, env: "BuildEnvironment", fromdocname: str,
949                            builder: "Builder", typ: str, target: str,
950                            node: pending_xref, contnode: Element) -> Element:
951         result = self._resolve_obj_xref(env, fromdocname, builder, typ,
952                                         target, node, contnode)
953         if result:
954             return result
955         else:
956             for objtype, term in self.objects:
957                 if objtype == 'term' and term.lower() == target.lower():
958                     docname, labelid = self.objects[objtype, term]
959                     logger.warning(__('term %s not found in case sensitive match.'
960                                       'made a reference to %s instead.'),
961                                    target, term, location=node, type='ref', subtype='term')
962                     break
963             else:
964                 docname, labelid = '', ''
965             if not docname:
966                 return None
967             return make_refnode(builder, fromdocname, docname,
968                                 labelid, contnode)
969 
970     def _resolve_obj_xref(self, env: "BuildEnvironment", fromdocname: str,
971                           builder: "Builder", typ: str, target: str,
972                           node: pending_xref, contnode: Element) -> Element:
973         objtypes = self.objtypes_for_role(typ) or []
974         for objtype in objtypes:
975             if (objtype, target) in self.objects:
976                 docname, labelid = self.objects[objtype, target]
977                 break
978         else:
979             docname, labelid = '', ''
980         if not docname:
981             return None
982         return make_refnode(builder, fromdocname, docname,
983                             labelid, contnode)
984 
985     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str,
986                          builder: "Builder", target: str, node: pending_xref,
987                          contnode: Element) -> List[Tuple[str, Element]]:
988         results = []  # type: List[Tuple[str, Element]]
989         ltarget = target.lower()  # :ref: lowercases its target automatically
990         for role in ('ref', 'option'):  # do not try "keyword"
991             res = self.resolve_xref(env, fromdocname, builder, role,
992                                     ltarget if role == 'ref' else target,
993                                     node, contnode)
994             if res:
995                 results.append(('std:' + role, res))
996         # all others
997         for objtype in self.object_types:
998             key = (objtype, target)
999             if objtype == 'term':
1000                 key = (objtype, ltarget)
1001             if key in self.objects:
1002                 docname, labelid = self.objects[key]
1003                 results.append(('std:' + self.role_for_objtype(objtype),
1004                                 make_refnode(builder, fromdocname, docname,
1005                                              labelid, contnode)))
1006         return results
1007 
1008     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1009         # handle the special 'doc' reference here
1010         for doc in self.env.all_docs:
1011             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)
1012         for (prog, option), info in self.progoptions.items():
1013             if prog:
1014                 fullname = ".".join([prog, option])
1015                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)
1016             else:
1017                 yield (option, option, 'cmdoption', info[0], info[1], 1)
1018         for (type, name), info in self.objects.items():
1019             yield (name, name, type, info[0], info[1],
1020                    self.object_types[type].attrs['searchprio'])
1021         for name, (docname, labelid, sectionname) in self.labels.items():
1022             yield (name, sectionname, 'label', docname, labelid, -1)
1023         # add anonymous-only labels as well
1024         non_anon_labels = set(self.labels)
1025         for name, (docname, labelid) in self.anonlabels.items():
1026             if name not in non_anon_labels:
1027                 yield (name, name, 'label', docname, labelid, -1)
1028 
1029     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
1030         # never prepend "Default"
1031         return type.lname
1032 
1033     def is_enumerable_node(self, node: Node) -> bool:
1034         return node.__class__ in self.enumerable_nodes
1035 
1036     def get_numfig_title(self, node: Node) -> str:
1037         """Get the title of enumerable nodes to refer them using its title"""
1038         if self.is_enumerable_node(node):
1039             elem = cast(Element, node)
1040             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))
1041             if title_getter:
1042                 return title_getter(elem)
1043             else:
1044                 for subnode in elem:
1045                     if isinstance(subnode, (nodes.caption, nodes.title)):
1046                         return clean_astext(subnode)
1047 
1048         return None
1049 
1050     def get_enumerable_node_type(self, node: Node) -> str:
1051         """Get type of enumerable nodes."""
1052         def has_child(node: Element, cls: "Type") -> bool:
1053             return any(isinstance(child, cls) for child in node)
1054 
1055         if isinstance(node, nodes.section):
1056             return 'section'
1057         elif (isinstance(node, nodes.container) and
1058               'literal_block' in node and
1059               has_child(node, nodes.literal_block)):
1060             # given node is a code-block having caption
1061             return 'code-block'
1062         else:
1063             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))
1064             return figtype
1065 
1066     def get_fignumber(self, env: "BuildEnvironment", builder: "Builder",
1067                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:
1068         if figtype == 'section':
1069             if builder.name == 'latex':
1070                 return tuple()
1071             elif docname not in env.toc_secnumbers:
1072                 raise ValueError  # no number assigned
1073             else:
1074                 anchorname = '#' + target_node['ids'][0]
1075                 if anchorname not in env.toc_secnumbers[docname]:
1076                     # try first heading which has no anchor
1077                     return env.toc_secnumbers[docname].get('')
1078                 else:
1079                     return env.toc_secnumbers[docname].get(anchorname)
1080         else:
1081             try:
1082                 figure_id = target_node['ids'][0]
1083                 return env.toc_fignumbers[docname][figtype][figure_id]
1084             except (KeyError, IndexError) as exc:
1085                 # target_node is found, but fignumber is not assigned.
1086                 # Maybe it is defined in orphaned document.
1087                 raise ValueError from exc
1088 
1089     def get_full_qualified_name(self, node: Element) -> str:
1090         if node.get('reftype') == 'option':
1091             progname = node.get('std:program')
1092             command = ws_re.split(node.get('reftarget'))
1093             if progname:
1094                 command.insert(0, progname)
1095             option = command.pop()
1096             if command:
1097                 return '.'.join(['-'.join(command), option])
1098             else:
1099                 return None
1100         else:
1101             return None
1102 
1103     def note_citations(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1104         warnings.warn('StandardDomain.note_citations() is deprecated.',
1105                       RemovedInSphinx40Warning, stacklevel=2)
1106 
1107     def note_citation_refs(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1108         warnings.warn('StandardDomain.note_citation_refs() is deprecated.',
1109                       RemovedInSphinx40Warning, stacklevel=2)
1110 
1111     def note_labels(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
1112         warnings.warn('StandardDomain.note_labels() is deprecated.',
1113                       RemovedInSphinx40Warning, stacklevel=2)
1114 
1115 
1116 def warn_missing_reference(app: "Sphinx", domain: Domain, node: pending_xref) -> bool:
1117     if (domain and domain.name != 'std') or node['reftype'] != 'ref':
1118         return None
1119     else:
1120         target = node['reftarget']
1121         if target not in domain.anonlabels:  # type: ignore
1122             msg = __('undefined label: %s')
1123         else:
1124             msg = __('Failed to create a cross reference. A title or caption not found: %s')
1125 
1126         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])
1127         return True
1128 
1129 
1130 def setup(app: "Sphinx") -> Dict[str, Any]:
1131     app.add_domain(StandardDomain)
1132     app.connect('warn-missing-reference', warn_missing_reference)
1133 
1134     return {
1135         'version': 'builtin',
1136         'env_version': 1,
1137         'parallel_read_safe': True,
1138         'parallel_write_safe': True,
1139     }

</code><intended_behavior>As this file likely includes directive processing logic for the standard domain, it should be ensured that the `:dedent:` option for `code-block` and `literalinclude` directives automatically removes common leading whitespace from all lines in the absence of an explicit dedent value. The change should maintain backward compatibility, allowing users to still specify a dedent value when desired.</intended_behavior>, <file>sphinx/util/docstrings.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docstrings
3     ~~~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities for docstring processing.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import sys
13 import warnings
14 from typing import Dict, List
15 
16 from docutils.parsers.rst.states import Body
17 
18 from sphinx.deprecation import RemovedInSphinx50Warning
19 
20 field_list_item_re = re.compile(Body.patterns['field_marker'])
21 
22 
23 def extract_metadata(s: str) -> Dict[str, str]:
24     """Extract metadata from docstring."""
25     in_other_element = False
26     metadata = {}  # type: Dict[str, str]
27 
28     if not s:
29         return metadata
30 
31     for line in prepare_docstring(s):
32         if line.strip() == '':
33             in_other_element = False
34         else:
35             matched = field_list_item_re.match(line)
36             if matched and not in_other_element:
37                 field_name = matched.group()[1:].split(':', 1)[0]
38                 if field_name.startswith('meta '):
39                     name = field_name[5:].strip()
40                     metadata[name] = line[matched.end():].strip()
41             else:
42                 in_other_element = True
43 
44     return metadata
45 
46 
47 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:
48     """Convert a docstring into lines of parseable reST.  Remove common leading
49     indentation, where the indentation of a given number of lines (usually just
50     one) is ignored.
51 
52     Return the docstring as a list of lines usable for inserting into a docutils
53     ViewList (used as argument of nested_parse().)  An empty line is added to
54     act as a separator between this docstring and following content.
55     """
56     if ignore is None:
57         ignore = 1
58     else:
59         warnings.warn("The 'ignore' argument to prepare_docstring() is deprecated.",
60                       RemovedInSphinx50Warning, stacklevel=2)
61 
62     lines = s.expandtabs(tabsize).splitlines()
63     # Find minimum indentation of any non-blank lines after ignored lines.
64     margin = sys.maxsize
65     for line in lines[ignore:]:
66         content = len(line.lstrip())
67         if content:
68             indent = len(line) - content
69             margin = min(margin, indent)
70     # Remove indentation from ignored lines.
71     for i in range(ignore):
72         if i < len(lines):
73             lines[i] = lines[i].lstrip()
74     if margin < sys.maxsize:
75         for i in range(ignore, len(lines)):
76             lines[i] = lines[i][margin:]
77     # Remove any leading blank lines.
78     while lines and not lines[0]:
79         lines.pop(0)
80     # make sure there is an empty line at the end
81     if lines and lines[-1]:
82         lines.append('')
83     return lines
84 
85 
86 def prepare_commentdoc(s: str) -> List[str]:
87     """Extract documentation comment lines (starting with #:) and return them
88     as a list of lines.  Returns an empty list if there is no documentation.
89     """
90     result = []
91     lines = [line.strip() for line in s.expandtabs().splitlines()]
92     for line in lines:
93         if line.startswith('#:'):
94             line = line[2:]
95             # the first space after the comment is ignored
96             if line and line[0] == ' ':
97                 line = line[1:]
98             result.append(line)
99     if result and result[-1]:
100         result.append('')
101     return result

</code><intended_behavior>This file is probably responsible for processing docstring content. Enhancements should be made to apply the automatic dedentation logic for code blocks and literal includes within docstrings, applying a universal dedent if no `:dedent:` value is specified. This modifies the docstring handling to better format embedded code snippets.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,
18                     TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,
26                                 RemovedInSphinx60Warning)
27 from sphinx.environment import BuildEnvironment
28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
29                                          import_object)
30 from sphinx.ext.autodoc.mock import ismock, mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect, logging
34 from sphinx.util.docstrings import extract_metadata, prepare_docstring
35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
36                                  stringify_signature)
37 from sphinx.util.typing import get_type_hints, restify
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43 
44     from sphinx.ext.autodoc.directive import DocumenterBridge
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # This type isn't exposed directly in any modules, but can be found
51 # here in most Python versions
52 MethodDescriptorType = type(type.__subclasses__)
53 
54 
55 #: extended signature RE: with explicit module name separated by ::
56 py_ext_sig_re = re.compile(
57     r'''^ ([\w.]+::)?            # explicit module name
58           ([\w.]+\.)?            # module and/or class name(s)
59           (\w+)  \s*             # thing name
60           (?: \((.*)\)           # optional: arguments
61            (?:\s* -> \s* (.*))?  #           return annotation
62           )? $                   # and nothing more
63           ''', re.VERBOSE)
64 special_member_re = re.compile(r'^__\S+__$')
65 
66 
67 def identity(x: Any) -> Any:
68     return x
69 
70 
71 class _All:
72     """A special value for :*-members: that matches to any member."""
73 
74     def __contains__(self, item: Any) -> bool:
75         return True
76 
77 
78 class _Empty:
79     """A special value for :exclude-members: that never matches to any member."""
80 
81     def __contains__(self, item: Any) -> bool:
82         return False
83 
84 
85 ALL = _All()
86 EMPTY = _Empty()
87 UNINITIALIZED_ATTR = object()
88 INSTANCEATTR = object()
89 SLOTSATTR = object()
90 
91 
92 def members_option(arg: Any) -> Union[object, List[str]]:
93     """Used to convert the :members: option to auto directives."""
94     if arg in (None, True):
95         return ALL
96     elif arg is False:
97         return None
98     else:
99         return [x.strip() for x in arg.split(',') if x.strip()]
100 
101 
102 def members_set_option(arg: Any) -> Union[object, Set[str]]:
103     """Used to convert the :members: option to auto directives."""
104     warnings.warn("members_set_option() is deprecated.",
105                   RemovedInSphinx50Warning, stacklevel=2)
106     if arg is None:
107         return ALL
108     return {x.strip() for x in arg.split(',') if x.strip()}
109 
110 
111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
112     """Used to convert the :exclude-members: option."""
113     if arg in (None, True):
114         return EMPTY
115     return {x.strip() for x in arg.split(',') if x.strip()}
116 
117 
118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
119     """Used to convert the :members: option to auto directives."""
120     if arg in (None, True):
121         return 'object'
122     else:
123         return arg
124 
125 
126 def member_order_option(arg: Any) -> Optional[str]:
127     """Used to convert the :members: option to auto directives."""
128     if arg in (None, True):
129         return None
130     elif arg in ('alphabetical', 'bysource', 'groupwise'):
131         return arg
132     else:
133         raise ValueError(__('invalid value for member-order option: %s') % arg)
134 
135 
136 SUPPRESS = object()
137 
138 
139 def annotation_option(arg: Any) -> Any:
140     if arg in (None, True):
141         # suppress showing the representation of the object
142         return SUPPRESS
143     else:
144         return arg
145 
146 
147 def bool_option(arg: Any) -> bool:
148     """Used to convert flag options to auto directives.  (Instead of
149     directives.flag(), which returns None).
150     """
151     return True
152 
153 
154 def merge_special_members_option(options: Dict) -> None:
155     """Merge :special-members: option to :members: option."""
156     warnings.warn("merge_special_members_option() is deprecated.",
157                   RemovedInSphinx50Warning, stacklevel=2)
158     if 'special-members' in options and options['special-members'] is not ALL:
159         if options.get('members') is ALL:
160             pass
161         elif options.get('members'):
162             for member in options['special-members']:
163                 if member not in options['members']:
164                     options['members'].append(member)
165         else:
166             options['members'] = options['special-members']
167 
168 
169 def merge_members_option(options: Dict) -> None:
170     """Merge :*-members: option to the :members: option."""
171     if options.get('members') is ALL:
172         # merging is not needed when members: ALL
173         return
174 
175     members = options.setdefault('members', [])
176     for key in {'private-members', 'special-members'}:
177         if key in options and options[key] not in (ALL, None):
178             for member in options[key]:
179                 if member not in members:
180                     members.append(member)
181 
182 
183 # Some useful event listener factories for autodoc-process-docstring.
184 
185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
186     """Return a listener that removes the first *pre* and last *post*
187     lines of every docstring.  If *what* is a sequence of strings,
188     only docstrings of a type in *what* will be processed.
189 
190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
191 
192        from sphinx.ext.autodoc import cut_lines
193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
194 
195     This can (and should) be used in place of :confval:`automodule_skip_lines`.
196     """
197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
198                 ) -> None:
199         if what and what_ not in what:
200             return
201         del lines[:pre]
202         if post:
203             # remove one trailing blank line.
204             if lines and not lines[-1]:
205                 lines.pop(-1)
206             del lines[-post:]
207         # make sure there is a blank line at the end
208         if lines and lines[-1]:
209             lines.append('')
210     return process
211 
212 
213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
214             exclude: bool = False) -> Callable:
215     """Return a listener that either keeps, or if *exclude* is True excludes,
216     lines between lines that match the *marker* regular expression.  If no line
217     matches, the resulting docstring would be empty, so no change will be made
218     unless *keepempty* is true.
219 
220     If *what* is a sequence of strings, only docstrings of a type in *what* will
221     be processed.
222     """
223     marker_re = re.compile(marker)
224 
225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
226                 ) -> None:
227         if what and what_ not in what:
228             return
229         deleted = 0
230         delete = not exclude
231         orig_lines = lines[:]
232         for i, line in enumerate(orig_lines):
233             if delete:
234                 lines.pop(i - deleted)
235                 deleted += 1
236             if marker_re.match(line):
237                 delete = not delete
238                 if delete:
239                     lines.pop(i - deleted)
240                     deleted += 1
241         if not lines and not keepempty:
242             lines[:] = orig_lines
243         # make sure there is a blank line at the end
244         if lines and lines[-1]:
245             lines.append('')
246     return process
247 
248 
249 # This class is used only in ``sphinx.ext.autodoc.directive``,
250 # But we define this class here to keep compatibility (see #4538)
251 class Options(dict):
252     """A dict/attribute hybrid that returns None on nonexisting keys."""
253     def __getattr__(self, name: str) -> Any:
254         try:
255             return self[name.replace('_', '-')]
256         except KeyError:
257             return None
258 
259 
260 class ObjectMember(tuple):
261     """A member of object.
262 
263     This is used for the result of `Documenter.get_object_members()` to
264     represent each member of the object.
265 
266     .. Note::
267 
268        An instance of this class behaves as a tuple of (name, object)
269        for compatibility to old Sphinx.  The behavior will be dropped
270        in the future.  Therefore extensions should not use the tuple
271        interface.
272     """
273 
274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
275         return super().__new__(cls, (name, obj))  # type: ignore
276 
277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
278                  class_: Any = None, skipped: bool = False) -> None:
279         self.__name__ = name
280         self.object = obj
281         self.docstring = docstring
282         self.skipped = skipped
283         self.class_ = class_
284 
285 
286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
287 
288 
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 return True
426             except ImportError as exc:
427                 if raiseerror:
428                     raise
429                 else:
430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
431                     self.env.note_reread()
432                     return False
433 
434     def get_real_modname(self) -> str:
435         """Get the real module name of an object to document.
436 
437         It can differ from the name of the module through which the object was
438         imported.
439         """
440         return self.get_attr(self.object, '__module__', None) or self.modname
441 
442     def check_module(self) -> bool:
443         """Check if *self.object* is really defined in the module given by
444         *self.modname*.
445         """
446         if self.options.imported_members:
447             return True
448 
449         subject = inspect.unpartial(self.object)
450         modname = self.get_attr(subject, '__module__', None)
451         if modname and modname != self.modname:
452             return False
453         return True
454 
455     def format_args(self, **kwargs: Any) -> str:
456         """Format the argument signature of *self.object*.
457 
458         Should return None if the object does not have a signature.
459         """
460         return None
461 
462     def format_name(self) -> str:
463         """Format the name of *self.object*.
464 
465         This normally should be something that can be parsed by the generated
466         directive, but doesn't need to be (Sphinx will display it unparsed
467         then).
468         """
469         # normally the name doesn't contain the module (except for module
470         # directives of course)
471         return '.'.join(self.objpath) or self.modname
472 
473     def _call_format_args(self, **kwargs: Any) -> str:
474         if kwargs:
475             try:
476                 return self.format_args(**kwargs)
477             except TypeError:
478                 # avoid chaining exceptions, by putting nothing here
479                 pass
480 
481         # retry without arguments for old documenters
482         return self.format_args()
483 
484     def format_signature(self, **kwargs: Any) -> str:
485         """Format the signature (arguments and return annotation) of the object.
486 
487         Let the user process it via the ``autodoc-process-signature`` event.
488         """
489         if self.args is not None:
490             # signature given explicitly
491             args = "(%s)" % self.args
492             retann = self.retann
493         else:
494             # try to introspect the signature
495             try:
496                 retann = None
497                 args = self._call_format_args(**kwargs)
498                 if args:
499                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
500                     if matched:
501                         args = matched.group(1)
502                         retann = matched.group(2)
503             except Exception as exc:
504                 logger.warning(__('error while formatting arguments for %s: %s'),
505                                self.fullname, exc, type='autodoc')
506                 args = None
507 
508         result = self.env.events.emit_firstresult('autodoc-process-signature',
509                                                   self.objtype, self.fullname,
510                                                   self.object, self.options, args, retann)
511         if result:
512             args, retann = result
513 
514         if args is not None:
515             return args + ((' -> %s' % retann) if retann else '')
516         else:
517             return ''
518 
519     def add_directive_header(self, sig: str) -> None:
520         """Add the directive header and options to the generated content."""
521         domain = getattr(self, 'domain', 'py')
522         directive = getattr(self, 'directivetype', self.objtype)
523         name = self.format_name()
524         sourcename = self.get_sourcename()
525 
526         # one signature per line, indented by column
527         prefix = '.. %s:%s:: ' % (domain, directive)
528         for i, sig_line in enumerate(sig.split("\n")):
529             self.add_line('%s%s%s' % (prefix, name, sig_line),
530                           sourcename)
531             if i == 0:
532                 prefix = " " * len(prefix)
533 
534         if self.options.noindex:
535             self.add_line('   :noindex:', sourcename)
536         if self.objpath:
537             # Be explicit about the module, this is necessary since .. class::
538             # etc. don't support a prepended module name
539             self.add_line('   :module: %s' % self.modname, sourcename)
540 
541     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
542         """Decode and return lines of the docstring(s) for the object.
543 
544         When it returns None value, autodoc-process-docstring will not be called for this
545         object.
546         """
547         if encoding is not None:
548             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
549                           % self.__class__.__name__,
550                           RemovedInSphinx40Warning, stacklevel=2)
551         if ignore is not None:
552             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
553                           % self.__class__.__name__,
554                           RemovedInSphinx50Warning, stacklevel=2)
555         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
556                            self.parent, self.object_name)
557         if docstring:
558             tab_width = self.directive.state.document.settings.tab_width
559             return [prepare_docstring(docstring, ignore, tab_width)]
560         return []
561 
562     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
563         """Let the user process the docstrings before adding them."""
564         for docstringlines in docstrings:
565             if self.env.app:
566                 # let extensions preprocess docstrings
567                 self.env.app.emit('autodoc-process-docstring',
568                                   self.objtype, self.fullname, self.object,
569                                   self.options, docstringlines)
570 
571                 if docstringlines and docstringlines[-1] != '':
572                     # append a blank line to the end of the docstring
573                     docstringlines.append('')
574 
575             yield from docstringlines
576 
577     def get_sourcename(self) -> str:
578         if (getattr(self.object, '__module__', None) and
579                 getattr(self.object, '__qualname__', None)):
580             # Get the correct location of docstring from self.object
581             # to support inherited methods
582             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
583         else:
584             fullname = self.fullname
585 
586         if self.analyzer:
587             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
588         else:
589             return 'docstring of %s' % fullname
590 
591     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
592                     ) -> None:
593         """Add content from docstrings, attribute documentation and user."""
594         if no_docstring:
595             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
596                           % self.__class__.__name__,
597                           RemovedInSphinx50Warning, stacklevel=2)
598 
599         # set sourcename and add content from attribute documentation
600         sourcename = self.get_sourcename()
601         if self.analyzer:
602             attr_docs = self.analyzer.find_attr_docs()
603             if self.objpath:
604                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
605                 if key in attr_docs:
606                     no_docstring = True
607                     # make a copy of docstring for attributes to avoid cache
608                     # the change of autodoc-process-docstring event.
609                     docstrings = [list(attr_docs[key])]
610 
611                     for i, line in enumerate(self.process_doc(docstrings)):
612                         self.add_line(line, sourcename, i)
613 
614         # add content from docstrings
615         if not no_docstring:
616             docstrings = self.get_doc()
617             if docstrings is None:
618                 # Do not call autodoc-process-docstring on get_doc() returns None.
619                 pass
620             else:
621                 if not docstrings:
622                     # append at least a dummy docstring, so that the event
623                     # autodoc-process-docstring is fired and can add some
624                     # content if desired
625                     docstrings.append([])
626                 for i, line in enumerate(self.process_doc(docstrings)):
627                     self.add_line(line, sourcename, i)
628 
629         # add additional content (e.g. from document), if present
630         if more_content:
631             for line, src in zip(more_content.data, more_content.items):
632                 self.add_line(line, src[0], src[1])
633 
634     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
635         """Return `(members_check_module, members)` where `members` is a
636         list of `(membername, member)` pairs of the members of *self.object*.
637 
638         If *want_all* is True, return all members.  Else, only return those
639         members given by *self.options.members* (which may also be none).
640         """
641         warnings.warn('The implementation of Documenter.get_object_members() will be '
642                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
643         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
644         if not want_all:
645             if not self.options.members:
646                 return False, []  # type: ignore
647             # specific members given
648             selected = []
649             for name in self.options.members:  # type: str
650                 if name in members:
651                     selected.append((name, members[name].value))
652                 else:
653                     logger.warning(__('missing attribute %s in object %s') %
654                                    (name, self.fullname), type='autodoc')
655             return False, selected
656         elif self.options.inherited_members:
657             return False, [(m.name, m.value) for m in members.values()]
658         else:
659             return False, [(m.name, m.value) for m in members.values()
660                            if m.directly_defined]
661 
662     def filter_members(self, members: ObjectMembers, want_all: bool
663                        ) -> List[Tuple[str, Any, bool]]:
664         """Filter the given member list.
665 
666         Members are skipped if
667 
668         - they are private (except if given explicitly or the private-members
669           option is set)
670         - they are special methods (except if given explicitly or the
671           special-members option is set)
672         - they are undocumented (except if the undoc-members option is set)
673 
674         The user can override the skipping decision by connecting to the
675         ``autodoc-skip-member`` event.
676         """
677         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
678             if inspect.isclass(self.object):
679                 for cls in self.object.__mro__:
680                     if cls.__name__ == self.options.inherited_members and cls != self.object:
681                         # given member is a member of specified *super class*
682                         return True
683                     elif name in cls.__dict__:
684                         return False
685                     elif name in self.get_attr(cls, '__annotations__', {}):
686                         return False
687                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
688                         return False
689 
690             return False
691 
692         ret = []
693 
694         # search for members in source code too
695         namespace = '.'.join(self.objpath)  # will be empty for modules
696 
697         if self.analyzer:
698             attr_docs = self.analyzer.find_attr_docs()
699         else:
700             attr_docs = {}
701 
702         # process members and determine which to skip
703         for obj in members:
704             membername, member = obj
705             # if isattr is True, the member is documented as an attribute
706             if member is INSTANCEATTR:
707                 isattr = True
708             else:
709                 isattr = False
710 
711             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
712                          self.parent, self.object_name)
713             if not isinstance(doc, str):
714                 # Ignore non-string __doc__
715                 doc = None
716 
717             # if the member __doc__ is the same as self's __doc__, it's just
718             # inherited and therefore not the member's doc
719             cls = self.get_attr(member, '__class__', None)
720             if cls:
721                 cls_doc = self.get_attr(cls, '__doc__', None)
722                 if cls_doc == doc:
723                     doc = None
724 
725             if isinstance(obj, ObjectMember) and obj.docstring:
726                 # hack for ClassDocumenter to inject docstring via ObjectMember
727                 doc = obj.docstring
728 
729             has_doc = bool(doc)
730 
731             metadata = extract_metadata(doc)
732             if 'private' in metadata:
733                 # consider a member private if docstring has "private" metadata
734                 isprivate = True
735             elif 'public' in metadata:
736                 # consider a member public if docstring has "public" metadata
737                 isprivate = False
738             else:
739                 isprivate = membername.startswith('_')
740 
741             keep = False
742             if ismock(member):
743                 # mocked module or object
744                 pass
745             elif self.options.exclude_members and membername in self.options.exclude_members:
746                 # remove members given by exclude-members
747                 keep = False
748             elif want_all and special_member_re.match(membername):
749                 # special __methods__
750                 if self.options.special_members and membername in self.options.special_members:
751                     if membername == '__doc__':
752                         keep = False
753                     elif is_filtered_inherited_member(membername, obj):
754                         keep = False
755                     else:
756                         keep = has_doc or self.options.undoc_members
757                 else:
758                     keep = False
759             elif (namespace, membername) in attr_docs:
760                 if want_all and isprivate:
761                     if self.options.private_members is None:
762                         keep = False
763                     else:
764                         keep = membername in self.options.private_members
765                 else:
766                     # keep documented attributes
767                     keep = True
768                 isattr = True
769             elif want_all and isprivate:
770                 if has_doc or self.options.undoc_members:
771                     if self.options.private_members is None:
772                         keep = False
773                     elif is_filtered_inherited_member(membername, obj):
774                         keep = False
775                     else:
776                         keep = membername in self.options.private_members
777                 else:
778                     keep = False
779             else:
780                 if (self.options.members is ALL and
781                         is_filtered_inherited_member(membername, obj)):
782                     keep = False
783                 else:
784                     # ignore undocumented members if :undoc-members: is not given
785                     keep = has_doc or self.options.undoc_members
786 
787             if isinstance(obj, ObjectMember) and obj.skipped:
788                 # forcedly skipped member (ex. a module attribute not defined in __all__)
789                 keep = False
790 
791             # give the user a chance to decide whether this member
792             # should be skipped
793             if self.env.app:
794                 # let extensions preprocess docstrings
795                 try:
796                     skip_user = self.env.app.emit_firstresult(
797                         'autodoc-skip-member', self.objtype, membername, member,
798                         not keep, self.options)
799                     if skip_user is not None:
800                         keep = not skip_user
801                 except Exception as exc:
802                     logger.warning(__('autodoc: failed to determine %r to be documented, '
803                                       'the following exception was raised:\n%s'),
804                                    member, exc, type='autodoc')
805                     keep = False
806 
807             if keep:
808                 ret.append((membername, member, isattr))
809 
810         return ret
811 
812     def document_members(self, all_members: bool = False) -> None:
813         """Generate reST for member documentation.
814 
815         If *all_members* is True, do all members, else those given by
816         *self.options.members*.
817         """
818         # set current namespace for finding members
819         self.env.temp_data['autodoc:module'] = self.modname
820         if self.objpath:
821             self.env.temp_data['autodoc:class'] = self.objpath[0]
822 
823         want_all = all_members or self.options.inherited_members or \
824             self.options.members is ALL
825         # find out which members are documentable
826         members_check_module, members = self.get_object_members(want_all)
827 
828         # document non-skipped members
829         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
830         for (mname, member, isattr) in self.filter_members(members, want_all):
831             classes = [cls for cls in self.documenters.values()
832                        if cls.can_document_member(member, mname, isattr, self)]
833             if not classes:
834                 # don't know how to document this member
835                 continue
836             # prefer the documenter with the highest priority
837             classes.sort(key=lambda cls: cls.priority)
838             # give explicitly separated module name, so that members
839             # of inner classes can be documented
840             full_mname = self.modname + '::' + \
841                 '.'.join(self.objpath + [mname])
842             documenter = classes[-1](self.directive, full_mname, self.indent)
843             memberdocumenters.append((documenter, isattr))
844 
845         member_order = self.options.member_order or self.config.autodoc_member_order
846         memberdocumenters = self.sort_members(memberdocumenters, member_order)
847 
848         for documenter, isattr in memberdocumenters:
849             documenter.generate(
850                 all_members=True, real_modname=self.real_modname,
851                 check_module=members_check_module and not isattr)
852 
853         # reset current objects
854         self.env.temp_data['autodoc:module'] = None
855         self.env.temp_data['autodoc:class'] = None
856 
857     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
858                      order: str) -> List[Tuple["Documenter", bool]]:
859         """Sort the given member list."""
860         if order == 'groupwise':
861             # sort by group; alphabetically within groups
862             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
863         elif order == 'bysource':
864             if self.analyzer:
865                 # sort by source order, by virtue of the module analyzer
866                 tagorder = self.analyzer.tagorder
867 
868                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
869                     fullname = entry[0].name.split('::')[1]
870                     return tagorder.get(fullname, len(tagorder))
871                 documenters.sort(key=keyfunc)
872             else:
873                 # Assume that member discovery order matches source order.
874                 # This is a reasonable assumption in Python 3.6 and up, where
875                 # module.__dict__ is insertion-ordered.
876                 pass
877         else:  # alphabetical
878             documenters.sort(key=lambda e: e[0].name)
879 
880         return documenters
881 
882     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
883                  check_module: bool = False, all_members: bool = False) -> None:
884         """Generate reST for the object given by *self.name*, and possibly for
885         its members.
886 
887         If *more_content* is given, include that content. If *real_modname* is
888         given, use that module name to find attribute docs. If *check_module* is
889         True, only generate if the object is defined in the module name it is
890         imported from. If *all_members* is True, document all members.
891         """
892         if not self.parse_name():
893             # need a module to import
894             logger.warning(
895                 __('don\'t know which module to import for autodocumenting '
896                    '%r (try placing a "module" or "currentmodule" directive '
897                    'in the document, or giving an explicit module name)') %
898                 self.name, type='autodoc')
899             return
900 
901         # now, import the module and get object to document
902         if not self.import_object():
903             return
904 
905         # If there is no real module defined, figure out which to use.
906         # The real module is used in the module analyzer to look up the module
907         # where the attribute documentation would actually be found in.
908         # This is used for situations where you have a module that collects the
909         # functions and classes of internal submodules.
910         guess_modname = self.get_real_modname()
911         self.real_modname = real_modname or guess_modname
912 
913         # try to also get a source code analyzer for attribute docs
914         try:
915             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
916             # parse right now, to get PycodeErrors on parsing (results will
917             # be cached anyway)
918             self.analyzer.find_attr_docs()
919         except PycodeError as exc:
920             logger.debug('[autodoc] module analyzer failed: %s', exc)
921             # no source file -- e.g. for builtin and C modules
922             self.analyzer = None
923             # at least add the module.__file__ as a dependency
924             if hasattr(self.module, '__file__') and self.module.__file__:
925                 self.directive.filename_set.add(self.module.__file__)
926         else:
927             self.directive.filename_set.add(self.analyzer.srcname)
928 
929         if self.real_modname != guess_modname:
930             # Add module to dependency list if target object is defined in other module.
931             try:
932                 analyzer = ModuleAnalyzer.for_module(guess_modname)
933                 self.directive.filename_set.add(analyzer.srcname)
934             except PycodeError:
935                 pass
936 
937         # check __module__ of object (for members not given explicitly)
938         if check_module:
939             if not self.check_module():
940                 return
941 
942         sourcename = self.get_sourcename()
943 
944         # make sure that the result starts with an empty line.  This is
945         # necessary for some situations where another directive preprocesses
946         # reST and no starting newline is present
947         self.add_line('', sourcename)
948 
949         # format the object's signature, if any
950         try:
951             sig = self.format_signature()
952         except Exception as exc:
953             logger.warning(__('error while formatting signature for %s: %s'),
954                            self.fullname, exc, type='autodoc')
955             return
956 
957         # generate the directive header and options, if applicable
958         self.add_directive_header(sig)
959         self.add_line('', sourcename)
960 
961         # e.g. the module directive doesn't have content
962         self.indent += self.content_indent
963 
964         # add all content (from docstrings, attribute docs etc.)
965         self.add_content(more_content)
966 
967         # document members, if possible
968         self.document_members(all_members)
969 
970 
971 class ModuleDocumenter(Documenter):
972     """
973     Specialized Documenter subclass for modules.
974     """
975     objtype = 'module'
976     content_indent = ''
977     titles_allowed = True
978 
979     option_spec = {
980         'members': members_option, 'undoc-members': bool_option,
981         'noindex': bool_option, 'inherited-members': inherited_members_option,
982         'show-inheritance': bool_option, 'synopsis': identity,
983         'platform': identity, 'deprecated': bool_option,
984         'member-order': member_order_option, 'exclude-members': exclude_members_option,
985         'private-members': members_option, 'special-members': members_option,
986         'imported-members': bool_option, 'ignore-module-all': bool_option
987     }  # type: Dict[str, Callable]
988 
989     def __init__(self, *args: Any) -> None:
990         super().__init__(*args)
991         merge_members_option(self.options)
992         self.__all__ = None  # type: Optional[Sequence[str]]
993 
994     @classmethod
995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
996                             ) -> bool:
997         # don't document submodules automatically
998         return False
999 
1000     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1001                      ) -> Tuple[str, List[str]]:
1002         if modname is not None:
1003             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1004                            type='autodoc')
1005         return (path or '') + base, []
1006 
1007     def parse_name(self) -> bool:
1008         ret = super().parse_name()
1009         if self.args or self.retann:
1010             logger.warning(__('signature arguments or return annotation '
1011                               'given for automodule %s') % self.fullname,
1012                            type='autodoc')
1013         return ret
1014 
1015     def import_object(self, raiseerror: bool = False) -> bool:
1016         ret = super().import_object(raiseerror)
1017 
1018         try:
1019             if not self.options.ignore_module_all:
1020                 self.__all__ = inspect.getall(self.object)
1021         except AttributeError as exc:
1022             # __all__ raises an error.
1023             logger.warning(__('%s.__all__ raises an error. Ignored: %r'),
1024                            (self.fullname, exc), type='autodoc')
1025         except ValueError as exc:
1026             # invalid __all__ found.
1027             logger.warning(__('__all__ should be a list of strings, not %r '
1028                               '(in module %s) -- ignoring __all__') %
1029                            (exc.args[0], self.fullname), type='autodoc')
1030 
1031         return ret
1032 
1033     def add_directive_header(self, sig: str) -> None:
1034         Documenter.add_directive_header(self, sig)
1035 
1036         sourcename = self.get_sourcename()
1037 
1038         # add some module-specific options
1039         if self.options.synopsis:
1040             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1041         if self.options.platform:
1042             self.add_line('   :platform: ' + self.options.platform, sourcename)
1043         if self.options.deprecated:
1044             self.add_line('   :deprecated:', sourcename)
1045 
1046     def get_module_members(self) -> Dict[str, ObjectMember]:
1047         """Get members of target module."""
1048         if self.analyzer:
1049             attr_docs = self.analyzer.attr_docs
1050         else:
1051             attr_docs = {}
1052 
1053         members = {}  # type: Dict[str, ObjectMember]
1054         for name in dir(self.object):
1055             try:
1056                 value = safe_getattr(self.object, name, None)
1057                 docstring = attr_docs.get(('', name), [])
1058                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1059             except AttributeError:
1060                 continue
1061 
1062         # annotation only member (ex. attr: int)
1063         try:
1064             for name in inspect.getannotations(self.object):
1065                 if name not in members:
1066                     docstring = attr_docs.get(('', name), [])
1067                     members[name] = ObjectMember(name, INSTANCEATTR,
1068                                                  docstring="\n".join(docstring))
1069         except AttributeError:
1070             pass
1071 
1072         return members
1073 
1074     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1075         members = self.get_module_members()
1076         if want_all:
1077             if self.__all__ is None:
1078                 # for implicit module members, check __module__ to avoid
1079                 # documenting imported objects
1080                 return True, list(members.values())
1081             else:
1082                 for member in members.values():
1083                     if member.__name__ not in self.__all__:
1084                         member.skipped = True
1085 
1086                 return False, list(members.values())
1087         else:
1088             memberlist = self.options.members or []
1089             ret = []
1090             for name in memberlist:
1091                 if name in members:
1092                     ret.append(members[name])
1093                 else:
1094                     logger.warning(__('missing attribute mentioned in :members: option: '
1095                                       'module %s, attribute %s') %
1096                                    (safe_getattr(self.object, '__name__', '???'), name),
1097                                    type='autodoc')
1098             return False, ret
1099 
1100     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1101                      order: str) -> List[Tuple["Documenter", bool]]:
1102         if order == 'bysource' and self.__all__:
1103             # Sort alphabetically first (for members not listed on the __all__)
1104             documenters.sort(key=lambda e: e[0].name)
1105 
1106             # Sort by __all__
1107             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1108                 name = entry[0].name.split('::')[1]
1109                 if name in self.__all__:
1110                     return self.__all__.index(name)
1111                 else:
1112                     return len(self.__all__)
1113             documenters.sort(key=keyfunc)
1114 
1115             return documenters
1116         else:
1117             return super().sort_members(documenters, order)
1118 
1119 
1120 class ModuleLevelDocumenter(Documenter):
1121     """
1122     Specialized Documenter subclass for objects on module level (functions,
1123     classes, data/constants).
1124     """
1125     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1126                      ) -> Tuple[str, List[str]]:
1127         if modname is None:
1128             if path:
1129                 modname = path.rstrip('.')
1130             else:
1131                 # if documenting a toplevel object without explicit module,
1132                 # it can be contained in another auto directive ...
1133                 modname = self.env.temp_data.get('autodoc:module')
1134                 # ... or in the scope of a module directive
1135                 if not modname:
1136                     modname = self.env.ref_context.get('py:module')
1137                 # ... else, it stays None, which means invalid
1138         return modname, parents + [base]
1139 
1140 
1141 class ClassLevelDocumenter(Documenter):
1142     """
1143     Specialized Documenter subclass for objects on class level (methods,
1144     attributes).
1145     """
1146     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1147                      ) -> Tuple[str, List[str]]:
1148         if modname is None:
1149             if path:
1150                 mod_cls = path.rstrip('.')
1151             else:
1152                 mod_cls = None
1153                 # if documenting a class-level object without path,
1154                 # there must be a current class, either from a parent
1155                 # auto directive ...
1156                 mod_cls = self.env.temp_data.get('autodoc:class')
1157                 # ... or from a class directive
1158                 if mod_cls is None:
1159                     mod_cls = self.env.ref_context.get('py:class')
1160                 # ... if still None, there's no way to know
1161                 if mod_cls is None:
1162                     return None, []
1163             modname, sep, cls = mod_cls.rpartition('.')
1164             parents = [cls]
1165             # if the module name is still missing, get it like above
1166             if not modname:
1167                 modname = self.env.temp_data.get('autodoc:module')
1168             if not modname:
1169                 modname = self.env.ref_context.get('py:module')
1170             # ... else, it stays None, which means invalid
1171         return modname, parents + [base]
1172 
1173 
1174 class DocstringSignatureMixin:
1175     """
1176     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1177     feature of reading the signature from the docstring.
1178     """
1179     _new_docstrings = None  # type: List[List[str]]
1180     _signatures = None      # type: List[str]
1181 
1182     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1183         if encoding is not None:
1184             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1185                           "deprecated." % self.__class__.__name__,
1186                           RemovedInSphinx40Warning, stacklevel=2)
1187 
1188         # candidates of the object name
1189         valid_names = [self.objpath[-1]]  # type: ignore
1190         if isinstance(self, ClassDocumenter):
1191             valid_names.append('__init__')
1192             if hasattr(self.object, '__mro__'):
1193                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1194 
1195         docstrings = self.get_doc()
1196         if docstrings is None:
1197             return None, None
1198         self._new_docstrings = docstrings[:]
1199         self._signatures = []
1200         result = None
1201         for i, doclines in enumerate(docstrings):
1202             for j, line in enumerate(doclines):
1203                 if not line:
1204                     # no lines in docstring, no match
1205                     break
1206 
1207                 if line.endswith('\\'):
1208                     multiline = True
1209                     line = line.rstrip('\\').rstrip()
1210                 else:
1211                     multiline = False
1212 
1213                 # match first line of docstring against signature RE
1214                 match = py_ext_sig_re.match(line)
1215                 if not match:
1216                     continue
1217                 exmod, path, base, args, retann = match.groups()
1218 
1219                 # the base name must match ours
1220                 if base not in valid_names:
1221                     continue
1222 
1223                 # re-prepare docstring to ignore more leading indentation
1224                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1225                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1226                                                             tabsize=tab_width)
1227 
1228                 if result is None:
1229                     # first signature
1230                     result = args, retann
1231                 else:
1232                     # subsequent signatures
1233                     self._signatures.append("(%s) -> %s" % (args, retann))
1234 
1235                 if multiline:
1236                     # the signature have multiple signatures on docstring
1237                     continue
1238                 else:
1239                     # don't look any further
1240                     break
1241 
1242             if result:
1243                 # finish the loop when signature found
1244                 break
1245 
1246         return result
1247 
1248     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1249         if encoding is not None:
1250             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1251                           % self.__class__.__name__,
1252                           RemovedInSphinx40Warning, stacklevel=2)
1253         if self._new_docstrings is not None:
1254             return self._new_docstrings
1255         return super().get_doc(None, ignore)  # type: ignore
1256 
1257     def format_signature(self, **kwargs: Any) -> str:
1258         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1259             # only act if a signature is not explicitly given already, and if
1260             # the feature is enabled
1261             result = self._find_signature()
1262             if result is not None:
1263                 self.args, self.retann = result
1264         sig = super().format_signature(**kwargs)  # type: ignore
1265         if self._signatures:
1266             return "\n".join([sig] + self._signatures)
1267         else:
1268             return sig
1269 
1270 
1271 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1272     """
1273     Mixin for AttributeDocumenter to provide the
1274     feature of stripping any function signature from the docstring.
1275     """
1276     def format_signature(self, **kwargs: Any) -> str:
1277         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1278             # only act if a signature is not explicitly given already, and if
1279             # the feature is enabled
1280             result = self._find_signature()
1281             if result is not None:
1282                 # Discarding _args is a only difference with
1283                 # DocstringSignatureMixin.format_signature.
1284                 # Documenter.format_signature use self.args value to format.
1285                 _args, self.retann = result
1286         return super().format_signature(**kwargs)
1287 
1288 
1289 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1290     """
1291     Specialized Documenter subclass for functions.
1292     """
1293     objtype = 'function'
1294     member_order = 30
1295 
1296     @classmethod
1297     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1298                             ) -> bool:
1299         # supports functions, builtins and bound methods exported at the module level
1300         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1301                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1302 
1303     def format_args(self, **kwargs: Any) -> str:
1304         if self.config.autodoc_typehints in ('none', 'description'):
1305             kwargs.setdefault('show_annotation', False)
1306 
1307         try:
1308             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1309             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1310             args = stringify_signature(sig, **kwargs)
1311         except TypeError as exc:
1312             logger.warning(__("Failed to get a function signature for %s: %s"),
1313                            self.fullname, exc)
1314             return None
1315         except ValueError:
1316             args = ''
1317 
1318         if self.config.strip_signature_backslash:
1319             # escape backslashes for reST
1320             args = args.replace('\\', '\\\\')
1321         return args
1322 
1323     def document_members(self, all_members: bool = False) -> None:
1324         pass
1325 
1326     def add_directive_header(self, sig: str) -> None:
1327         sourcename = self.get_sourcename()
1328         super().add_directive_header(sig)
1329 
1330         if inspect.iscoroutinefunction(self.object):
1331             self.add_line('   :async:', sourcename)
1332 
1333     def format_signature(self, **kwargs: Any) -> str:
1334         sigs = []
1335         if (self.analyzer and
1336                 '.'.join(self.objpath) in self.analyzer.overloads and
1337                 self.config.autodoc_typehints == 'signature'):
1338             # Use signatures for overloaded functions instead of the implementation function.
1339             overloaded = True
1340         else:
1341             overloaded = False
1342             sig = super().format_signature(**kwargs)
1343             sigs.append(sig)
1344 
1345         if inspect.is_singledispatch_function(self.object):
1346             # append signature of singledispatch'ed functions
1347             for typ, func in self.object.registry.items():
1348                 if typ is object:
1349                     pass  # default implementation. skipped.
1350                 else:
1351                     self.annotate_to_first_argument(func, typ)
1352 
1353                     documenter = FunctionDocumenter(self.directive, '')
1354                     documenter.object = func
1355                     documenter.objpath = [None]
1356                     sigs.append(documenter.format_signature())
1357         if overloaded:
1358             __globals__ = safe_getattr(self.object, '__globals__', {})
1359             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1360                 overload = evaluate_signature(overload, __globals__,
1361                                               self.config.autodoc_type_aliases)
1362 
1363                 sig = stringify_signature(overload, **kwargs)
1364                 sigs.append(sig)
1365 
1366         return "\n".join(sigs)
1367 
1368     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1369         """Annotate type hint to the first argument of function if needed."""
1370         try:
1371             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1372         except TypeError as exc:
1373             logger.warning(__("Failed to get a function signature for %s: %s"),
1374                            self.fullname, exc)
1375             return
1376         except ValueError:
1377             return
1378 
1379         if len(sig.parameters) == 0:
1380             return
1381 
1382         params = list(sig.parameters.values())
1383         if params[0].annotation is Parameter.empty:
1384             params[0] = params[0].replace(annotation=typ)
1385             try:
1386                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1387             except TypeError:
1388                 # failed to update signature (ex. built-in or extension types)
1389                 return
1390 
1391 
1392 class DecoratorDocumenter(FunctionDocumenter):
1393     """
1394     Specialized Documenter subclass for decorator functions.
1395     """
1396     objtype = 'decorator'
1397 
1398     # must be lower than FunctionDocumenter
1399     priority = -1
1400 
1401     def format_args(self, **kwargs: Any) -> Any:
1402         args = super().format_args(**kwargs)
1403         if ',' in args:
1404             return args
1405         else:
1406             return None
1407 
1408 
1409 # Types which have confusing metaclass signatures it would be best not to show.
1410 # These are listed by name, rather than storing the objects themselves, to avoid
1411 # needing to import the modules.
1412 _METACLASS_CALL_BLACKLIST = [
1413     'enum.EnumMeta.__call__',
1414 ]
1415 
1416 
1417 # Types whose __new__ signature is a pass-thru.
1418 _CLASS_NEW_BLACKLIST = [
1419     'typing.Generic.__new__',
1420 ]
1421 
1422 
1423 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1424     """
1425     Specialized Documenter subclass for classes.
1426     """
1427     objtype = 'class'
1428     member_order = 20
1429     option_spec = {
1430         'members': members_option, 'undoc-members': bool_option,
1431         'noindex': bool_option, 'inherited-members': inherited_members_option,
1432         'show-inheritance': bool_option, 'member-order': member_order_option,
1433         'exclude-members': exclude_members_option,
1434         'private-members': members_option, 'special-members': members_option,
1435     }  # type: Dict[str, Callable]
1436 
1437     _signature_class = None  # type: Any
1438     _signature_method_name = None  # type: str
1439 
1440     def __init__(self, *args: Any) -> None:
1441         super().__init__(*args)
1442         merge_members_option(self.options)
1443 
1444     @classmethod
1445     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1446                             ) -> bool:
1447         return isinstance(member, type)
1448 
1449     def import_object(self, raiseerror: bool = False) -> bool:
1450         ret = super().import_object(raiseerror)
1451         # if the class is documented under another name, document it
1452         # as data/attribute
1453         if ret:
1454             if hasattr(self.object, '__name__'):
1455                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1456             else:
1457                 self.doc_as_attr = True
1458         return ret
1459 
1460     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1461         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1462             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1463             if inspect.is_builtin_class_method(obj, attr):
1464                 return None
1465             attr = self.get_attr(obj, attr, None)
1466             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1467                 return None
1468             return attr
1469 
1470         # This sequence is copied from inspect._signature_from_callable.
1471         # ValueError means that no signature could be found, so we keep going.
1472 
1473         # First, we check the obj has a __signature__ attribute
1474         if (hasattr(self.object, '__signature__') and
1475                 isinstance(self.object.__signature__, Signature)):
1476             return None, None, self.object.__signature__
1477 
1478         # Next, let's see if it has an overloaded __call__ defined
1479         # in its metaclass
1480         call = get_user_defined_function_or_method(type(self.object), '__call__')
1481 
1482         if call is not None:
1483             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1484                 call = None
1485 
1486         if call is not None:
1487             self.env.app.emit('autodoc-before-process-signature', call, True)
1488             try:
1489                 sig = inspect.signature(call, bound_method=True,
1490                                         type_aliases=self.config.autodoc_type_aliases)
1491                 return type(self.object), '__call__', sig
1492             except ValueError:
1493                 pass
1494 
1495         # Now we check if the 'obj' class has a '__new__' method
1496         new = get_user_defined_function_or_method(self.object, '__new__')
1497 
1498         if new is not None:
1499             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1500                 new = None
1501 
1502         if new is not None:
1503             self.env.app.emit('autodoc-before-process-signature', new, True)
1504             try:
1505                 sig = inspect.signature(new, bound_method=True,
1506                                         type_aliases=self.config.autodoc_type_aliases)
1507                 return self.object, '__new__', sig
1508             except ValueError:
1509                 pass
1510 
1511         # Finally, we should have at least __init__ implemented
1512         init = get_user_defined_function_or_method(self.object, '__init__')
1513         if init is not None:
1514             self.env.app.emit('autodoc-before-process-signature', init, True)
1515             try:
1516                 sig = inspect.signature(init, bound_method=True,
1517                                         type_aliases=self.config.autodoc_type_aliases)
1518                 return self.object, '__init__', sig
1519             except ValueError:
1520                 pass
1521 
1522         # None of the attributes are user-defined, so fall back to let inspect
1523         # handle it.
1524         # We don't know the exact method that inspect.signature will read
1525         # the signature from, so just pass the object itself to our hook.
1526         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1527         try:
1528             sig = inspect.signature(self.object, bound_method=False,
1529                                     type_aliases=self.config.autodoc_type_aliases)
1530             return None, None, sig
1531         except ValueError:
1532             pass
1533 
1534         # Still no signature: happens e.g. for old-style classes
1535         # with __init__ in C and no `__text_signature__`.
1536         return None, None, None
1537 
1538     def format_args(self, **kwargs: Any) -> str:
1539         if self.config.autodoc_typehints in ('none', 'description'):
1540             kwargs.setdefault('show_annotation', False)
1541 
1542         try:
1543             self._signature_class, self._signature_method_name, sig = self._get_signature()
1544         except TypeError as exc:
1545             # __signature__ attribute contained junk
1546             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1547                            self.fullname, exc)
1548             return None
1549 
1550         if sig is None:
1551             return None
1552 
1553         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1554 
1555     def format_signature(self, **kwargs: Any) -> str:
1556         if self.doc_as_attr:
1557             return ''
1558 
1559         sig = super().format_signature()
1560         sigs = []
1561 
1562         overloads = self.get_overloaded_signatures()
1563         if overloads and self.config.autodoc_typehints == 'signature':
1564             # Use signatures for overloaded methods instead of the implementation method.
1565             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1566             __globals__ = safe_getattr(method, '__globals__', {})
1567             for overload in overloads:
1568                 overload = evaluate_signature(overload, __globals__,
1569                                               self.config.autodoc_type_aliases)
1570 
1571                 parameters = list(overload.parameters.values())
1572                 overload = overload.replace(parameters=parameters[1:],
1573                                             return_annotation=Parameter.empty)
1574                 sig = stringify_signature(overload, **kwargs)
1575                 sigs.append(sig)
1576         else:
1577             sigs.append(sig)
1578 
1579         return "\n".join(sigs)
1580 
1581     def get_overloaded_signatures(self) -> List[Signature]:
1582         if self._signature_class and self._signature_method_name:
1583             for cls in self._signature_class.__mro__:
1584                 try:
1585                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1586                     analyzer.analyze()
1587                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1588                     if qualname in analyzer.overloads:
1589                         return analyzer.overloads.get(qualname)
1590                     elif qualname in analyzer.tagorder:
1591                         # the constructor is defined in the class, but not overrided.
1592                         return []
1593                 except PycodeError:
1594                     pass
1595 
1596         return []
1597 
1598     def add_directive_header(self, sig: str) -> None:
1599         sourcename = self.get_sourcename()
1600 
1601         if self.doc_as_attr:
1602             self.directivetype = 'attribute'
1603         super().add_directive_header(sig)
1604 
1605         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1606             self.add_line('   :final:', sourcename)
1607 
1608         # add inheritance info, if wanted
1609         if not self.doc_as_attr and self.options.show_inheritance:
1610             sourcename = self.get_sourcename()
1611             self.add_line('', sourcename)
1612 
1613             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1614                 # A subclass of generic types
1615                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1616                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1617                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1618             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1619                 # A normal class
1620                 bases = [restify(cls) for cls in self.object.__bases__]
1621                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1622 
1623     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1624         members = get_class_members(self.object, self.objpath, self.get_attr)
1625         if not want_all:
1626             if not self.options.members:
1627                 return False, []  # type: ignore
1628             # specific members given
1629             selected = []
1630             for name in self.options.members:  # type: str
1631                 if name in members:
1632                     selected.append(members[name])
1633                 else:
1634                     logger.warning(__('missing attribute %s in object %s') %
1635                                    (name, self.fullname), type='autodoc')
1636             return False, selected
1637         elif self.options.inherited_members:
1638             return False, list(members.values())
1639         else:
1640             return False, [m for m in members.values() if m.class_ == self.object]
1641 
1642     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1643         if encoding is not None:
1644             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1645                           % self.__class__.__name__,
1646                           RemovedInSphinx40Warning, stacklevel=2)
1647         if self.doc_as_attr:
1648             # Don't show the docstring of the class when it is an alias.
1649             return None
1650 
1651         lines = getattr(self, '_new_docstrings', None)
1652         if lines is not None:
1653             return lines
1654 
1655         content = self.config.autoclass_content
1656 
1657         docstrings = []
1658         attrdocstring = self.get_attr(self.object, '__doc__', None)
1659         if attrdocstring:
1660             docstrings.append(attrdocstring)
1661 
1662         # for classes, what the "docstring" is can be controlled via a
1663         # config value; the default is only the class docstring
1664         if content in ('both', 'init'):
1665             __init__ = self.get_attr(self.object, '__init__', None)
1666             initdocstring = getdoc(__init__, self.get_attr,
1667                                    self.config.autodoc_inherit_docstrings,
1668                                    self.parent, self.object_name)
1669             # for new-style classes, no __init__ means default __init__
1670             if (initdocstring is not None and
1671                 (initdocstring == object.__init__.__doc__ or  # for pypy
1672                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1673                 initdocstring = None
1674             if not initdocstring:
1675                 # try __new__
1676                 __new__ = self.get_attr(self.object, '__new__', None)
1677                 initdocstring = getdoc(__new__, self.get_attr,
1678                                        self.config.autodoc_inherit_docstrings,
1679                                        self.parent, self.object_name)
1680                 # for new-style classes, no __new__ means default __new__
1681                 if (initdocstring is not None and
1682                     (initdocstring == object.__new__.__doc__ or  # for pypy
1683                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1684                     initdocstring = None
1685             if initdocstring:
1686                 if content == 'init':
1687                     docstrings = [initdocstring]
1688                 else:
1689                     docstrings.append(initdocstring)
1690 
1691         tab_width = self.directive.state.document.settings.tab_width
1692         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1693 
1694     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1695                     ) -> None:
1696         if self.doc_as_attr:
1697             try:
1698                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1699             except AttributeError:
1700                 pass  # Invalid class object is passed.
1701 
1702         super().add_content(more_content)
1703 
1704     def document_members(self, all_members: bool = False) -> None:
1705         if self.doc_as_attr:
1706             return
1707         super().document_members(all_members)
1708 
1709     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1710                  check_module: bool = False, all_members: bool = False) -> None:
1711         # Do not pass real_modname and use the name from the __module__
1712         # attribute of the class.
1713         # If a class gets imported into the module real_modname
1714         # the analyzer won't find the source of the class, if
1715         # it looks in real_modname.
1716         return super().generate(more_content=more_content,
1717                                 check_module=check_module,
1718                                 all_members=all_members)
1719 
1720 
1721 class ExceptionDocumenter(ClassDocumenter):
1722     """
1723     Specialized ClassDocumenter subclass for exceptions.
1724     """
1725     objtype = 'exception'
1726     member_order = 10
1727 
1728     # needs a higher priority than ClassDocumenter
1729     priority = 10
1730 
1731     @classmethod
1732     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1733                             ) -> bool:
1734         return isinstance(member, type) and issubclass(member, BaseException)
1735 
1736 
1737 class DataDocumenterMixinBase:
1738     # define types of instance variables
1739     config = None  # type: Config
1740     env = None  # type: BuildEnvironment
1741     modname = None  # type: str
1742     parent = None  # type: Any
1743     object = None  # type: Any
1744     objpath = None  # type: List[str]
1745 
1746     def should_suppress_directive_header(self) -> bool:
1747         """Check directive header should be suppressed."""
1748         return False
1749 
1750     def should_suppress_value_header(self) -> bool:
1751         """Check :value: header should be suppressed."""
1752         return False
1753 
1754     def update_content(self, more_content: StringList) -> None:
1755         """Update docstring for the NewType object."""
1756         pass
1757 
1758 
1759 class GenericAliasMixin(DataDocumenterMixinBase):
1760     """
1761     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1762     supporting GenericAliases.
1763     """
1764 
1765     def should_suppress_directive_header(self) -> bool:
1766         return (inspect.isgenericalias(self.object) or
1767                 super().should_suppress_directive_header())
1768 
1769     def update_content(self, more_content: StringList) -> None:
1770         if inspect.isgenericalias(self.object):
1771             alias = stringify_typehint(self.object)
1772             more_content.append(_('alias of %s') % alias, '')
1773             more_content.append('', '')
1774 
1775         super().update_content(more_content)
1776 
1777 
1778 class NewTypeMixin(DataDocumenterMixinBase):
1779     """
1780     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1781     supporting NewTypes.
1782     """
1783 
1784     def should_suppress_directive_header(self) -> bool:
1785         return (inspect.isNewType(self.object) or
1786                 super().should_suppress_directive_header())
1787 
1788     def update_content(self, more_content: StringList) -> None:
1789         if inspect.isNewType(self.object):
1790             supertype = restify(self.object.__supertype__)
1791             more_content.append(_('alias of %s') % supertype, '')
1792             more_content.append('', '')
1793 
1794         super().update_content(more_content)
1795 
1796 
1797 class TypeVarMixin(DataDocumenterMixinBase):
1798     """
1799     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1800     supporting TypeVars.
1801     """
1802 
1803     def should_suppress_directive_header(self) -> bool:
1804         return (isinstance(self.object, TypeVar) or
1805                 super().should_suppress_directive_header())
1806 
1807     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1808         if ignore is not None:
1809             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1810                           % self.__class__.__name__,
1811                           RemovedInSphinx50Warning, stacklevel=2)
1812 
1813         if isinstance(self.object, TypeVar):
1814             if self.object.__doc__ != TypeVar.__doc__:
1815                 return super().get_doc()  # type: ignore
1816             else:
1817                 return []
1818         else:
1819             return super().get_doc()  # type: ignore
1820 
1821     def update_content(self, more_content: StringList) -> None:
1822         if isinstance(self.object, TypeVar):
1823             attrs = [repr(self.object.__name__)]
1824             for constraint in self.object.__constraints__:
1825                 attrs.append(stringify_typehint(constraint))
1826             if self.object.__covariant__:
1827                 attrs.append("covariant=True")
1828             if self.object.__contravariant__:
1829                 attrs.append("contravariant=True")
1830 
1831             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1832             more_content.append('', '')
1833 
1834         super().update_content(more_content)
1835 
1836 
1837 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1838     """
1839     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1840     (type annotation only) global variables.
1841     """
1842 
1843     def import_object(self, raiseerror: bool = False) -> bool:
1844         try:
1845             return super().import_object(raiseerror=True)  # type: ignore
1846         except ImportError as exc:
1847             # annotation only instance variable (PEP-526)
1848             try:
1849                 with mock(self.config.autodoc_mock_imports):
1850                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1851                     annotations = get_type_hints(parent, None,
1852                                                  self.config.autodoc_type_aliases)
1853                     if self.objpath[-1] in annotations:
1854                         self.object = UNINITIALIZED_ATTR
1855                         self.parent = parent
1856                         return True
1857             except ImportError:
1858                 pass
1859 
1860             if raiseerror:
1861                 raise
1862             else:
1863                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1864                 self.env.note_reread()
1865                 return False
1866 
1867     def should_suppress_value_header(self) -> bool:
1868         return (self.object is UNINITIALIZED_ATTR or
1869                 super().should_suppress_value_header())
1870 
1871     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1872         if self.object is UNINITIALIZED_ATTR:
1873             return []
1874         else:
1875             return super().get_doc(encoding, ignore)  # type: ignore
1876 
1877 
1878 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1879                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1880     """
1881     Specialized Documenter subclass for data items.
1882     """
1883     objtype = 'data'
1884     member_order = 40
1885     priority = -10
1886     option_spec = dict(ModuleLevelDocumenter.option_spec)
1887     option_spec["annotation"] = annotation_option
1888     option_spec["no-value"] = bool_option
1889 
1890     @classmethod
1891     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1892                             ) -> bool:
1893         return isinstance(parent, ModuleDocumenter) and isattr
1894 
1895     def update_annotations(self, parent: Any) -> None:
1896         """Update __annotations__ to support type_comment and so on."""
1897         try:
1898             annotations = dict(inspect.getannotations(parent))
1899             parent.__annotations__ = annotations
1900 
1901             analyzer = ModuleAnalyzer.for_module(self.modname)
1902             analyzer.analyze()
1903             for (classname, attrname), annotation in analyzer.annotations.items():
1904                 if classname == '' and attrname not in annotations:
1905                     annotations[attrname] = annotation
1906         except AttributeError:
1907             pass
1908 
1909     def import_object(self, raiseerror: bool = False) -> bool:
1910         ret = super().import_object(raiseerror)
1911         if self.parent:
1912             self.update_annotations(self.parent)
1913 
1914         return ret
1915 
1916     def should_suppress_value_header(self) -> bool:
1917         if super().should_suppress_value_header():
1918             return True
1919         else:
1920             doc = self.get_doc()
1921             metadata = extract_metadata('\n'.join(sum(doc, [])))
1922             if 'hide-value' in metadata:
1923                 return True
1924 
1925         return False
1926 
1927     def add_directive_header(self, sig: str) -> None:
1928         super().add_directive_header(sig)
1929         sourcename = self.get_sourcename()
1930         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1931             pass
1932         elif self.options.annotation:
1933             self.add_line('   :annotation: %s' % self.options.annotation,
1934                           sourcename)
1935         else:
1936             # obtain annotation for this data
1937             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1938             if self.objpath[-1] in annotations:
1939                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1940                 self.add_line('   :type: ' + objrepr, sourcename)
1941 
1942             try:
1943                 if self.options.no_value or self.should_suppress_value_header():
1944                     pass
1945                 else:
1946                     objrepr = object_description(self.object)
1947                     self.add_line('   :value: ' + objrepr, sourcename)
1948             except ValueError:
1949                 pass
1950 
1951     def document_members(self, all_members: bool = False) -> None:
1952         pass
1953 
1954     def get_real_modname(self) -> str:
1955         return self.get_attr(self.parent or self.object, '__module__', None) \
1956             or self.modname
1957 
1958     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1959         try:
1960             analyzer = ModuleAnalyzer.for_module(self.modname)
1961             analyzer.analyze()
1962             key = ('', attrname)
1963             if key in analyzer.attr_docs:
1964                 return list(analyzer.attr_docs[key])
1965         except PycodeError:
1966             pass
1967 
1968         return None
1969 
1970     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1971         # Check the variable has a docstring-comment
1972         comment = self.get_module_comment(self.objpath[-1])
1973         if comment:
1974             return [comment]
1975         else:
1976             return super().get_doc(encoding, ignore)
1977 
1978     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1979                     ) -> None:
1980         # Disable analyzing variable comment on Documenter.add_content() to control it on
1981         # DataDocumenter.add_content()
1982         self.analyzer = None
1983 
1984         if not more_content:
1985             more_content = StringList()
1986 
1987         self.update_content(more_content)
1988         super().add_content(more_content, no_docstring=no_docstring)
1989 
1990 
1991 class NewTypeDataDocumenter(DataDocumenter):
1992     """
1993     Specialized Documenter subclass for NewTypes.
1994 
1995     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
1996     function object.
1997     """
1998 
1999     objtype = 'newtypedata'
2000     directivetype = 'data'
2001     priority = FunctionDocumenter.priority + 1
2002 
2003     @classmethod
2004     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2005                             ) -> bool:
2006         return inspect.isNewType(member) and isattr
2007 
2008 
2009 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2010     """
2011     Specialized Documenter subclass for methods (normal, static and class).
2012     """
2013     objtype = 'method'
2014     directivetype = 'method'
2015     member_order = 50
2016     priority = 1  # must be more than FunctionDocumenter
2017 
2018     @classmethod
2019     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2020                             ) -> bool:
2021         return inspect.isroutine(member) and \
2022             not isinstance(parent, ModuleDocumenter)
2023 
2024     def import_object(self, raiseerror: bool = False) -> bool:
2025         ret = super().import_object(raiseerror)
2026         if not ret:
2027             return ret
2028 
2029         # to distinguish classmethod/staticmethod
2030         obj = self.parent.__dict__.get(self.object_name)
2031         if obj is None:
2032             obj = self.object
2033 
2034         if (inspect.isclassmethod(obj) or
2035                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2036             # document class and static members before ordinary ones
2037             self.member_order = self.member_order - 1
2038 
2039         return ret
2040 
2041     def format_args(self, **kwargs: Any) -> str:
2042         if self.config.autodoc_typehints in ('none', 'description'):
2043             kwargs.setdefault('show_annotation', False)
2044 
2045         try:
2046             if self.object == object.__init__ and self.parent != object:
2047                 # Classes not having own __init__() method are shown as no arguments.
2048                 #
2049                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2050                 #       But it makes users confused.
2051                 args = '()'
2052             else:
2053                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2054                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2055                     sig = inspect.signature(self.object, bound_method=False,
2056                                             type_aliases=self.config.autodoc_type_aliases)
2057                 else:
2058                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2059                     sig = inspect.signature(self.object, bound_method=True,
2060                                             type_aliases=self.config.autodoc_type_aliases)
2061                 args = stringify_signature(sig, **kwargs)
2062         except TypeError as exc:
2063             logger.warning(__("Failed to get a method signature for %s: %s"),
2064                            self.fullname, exc)
2065             return None
2066         except ValueError:
2067             args = ''
2068 
2069         if self.config.strip_signature_backslash:
2070             # escape backslashes for reST
2071             args = args.replace('\\', '\\\\')
2072         return args
2073 
2074     def add_directive_header(self, sig: str) -> None:
2075         super().add_directive_header(sig)
2076 
2077         sourcename = self.get_sourcename()
2078         obj = self.parent.__dict__.get(self.object_name, self.object)
2079         if inspect.isabstractmethod(obj):
2080             self.add_line('   :abstractmethod:', sourcename)
2081         if inspect.iscoroutinefunction(obj):
2082             self.add_line('   :async:', sourcename)
2083         if inspect.isclassmethod(obj):
2084             self.add_line('   :classmethod:', sourcename)
2085         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2086             self.add_line('   :staticmethod:', sourcename)
2087         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2088             self.add_line('   :final:', sourcename)
2089 
2090     def document_members(self, all_members: bool = False) -> None:
2091         pass
2092 
2093     def format_signature(self, **kwargs: Any) -> str:
2094         sigs = []
2095         if (self.analyzer and
2096                 '.'.join(self.objpath) in self.analyzer.overloads and
2097                 self.config.autodoc_typehints == 'signature'):
2098             # Use signatures for overloaded methods instead of the implementation method.
2099             overloaded = True
2100         else:
2101             overloaded = False
2102             sig = super().format_signature(**kwargs)
2103             sigs.append(sig)
2104 
2105         meth = self.parent.__dict__.get(self.objpath[-1])
2106         if inspect.is_singledispatch_method(meth):
2107             # append signature of singledispatch'ed functions
2108             for typ, func in meth.dispatcher.registry.items():
2109                 if typ is object:
2110                     pass  # default implementation. skipped.
2111                 else:
2112                     self.annotate_to_first_argument(func, typ)
2113 
2114                     documenter = MethodDocumenter(self.directive, '')
2115                     documenter.parent = self.parent
2116                     documenter.object = func
2117                     documenter.objpath = [None]
2118                     sigs.append(documenter.format_signature())
2119         if overloaded:
2120             __globals__ = safe_getattr(self.object, '__globals__', {})
2121             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2122                 overload = evaluate_signature(overload, __globals__,
2123                                               self.config.autodoc_type_aliases)
2124 
2125                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2126                                               name=self.object_name):
2127                     parameters = list(overload.parameters.values())
2128                     overload = overload.replace(parameters=parameters[1:])
2129                 sig = stringify_signature(overload, **kwargs)
2130                 sigs.append(sig)
2131 
2132         return "\n".join(sigs)
2133 
2134     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2135         """Annotate type hint to the first argument of function if needed."""
2136         try:
2137             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2138         except TypeError as exc:
2139             logger.warning(__("Failed to get a method signature for %s: %s"),
2140                            self.fullname, exc)
2141             return
2142         except ValueError:
2143             return
2144         if len(sig.parameters) == 1:
2145             return
2146 
2147         params = list(sig.parameters.values())
2148         if params[1].annotation is Parameter.empty:
2149             params[1] = params[1].replace(annotation=typ)
2150             try:
2151                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2152             except TypeError:
2153                 # failed to update signature (ex. built-in or extension types)
2154                 return
2155 
2156 
2157 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2158     """
2159     Mixin for AttributeDocumenter to provide the feature for supporting non
2160     data-descriptors.
2161 
2162     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2163               and :value: header will be suppressed unexpectedly.
2164     """
2165 
2166     def import_object(self, raiseerror: bool = False) -> bool:
2167         ret = super().import_object(raiseerror)  # type: ignore
2168         if ret and not inspect.isattributedescriptor(self.object):
2169             self.non_data_descriptor = True
2170         else:
2171             self.non_data_descriptor = False
2172 
2173         return ret
2174 
2175     def should_suppress_value_header(self) -> bool:
2176         return (not getattr(self, 'non_data_descriptor', False) or
2177                 super().should_suppress_directive_header())
2178 
2179     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2180         if getattr(self, 'non_data_descriptor', False):
2181             # the docstring of non datadescriptor is very probably the wrong thing
2182             # to display
2183             return None
2184         else:
2185             return super().get_doc(encoding, ignore)  # type: ignore
2186 
2187 
2188 class SlotsMixin(DataDocumenterMixinBase):
2189     """
2190     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2191     """
2192 
2193     def isslotsattribute(self) -> bool:
2194         """Check the subject is an attribute in __slots__."""
2195         try:
2196             __slots__ = inspect.getslots(self.parent)
2197             if __slots__ and self.objpath[-1] in __slots__:
2198                 return True
2199             else:
2200                 return False
2201         except (AttributeError, ValueError, TypeError):
2202             return False
2203 
2204     def import_object(self, raiseerror: bool = False) -> bool:
2205         ret = super().import_object(raiseerror)  # type: ignore
2206         if self.isslotsattribute():
2207             self.object = SLOTSATTR
2208 
2209         return ret
2210 
2211     def should_suppress_directive_header(self) -> bool:
2212         if self.object is SLOTSATTR:
2213             self._datadescriptor = True
2214             return True
2215         else:
2216             return super().should_suppress_directive_header()
2217 
2218     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2219         if self.object is SLOTSATTR:
2220             try:
2221                 __slots__ = inspect.getslots(self.parent)
2222                 if __slots__ and __slots__.get(self.objpath[-1]):
2223                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2224                     return [docstring]
2225                 else:
2226                     return []
2227             except (AttributeError, ValueError) as exc:
2228                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2229                                (self.parent.__qualname__, exc), type='autodoc')
2230                 return []
2231         else:
2232             return super().get_doc(encoding, ignore)  # type: ignore
2233 
2234 
2235 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2236     """
2237     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2238     instance attributes (that are defined in __init__() methods with doc-comments).
2239 
2240     Example:
2241 
2242         class Foo:
2243             def __init__(self):
2244                 self.attr = None  #: This is a target of this mix-in.
2245     """
2246 
2247     RUNTIME_INSTANCE_ATTRIBUTE = object()
2248 
2249     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2250         """Check the subject is an attribute defined in __init__()."""
2251         # An instance variable defined in __init__().
2252         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2253             return True
2254         else:
2255             return False
2256 
2257     def import_object(self, raiseerror: bool = False) -> bool:
2258         """Check the existence of runtime instance attribute when failed to import the
2259         attribute."""
2260         try:
2261             return super().import_object(raiseerror=True)  # type: ignore
2262         except ImportError as exc:
2263             try:
2264                 with mock(self.config.autodoc_mock_imports):
2265                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2266                                         attrgetter=self.get_attr,  # type: ignore
2267                                         warningiserror=self.config.autodoc_warningiserror)
2268                     parent = ret[3]
2269                     if self.is_runtime_instance_attribute(parent):
2270                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2271                         self.parent = parent
2272                         return True
2273             except ImportError:
2274                 pass
2275 
2276             if raiseerror:
2277                 raise
2278             else:
2279                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2280                 self.env.note_reread()
2281                 return False
2282 
2283     def should_suppress_value_header(self) -> bool:
2284         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2285                 super().should_suppress_value_header())
2286 
2287 
2288 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2289     """
2290     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2291     instance attributes (PEP-526 styled, annotation only attributes).
2292 
2293     Example:
2294 
2295         class Foo:
2296             attr: int  #: This is a target of this mix-in.
2297     """
2298 
2299     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2300         """Check the subject is an annotation only attribute."""
2301         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2302         if self.objpath[-1] in annotations:
2303             return True
2304         else:
2305             return False
2306 
2307     def import_object(self, raiseerror: bool = False) -> bool:
2308         """Check the exisitence of uninitialized instance attribute when failed to import
2309         the attribute."""
2310         try:
2311             return super().import_object(raiseerror=True)  # type: ignore
2312         except ImportError as exc:
2313             try:
2314                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2315                                     attrgetter=self.get_attr,  # type: ignore
2316                                     warningiserror=self.config.autodoc_warningiserror)
2317                 parent = ret[3]
2318                 if self.is_uninitialized_instance_attribute(parent):
2319                     self.object = UNINITIALIZED_ATTR
2320                     self.parent = parent
2321                     return True
2322             except ImportError:
2323                 pass
2324 
2325             if raiseerror:
2326                 raise
2327             else:
2328                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2329                 self.env.note_reread()
2330                 return False
2331 
2332     def should_suppress_value_header(self) -> bool:
2333         return (self.object is UNINITIALIZED_ATTR or
2334                 super().should_suppress_value_header())
2335 
2336     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2337         if self.object is UNINITIALIZED_ATTR:
2338             return None
2339         else:
2340             return super().get_doc(encoding, ignore)  # type: ignore
2341 
2342 
2343 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2344                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2345                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2346                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2347     """
2348     Specialized Documenter subclass for attributes.
2349     """
2350     objtype = 'attribute'
2351     member_order = 60
2352     option_spec = dict(ModuleLevelDocumenter.option_spec)
2353     option_spec["annotation"] = annotation_option
2354     option_spec["no-value"] = bool_option
2355 
2356     # must be higher than the MethodDocumenter, else it will recognize
2357     # some non-data descriptors as methods
2358     priority = 10
2359 
2360     @staticmethod
2361     def is_function_or_method(obj: Any) -> bool:
2362         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2363 
2364     @classmethod
2365     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2366                             ) -> bool:
2367         if inspect.isattributedescriptor(member):
2368             return True
2369         elif (not isinstance(parent, ModuleDocumenter) and
2370               not inspect.isroutine(member) and
2371               not isinstance(member, type)):
2372             return True
2373         else:
2374             return False
2375 
2376     def document_members(self, all_members: bool = False) -> None:
2377         pass
2378 
2379     def isinstanceattribute(self) -> bool:
2380         """Check the subject is an instance attribute."""
2381         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2382                       RemovedInSphinx50Warning)
2383         # uninitialized instance variable (PEP-526)
2384         with mock(self.config.autodoc_mock_imports):
2385             try:
2386                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2387                                     attrgetter=self.get_attr,
2388                                     warningiserror=self.config.autodoc_warningiserror)
2389                 self.parent = ret[3]
2390                 annotations = get_type_hints(self.parent, None,
2391                                              self.config.autodoc_type_aliases)
2392                 if self.objpath[-1] in annotations:
2393                     self.object = UNINITIALIZED_ATTR
2394                     return True
2395             except ImportError:
2396                 pass
2397 
2398         return False
2399 
2400     def update_annotations(self, parent: Any) -> None:
2401         """Update __annotations__ to support type_comment and so on."""
2402         try:
2403             annotations = dict(inspect.getannotations(parent))
2404             parent.__annotations__ = annotations
2405 
2406             for cls in inspect.getmro(parent):
2407                 try:
2408                     module = safe_getattr(cls, '__module__')
2409                     qualname = safe_getattr(cls, '__qualname__')
2410 
2411                     analyzer = ModuleAnalyzer.for_module(module)
2412                     analyzer.analyze()
2413                     for (classname, attrname), annotation in analyzer.annotations.items():
2414                         if classname == qualname and attrname not in annotations:
2415                             annotations[attrname] = annotation
2416                 except (AttributeError, PycodeError):
2417                     pass
2418         except AttributeError:
2419             pass
2420         except TypeError:
2421             # Failed to set __annotations__ (built-in, extensions, etc.)
2422             pass
2423 
2424     def import_object(self, raiseerror: bool = False) -> bool:
2425         ret = super().import_object(raiseerror)
2426         if inspect.isenumattribute(self.object):
2427             self.object = self.object.value
2428         if self.parent:
2429             self.update_annotations(self.parent)
2430 
2431         return ret
2432 
2433     def get_real_modname(self) -> str:
2434         return self.get_attr(self.parent or self.object, '__module__', None) \
2435             or self.modname
2436 
2437     def should_suppress_value_header(self) -> bool:
2438         if super().should_suppress_value_header():
2439             return True
2440         else:
2441             doc = self.get_doc()
2442             if doc:
2443                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2444                 if 'hide-value' in metadata:
2445                     return True
2446 
2447         return False
2448 
2449     def add_directive_header(self, sig: str) -> None:
2450         super().add_directive_header(sig)
2451         sourcename = self.get_sourcename()
2452         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2453             pass
2454         elif self.options.annotation:
2455             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2456         else:
2457             # obtain type annotation for this attribute
2458             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2459             if self.objpath[-1] in annotations:
2460                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2461                 self.add_line('   :type: ' + objrepr, sourcename)
2462 
2463             try:
2464                 if self.options.no_value or self.should_suppress_value_header():
2465                     pass
2466                 else:
2467                     objrepr = object_description(self.object)
2468                     self.add_line('   :value: ' + objrepr, sourcename)
2469             except ValueError:
2470                 pass
2471 
2472     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2473         try:
2474             for cls in inspect.getmro(parent):
2475                 try:
2476                     module = safe_getattr(cls, '__module__')
2477                     qualname = safe_getattr(cls, '__qualname__')
2478 
2479                     analyzer = ModuleAnalyzer.for_module(module)
2480                     analyzer.analyze()
2481                     if qualname and self.objpath:
2482                         key = (qualname, attrname)
2483                         if key in analyzer.attr_docs:
2484                             return list(analyzer.attr_docs[key])
2485                 except (AttributeError, PycodeError):
2486                     pass
2487         except (AttributeError, PycodeError):
2488             pass
2489 
2490         return None
2491 
2492     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2493         # Check the attribute has a docstring-comment
2494         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2495         if comment:
2496             return [comment]
2497 
2498         try:
2499             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2500             # a docstring from the value which descriptor returns unexpectedly.
2501             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2502             orig = self.config.autodoc_inherit_docstrings
2503             self.config.autodoc_inherit_docstrings = False  # type: ignore
2504             return super().get_doc(encoding, ignore)
2505         finally:
2506             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2507 
2508     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2509                     ) -> None:
2510         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2511         # AttributeDocumenter.add_content()
2512         self.analyzer = None
2513 
2514         if more_content is None:
2515             more_content = StringList()
2516         self.update_content(more_content)
2517         super().add_content(more_content, no_docstring)
2518 
2519 
2520 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2521     """
2522     Specialized Documenter subclass for properties.
2523     """
2524     objtype = 'property'
2525     directivetype = 'method'
2526     member_order = 60
2527 
2528     # before AttributeDocumenter
2529     priority = AttributeDocumenter.priority + 1
2530 
2531     @classmethod
2532     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2533                             ) -> bool:
2534         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2535 
2536     def document_members(self, all_members: bool = False) -> None:
2537         pass
2538 
2539     def get_real_modname(self) -> str:
2540         return self.get_attr(self.parent or self.object, '__module__', None) \
2541             or self.modname
2542 
2543     def add_directive_header(self, sig: str) -> None:
2544         super().add_directive_header(sig)
2545         sourcename = self.get_sourcename()
2546         if inspect.isabstractmethod(self.object):
2547             self.add_line('   :abstractmethod:', sourcename)
2548         self.add_line('   :property:', sourcename)
2549 
2550 
2551 class NewTypeAttributeDocumenter(AttributeDocumenter):
2552     """
2553     Specialized Documenter subclass for NewTypes.
2554 
2555     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2556     function object.
2557     """
2558 
2559     objtype = 'newvarattribute'
2560     directivetype = 'attribute'
2561     priority = MethodDocumenter.priority + 1
2562 
2563     @classmethod
2564     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2565                             ) -> bool:
2566         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2567 
2568 
2569 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2570     """Returns registered Documenter classes"""
2571     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2572     return app.registry.documenters
2573 
2574 
2575 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2576     """Alternative getattr() for types"""
2577     for typ, func in app.registry.autodoc_attrgettrs.items():
2578         if isinstance(obj, typ):
2579             return func(obj, name, *defargs)
2580 
2581     return safe_getattr(obj, name, *defargs)
2582 
2583 
2584 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2585     if config.autodoc_member_order == 'alphabetic':
2586         # RemovedInSphinx50Warning
2587         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2588                           'instead of "alphabetic". Please update your setting.'))
2589         config.autodoc_member_order = 'alphabetical'  # type: ignore
2590 
2591 
2592 # for compatibility
2593 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2594 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2595 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2596 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2597 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2598 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2599 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2600 
2601 
2602 def setup(app: Sphinx) -> Dict[str, Any]:
2603     app.add_autodocumenter(ModuleDocumenter)
2604     app.add_autodocumenter(ClassDocumenter)
2605     app.add_autodocumenter(ExceptionDocumenter)
2606     app.add_autodocumenter(DataDocumenter)
2607     app.add_autodocumenter(NewTypeDataDocumenter)
2608     app.add_autodocumenter(FunctionDocumenter)
2609     app.add_autodocumenter(DecoratorDocumenter)
2610     app.add_autodocumenter(MethodDocumenter)
2611     app.add_autodocumenter(AttributeDocumenter)
2612     app.add_autodocumenter(PropertyDocumenter)
2613     app.add_autodocumenter(NewTypeAttributeDocumenter)
2614 
2615     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2616     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2617                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2618     app.add_config_value('autodoc_default_options', {}, True)
2619     app.add_config_value('autodoc_docstring_signature', True, True)
2620     app.add_config_value('autodoc_mock_imports', [], True)
2621     app.add_config_value('autodoc_typehints', "signature", True,
2622                          ENUM("signature", "description", "none"))
2623     app.add_config_value('autodoc_type_aliases', {}, True)
2624     app.add_config_value('autodoc_warningiserror', True, True)
2625     app.add_config_value('autodoc_inherit_docstrings', True, True)
2626     app.add_event('autodoc-before-process-signature')
2627     app.add_event('autodoc-process-docstring')
2628     app.add_event('autodoc-process-signature')
2629     app.add_event('autodoc-skip-member')
2630 
2631     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2632 
2633     app.setup_extension('sphinx.ext.autodoc.type_comment')
2634     app.setup_extension('sphinx.ext.autodoc.typehints')
2635 
2636     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>This file's functionality includes automatically documenting Python source code files. The modification needed here involves ensuring that when extracting docstrings that include `code-block` or `literalinclude` directives, an automatic dedent is applied to these blocks if they lack a specific `:dedent:` value. This change should gracefully handle existing documentation and new inclusions alike, promoting ease of documentation writing and consistency in documentation appearance.</intended_behavior>]
2025-10-15 12:21:04.786 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 12:21:04.786 | INFO     | Search-only: skipping patch selection
2025-10-15 12:21:04.886 | INFO     | Task sphinx-doc__sphinx-8684 completed successfully.
2025-10-15 12:21:04.887 | INFO     | No patch generated. You can try running ACR again.
