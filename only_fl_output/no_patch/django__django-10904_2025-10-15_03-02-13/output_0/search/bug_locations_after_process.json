[
    {
        "rel_file_path": "django/middleware/csrf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/middleware/csrf.py",
        "start": 1,
        "end": 327,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Cross Site Request Forgery Middleware.\n3 \n4 This module provides a middleware that implements protection\n5 against request forgeries from other sites.\n6 \"\"\"\n7 import logging\n8 import re\n9 import string\n10 from urllib.parse import urlparse\n11 \n12 from django.conf import settings\n13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured\n14 from django.urls import get_callable\n15 from django.utils.cache import patch_vary_headers\n16 from django.utils.crypto import constant_time_compare, get_random_string\n17 from django.utils.deprecation import MiddlewareMixin\n18 from django.utils.http import is_same_domain\n19 from django.utils.log import log_response\n20 \n21 logger = logging.getLogger('django.security.csrf')\n22 \n23 REASON_NO_REFERER = \"Referer checking failed - no Referer.\"\n24 REASON_BAD_REFERER = \"Referer checking failed - %s does not match any trusted origins.\"\n25 REASON_NO_CSRF_COOKIE = \"CSRF cookie not set.\"\n26 REASON_BAD_TOKEN = \"CSRF token missing or incorrect.\"\n27 REASON_MALFORMED_REFERER = \"Referer checking failed - Referer is malformed.\"\n28 REASON_INSECURE_REFERER = \"Referer checking failed - Referer is insecure while host is secure.\"\n29 \n30 CSRF_SECRET_LENGTH = 32\n31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH\n32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits\n33 CSRF_SESSION_KEY = '_csrftoken'\n34 \n35 \n36 def _get_failure_view():\n37     \"\"\"Return the view to be used for CSRF rejections.\"\"\"\n38     return get_callable(settings.CSRF_FAILURE_VIEW)\n39 \n40 \n41 def _get_new_csrf_string():\n42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)\n43 \n44 \n45 def _salt_cipher_secret(secret):\n46     \"\"\"\n47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a\n48     token by adding a salt and using it to encrypt the secret.\n49     \"\"\"\n50     salt = _get_new_csrf_string()\n51     chars = CSRF_ALLOWED_CHARS\n52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))\n53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)\n54     return salt + cipher\n55 \n56 \n57 def _unsalt_cipher_token(token):\n58     \"\"\"\n59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length\n60     CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt\n61     the second half to produce the original secret.\n62     \"\"\"\n63     salt = token[:CSRF_SECRET_LENGTH]\n64     token = token[CSRF_SECRET_LENGTH:]\n65     chars = CSRF_ALLOWED_CHARS\n66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))\n67     secret = ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok\n68     return secret\n69 \n70 \n71 def _get_new_csrf_token():\n72     return _salt_cipher_secret(_get_new_csrf_string())\n73 \n74 \n75 def get_token(request):\n76     \"\"\"\n77     Return the CSRF token required for a POST form. The token is an\n78     alphanumeric value. A new token is created if one is not already set.\n79 \n80     A side effect of calling this function is to make the csrf_protect\n81     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'\n82     header to the outgoing response.  For this reason, you may need to use this\n83     function lazily, as is done by the csrf context processor.\n84     \"\"\"\n85     if \"CSRF_COOKIE\" not in request.META:\n86         csrf_secret = _get_new_csrf_string()\n87         request.META[\"CSRF_COOKIE\"] = _salt_cipher_secret(csrf_secret)\n88     else:\n89         csrf_secret = _unsalt_cipher_token(request.META[\"CSRF_COOKIE\"])\n90     request.META[\"CSRF_COOKIE_USED\"] = True\n91     return _salt_cipher_secret(csrf_secret)\n92 \n93 \n94 def rotate_token(request):\n95     \"\"\"\n96     Change the CSRF token in use for a request - should be done on login\n97     for security purposes.\n98     \"\"\"\n99     request.META.update({\n100         \"CSRF_COOKIE_USED\": True,\n101         \"CSRF_COOKIE\": _get_new_csrf_token(),\n102     })\n103     request.csrf_cookie_needs_reset = True\n104 \n105 \n106 def _sanitize_token(token):\n107     # Allow only ASCII alphanumerics\n108     if re.search('[^a-zA-Z0-9]', token):\n109         return _get_new_csrf_token()\n110     elif len(token) == CSRF_TOKEN_LENGTH:\n111         return token\n112     elif len(token) == CSRF_SECRET_LENGTH:\n113         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH\n114         # alphanumeric characters. For backwards compatibility, accept\n115         # such values as unsalted secrets.\n116         # It's easier to salt here and be consistent later, rather than add\n117         # different code paths in the checks, although that might be a tad more\n118         # efficient.\n119         return _salt_cipher_secret(token)\n120     return _get_new_csrf_token()\n121 \n122 \n123 def _compare_salted_tokens(request_csrf_token, csrf_token):\n124     # Assume both arguments are sanitized -- that is, strings of\n125     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.\n126     return constant_time_compare(\n127         _unsalt_cipher_token(request_csrf_token),\n128         _unsalt_cipher_token(csrf_token),\n129     )\n130 \n131 \n132 class CsrfViewMiddleware(MiddlewareMixin):\n133     \"\"\"\n134     Require a present and correct csrfmiddlewaretoken for POST requests that\n135     have a CSRF cookie, and set an outgoing CSRF cookie.\n136 \n137     This middleware should be used in conjunction with the {% csrf_token %}\n138     template tag.\n139     \"\"\"\n140     # The _accept and _reject methods currently only exist for the sake of the\n141     # requires_csrf_token decorator.\n142     def _accept(self, request):\n143         # Avoid checking the request twice by adding a custom attribute to\n144         # request.  This will be relevant when both decorator and middleware\n145         # are used.\n146         request.csrf_processing_done = True\n147         return None\n148 \n149     def _reject(self, request, reason):\n150         response = _get_failure_view()(request, reason=reason)\n151         log_response(\n152             'Forbidden (%s): %s', reason, request.path,\n153             response=response,\n154             request=request,\n155             logger=logger,\n156         )\n157         return response\n158 \n159     def _get_token(self, request):\n160         if settings.CSRF_USE_SESSIONS:\n161             try:\n162                 return request.session.get(CSRF_SESSION_KEY)\n163             except AttributeError:\n164                 raise ImproperlyConfigured(\n165                     'CSRF_USE_SESSIONS is enabled, but request.session is not '\n166                     'set. SessionMiddleware must appear before CsrfViewMiddleware '\n167                     'in MIDDLEWARE%s.' % ('_CLASSES' if settings.MIDDLEWARE is None else '')\n168                 )\n169         else:\n170             try:\n171                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]\n172             except KeyError:\n173                 return None\n174 \n175             csrf_token = _sanitize_token(cookie_token)\n176             if csrf_token != cookie_token:\n177                 # Cookie token needed to be replaced;\n178                 # the cookie needs to be reset.\n179                 request.csrf_cookie_needs_reset = True\n180             return csrf_token\n181 \n182     def _set_token(self, request, response):\n183         if settings.CSRF_USE_SESSIONS:\n184             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:\n185                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']\n186         else:\n187             response.set_cookie(\n188                 settings.CSRF_COOKIE_NAME,\n189                 request.META['CSRF_COOKIE'],\n190                 max_age=settings.CSRF_COOKIE_AGE,\n191                 domain=settings.CSRF_COOKIE_DOMAIN,\n192                 path=settings.CSRF_COOKIE_PATH,\n193                 secure=settings.CSRF_COOKIE_SECURE,\n194                 httponly=settings.CSRF_COOKIE_HTTPONLY,\n195                 samesite=settings.CSRF_COOKIE_SAMESITE,\n196             )\n197             # Set the Vary header since content varies with the CSRF cookie.\n198             patch_vary_headers(response, ('Cookie',))\n199 \n200     def process_request(self, request):\n201         csrf_token = self._get_token(request)\n202         if csrf_token is not None:\n203             # Use same token next time.\n204             request.META['CSRF_COOKIE'] = csrf_token\n205 \n206     def process_view(self, request, callback, callback_args, callback_kwargs):\n207         if getattr(request, 'csrf_processing_done', False):\n208             return None\n209 \n210         # Wait until request.META[\"CSRF_COOKIE\"] has been manipulated before\n211         # bailing out, so that get_token still works\n212         if getattr(callback, 'csrf_exempt', False):\n213             return None\n214 \n215         # Assume that anything not defined as 'safe' by RFC7231 needs protection\n216         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):\n217             if getattr(request, '_dont_enforce_csrf_checks', False):\n218                 # Mechanism to turn off CSRF checks for test suite.\n219                 # It comes after the creation of CSRF cookies, so that\n220                 # everything else continues to work exactly the same\n221                 # (e.g. cookies are sent, etc.), but before any\n222                 # branches that call reject().\n223                 return self._accept(request)\n224 \n225             if request.is_secure():\n226                 # Suppose user visits http://example.com/\n227                 # An active network attacker (man-in-the-middle, MITM) sends a\n228                 # POST form that targets https://example.com/detonate-bomb/ and\n229                 # submits it via JavaScript.\n230                 #\n231                 # The attacker will need to provide a CSRF cookie and token, but\n232                 # that's no problem for a MITM and the session-independent\n233                 # secret we're using. So the MITM can circumvent the CSRF\n234                 # protection. This is true for any HTTP connection, but anyone\n235                 # using HTTPS expects better! For this reason, for\n236                 # https://example.com/ we need additional protection that treats\n237                 # http://example.com/ as completely untrusted. Under HTTPS,\n238                 # Barth et al. found that the Referer header is missing for\n239                 # same-domain requests in only about 0.2% of cases or less, so\n240                 # we can use strict Referer checking.\n241                 referer = request.META.get('HTTP_REFERER')\n242                 if referer is None:\n243                     return self._reject(request, REASON_NO_REFERER)\n244 \n245                 referer = urlparse(referer)\n246 \n247                 # Make sure we have a valid URL for Referer.\n248                 if '' in (referer.scheme, referer.netloc):\n249                     return self._reject(request, REASON_MALFORMED_REFERER)\n250 \n251                 # Ensure that our Referer is also secure.\n252                 if referer.scheme != 'https':\n253                     return self._reject(request, REASON_INSECURE_REFERER)\n254 \n255                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match\n256                 # match on host:port. If not, obey the cookie rules (or those\n257                 # for the session cookie, if CSRF_USE_SESSIONS).\n258                 good_referer = (\n259                     settings.SESSION_COOKIE_DOMAIN\n260                     if settings.CSRF_USE_SESSIONS\n261                     else settings.CSRF_COOKIE_DOMAIN\n262                 )\n263                 if good_referer is not None:\n264                     server_port = request.get_port()\n265                     if server_port not in ('443', '80'):\n266                         good_referer = '%s:%s' % (good_referer, server_port)\n267                 else:\n268                     try:\n269                         # request.get_host() includes the port.\n270                         good_referer = request.get_host()\n271                     except DisallowedHost:\n272                         pass\n273 \n274                 # Create a list of all acceptable HTTP referers, including the\n275                 # current host if it's permitted by ALLOWED_HOSTS.\n276                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)\n277                 if good_referer is not None:\n278                     good_hosts.append(good_referer)\n279 \n280                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):\n281                     reason = REASON_BAD_REFERER % referer.geturl()\n282                     return self._reject(request, reason)\n283 \n284             csrf_token = request.META.get('CSRF_COOKIE')\n285             if csrf_token is None:\n286                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,\n287                 # and in this way we can avoid all CSRF attacks, including login\n288                 # CSRF.\n289                 return self._reject(request, REASON_NO_CSRF_COOKIE)\n290 \n291             # Check non-cookie token for match.\n292             request_csrf_token = \"\"\n293             if request.method == \"POST\":\n294                 try:\n295                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')\n296                 except IOError:\n297                     # Handle a broken connection before we've completed reading\n298                     # the POST data. process_view shouldn't raise any\n299                     # exceptions, so we'll ignore and serve the user a 403\n300                     # (assuming they're still listening, which they probably\n301                     # aren't because of the error).\n302                     pass\n303 \n304             if request_csrf_token == \"\":\n305                 # Fall back to X-CSRFToken, to make things easier for AJAX,\n306                 # and possible for PUT/DELETE.\n307                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')\n308 \n309             request_csrf_token = _sanitize_token(request_csrf_token)\n310             if not _compare_salted_tokens(request_csrf_token, csrf_token):\n311                 return self._reject(request, REASON_BAD_TOKEN)\n312 \n313         return self._accept(request)\n314 \n315     def process_response(self, request, response):\n316         if not getattr(request, 'csrf_cookie_needs_reset', False):\n317             if getattr(response, 'csrf_cookie_set', False):\n318                 return response\n319 \n320         if not request.META.get(\"CSRF_COOKIE_USED\", False):\n321             return response\n322 \n323         # Set the CSRF cookie even if it's already set, so we renew\n324         # the expiry timer.\n325         self._set_token(request, response)\n326         response.csrf_cookie_set = True\n327         return response\n",
        "intended_behavior": "Replace instances of `IOError` with `OSError`. This change will handle exceptions related to issues such as reading and writing CSRF tokens to the underlying storage mechanism while preserving the existing functionality of CSRF middleware exception handling."
    },
    {
        "rel_file_path": "django/contrib/gis/geos/libgeos.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/contrib/gis/geos/libgeos.py",
        "start": 21,
        "end": 71,
        "class_name": null,
        "method_name": "load_geos",
        "code": "21 def load_geos():\n22     # Custom library path set?\n23     try:\n24         from django.conf import settings\n25         lib_path = settings.GEOS_LIBRARY_PATH\n26     except (AttributeError, EnvironmentError,\n27             ImportError, ImproperlyConfigured):\n28         lib_path = None\n29 \n30     # Setting the appropriate names for the GEOS-C library.\n31     if lib_path:\n32         lib_names = None\n33     elif os.name == 'nt':\n34         # Windows NT libraries\n35         lib_names = ['geos_c', 'libgeos_c-1']\n36     elif os.name == 'posix':\n37         # *NIX libraries\n38         lib_names = ['geos_c', 'GEOS']\n39     else:\n40         raise ImportError('Unsupported OS \"%s\"' % os.name)\n41 \n42     # Using the ctypes `find_library` utility to find the path to the GEOS\n43     # shared library.  This is better than manually specifying each library name\n44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).\n45     if lib_names:\n46         for lib_name in lib_names:\n47             lib_path = find_library(lib_name)\n48             if lib_path is not None:\n49                 break\n50 \n51     # No GEOS library could be found.\n52     if lib_path is None:\n53         raise ImportError(\n54             'Could not find the GEOS library (tried \"%s\"). '\n55             'Try setting GEOS_LIBRARY_PATH in your settings.' %\n56             '\", \"'.join(lib_names)\n57         )\n58     # Getting the GEOS C library.  The C interface (CDLL) is used for\n59     # both *NIX and Windows.\n60     # See the GEOS C API source code for more details on the library function calls:\n61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html\n62     _lgeos = CDLL(lib_path)\n63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r\n64     # routines.  These functions aren't actually called until they are\n65     # attached to a GEOS context handle -- this actually occurs in\n66     # geos/prototypes/threadsafe.py.\n67     _lgeos.initGEOS_r.restype = CONTEXT_PTR\n68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]\n69     # Set restype for compatibility across 32 and 64-bit platforms.\n70     _lgeos.GEOSversion.restype = c_char_p\n71     return _lgeos\n",
        "intended_behavior": "Replace `EnvironmentError` with `OSError` in the exception handling block. This ensures that any issues related to loading the GEOS library, such as file not found or access errors, remain effectively caught under the unified `OSError` class, keeping the geographic information system functionalities intact."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 42,
        "end": 74,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n",
        "intended_behavior": "Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 59,
        "end": 63,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n",
        "intended_behavior": "Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 13,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(ConsoleEmailBackend):\n14     def __init__(self, *args, file_path=None, **kwargs):\n15         self._fname = None\n16         if file_path is not None:\n17             self.file_path = file_path\n18         else:\n19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)\n20         # Make sure self.file_path is a string.\n21         if not isinstance(self.file_path, str):\n22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)\n23         self.file_path = os.path.abspath(self.file_path)\n24         # Make sure that self.file_path is a directory if it exists.\n25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):\n26             raise ImproperlyConfigured(\n27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path\n28             )\n29         # Try to create it, if it not exists.\n30         elif not os.path.exists(self.file_path):\n31             try:\n32                 os.makedirs(self.file_path)\n33             except OSError as err:\n34                 raise ImproperlyConfigured(\n35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)\n36                 )\n37         # Make sure that self.file_path is writable.\n38         if not os.access(self.file_path, os.W_OK):\n39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)\n40         # Finally, call super().\n41         # Since we're using the console-based backend as a base,\n42         # force the stream to be None, so we don't default to stdout\n43         kwargs['stream'] = None\n44         super().__init__(*args, **kwargs)\n45 \n46     def write_message(self, message):\n47         self.stream.write(message.message().as_bytes() + b'\\n')\n48         self.stream.write(b'-' * 79)\n49         self.stream.write(b'\\n')\n50 \n51     def _get_filename(self):\n52         \"\"\"Return a unique file name.\"\"\"\n53         if self._fname is None:\n54             timestamp = datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n55             fname = \"%s-%s.log\" % (timestamp, abs(id(self)))\n56             self._fname = os.path.join(self.file_path, fname)\n57         return self._fname\n58 \n59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n64 \n65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/management/commands/runserver.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/management/commands/runserver.py",
        "start": 1,
        "end": 161,
        "class_name": null,
        "method_name": null,
        "code": "1 import errno\n2 import os\n3 import re\n4 import socket\n5 import sys\n6 from datetime import datetime\n7 \n8 from django.conf import settings\n9 from django.core.management.base import BaseCommand, CommandError\n10 from django.core.servers.basehttp import (\n11     WSGIServer, get_internal_wsgi_application, run,\n12 )\n13 from django.utils import autoreload\n14 \n15 naiveip_re = re.compile(r\"\"\"^(?:\n16 (?P<addr>\n17     (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address\n18     (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address\n19     (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN\n20 ):)?(?P<port>\\d+)$\"\"\", re.X)\n21 \n22 \n23 class Command(BaseCommand):\n24     help = \"Starts a lightweight Web server for development.\"\n25 \n26     # Validation is called explicitly each time the server is reloaded.\n27     requires_system_checks = False\n28     stealth_options = ('shutdown_message',)\n29 \n30     default_addr = '127.0.0.1'\n31     default_addr_ipv6 = '::1'\n32     default_port = '8000'\n33     protocol = 'http'\n34     server_cls = WSGIServer\n35 \n36     def add_arguments(self, parser):\n37         parser.add_argument(\n38             'addrport', nargs='?',\n39             help='Optional port number, or ipaddr:port'\n40         )\n41         parser.add_argument(\n42             '--ipv6', '-6', action='store_true', dest='use_ipv6',\n43             help='Tells Django to use an IPv6 address.',\n44         )\n45         parser.add_argument(\n46             '--nothreading', action='store_false', dest='use_threading',\n47             help='Tells Django to NOT use threading.',\n48         )\n49         parser.add_argument(\n50             '--noreload', action='store_false', dest='use_reloader',\n51             help='Tells Django to NOT use the auto-reloader.',\n52         )\n53 \n54     def execute(self, *args, **options):\n55         if options['no_color']:\n56             # We rely on the environment because it's currently the only\n57             # way to reach WSGIRequestHandler. This seems an acceptable\n58             # compromise considering `runserver` runs indefinitely.\n59             os.environ[\"DJANGO_COLORS\"] = \"nocolor\"\n60         super().execute(*args, **options)\n61 \n62     def get_handler(self, *args, **options):\n63         \"\"\"Return the default WSGI handler for the runner.\"\"\"\n64         return get_internal_wsgi_application()\n65 \n66     def handle(self, *args, **options):\n67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:\n68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')\n69 \n70         self.use_ipv6 = options['use_ipv6']\n71         if self.use_ipv6 and not socket.has_ipv6:\n72             raise CommandError('Your Python does not support IPv6.')\n73         self._raw_ipv6 = False\n74         if not options['addrport']:\n75             self.addr = ''\n76             self.port = self.default_port\n77         else:\n78             m = re.match(naiveip_re, options['addrport'])\n79             if m is None:\n80                 raise CommandError('\"%s\" is not a valid port number '\n81                                    'or address:port pair.' % options['addrport'])\n82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()\n83             if not self.port.isdigit():\n84                 raise CommandError(\"%r is not a valid port number.\" % self.port)\n85             if self.addr:\n86                 if _ipv6:\n87                     self.addr = self.addr[1:-1]\n88                     self.use_ipv6 = True\n89                     self._raw_ipv6 = True\n90                 elif self.use_ipv6 and not _fqdn:\n91                     raise CommandError('\"%s\" is not a valid IPv6 address.' % self.addr)\n92         if not self.addr:\n93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr\n94             self._raw_ipv6 = self.use_ipv6\n95         self.run(**options)\n96 \n97     def run(self, **options):\n98         \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n99         use_reloader = options['use_reloader']\n100 \n101         if use_reloader:\n102             autoreload.run_with_reloader(self.inner_run, **options)\n103         else:\n104             self.inner_run(None, **options)\n105 \n106     def inner_run(self, *args, **options):\n107         # If an exception was silenced in ManagementUtility.execute in order\n108         # to be raised in the child process, raise it now.\n109         autoreload.raise_last_exception()\n110 \n111         threading = options['use_threading']\n112         # 'shutdown_message' is a stealth option.\n113         shutdown_message = options.get('shutdown_message', '')\n114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n115 \n116         self.stdout.write(\"Performing system checks\u2026\\n\\n\")\n117         self.check(display_num_errors=True)\n118         # Need to check migrations here, so can't use the\n119         # requires_migrations_check attribute.\n120         self.check_migrations()\n121         now = datetime.now().strftime('%B %d, %Y - %X')\n122         self.stdout.write(now)\n123         self.stdout.write((\n124             \"Django version %(version)s, using settings %(settings)r\\n\"\n125             \"Starting development server at %(protocol)s://%(addr)s:%(port)s/\\n\"\n126             \"Quit the server with %(quit_command)s.\\n\"\n127         ) % {\n128             \"version\": self.get_version(),\n129             \"settings\": settings.SETTINGS_MODULE,\n130             \"protocol\": self.protocol,\n131             \"addr\": '[%s]' % self.addr if self._raw_ipv6 else self.addr,\n132             \"port\": self.port,\n133             \"quit_command\": quit_command,\n134         })\n135 \n136         try:\n137             handler = self.get_handler(*args, **options)\n138             run(self.addr, int(self.port), handler,\n139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)\n140         except socket.error as e:\n141             # Use helpful error messages instead of ugly tracebacks.\n142             ERRORS = {\n143                 errno.EACCES: \"You don't have permission to access that port.\",\n144                 errno.EADDRINUSE: \"That port is already in use.\",\n145                 errno.EADDRNOTAVAIL: \"That IP address can't be assigned to.\",\n146             }\n147             try:\n148                 error_text = ERRORS[e.errno]\n149             except KeyError:\n150                 error_text = e\n151             self.stderr.write(\"Error: %s\" % error_text)\n152             # Need to use an OS exit because sys.exit doesn't work in a thread\n153             os._exit(1)\n154         except KeyboardInterrupt:\n155             if shutdown_message:\n156                 self.stdout.write(shutdown_message)\n157             sys.exit(0)\n158 \n159 \n160 # Kept for backward compatibility\n161 BaseRunserverCommand = Command\n",
        "intended_behavior": "Substitute `socket.error` with `OSError` where applicable. This adjustment will cater to network issues that may arise during the server run-time, like port binding errors, ensuring the server command's robustness against such failures."
    }
]