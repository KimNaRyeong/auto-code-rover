2025-10-15 03:02:14.149 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 03:02:18.871 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=344, output_tokens=12, cost=0.003800
2025-10-15 03:02:18.872 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 03:02:18.875 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:02:23.791 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=653, output_tokens=209, cost=0.012800
2025-10-15 03:02:23.808 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:02:27.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=563, output_tokens=80, cost=0.008030
2025-10-15 03:02:27.202 | DEBUG    | Extracted a valid json.
2025-10-15 03:02:27.202 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"IOError\")",
        "search_code(\"EnvironmentError\")",
        "search_code(\"WindowsError\")",
        "search_code(\"mmap.error\")",
        "search_code(\"socket.error\")",
        "search_code(\"select.error\")",
        "search_code(\"SMTPException\")"
    ],
    "bug_locations": []
}
2025-10-15 03:02:27.360 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 03:02:27.361 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 03:02:42.835 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1893, output_tokens=731, cost=0.040860
2025-10-15 03:02:42.843 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 03:03:00.075 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2840, output_tokens=433, cost=0.041390
2025-10-15 03:03:00.085 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 03:03:09.705 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=787, output_tokens=388, cost=0.019510
2025-10-15 03:03:09.706 | DEBUG    | Extracted a valid json.
2025-10-15 03:03:09.706 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/middleware/csrf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Replace instances of `IOError` with `OSError`. This change will handle exceptions related to issues such as reading and writing CSRF tokens to the underlying storage mechanism while preserving the existing functionality of CSRF middleware exception handling."
        },
        {
            "file": "django/contrib/gis/geos/libgeos.py",
            "class": "",
            "method": "load_geos",
            "intended_behavior": "Replace `EnvironmentError` with `OSError` in the exception handling block. This ensures that any issues related to loading the GEOS library, such as file not found or access errors, remain effectively caught under the unified `OSError` class, keeping the geographic information system functionalities intact."
        },
        {
            "file": "django/core/mail/backends/smtp.py",
            "class": "EmailBackend",
            "method": "open",
            "intended_behavior": "Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections."
        },
        {
            "file": "django/core/management/commands/runserver.py",
            "class": "",
            "method": "",
            "intended_behavior": "Substitute `socket.error` with `OSError` where applicable. This adjustment will cater to network issues that may arise during the server run-time, like port binding errors, ensuring the server command's robustness against such failures."
        }
    ]
}
2025-10-15 03:03:09.717 | DEBUG    | Bug location extracted successfully: [<file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _salt_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a salt and using it to encrypt the secret.
49     """
50     salt = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return salt + cipher
55 
56 
57 def _unsalt_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt
61     the second half to produce the original secret.
62     """
63     salt = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))
67     secret = ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68     return secret
69 
70 
71 def _get_new_csrf_token():
72     return _salt_cipher_secret(_get_new_csrf_string())
73 
74 
75 def get_token(request):
76     """
77     Return the CSRF token required for a POST form. The token is an
78     alphanumeric value. A new token is created if one is not already set.
79 
80     A side effect of calling this function is to make the csrf_protect
81     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
82     header to the outgoing response.  For this reason, you may need to use this
83     function lazily, as is done by the csrf context processor.
84     """
85     if "CSRF_COOKIE" not in request.META:
86         csrf_secret = _get_new_csrf_string()
87         request.META["CSRF_COOKIE"] = _salt_cipher_secret(csrf_secret)
88     else:
89         csrf_secret = _unsalt_cipher_token(request.META["CSRF_COOKIE"])
90     request.META["CSRF_COOKIE_USED"] = True
91     return _salt_cipher_secret(csrf_secret)
92 
93 
94 def rotate_token(request):
95     """
96     Change the CSRF token in use for a request - should be done on login
97     for security purposes.
98     """
99     request.META.update({
100         "CSRF_COOKIE_USED": True,
101         "CSRF_COOKIE": _get_new_csrf_token(),
102     })
103     request.csrf_cookie_needs_reset = True
104 
105 
106 def _sanitize_token(token):
107     # Allow only ASCII alphanumerics
108     if re.search('[^a-zA-Z0-9]', token):
109         return _get_new_csrf_token()
110     elif len(token) == CSRF_TOKEN_LENGTH:
111         return token
112     elif len(token) == CSRF_SECRET_LENGTH:
113         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
114         # alphanumeric characters. For backwards compatibility, accept
115         # such values as unsalted secrets.
116         # It's easier to salt here and be consistent later, rather than add
117         # different code paths in the checks, although that might be a tad more
118         # efficient.
119         return _salt_cipher_secret(token)
120     return _get_new_csrf_token()
121 
122 
123 def _compare_salted_tokens(request_csrf_token, csrf_token):
124     # Assume both arguments are sanitized -- that is, strings of
125     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
126     return constant_time_compare(
127         _unsalt_cipher_token(request_csrf_token),
128         _unsalt_cipher_token(csrf_token),
129     )
130 
131 
132 class CsrfViewMiddleware(MiddlewareMixin):
133     """
134     Require a present and correct csrfmiddlewaretoken for POST requests that
135     have a CSRF cookie, and set an outgoing CSRF cookie.
136 
137     This middleware should be used in conjunction with the {% csrf_token %}
138     template tag.
139     """
140     # The _accept and _reject methods currently only exist for the sake of the
141     # requires_csrf_token decorator.
142     def _accept(self, request):
143         # Avoid checking the request twice by adding a custom attribute to
144         # request.  This will be relevant when both decorator and middleware
145         # are used.
146         request.csrf_processing_done = True
147         return None
148 
149     def _reject(self, request, reason):
150         response = _get_failure_view()(request, reason=reason)
151         log_response(
152             'Forbidden (%s): %s', reason, request.path,
153             response=response,
154             request=request,
155             logger=logger,
156         )
157         return response
158 
159     def _get_token(self, request):
160         if settings.CSRF_USE_SESSIONS:
161             try:
162                 return request.session.get(CSRF_SESSION_KEY)
163             except AttributeError:
164                 raise ImproperlyConfigured(
165                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
166                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
167                     'in MIDDLEWARE%s.' % ('_CLASSES' if settings.MIDDLEWARE is None else '')
168                 )
169         else:
170             try:
171                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
172             except KeyError:
173                 return None
174 
175             csrf_token = _sanitize_token(cookie_token)
176             if csrf_token != cookie_token:
177                 # Cookie token needed to be replaced;
178                 # the cookie needs to be reset.
179                 request.csrf_cookie_needs_reset = True
180             return csrf_token
181 
182     def _set_token(self, request, response):
183         if settings.CSRF_USE_SESSIONS:
184             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
185                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
186         else:
187             response.set_cookie(
188                 settings.CSRF_COOKIE_NAME,
189                 request.META['CSRF_COOKIE'],
190                 max_age=settings.CSRF_COOKIE_AGE,
191                 domain=settings.CSRF_COOKIE_DOMAIN,
192                 path=settings.CSRF_COOKIE_PATH,
193                 secure=settings.CSRF_COOKIE_SECURE,
194                 httponly=settings.CSRF_COOKIE_HTTPONLY,
195                 samesite=settings.CSRF_COOKIE_SAMESITE,
196             )
197             # Set the Vary header since content varies with the CSRF cookie.
198             patch_vary_headers(response, ('Cookie',))
199 
200     def process_request(self, request):
201         csrf_token = self._get_token(request)
202         if csrf_token is not None:
203             # Use same token next time.
204             request.META['CSRF_COOKIE'] = csrf_token
205 
206     def process_view(self, request, callback, callback_args, callback_kwargs):
207         if getattr(request, 'csrf_processing_done', False):
208             return None
209 
210         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
211         # bailing out, so that get_token still works
212         if getattr(callback, 'csrf_exempt', False):
213             return None
214 
215         # Assume that anything not defined as 'safe' by RFC7231 needs protection
216         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
217             if getattr(request, '_dont_enforce_csrf_checks', False):
218                 # Mechanism to turn off CSRF checks for test suite.
219                 # It comes after the creation of CSRF cookies, so that
220                 # everything else continues to work exactly the same
221                 # (e.g. cookies are sent, etc.), but before any
222                 # branches that call reject().
223                 return self._accept(request)
224 
225             if request.is_secure():
226                 # Suppose user visits http://example.com/
227                 # An active network attacker (man-in-the-middle, MITM) sends a
228                 # POST form that targets https://example.com/detonate-bomb/ and
229                 # submits it via JavaScript.
230                 #
231                 # The attacker will need to provide a CSRF cookie and token, but
232                 # that's no problem for a MITM and the session-independent
233                 # secret we're using. So the MITM can circumvent the CSRF
234                 # protection. This is true for any HTTP connection, but anyone
235                 # using HTTPS expects better! For this reason, for
236                 # https://example.com/ we need additional protection that treats
237                 # http://example.com/ as completely untrusted. Under HTTPS,
238                 # Barth et al. found that the Referer header is missing for
239                 # same-domain requests in only about 0.2% of cases or less, so
240                 # we can use strict Referer checking.
241                 referer = request.META.get('HTTP_REFERER')
242                 if referer is None:
243                     return self._reject(request, REASON_NO_REFERER)
244 
245                 referer = urlparse(referer)
246 
247                 # Make sure we have a valid URL for Referer.
248                 if '' in (referer.scheme, referer.netloc):
249                     return self._reject(request, REASON_MALFORMED_REFERER)
250 
251                 # Ensure that our Referer is also secure.
252                 if referer.scheme != 'https':
253                     return self._reject(request, REASON_INSECURE_REFERER)
254 
255                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
256                 # match on host:port. If not, obey the cookie rules (or those
257                 # for the session cookie, if CSRF_USE_SESSIONS).
258                 good_referer = (
259                     settings.SESSION_COOKIE_DOMAIN
260                     if settings.CSRF_USE_SESSIONS
261                     else settings.CSRF_COOKIE_DOMAIN
262                 )
263                 if good_referer is not None:
264                     server_port = request.get_port()
265                     if server_port not in ('443', '80'):
266                         good_referer = '%s:%s' % (good_referer, server_port)
267                 else:
268                     try:
269                         # request.get_host() includes the port.
270                         good_referer = request.get_host()
271                     except DisallowedHost:
272                         pass
273 
274                 # Create a list of all acceptable HTTP referers, including the
275                 # current host if it's permitted by ALLOWED_HOSTS.
276                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
277                 if good_referer is not None:
278                     good_hosts.append(good_referer)
279 
280                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
281                     reason = REASON_BAD_REFERER % referer.geturl()
282                     return self._reject(request, reason)
283 
284             csrf_token = request.META.get('CSRF_COOKIE')
285             if csrf_token is None:
286                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
287                 # and in this way we can avoid all CSRF attacks, including login
288                 # CSRF.
289                 return self._reject(request, REASON_NO_CSRF_COOKIE)
290 
291             # Check non-cookie token for match.
292             request_csrf_token = ""
293             if request.method == "POST":
294                 try:
295                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
296                 except IOError:
297                     # Handle a broken connection before we've completed reading
298                     # the POST data. process_view shouldn't raise any
299                     # exceptions, so we'll ignore and serve the user a 403
300                     # (assuming they're still listening, which they probably
301                     # aren't because of the error).
302                     pass
303 
304             if request_csrf_token == "":
305                 # Fall back to X-CSRFToken, to make things easier for AJAX,
306                 # and possible for PUT/DELETE.
307                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
308 
309             request_csrf_token = _sanitize_token(request_csrf_token)
310             if not _compare_salted_tokens(request_csrf_token, csrf_token):
311                 return self._reject(request, REASON_BAD_TOKEN)
312 
313         return self._accept(request)
314 
315     def process_response(self, request, response):
316         if not getattr(request, 'csrf_cookie_needs_reset', False):
317             if getattr(response, 'csrf_cookie_set', False):
318                 return response
319 
320         if not request.META.get("CSRF_COOKIE_USED", False):
321             return response
322 
323         # Set the CSRF cookie even if it's already set, so we renew
324         # the expiry timer.
325         self._set_token(request, response)
326         response.csrf_cookie_set = True
327         return response

</code><intended_behavior>Replace instances of `IOError` with `OSError`. This change will handle exceptions related to issues such as reading and writing CSRF tokens to the underlying storage mechanism while preserving the existing functionality of CSRF middleware exception handling.</intended_behavior>, <file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>load_geos</method>
<code>
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos

</code><intended_behavior>Replace `EnvironmentError` with `OSError` in the exception handling block. This ensures that any issues related to loading the GEOS library, such as file not found or access errors, remain effectively caught under the unified `OSError` class, keeping the geographic information system functionalities intact.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise

</code><intended_behavior>Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False

</code><intended_behavior>Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/management/commands/runserver.py</file>
<class>None</class>
<method>None</method>
<code>
1 import errno
2 import os
3 import re
4 import socket
5 import sys
6 from datetime import datetime
7 
8 from django.conf import settings
9 from django.core.management.base import BaseCommand, CommandError
10 from django.core.servers.basehttp import (
11     WSGIServer, get_internal_wsgi_application, run,
12 )
13 from django.utils import autoreload
14 
15 naiveip_re = re.compile(r"""^(?:
16 (?P<addr>
17     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
18     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
19     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
20 ):)?(?P<port>\d+)$""", re.X)
21 
22 
23 class Command(BaseCommand):
24     help = "Starts a lightweight Web server for development."
25 
26     # Validation is called explicitly each time the server is reloaded.
27     requires_system_checks = False
28     stealth_options = ('shutdown_message',)
29 
30     default_addr = '127.0.0.1'
31     default_addr_ipv6 = '::1'
32     default_port = '8000'
33     protocol = 'http'
34     server_cls = WSGIServer
35 
36     def add_arguments(self, parser):
37         parser.add_argument(
38             'addrport', nargs='?',
39             help='Optional port number, or ipaddr:port'
40         )
41         parser.add_argument(
42             '--ipv6', '-6', action='store_true', dest='use_ipv6',
43             help='Tells Django to use an IPv6 address.',
44         )
45         parser.add_argument(
46             '--nothreading', action='store_false', dest='use_threading',
47             help='Tells Django to NOT use threading.',
48         )
49         parser.add_argument(
50             '--noreload', action='store_false', dest='use_reloader',
51             help='Tells Django to NOT use the auto-reloader.',
52         )
53 
54     def execute(self, *args, **options):
55         if options['no_color']:
56             # We rely on the environment because it's currently the only
57             # way to reach WSGIRequestHandler. This seems an acceptable
58             # compromise considering `runserver` runs indefinitely.
59             os.environ["DJANGO_COLORS"] = "nocolor"
60         super().execute(*args, **options)
61 
62     def get_handler(self, *args, **options):
63         """Return the default WSGI handler for the runner."""
64         return get_internal_wsgi_application()
65 
66     def handle(self, *args, **options):
67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:
68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')
69 
70         self.use_ipv6 = options['use_ipv6']
71         if self.use_ipv6 and not socket.has_ipv6:
72             raise CommandError('Your Python does not support IPv6.')
73         self._raw_ipv6 = False
74         if not options['addrport']:
75             self.addr = ''
76             self.port = self.default_port
77         else:
78             m = re.match(naiveip_re, options['addrport'])
79             if m is None:
80                 raise CommandError('"%s" is not a valid port number '
81                                    'or address:port pair.' % options['addrport'])
82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()
83             if not self.port.isdigit():
84                 raise CommandError("%r is not a valid port number." % self.port)
85             if self.addr:
86                 if _ipv6:
87                     self.addr = self.addr[1:-1]
88                     self.use_ipv6 = True
89                     self._raw_ipv6 = True
90                 elif self.use_ipv6 and not _fqdn:
91                     raise CommandError('"%s" is not a valid IPv6 address.' % self.addr)
92         if not self.addr:
93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr
94             self._raw_ipv6 = self.use_ipv6
95         self.run(**options)
96 
97     def run(self, **options):
98         """Run the server, using the autoreloader if needed."""
99         use_reloader = options['use_reloader']
100 
101         if use_reloader:
102             autoreload.run_with_reloader(self.inner_run, **options)
103         else:
104             self.inner_run(None, **options)
105 
106     def inner_run(self, *args, **options):
107         # If an exception was silenced in ManagementUtility.execute in order
108         # to be raised in the child process, raise it now.
109         autoreload.raise_last_exception()
110 
111         threading = options['use_threading']
112         # 'shutdown_message' is a stealth option.
113         shutdown_message = options.get('shutdown_message', '')
114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'
115 
116         self.stdout.write("Performing system checks…\n\n")
117         self.check(display_num_errors=True)
118         # Need to check migrations here, so can't use the
119         # requires_migrations_check attribute.
120         self.check_migrations()
121         now = datetime.now().strftime('%B %d, %Y - %X')
122         self.stdout.write(now)
123         self.stdout.write((
124             "Django version %(version)s, using settings %(settings)r\n"
125             "Starting development server at %(protocol)s://%(addr)s:%(port)s/\n"
126             "Quit the server with %(quit_command)s.\n"
127         ) % {
128             "version": self.get_version(),
129             "settings": settings.SETTINGS_MODULE,
130             "protocol": self.protocol,
131             "addr": '[%s]' % self.addr if self._raw_ipv6 else self.addr,
132             "port": self.port,
133             "quit_command": quit_command,
134         })
135 
136         try:
137             handler = self.get_handler(*args, **options)
138             run(self.addr, int(self.port), handler,
139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)
140         except socket.error as e:
141             # Use helpful error messages instead of ugly tracebacks.
142             ERRORS = {
143                 errno.EACCES: "You don't have permission to access that port.",
144                 errno.EADDRINUSE: "That port is already in use.",
145                 errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
146             }
147             try:
148                 error_text = ERRORS[e.errno]
149             except KeyError:
150                 error_text = e
151             self.stderr.write("Error: %s" % error_text)
152             # Need to use an OS exit because sys.exit doesn't work in a thread
153             os._exit(1)
154         except KeyboardInterrupt:
155             if shutdown_message:
156                 self.stdout.write(shutdown_message)
157             sys.exit(0)
158 
159 
160 # Kept for backward compatibility
161 BaseRunserverCommand = Command

</code><intended_behavior>Substitute `socket.error` with `OSError` where applicable. This adjustment will cater to network issues that may arise during the server run-time, like port binding errors, ensuring the server command's robustness against such failures.</intended_behavior>]
2025-10-15 03:03:09.717 | INFO     | Search completed. Bug locations: [<file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _salt_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a salt and using it to encrypt the secret.
49     """
50     salt = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return salt + cipher
55 
56 
57 def _unsalt_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt
61     the second half to produce the original secret.
62     """
63     salt = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))
67     secret = ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68     return secret
69 
70 
71 def _get_new_csrf_token():
72     return _salt_cipher_secret(_get_new_csrf_string())
73 
74 
75 def get_token(request):
76     """
77     Return the CSRF token required for a POST form. The token is an
78     alphanumeric value. A new token is created if one is not already set.
79 
80     A side effect of calling this function is to make the csrf_protect
81     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
82     header to the outgoing response.  For this reason, you may need to use this
83     function lazily, as is done by the csrf context processor.
84     """
85     if "CSRF_COOKIE" not in request.META:
86         csrf_secret = _get_new_csrf_string()
87         request.META["CSRF_COOKIE"] = _salt_cipher_secret(csrf_secret)
88     else:
89         csrf_secret = _unsalt_cipher_token(request.META["CSRF_COOKIE"])
90     request.META["CSRF_COOKIE_USED"] = True
91     return _salt_cipher_secret(csrf_secret)
92 
93 
94 def rotate_token(request):
95     """
96     Change the CSRF token in use for a request - should be done on login
97     for security purposes.
98     """
99     request.META.update({
100         "CSRF_COOKIE_USED": True,
101         "CSRF_COOKIE": _get_new_csrf_token(),
102     })
103     request.csrf_cookie_needs_reset = True
104 
105 
106 def _sanitize_token(token):
107     # Allow only ASCII alphanumerics
108     if re.search('[^a-zA-Z0-9]', token):
109         return _get_new_csrf_token()
110     elif len(token) == CSRF_TOKEN_LENGTH:
111         return token
112     elif len(token) == CSRF_SECRET_LENGTH:
113         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
114         # alphanumeric characters. For backwards compatibility, accept
115         # such values as unsalted secrets.
116         # It's easier to salt here and be consistent later, rather than add
117         # different code paths in the checks, although that might be a tad more
118         # efficient.
119         return _salt_cipher_secret(token)
120     return _get_new_csrf_token()
121 
122 
123 def _compare_salted_tokens(request_csrf_token, csrf_token):
124     # Assume both arguments are sanitized -- that is, strings of
125     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
126     return constant_time_compare(
127         _unsalt_cipher_token(request_csrf_token),
128         _unsalt_cipher_token(csrf_token),
129     )
130 
131 
132 class CsrfViewMiddleware(MiddlewareMixin):
133     """
134     Require a present and correct csrfmiddlewaretoken for POST requests that
135     have a CSRF cookie, and set an outgoing CSRF cookie.
136 
137     This middleware should be used in conjunction with the {% csrf_token %}
138     template tag.
139     """
140     # The _accept and _reject methods currently only exist for the sake of the
141     # requires_csrf_token decorator.
142     def _accept(self, request):
143         # Avoid checking the request twice by adding a custom attribute to
144         # request.  This will be relevant when both decorator and middleware
145         # are used.
146         request.csrf_processing_done = True
147         return None
148 
149     def _reject(self, request, reason):
150         response = _get_failure_view()(request, reason=reason)
151         log_response(
152             'Forbidden (%s): %s', reason, request.path,
153             response=response,
154             request=request,
155             logger=logger,
156         )
157         return response
158 
159     def _get_token(self, request):
160         if settings.CSRF_USE_SESSIONS:
161             try:
162                 return request.session.get(CSRF_SESSION_KEY)
163             except AttributeError:
164                 raise ImproperlyConfigured(
165                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
166                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
167                     'in MIDDLEWARE%s.' % ('_CLASSES' if settings.MIDDLEWARE is None else '')
168                 )
169         else:
170             try:
171                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
172             except KeyError:
173                 return None
174 
175             csrf_token = _sanitize_token(cookie_token)
176             if csrf_token != cookie_token:
177                 # Cookie token needed to be replaced;
178                 # the cookie needs to be reset.
179                 request.csrf_cookie_needs_reset = True
180             return csrf_token
181 
182     def _set_token(self, request, response):
183         if settings.CSRF_USE_SESSIONS:
184             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
185                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
186         else:
187             response.set_cookie(
188                 settings.CSRF_COOKIE_NAME,
189                 request.META['CSRF_COOKIE'],
190                 max_age=settings.CSRF_COOKIE_AGE,
191                 domain=settings.CSRF_COOKIE_DOMAIN,
192                 path=settings.CSRF_COOKIE_PATH,
193                 secure=settings.CSRF_COOKIE_SECURE,
194                 httponly=settings.CSRF_COOKIE_HTTPONLY,
195                 samesite=settings.CSRF_COOKIE_SAMESITE,
196             )
197             # Set the Vary header since content varies with the CSRF cookie.
198             patch_vary_headers(response, ('Cookie',))
199 
200     def process_request(self, request):
201         csrf_token = self._get_token(request)
202         if csrf_token is not None:
203             # Use same token next time.
204             request.META['CSRF_COOKIE'] = csrf_token
205 
206     def process_view(self, request, callback, callback_args, callback_kwargs):
207         if getattr(request, 'csrf_processing_done', False):
208             return None
209 
210         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
211         # bailing out, so that get_token still works
212         if getattr(callback, 'csrf_exempt', False):
213             return None
214 
215         # Assume that anything not defined as 'safe' by RFC7231 needs protection
216         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
217             if getattr(request, '_dont_enforce_csrf_checks', False):
218                 # Mechanism to turn off CSRF checks for test suite.
219                 # It comes after the creation of CSRF cookies, so that
220                 # everything else continues to work exactly the same
221                 # (e.g. cookies are sent, etc.), but before any
222                 # branches that call reject().
223                 return self._accept(request)
224 
225             if request.is_secure():
226                 # Suppose user visits http://example.com/
227                 # An active network attacker (man-in-the-middle, MITM) sends a
228                 # POST form that targets https://example.com/detonate-bomb/ and
229                 # submits it via JavaScript.
230                 #
231                 # The attacker will need to provide a CSRF cookie and token, but
232                 # that's no problem for a MITM and the session-independent
233                 # secret we're using. So the MITM can circumvent the CSRF
234                 # protection. This is true for any HTTP connection, but anyone
235                 # using HTTPS expects better! For this reason, for
236                 # https://example.com/ we need additional protection that treats
237                 # http://example.com/ as completely untrusted. Under HTTPS,
238                 # Barth et al. found that the Referer header is missing for
239                 # same-domain requests in only about 0.2% of cases or less, so
240                 # we can use strict Referer checking.
241                 referer = request.META.get('HTTP_REFERER')
242                 if referer is None:
243                     return self._reject(request, REASON_NO_REFERER)
244 
245                 referer = urlparse(referer)
246 
247                 # Make sure we have a valid URL for Referer.
248                 if '' in (referer.scheme, referer.netloc):
249                     return self._reject(request, REASON_MALFORMED_REFERER)
250 
251                 # Ensure that our Referer is also secure.
252                 if referer.scheme != 'https':
253                     return self._reject(request, REASON_INSECURE_REFERER)
254 
255                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
256                 # match on host:port. If not, obey the cookie rules (or those
257                 # for the session cookie, if CSRF_USE_SESSIONS).
258                 good_referer = (
259                     settings.SESSION_COOKIE_DOMAIN
260                     if settings.CSRF_USE_SESSIONS
261                     else settings.CSRF_COOKIE_DOMAIN
262                 )
263                 if good_referer is not None:
264                     server_port = request.get_port()
265                     if server_port not in ('443', '80'):
266                         good_referer = '%s:%s' % (good_referer, server_port)
267                 else:
268                     try:
269                         # request.get_host() includes the port.
270                         good_referer = request.get_host()
271                     except DisallowedHost:
272                         pass
273 
274                 # Create a list of all acceptable HTTP referers, including the
275                 # current host if it's permitted by ALLOWED_HOSTS.
276                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
277                 if good_referer is not None:
278                     good_hosts.append(good_referer)
279 
280                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
281                     reason = REASON_BAD_REFERER % referer.geturl()
282                     return self._reject(request, reason)
283 
284             csrf_token = request.META.get('CSRF_COOKIE')
285             if csrf_token is None:
286                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
287                 # and in this way we can avoid all CSRF attacks, including login
288                 # CSRF.
289                 return self._reject(request, REASON_NO_CSRF_COOKIE)
290 
291             # Check non-cookie token for match.
292             request_csrf_token = ""
293             if request.method == "POST":
294                 try:
295                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
296                 except IOError:
297                     # Handle a broken connection before we've completed reading
298                     # the POST data. process_view shouldn't raise any
299                     # exceptions, so we'll ignore and serve the user a 403
300                     # (assuming they're still listening, which they probably
301                     # aren't because of the error).
302                     pass
303 
304             if request_csrf_token == "":
305                 # Fall back to X-CSRFToken, to make things easier for AJAX,
306                 # and possible for PUT/DELETE.
307                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
308 
309             request_csrf_token = _sanitize_token(request_csrf_token)
310             if not _compare_salted_tokens(request_csrf_token, csrf_token):
311                 return self._reject(request, REASON_BAD_TOKEN)
312 
313         return self._accept(request)
314 
315     def process_response(self, request, response):
316         if not getattr(request, 'csrf_cookie_needs_reset', False):
317             if getattr(response, 'csrf_cookie_set', False):
318                 return response
319 
320         if not request.META.get("CSRF_COOKIE_USED", False):
321             return response
322 
323         # Set the CSRF cookie even if it's already set, so we renew
324         # the expiry timer.
325         self._set_token(request, response)
326         response.csrf_cookie_set = True
327         return response

</code><intended_behavior>Replace instances of `IOError` with `OSError`. This change will handle exceptions related to issues such as reading and writing CSRF tokens to the underlying storage mechanism while preserving the existing functionality of CSRF middleware exception handling.</intended_behavior>, <file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>load_geos</method>
<code>
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos

</code><intended_behavior>Replace `EnvironmentError` with `OSError` in the exception handling block. This ensures that any issues related to loading the GEOS library, such as file not found or access errors, remain effectively caught under the unified `OSError` class, keeping the geographic information system functionalities intact.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise

</code><intended_behavior>Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False

</code><intended_behavior>Update the exception handling to replace `(smtplib.SMTPException, socket.error)` with just `OSError`. Since `SMTPException` is a subclass of `OSError` and `socket.error` is now an alias for `OSError`, this simplification will ensure that all SMTP connection-related errors are caught without altering the error handling logic for email backend connections.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/management/commands/runserver.py</file>
<class>None</class>
<method>None</method>
<code>
1 import errno
2 import os
3 import re
4 import socket
5 import sys
6 from datetime import datetime
7 
8 from django.conf import settings
9 from django.core.management.base import BaseCommand, CommandError
10 from django.core.servers.basehttp import (
11     WSGIServer, get_internal_wsgi_application, run,
12 )
13 from django.utils import autoreload
14 
15 naiveip_re = re.compile(r"""^(?:
16 (?P<addr>
17     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
18     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
19     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
20 ):)?(?P<port>\d+)$""", re.X)
21 
22 
23 class Command(BaseCommand):
24     help = "Starts a lightweight Web server for development."
25 
26     # Validation is called explicitly each time the server is reloaded.
27     requires_system_checks = False
28     stealth_options = ('shutdown_message',)
29 
30     default_addr = '127.0.0.1'
31     default_addr_ipv6 = '::1'
32     default_port = '8000'
33     protocol = 'http'
34     server_cls = WSGIServer
35 
36     def add_arguments(self, parser):
37         parser.add_argument(
38             'addrport', nargs='?',
39             help='Optional port number, or ipaddr:port'
40         )
41         parser.add_argument(
42             '--ipv6', '-6', action='store_true', dest='use_ipv6',
43             help='Tells Django to use an IPv6 address.',
44         )
45         parser.add_argument(
46             '--nothreading', action='store_false', dest='use_threading',
47             help='Tells Django to NOT use threading.',
48         )
49         parser.add_argument(
50             '--noreload', action='store_false', dest='use_reloader',
51             help='Tells Django to NOT use the auto-reloader.',
52         )
53 
54     def execute(self, *args, **options):
55         if options['no_color']:
56             # We rely on the environment because it's currently the only
57             # way to reach WSGIRequestHandler. This seems an acceptable
58             # compromise considering `runserver` runs indefinitely.
59             os.environ["DJANGO_COLORS"] = "nocolor"
60         super().execute(*args, **options)
61 
62     def get_handler(self, *args, **options):
63         """Return the default WSGI handler for the runner."""
64         return get_internal_wsgi_application()
65 
66     def handle(self, *args, **options):
67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:
68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')
69 
70         self.use_ipv6 = options['use_ipv6']
71         if self.use_ipv6 and not socket.has_ipv6:
72             raise CommandError('Your Python does not support IPv6.')
73         self._raw_ipv6 = False
74         if not options['addrport']:
75             self.addr = ''
76             self.port = self.default_port
77         else:
78             m = re.match(naiveip_re, options['addrport'])
79             if m is None:
80                 raise CommandError('"%s" is not a valid port number '
81                                    'or address:port pair.' % options['addrport'])
82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()
83             if not self.port.isdigit():
84                 raise CommandError("%r is not a valid port number." % self.port)
85             if self.addr:
86                 if _ipv6:
87                     self.addr = self.addr[1:-1]
88                     self.use_ipv6 = True
89                     self._raw_ipv6 = True
90                 elif self.use_ipv6 and not _fqdn:
91                     raise CommandError('"%s" is not a valid IPv6 address.' % self.addr)
92         if not self.addr:
93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr
94             self._raw_ipv6 = self.use_ipv6
95         self.run(**options)
96 
97     def run(self, **options):
98         """Run the server, using the autoreloader if needed."""
99         use_reloader = options['use_reloader']
100 
101         if use_reloader:
102             autoreload.run_with_reloader(self.inner_run, **options)
103         else:
104             self.inner_run(None, **options)
105 
106     def inner_run(self, *args, **options):
107         # If an exception was silenced in ManagementUtility.execute in order
108         # to be raised in the child process, raise it now.
109         autoreload.raise_last_exception()
110 
111         threading = options['use_threading']
112         # 'shutdown_message' is a stealth option.
113         shutdown_message = options.get('shutdown_message', '')
114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'
115 
116         self.stdout.write("Performing system checks…\n\n")
117         self.check(display_num_errors=True)
118         # Need to check migrations here, so can't use the
119         # requires_migrations_check attribute.
120         self.check_migrations()
121         now = datetime.now().strftime('%B %d, %Y - %X')
122         self.stdout.write(now)
123         self.stdout.write((
124             "Django version %(version)s, using settings %(settings)r\n"
125             "Starting development server at %(protocol)s://%(addr)s:%(port)s/\n"
126             "Quit the server with %(quit_command)s.\n"
127         ) % {
128             "version": self.get_version(),
129             "settings": settings.SETTINGS_MODULE,
130             "protocol": self.protocol,
131             "addr": '[%s]' % self.addr if self._raw_ipv6 else self.addr,
132             "port": self.port,
133             "quit_command": quit_command,
134         })
135 
136         try:
137             handler = self.get_handler(*args, **options)
138             run(self.addr, int(self.port), handler,
139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)
140         except socket.error as e:
141             # Use helpful error messages instead of ugly tracebacks.
142             ERRORS = {
143                 errno.EACCES: "You don't have permission to access that port.",
144                 errno.EADDRINUSE: "That port is already in use.",
145                 errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
146             }
147             try:
148                 error_text = ERRORS[e.errno]
149             except KeyError:
150                 error_text = e
151             self.stderr.write("Error: %s" % error_text)
152             # Need to use an OS exit because sys.exit doesn't work in a thread
153             os._exit(1)
154         except KeyboardInterrupt:
155             if shutdown_message:
156                 self.stdout.write(shutdown_message)
157             sys.exit(0)
158 
159 
160 # Kept for backward compatibility
161 BaseRunserverCommand = Command

</code><intended_behavior>Substitute `socket.error` with `OSError` where applicable. This adjustment will cater to network issues that may arise during the server run-time, like port binding errors, ensuring the server command's robustness against such failures.</intended_behavior>]
2025-10-15 03:03:09.718 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 03:03:09.718 | INFO     | Search-only: skipping patch selection
2025-10-15 03:03:09.844 | INFO     | Task django__django-10904 completed successfully.
2025-10-15 03:03:09.845 | INFO     | No patch generated. You can try running ACR again.
