2025-10-15 02:38:00.072 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 02:38:03.912 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=302, output_tokens=12, cost=0.003380
2025-10-15 02:38:03.913 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 02:38:03.917 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 02:38:13.302 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=610, output_tokens=352, cost=0.016660
2025-10-15 02:38:13.307 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 02:38:15.723 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=67, cost=0.009070
2025-10-15 02:38:15.725 | DEBUG    | Extracted a valid json.
2025-10-15 02:38:15.725 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Cosmology\")",
        "search_method_in_class(\"write\", \"Cosmology\")",
        "search_method(\"to_table\")",
        "search_method(\"write\")",
        "search_method(\"def_unit\")"
    ],
    "bug_locations": []
}
2025-10-15 02:38:15.776 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 02:38:15.777 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 02:38:35.583 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2660, output_tokens=819, cost=0.051170
2025-10-15 02:38:35.598 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 02:38:41.552 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3695, output_tokens=210, cost=0.043250
2025-10-15 02:38:41.557 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 02:38:43.907 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=564, output_tokens=62, cost=0.007500
2025-10-15 02:38:43.908 | DEBUG    | Extracted a valid json.
2025-10-15 02:38:43.908 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"UnifiedReadWriteMethod\")",
        "search_code_in_file(\"write\", \"astropy/io/registry/core.py\")",
        "search_code_in_file(\"write\", \"astropy/table/table.py\")"
    ],
    "bug_locations": []
}
2025-10-15 02:38:43.976 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 02:38:43.976 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 02:39:04.102 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4451, output_tokens=878, cost=0.070850
2025-10-15 02:39:04.114 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 02:39:18.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5545, output_tokens=431, cost=0.068380
2025-10-15 02:39:18.564 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 02:39:29.024 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=785, output_tokens=350, cost=0.018350
2025-10-15 02:39:29.025 | DEBUG    | Extracted a valid json.
2025-10-15 02:39:29.025 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/cosmology/io/registry.py",
            "class": "Potentially a new class or existing I/O handling class for cosmology",
            "method": "A new method needs to be added",
            "intended_behavior": "Implement a new `write_html` method (or equivalent that fits within Astropy's naming and design conventions) for the `Cosmology` class. This method should: 1. Utilize the `to_table` method or functionality to convert a `Cosmology` instance into a table format. 2. Format the table to HTML, ensuring that mathematical expressions are converted to MathJax format where appropriate, likely leveraging the `parameter.format` attribute proposed in the issue. 3. Register this new `write` method with the Astropy I/O system to handle the `html` format specifically for `Cosmology` objects, using `register_writer` in `astropy/io/registry/core.py`."
        },
        {
            "file": "astropy/io/registry/core.py",
            "class": "N/A",
            "method": "Modifications may be needed within `register_writer`, `write`, or both",
            "intended_behavior": "Ensure that the registration system can accommodate the new HTML writer for `Cosmology`. This may involve adding a new format specifier for `html` that specifically targets `Cosmology` objects, and ensuring that the `write` method can appropriately dispatch `Cosmology` instances to the new HTML writer function when the `format='html'` argument is used."
        }
    ]
}
2025-10-15 02:39:29.033 | DEBUG    | Bug location extracted successfully: [<file>astropy/io/registry/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 import os
4 import sys
5 from collections import OrderedDict
6 
7 from .base import IORegistryError, _UnifiedIORegistryBase
8 
9 __all__ = ['UnifiedIORegistry', 'UnifiedInputRegistry', 'UnifiedOutputRegistry']
10 
11 
12 PATH_TYPES = (str, os.PathLike)  # TODO! include bytes
13 
14 
15 def _expand_user_in_args(args):
16     # Conservatively attempt to apply `os.path.expanduser` to the first
17     # argument, which can be either a path or the contents of a table.
18     if len(args) and isinstance(args[0], PATH_TYPES):
19         ex_user = os.path.expanduser(args[0])
20         if ex_user != args[0] and os.path.exists(os.path.dirname(ex_user)):
21             args = (ex_user,) + args[1:]
22     return args
23 
24 
25 # -----------------------------------------------------------------------------
26 
27 class UnifiedInputRegistry(_UnifiedIORegistryBase):
28     """Read-only Unified Registry.
29 
30     .. versionadded:: 5.0
31 
32     Examples
33     --------
34     First let's start by creating a read-only registry.
35 
36     .. code-block:: python
37 
38         >>> from astropy.io.registry import UnifiedInputRegistry
39         >>> read_reg = UnifiedInputRegistry()
40 
41     There is nothing in this registry. Let's make a reader for the
42     :class:`~astropy.table.Table` class::
43 
44         from astropy.table import Table
45 
46         def my_table_reader(filename, some_option=1):
47             # Read in the table by any means necessary
48             return table  # should be an instance of Table
49 
50     Such a function can then be registered with the I/O registry::
51 
52         read_reg.register_reader('my-table-format', Table, my_table_reader)
53 
54     Note that we CANNOT then read in a table with::
55 
56         d = Table.read('my_table_file.mtf', format='my-table-format')
57 
58     Why? because ``Table.read`` uses Astropy's default global registry and this
59     is a separate registry.
60     Instead we can read by the read method on the registry::
61 
62         d = read_reg.read(Table, 'my_table_file.mtf', format='my-table-format')
63 
64     """
65 
66     def __init__(self):
67         super().__init__()  # set _identifiers
68         self._readers = OrderedDict()
69         self._registries["read"] = dict(attr="_readers", column="Read")
70         self._registries_order = ("read", "identify")
71 
72     # =========================================================================
73     # Read methods
74 
75     def register_reader(self, data_format, data_class, function, force=False,
76                         priority=0):
77         """
78         Register a reader function.
79 
80         Parameters
81         ----------
82         data_format : str
83             The data format identifier. This is the string that will be used to
84             specify the data type when reading.
85         data_class : class
86             The class of the object that the reader produces.
87         function : function
88             The function to read in a data object.
89         force : bool, optional
90             Whether to override any existing function if already present.
91             Default is ``False``.
92         priority : int, optional
93             The priority of the reader, used to compare possible formats when
94             trying to determine the best reader to use. Higher priorities are
95             preferred over lower priorities, with the default priority being 0
96             (negative numbers are allowed though).
97         """
98         if not (data_format, data_class) in self._readers or force:
99             self._readers[(data_format, data_class)] = function, priority
100         else:
101             raise IORegistryError("Reader for format '{}' and class '{}' is "
102                               'already defined'
103                               ''.format(data_format, data_class.__name__))
104 
105         if data_class not in self._delayed_docs_classes:
106             self._update__doc__(data_class, 'read')
107 
108     def unregister_reader(self, data_format, data_class):
109         """
110         Unregister a reader function
111 
112         Parameters
113         ----------
114         data_format : str
115             The data format identifier.
116         data_class : class
117             The class of the object that the reader produces.
118         """
119 
120         if (data_format, data_class) in self._readers:
121             self._readers.pop((data_format, data_class))
122         else:
123             raise IORegistryError("No reader defined for format '{}' and class '{}'"
124                                   ''.format(data_format, data_class.__name__))
125 
126         if data_class not in self._delayed_docs_classes:
127             self._update__doc__(data_class, 'read')
128 
129     def get_reader(self, data_format, data_class):
130         """Get reader for ``data_format``.
131 
132         Parameters
133         ----------
134         data_format : str
135             The data format identifier. This is the string that is used to
136             specify the data type when reading/writing.
137         data_class : class
138             The class of the object that can be written.
139 
140         Returns
141         -------
142         reader : callable
143             The registered reader function for this format and class.
144         """
145         readers = [(fmt, cls) for fmt, cls in self._readers if fmt == data_format]
146         for reader_format, reader_class in readers:
147             if self._is_best_match(data_class, reader_class, readers):
148                 return self._readers[(reader_format, reader_class)][0]
149         else:
150             format_table_str = self._get_format_table_str(data_class, 'Read')
151             raise IORegistryError(
152                 "No reader defined for format '{}' and class '{}'.\n\nThe "
153                 "available formats are:\n\n{}".format(
154                     data_format, data_class.__name__, format_table_str))
155 
156     def read(self, cls, *args, format=None, cache=False, **kwargs):
157         """
158         Read in data.
159 
160         Parameters
161         ----------
162         cls : class
163         *args
164             The arguments passed to this method depend on the format.
165         format : str or None
166         cache : bool
167             Whether to cache the results of reading in the data.
168         **kwargs
169             The arguments passed to this method depend on the format.
170 
171         Returns
172         -------
173         object or None
174             The output of the registered reader.
175         """
176         ctx = None
177         try:
178             # Expand a tilde-prefixed path if present in args[0]
179             args = _expand_user_in_args(args)
180 
181             if format is None:
182                 path = None
183                 fileobj = None
184 
185                 if len(args):
186                     if isinstance(args[0], PATH_TYPES) and not os.path.isdir(args[0]):
187                         from astropy.utils.data import get_readable_fileobj
188 
189                         # path might be a os.PathLike object
190                         if isinstance(args[0], os.PathLike):
191                             args = (os.fspath(args[0]),) + args[1:]
192                         path = args[0]
193                         try:
194                             ctx = get_readable_fileobj(args[0], encoding='binary', cache=cache)
195                             fileobj = ctx.__enter__()
196                         except OSError:
197                             raise
198                         except Exception:
199                             fileobj = None
200                         else:
201                             args = [fileobj] + list(args[1:])
202                     elif hasattr(args[0], 'read'):
203                         path = None
204                         fileobj = args[0]
205 
206                 format = self._get_valid_format(
207                     'read', cls, path, fileobj, args, kwargs)
208 
209             reader = self.get_reader(format, cls)
210             data = reader(*args, **kwargs)
211 
212             if not isinstance(data, cls):
213                 # User has read with a subclass where only the parent class is
214                 # registered.  This returns the parent class, so try coercing
215                 # to desired subclass.
216                 try:
217                     data = cls(data)
218                 except Exception:
219                     raise TypeError('could not convert reader output to {} '
220                                     'class.'.format(cls.__name__))
221         finally:
222             if ctx is not None:
223                 ctx.__exit__(*sys.exc_info())
224 
225         return data
226 
227 
228 # -----------------------------------------------------------------------------
229 
230 class UnifiedOutputRegistry(_UnifiedIORegistryBase):
231     """Write-only Registry.
232 
233     .. versionadded:: 5.0
234     """
235 
236     def __init__(self):
237         super().__init__()
238         self._writers = OrderedDict()
239         self._registries["write"] = dict(attr="_writers", column="Write")
240         self._registries_order = ("write", "identify", )
241 
242     # =========================================================================
243     # Write Methods
244 
245     def register_writer(self, data_format, data_class, function, force=False, priority=0):
246         """
247         Register a table writer function.
248 
249         Parameters
250         ----------
251         data_format : str
252             The data format identifier. This is the string that will be used to
253             specify the data type when writing.
254         data_class : class
255             The class of the object that can be written.
256         function : function
257             The function to write out a data object.
258         force : bool, optional
259             Whether to override any existing function if already present.
260             Default is ``False``.
261         priority : int, optional
262             The priority of the writer, used to compare possible formats when trying
263             to determine the best writer to use. Higher priorities are preferred
264             over lower priorities, with the default priority being 0 (negative
265             numbers are allowed though).
266         """
267         if not (data_format, data_class) in self._writers or force:
268             self._writers[(data_format, data_class)] = function, priority
269         else:
270             raise IORegistryError("Writer for format '{}' and class '{}' is "
271                                   'already defined'
272                                   ''.format(data_format, data_class.__name__))
273 
274         if data_class not in self._delayed_docs_classes:
275             self._update__doc__(data_class, 'write')
276 
277     def unregister_writer(self, data_format, data_class):
278         """
279         Unregister a writer function
280 
281         Parameters
282         ----------
283         data_format : str
284             The data format identifier.
285         data_class : class
286             The class of the object that can be written.
287         """
288 
289         if (data_format, data_class) in self._writers:
290             self._writers.pop((data_format, data_class))
291         else:
292             raise IORegistryError("No writer defined for format '{}' and class '{}'"
293                                   ''.format(data_format, data_class.__name__))
294 
295         if data_class not in self._delayed_docs_classes:
296             self._update__doc__(data_class, 'write')
297 
298     def get_writer(self, data_format, data_class):
299         """Get writer for ``data_format``.
300 
301         Parameters
302         ----------
303         data_format : str
304             The data format identifier. This is the string that is used to
305             specify the data type when reading/writing.
306         data_class : class
307             The class of the object that can be written.
308 
309         Returns
310         -------
311         writer : callable
312             The registered writer function for this format and class.
313         """
314         writers = [(fmt, cls) for fmt, cls in self._writers if fmt == data_format]
315         for writer_format, writer_class in writers:
316             if self._is_best_match(data_class, writer_class, writers):
317                 return self._writers[(writer_format, writer_class)][0]
318         else:
319             format_table_str = self._get_format_table_str(data_class, 'Write')
320             raise IORegistryError(
321                 "No writer defined for format '{}' and class '{}'.\n\nThe "
322                 "available formats are:\n\n{}".format(
323                     data_format, data_class.__name__, format_table_str))
324 
325     def write(self, data, *args, format=None, **kwargs):
326         """
327         Write out data.
328 
329         Parameters
330         ----------
331         data : object
332             The data to write.
333         *args
334             The arguments passed to this method depend on the format.
335         format : str or None
336         **kwargs
337             The arguments passed to this method depend on the format.
338 
339         Returns
340         -------
341         object or None
342             The output of the registered writer. Most often `None`.
343 
344             .. versionadded:: 4.3
345         """
346         # Expand a tilde-prefixed path if present in args[0]
347         args = _expand_user_in_args(args)
348 
349         if format is None:
350             path = None
351             fileobj = None
352             if len(args):
353                 if isinstance(args[0], PATH_TYPES):
354                     # path might be a os.PathLike object
355                     if isinstance(args[0], os.PathLike):
356                         args = (os.fspath(args[0]),) + args[1:]
357                     path = args[0]
358                     fileobj = None
359                 elif hasattr(args[0], 'read'):
360                     path = None
361                     fileobj = args[0]
362 
363             format = self._get_valid_format(
364                 'write', data.__class__, path, fileobj, args, kwargs)
365 
366         writer = self.get_writer(format, data.__class__)
367         return writer(data, *args, **kwargs)
368 
369 
370 # -----------------------------------------------------------------------------
371 
372 class UnifiedIORegistry(UnifiedInputRegistry, UnifiedOutputRegistry):
373     """Unified I/O Registry.
374 
375     .. versionadded:: 5.0
376     """
377 
378     def __init__(self):
379         super().__init__()
380         self._registries_order = ("read", "write", "identify")
381 
382     def get_formats(self, data_class=None, readwrite=None):
383         """
384         Get the list of registered I/O formats as a `~astropy.table.Table`.
385 
386         Parameters
387         ----------
388         data_class : class, optional
389             Filter readers/writer to match data class (default = all classes).
390 
391         readwrite : str or None, optional
392             Search only for readers (``"Read"``) or writers (``"Write"``).
393             If None search for both.  Default is None.
394 
395             .. versionadded:: 1.3
396 
397         Returns
398         -------
399         format_table : :class:`~astropy.table.Table`
400             Table of available I/O formats.
401         """
402         return super().get_formats(data_class, readwrite)

</code><intended_behavior>Ensure that the registration system can accommodate the new HTML writer for `Cosmology`. This may involve adding a new format specifier for `html` that specifically targets `Cosmology` objects, and ensuring that the `write` method can appropriately dispatch `Cosmology` instances to the new HTML writer function when the `format='html'` argument is used.</intended_behavior>]
2025-10-15 02:39:29.033 | INFO     | Search completed. Bug locations: [<file>astropy/io/registry/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 import os
4 import sys
5 from collections import OrderedDict
6 
7 from .base import IORegistryError, _UnifiedIORegistryBase
8 
9 __all__ = ['UnifiedIORegistry', 'UnifiedInputRegistry', 'UnifiedOutputRegistry']
10 
11 
12 PATH_TYPES = (str, os.PathLike)  # TODO! include bytes
13 
14 
15 def _expand_user_in_args(args):
16     # Conservatively attempt to apply `os.path.expanduser` to the first
17     # argument, which can be either a path or the contents of a table.
18     if len(args) and isinstance(args[0], PATH_TYPES):
19         ex_user = os.path.expanduser(args[0])
20         if ex_user != args[0] and os.path.exists(os.path.dirname(ex_user)):
21             args = (ex_user,) + args[1:]
22     return args
23 
24 
25 # -----------------------------------------------------------------------------
26 
27 class UnifiedInputRegistry(_UnifiedIORegistryBase):
28     """Read-only Unified Registry.
29 
30     .. versionadded:: 5.0
31 
32     Examples
33     --------
34     First let's start by creating a read-only registry.
35 
36     .. code-block:: python
37 
38         >>> from astropy.io.registry import UnifiedInputRegistry
39         >>> read_reg = UnifiedInputRegistry()
40 
41     There is nothing in this registry. Let's make a reader for the
42     :class:`~astropy.table.Table` class::
43 
44         from astropy.table import Table
45 
46         def my_table_reader(filename, some_option=1):
47             # Read in the table by any means necessary
48             return table  # should be an instance of Table
49 
50     Such a function can then be registered with the I/O registry::
51 
52         read_reg.register_reader('my-table-format', Table, my_table_reader)
53 
54     Note that we CANNOT then read in a table with::
55 
56         d = Table.read('my_table_file.mtf', format='my-table-format')
57 
58     Why? because ``Table.read`` uses Astropy's default global registry and this
59     is a separate registry.
60     Instead we can read by the read method on the registry::
61 
62         d = read_reg.read(Table, 'my_table_file.mtf', format='my-table-format')
63 
64     """
65 
66     def __init__(self):
67         super().__init__()  # set _identifiers
68         self._readers = OrderedDict()
69         self._registries["read"] = dict(attr="_readers", column="Read")
70         self._registries_order = ("read", "identify")
71 
72     # =========================================================================
73     # Read methods
74 
75     def register_reader(self, data_format, data_class, function, force=False,
76                         priority=0):
77         """
78         Register a reader function.
79 
80         Parameters
81         ----------
82         data_format : str
83             The data format identifier. This is the string that will be used to
84             specify the data type when reading.
85         data_class : class
86             The class of the object that the reader produces.
87         function : function
88             The function to read in a data object.
89         force : bool, optional
90             Whether to override any existing function if already present.
91             Default is ``False``.
92         priority : int, optional
93             The priority of the reader, used to compare possible formats when
94             trying to determine the best reader to use. Higher priorities are
95             preferred over lower priorities, with the default priority being 0
96             (negative numbers are allowed though).
97         """
98         if not (data_format, data_class) in self._readers or force:
99             self._readers[(data_format, data_class)] = function, priority
100         else:
101             raise IORegistryError("Reader for format '{}' and class '{}' is "
102                               'already defined'
103                               ''.format(data_format, data_class.__name__))
104 
105         if data_class not in self._delayed_docs_classes:
106             self._update__doc__(data_class, 'read')
107 
108     def unregister_reader(self, data_format, data_class):
109         """
110         Unregister a reader function
111 
112         Parameters
113         ----------
114         data_format : str
115             The data format identifier.
116         data_class : class
117             The class of the object that the reader produces.
118         """
119 
120         if (data_format, data_class) in self._readers:
121             self._readers.pop((data_format, data_class))
122         else:
123             raise IORegistryError("No reader defined for format '{}' and class '{}'"
124                                   ''.format(data_format, data_class.__name__))
125 
126         if data_class not in self._delayed_docs_classes:
127             self._update__doc__(data_class, 'read')
128 
129     def get_reader(self, data_format, data_class):
130         """Get reader for ``data_format``.
131 
132         Parameters
133         ----------
134         data_format : str
135             The data format identifier. This is the string that is used to
136             specify the data type when reading/writing.
137         data_class : class
138             The class of the object that can be written.
139 
140         Returns
141         -------
142         reader : callable
143             The registered reader function for this format and class.
144         """
145         readers = [(fmt, cls) for fmt, cls in self._readers if fmt == data_format]
146         for reader_format, reader_class in readers:
147             if self._is_best_match(data_class, reader_class, readers):
148                 return self._readers[(reader_format, reader_class)][0]
149         else:
150             format_table_str = self._get_format_table_str(data_class, 'Read')
151             raise IORegistryError(
152                 "No reader defined for format '{}' and class '{}'.\n\nThe "
153                 "available formats are:\n\n{}".format(
154                     data_format, data_class.__name__, format_table_str))
155 
156     def read(self, cls, *args, format=None, cache=False, **kwargs):
157         """
158         Read in data.
159 
160         Parameters
161         ----------
162         cls : class
163         *args
164             The arguments passed to this method depend on the format.
165         format : str or None
166         cache : bool
167             Whether to cache the results of reading in the data.
168         **kwargs
169             The arguments passed to this method depend on the format.
170 
171         Returns
172         -------
173         object or None
174             The output of the registered reader.
175         """
176         ctx = None
177         try:
178             # Expand a tilde-prefixed path if present in args[0]
179             args = _expand_user_in_args(args)
180 
181             if format is None:
182                 path = None
183                 fileobj = None
184 
185                 if len(args):
186                     if isinstance(args[0], PATH_TYPES) and not os.path.isdir(args[0]):
187                         from astropy.utils.data import get_readable_fileobj
188 
189                         # path might be a os.PathLike object
190                         if isinstance(args[0], os.PathLike):
191                             args = (os.fspath(args[0]),) + args[1:]
192                         path = args[0]
193                         try:
194                             ctx = get_readable_fileobj(args[0], encoding='binary', cache=cache)
195                             fileobj = ctx.__enter__()
196                         except OSError:
197                             raise
198                         except Exception:
199                             fileobj = None
200                         else:
201                             args = [fileobj] + list(args[1:])
202                     elif hasattr(args[0], 'read'):
203                         path = None
204                         fileobj = args[0]
205 
206                 format = self._get_valid_format(
207                     'read', cls, path, fileobj, args, kwargs)
208 
209             reader = self.get_reader(format, cls)
210             data = reader(*args, **kwargs)
211 
212             if not isinstance(data, cls):
213                 # User has read with a subclass where only the parent class is
214                 # registered.  This returns the parent class, so try coercing
215                 # to desired subclass.
216                 try:
217                     data = cls(data)
218                 except Exception:
219                     raise TypeError('could not convert reader output to {} '
220                                     'class.'.format(cls.__name__))
221         finally:
222             if ctx is not None:
223                 ctx.__exit__(*sys.exc_info())
224 
225         return data
226 
227 
228 # -----------------------------------------------------------------------------
229 
230 class UnifiedOutputRegistry(_UnifiedIORegistryBase):
231     """Write-only Registry.
232 
233     .. versionadded:: 5.0
234     """
235 
236     def __init__(self):
237         super().__init__()
238         self._writers = OrderedDict()
239         self._registries["write"] = dict(attr="_writers", column="Write")
240         self._registries_order = ("write", "identify", )
241 
242     # =========================================================================
243     # Write Methods
244 
245     def register_writer(self, data_format, data_class, function, force=False, priority=0):
246         """
247         Register a table writer function.
248 
249         Parameters
250         ----------
251         data_format : str
252             The data format identifier. This is the string that will be used to
253             specify the data type when writing.
254         data_class : class
255             The class of the object that can be written.
256         function : function
257             The function to write out a data object.
258         force : bool, optional
259             Whether to override any existing function if already present.
260             Default is ``False``.
261         priority : int, optional
262             The priority of the writer, used to compare possible formats when trying
263             to determine the best writer to use. Higher priorities are preferred
264             over lower priorities, with the default priority being 0 (negative
265             numbers are allowed though).
266         """
267         if not (data_format, data_class) in self._writers or force:
268             self._writers[(data_format, data_class)] = function, priority
269         else:
270             raise IORegistryError("Writer for format '{}' and class '{}' is "
271                                   'already defined'
272                                   ''.format(data_format, data_class.__name__))
273 
274         if data_class not in self._delayed_docs_classes:
275             self._update__doc__(data_class, 'write')
276 
277     def unregister_writer(self, data_format, data_class):
278         """
279         Unregister a writer function
280 
281         Parameters
282         ----------
283         data_format : str
284             The data format identifier.
285         data_class : class
286             The class of the object that can be written.
287         """
288 
289         if (data_format, data_class) in self._writers:
290             self._writers.pop((data_format, data_class))
291         else:
292             raise IORegistryError("No writer defined for format '{}' and class '{}'"
293                                   ''.format(data_format, data_class.__name__))
294 
295         if data_class not in self._delayed_docs_classes:
296             self._update__doc__(data_class, 'write')
297 
298     def get_writer(self, data_format, data_class):
299         """Get writer for ``data_format``.
300 
301         Parameters
302         ----------
303         data_format : str
304             The data format identifier. This is the string that is used to
305             specify the data type when reading/writing.
306         data_class : class
307             The class of the object that can be written.
308 
309         Returns
310         -------
311         writer : callable
312             The registered writer function for this format and class.
313         """
314         writers = [(fmt, cls) for fmt, cls in self._writers if fmt == data_format]
315         for writer_format, writer_class in writers:
316             if self._is_best_match(data_class, writer_class, writers):
317                 return self._writers[(writer_format, writer_class)][0]
318         else:
319             format_table_str = self._get_format_table_str(data_class, 'Write')
320             raise IORegistryError(
321                 "No writer defined for format '{}' and class '{}'.\n\nThe "
322                 "available formats are:\n\n{}".format(
323                     data_format, data_class.__name__, format_table_str))
324 
325     def write(self, data, *args, format=None, **kwargs):
326         """
327         Write out data.
328 
329         Parameters
330         ----------
331         data : object
332             The data to write.
333         *args
334             The arguments passed to this method depend on the format.
335         format : str or None
336         **kwargs
337             The arguments passed to this method depend on the format.
338 
339         Returns
340         -------
341         object or None
342             The output of the registered writer. Most often `None`.
343 
344             .. versionadded:: 4.3
345         """
346         # Expand a tilde-prefixed path if present in args[0]
347         args = _expand_user_in_args(args)
348 
349         if format is None:
350             path = None
351             fileobj = None
352             if len(args):
353                 if isinstance(args[0], PATH_TYPES):
354                     # path might be a os.PathLike object
355                     if isinstance(args[0], os.PathLike):
356                         args = (os.fspath(args[0]),) + args[1:]
357                     path = args[0]
358                     fileobj = None
359                 elif hasattr(args[0], 'read'):
360                     path = None
361                     fileobj = args[0]
362 
363             format = self._get_valid_format(
364                 'write', data.__class__, path, fileobj, args, kwargs)
365 
366         writer = self.get_writer(format, data.__class__)
367         return writer(data, *args, **kwargs)
368 
369 
370 # -----------------------------------------------------------------------------
371 
372 class UnifiedIORegistry(UnifiedInputRegistry, UnifiedOutputRegistry):
373     """Unified I/O Registry.
374 
375     .. versionadded:: 5.0
376     """
377 
378     def __init__(self):
379         super().__init__()
380         self._registries_order = ("read", "write", "identify")
381 
382     def get_formats(self, data_class=None, readwrite=None):
383         """
384         Get the list of registered I/O formats as a `~astropy.table.Table`.
385 
386         Parameters
387         ----------
388         data_class : class, optional
389             Filter readers/writer to match data class (default = all classes).
390 
391         readwrite : str or None, optional
392             Search only for readers (``"Read"``) or writers (``"Write"``).
393             If None search for both.  Default is None.
394 
395             .. versionadded:: 1.3
396 
397         Returns
398         -------
399         format_table : :class:`~astropy.table.Table`
400             Table of available I/O formats.
401         """
402         return super().get_formats(data_class, readwrite)

</code><intended_behavior>Ensure that the registration system can accommodate the new HTML writer for `Cosmology`. This may involve adding a new format specifier for `html` that specifically targets `Cosmology` objects, and ensuring that the `write` method can appropriately dispatch `Cosmology` instances to the new HTML writer function when the `format='html'` argument is used.</intended_behavior>]
2025-10-15 02:39:29.034 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 02:39:29.034 | INFO     | Search-only: skipping patch selection
2025-10-15 02:39:29.111 | INFO     | Task astropy__astropy-13075 completed successfully.
2025-10-15 02:39:29.112 | INFO     | No patch generated. You can try running ACR again.
