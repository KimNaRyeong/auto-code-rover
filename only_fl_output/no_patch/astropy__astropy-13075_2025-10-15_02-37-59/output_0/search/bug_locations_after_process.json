[
    {
        "rel_file_path": "astropy/io/registry/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/io/registry/core.py",
        "start": 1,
        "end": 402,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 import os\n4 import sys\n5 from collections import OrderedDict\n6 \n7 from .base import IORegistryError, _UnifiedIORegistryBase\n8 \n9 __all__ = ['UnifiedIORegistry', 'UnifiedInputRegistry', 'UnifiedOutputRegistry']\n10 \n11 \n12 PATH_TYPES = (str, os.PathLike)  # TODO! include bytes\n13 \n14 \n15 def _expand_user_in_args(args):\n16     # Conservatively attempt to apply `os.path.expanduser` to the first\n17     # argument, which can be either a path or the contents of a table.\n18     if len(args) and isinstance(args[0], PATH_TYPES):\n19         ex_user = os.path.expanduser(args[0])\n20         if ex_user != args[0] and os.path.exists(os.path.dirname(ex_user)):\n21             args = (ex_user,) + args[1:]\n22     return args\n23 \n24 \n25 # -----------------------------------------------------------------------------\n26 \n27 class UnifiedInputRegistry(_UnifiedIORegistryBase):\n28     \"\"\"Read-only Unified Registry.\n29 \n30     .. versionadded:: 5.0\n31 \n32     Examples\n33     --------\n34     First let's start by creating a read-only registry.\n35 \n36     .. code-block:: python\n37 \n38         >>> from astropy.io.registry import UnifiedInputRegistry\n39         >>> read_reg = UnifiedInputRegistry()\n40 \n41     There is nothing in this registry. Let's make a reader for the\n42     :class:`~astropy.table.Table` class::\n43 \n44         from astropy.table import Table\n45 \n46         def my_table_reader(filename, some_option=1):\n47             # Read in the table by any means necessary\n48             return table  # should be an instance of Table\n49 \n50     Such a function can then be registered with the I/O registry::\n51 \n52         read_reg.register_reader('my-table-format', Table, my_table_reader)\n53 \n54     Note that we CANNOT then read in a table with::\n55 \n56         d = Table.read('my_table_file.mtf', format='my-table-format')\n57 \n58     Why? because ``Table.read`` uses Astropy's default global registry and this\n59     is a separate registry.\n60     Instead we can read by the read method on the registry::\n61 \n62         d = read_reg.read(Table, 'my_table_file.mtf', format='my-table-format')\n63 \n64     \"\"\"\n65 \n66     def __init__(self):\n67         super().__init__()  # set _identifiers\n68         self._readers = OrderedDict()\n69         self._registries[\"read\"] = dict(attr=\"_readers\", column=\"Read\")\n70         self._registries_order = (\"read\", \"identify\")\n71 \n72     # =========================================================================\n73     # Read methods\n74 \n75     def register_reader(self, data_format, data_class, function, force=False,\n76                         priority=0):\n77         \"\"\"\n78         Register a reader function.\n79 \n80         Parameters\n81         ----------\n82         data_format : str\n83             The data format identifier. This is the string that will be used to\n84             specify the data type when reading.\n85         data_class : class\n86             The class of the object that the reader produces.\n87         function : function\n88             The function to read in a data object.\n89         force : bool, optional\n90             Whether to override any existing function if already present.\n91             Default is ``False``.\n92         priority : int, optional\n93             The priority of the reader, used to compare possible formats when\n94             trying to determine the best reader to use. Higher priorities are\n95             preferred over lower priorities, with the default priority being 0\n96             (negative numbers are allowed though).\n97         \"\"\"\n98         if not (data_format, data_class) in self._readers or force:\n99             self._readers[(data_format, data_class)] = function, priority\n100         else:\n101             raise IORegistryError(\"Reader for format '{}' and class '{}' is \"\n102                               'already defined'\n103                               ''.format(data_format, data_class.__name__))\n104 \n105         if data_class not in self._delayed_docs_classes:\n106             self._update__doc__(data_class, 'read')\n107 \n108     def unregister_reader(self, data_format, data_class):\n109         \"\"\"\n110         Unregister a reader function\n111 \n112         Parameters\n113         ----------\n114         data_format : str\n115             The data format identifier.\n116         data_class : class\n117             The class of the object that the reader produces.\n118         \"\"\"\n119 \n120         if (data_format, data_class) in self._readers:\n121             self._readers.pop((data_format, data_class))\n122         else:\n123             raise IORegistryError(\"No reader defined for format '{}' and class '{}'\"\n124                                   ''.format(data_format, data_class.__name__))\n125 \n126         if data_class not in self._delayed_docs_classes:\n127             self._update__doc__(data_class, 'read')\n128 \n129     def get_reader(self, data_format, data_class):\n130         \"\"\"Get reader for ``data_format``.\n131 \n132         Parameters\n133         ----------\n134         data_format : str\n135             The data format identifier. This is the string that is used to\n136             specify the data type when reading/writing.\n137         data_class : class\n138             The class of the object that can be written.\n139 \n140         Returns\n141         -------\n142         reader : callable\n143             The registered reader function for this format and class.\n144         \"\"\"\n145         readers = [(fmt, cls) for fmt, cls in self._readers if fmt == data_format]\n146         for reader_format, reader_class in readers:\n147             if self._is_best_match(data_class, reader_class, readers):\n148                 return self._readers[(reader_format, reader_class)][0]\n149         else:\n150             format_table_str = self._get_format_table_str(data_class, 'Read')\n151             raise IORegistryError(\n152                 \"No reader defined for format '{}' and class '{}'.\\n\\nThe \"\n153                 \"available formats are:\\n\\n{}\".format(\n154                     data_format, data_class.__name__, format_table_str))\n155 \n156     def read(self, cls, *args, format=None, cache=False, **kwargs):\n157         \"\"\"\n158         Read in data.\n159 \n160         Parameters\n161         ----------\n162         cls : class\n163         *args\n164             The arguments passed to this method depend on the format.\n165         format : str or None\n166         cache : bool\n167             Whether to cache the results of reading in the data.\n168         **kwargs\n169             The arguments passed to this method depend on the format.\n170 \n171         Returns\n172         -------\n173         object or None\n174             The output of the registered reader.\n175         \"\"\"\n176         ctx = None\n177         try:\n178             # Expand a tilde-prefixed path if present in args[0]\n179             args = _expand_user_in_args(args)\n180 \n181             if format is None:\n182                 path = None\n183                 fileobj = None\n184 \n185                 if len(args):\n186                     if isinstance(args[0], PATH_TYPES) and not os.path.isdir(args[0]):\n187                         from astropy.utils.data import get_readable_fileobj\n188 \n189                         # path might be a os.PathLike object\n190                         if isinstance(args[0], os.PathLike):\n191                             args = (os.fspath(args[0]),) + args[1:]\n192                         path = args[0]\n193                         try:\n194                             ctx = get_readable_fileobj(args[0], encoding='binary', cache=cache)\n195                             fileobj = ctx.__enter__()\n196                         except OSError:\n197                             raise\n198                         except Exception:\n199                             fileobj = None\n200                         else:\n201                             args = [fileobj] + list(args[1:])\n202                     elif hasattr(args[0], 'read'):\n203                         path = None\n204                         fileobj = args[0]\n205 \n206                 format = self._get_valid_format(\n207                     'read', cls, path, fileobj, args, kwargs)\n208 \n209             reader = self.get_reader(format, cls)\n210             data = reader(*args, **kwargs)\n211 \n212             if not isinstance(data, cls):\n213                 # User has read with a subclass where only the parent class is\n214                 # registered.  This returns the parent class, so try coercing\n215                 # to desired subclass.\n216                 try:\n217                     data = cls(data)\n218                 except Exception:\n219                     raise TypeError('could not convert reader output to {} '\n220                                     'class.'.format(cls.__name__))\n221         finally:\n222             if ctx is not None:\n223                 ctx.__exit__(*sys.exc_info())\n224 \n225         return data\n226 \n227 \n228 # -----------------------------------------------------------------------------\n229 \n230 class UnifiedOutputRegistry(_UnifiedIORegistryBase):\n231     \"\"\"Write-only Registry.\n232 \n233     .. versionadded:: 5.0\n234     \"\"\"\n235 \n236     def __init__(self):\n237         super().__init__()\n238         self._writers = OrderedDict()\n239         self._registries[\"write\"] = dict(attr=\"_writers\", column=\"Write\")\n240         self._registries_order = (\"write\", \"identify\", )\n241 \n242     # =========================================================================\n243     # Write Methods\n244 \n245     def register_writer(self, data_format, data_class, function, force=False, priority=0):\n246         \"\"\"\n247         Register a table writer function.\n248 \n249         Parameters\n250         ----------\n251         data_format : str\n252             The data format identifier. This is the string that will be used to\n253             specify the data type when writing.\n254         data_class : class\n255             The class of the object that can be written.\n256         function : function\n257             The function to write out a data object.\n258         force : bool, optional\n259             Whether to override any existing function if already present.\n260             Default is ``False``.\n261         priority : int, optional\n262             The priority of the writer, used to compare possible formats when trying\n263             to determine the best writer to use. Higher priorities are preferred\n264             over lower priorities, with the default priority being 0 (negative\n265             numbers are allowed though).\n266         \"\"\"\n267         if not (data_format, data_class) in self._writers or force:\n268             self._writers[(data_format, data_class)] = function, priority\n269         else:\n270             raise IORegistryError(\"Writer for format '{}' and class '{}' is \"\n271                                   'already defined'\n272                                   ''.format(data_format, data_class.__name__))\n273 \n274         if data_class not in self._delayed_docs_classes:\n275             self._update__doc__(data_class, 'write')\n276 \n277     def unregister_writer(self, data_format, data_class):\n278         \"\"\"\n279         Unregister a writer function\n280 \n281         Parameters\n282         ----------\n283         data_format : str\n284             The data format identifier.\n285         data_class : class\n286             The class of the object that can be written.\n287         \"\"\"\n288 \n289         if (data_format, data_class) in self._writers:\n290             self._writers.pop((data_format, data_class))\n291         else:\n292             raise IORegistryError(\"No writer defined for format '{}' and class '{}'\"\n293                                   ''.format(data_format, data_class.__name__))\n294 \n295         if data_class not in self._delayed_docs_classes:\n296             self._update__doc__(data_class, 'write')\n297 \n298     def get_writer(self, data_format, data_class):\n299         \"\"\"Get writer for ``data_format``.\n300 \n301         Parameters\n302         ----------\n303         data_format : str\n304             The data format identifier. This is the string that is used to\n305             specify the data type when reading/writing.\n306         data_class : class\n307             The class of the object that can be written.\n308 \n309         Returns\n310         -------\n311         writer : callable\n312             The registered writer function for this format and class.\n313         \"\"\"\n314         writers = [(fmt, cls) for fmt, cls in self._writers if fmt == data_format]\n315         for writer_format, writer_class in writers:\n316             if self._is_best_match(data_class, writer_class, writers):\n317                 return self._writers[(writer_format, writer_class)][0]\n318         else:\n319             format_table_str = self._get_format_table_str(data_class, 'Write')\n320             raise IORegistryError(\n321                 \"No writer defined for format '{}' and class '{}'.\\n\\nThe \"\n322                 \"available formats are:\\n\\n{}\".format(\n323                     data_format, data_class.__name__, format_table_str))\n324 \n325     def write(self, data, *args, format=None, **kwargs):\n326         \"\"\"\n327         Write out data.\n328 \n329         Parameters\n330         ----------\n331         data : object\n332             The data to write.\n333         *args\n334             The arguments passed to this method depend on the format.\n335         format : str or None\n336         **kwargs\n337             The arguments passed to this method depend on the format.\n338 \n339         Returns\n340         -------\n341         object or None\n342             The output of the registered writer. Most often `None`.\n343 \n344             .. versionadded:: 4.3\n345         \"\"\"\n346         # Expand a tilde-prefixed path if present in args[0]\n347         args = _expand_user_in_args(args)\n348 \n349         if format is None:\n350             path = None\n351             fileobj = None\n352             if len(args):\n353                 if isinstance(args[0], PATH_TYPES):\n354                     # path might be a os.PathLike object\n355                     if isinstance(args[0], os.PathLike):\n356                         args = (os.fspath(args[0]),) + args[1:]\n357                     path = args[0]\n358                     fileobj = None\n359                 elif hasattr(args[0], 'read'):\n360                     path = None\n361                     fileobj = args[0]\n362 \n363             format = self._get_valid_format(\n364                 'write', data.__class__, path, fileobj, args, kwargs)\n365 \n366         writer = self.get_writer(format, data.__class__)\n367         return writer(data, *args, **kwargs)\n368 \n369 \n370 # -----------------------------------------------------------------------------\n371 \n372 class UnifiedIORegistry(UnifiedInputRegistry, UnifiedOutputRegistry):\n373     \"\"\"Unified I/O Registry.\n374 \n375     .. versionadded:: 5.0\n376     \"\"\"\n377 \n378     def __init__(self):\n379         super().__init__()\n380         self._registries_order = (\"read\", \"write\", \"identify\")\n381 \n382     def get_formats(self, data_class=None, readwrite=None):\n383         \"\"\"\n384         Get the list of registered I/O formats as a `~astropy.table.Table`.\n385 \n386         Parameters\n387         ----------\n388         data_class : class, optional\n389             Filter readers/writer to match data class (default = all classes).\n390 \n391         readwrite : str or None, optional\n392             Search only for readers (``\"Read\"``) or writers (``\"Write\"``).\n393             If None search for both.  Default is None.\n394 \n395             .. versionadded:: 1.3\n396 \n397         Returns\n398         -------\n399         format_table : :class:`~astropy.table.Table`\n400             Table of available I/O formats.\n401         \"\"\"\n402         return super().get_formats(data_class, readwrite)\n",
        "intended_behavior": "Ensure that the registration system can accommodate the new HTML writer for `Cosmology`. This may involve adding a new format specifier for `html` that specifically targets `Cosmology` objects, and ensuring that the `write` method can appropriately dispatch `Cosmology` instances to the new HTML writer function when the `format='html'` argument is used."
    }
]