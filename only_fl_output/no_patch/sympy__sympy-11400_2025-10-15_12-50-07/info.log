2025-10-15 12:50:07.547 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 12:50:12.816 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=207, output_tokens=12, cost=0.002430
2025-10-15 12:50:29.380 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=387, output_tokens=574, cost=0.021090
2025-10-15 12:50:31.110 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:50:38.598 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=516, output_tokens=227, cost=0.011970
2025-10-15 12:50:38.603 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:50:42.839 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=581, output_tokens=45, cost=0.007160
2025-10-15 12:50:42.840 | DEBUG    | Extracted a valid json.
2025-10-15 12:50:42.840 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"ccode\")",
        "search_code(\"sinc(x)\")",
        "search_code(\"Piecewise\")"
    ],
    "bug_locations": []
}
2025-10-15 12:50:43.342 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 12:50:43.343 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 12:51:05.829 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3292, output_tokens=819, cost=0.057490
2025-10-15 12:51:05.837 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 12:51:16.823 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4327, output_tokens=472, cost=0.057430
2025-10-15 12:51:16.832 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 12:51:30.171 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=826, output_tokens=478, cost=0.022600
2025-10-15 12:51:30.172 | DEBUG    | Extracted a valid json.
2025-10-15 12:51:30.172 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/ccode.py",
            "class": "",
            "method": "ccode",
            "intended_behavior": "The `ccode` method should be enhanced to include support for converting `sinc(x)` expressions into an equivalent C code representation. Given that `sinc(x)` can be expressed as `sin(x)/x` for `x != 0`, and `1` for `x = 0`, the method should incorporate logic similar to handling `Piecewise` expressions, as evidenced in the current implementation for other mathematical expressions. The addition should preserve all existing functionalities of the `ccode` method, only extending it to recognize and properly convert `sinc(x)` expressions. Potential approaches include either directly implementing the conversion within the method based on detected `sinc(x)` patterns or leveraging the `user_functions` argument more effectively to allow users to specify custom conversions for unsupported functions like `sinc(x)`."
        },
        {
            "file": "sympy/functions/elementary/trigonometric.py",
            "class": "",
            "method": "",
            "intended_behavior": "Although not directly buggy, this file might need a review or update to ensure that the definition and handling of `sinc(x)` within SymPy are conducive to conversion to C code via `ccode`. Specifically, the documentation or meta-information of `sinc(x)` could include hints or properties that `ccode` can utilize to recognize and convert `sinc(x)` expressions more effectively. Enhancing how `sinc(x)` is represented in the context of SymPy's elementary trigonometric functions could aid in its conversion to C code, ensuring a seamless process when such expressions are encountered by `ccode`. If `sinc(x)` is treated specially in terms of symbolic manipulation or simplification, such properties should be documented or coded in a way that `ccode` (or any code-printing routine) can easily translate it into the target language's idioms or library function calls, if available, or into a manually specified piecewise expression otherwise. This may imply refining the symbolic properties of `sinc(x)` to ensure they align with the expectations and capabilities of the code conversion routines."
        }
    ]
}
2025-10-15 12:51:30.183 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/ccode.py</file>
<class>None</class>
<method>ccode</method>
<code>
283 def ccode(expr, assign_to=None, **settings):
284     """Converts an expr to a string of c code
285 
286     Parameters
287     ==========
288 
289     expr : Expr
290         A sympy expression to be converted.
291     assign_to : optional
292         When given, the argument is used as the name of the variable to which
293         the expression is assigned. Can be a string, ``Symbol``,
294         ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of
295         line-wrapping, or for expressions that generate multi-line statements.
296     precision : integer, optional
297         The precision for numbers such as pi [default=15].
298     user_functions : dict, optional
299         A dictionary where the keys are string representations of either
300         ``FunctionClass`` or ``UndefinedFunction`` instances and the values
301         are their desired C string representations. Alternatively, the
302         dictionary value can be a list of tuples i.e. [(argument_test,
303         cfunction_string)].  See below for examples.
304     dereference : iterable, optional
305         An iterable of symbols that should be dereferenced in the printed code
306         expression. These would be values passed by address to the function.
307         For example, if ``dereference=[a]``, the resulting code would print
308         ``(*a)`` instead of ``a``.
309     human : bool, optional
310         If True, the result is a single string that may contain some constant
311         declarations for the number symbols. If False, the same information is
312         returned in a tuple of (symbols_to_declare, not_supported_functions,
313         code_text). [default=True].
314     contract: bool, optional
315         If True, ``Indexed`` instances are assumed to obey tensor contraction
316         rules and the corresponding nested loops over indices are generated.
317         Setting contract=False will not generate loops, instead the user is
318         responsible to provide values for the indices in the code.
319         [default=True].
320 
321     Examples
322     ========
323 
324     >>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function
325     >>> x, tau = symbols("x, tau")
326     >>> ccode((2*tau)**Rational(7, 2))
327     '8*sqrt(2)*pow(tau, 7.0L/2.0L)'
328     >>> ccode(sin(x), assign_to="s")
329     's = sin(x);'
330 
331     Simple custom printing can be defined for certain types by passing a
332     dictionary of {"type" : "function"} to the ``user_functions`` kwarg.
333     Alternatively, the dictionary value can be a list of tuples i.e.
334     [(argument_test, cfunction_string)].
335 
336     >>> custom_functions = {
337     ...   "ceiling": "CEIL",
338     ...   "Abs": [(lambda x: not x.is_integer, "fabs"),
339     ...           (lambda x: x.is_integer, "ABS")],
340     ...   "func": "f"
341     ... }
342     >>> func = Function('func')
343     >>> ccode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)
344     'f(fabs(x) + CEIL(x))'
345 
346     ``Piecewise`` expressions are converted into conditionals. If an
347     ``assign_to`` variable is provided an if statement is created, otherwise
348     the ternary operator is used. Note that if the ``Piecewise`` lacks a
349     default term, represented by ``(expr, True)`` then an error will be thrown.
350     This is to prevent generating an expression that may not evaluate to
351     anything.
352 
353     >>> from sympy import Piecewise
354     >>> expr = Piecewise((x + 1, x > 0), (x, True))
355     >>> print(ccode(expr, tau))
356     if (x > 0) {
357     tau = x + 1;
358     }
359     else {
360     tau = x;
361     }
362 
363     Support for loops is provided through ``Indexed`` types. With
364     ``contract=True`` these expressions will be turned into loops, whereas
365     ``contract=False`` will just print the assignment expression that should be
366     looped over:
367 
368     >>> from sympy import Eq, IndexedBase, Idx
369     >>> len_y = 5
370     >>> y = IndexedBase('y', shape=(len_y,))
371     >>> t = IndexedBase('t', shape=(len_y,))
372     >>> Dy = IndexedBase('Dy', shape=(len_y-1,))
373     >>> i = Idx('i', len_y-1)
374     >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))
375     >>> ccode(e.rhs, assign_to=e.lhs, contract=False)
376     'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'
377 
378     Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions
379     must be provided to ``assign_to``. Note that any expression that can be
380     generated normally can also exist inside a Matrix:
381 
382     >>> from sympy import Matrix, MatrixSymbol
383     >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])
384     >>> A = MatrixSymbol('A', 3, 1)
385     >>> print(ccode(mat, A))
386     A[0] = pow(x, 2);
387     if (x > 0) {
388        A[1] = x + 1;
389     }
390     else {
391        A[1] = x;
392     }
393     A[2] = sin(x);
394     """
395 
396     return CCodePrinter(settings).doprint(expr, assign_to)

</code><intended_behavior>The `ccode` method should be enhanced to include support for converting `sinc(x)` expressions into an equivalent C code representation. Given that `sinc(x)` can be expressed as `sin(x)/x` for `x != 0`, and `1` for `x = 0`, the method should incorporate logic similar to handling `Piecewise` expressions, as evidenced in the current implementation for other mathematical expressions. The addition should preserve all existing functionalities of the `ccode` method, only extending it to recognize and properly convert `sinc(x)` expressions. Potential approaches include either directly implementing the conversion within the method based on detected `sinc(x)` patterns or leveraging the `user_functions` argument more effectively to allow users to specify custom conversions for unsupported functions like `sinc(x)`.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core.add import Add
4 from sympy.core.basic import sympify, cacheit
5 from sympy.core.function import Function, ArgumentIndexError
6 from sympy.core.numbers import igcdex, Rational
7 from sympy.core.singleton import S
8 from sympy.core.symbol import Symbol
9 from sympy.core.logic import fuzzy_not
10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max
12 from sympy.functions.elementary.exponential import log, exp
13 from sympy.functions.elementary.integers import floor
14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,
15     coth, HyperbolicFunction, sinh, tanh)
16 from sympy.sets.sets import FiniteSet
17 from sympy.utilities.iterables import numbered_symbols
18 from sympy.core.compatibility import range
19 
20 ###############################################################################
21 ########################## TRIGONOMETRIC FUNCTIONS ############################
22 ###############################################################################
23 
24 
25 class TrigonometricFunction(Function):
26     """Base class for trigonometric functions. """
27 
28     unbranched = True
29 
30     def _eval_is_rational(self):
31         s = self.func(*self.args)
32         if s.func == self.func:
33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):
34                 return False
35         else:
36             return s.is_rational
37 
38     def _eval_is_algebraic(self):
39         s = self.func(*self.args)
40         if s.func == self.func:
41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
42                 return False
43             pi_coeff = _pi_coeff(self.args[0])
44             if pi_coeff is not None and pi_coeff.is_rational:
45                 return True
46         else:
47             return s.is_algebraic
48 
49     def _eval_expand_complex(self, deep=True, **hints):
50         re_part, im_part = self.as_real_imag(deep=deep, **hints)
51         return re_part + im_part*S.ImaginaryUnit
52 
53     def _as_real_imag(self, deep=True, **hints):
54         if self.args[0].is_real:
55             if deep:
56                 hints['complex'] = False
57                 return (self.args[0].expand(deep, **hints), S.Zero)
58             else:
59                 return (self.args[0], S.Zero)
60         if deep:
61             re, im = self.args[0].expand(deep, **hints).as_real_imag()
62         else:
63             re, im = self.args[0].as_real_imag()
64         return (re, im)
65 
66 
67 def _peeloff_pi(arg):
68     """
69     Split ARG into two parts, a "rest" and a multiple of pi/2.
70     This assumes ARG to be an Add.
71     The multiple of pi returned in the second position is always a Rational.
72 
73     Examples
74     ========
75 
76     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel
77     >>> from sympy import pi
78     >>> from sympy.abc import x, y
79     >>> peel(x + pi/2)
80     (x, pi/2)
81     >>> peel(x + 2*pi/3 + pi*y)
82     (x + pi*y + pi/6, pi/2)
83     """
84     for a in Add.make_args(arg):
85         if a is S.Pi:
86             K = S.One
87             break
88         elif a.is_Mul:
89             K, p = a.as_two_terms()
90             if p is S.Pi and K.is_Rational:
91                 break
92     else:
93         return arg, S.Zero
94 
95     m1 = (K % S.Half) * S.Pi
96     m2 = K*S.Pi - m1
97     return arg - m2, m2
98 
99 
100 def _pi_coeff(arg, cycles=1):
101     """
102     When arg is a Number times pi (e.g. 3*pi/2) then return the Number
103     normalized to be in the range [0, 2], else None.
104 
105     When an even multiple of pi is encountered, if it is multiplying
106     something with known parity then the multiple is returned as 0 otherwise
107     as 2.
108 
109     Examples
110     ========
111 
112     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
113     >>> from sympy import pi, Dummy
114     >>> from sympy.abc import x, y
115     >>> coeff(3*x*pi)
116     3*x
117     >>> coeff(11*pi/7)
118     11/7
119     >>> coeff(-11*pi/7)
120     3/7
121     >>> coeff(4*pi)
122     0
123     >>> coeff(5*pi)
124     1
125     >>> coeff(5.0*pi)
126     1
127     >>> coeff(5.5*pi)
128     3/2
129     >>> coeff(2 + pi)
130 
131     >>> coeff(2*Dummy(integer=True)*pi)
132     2
133     >>> coeff(2*Dummy(even=True)*pi)
134     0
135     """
136     arg = sympify(arg)
137     if arg is S.Pi:
138         return S.One
139     elif not arg:
140         return S.Zero
141     elif arg.is_Mul:
142         cx = arg.coeff(S.Pi)
143         if cx:
144             c, x = cx.as_coeff_Mul()  # pi is not included as coeff
145             if c.is_Float:
146                 # recast exact binary fractions to Rationals
147                 f = abs(c) % 1
148                 if f != 0:
149                     p = -int(round(log(f, 2).evalf()))
150                     m = 2**p
151                     cm = c*m
152                     i = int(cm)
153                     if i == cm:
154                         c = Rational(i, m)
155                         cx = c*x
156                 else:
157                     c = Rational(int(c))
158                     cx = c*x
159             if x.is_integer:
160                 c2 = c % 2
161                 if c2 == 1:
162                     return x
163                 elif not c2:
164                     if x.is_even is not None:  # known parity
165                         return S.Zero
166                     return S(2)
167                 else:
168                     return c2*x
169             return cx
170 
171 
172 class sin(TrigonometricFunction):
173     """
174     The sine function.
175 
176     Returns the sine of x (measured in radians).
177 
178     Notes
179     =====
180 
181     This function will evaluate automatically in the
182     case x/pi is some rational number [4]_.  For example,
183     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.
184 
185     Examples
186     ========
187 
188     >>> from sympy import sin, pi
189     >>> from sympy.abc import x
190     >>> sin(x**2).diff(x)
191     2*x*cos(x**2)
192     >>> sin(1).diff(x)
193     0
194     >>> sin(pi)
195     0
196     >>> sin(pi/2)
197     1
198     >>> sin(pi/6)
199     1/2
200     >>> sin(pi/12)
201     -sqrt(2)/4 + sqrt(6)/4
202 
203 
204     See Also
205     ========
206 
207     csc, cos, sec, tan, cot
208     asin, acsc, acos, asec, atan, acot, atan2
209 
210     References
211     ==========
212 
213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
214     .. [2] http://dlmf.nist.gov/4.14
215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin
216     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html
217     """
218 
219     def fdiff(self, argindex=1):
220         if argindex == 1:
221             return cos(self.args[0])
222         else:
223             raise ArgumentIndexError(self, argindex)
224 
225     @classmethod
226     def eval(cls, arg):
227         from sympy.calculus import AccumBounds
228         if arg.is_Number:
229             if arg is S.NaN:
230                 return S.NaN
231             elif arg is S.Zero:
232                 return S.Zero
233             elif arg is S.Infinity or arg is S.NegativeInfinity:
234                 return AccumBounds(-1, 1)
235 
236         if isinstance(arg, AccumBounds):
237             min, max = arg.min, arg.max
238             d = floor(min/(2*S.Pi))
239             if min is not S.NegativeInfinity:
240                 min = min - d*2*S.Pi
241             if max is not S.Infinity:
242                 max = max - d*2*S.Pi
243             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
244                     is not S.EmptySet and \
245                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,
246                         7*S.Pi/2)) is not S.EmptySet:
247                 return AccumBounds(-1, 1)
248             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
249                     is not S.EmptySet:
250                 return AccumBounds(Min(sin(min), sin(max)), 1)
251             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \
252                         is not S.EmptySet:
253                 return AccumBounds(-1, Max(sin(min), sin(max)))
254             else:
255                 return AccumBounds(Min(sin(min), sin(max)),
256                                 Max(sin(min), sin(max)))
257 
258         if arg.could_extract_minus_sign():
259             return -cls(-arg)
260 
261         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
262         if i_coeff is not None:
263             return S.ImaginaryUnit * sinh(i_coeff)
264 
265         pi_coeff = _pi_coeff(arg)
266         if pi_coeff is not None:
267             if pi_coeff.is_integer:
268                 return S.Zero
269 
270             if (2*pi_coeff).is_integer:
271                 if pi_coeff.is_even:
272                     return S.Zero
273                 elif pi_coeff.is_even is False:
274                     return S.NegativeOne**(pi_coeff - S.Half)
275 
276             if not pi_coeff.is_Rational:
277                 narg = pi_coeff*S.Pi
278                 if narg != arg:
279                     return cls(narg)
280                 return None
281 
282             # https://github.com/sympy/sympy/issues/6048
283             # transform a sine to a cosine, to avoid redundant code
284             if pi_coeff.is_Rational:
285                 x = pi_coeff % 2
286                 if x > 1:
287                     return -cls((x % 1)*S.Pi)
288                 if 2*x > 1:
289                     return cls((1 - x)*S.Pi)
290                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi
291                 result = cos(narg)
292                 if not isinstance(result, cos):
293                     return result
294                 if pi_coeff*S.Pi != arg:
295                     return cls(pi_coeff*S.Pi)
296                 return None
297 
298         if arg.is_Add:
299             x, m = _peeloff_pi(arg)
300             if m:
301                 return sin(m)*cos(x) + cos(m)*sin(x)
302 
303         if arg.func is asin:
304             return arg.args[0]
305 
306         if arg.func is atan:
307             x = arg.args[0]
308             return x / sqrt(1 + x**2)
309 
310         if arg.func is atan2:
311             y, x = arg.args
312             return y / sqrt(x**2 + y**2)
313 
314         if arg.func is acos:
315             x = arg.args[0]
316             return sqrt(1 - x**2)
317 
318         if arg.func is acot:
319             x = arg.args[0]
320             return 1 / (sqrt(1 + 1 / x**2) * x)
321 
322     @staticmethod
323     @cacheit
324     def taylor_term(n, x, *previous_terms):
325         if n < 0 or n % 2 == 0:
326             return S.Zero
327         else:
328             x = sympify(x)
329 
330             if len(previous_terms) > 2:
331                 p = previous_terms[-2]
332                 return -p * x**2 / (n*(n - 1))
333             else:
334                 return (-1)**(n//2) * x**(n)/factorial(n)
335 
336     def _eval_rewrite_as_exp(self, arg):
337         I = S.ImaginaryUnit
338         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
339             arg = arg.func(arg.args[0]).rewrite(exp)
340         return (exp(arg*I) - exp(-arg*I)) / (2*I)
341 
342     def _eval_rewrite_as_Pow(self, arg):
343         if arg.func is log:
344             I = S.ImaginaryUnit
345             x = arg.args[0]
346             return I*x**-I / 2 - I*x**I /2
347 
348     def _eval_rewrite_as_cos(self, arg):
349         return -cos(arg + S.Pi/2)
350 
351     def _eval_rewrite_as_tan(self, arg):
352         tan_half = tan(S.Half*arg)
353         return 2*tan_half/(1 + tan_half**2)
354 
355     def _eval_rewrite_as_sincos(self, arg):
356         return sin(arg)*cos(arg)/cos(arg)
357 
358     def _eval_rewrite_as_cot(self, arg):
359         cot_half = cot(S.Half*arg)
360         return 2*cot_half/(1 + cot_half**2)
361 
362     def _eval_rewrite_as_pow(self, arg):
363         return self.rewrite(cos).rewrite(pow)
364 
365     def _eval_rewrite_as_sqrt(self, arg):
366         return self.rewrite(cos).rewrite(sqrt)
367 
368     def _eval_rewrite_as_csc(self, arg):
369         return 1/csc(arg)
370 
371     def _eval_conjugate(self):
372         return self.func(self.args[0].conjugate())
373 
374     def as_real_imag(self, deep=True, **hints):
375         re, im = self._as_real_imag(deep=deep, **hints)
376         return (sin(re)*cosh(im), cos(re)*sinh(im))
377 
378     def _eval_expand_trig(self, **hints):
379         from sympy import expand_mul
380         from sympy.functions.special.polynomials import chebyshevt, chebyshevu
381         arg = self.args[0]
382         x = None
383         if arg.is_Add:  # TODO, implement more if deep stuff here
384             # TODO: Do this more efficiently for more than two terms
385             x, y = arg.as_two_terms()
386             sx = sin(x, evaluate=False)._eval_expand_trig()
387             sy = sin(y, evaluate=False)._eval_expand_trig()
388             cx = cos(x, evaluate=False)._eval_expand_trig()
389             cy = cos(y, evaluate=False)._eval_expand_trig()
390             return sx*cy + sy*cx
391         else:
392             n, x = arg.as_coeff_Mul(rational=True)
393             if n.is_Integer:  # n will be positive because of .eval
394                 # canonicalization
395 
396                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html
397                 if n.is_odd:
398                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))
399                 else:
400                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -
401                         1, sin(x)), deep=False)
402             pi_coeff = _pi_coeff(arg)
403             if pi_coeff is not None:
404                 if pi_coeff.is_Rational:
405                     return self.rewrite(sqrt)
406         return sin(arg)
407 
408     def _eval_as_leading_term(self, x):
409         from sympy import Order
410         arg = self.args[0].as_leading_term(x)
411 
412         if x in arg.free_symbols and Order(1, x).contains(arg):
413             return arg
414         else:
415             return self.func(arg)
416 
417     def _eval_is_real(self):
418         return self.args[0].is_real
419 
420     def _eval_is_finite(self):
421         arg = self.args[0]
422         if arg.is_real:
423             return True
424 
425 
426 class cos(TrigonometricFunction):
427     """
428     The cosine function.
429 
430     Returns the cosine of x (measured in radians).
431 
432     Notes
433     =====
434 
435     See :func:`sin` for notes about automatic evaluation.
436 
437     Examples
438     ========
439 
440     >>> from sympy import cos, pi
441     >>> from sympy.abc import x
442     >>> cos(x**2).diff(x)
443     -2*x*sin(x**2)
444     >>> cos(1).diff(x)
445     0
446     >>> cos(pi)
447     -1
448     >>> cos(pi/2)
449     0
450     >>> cos(2*pi/3)
451     -1/2
452     >>> cos(pi/12)
453     sqrt(2)/4 + sqrt(6)/4
454 
455     See Also
456     ========
457 
458     sin, csc, sec, tan, cot
459     asin, acsc, acos, asec, atan, acot, atan2
460 
461     References
462     ==========
463 
464     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
465     .. [2] http://dlmf.nist.gov/4.14
466     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
467     """
468 
469     def fdiff(self, argindex=1):
470         if argindex == 1:
471             return -sin(self.args[0])
472         else:
473             raise ArgumentIndexError(self, argindex)
474 
475     @classmethod
476     def eval(cls, arg):
477         from sympy.functions.special.polynomials import chebyshevt
478         from sympy.calculus.util import AccumBounds
479         if arg.is_Number:
480             if arg is S.NaN:
481                 return S.NaN
482             elif arg is S.Zero:
483                 return S.One
484             elif arg is S.Infinity or arg is S.NegativeInfinity:
485                 # In this case it is better to return AccumBounds(-1, 1)
486                 # rather than returning S.NaN, since AccumBounds(-1, 1)
487                 # preserves the information that sin(oo) is between
488                 # -1 and 1, where S.NaN does not do that.
489                 return AccumBounds(-1, 1)
490 
491         if isinstance(arg, AccumBounds):
492             return sin(arg + S.Pi/2)
493 
494         if arg.could_extract_minus_sign():
495             return cls(-arg)
496 
497         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
498         if i_coeff is not None:
499             return cosh(i_coeff)
500 
501         pi_coeff = _pi_coeff(arg)
502         if pi_coeff is not None:
503             if pi_coeff.is_integer:
504                 return (S.NegativeOne)**pi_coeff
505 
506             if (2*pi_coeff).is_integer:
507                 if pi_coeff.is_even:
508                     return (S.NegativeOne)**(pi_coeff/2)
509                 elif pi_coeff.is_even is False:
510                     return S.Zero
511 
512             if not pi_coeff.is_Rational:
513                 narg = pi_coeff*S.Pi
514                 if narg != arg:
515                     return cls(narg)
516                 return None
517 
518             # cosine formula #####################
519             # https://github.com/sympy/sympy/issues/6048
520             # explicit calculations are preformed for
521             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
522             # Some other exact values like cos(k pi/240) can be
523             # calculated using a partial-fraction decomposition
524             # by calling cos( X ).rewrite(sqrt)
525             cst_table_some = {
526                 3: S.Half,
527                 5: (sqrt(5) + 1)/4,
528             }
529             if pi_coeff.is_Rational:
530                 q = pi_coeff.q
531                 p = pi_coeff.p % (2*q)
532                 if p > q:
533                     narg = (pi_coeff - 1)*S.Pi
534                     return -cls(narg)
535                 if 2*p > q:
536                     narg = (1 - pi_coeff)*S.Pi
537                     return -cls(narg)
538 
539                 # If nested sqrt's are worse than un-evaluation
540                 # you can require q to be in (1, 2, 3, 4, 6, 12)
541                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
542                 # expressions with 2 or fewer sqrt nestings.
543                 table2 = {
544                     12: (3, 4),
545                     20: (4, 5),
546                     30: (5, 6),
547                     15: (6, 10),
548                     24: (6, 8),
549                     40: (8, 10),
550                     60: (20, 30),
551                     120: (40, 60)
552                     }
553                 if q in table2:
554                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
555                     nvala, nvalb = cls(a), cls(b)
556                     if None == nvala or None == nvalb:
557                         return None
558                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
559 
560                 if q > 12:
561                     return None
562 
563                 if q in cst_table_some:
564                     cts = cst_table_some[pi_coeff.q]
565                     return chebyshevt(pi_coeff.p, cts).expand()
566 
567                 if 0 == q % 2:
568                     narg = (pi_coeff*2)*S.Pi
569                     nval = cls(narg)
570                     if None == nval:
571                         return None
572                     x = (2*pi_coeff + 1)/2
573                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
574                     return sign_cos*sqrt( (1 + nval)/2 )
575             return None
576 
577         if arg.is_Add:
578             x, m = _peeloff_pi(arg)
579             if m:
580                 return cos(m)*cos(x) - sin(m)*sin(x)
581 
582         if arg.func is acos:
583             return arg.args[0]
584 
585         if arg.func is atan:
586             x = arg.args[0]
587             return 1 / sqrt(1 + x**2)
588 
589         if arg.func is atan2:
590             y, x = arg.args
591             return x / sqrt(x**2 + y**2)
592 
593         if arg.func is asin:
594             x = arg.args[0]
595             return sqrt(1 - x ** 2)
596 
597         if arg.func is acot:
598             x = arg.args[0]
599             return 1 / sqrt(1 + 1 / x**2)
600 
601     @staticmethod
602     @cacheit
603     def taylor_term(n, x, *previous_terms):
604         if n < 0 or n % 2 == 1:
605             return S.Zero
606         else:
607             x = sympify(x)
608 
609             if len(previous_terms) > 2:
610                 p = previous_terms[-2]
611                 return -p * x**2 / (n*(n - 1))
612             else:
613                 return (-1)**(n//2)*x**(n)/factorial(n)
614 
615     def _eval_rewrite_as_exp(self, arg):
616         I = S.ImaginaryUnit
617         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
618             arg = arg.func(arg.args[0]).rewrite(exp)
619         return (exp(arg*I) + exp(-arg*I)) / 2
620 
621     def _eval_rewrite_as_Pow(self, arg):
622         if arg.func is log:
623             I = S.ImaginaryUnit
624             x = arg.args[0]
625             return x**I/2 + x**-I/2
626 
627     def _eval_rewrite_as_sin(self, arg):
628         return sin(arg + S.Pi/2)
629 
630     def _eval_rewrite_as_tan(self, arg):
631         tan_half = tan(S.Half*arg)**2
632         return (1 - tan_half)/(1 + tan_half)
633 
634     def _eval_rewrite_as_sincos(self, arg):
635         return sin(arg)*cos(arg)/sin(arg)
636 
637     def _eval_rewrite_as_cot(self, arg):
638         cot_half = cot(S.Half*arg)**2
639         return (cot_half - 1)/(cot_half + 1)
640 
641     def _eval_rewrite_as_pow(self, arg):
642         return self._eval_rewrite_as_sqrt(arg)
643 
644     def _eval_rewrite_as_sqrt(self, arg):
645         from sympy.functions.special.polynomials import chebyshevt
646 
647         def migcdex(x):
648             # recursive calcuation of gcd and linear combination
649             # for a sequence of integers.
650             # Given  (x1, x2, x3)
651             # Returns (y1, y1, y3, g)
652             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
653             # Note, that this is only one such linear combination.
654             if len(x) == 1:
655                 return (1, x[0])
656             if len(x) == 2:
657                 return igcdex(x[0], x[-1])
658             g = migcdex(x[1:])
659             u, v, h = igcdex(x[0], g[-1])
660             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
661 
662         def ipartfrac(r, factors=None):
663             from sympy.ntheory import factorint
664             if isinstance(r, int):
665                 return r
666             if not isinstance(r, Rational):
667                 raise TypeError("r is not rational")
668             n = r.q
669             if 2 > r.q*r.q:
670                 return r.q
671 
672             if None == factors:
673                 a = [n//x**y for x, y in factorint(r.q).items()]
674             else:
675                 a = [n//x for x in factors]
676             if len(a) == 1:
677                 return [ r ]
678             h = migcdex(a)
679             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
680             assert r == sum(ans)
681             return ans
682         pi_coeff = _pi_coeff(arg)
683         if pi_coeff is None:
684             return None
685 
686         if pi_coeff.is_integer:
687             # it was unevaluated
688             return self.func(pi_coeff*S.Pi)
689 
690         if not pi_coeff.is_Rational:
691             return None
692 
693         def _cospi257():
694             """ Express cos(pi/257) explicitly as a function of radicals
695                 Based upon the equations in
696                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
697                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
698             """
699             def f1(a, b):
700                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
701 
702             def f2(a, b):
703                 return (a - sqrt(a**2 + b))/2
704 
705             t1, t2 = f1(-1, 256)
706             z1, z3 = f1(t1, 64)
707             z2, z4 = f1(t2, 64)
708             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
709             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
710             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
711             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
712             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
713             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
714             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
715             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
716             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
717             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
718             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
719             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
720             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
721             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
722             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
723             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
724             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
725             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
726             u1 = -f2(-v1, -4*(v2 + v3))
727             u2 = -f2(-v4, -4*(v5 + v6))
728             w1 = -2*f2(-u1, -4*u2)
729             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
730 
731         cst_table_some = {
732             3: S.Half,
733             5: (sqrt(5) + 1)/4,
734             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
735                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
736                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
737             257: _cospi257()
738             # 65537 is the only other known Fermat prime and the very
739             # large expression is intentionally omitted from SymPy; see
740             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
741         }
742 
743         def _fermatCoords(n):
744             # if n can be factored in terms of Fermat primes with
745             # multiplicity of each being 1, return those primes, else
746             # False
747             from sympy import chebyshevt
748             primes = []
749             for p_i in cst_table_some:
750                 n, r = divmod(n, p_i)
751                 if not r:
752                     primes.append(p_i)
753                     if n == 1:
754                         return tuple(primes)
755             return False
756 
757         if pi_coeff.q in cst_table_some:
758             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
759             if pi_coeff.q < 257:
760                 rv = rv.expand()
761             return rv
762 
763         if not pi_coeff.q % 2:  # recursively remove factors of 2
764             pico2 = pi_coeff*2
765             nval = cos(pico2*S.Pi).rewrite(sqrt)
766             x = (pico2 + 1)/2
767             sign_cos = -1 if int(x) % 2 else 1
768             return sign_cos*sqrt( (1 + nval)/2 )
769 
770         FC = _fermatCoords(pi_coeff.q)
771         if FC:
772             decomp = ipartfrac(pi_coeff, FC)
773             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
774             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
775             return pcls.rewrite(sqrt)
776         else:
777             decomp = ipartfrac(pi_coeff)
778             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
779             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
780             return pcls
781 
782     def _eval_rewrite_as_sec(self, arg):
783         return 1/sec(arg)
784 
785     def _eval_conjugate(self):
786         return self.func(self.args[0].conjugate())
787 
788     def as_real_imag(self, deep=True, **hints):
789         re, im = self._as_real_imag(deep=deep, **hints)
790         return (cos(re)*cosh(im), -sin(re)*sinh(im))
791 
792     def _eval_expand_trig(self, **hints):
793         from sympy.functions.special.polynomials import chebyshevt
794         arg = self.args[0]
795         x = None
796         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
797             x, y = arg.as_two_terms()
798             sx = sin(x, evaluate=False)._eval_expand_trig()
799             sy = sin(y, evaluate=False)._eval_expand_trig()
800             cx = cos(x, evaluate=False)._eval_expand_trig()
801             cy = cos(y, evaluate=False)._eval_expand_trig()
802             return cx*cy - sx*sy
803         else:
804             coeff, terms = arg.as_coeff_Mul(rational=True)
805             if coeff.is_Integer:
806                 return chebyshevt(coeff, cos(terms))
807             pi_coeff = _pi_coeff(arg)
808             if pi_coeff is not None:
809                 if pi_coeff.is_Rational:
810                     return self.rewrite(sqrt)
811         return cos(arg)
812 
813     def _eval_as_leading_term(self, x):
814         from sympy import Order
815         arg = self.args[0].as_leading_term(x)
816 
817         if x in arg.free_symbols and Order(1, x).contains(arg):
818             return S.One
819         else:
820             return self.func(arg)
821 
822     def _eval_is_real(self):
823         return self.args[0].is_real
824 
825     def _eval_is_finite(self):
826         arg = self.args[0]
827 
828         if arg.is_real:
829             return True
830 
831 
832 class tan(TrigonometricFunction):
833     """
834     The tangent function.
835 
836     Returns the tangent of x (measured in radians).
837 
838     Notes
839     =====
840 
841     See :func:`sin` for notes about automatic evaluation.
842 
843     Examples
844     ========
845 
846     >>> from sympy import tan, pi
847     >>> from sympy.abc import x
848     >>> tan(x**2).diff(x)
849     2*x*(tan(x**2)**2 + 1)
850     >>> tan(1).diff(x)
851     0
852     >>> tan(pi/8).expand()
853     -1 + sqrt(2)
854 
855     See Also
856     ========
857 
858     sin, csc, cos, sec, cot
859     asin, acsc, acos, asec, atan, acot, atan2
860 
861     References
862     ==========
863 
864     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
865     .. [2] http://dlmf.nist.gov/4.14
866     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan
867     """
868 
869     def fdiff(self, argindex=1):
870         if argindex == 1:
871             return S.One + self**2
872         else:
873             raise ArgumentIndexError(self, argindex)
874 
875     def inverse(self, argindex=1):
876         """
877         Returns the inverse of this function.
878         """
879         return atan
880 
881     @classmethod
882     def eval(cls, arg):
883         from sympy.calculus.util import AccumBounds
884         if arg.is_Number:
885             if arg is S.NaN:
886                 return S.NaN
887             elif arg is S.Zero:
888                 return S.Zero
889             elif arg is S.Infinity or arg is S.NegativeInfinity:
890                 return AccumBounds(S.NegativeInfinity, S.Infinity)
891 
892         if isinstance(arg, AccumBounds):
893             min, max = arg.min, arg.max
894             d = floor(min/S.Pi)
895             if min is not S.NegativeInfinity:
896                 min = min - d*S.Pi
897             if max is not S.Infinity:
898                 max = max - d*S.Pi
899             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):
900                 return AccumBounds(S.NegativeInfinity, S.Infinity)
901             else:
902                 return AccumBounds(tan(min), tan(max))
903 
904         if arg.could_extract_minus_sign():
905             return -cls(-arg)
906 
907         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
908         if i_coeff is not None:
909             return S.ImaginaryUnit * tanh(i_coeff)
910 
911         pi_coeff = _pi_coeff(arg, 2)
912         if pi_coeff is not None:
913             if pi_coeff.is_integer:
914                 return S.Zero
915 
916             if not pi_coeff.is_Rational:
917                 narg = pi_coeff*S.Pi
918                 if narg != arg:
919                     return cls(narg)
920                 return None
921 
922             if pi_coeff.is_Rational:
923                 if not pi_coeff.q % 2:
924                     narg = pi_coeff*S.Pi*2
925                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
926                     if not isinstance(cresult, cos) \
927                             and not isinstance(sresult, cos):
928                         if sresult == 0:
929                             return S.ComplexInfinity
930                         return (1 - cresult)/sresult
931                 table2 = {
932                     12: (3, 4),
933                     20: (4, 5),
934                     30: (5, 6),
935                     15: (6, 10),
936                     24: (6, 8),
937                     40: (8, 10),
938                     60: (20, 30),
939                     120: (40, 60)
940                     }
941                 q = pi_coeff.q
942                 p = pi_coeff.p % q
943                 if q in table2:
944                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
945                     if None == nvala or None == nvalb:
946                         return None
947                     return (nvala - nvalb)/(1 + nvala*nvalb)
948                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi
949                 # see cos() to specify which expressions should  be
950                 # expanded automatically in terms of radicals
951                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
952                 if not isinstance(cresult, cos) \
953                         and not isinstance(sresult, cos):
954                     if cresult == 0:
955                         return S.ComplexInfinity
956                     return (sresult/cresult)
957                 if narg != arg:
958                     return cls(narg)
959 
960         if arg.is_Add:
961             x, m = _peeloff_pi(arg)
962             if m:
963                 tanm = tan(m)
964                 tanx = tan(x)
965                 if tanm is S.ComplexInfinity:
966                     return -cot(x)
967                 return (tanm + tanx)/(1 - tanm*tanx)
968 
969         if arg.func is atan:
970             return arg.args[0]
971 
972         if arg.func is atan2:
973             y, x = arg.args
974             return y/x
975 
976         if arg.func is asin:
977             x = arg.args[0]
978             return x / sqrt(1 - x**2)
979 
980         if arg.func is acos:
981             x = arg.args[0]
982             return sqrt(1 - x**2) / x
983 
984         if arg.func is acot:
985             x = arg.args[0]
986             return 1 / x
987 
988     @staticmethod
989     @cacheit
990     def taylor_term(n, x, *previous_terms):
991         from sympy import bernoulli
992         if n < 0 or n % 2 == 0:
993             return S.Zero
994         else:
995             x = sympify(x)
996 
997             a, b = ((n - 1)//2), 2**(n + 1)
998 
999             B = bernoulli(n + 1)
1000             F = factorial(n + 1)
1001 
1002             return (-1)**a * b*(b - 1) * B/F * x**n
1003 
1004     def _eval_nseries(self, x, n, logx):
1005         i = self.args[0].limit(x, 0)*2/S.Pi
1006         if i and i.is_Integer:
1007             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1008         return Function._eval_nseries(self, x, n=n, logx=logx)
1009 
1010     def _eval_rewrite_as_Pow(self, arg):
1011         if arg.func is log:
1012             I = S.ImaginaryUnit
1013             x = arg.args[0]
1014             return I*(x**-I - x**I)/(x**-I + x**I)
1015 
1016     def _eval_conjugate(self):
1017         return self.func(self.args[0].conjugate())
1018 
1019     def as_real_imag(self, deep=True, **hints):
1020         re, im = self._as_real_imag(deep=deep, **hints)
1021         if im:
1022             denom = cos(2*re) + cosh(2*im)
1023             return (sin(2*re)/denom, sinh(2*im)/denom)
1024         else:
1025             return (self.func(re), S.Zero)
1026 
1027     def _eval_expand_trig(self, **hints):
1028         from sympy import im, re
1029         arg = self.args[0]
1030         x = None
1031         if arg.is_Add:
1032             from sympy import symmetric_poly
1033             n = len(arg.args)
1034             TX = []
1035             for x in arg.args:
1036                 tx = tan(x, evaluate=False)._eval_expand_trig()
1037                 TX.append(tx)
1038 
1039             Yg = numbered_symbols('Y')
1040             Y = [ next(Yg) for i in range(n) ]
1041 
1042             p = [0, 0]
1043             for i in range(n + 1):
1044                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)
1045             return (p[0]/p[1]).subs(list(zip(Y, TX)))
1046 
1047         else:
1048             coeff, terms = arg.as_coeff_Mul(rational=True)
1049             if coeff.is_Integer and coeff > 1:
1050                 I = S.ImaginaryUnit
1051                 z = Symbol('dummy', real=True)
1052                 P = ((1 + I*z)**coeff).expand()
1053                 return (im(P)/re(P)).subs([(z, tan(terms))])
1054         return tan(arg)
1055 
1056     def _eval_rewrite_as_exp(self, arg):
1057         I = S.ImaginaryUnit
1058         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1059             arg = arg.func(arg.args[0]).rewrite(exp)
1060         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1061         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)
1062 
1063     def _eval_rewrite_as_sin(self, x):
1064         return 2*sin(x)**2/sin(2*x)
1065 
1066     def _eval_rewrite_as_cos(self, x):
1067         return -cos(x + S.Pi/2)/cos(x)
1068 
1069     def _eval_rewrite_as_sincos(self, arg):
1070         return sin(arg)/cos(arg)
1071 
1072     def _eval_rewrite_as_cot(self, arg):
1073         return 1/cot(arg)
1074 
1075     def _eval_rewrite_as_pow(self, arg):
1076         y = self.rewrite(cos).rewrite(pow)
1077         if y.has(cos):
1078             return None
1079         return y
1080 
1081     def _eval_rewrite_as_sqrt(self, arg):
1082         y = self.rewrite(cos).rewrite(sqrt)
1083         if y.has(cos):
1084             return None
1085         return y
1086 
1087     def _eval_as_leading_term(self, x):
1088         from sympy import Order
1089         arg = self.args[0].as_leading_term(x)
1090 
1091         if x in arg.free_symbols and Order(1, x).contains(arg):
1092             return arg
1093         else:
1094             return self.func(arg)
1095 
1096     def _eval_is_real(self):
1097         return self.args[0].is_real
1098 
1099     def _eval_is_finite(self):
1100         arg = self.args[0]
1101 
1102         if arg.is_imaginary:
1103             return True
1104 
1105 
1106 class cot(TrigonometricFunction):
1107     """
1108     The cotangent function.
1109 
1110     Returns the cotangent of x (measured in radians).
1111 
1112     Notes
1113     =====
1114 
1115     See :func:`sin` for notes about automatic evaluation.
1116 
1117     Examples
1118     ========
1119 
1120     >>> from sympy import cot, pi
1121     >>> from sympy.abc import x
1122     >>> cot(x**2).diff(x)
1123     2*x*(-cot(x**2)**2 - 1)
1124     >>> cot(1).diff(x)
1125     0
1126     >>> cot(pi/12)
1127     sqrt(3) + 2
1128 
1129     See Also
1130     ========
1131 
1132     sin, csc, cos, sec, tan
1133     asin, acsc, acos, asec, atan, acot, atan2
1134 
1135     References
1136     ==========
1137 
1138     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1139     .. [2] http://dlmf.nist.gov/4.14
1140     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot
1141     """
1142 
1143     def fdiff(self, argindex=1):
1144         if argindex == 1:
1145             return S.NegativeOne - self**2
1146         else:
1147             raise ArgumentIndexError(self, argindex)
1148 
1149     def inverse(self, argindex=1):
1150         """
1151         Returns the inverse of this function.
1152         """
1153         return acot
1154 
1155     @classmethod
1156     def eval(cls, arg):
1157         from sympy.calculus.util import AccumBounds
1158         if arg.is_Number:
1159             if arg is S.NaN:
1160                 return S.NaN
1161             if arg is S.Zero:
1162                 return S.ComplexInfinity
1163 
1164         if isinstance(arg, AccumBounds):
1165             return -tan(arg + S.Pi/2)
1166 
1167         if arg.could_extract_minus_sign():
1168             return -cls(-arg)
1169 
1170         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1171         if i_coeff is not None:
1172             return -S.ImaginaryUnit * coth(i_coeff)
1173 
1174         pi_coeff = _pi_coeff(arg, 2)
1175         if pi_coeff is not None:
1176             if pi_coeff.is_integer:
1177                 return S.ComplexInfinity
1178 
1179             if not pi_coeff.is_Rational:
1180                 narg = pi_coeff*S.Pi
1181                 if narg != arg:
1182                     return cls(narg)
1183                 return None
1184 
1185             if pi_coeff.is_Rational:
1186                 if pi_coeff.q > 2 and not pi_coeff.q % 2:
1187                     narg = pi_coeff*S.Pi*2
1188                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1189                     if not isinstance(cresult, cos) \
1190                             and not isinstance(sresult, cos):
1191                         return (1 + cresult)/sresult
1192                 table2 = {
1193                     12: (3, 4),
1194                     20: (4, 5),
1195                     30: (5, 6),
1196                     15: (6, 10),
1197                     24: (6, 8),
1198                     40: (8, 10),
1199                     60: (20, 30),
1200                     120: (40, 60)
1201                     }
1202                 q = pi_coeff.q
1203                 p = pi_coeff.p % q
1204                 if q in table2:
1205                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1206                     if None == nvala or None == nvalb:
1207                         return None
1208                     return (1 + nvala*nvalb)/(nvalb - nvala)
1209                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi
1210                 # see cos() to specify which expressions should be
1211                 # expanded automatically in terms of radicals
1212                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1213                 if not isinstance(cresult, cos) \
1214                         and not isinstance(sresult, cos):
1215                     if sresult == 0:
1216                         return S.ComplexInfinity
1217                     return cresult / sresult
1218                 if narg != arg:
1219                     return cls(narg)
1220 
1221         if arg.is_Add:
1222             x, m = _peeloff_pi(arg)
1223             if m:
1224                 cotm = cot(m)
1225                 if cotm == 0:
1226                     return -tan(x)
1227                 cotx = cot(x)
1228                 if cotm is S.ComplexInfinity:
1229                     return cotx
1230                 if cotm.is_Rational:
1231                     return (cotm*cotx - 1) / (cotm + cotx)
1232             return None
1233 
1234         if arg.func is acot:
1235             return arg.args[0]
1236 
1237         if arg.func is atan:
1238             x = arg.args[0]
1239             return 1 / x
1240 
1241         if arg.func is atan2:
1242             y, x = arg.args
1243             return x/y
1244 
1245         if arg.func is asin:
1246             x = arg.args[0]
1247             return sqrt(1 - x**2) / x
1248 
1249         if arg.func is acos:
1250             x = arg.args[0]
1251             return x / sqrt(1 - x**2)
1252 
1253     @staticmethod
1254     @cacheit
1255     def taylor_term(n, x, *previous_terms):
1256         from sympy import bernoulli
1257         if n == 0:
1258             return 1 / sympify(x)
1259         elif n < 0 or n % 2 == 0:
1260             return S.Zero
1261         else:
1262             x = sympify(x)
1263 
1264             B = bernoulli(n + 1)
1265             F = factorial(n + 1)
1266 
1267             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n
1268 
1269     def _eval_nseries(self, x, n, logx):
1270         i = self.args[0].limit(x, 0)/S.Pi
1271         if i and i.is_Integer:
1272             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1273         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)
1274 
1275     def _eval_conjugate(self):
1276         return self.func(self.args[0].conjugate())
1277 
1278     def as_real_imag(self, deep=True, **hints):
1279         re, im = self._as_real_imag(deep=deep, **hints)
1280         if im:
1281             denom = cos(2*re) - cosh(2*im)
1282             return (-sin(2*re)/denom, -sinh(2*im)/denom)
1283         else:
1284             return (self.func(re), S.Zero)
1285 
1286     def _eval_rewrite_as_exp(self, arg):
1287         I = S.ImaginaryUnit
1288         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1289             arg = arg.func(arg.args[0]).rewrite(exp)
1290         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1291         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)
1292 
1293     def _eval_rewrite_as_Pow(self, arg):
1294         if arg.func is log:
1295             I = S.ImaginaryUnit
1296             x = arg.args[0]
1297             return -I*(x**-I + x**I)/(x**-I - x**I)
1298 
1299     def _eval_rewrite_as_sin(self, x):
1300         return 2*sin(2*x)/sin(x)**2
1301 
1302     def _eval_rewrite_as_cos(self, x):
1303         return -cos(x)/cos(x + S.Pi/2)
1304 
1305     def _eval_rewrite_as_sincos(self, arg):
1306         return cos(arg)/sin(arg)
1307 
1308     def _eval_rewrite_as_tan(self, arg):
1309         return 1/tan(arg)
1310 
1311     def _eval_rewrite_as_pow(self, arg):
1312         y = self.rewrite(cos).rewrite(pow)
1313         if y.has(cos):
1314             return None
1315         return y
1316 
1317     def _eval_rewrite_as_sqrt(self, arg):
1318         y = self.rewrite(cos).rewrite(sqrt)
1319         if y.has(cos):
1320             return None
1321         return y
1322 
1323     def _eval_as_leading_term(self, x):
1324         from sympy import Order
1325         arg = self.args[0].as_leading_term(x)
1326 
1327         if x in arg.free_symbols and Order(1, x).contains(arg):
1328             return 1/arg
1329         else:
1330             return self.func(arg)
1331 
1332     def _eval_is_real(self):
1333         return self.args[0].is_real
1334 
1335     def _eval_expand_trig(self, **hints):
1336         from sympy import im, re
1337         arg = self.args[0]
1338         x = None
1339         if arg.is_Add:
1340             from sympy import symmetric_poly
1341             n = len(arg.args)
1342             CX = []
1343             for x in arg.args:
1344                 cx = cot(x, evaluate=False)._eval_expand_trig()
1345                 CX.append(cx)
1346 
1347             Yg = numbered_symbols('Y')
1348             Y = [ next(Yg) for i in range(n) ]
1349 
1350             p = [0, 0]
1351             for i in range(n, -1, -1):
1352                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)
1353             return (p[0]/p[1]).subs(list(zip(Y, CX)))
1354         else:
1355             coeff, terms = arg.as_coeff_Mul(rational=True)
1356             if coeff.is_Integer and coeff > 1:
1357                 I = S.ImaginaryUnit
1358                 z = Symbol('dummy', real=True)
1359                 P = ((z + I)**coeff).expand()
1360                 return (re(P)/im(P)).subs([(z, cot(terms))])
1361         return cot(arg)
1362 
1363     def _eval_is_finite(self):
1364         arg = self.args[0]
1365         if arg.is_imaginary:
1366             return True
1367 
1368     def _eval_subs(self, old, new):
1369         if self == old:
1370             return new
1371         arg = self.args[0]
1372         argnew = arg.subs(old, new)
1373         if arg != argnew and (argnew/S.Pi).is_integer:
1374             return S.ComplexInfinity
1375         return cot(argnew)
1376 
1377 
1378 class ReciprocalTrigonometricFunction(TrigonometricFunction):
1379     """Base class for reciprocal functions of trigonometric functions. """
1380 
1381     _reciprocal_of = None       # mandatory, to be defined in subclass
1382 
1383     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)
1384     # TODO refactor into TrigonometricFunction common parts of
1385     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.
1386     _is_even = None  # optional, to be defined in subclass
1387     _is_odd = None   # optional, to be defined in subclass
1388 
1389     @classmethod
1390     def eval(cls, arg):
1391         if arg.could_extract_minus_sign():
1392             if cls._is_even:
1393                 return cls(-arg)
1394             if cls._is_odd:
1395                 return -cls(-arg)
1396 
1397         pi_coeff = _pi_coeff(arg)
1398         if (pi_coeff is not None
1399             and not (2*pi_coeff).is_integer
1400             and pi_coeff.is_Rational):
1401                 q = pi_coeff.q
1402                 p = pi_coeff.p % (2*q)
1403                 if p > q:
1404                     narg = (pi_coeff - 1)*S.Pi
1405                     return -cls(narg)
1406                 if 2*p > q:
1407                     narg = (1 - pi_coeff)*S.Pi
1408                     if cls._is_odd:
1409                         return cls(narg)
1410                     elif cls._is_even:
1411                         return -cls(narg)
1412 
1413         t = cls._reciprocal_of.eval(arg)
1414         if hasattr(arg, 'inverse') and arg.inverse() == cls:
1415             return arg.args[0]
1416         return 1/t if t != None else t
1417 
1418     def _call_reciprocal(self, method_name, *args, **kwargs):
1419         # Calls method_name on _reciprocal_of
1420         o = self._reciprocal_of(self.args[0])
1421         return getattr(o, method_name)(*args, **kwargs)
1422 
1423     def _calculate_reciprocal(self, method_name, *args, **kwargs):
1424         # If calling method_name on _reciprocal_of returns a value != None
1425         # then return the reciprocal of that value
1426         t = self._call_reciprocal(method_name, *args, **kwargs)
1427         return 1/t if t != None else t
1428 
1429     def _rewrite_reciprocal(self, method_name, arg):
1430         # Special handling for rewrite functions. If reciprocal rewrite returns
1431         # unmodified expression, then return None
1432         t = self._call_reciprocal(method_name, arg)
1433         if t != None and t != self._reciprocal_of(arg):
1434             return 1/t
1435 
1436     def fdiff(self, argindex=1):
1437         return -self._calculate_reciprocal("fdiff", argindex)/self**2
1438 
1439     def _eval_rewrite_as_exp(self, arg):
1440         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
1441 
1442     def _eval_rewrite_as_Pow(self, arg):
1443         return self._rewrite_reciprocal("_eval_rewrite_as_Pow", arg)
1444 
1445     def _eval_rewrite_as_sin(self, arg):
1446         return self._rewrite_reciprocal("_eval_rewrite_as_sin", arg)
1447 
1448     def _eval_rewrite_as_cos(self, arg):
1449         return self._rewrite_reciprocal("_eval_rewrite_as_cos", arg)
1450 
1451     def _eval_rewrite_as_tan(self, arg):
1452         return self._rewrite_reciprocal("_eval_rewrite_as_tan", arg)
1453 
1454     def _eval_rewrite_as_pow(self, arg):
1455         return self._rewrite_reciprocal("_eval_rewrite_as_pow", arg)
1456 
1457     def _eval_rewrite_as_sqrt(self, arg):
1458         return self._rewrite_reciprocal("_eval_rewrite_as_sqrt", arg)
1459 
1460     def _eval_conjugate(self):
1461         return self.func(self.args[0].conjugate())
1462 
1463     def as_real_imag(self, deep=True, **hints):
1464         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,
1465                                                                   **hints)
1466 
1467     def _eval_expand_trig(self, **hints):
1468         return self._calculate_reciprocal("_eval_expand_trig", **hints)
1469 
1470     def _eval_is_real(self):
1471         return self._reciprocal_of(self.args[0])._eval_is_real()
1472 
1473     def _eval_as_leading_term(self, x):
1474         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
1475 
1476     def _eval_is_finite(self):
1477         return (1/self._reciprocal_of(self.args[0])).is_finite
1478 
1479     def _eval_nseries(self, x, n, logx):
1480         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)
1481 
1482 
1483 class sec(ReciprocalTrigonometricFunction):
1484     """
1485     The secant function.
1486 
1487     Returns the secant of x (measured in radians).
1488 
1489     Notes
1490     =====
1491 
1492     See :func:`sin` for notes about automatic evaluation.
1493 
1494     Examples
1495     ========
1496 
1497     >>> from sympy import sec
1498     >>> from sympy.abc import x
1499     >>> sec(x**2).diff(x)
1500     2*x*tan(x**2)*sec(x**2)
1501     >>> sec(1).diff(x)
1502     0
1503 
1504     See Also
1505     ========
1506 
1507     sin, csc, cos, tan, cot
1508     asin, acsc, acos, asec, atan, acot, atan2
1509 
1510     References
1511     ==========
1512 
1513     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1514     .. [2] http://dlmf.nist.gov/4.14
1515     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec
1516     """
1517 
1518     _reciprocal_of = cos
1519     _is_even = True
1520 
1521     def _eval_rewrite_as_cot(self, arg):
1522         cot_half_sq = cot(arg/2)**2
1523         return (cot_half_sq + 1)/(cot_half_sq - 1)
1524 
1525     def _eval_rewrite_as_cos(self, arg):
1526         return (1/cos(arg))
1527 
1528     def _eval_rewrite_as_sincos(self, arg):
1529         return sin(arg)/(cos(arg)*sin(arg))
1530 
1531     def fdiff(self, argindex=1):
1532         if argindex == 1:
1533             return tan(self.args[0])*sec(self.args[0])
1534         else:
1535             raise ArgumentIndexError(self, argindex)
1536 
1537     @staticmethod
1538     @cacheit
1539     def taylor_term(n, x, *previous_terms):
1540         # Reference Formula:
1541         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/
1542         from sympy.functions.combinatorial.numbers import euler
1543         if n < 0 or n % 2 == 1:
1544             return S.Zero
1545         else:
1546             x = sympify(x)
1547             k = n//2
1548             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)
1549 
1550 
1551 class csc(ReciprocalTrigonometricFunction):
1552     """
1553     The cosecant function.
1554 
1555     Returns the cosecant of x (measured in radians).
1556 
1557     Notes
1558     =====
1559 
1560     See :func:`sin` for notes about automatic evaluation.
1561 
1562     Examples
1563     ========
1564 
1565     >>> from sympy import csc
1566     >>> from sympy.abc import x
1567     >>> csc(x**2).diff(x)
1568     -2*x*cot(x**2)*csc(x**2)
1569     >>> csc(1).diff(x)
1570     0
1571 
1572     See Also
1573     ========
1574 
1575     sin, cos, sec, tan, cot
1576     asin, acsc, acos, asec, atan, acot, atan2
1577 
1578     References
1579     ==========
1580 
1581     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1582     .. [2] http://dlmf.nist.gov/4.14
1583     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc
1584     """
1585 
1586     _reciprocal_of = sin
1587     _is_odd = True
1588 
1589     def _eval_rewrite_as_sin(self, arg):
1590         return (1/sin(arg))
1591 
1592     def _eval_rewrite_as_sincos(self, arg):
1593         return cos(arg)/(sin(arg)*cos(arg))
1594 
1595     def _eval_rewrite_as_cot(self, arg):
1596         cot_half = cot(arg/2)
1597         return (1 + cot_half**2)/(2*cot_half)
1598 
1599     def fdiff(self, argindex=1):
1600         if argindex == 1:
1601             return -cot(self.args[0])*csc(self.args[0])
1602         else:
1603             raise ArgumentIndexError(self, argindex)
1604 
1605     @staticmethod
1606     @cacheit
1607     def taylor_term(n, x, *previous_terms):
1608         from sympy import bernoulli
1609         if n == 0:
1610             return 1/sympify(x)
1611         elif n < 0 or n % 2 == 0:
1612             return S.Zero
1613         else:
1614             x = sympify(x)
1615             k = n//2 + 1
1616             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*
1617                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))
1618 
1619 
1620 class sinc(TrigonometricFunction):
1621     r"""Represents unnormalized sinc function
1622 
1623     Examples
1624     ========
1625 
1626     >>> from sympy import sinc, oo, jn, Product, Symbol
1627     >>> from sympy.abc import x
1628     >>> sinc(x)
1629     sinc(x)
1630 
1631     * Automated Evaluation
1632 
1633     >>> sinc(0)
1634     1
1635     >>> sinc(oo)
1636     0
1637 
1638     * Differentiation
1639 
1640     >>> sinc(x).diff()
1641     (x*cos(x) - sin(x))/x**2
1642 
1643     * Series Expansion
1644 
1645     >>> sinc(x).series()
1646     1 - x**2/6 + x**4/120 + O(x**6)
1647 
1648     * As zero'th order spherical Bessel Function
1649 
1650     >>> sinc(x).rewrite(jn)
1651     jn(0, x)
1652 
1653     References
1654     ==========
1655 
1656     .. [1] http://en.wikipedia.org/wiki/Sinc_function
1657 
1658     """
1659 
1660     def fdiff(self, argindex=1):
1661         x = self.args[0]
1662         if argindex == 1:
1663             return (x*cos(x) - sin(x)) / x**2
1664         else:
1665             raise ArgumentIndexError(self, argindex)
1666 
1667     @classmethod
1668     def eval(cls, arg):
1669         if arg.is_zero:
1670             return S.One
1671         if arg.is_Number:
1672             if arg in [S.Infinity, -S.Infinity]:
1673                 return S.Zero
1674             elif arg is S.NaN:
1675                 return S.NaN
1676 
1677         if arg is S.ComplexInfinity:
1678             return S.NaN
1679 
1680         if arg.could_extract_minus_sign():
1681             return cls(-arg)
1682 
1683         pi_coeff = _pi_coeff(arg)
1684         if pi_coeff is not None:
1685             if pi_coeff.is_integer:
1686                 if fuzzy_not(arg.is_zero):
1687                     return S.Zero
1688             elif (2*pi_coeff).is_integer:
1689                 return S.NegativeOne**(pi_coeff - S.Half) / arg
1690 
1691     def _eval_nseries(self, x, n, logx):
1692         x = self.args[0]
1693         return (sin(x)/x)._eval_nseries(x, n, logx)
1694 
1695     def _eval_rewrite_as_jn(self, arg):
1696         from sympy.functions.special.bessel import jn
1697         return jn(0, arg)
1698 
1699     def _eval_rewrite_as_sin(self, arg):
1700         return sin(arg) / arg
1701 
1702 
1703 ###############################################################################
1704 ########################### TRIGONOMETRIC INVERSES ############################
1705 ###############################################################################
1706 
1707 
1708 class InverseTrigonometricFunction(Function):
1709     """Base class for inverse trigonometric functions."""
1710 
1711     pass
1712 
1713 
1714 class asin(InverseTrigonometricFunction):
1715     """
1716     The inverse sine function.
1717 
1718     Returns the arcsine of x in radians.
1719 
1720     Notes
1721     =====
1722 
1723     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,
1724     -1 and for some instances when the result is a rational multiple
1725     of pi (see the eval class method).
1726 
1727     Examples
1728     ========
1729 
1730     >>> from sympy import asin, oo, pi
1731     >>> asin(1)
1732     pi/2
1733     >>> asin(-1)
1734     -pi/2
1735 
1736     See Also
1737     ========
1738 
1739     sin, csc, cos, sec, tan, cot
1740     acsc, acos, asec, atan, acot, atan2
1741 
1742     References
1743     ==========
1744 
1745     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1746     .. [2] http://dlmf.nist.gov/4.23
1747     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin
1748     """
1749 
1750     def fdiff(self, argindex=1):
1751         if argindex == 1:
1752             return 1/sqrt(1 - self.args[0]**2)
1753         else:
1754             raise ArgumentIndexError(self, argindex)
1755 
1756     def _eval_is_rational(self):
1757         s = self.func(*self.args)
1758         if s.func == self.func:
1759             if s.args[0].is_rational:
1760                 return False
1761         else:
1762             return s.is_rational
1763 
1764     def _eval_is_positive(self):
1765         if self.args[0].is_positive:
1766             return (self.args[0] - 1).is_negative
1767         if self.args[0].is_negative:
1768             return not (self.args[0] + 1).is_positive
1769 
1770     @classmethod
1771     def eval(cls, arg):
1772         if arg.is_Number:
1773             if arg is S.NaN:
1774                 return S.NaN
1775             elif arg is S.Infinity:
1776                 return S.NegativeInfinity * S.ImaginaryUnit
1777             elif arg is S.NegativeInfinity:
1778                 return S.Infinity * S.ImaginaryUnit
1779             elif arg is S.Zero:
1780                 return S.Zero
1781             elif arg is S.One:
1782                 return S.Pi / 2
1783             elif arg is S.NegativeOne:
1784                 return -S.Pi / 2
1785 
1786         if arg.could_extract_minus_sign():
1787             return -cls(-arg)
1788 
1789         if arg.is_number:
1790             cst_table = {
1791                 sqrt(3)/2: 3,
1792                 -sqrt(3)/2: -3,
1793                 sqrt(2)/2: 4,
1794                 -sqrt(2)/2: -4,
1795                 1/sqrt(2): 4,
1796                 -1/sqrt(2): -4,
1797                 sqrt((5 - sqrt(5))/8): 5,
1798                 -sqrt((5 - sqrt(5))/8): -5,
1799                 S.Half: 6,
1800                 -S.Half: -6,
1801                 sqrt(2 - sqrt(2))/2: 8,
1802                 -sqrt(2 - sqrt(2))/2: -8,
1803                 (sqrt(5) - 1)/4: 10,
1804                 (1 - sqrt(5))/4: -10,
1805                 (sqrt(3) - 1)/sqrt(2**3): 12,
1806                 (1 - sqrt(3))/sqrt(2**3): -12,
1807                 (sqrt(5) + 1)/4: S(10)/3,
1808                 -(sqrt(5) + 1)/4: -S(10)/3
1809             }
1810 
1811             if arg in cst_table:
1812                 return S.Pi / cst_table[arg]
1813 
1814         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1815         if i_coeff is not None:
1816             return S.ImaginaryUnit * asinh(i_coeff)
1817 
1818     @staticmethod
1819     @cacheit
1820     def taylor_term(n, x, *previous_terms):
1821         if n < 0 or n % 2 == 0:
1822             return S.Zero
1823         else:
1824             x = sympify(x)
1825             if len(previous_terms) >= 2 and n > 2:
1826                 p = previous_terms[-2]
1827                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1828             else:
1829                 k = (n - 1) // 2
1830                 R = RisingFactorial(S.Half, k)
1831                 F = factorial(k)
1832                 return R / F * x**n / n
1833 
1834     def _eval_as_leading_term(self, x):
1835         from sympy import Order
1836         arg = self.args[0].as_leading_term(x)
1837 
1838         if x in arg.free_symbols and Order(1, x).contains(arg):
1839             return arg
1840         else:
1841             return self.func(arg)
1842 
1843     def _eval_rewrite_as_acos(self, x):
1844         return S.Pi/2 - acos(x)
1845 
1846     def _eval_rewrite_as_atan(self, x):
1847         return 2*atan(x/(1 + sqrt(1 - x**2)))
1848 
1849     def _eval_rewrite_as_log(self, x):
1850         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))
1851 
1852     def _eval_rewrite_as_acot(self, arg):
1853         return 2*acot((1 + sqrt(1 - arg**2))/arg)
1854 
1855     def _eval_rewrite_as_asec(self, arg):
1856         return S.Pi/2 - asec(1/arg)
1857 
1858     def _eval_rewrite_as_acsc(self, arg):
1859         return acsc(1/arg)
1860 
1861     def _eval_is_real(self):
1862         x = self.args[0]
1863         return x.is_real and (1 - abs(x)).is_nonnegative
1864 
1865     def inverse(self, argindex=1):
1866         """
1867         Returns the inverse of this function.
1868         """
1869         return sin
1870 
1871 
1872 class acos(InverseTrigonometricFunction):
1873     """
1874     The inverse cosine function.
1875 
1876     Returns the arc cosine of x (measured in radians).
1877 
1878     Notes
1879     =====
1880 
1881     ``acos(x)`` will evaluate automatically in the cases
1882     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
1883 
1884     ``acos(zoo)`` evaluates to ``zoo``
1885     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)
1886 
1887     Examples
1888     ========
1889 
1890     >>> from sympy import acos, oo, pi
1891     >>> acos(1)
1892     0
1893     >>> acos(0)
1894     pi/2
1895     >>> acos(oo)
1896     oo*I
1897 
1898     See Also
1899     ========
1900 
1901     sin, csc, cos, sec, tan, cot
1902     asin, acsc, asec, atan, acot, atan2
1903 
1904     References
1905     ==========
1906 
1907     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1908     .. [2] http://dlmf.nist.gov/4.23
1909     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos
1910     """
1911 
1912     def fdiff(self, argindex=1):
1913         if argindex == 1:
1914             return -1/sqrt(1 - self.args[0]**2)
1915         else:
1916             raise ArgumentIndexError(self, argindex)
1917 
1918     def _eval_is_rational(self):
1919         s = self.func(*self.args)
1920         if s.func == self.func:
1921             if s.args[0].is_rational:
1922                 return False
1923         else:
1924             return s.is_rational
1925 
1926     def _eval_is_positive(self):
1927         x = self.args[0]
1928         return (1 - abs(x)).is_nonnegative
1929 
1930     @classmethod
1931     def eval(cls, arg):
1932         if arg.is_Number:
1933             if arg is S.NaN:
1934                 return S.NaN
1935             elif arg is S.Infinity:
1936                 return S.Infinity * S.ImaginaryUnit
1937             elif arg is S.NegativeInfinity:
1938                 return S.NegativeInfinity * S.ImaginaryUnit
1939             elif arg is S.Zero:
1940                 return S.Pi / 2
1941             elif arg is S.One:
1942                 return S.Zero
1943             elif arg is S.NegativeOne:
1944                 return S.Pi
1945 
1946         if arg is S.ComplexInfinity:
1947             return S.ComplexInfinity
1948 
1949         if arg.is_number:
1950             cst_table = {
1951                 S.Half: S.Pi/3,
1952                 -S.Half: 2*S.Pi/3,
1953                 sqrt(2)/2: S.Pi/4,
1954                 -sqrt(2)/2: 3*S.Pi/4,
1955                 1/sqrt(2): S.Pi/4,
1956                 -1/sqrt(2): 3*S.Pi/4,
1957                 sqrt(3)/2: S.Pi/6,
1958                 -sqrt(3)/2: 5*S.Pi/6,
1959             }
1960 
1961             if arg in cst_table:
1962                 return cst_table[arg]
1963 
1964     @staticmethod
1965     @cacheit
1966     def taylor_term(n, x, *previous_terms):
1967         if n == 0:
1968             return S.Pi / 2
1969         elif n < 0 or n % 2 == 0:
1970             return S.Zero
1971         else:
1972             x = sympify(x)
1973             if len(previous_terms) >= 2 and n > 2:
1974                 p = previous_terms[-2]
1975                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1976             else:
1977                 k = (n - 1) // 2
1978                 R = RisingFactorial(S.Half, k)
1979                 F = factorial(k)
1980                 return -R / F * x**n / n
1981 
1982     def _eval_as_leading_term(self, x):
1983         from sympy import Order
1984         arg = self.args[0].as_leading_term(x)
1985 
1986         if x in arg.free_symbols and Order(1, x).contains(arg):
1987             return arg
1988         else:
1989             return self.func(arg)
1990 
1991     def _eval_is_real(self):
1992         x = self.args[0]
1993         return x.is_real and (1 - abs(x)).is_nonnegative
1994 
1995     def _eval_rewrite_as_log(self, x):
1996         return S.Pi/2 + S.ImaginaryUnit * \
1997             log(S.ImaginaryUnit * x + sqrt(1 - x**2))
1998 
1999     def _eval_rewrite_as_asin(self, x):
2000         return S.Pi/2 - asin(x)
2001 
2002     def _eval_rewrite_as_atan(self, x):
2003         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))
2004 
2005     def inverse(self, argindex=1):
2006         """
2007         Returns the inverse of this function.
2008         """
2009         return cos
2010 
2011     def _eval_rewrite_as_acot(self, arg):
2012         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)
2013 
2014     def _eval_rewrite_as_asec(self, arg):
2015         return asec(1/arg)
2016 
2017     def _eval_rewrite_as_acsc(self, arg):
2018         return S.Pi/2 - acsc(1/arg)
2019 
2020     def _eval_conjugate(self):
2021         z = self.args[0]
2022         r = self.func(self.args[0].conjugate())
2023         if z.is_real is False:
2024             return r
2025         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:
2026             return r
2027 
2028 
2029 class atan(InverseTrigonometricFunction):
2030     """
2031     The inverse tangent function.
2032 
2033     Returns the arc tangent of x (measured in radians).
2034 
2035     Notes
2036     =====
2037 
2038     atan(x) will evaluate automatically in the cases
2039     oo, -oo, 0, 1, -1.
2040 
2041     Examples
2042     ========
2043 
2044     >>> from sympy import atan, oo, pi
2045     >>> atan(0)
2046     0
2047     >>> atan(1)
2048     pi/4
2049     >>> atan(oo)
2050     pi/2
2051 
2052     See Also
2053     ========
2054 
2055     sin, csc, cos, sec, tan, cot
2056     asin, acsc, acos, asec, acot, atan2
2057 
2058     References
2059     ==========
2060 
2061     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2062     .. [2] http://dlmf.nist.gov/4.23
2063     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan
2064     """
2065 
2066     def fdiff(self, argindex=1):
2067         if argindex == 1:
2068             return 1/(1 + self.args[0]**2)
2069         else:
2070             raise ArgumentIndexError(self, argindex)
2071 
2072     def _eval_is_rational(self):
2073         s = self.func(*self.args)
2074         if s.func == self.func:
2075             if s.args[0].is_rational:
2076                 return False
2077         else:
2078             return s.is_rational
2079 
2080     def _eval_is_positive(self):
2081         return self.args[0].is_positive
2082 
2083     def _eval_is_nonnegative(self):
2084         return self.args[0].is_nonnegative
2085 
2086     @classmethod
2087     def eval(cls, arg):
2088         if arg.is_Number:
2089             if arg is S.NaN:
2090                 return S.NaN
2091             elif arg is S.Infinity:
2092                 return S.Pi / 2
2093             elif arg is S.NegativeInfinity:
2094                 return -S.Pi / 2
2095             elif arg is S.Zero:
2096                 return S.Zero
2097             elif arg is S.One:
2098                 return S.Pi / 4
2099             elif arg is S.NegativeOne:
2100                 return -S.Pi / 4
2101         if arg.could_extract_minus_sign():
2102             return -cls(-arg)
2103 
2104         if arg.is_number:
2105             cst_table = {
2106                 sqrt(3)/3: 6,
2107                 -sqrt(3)/3: -6,
2108                 1/sqrt(3): 6,
2109                 -1/sqrt(3): -6,
2110                 sqrt(3): 3,
2111                 -sqrt(3): -3,
2112                 (1 + sqrt(2)): S(8)/3,
2113                 -(1 + sqrt(2)): S(8)/3,
2114                 (sqrt(2) - 1): 8,
2115                 (1 - sqrt(2)): -8,
2116                 sqrt((5 + 2*sqrt(5))): S(5)/2,
2117                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,
2118                 (2 - sqrt(3)): 12,
2119                 -(2 - sqrt(3)): -12
2120             }
2121 
2122             if arg in cst_table:
2123                 return S.Pi / cst_table[arg]
2124 
2125         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2126         if i_coeff is not None:
2127             return S.ImaginaryUnit * atanh(i_coeff)
2128 
2129     @staticmethod
2130     @cacheit
2131     def taylor_term(n, x, *previous_terms):
2132         if n < 0 or n % 2 == 0:
2133             return S.Zero
2134         else:
2135             x = sympify(x)
2136             return (-1)**((n - 1)//2) * x**n / n
2137 
2138     def _eval_as_leading_term(self, x):
2139         from sympy import Order
2140         arg = self.args[0].as_leading_term(x)
2141 
2142         if x in arg.free_symbols and Order(1, x).contains(arg):
2143             return arg
2144         else:
2145             return self.func(arg)
2146 
2147     def _eval_is_real(self):
2148         return self.args[0].is_real
2149 
2150     def _eval_rewrite_as_log(self, x):
2151         return S.ImaginaryUnit/2 * (log(
2152             (S(1) - S.ImaginaryUnit * x)/(S(1) + S.ImaginaryUnit * x)))
2153 
2154     def _eval_aseries(self, n, args0, x, logx):
2155         if args0[0] == S.Infinity:
2156             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2157         elif args0[0] == S.NegativeInfinity:
2158             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2159         else:
2160             return super(atan, self)._eval_aseries(n, args0, x, logx)
2161 
2162     def inverse(self, argindex=1):
2163         """
2164         Returns the inverse of this function.
2165         """
2166         return tan
2167 
2168     def _eval_rewrite_as_asin(self, arg):
2169         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))
2170 
2171     def _eval_rewrite_as_acos(self, arg):
2172         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))
2173 
2174     def _eval_rewrite_as_acot(self, arg):
2175         return acot(1/arg)
2176 
2177     def _eval_rewrite_as_asec(self, arg):
2178         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))
2179 
2180     def _eval_rewrite_as_acsc(self, arg):
2181         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))
2182 
2183 
2184 class acot(InverseTrigonometricFunction):
2185     """
2186     The inverse cotangent function.
2187 
2188     Returns the arc cotangent of x (measured in radians).
2189 
2190     See Also
2191     ========
2192 
2193     sin, csc, cos, sec, tan, cot
2194     asin, acsc, acos, asec, atan, atan2
2195 
2196     References
2197     ==========
2198 
2199     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2200     .. [2] http://dlmf.nist.gov/4.23
2201     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot
2202     """
2203 
2204     def fdiff(self, argindex=1):
2205         if argindex == 1:
2206             return -1 / (1 + self.args[0]**2)
2207         else:
2208             raise ArgumentIndexError(self, argindex)
2209 
2210     def _eval_is_rational(self):
2211         s = self.func(*self.args)
2212         if s.func == self.func:
2213             if s.args[0].is_rational:
2214                 return False
2215         else:
2216             return s.is_rational
2217 
2218     def _eval_is_positive(self):
2219         return self.args[0].is_real
2220 
2221     @classmethod
2222     def eval(cls, arg):
2223         if arg.is_Number:
2224             if arg is S.NaN:
2225                 return S.NaN
2226             elif arg is S.Infinity:
2227                 return S.Zero
2228             elif arg is S.NegativeInfinity:
2229                 return S.Zero
2230             elif arg is S.Zero:
2231                 return S.Pi/ 2
2232             elif arg is S.One:
2233                 return S.Pi / 4
2234             elif arg is S.NegativeOne:
2235                 return -S.Pi / 4
2236 
2237         if arg.could_extract_minus_sign():
2238             return -cls(-arg)
2239 
2240         if arg.is_number:
2241             cst_table = {
2242                 sqrt(3)/3: 3,
2243                 -sqrt(3)/3: -3,
2244                 1/sqrt(3): 3,
2245                 -1/sqrt(3): -3,
2246                 sqrt(3): 6,
2247                 -sqrt(3): -6,
2248                 (1 + sqrt(2)): 8,
2249                 -(1 + sqrt(2)): -8,
2250                 (1 - sqrt(2)): -S(8)/3,
2251                 (sqrt(2) - 1): S(8)/3,
2252                 sqrt(5 + 2*sqrt(5)): 10,
2253                 -sqrt(5 + 2*sqrt(5)): -10,
2254                 (2 + sqrt(3)): 12,
2255                 -(2 + sqrt(3)): -12,
2256                 (2 - sqrt(3)): S(12)/5,
2257                 -(2 - sqrt(3)): -S(12)/5,
2258             }
2259 
2260             if arg in cst_table:
2261                 return S.Pi / cst_table[arg]
2262 
2263         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2264         if i_coeff is not None:
2265             return -S.ImaginaryUnit * acoth(i_coeff)
2266 
2267     @staticmethod
2268     @cacheit
2269     def taylor_term(n, x, *previous_terms):
2270         if n == 0:
2271             return S.Pi / 2  # FIX THIS
2272         elif n < 0 or n % 2 == 0:
2273             return S.Zero
2274         else:
2275             x = sympify(x)
2276             return (-1)**((n + 1)//2) * x**n / n
2277 
2278     def _eval_as_leading_term(self, x):
2279         from sympy import Order
2280         arg = self.args[0].as_leading_term(x)
2281 
2282         if x in arg.free_symbols and Order(1, x).contains(arg):
2283             return arg
2284         else:
2285             return self.func(arg)
2286 
2287     def _eval_is_real(self):
2288         return self.args[0].is_real
2289 
2290     def _eval_aseries(self, n, args0, x, logx):
2291         if args0[0] == S.Infinity:
2292             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2293         elif args0[0] == S.NegativeInfinity:
2294             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2295         else:
2296             return super(atan, self)._eval_aseries(n, args0, x, logx)
2297 
2298     def _eval_rewrite_as_log(self, x):
2299         return S.ImaginaryUnit/2 * \
2300             (log((x - S.ImaginaryUnit)/(x + S.ImaginaryUnit)))
2301 
2302     def inverse(self, argindex=1):
2303         """
2304         Returns the inverse of this function.
2305         """
2306         return cot
2307 
2308     def _eval_rewrite_as_asin(self, arg):
2309         return (arg*sqrt(1/arg**2)*
2310                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))
2311 
2312     def _eval_rewrite_as_acos(self, arg):
2313         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))
2314 
2315     def _eval_rewrite_as_atan(self, arg):
2316         return atan(1/arg)
2317 
2318     def _eval_rewrite_as_asec(self, arg):
2319         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))
2320 
2321     def _eval_rewrite_as_acsc(self, arg):
2322         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))
2323 
2324 
2325 class asec(InverseTrigonometricFunction):
2326     """
2327     The inverse secant function.
2328 
2329     Returns the arc secant of x (measured in radians).
2330 
2331     Notes
2332     =====
2333 
2334     ``asec(x)`` will evaluate automatically in the cases
2335     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2336 
2337     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,
2338     it can be defined [4]_ as
2339 
2340     .. math::
2341         sec^{-1}(z) = -i*(log(\sqrt{1 - z^2} + 1) / z)
2342 
2343     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For
2344     negative branch cut, the limit
2345 
2346     .. math::
2347         \lim_{z \to 0}-i*(log(-\sqrt{1 - z^2} + 1) / z)
2348 
2349     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to
2350     ``zoo``.
2351 
2352     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for
2353     ``acos(x)``.
2354 
2355     Examples
2356     ========
2357 
2358     >>> from sympy import asec, oo, pi
2359     >>> asec(1)
2360     0
2361     >>> asec(-1)
2362     pi
2363 
2364     See Also
2365     ========
2366 
2367     sin, csc, cos, sec, tan, cot
2368     asin, acsc, acos, atan, acot, atan2
2369 
2370     References
2371     ==========
2372 
2373     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2374     .. [2] http://dlmf.nist.gov/4.23
2375     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec
2376     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html
2377     """
2378 
2379     @classmethod
2380     def eval(cls, arg):
2381         if arg.is_zero:
2382             return S.ComplexInfinity
2383         if arg.is_Number:
2384             if arg is S.NaN:
2385                 return S.NaN
2386             elif arg is S.One:
2387                 return S.Zero
2388             elif arg is S.NegativeOne:
2389                 return S.Pi
2390         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2391             return S.Pi/2
2392 
2393     def fdiff(self, argindex=1):
2394         if argindex == 1:
2395             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2396         else:
2397             raise ArgumentIndexError(self, argindex)
2398 
2399     def inverse(self, argindex=1):
2400         """
2401         Returns the inverse of this function.
2402         """
2403         return sec
2404 
2405     def _eval_as_leading_term(self, x):
2406         from sympy import Order
2407         arg = self.args[0].as_leading_term(x)
2408         if Order(1,x).contains(arg):
2409             return log(arg)
2410         else:
2411             return self.func(arg)
2412 
2413     def _eval_is_real(self):
2414         x = self.args[0]
2415         if x.is_real is False:
2416             return False
2417         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative
2418 
2419     def _eval_rewrite_as_log(self, arg):
2420         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2421 
2422     def _eval_rewrite_as_asin(self, arg):
2423         return S.Pi/2 - asin(1/arg)
2424 
2425     def _eval_rewrite_as_acos(self, arg):
2426         return acos(1/arg)
2427 
2428     def _eval_rewrite_as_atan(self, arg):
2429         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))
2430 
2431     def _eval_rewrite_as_acot(self, arg):
2432         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))
2433 
2434     def _eval_rewrite_as_acsc(self, arg):
2435         return S.Pi/2 - acsc(arg)
2436 
2437 
2438 class acsc(InverseTrigonometricFunction):
2439     """
2440     The inverse cosecant function.
2441 
2442     Returns the arc cosecant of x (measured in radians).
2443 
2444     Notes
2445     =====
2446 
2447     acsc(x) will evaluate automatically in the cases
2448     oo, -oo, 0, 1, -1.
2449 
2450     Examples
2451     ========
2452 
2453     >>> from sympy import acsc, oo, pi
2454     >>> acsc(1)
2455     pi/2
2456     >>> acsc(-1)
2457     -pi/2
2458 
2459     See Also
2460     ========
2461 
2462     sin, csc, cos, sec, tan, cot
2463     asin, acos, asec, atan, acot, atan2
2464 
2465     References
2466     ==========
2467 
2468     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2469     .. [2] http://dlmf.nist.gov/4.23
2470     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc
2471     """
2472 
2473     @classmethod
2474     def eval(cls, arg):
2475         if arg.is_Number:
2476             if arg is S.NaN:
2477                 return S.NaN
2478             elif arg is S.One:
2479                 return S.Pi/2
2480             elif arg is S.NegativeOne:
2481                 return -S.Pi/2
2482         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2483             return S.Zero
2484 
2485     def fdiff(self, argindex=1):
2486         if argindex == 1:
2487             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2488         else:
2489             raise ArgumentIndexError(self, argindex)
2490 
2491     def inverse(self, argindex=1):
2492         """
2493         Returns the inverse of this function.
2494         """
2495         return csc
2496 
2497     def _eval_as_leading_term(self, x):
2498         from sympy import Order
2499         arg = self.args[0].as_leading_term(x)
2500         if Order(1,x).contains(arg):
2501             return log(arg)
2502         else:
2503             return self.func(arg)
2504 
2505     def _eval_rewrite_as_log(self, arg):
2506         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2507 
2508     def _eval_rewrite_as_asin(self, arg):
2509         return asin(1/arg)
2510 
2511     def _eval_rewrite_as_acos(self, arg):
2512         return S.Pi/2 - acos(1/arg)
2513 
2514     def _eval_rewrite_as_atan(self, arg):
2515         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))
2516 
2517     def _eval_rewrite_as_acot(self, arg):
2518         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))
2519 
2520     def _eval_rewrite_as_asec(self, arg):
2521         return S.Pi/2 - asec(arg)
2522 
2523 
2524 class atan2(InverseTrigonometricFunction):
2525     r"""
2526     The function ``atan2(y, x)`` computes `\operatorname{atan}(y/x)` taking
2527     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to
2528     determine the appropriate quadrant of `\operatorname{atan}(y/x)`.
2529     The range is `(-\pi, \pi]`. The complete definition reads as follows:
2530 
2531     .. math::
2532 
2533         \operatorname{atan2}(y, x) =
2534         \begin{cases}
2535           \arctan\left(\frac y x\right) & \qquad x > 0 \\
2536           \arctan\left(\frac y x\right) + \pi& \qquad y \ge 0 , x < 0 \\
2537           \arctan\left(\frac y x\right) - \pi& \qquad y < 0 , x < 0 \\
2538           +\frac{\pi}{2} & \qquad y > 0 , x = 0 \\
2539           -\frac{\pi}{2} & \qquad y < 0 , x = 0 \\
2540           \text{undefined} & \qquad y = 0, x = 0
2541         \end{cases}
2542 
2543     Attention: Note the role reversal of both arguments. The `y`-coordinate
2544     is the first argument and the `x`-coordinate the second.
2545 
2546     Examples
2547     ========
2548 
2549     Going counter-clock wise around the origin we find the
2550     following angles:
2551 
2552     >>> from sympy import atan2
2553     >>> atan2(0, 1)
2554     0
2555     >>> atan2(1, 1)
2556     pi/4
2557     >>> atan2(1, 0)
2558     pi/2
2559     >>> atan2(1, -1)
2560     3*pi/4
2561     >>> atan2(0, -1)
2562     pi
2563     >>> atan2(-1, -1)
2564     -3*pi/4
2565     >>> atan2(-1, 0)
2566     -pi/2
2567     >>> atan2(-1, 1)
2568     -pi/4
2569 
2570     which are all correct. Compare this to the results of the ordinary
2571     `\operatorname{atan}` function for the point `(x, y) = (-1, 1)`
2572 
2573     >>> from sympy import atan, S
2574     >>> atan(S(1) / -1)
2575     -pi/4
2576     >>> atan2(1, -1)
2577     3*pi/4
2578 
2579     where only the `\operatorname{atan2}` function reurns what we expect.
2580     We can differentiate the function with respect to both arguments:
2581 
2582     >>> from sympy import diff
2583     >>> from sympy.abc import x, y
2584     >>> diff(atan2(y, x), x)
2585     -y/(x**2 + y**2)
2586 
2587     >>> diff(atan2(y, x), y)
2588     x/(x**2 + y**2)
2589 
2590     We can express the `\operatorname{atan2}` function in terms of
2591     complex logarithms:
2592 
2593     >>> from sympy import log
2594     >>> atan2(y, x).rewrite(log)
2595     -I*log((x + I*y)/sqrt(x**2 + y**2))
2596 
2597     and in terms of `\operatorname(atan)`:
2598 
2599     >>> from sympy import atan
2600     >>> atan2(y, x).rewrite(atan)
2601     2*atan(y/(x + sqrt(x**2 + y**2)))
2602 
2603     but note that this form is undefined on the negative real axis.
2604 
2605     See Also
2606     ========
2607 
2608     sin, csc, cos, sec, tan, cot
2609     asin, acsc, acos, asec, atan, acot
2610 
2611     References
2612     ==========
2613 
2614     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2615     .. [2] http://en.wikipedia.org/wiki/Atan2
2616     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2
2617     """
2618 
2619     @classmethod
2620     def eval(cls, y, x):
2621         from sympy import Heaviside, im, re
2622         if x is S.NegativeInfinity:
2623             if y.is_zero:
2624                 # Special case y = 0 because we define Heaviside(0) = 1/2
2625                 return S.Pi
2626             return 2*S.Pi*(Heaviside(re(y))) - S.Pi
2627         elif x is S.Infinity:
2628             return S.Zero
2629         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:
2630             x = im(x)
2631             y = im(y)
2632 
2633         if x.is_real and y.is_real:
2634             if x.is_positive:
2635                 return atan(y / x)
2636             elif x.is_negative:
2637                 if y.is_negative:
2638                     return atan(y / x) - S.Pi
2639                 elif y.is_nonnegative:
2640                     return atan(y / x) + S.Pi
2641             elif x.is_zero:
2642                 if y.is_positive:
2643                     return S.Pi/2
2644                 elif y.is_negative:
2645                     return -S.Pi/2
2646                 elif y.is_zero:
2647                     return S.NaN
2648         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):
2649             return S.Pi * (S.One - Heaviside(x))
2650         if x.is_number and y.is_number:
2651             return -S.ImaginaryUnit*log(
2652                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))
2653 
2654     def _eval_rewrite_as_log(self, y, x):
2655         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))
2656 
2657     def _eval_rewrite_as_atan(self, y, x):
2658         return 2*atan(y / (sqrt(x**2 + y**2) + x))
2659 
2660     def _eval_rewrite_as_arg(self, y, x):
2661         from sympy import arg
2662         if x.is_real and y.is_real:
2663             return arg(x + y*S.ImaginaryUnit)
2664         I = S.ImaginaryUnit
2665         n = x + I*y
2666         d = x**2 + y**2
2667         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))
2668 
2669     def _eval_is_real(self):
2670         return self.args[0].is_real and self.args[1].is_real
2671 
2672     def _eval_conjugate(self):
2673         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
2674 
2675     def fdiff(self, argindex):
2676         y, x = self.args
2677         if argindex == 1:
2678             # Diff wrt y
2679             return x/(x**2 + y**2)
2680         elif argindex == 2:
2681             # Diff wrt x
2682             return -y/(x**2 + y**2)
2683         else:
2684             raise ArgumentIndexError(self, argindex)
2685 
2686     def _eval_evalf(self, prec):
2687         y, x = self.args
2688         if x.is_real and y.is_real:
2689             super(atan2, self)._eval_evalf(prec)

</code><intended_behavior>Although not directly buggy, this file might need a review or update to ensure that the definition and handling of `sinc(x)` within SymPy are conducive to conversion to C code via `ccode`. Specifically, the documentation or meta-information of `sinc(x)` could include hints or properties that `ccode` can utilize to recognize and convert `sinc(x)` expressions more effectively. Enhancing how `sinc(x)` is represented in the context of SymPy's elementary trigonometric functions could aid in its conversion to C code, ensuring a seamless process when such expressions are encountered by `ccode`. If `sinc(x)` is treated specially in terms of symbolic manipulation or simplification, such properties should be documented or coded in a way that `ccode` (or any code-printing routine) can easily translate it into the target language's idioms or library function calls, if available, or into a manually specified piecewise expression otherwise. This may imply refining the symbolic properties of `sinc(x)` to ensure they align with the expectations and capabilities of the code conversion routines.</intended_behavior>]
2025-10-15 12:51:30.184 | INFO     | Search completed. Bug locations: [<file>sympy/printing/ccode.py</file>
<class>None</class>
<method>ccode</method>
<code>
283 def ccode(expr, assign_to=None, **settings):
284     """Converts an expr to a string of c code
285 
286     Parameters
287     ==========
288 
289     expr : Expr
290         A sympy expression to be converted.
291     assign_to : optional
292         When given, the argument is used as the name of the variable to which
293         the expression is assigned. Can be a string, ``Symbol``,
294         ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of
295         line-wrapping, or for expressions that generate multi-line statements.
296     precision : integer, optional
297         The precision for numbers such as pi [default=15].
298     user_functions : dict, optional
299         A dictionary where the keys are string representations of either
300         ``FunctionClass`` or ``UndefinedFunction`` instances and the values
301         are their desired C string representations. Alternatively, the
302         dictionary value can be a list of tuples i.e. [(argument_test,
303         cfunction_string)].  See below for examples.
304     dereference : iterable, optional
305         An iterable of symbols that should be dereferenced in the printed code
306         expression. These would be values passed by address to the function.
307         For example, if ``dereference=[a]``, the resulting code would print
308         ``(*a)`` instead of ``a``.
309     human : bool, optional
310         If True, the result is a single string that may contain some constant
311         declarations for the number symbols. If False, the same information is
312         returned in a tuple of (symbols_to_declare, not_supported_functions,
313         code_text). [default=True].
314     contract: bool, optional
315         If True, ``Indexed`` instances are assumed to obey tensor contraction
316         rules and the corresponding nested loops over indices are generated.
317         Setting contract=False will not generate loops, instead the user is
318         responsible to provide values for the indices in the code.
319         [default=True].
320 
321     Examples
322     ========
323 
324     >>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function
325     >>> x, tau = symbols("x, tau")
326     >>> ccode((2*tau)**Rational(7, 2))
327     '8*sqrt(2)*pow(tau, 7.0L/2.0L)'
328     >>> ccode(sin(x), assign_to="s")
329     's = sin(x);'
330 
331     Simple custom printing can be defined for certain types by passing a
332     dictionary of {"type" : "function"} to the ``user_functions`` kwarg.
333     Alternatively, the dictionary value can be a list of tuples i.e.
334     [(argument_test, cfunction_string)].
335 
336     >>> custom_functions = {
337     ...   "ceiling": "CEIL",
338     ...   "Abs": [(lambda x: not x.is_integer, "fabs"),
339     ...           (lambda x: x.is_integer, "ABS")],
340     ...   "func": "f"
341     ... }
342     >>> func = Function('func')
343     >>> ccode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)
344     'f(fabs(x) + CEIL(x))'
345 
346     ``Piecewise`` expressions are converted into conditionals. If an
347     ``assign_to`` variable is provided an if statement is created, otherwise
348     the ternary operator is used. Note that if the ``Piecewise`` lacks a
349     default term, represented by ``(expr, True)`` then an error will be thrown.
350     This is to prevent generating an expression that may not evaluate to
351     anything.
352 
353     >>> from sympy import Piecewise
354     >>> expr = Piecewise((x + 1, x > 0), (x, True))
355     >>> print(ccode(expr, tau))
356     if (x > 0) {
357     tau = x + 1;
358     }
359     else {
360     tau = x;
361     }
362 
363     Support for loops is provided through ``Indexed`` types. With
364     ``contract=True`` these expressions will be turned into loops, whereas
365     ``contract=False`` will just print the assignment expression that should be
366     looped over:
367 
368     >>> from sympy import Eq, IndexedBase, Idx
369     >>> len_y = 5
370     >>> y = IndexedBase('y', shape=(len_y,))
371     >>> t = IndexedBase('t', shape=(len_y,))
372     >>> Dy = IndexedBase('Dy', shape=(len_y-1,))
373     >>> i = Idx('i', len_y-1)
374     >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))
375     >>> ccode(e.rhs, assign_to=e.lhs, contract=False)
376     'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'
377 
378     Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions
379     must be provided to ``assign_to``. Note that any expression that can be
380     generated normally can also exist inside a Matrix:
381 
382     >>> from sympy import Matrix, MatrixSymbol
383     >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])
384     >>> A = MatrixSymbol('A', 3, 1)
385     >>> print(ccode(mat, A))
386     A[0] = pow(x, 2);
387     if (x > 0) {
388        A[1] = x + 1;
389     }
390     else {
391        A[1] = x;
392     }
393     A[2] = sin(x);
394     """
395 
396     return CCodePrinter(settings).doprint(expr, assign_to)

</code><intended_behavior>The `ccode` method should be enhanced to include support for converting `sinc(x)` expressions into an equivalent C code representation. Given that `sinc(x)` can be expressed as `sin(x)/x` for `x != 0`, and `1` for `x = 0`, the method should incorporate logic similar to handling `Piecewise` expressions, as evidenced in the current implementation for other mathematical expressions. The addition should preserve all existing functionalities of the `ccode` method, only extending it to recognize and properly convert `sinc(x)` expressions. Potential approaches include either directly implementing the conversion within the method based on detected `sinc(x)` patterns or leveraging the `user_functions` argument more effectively to allow users to specify custom conversions for unsupported functions like `sinc(x)`.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core.add import Add
4 from sympy.core.basic import sympify, cacheit
5 from sympy.core.function import Function, ArgumentIndexError
6 from sympy.core.numbers import igcdex, Rational
7 from sympy.core.singleton import S
8 from sympy.core.symbol import Symbol
9 from sympy.core.logic import fuzzy_not
10 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
11 from sympy.functions.elementary.miscellaneous import sqrt, Min, Max
12 from sympy.functions.elementary.exponential import log, exp
13 from sympy.functions.elementary.integers import floor
14 from sympy.functions.elementary.hyperbolic import (acoth, asinh, atanh, cosh,
15     coth, HyperbolicFunction, sinh, tanh)
16 from sympy.sets.sets import FiniteSet
17 from sympy.utilities.iterables import numbered_symbols
18 from sympy.core.compatibility import range
19 
20 ###############################################################################
21 ########################## TRIGONOMETRIC FUNCTIONS ############################
22 ###############################################################################
23 
24 
25 class TrigonometricFunction(Function):
26     """Base class for trigonometric functions. """
27 
28     unbranched = True
29 
30     def _eval_is_rational(self):
31         s = self.func(*self.args)
32         if s.func == self.func:
33             if s.args[0].is_rational and fuzzy_not(s.args[0].is_zero):
34                 return False
35         else:
36             return s.is_rational
37 
38     def _eval_is_algebraic(self):
39         s = self.func(*self.args)
40         if s.func == self.func:
41             if fuzzy_not(self.args[0].is_zero) and self.args[0].is_algebraic:
42                 return False
43             pi_coeff = _pi_coeff(self.args[0])
44             if pi_coeff is not None and pi_coeff.is_rational:
45                 return True
46         else:
47             return s.is_algebraic
48 
49     def _eval_expand_complex(self, deep=True, **hints):
50         re_part, im_part = self.as_real_imag(deep=deep, **hints)
51         return re_part + im_part*S.ImaginaryUnit
52 
53     def _as_real_imag(self, deep=True, **hints):
54         if self.args[0].is_real:
55             if deep:
56                 hints['complex'] = False
57                 return (self.args[0].expand(deep, **hints), S.Zero)
58             else:
59                 return (self.args[0], S.Zero)
60         if deep:
61             re, im = self.args[0].expand(deep, **hints).as_real_imag()
62         else:
63             re, im = self.args[0].as_real_imag()
64         return (re, im)
65 
66 
67 def _peeloff_pi(arg):
68     """
69     Split ARG into two parts, a "rest" and a multiple of pi/2.
70     This assumes ARG to be an Add.
71     The multiple of pi returned in the second position is always a Rational.
72 
73     Examples
74     ========
75 
76     >>> from sympy.functions.elementary.trigonometric import _peeloff_pi as peel
77     >>> from sympy import pi
78     >>> from sympy.abc import x, y
79     >>> peel(x + pi/2)
80     (x, pi/2)
81     >>> peel(x + 2*pi/3 + pi*y)
82     (x + pi*y + pi/6, pi/2)
83     """
84     for a in Add.make_args(arg):
85         if a is S.Pi:
86             K = S.One
87             break
88         elif a.is_Mul:
89             K, p = a.as_two_terms()
90             if p is S.Pi and K.is_Rational:
91                 break
92     else:
93         return arg, S.Zero
94 
95     m1 = (K % S.Half) * S.Pi
96     m2 = K*S.Pi - m1
97     return arg - m2, m2
98 
99 
100 def _pi_coeff(arg, cycles=1):
101     """
102     When arg is a Number times pi (e.g. 3*pi/2) then return the Number
103     normalized to be in the range [0, 2], else None.
104 
105     When an even multiple of pi is encountered, if it is multiplying
106     something with known parity then the multiple is returned as 0 otherwise
107     as 2.
108 
109     Examples
110     ========
111 
112     >>> from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
113     >>> from sympy import pi, Dummy
114     >>> from sympy.abc import x, y
115     >>> coeff(3*x*pi)
116     3*x
117     >>> coeff(11*pi/7)
118     11/7
119     >>> coeff(-11*pi/7)
120     3/7
121     >>> coeff(4*pi)
122     0
123     >>> coeff(5*pi)
124     1
125     >>> coeff(5.0*pi)
126     1
127     >>> coeff(5.5*pi)
128     3/2
129     >>> coeff(2 + pi)
130 
131     >>> coeff(2*Dummy(integer=True)*pi)
132     2
133     >>> coeff(2*Dummy(even=True)*pi)
134     0
135     """
136     arg = sympify(arg)
137     if arg is S.Pi:
138         return S.One
139     elif not arg:
140         return S.Zero
141     elif arg.is_Mul:
142         cx = arg.coeff(S.Pi)
143         if cx:
144             c, x = cx.as_coeff_Mul()  # pi is not included as coeff
145             if c.is_Float:
146                 # recast exact binary fractions to Rationals
147                 f = abs(c) % 1
148                 if f != 0:
149                     p = -int(round(log(f, 2).evalf()))
150                     m = 2**p
151                     cm = c*m
152                     i = int(cm)
153                     if i == cm:
154                         c = Rational(i, m)
155                         cx = c*x
156                 else:
157                     c = Rational(int(c))
158                     cx = c*x
159             if x.is_integer:
160                 c2 = c % 2
161                 if c2 == 1:
162                     return x
163                 elif not c2:
164                     if x.is_even is not None:  # known parity
165                         return S.Zero
166                     return S(2)
167                 else:
168                     return c2*x
169             return cx
170 
171 
172 class sin(TrigonometricFunction):
173     """
174     The sine function.
175 
176     Returns the sine of x (measured in radians).
177 
178     Notes
179     =====
180 
181     This function will evaluate automatically in the
182     case x/pi is some rational number [4]_.  For example,
183     if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.
184 
185     Examples
186     ========
187 
188     >>> from sympy import sin, pi
189     >>> from sympy.abc import x
190     >>> sin(x**2).diff(x)
191     2*x*cos(x**2)
192     >>> sin(1).diff(x)
193     0
194     >>> sin(pi)
195     0
196     >>> sin(pi/2)
197     1
198     >>> sin(pi/6)
199     1/2
200     >>> sin(pi/12)
201     -sqrt(2)/4 + sqrt(6)/4
202 
203 
204     See Also
205     ========
206 
207     csc, cos, sec, tan, cot
208     asin, acsc, acos, asec, atan, acot, atan2
209 
210     References
211     ==========
212 
213     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
214     .. [2] http://dlmf.nist.gov/4.14
215     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin
216     .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html
217     """
218 
219     def fdiff(self, argindex=1):
220         if argindex == 1:
221             return cos(self.args[0])
222         else:
223             raise ArgumentIndexError(self, argindex)
224 
225     @classmethod
226     def eval(cls, arg):
227         from sympy.calculus import AccumBounds
228         if arg.is_Number:
229             if arg is S.NaN:
230                 return S.NaN
231             elif arg is S.Zero:
232                 return S.Zero
233             elif arg is S.Infinity or arg is S.NegativeInfinity:
234                 return AccumBounds(-1, 1)
235 
236         if isinstance(arg, AccumBounds):
237             min, max = arg.min, arg.max
238             d = floor(min/(2*S.Pi))
239             if min is not S.NegativeInfinity:
240                 min = min - d*2*S.Pi
241             if max is not S.Infinity:
242                 max = max - d*2*S.Pi
243             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
244                     is not S.EmptySet and \
245                     AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,
246                         7*S.Pi/2)) is not S.EmptySet:
247                 return AccumBounds(-1, 1)
248             elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \
249                     is not S.EmptySet:
250                 return AccumBounds(Min(sin(min), sin(max)), 1)
251             elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \
252                         is not S.EmptySet:
253                 return AccumBounds(-1, Max(sin(min), sin(max)))
254             else:
255                 return AccumBounds(Min(sin(min), sin(max)),
256                                 Max(sin(min), sin(max)))
257 
258         if arg.could_extract_minus_sign():
259             return -cls(-arg)
260 
261         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
262         if i_coeff is not None:
263             return S.ImaginaryUnit * sinh(i_coeff)
264 
265         pi_coeff = _pi_coeff(arg)
266         if pi_coeff is not None:
267             if pi_coeff.is_integer:
268                 return S.Zero
269 
270             if (2*pi_coeff).is_integer:
271                 if pi_coeff.is_even:
272                     return S.Zero
273                 elif pi_coeff.is_even is False:
274                     return S.NegativeOne**(pi_coeff - S.Half)
275 
276             if not pi_coeff.is_Rational:
277                 narg = pi_coeff*S.Pi
278                 if narg != arg:
279                     return cls(narg)
280                 return None
281 
282             # https://github.com/sympy/sympy/issues/6048
283             # transform a sine to a cosine, to avoid redundant code
284             if pi_coeff.is_Rational:
285                 x = pi_coeff % 2
286                 if x > 1:
287                     return -cls((x % 1)*S.Pi)
288                 if 2*x > 1:
289                     return cls((1 - x)*S.Pi)
290                 narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi
291                 result = cos(narg)
292                 if not isinstance(result, cos):
293                     return result
294                 if pi_coeff*S.Pi != arg:
295                     return cls(pi_coeff*S.Pi)
296                 return None
297 
298         if arg.is_Add:
299             x, m = _peeloff_pi(arg)
300             if m:
301                 return sin(m)*cos(x) + cos(m)*sin(x)
302 
303         if arg.func is asin:
304             return arg.args[0]
305 
306         if arg.func is atan:
307             x = arg.args[0]
308             return x / sqrt(1 + x**2)
309 
310         if arg.func is atan2:
311             y, x = arg.args
312             return y / sqrt(x**2 + y**2)
313 
314         if arg.func is acos:
315             x = arg.args[0]
316             return sqrt(1 - x**2)
317 
318         if arg.func is acot:
319             x = arg.args[0]
320             return 1 / (sqrt(1 + 1 / x**2) * x)
321 
322     @staticmethod
323     @cacheit
324     def taylor_term(n, x, *previous_terms):
325         if n < 0 or n % 2 == 0:
326             return S.Zero
327         else:
328             x = sympify(x)
329 
330             if len(previous_terms) > 2:
331                 p = previous_terms[-2]
332                 return -p * x**2 / (n*(n - 1))
333             else:
334                 return (-1)**(n//2) * x**(n)/factorial(n)
335 
336     def _eval_rewrite_as_exp(self, arg):
337         I = S.ImaginaryUnit
338         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
339             arg = arg.func(arg.args[0]).rewrite(exp)
340         return (exp(arg*I) - exp(-arg*I)) / (2*I)
341 
342     def _eval_rewrite_as_Pow(self, arg):
343         if arg.func is log:
344             I = S.ImaginaryUnit
345             x = arg.args[0]
346             return I*x**-I / 2 - I*x**I /2
347 
348     def _eval_rewrite_as_cos(self, arg):
349         return -cos(arg + S.Pi/2)
350 
351     def _eval_rewrite_as_tan(self, arg):
352         tan_half = tan(S.Half*arg)
353         return 2*tan_half/(1 + tan_half**2)
354 
355     def _eval_rewrite_as_sincos(self, arg):
356         return sin(arg)*cos(arg)/cos(arg)
357 
358     def _eval_rewrite_as_cot(self, arg):
359         cot_half = cot(S.Half*arg)
360         return 2*cot_half/(1 + cot_half**2)
361 
362     def _eval_rewrite_as_pow(self, arg):
363         return self.rewrite(cos).rewrite(pow)
364 
365     def _eval_rewrite_as_sqrt(self, arg):
366         return self.rewrite(cos).rewrite(sqrt)
367 
368     def _eval_rewrite_as_csc(self, arg):
369         return 1/csc(arg)
370 
371     def _eval_conjugate(self):
372         return self.func(self.args[0].conjugate())
373 
374     def as_real_imag(self, deep=True, **hints):
375         re, im = self._as_real_imag(deep=deep, **hints)
376         return (sin(re)*cosh(im), cos(re)*sinh(im))
377 
378     def _eval_expand_trig(self, **hints):
379         from sympy import expand_mul
380         from sympy.functions.special.polynomials import chebyshevt, chebyshevu
381         arg = self.args[0]
382         x = None
383         if arg.is_Add:  # TODO, implement more if deep stuff here
384             # TODO: Do this more efficiently for more than two terms
385             x, y = arg.as_two_terms()
386             sx = sin(x, evaluate=False)._eval_expand_trig()
387             sy = sin(y, evaluate=False)._eval_expand_trig()
388             cx = cos(x, evaluate=False)._eval_expand_trig()
389             cy = cos(y, evaluate=False)._eval_expand_trig()
390             return sx*cy + sy*cx
391         else:
392             n, x = arg.as_coeff_Mul(rational=True)
393             if n.is_Integer:  # n will be positive because of .eval
394                 # canonicalization
395 
396                 # See http://mathworld.wolfram.com/Multiple-AngleFormulas.html
397                 if n.is_odd:
398                     return (-1)**((n - 1)/2)*chebyshevt(n, sin(x))
399                 else:
400                     return expand_mul((-1)**(n/2 - 1)*cos(x)*chebyshevu(n -
401                         1, sin(x)), deep=False)
402             pi_coeff = _pi_coeff(arg)
403             if pi_coeff is not None:
404                 if pi_coeff.is_Rational:
405                     return self.rewrite(sqrt)
406         return sin(arg)
407 
408     def _eval_as_leading_term(self, x):
409         from sympy import Order
410         arg = self.args[0].as_leading_term(x)
411 
412         if x in arg.free_symbols and Order(1, x).contains(arg):
413             return arg
414         else:
415             return self.func(arg)
416 
417     def _eval_is_real(self):
418         return self.args[0].is_real
419 
420     def _eval_is_finite(self):
421         arg = self.args[0]
422         if arg.is_real:
423             return True
424 
425 
426 class cos(TrigonometricFunction):
427     """
428     The cosine function.
429 
430     Returns the cosine of x (measured in radians).
431 
432     Notes
433     =====
434 
435     See :func:`sin` for notes about automatic evaluation.
436 
437     Examples
438     ========
439 
440     >>> from sympy import cos, pi
441     >>> from sympy.abc import x
442     >>> cos(x**2).diff(x)
443     -2*x*sin(x**2)
444     >>> cos(1).diff(x)
445     0
446     >>> cos(pi)
447     -1
448     >>> cos(pi/2)
449     0
450     >>> cos(2*pi/3)
451     -1/2
452     >>> cos(pi/12)
453     sqrt(2)/4 + sqrt(6)/4
454 
455     See Also
456     ========
457 
458     sin, csc, sec, tan, cot
459     asin, acsc, acos, asec, atan, acot, atan2
460 
461     References
462     ==========
463 
464     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
465     .. [2] http://dlmf.nist.gov/4.14
466     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
467     """
468 
469     def fdiff(self, argindex=1):
470         if argindex == 1:
471             return -sin(self.args[0])
472         else:
473             raise ArgumentIndexError(self, argindex)
474 
475     @classmethod
476     def eval(cls, arg):
477         from sympy.functions.special.polynomials import chebyshevt
478         from sympy.calculus.util import AccumBounds
479         if arg.is_Number:
480             if arg is S.NaN:
481                 return S.NaN
482             elif arg is S.Zero:
483                 return S.One
484             elif arg is S.Infinity or arg is S.NegativeInfinity:
485                 # In this case it is better to return AccumBounds(-1, 1)
486                 # rather than returning S.NaN, since AccumBounds(-1, 1)
487                 # preserves the information that sin(oo) is between
488                 # -1 and 1, where S.NaN does not do that.
489                 return AccumBounds(-1, 1)
490 
491         if isinstance(arg, AccumBounds):
492             return sin(arg + S.Pi/2)
493 
494         if arg.could_extract_minus_sign():
495             return cls(-arg)
496 
497         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
498         if i_coeff is not None:
499             return cosh(i_coeff)
500 
501         pi_coeff = _pi_coeff(arg)
502         if pi_coeff is not None:
503             if pi_coeff.is_integer:
504                 return (S.NegativeOne)**pi_coeff
505 
506             if (2*pi_coeff).is_integer:
507                 if pi_coeff.is_even:
508                     return (S.NegativeOne)**(pi_coeff/2)
509                 elif pi_coeff.is_even is False:
510                     return S.Zero
511 
512             if not pi_coeff.is_Rational:
513                 narg = pi_coeff*S.Pi
514                 if narg != arg:
515                     return cls(narg)
516                 return None
517 
518             # cosine formula #####################
519             # https://github.com/sympy/sympy/issues/6048
520             # explicit calculations are preformed for
521             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
522             # Some other exact values like cos(k pi/240) can be
523             # calculated using a partial-fraction decomposition
524             # by calling cos( X ).rewrite(sqrt)
525             cst_table_some = {
526                 3: S.Half,
527                 5: (sqrt(5) + 1)/4,
528             }
529             if pi_coeff.is_Rational:
530                 q = pi_coeff.q
531                 p = pi_coeff.p % (2*q)
532                 if p > q:
533                     narg = (pi_coeff - 1)*S.Pi
534                     return -cls(narg)
535                 if 2*p > q:
536                     narg = (1 - pi_coeff)*S.Pi
537                     return -cls(narg)
538 
539                 # If nested sqrt's are worse than un-evaluation
540                 # you can require q to be in (1, 2, 3, 4, 6, 12)
541                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
542                 # expressions with 2 or fewer sqrt nestings.
543                 table2 = {
544                     12: (3, 4),
545                     20: (4, 5),
546                     30: (5, 6),
547                     15: (6, 10),
548                     24: (6, 8),
549                     40: (8, 10),
550                     60: (20, 30),
551                     120: (40, 60)
552                     }
553                 if q in table2:
554                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
555                     nvala, nvalb = cls(a), cls(b)
556                     if None == nvala or None == nvalb:
557                         return None
558                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
559 
560                 if q > 12:
561                     return None
562 
563                 if q in cst_table_some:
564                     cts = cst_table_some[pi_coeff.q]
565                     return chebyshevt(pi_coeff.p, cts).expand()
566 
567                 if 0 == q % 2:
568                     narg = (pi_coeff*2)*S.Pi
569                     nval = cls(narg)
570                     if None == nval:
571                         return None
572                     x = (2*pi_coeff + 1)/2
573                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
574                     return sign_cos*sqrt( (1 + nval)/2 )
575             return None
576 
577         if arg.is_Add:
578             x, m = _peeloff_pi(arg)
579             if m:
580                 return cos(m)*cos(x) - sin(m)*sin(x)
581 
582         if arg.func is acos:
583             return arg.args[0]
584 
585         if arg.func is atan:
586             x = arg.args[0]
587             return 1 / sqrt(1 + x**2)
588 
589         if arg.func is atan2:
590             y, x = arg.args
591             return x / sqrt(x**2 + y**2)
592 
593         if arg.func is asin:
594             x = arg.args[0]
595             return sqrt(1 - x ** 2)
596 
597         if arg.func is acot:
598             x = arg.args[0]
599             return 1 / sqrt(1 + 1 / x**2)
600 
601     @staticmethod
602     @cacheit
603     def taylor_term(n, x, *previous_terms):
604         if n < 0 or n % 2 == 1:
605             return S.Zero
606         else:
607             x = sympify(x)
608 
609             if len(previous_terms) > 2:
610                 p = previous_terms[-2]
611                 return -p * x**2 / (n*(n - 1))
612             else:
613                 return (-1)**(n//2)*x**(n)/factorial(n)
614 
615     def _eval_rewrite_as_exp(self, arg):
616         I = S.ImaginaryUnit
617         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
618             arg = arg.func(arg.args[0]).rewrite(exp)
619         return (exp(arg*I) + exp(-arg*I)) / 2
620 
621     def _eval_rewrite_as_Pow(self, arg):
622         if arg.func is log:
623             I = S.ImaginaryUnit
624             x = arg.args[0]
625             return x**I/2 + x**-I/2
626 
627     def _eval_rewrite_as_sin(self, arg):
628         return sin(arg + S.Pi/2)
629 
630     def _eval_rewrite_as_tan(self, arg):
631         tan_half = tan(S.Half*arg)**2
632         return (1 - tan_half)/(1 + tan_half)
633 
634     def _eval_rewrite_as_sincos(self, arg):
635         return sin(arg)*cos(arg)/sin(arg)
636 
637     def _eval_rewrite_as_cot(self, arg):
638         cot_half = cot(S.Half*arg)**2
639         return (cot_half - 1)/(cot_half + 1)
640 
641     def _eval_rewrite_as_pow(self, arg):
642         return self._eval_rewrite_as_sqrt(arg)
643 
644     def _eval_rewrite_as_sqrt(self, arg):
645         from sympy.functions.special.polynomials import chebyshevt
646 
647         def migcdex(x):
648             # recursive calcuation of gcd and linear combination
649             # for a sequence of integers.
650             # Given  (x1, x2, x3)
651             # Returns (y1, y1, y3, g)
652             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
653             # Note, that this is only one such linear combination.
654             if len(x) == 1:
655                 return (1, x[0])
656             if len(x) == 2:
657                 return igcdex(x[0], x[-1])
658             g = migcdex(x[1:])
659             u, v, h = igcdex(x[0], g[-1])
660             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
661 
662         def ipartfrac(r, factors=None):
663             from sympy.ntheory import factorint
664             if isinstance(r, int):
665                 return r
666             if not isinstance(r, Rational):
667                 raise TypeError("r is not rational")
668             n = r.q
669             if 2 > r.q*r.q:
670                 return r.q
671 
672             if None == factors:
673                 a = [n//x**y for x, y in factorint(r.q).items()]
674             else:
675                 a = [n//x for x in factors]
676             if len(a) == 1:
677                 return [ r ]
678             h = migcdex(a)
679             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
680             assert r == sum(ans)
681             return ans
682         pi_coeff = _pi_coeff(arg)
683         if pi_coeff is None:
684             return None
685 
686         if pi_coeff.is_integer:
687             # it was unevaluated
688             return self.func(pi_coeff*S.Pi)
689 
690         if not pi_coeff.is_Rational:
691             return None
692 
693         def _cospi257():
694             """ Express cos(pi/257) explicitly as a function of radicals
695                 Based upon the equations in
696                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
697                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
698             """
699             def f1(a, b):
700                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
701 
702             def f2(a, b):
703                 return (a - sqrt(a**2 + b))/2
704 
705             t1, t2 = f1(-1, 256)
706             z1, z3 = f1(t1, 64)
707             z2, z4 = f1(t2, 64)
708             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
709             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
710             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
711             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
712             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
713             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
714             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
715             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
716             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
717             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
718             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
719             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
720             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
721             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
722             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
723             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
724             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
725             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
726             u1 = -f2(-v1, -4*(v2 + v3))
727             u2 = -f2(-v4, -4*(v5 + v6))
728             w1 = -2*f2(-u1, -4*u2)
729             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
730 
731         cst_table_some = {
732             3: S.Half,
733             5: (sqrt(5) + 1)/4,
734             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
735                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
736                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
737             257: _cospi257()
738             # 65537 is the only other known Fermat prime and the very
739             # large expression is intentionally omitted from SymPy; see
740             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
741         }
742 
743         def _fermatCoords(n):
744             # if n can be factored in terms of Fermat primes with
745             # multiplicity of each being 1, return those primes, else
746             # False
747             from sympy import chebyshevt
748             primes = []
749             for p_i in cst_table_some:
750                 n, r = divmod(n, p_i)
751                 if not r:
752                     primes.append(p_i)
753                     if n == 1:
754                         return tuple(primes)
755             return False
756 
757         if pi_coeff.q in cst_table_some:
758             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
759             if pi_coeff.q < 257:
760                 rv = rv.expand()
761             return rv
762 
763         if not pi_coeff.q % 2:  # recursively remove factors of 2
764             pico2 = pi_coeff*2
765             nval = cos(pico2*S.Pi).rewrite(sqrt)
766             x = (pico2 + 1)/2
767             sign_cos = -1 if int(x) % 2 else 1
768             return sign_cos*sqrt( (1 + nval)/2 )
769 
770         FC = _fermatCoords(pi_coeff.q)
771         if FC:
772             decomp = ipartfrac(pi_coeff, FC)
773             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
774             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
775             return pcls.rewrite(sqrt)
776         else:
777             decomp = ipartfrac(pi_coeff)
778             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
779             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
780             return pcls
781 
782     def _eval_rewrite_as_sec(self, arg):
783         return 1/sec(arg)
784 
785     def _eval_conjugate(self):
786         return self.func(self.args[0].conjugate())
787 
788     def as_real_imag(self, deep=True, **hints):
789         re, im = self._as_real_imag(deep=deep, **hints)
790         return (cos(re)*cosh(im), -sin(re)*sinh(im))
791 
792     def _eval_expand_trig(self, **hints):
793         from sympy.functions.special.polynomials import chebyshevt
794         arg = self.args[0]
795         x = None
796         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
797             x, y = arg.as_two_terms()
798             sx = sin(x, evaluate=False)._eval_expand_trig()
799             sy = sin(y, evaluate=False)._eval_expand_trig()
800             cx = cos(x, evaluate=False)._eval_expand_trig()
801             cy = cos(y, evaluate=False)._eval_expand_trig()
802             return cx*cy - sx*sy
803         else:
804             coeff, terms = arg.as_coeff_Mul(rational=True)
805             if coeff.is_Integer:
806                 return chebyshevt(coeff, cos(terms))
807             pi_coeff = _pi_coeff(arg)
808             if pi_coeff is not None:
809                 if pi_coeff.is_Rational:
810                     return self.rewrite(sqrt)
811         return cos(arg)
812 
813     def _eval_as_leading_term(self, x):
814         from sympy import Order
815         arg = self.args[0].as_leading_term(x)
816 
817         if x in arg.free_symbols and Order(1, x).contains(arg):
818             return S.One
819         else:
820             return self.func(arg)
821 
822     def _eval_is_real(self):
823         return self.args[0].is_real
824 
825     def _eval_is_finite(self):
826         arg = self.args[0]
827 
828         if arg.is_real:
829             return True
830 
831 
832 class tan(TrigonometricFunction):
833     """
834     The tangent function.
835 
836     Returns the tangent of x (measured in radians).
837 
838     Notes
839     =====
840 
841     See :func:`sin` for notes about automatic evaluation.
842 
843     Examples
844     ========
845 
846     >>> from sympy import tan, pi
847     >>> from sympy.abc import x
848     >>> tan(x**2).diff(x)
849     2*x*(tan(x**2)**2 + 1)
850     >>> tan(1).diff(x)
851     0
852     >>> tan(pi/8).expand()
853     -1 + sqrt(2)
854 
855     See Also
856     ========
857 
858     sin, csc, cos, sec, cot
859     asin, acsc, acos, asec, atan, acot, atan2
860 
861     References
862     ==========
863 
864     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
865     .. [2] http://dlmf.nist.gov/4.14
866     .. [3] http://functions.wolfram.com/ElementaryFunctions/Tan
867     """
868 
869     def fdiff(self, argindex=1):
870         if argindex == 1:
871             return S.One + self**2
872         else:
873             raise ArgumentIndexError(self, argindex)
874 
875     def inverse(self, argindex=1):
876         """
877         Returns the inverse of this function.
878         """
879         return atan
880 
881     @classmethod
882     def eval(cls, arg):
883         from sympy.calculus.util import AccumBounds
884         if arg.is_Number:
885             if arg is S.NaN:
886                 return S.NaN
887             elif arg is S.Zero:
888                 return S.Zero
889             elif arg is S.Infinity or arg is S.NegativeInfinity:
890                 return AccumBounds(S.NegativeInfinity, S.Infinity)
891 
892         if isinstance(arg, AccumBounds):
893             min, max = arg.min, arg.max
894             d = floor(min/S.Pi)
895             if min is not S.NegativeInfinity:
896                 min = min - d*S.Pi
897             if max is not S.Infinity:
898                 max = max - d*S.Pi
899             if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 3*S.Pi/2)):
900                 return AccumBounds(S.NegativeInfinity, S.Infinity)
901             else:
902                 return AccumBounds(tan(min), tan(max))
903 
904         if arg.could_extract_minus_sign():
905             return -cls(-arg)
906 
907         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
908         if i_coeff is not None:
909             return S.ImaginaryUnit * tanh(i_coeff)
910 
911         pi_coeff = _pi_coeff(arg, 2)
912         if pi_coeff is not None:
913             if pi_coeff.is_integer:
914                 return S.Zero
915 
916             if not pi_coeff.is_Rational:
917                 narg = pi_coeff*S.Pi
918                 if narg != arg:
919                     return cls(narg)
920                 return None
921 
922             if pi_coeff.is_Rational:
923                 if not pi_coeff.q % 2:
924                     narg = pi_coeff*S.Pi*2
925                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
926                     if not isinstance(cresult, cos) \
927                             and not isinstance(sresult, cos):
928                         if sresult == 0:
929                             return S.ComplexInfinity
930                         return (1 - cresult)/sresult
931                 table2 = {
932                     12: (3, 4),
933                     20: (4, 5),
934                     30: (5, 6),
935                     15: (6, 10),
936                     24: (6, 8),
937                     40: (8, 10),
938                     60: (20, 30),
939                     120: (40, 60)
940                     }
941                 q = pi_coeff.q
942                 p = pi_coeff.p % q
943                 if q in table2:
944                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
945                     if None == nvala or None == nvalb:
946                         return None
947                     return (nvala - nvalb)/(1 + nvala*nvalb)
948                 narg = ((pi_coeff + S.Half) % 1 - S.Half)*S.Pi
949                 # see cos() to specify which expressions should  be
950                 # expanded automatically in terms of radicals
951                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
952                 if not isinstance(cresult, cos) \
953                         and not isinstance(sresult, cos):
954                     if cresult == 0:
955                         return S.ComplexInfinity
956                     return (sresult/cresult)
957                 if narg != arg:
958                     return cls(narg)
959 
960         if arg.is_Add:
961             x, m = _peeloff_pi(arg)
962             if m:
963                 tanm = tan(m)
964                 tanx = tan(x)
965                 if tanm is S.ComplexInfinity:
966                     return -cot(x)
967                 return (tanm + tanx)/(1 - tanm*tanx)
968 
969         if arg.func is atan:
970             return arg.args[0]
971 
972         if arg.func is atan2:
973             y, x = arg.args
974             return y/x
975 
976         if arg.func is asin:
977             x = arg.args[0]
978             return x / sqrt(1 - x**2)
979 
980         if arg.func is acos:
981             x = arg.args[0]
982             return sqrt(1 - x**2) / x
983 
984         if arg.func is acot:
985             x = arg.args[0]
986             return 1 / x
987 
988     @staticmethod
989     @cacheit
990     def taylor_term(n, x, *previous_terms):
991         from sympy import bernoulli
992         if n < 0 or n % 2 == 0:
993             return S.Zero
994         else:
995             x = sympify(x)
996 
997             a, b = ((n - 1)//2), 2**(n + 1)
998 
999             B = bernoulli(n + 1)
1000             F = factorial(n + 1)
1001 
1002             return (-1)**a * b*(b - 1) * B/F * x**n
1003 
1004     def _eval_nseries(self, x, n, logx):
1005         i = self.args[0].limit(x, 0)*2/S.Pi
1006         if i and i.is_Integer:
1007             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1008         return Function._eval_nseries(self, x, n=n, logx=logx)
1009 
1010     def _eval_rewrite_as_Pow(self, arg):
1011         if arg.func is log:
1012             I = S.ImaginaryUnit
1013             x = arg.args[0]
1014             return I*(x**-I - x**I)/(x**-I + x**I)
1015 
1016     def _eval_conjugate(self):
1017         return self.func(self.args[0].conjugate())
1018 
1019     def as_real_imag(self, deep=True, **hints):
1020         re, im = self._as_real_imag(deep=deep, **hints)
1021         if im:
1022             denom = cos(2*re) + cosh(2*im)
1023             return (sin(2*re)/denom, sinh(2*im)/denom)
1024         else:
1025             return (self.func(re), S.Zero)
1026 
1027     def _eval_expand_trig(self, **hints):
1028         from sympy import im, re
1029         arg = self.args[0]
1030         x = None
1031         if arg.is_Add:
1032             from sympy import symmetric_poly
1033             n = len(arg.args)
1034             TX = []
1035             for x in arg.args:
1036                 tx = tan(x, evaluate=False)._eval_expand_trig()
1037                 TX.append(tx)
1038 
1039             Yg = numbered_symbols('Y')
1040             Y = [ next(Yg) for i in range(n) ]
1041 
1042             p = [0, 0]
1043             for i in range(n + 1):
1044                 p[1 - i % 2] += symmetric_poly(i, Y)*(-1)**((i % 4)//2)
1045             return (p[0]/p[1]).subs(list(zip(Y, TX)))
1046 
1047         else:
1048             coeff, terms = arg.as_coeff_Mul(rational=True)
1049             if coeff.is_Integer and coeff > 1:
1050                 I = S.ImaginaryUnit
1051                 z = Symbol('dummy', real=True)
1052                 P = ((1 + I*z)**coeff).expand()
1053                 return (im(P)/re(P)).subs([(z, tan(terms))])
1054         return tan(arg)
1055 
1056     def _eval_rewrite_as_exp(self, arg):
1057         I = S.ImaginaryUnit
1058         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1059             arg = arg.func(arg.args[0]).rewrite(exp)
1060         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1061         return I*(neg_exp - pos_exp)/(neg_exp + pos_exp)
1062 
1063     def _eval_rewrite_as_sin(self, x):
1064         return 2*sin(x)**2/sin(2*x)
1065 
1066     def _eval_rewrite_as_cos(self, x):
1067         return -cos(x + S.Pi/2)/cos(x)
1068 
1069     def _eval_rewrite_as_sincos(self, arg):
1070         return sin(arg)/cos(arg)
1071 
1072     def _eval_rewrite_as_cot(self, arg):
1073         return 1/cot(arg)
1074 
1075     def _eval_rewrite_as_pow(self, arg):
1076         y = self.rewrite(cos).rewrite(pow)
1077         if y.has(cos):
1078             return None
1079         return y
1080 
1081     def _eval_rewrite_as_sqrt(self, arg):
1082         y = self.rewrite(cos).rewrite(sqrt)
1083         if y.has(cos):
1084             return None
1085         return y
1086 
1087     def _eval_as_leading_term(self, x):
1088         from sympy import Order
1089         arg = self.args[0].as_leading_term(x)
1090 
1091         if x in arg.free_symbols and Order(1, x).contains(arg):
1092             return arg
1093         else:
1094             return self.func(arg)
1095 
1096     def _eval_is_real(self):
1097         return self.args[0].is_real
1098 
1099     def _eval_is_finite(self):
1100         arg = self.args[0]
1101 
1102         if arg.is_imaginary:
1103             return True
1104 
1105 
1106 class cot(TrigonometricFunction):
1107     """
1108     The cotangent function.
1109 
1110     Returns the cotangent of x (measured in radians).
1111 
1112     Notes
1113     =====
1114 
1115     See :func:`sin` for notes about automatic evaluation.
1116 
1117     Examples
1118     ========
1119 
1120     >>> from sympy import cot, pi
1121     >>> from sympy.abc import x
1122     >>> cot(x**2).diff(x)
1123     2*x*(-cot(x**2)**2 - 1)
1124     >>> cot(1).diff(x)
1125     0
1126     >>> cot(pi/12)
1127     sqrt(3) + 2
1128 
1129     See Also
1130     ========
1131 
1132     sin, csc, cos, sec, tan
1133     asin, acsc, acos, asec, atan, acot, atan2
1134 
1135     References
1136     ==========
1137 
1138     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1139     .. [2] http://dlmf.nist.gov/4.14
1140     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cot
1141     """
1142 
1143     def fdiff(self, argindex=1):
1144         if argindex == 1:
1145             return S.NegativeOne - self**2
1146         else:
1147             raise ArgumentIndexError(self, argindex)
1148 
1149     def inverse(self, argindex=1):
1150         """
1151         Returns the inverse of this function.
1152         """
1153         return acot
1154 
1155     @classmethod
1156     def eval(cls, arg):
1157         from sympy.calculus.util import AccumBounds
1158         if arg.is_Number:
1159             if arg is S.NaN:
1160                 return S.NaN
1161             if arg is S.Zero:
1162                 return S.ComplexInfinity
1163 
1164         if isinstance(arg, AccumBounds):
1165             return -tan(arg + S.Pi/2)
1166 
1167         if arg.could_extract_minus_sign():
1168             return -cls(-arg)
1169 
1170         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1171         if i_coeff is not None:
1172             return -S.ImaginaryUnit * coth(i_coeff)
1173 
1174         pi_coeff = _pi_coeff(arg, 2)
1175         if pi_coeff is not None:
1176             if pi_coeff.is_integer:
1177                 return S.ComplexInfinity
1178 
1179             if not pi_coeff.is_Rational:
1180                 narg = pi_coeff*S.Pi
1181                 if narg != arg:
1182                     return cls(narg)
1183                 return None
1184 
1185             if pi_coeff.is_Rational:
1186                 if pi_coeff.q > 2 and not pi_coeff.q % 2:
1187                     narg = pi_coeff*S.Pi*2
1188                     cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1189                     if not isinstance(cresult, cos) \
1190                             and not isinstance(sresult, cos):
1191                         return (1 + cresult)/sresult
1192                 table2 = {
1193                     12: (3, 4),
1194                     20: (4, 5),
1195                     30: (5, 6),
1196                     15: (6, 10),
1197                     24: (6, 8),
1198                     40: (8, 10),
1199                     60: (20, 30),
1200                     120: (40, 60)
1201                     }
1202                 q = pi_coeff.q
1203                 p = pi_coeff.p % q
1204                 if q in table2:
1205                     nvala, nvalb = cls(p*S.Pi/table2[q][0]), cls(p*S.Pi/table2[q][1])
1206                     if None == nvala or None == nvalb:
1207                         return None
1208                     return (1 + nvala*nvalb)/(nvalb - nvala)
1209                 narg = (((pi_coeff + S.Half) % 1) - S.Half)*S.Pi
1210                 # see cos() to specify which expressions should be
1211                 # expanded automatically in terms of radicals
1212                 cresult, sresult = cos(narg), cos(narg - S.Pi/2)
1213                 if not isinstance(cresult, cos) \
1214                         and not isinstance(sresult, cos):
1215                     if sresult == 0:
1216                         return S.ComplexInfinity
1217                     return cresult / sresult
1218                 if narg != arg:
1219                     return cls(narg)
1220 
1221         if arg.is_Add:
1222             x, m = _peeloff_pi(arg)
1223             if m:
1224                 cotm = cot(m)
1225                 if cotm == 0:
1226                     return -tan(x)
1227                 cotx = cot(x)
1228                 if cotm is S.ComplexInfinity:
1229                     return cotx
1230                 if cotm.is_Rational:
1231                     return (cotm*cotx - 1) / (cotm + cotx)
1232             return None
1233 
1234         if arg.func is acot:
1235             return arg.args[0]
1236 
1237         if arg.func is atan:
1238             x = arg.args[0]
1239             return 1 / x
1240 
1241         if arg.func is atan2:
1242             y, x = arg.args
1243             return x/y
1244 
1245         if arg.func is asin:
1246             x = arg.args[0]
1247             return sqrt(1 - x**2) / x
1248 
1249         if arg.func is acos:
1250             x = arg.args[0]
1251             return x / sqrt(1 - x**2)
1252 
1253     @staticmethod
1254     @cacheit
1255     def taylor_term(n, x, *previous_terms):
1256         from sympy import bernoulli
1257         if n == 0:
1258             return 1 / sympify(x)
1259         elif n < 0 or n % 2 == 0:
1260             return S.Zero
1261         else:
1262             x = sympify(x)
1263 
1264             B = bernoulli(n + 1)
1265             F = factorial(n + 1)
1266 
1267             return (-1)**((n + 1)//2) * 2**(n + 1) * B/F * x**n
1268 
1269     def _eval_nseries(self, x, n, logx):
1270         i = self.args[0].limit(x, 0)/S.Pi
1271         if i and i.is_Integer:
1272             return self.rewrite(cos)._eval_nseries(x, n=n, logx=logx)
1273         return self.rewrite(tan)._eval_nseries(x, n=n, logx=logx)
1274 
1275     def _eval_conjugate(self):
1276         return self.func(self.args[0].conjugate())
1277 
1278     def as_real_imag(self, deep=True, **hints):
1279         re, im = self._as_real_imag(deep=deep, **hints)
1280         if im:
1281             denom = cos(2*re) - cosh(2*im)
1282             return (-sin(2*re)/denom, -sinh(2*im)/denom)
1283         else:
1284             return (self.func(re), S.Zero)
1285 
1286     def _eval_rewrite_as_exp(self, arg):
1287         I = S.ImaginaryUnit
1288         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
1289             arg = arg.func(arg.args[0]).rewrite(exp)
1290         neg_exp, pos_exp = exp(-arg*I), exp(arg*I)
1291         return I*(pos_exp + neg_exp)/(pos_exp - neg_exp)
1292 
1293     def _eval_rewrite_as_Pow(self, arg):
1294         if arg.func is log:
1295             I = S.ImaginaryUnit
1296             x = arg.args[0]
1297             return -I*(x**-I + x**I)/(x**-I - x**I)
1298 
1299     def _eval_rewrite_as_sin(self, x):
1300         return 2*sin(2*x)/sin(x)**2
1301 
1302     def _eval_rewrite_as_cos(self, x):
1303         return -cos(x)/cos(x + S.Pi/2)
1304 
1305     def _eval_rewrite_as_sincos(self, arg):
1306         return cos(arg)/sin(arg)
1307 
1308     def _eval_rewrite_as_tan(self, arg):
1309         return 1/tan(arg)
1310 
1311     def _eval_rewrite_as_pow(self, arg):
1312         y = self.rewrite(cos).rewrite(pow)
1313         if y.has(cos):
1314             return None
1315         return y
1316 
1317     def _eval_rewrite_as_sqrt(self, arg):
1318         y = self.rewrite(cos).rewrite(sqrt)
1319         if y.has(cos):
1320             return None
1321         return y
1322 
1323     def _eval_as_leading_term(self, x):
1324         from sympy import Order
1325         arg = self.args[0].as_leading_term(x)
1326 
1327         if x in arg.free_symbols and Order(1, x).contains(arg):
1328             return 1/arg
1329         else:
1330             return self.func(arg)
1331 
1332     def _eval_is_real(self):
1333         return self.args[0].is_real
1334 
1335     def _eval_expand_trig(self, **hints):
1336         from sympy import im, re
1337         arg = self.args[0]
1338         x = None
1339         if arg.is_Add:
1340             from sympy import symmetric_poly
1341             n = len(arg.args)
1342             CX = []
1343             for x in arg.args:
1344                 cx = cot(x, evaluate=False)._eval_expand_trig()
1345                 CX.append(cx)
1346 
1347             Yg = numbered_symbols('Y')
1348             Y = [ next(Yg) for i in range(n) ]
1349 
1350             p = [0, 0]
1351             for i in range(n, -1, -1):
1352                 p[(n - i) % 2] += symmetric_poly(i, Y)*(-1)**(((n - i) % 4)//2)
1353             return (p[0]/p[1]).subs(list(zip(Y, CX)))
1354         else:
1355             coeff, terms = arg.as_coeff_Mul(rational=True)
1356             if coeff.is_Integer and coeff > 1:
1357                 I = S.ImaginaryUnit
1358                 z = Symbol('dummy', real=True)
1359                 P = ((z + I)**coeff).expand()
1360                 return (re(P)/im(P)).subs([(z, cot(terms))])
1361         return cot(arg)
1362 
1363     def _eval_is_finite(self):
1364         arg = self.args[0]
1365         if arg.is_imaginary:
1366             return True
1367 
1368     def _eval_subs(self, old, new):
1369         if self == old:
1370             return new
1371         arg = self.args[0]
1372         argnew = arg.subs(old, new)
1373         if arg != argnew and (argnew/S.Pi).is_integer:
1374             return S.ComplexInfinity
1375         return cot(argnew)
1376 
1377 
1378 class ReciprocalTrigonometricFunction(TrigonometricFunction):
1379     """Base class for reciprocal functions of trigonometric functions. """
1380 
1381     _reciprocal_of = None       # mandatory, to be defined in subclass
1382 
1383     # _is_even and _is_odd are used for correct evaluation of csc(-x), sec(-x)
1384     # TODO refactor into TrigonometricFunction common parts of
1385     # trigonometric functions eval() like even/odd, func(x+2*k*pi), etc.
1386     _is_even = None  # optional, to be defined in subclass
1387     _is_odd = None   # optional, to be defined in subclass
1388 
1389     @classmethod
1390     def eval(cls, arg):
1391         if arg.could_extract_minus_sign():
1392             if cls._is_even:
1393                 return cls(-arg)
1394             if cls._is_odd:
1395                 return -cls(-arg)
1396 
1397         pi_coeff = _pi_coeff(arg)
1398         if (pi_coeff is not None
1399             and not (2*pi_coeff).is_integer
1400             and pi_coeff.is_Rational):
1401                 q = pi_coeff.q
1402                 p = pi_coeff.p % (2*q)
1403                 if p > q:
1404                     narg = (pi_coeff - 1)*S.Pi
1405                     return -cls(narg)
1406                 if 2*p > q:
1407                     narg = (1 - pi_coeff)*S.Pi
1408                     if cls._is_odd:
1409                         return cls(narg)
1410                     elif cls._is_even:
1411                         return -cls(narg)
1412 
1413         t = cls._reciprocal_of.eval(arg)
1414         if hasattr(arg, 'inverse') and arg.inverse() == cls:
1415             return arg.args[0]
1416         return 1/t if t != None else t
1417 
1418     def _call_reciprocal(self, method_name, *args, **kwargs):
1419         # Calls method_name on _reciprocal_of
1420         o = self._reciprocal_of(self.args[0])
1421         return getattr(o, method_name)(*args, **kwargs)
1422 
1423     def _calculate_reciprocal(self, method_name, *args, **kwargs):
1424         # If calling method_name on _reciprocal_of returns a value != None
1425         # then return the reciprocal of that value
1426         t = self._call_reciprocal(method_name, *args, **kwargs)
1427         return 1/t if t != None else t
1428 
1429     def _rewrite_reciprocal(self, method_name, arg):
1430         # Special handling for rewrite functions. If reciprocal rewrite returns
1431         # unmodified expression, then return None
1432         t = self._call_reciprocal(method_name, arg)
1433         if t != None and t != self._reciprocal_of(arg):
1434             return 1/t
1435 
1436     def fdiff(self, argindex=1):
1437         return -self._calculate_reciprocal("fdiff", argindex)/self**2
1438 
1439     def _eval_rewrite_as_exp(self, arg):
1440         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
1441 
1442     def _eval_rewrite_as_Pow(self, arg):
1443         return self._rewrite_reciprocal("_eval_rewrite_as_Pow", arg)
1444 
1445     def _eval_rewrite_as_sin(self, arg):
1446         return self._rewrite_reciprocal("_eval_rewrite_as_sin", arg)
1447 
1448     def _eval_rewrite_as_cos(self, arg):
1449         return self._rewrite_reciprocal("_eval_rewrite_as_cos", arg)
1450 
1451     def _eval_rewrite_as_tan(self, arg):
1452         return self._rewrite_reciprocal("_eval_rewrite_as_tan", arg)
1453 
1454     def _eval_rewrite_as_pow(self, arg):
1455         return self._rewrite_reciprocal("_eval_rewrite_as_pow", arg)
1456 
1457     def _eval_rewrite_as_sqrt(self, arg):
1458         return self._rewrite_reciprocal("_eval_rewrite_as_sqrt", arg)
1459 
1460     def _eval_conjugate(self):
1461         return self.func(self.args[0].conjugate())
1462 
1463     def as_real_imag(self, deep=True, **hints):
1464         return (1/self._reciprocal_of(self.args[0])).as_real_imag(deep,
1465                                                                   **hints)
1466 
1467     def _eval_expand_trig(self, **hints):
1468         return self._calculate_reciprocal("_eval_expand_trig", **hints)
1469 
1470     def _eval_is_real(self):
1471         return self._reciprocal_of(self.args[0])._eval_is_real()
1472 
1473     def _eval_as_leading_term(self, x):
1474         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
1475 
1476     def _eval_is_finite(self):
1477         return (1/self._reciprocal_of(self.args[0])).is_finite
1478 
1479     def _eval_nseries(self, x, n, logx):
1480         return (1/self._reciprocal_of(self.args[0]))._eval_nseries(x, n, logx)
1481 
1482 
1483 class sec(ReciprocalTrigonometricFunction):
1484     """
1485     The secant function.
1486 
1487     Returns the secant of x (measured in radians).
1488 
1489     Notes
1490     =====
1491 
1492     See :func:`sin` for notes about automatic evaluation.
1493 
1494     Examples
1495     ========
1496 
1497     >>> from sympy import sec
1498     >>> from sympy.abc import x
1499     >>> sec(x**2).diff(x)
1500     2*x*tan(x**2)*sec(x**2)
1501     >>> sec(1).diff(x)
1502     0
1503 
1504     See Also
1505     ========
1506 
1507     sin, csc, cos, tan, cot
1508     asin, acsc, acos, asec, atan, acot, atan2
1509 
1510     References
1511     ==========
1512 
1513     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1514     .. [2] http://dlmf.nist.gov/4.14
1515     .. [3] http://functions.wolfram.com/ElementaryFunctions/Sec
1516     """
1517 
1518     _reciprocal_of = cos
1519     _is_even = True
1520 
1521     def _eval_rewrite_as_cot(self, arg):
1522         cot_half_sq = cot(arg/2)**2
1523         return (cot_half_sq + 1)/(cot_half_sq - 1)
1524 
1525     def _eval_rewrite_as_cos(self, arg):
1526         return (1/cos(arg))
1527 
1528     def _eval_rewrite_as_sincos(self, arg):
1529         return sin(arg)/(cos(arg)*sin(arg))
1530 
1531     def fdiff(self, argindex=1):
1532         if argindex == 1:
1533             return tan(self.args[0])*sec(self.args[0])
1534         else:
1535             raise ArgumentIndexError(self, argindex)
1536 
1537     @staticmethod
1538     @cacheit
1539     def taylor_term(n, x, *previous_terms):
1540         # Reference Formula:
1541         # http://functions.wolfram.com/ElementaryFunctions/Sec/06/01/02/01/
1542         from sympy.functions.combinatorial.numbers import euler
1543         if n < 0 or n % 2 == 1:
1544             return S.Zero
1545         else:
1546             x = sympify(x)
1547             k = n//2
1548             return (-1)**k*euler(2*k)/factorial(2*k)*x**(2*k)
1549 
1550 
1551 class csc(ReciprocalTrigonometricFunction):
1552     """
1553     The cosecant function.
1554 
1555     Returns the cosecant of x (measured in radians).
1556 
1557     Notes
1558     =====
1559 
1560     See :func:`sin` for notes about automatic evaluation.
1561 
1562     Examples
1563     ========
1564 
1565     >>> from sympy import csc
1566     >>> from sympy.abc import x
1567     >>> csc(x**2).diff(x)
1568     -2*x*cot(x**2)*csc(x**2)
1569     >>> csc(1).diff(x)
1570     0
1571 
1572     See Also
1573     ========
1574 
1575     sin, cos, sec, tan, cot
1576     asin, acsc, acos, asec, atan, acot, atan2
1577 
1578     References
1579     ==========
1580 
1581     .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions
1582     .. [2] http://dlmf.nist.gov/4.14
1583     .. [3] http://functions.wolfram.com/ElementaryFunctions/Csc
1584     """
1585 
1586     _reciprocal_of = sin
1587     _is_odd = True
1588 
1589     def _eval_rewrite_as_sin(self, arg):
1590         return (1/sin(arg))
1591 
1592     def _eval_rewrite_as_sincos(self, arg):
1593         return cos(arg)/(sin(arg)*cos(arg))
1594 
1595     def _eval_rewrite_as_cot(self, arg):
1596         cot_half = cot(arg/2)
1597         return (1 + cot_half**2)/(2*cot_half)
1598 
1599     def fdiff(self, argindex=1):
1600         if argindex == 1:
1601             return -cot(self.args[0])*csc(self.args[0])
1602         else:
1603             raise ArgumentIndexError(self, argindex)
1604 
1605     @staticmethod
1606     @cacheit
1607     def taylor_term(n, x, *previous_terms):
1608         from sympy import bernoulli
1609         if n == 0:
1610             return 1/sympify(x)
1611         elif n < 0 or n % 2 == 0:
1612             return S.Zero
1613         else:
1614             x = sympify(x)
1615             k = n//2 + 1
1616             return ((-1)**(k - 1)*2*(2**(2*k - 1) - 1)*
1617                     bernoulli(2*k)*x**(2*k - 1)/factorial(2*k))
1618 
1619 
1620 class sinc(TrigonometricFunction):
1621     r"""Represents unnormalized sinc function
1622 
1623     Examples
1624     ========
1625 
1626     >>> from sympy import sinc, oo, jn, Product, Symbol
1627     >>> from sympy.abc import x
1628     >>> sinc(x)
1629     sinc(x)
1630 
1631     * Automated Evaluation
1632 
1633     >>> sinc(0)
1634     1
1635     >>> sinc(oo)
1636     0
1637 
1638     * Differentiation
1639 
1640     >>> sinc(x).diff()
1641     (x*cos(x) - sin(x))/x**2
1642 
1643     * Series Expansion
1644 
1645     >>> sinc(x).series()
1646     1 - x**2/6 + x**4/120 + O(x**6)
1647 
1648     * As zero'th order spherical Bessel Function
1649 
1650     >>> sinc(x).rewrite(jn)
1651     jn(0, x)
1652 
1653     References
1654     ==========
1655 
1656     .. [1] http://en.wikipedia.org/wiki/Sinc_function
1657 
1658     """
1659 
1660     def fdiff(self, argindex=1):
1661         x = self.args[0]
1662         if argindex == 1:
1663             return (x*cos(x) - sin(x)) / x**2
1664         else:
1665             raise ArgumentIndexError(self, argindex)
1666 
1667     @classmethod
1668     def eval(cls, arg):
1669         if arg.is_zero:
1670             return S.One
1671         if arg.is_Number:
1672             if arg in [S.Infinity, -S.Infinity]:
1673                 return S.Zero
1674             elif arg is S.NaN:
1675                 return S.NaN
1676 
1677         if arg is S.ComplexInfinity:
1678             return S.NaN
1679 
1680         if arg.could_extract_minus_sign():
1681             return cls(-arg)
1682 
1683         pi_coeff = _pi_coeff(arg)
1684         if pi_coeff is not None:
1685             if pi_coeff.is_integer:
1686                 if fuzzy_not(arg.is_zero):
1687                     return S.Zero
1688             elif (2*pi_coeff).is_integer:
1689                 return S.NegativeOne**(pi_coeff - S.Half) / arg
1690 
1691     def _eval_nseries(self, x, n, logx):
1692         x = self.args[0]
1693         return (sin(x)/x)._eval_nseries(x, n, logx)
1694 
1695     def _eval_rewrite_as_jn(self, arg):
1696         from sympy.functions.special.bessel import jn
1697         return jn(0, arg)
1698 
1699     def _eval_rewrite_as_sin(self, arg):
1700         return sin(arg) / arg
1701 
1702 
1703 ###############################################################################
1704 ########################### TRIGONOMETRIC INVERSES ############################
1705 ###############################################################################
1706 
1707 
1708 class InverseTrigonometricFunction(Function):
1709     """Base class for inverse trigonometric functions."""
1710 
1711     pass
1712 
1713 
1714 class asin(InverseTrigonometricFunction):
1715     """
1716     The inverse sine function.
1717 
1718     Returns the arcsine of x in radians.
1719 
1720     Notes
1721     =====
1722 
1723     asin(x) will evaluate automatically in the cases oo, -oo, 0, 1,
1724     -1 and for some instances when the result is a rational multiple
1725     of pi (see the eval class method).
1726 
1727     Examples
1728     ========
1729 
1730     >>> from sympy import asin, oo, pi
1731     >>> asin(1)
1732     pi/2
1733     >>> asin(-1)
1734     -pi/2
1735 
1736     See Also
1737     ========
1738 
1739     sin, csc, cos, sec, tan, cot
1740     acsc, acos, asec, atan, acot, atan2
1741 
1742     References
1743     ==========
1744 
1745     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1746     .. [2] http://dlmf.nist.gov/4.23
1747     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSin
1748     """
1749 
1750     def fdiff(self, argindex=1):
1751         if argindex == 1:
1752             return 1/sqrt(1 - self.args[0]**2)
1753         else:
1754             raise ArgumentIndexError(self, argindex)
1755 
1756     def _eval_is_rational(self):
1757         s = self.func(*self.args)
1758         if s.func == self.func:
1759             if s.args[0].is_rational:
1760                 return False
1761         else:
1762             return s.is_rational
1763 
1764     def _eval_is_positive(self):
1765         if self.args[0].is_positive:
1766             return (self.args[0] - 1).is_negative
1767         if self.args[0].is_negative:
1768             return not (self.args[0] + 1).is_positive
1769 
1770     @classmethod
1771     def eval(cls, arg):
1772         if arg.is_Number:
1773             if arg is S.NaN:
1774                 return S.NaN
1775             elif arg is S.Infinity:
1776                 return S.NegativeInfinity * S.ImaginaryUnit
1777             elif arg is S.NegativeInfinity:
1778                 return S.Infinity * S.ImaginaryUnit
1779             elif arg is S.Zero:
1780                 return S.Zero
1781             elif arg is S.One:
1782                 return S.Pi / 2
1783             elif arg is S.NegativeOne:
1784                 return -S.Pi / 2
1785 
1786         if arg.could_extract_minus_sign():
1787             return -cls(-arg)
1788 
1789         if arg.is_number:
1790             cst_table = {
1791                 sqrt(3)/2: 3,
1792                 -sqrt(3)/2: -3,
1793                 sqrt(2)/2: 4,
1794                 -sqrt(2)/2: -4,
1795                 1/sqrt(2): 4,
1796                 -1/sqrt(2): -4,
1797                 sqrt((5 - sqrt(5))/8): 5,
1798                 -sqrt((5 - sqrt(5))/8): -5,
1799                 S.Half: 6,
1800                 -S.Half: -6,
1801                 sqrt(2 - sqrt(2))/2: 8,
1802                 -sqrt(2 - sqrt(2))/2: -8,
1803                 (sqrt(5) - 1)/4: 10,
1804                 (1 - sqrt(5))/4: -10,
1805                 (sqrt(3) - 1)/sqrt(2**3): 12,
1806                 (1 - sqrt(3))/sqrt(2**3): -12,
1807                 (sqrt(5) + 1)/4: S(10)/3,
1808                 -(sqrt(5) + 1)/4: -S(10)/3
1809             }
1810 
1811             if arg in cst_table:
1812                 return S.Pi / cst_table[arg]
1813 
1814         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1815         if i_coeff is not None:
1816             return S.ImaginaryUnit * asinh(i_coeff)
1817 
1818     @staticmethod
1819     @cacheit
1820     def taylor_term(n, x, *previous_terms):
1821         if n < 0 or n % 2 == 0:
1822             return S.Zero
1823         else:
1824             x = sympify(x)
1825             if len(previous_terms) >= 2 and n > 2:
1826                 p = previous_terms[-2]
1827                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1828             else:
1829                 k = (n - 1) // 2
1830                 R = RisingFactorial(S.Half, k)
1831                 F = factorial(k)
1832                 return R / F * x**n / n
1833 
1834     def _eval_as_leading_term(self, x):
1835         from sympy import Order
1836         arg = self.args[0].as_leading_term(x)
1837 
1838         if x in arg.free_symbols and Order(1, x).contains(arg):
1839             return arg
1840         else:
1841             return self.func(arg)
1842 
1843     def _eval_rewrite_as_acos(self, x):
1844         return S.Pi/2 - acos(x)
1845 
1846     def _eval_rewrite_as_atan(self, x):
1847         return 2*atan(x/(1 + sqrt(1 - x**2)))
1848 
1849     def _eval_rewrite_as_log(self, x):
1850         return -S.ImaginaryUnit*log(S.ImaginaryUnit*x + sqrt(1 - x**2))
1851 
1852     def _eval_rewrite_as_acot(self, arg):
1853         return 2*acot((1 + sqrt(1 - arg**2))/arg)
1854 
1855     def _eval_rewrite_as_asec(self, arg):
1856         return S.Pi/2 - asec(1/arg)
1857 
1858     def _eval_rewrite_as_acsc(self, arg):
1859         return acsc(1/arg)
1860 
1861     def _eval_is_real(self):
1862         x = self.args[0]
1863         return x.is_real and (1 - abs(x)).is_nonnegative
1864 
1865     def inverse(self, argindex=1):
1866         """
1867         Returns the inverse of this function.
1868         """
1869         return sin
1870 
1871 
1872 class acos(InverseTrigonometricFunction):
1873     """
1874     The inverse cosine function.
1875 
1876     Returns the arc cosine of x (measured in radians).
1877 
1878     Notes
1879     =====
1880 
1881     ``acos(x)`` will evaluate automatically in the cases
1882     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
1883 
1884     ``acos(zoo)`` evaluates to ``zoo``
1885     (see note in :py:class`sympy.functions.elementary.trigonometric.asec`)
1886 
1887     Examples
1888     ========
1889 
1890     >>> from sympy import acos, oo, pi
1891     >>> acos(1)
1892     0
1893     >>> acos(0)
1894     pi/2
1895     >>> acos(oo)
1896     oo*I
1897 
1898     See Also
1899     ========
1900 
1901     sin, csc, cos, sec, tan, cot
1902     asin, acsc, asec, atan, acot, atan2
1903 
1904     References
1905     ==========
1906 
1907     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
1908     .. [2] http://dlmf.nist.gov/4.23
1909     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCos
1910     """
1911 
1912     def fdiff(self, argindex=1):
1913         if argindex == 1:
1914             return -1/sqrt(1 - self.args[0]**2)
1915         else:
1916             raise ArgumentIndexError(self, argindex)
1917 
1918     def _eval_is_rational(self):
1919         s = self.func(*self.args)
1920         if s.func == self.func:
1921             if s.args[0].is_rational:
1922                 return False
1923         else:
1924             return s.is_rational
1925 
1926     def _eval_is_positive(self):
1927         x = self.args[0]
1928         return (1 - abs(x)).is_nonnegative
1929 
1930     @classmethod
1931     def eval(cls, arg):
1932         if arg.is_Number:
1933             if arg is S.NaN:
1934                 return S.NaN
1935             elif arg is S.Infinity:
1936                 return S.Infinity * S.ImaginaryUnit
1937             elif arg is S.NegativeInfinity:
1938                 return S.NegativeInfinity * S.ImaginaryUnit
1939             elif arg is S.Zero:
1940                 return S.Pi / 2
1941             elif arg is S.One:
1942                 return S.Zero
1943             elif arg is S.NegativeOne:
1944                 return S.Pi
1945 
1946         if arg is S.ComplexInfinity:
1947             return S.ComplexInfinity
1948 
1949         if arg.is_number:
1950             cst_table = {
1951                 S.Half: S.Pi/3,
1952                 -S.Half: 2*S.Pi/3,
1953                 sqrt(2)/2: S.Pi/4,
1954                 -sqrt(2)/2: 3*S.Pi/4,
1955                 1/sqrt(2): S.Pi/4,
1956                 -1/sqrt(2): 3*S.Pi/4,
1957                 sqrt(3)/2: S.Pi/6,
1958                 -sqrt(3)/2: 5*S.Pi/6,
1959             }
1960 
1961             if arg in cst_table:
1962                 return cst_table[arg]
1963 
1964     @staticmethod
1965     @cacheit
1966     def taylor_term(n, x, *previous_terms):
1967         if n == 0:
1968             return S.Pi / 2
1969         elif n < 0 or n % 2 == 0:
1970             return S.Zero
1971         else:
1972             x = sympify(x)
1973             if len(previous_terms) >= 2 and n > 2:
1974                 p = previous_terms[-2]
1975                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1976             else:
1977                 k = (n - 1) // 2
1978                 R = RisingFactorial(S.Half, k)
1979                 F = factorial(k)
1980                 return -R / F * x**n / n
1981 
1982     def _eval_as_leading_term(self, x):
1983         from sympy import Order
1984         arg = self.args[0].as_leading_term(x)
1985 
1986         if x in arg.free_symbols and Order(1, x).contains(arg):
1987             return arg
1988         else:
1989             return self.func(arg)
1990 
1991     def _eval_is_real(self):
1992         x = self.args[0]
1993         return x.is_real and (1 - abs(x)).is_nonnegative
1994 
1995     def _eval_rewrite_as_log(self, x):
1996         return S.Pi/2 + S.ImaginaryUnit * \
1997             log(S.ImaginaryUnit * x + sqrt(1 - x**2))
1998 
1999     def _eval_rewrite_as_asin(self, x):
2000         return S.Pi/2 - asin(x)
2001 
2002     def _eval_rewrite_as_atan(self, x):
2003         return atan(sqrt(1 - x**2)/x) + (S.Pi/2)*(1 - x*sqrt(1/x**2))
2004 
2005     def inverse(self, argindex=1):
2006         """
2007         Returns the inverse of this function.
2008         """
2009         return cos
2010 
2011     def _eval_rewrite_as_acot(self, arg):
2012         return S.Pi/2 - 2*acot((1 + sqrt(1 - arg**2))/arg)
2013 
2014     def _eval_rewrite_as_asec(self, arg):
2015         return asec(1/arg)
2016 
2017     def _eval_rewrite_as_acsc(self, arg):
2018         return S.Pi/2 - acsc(1/arg)
2019 
2020     def _eval_conjugate(self):
2021         z = self.args[0]
2022         r = self.func(self.args[0].conjugate())
2023         if z.is_real is False:
2024             return r
2025         elif z.is_real and (z + 1).is_nonnegative and (z - 1).is_nonpositive:
2026             return r
2027 
2028 
2029 class atan(InverseTrigonometricFunction):
2030     """
2031     The inverse tangent function.
2032 
2033     Returns the arc tangent of x (measured in radians).
2034 
2035     Notes
2036     =====
2037 
2038     atan(x) will evaluate automatically in the cases
2039     oo, -oo, 0, 1, -1.
2040 
2041     Examples
2042     ========
2043 
2044     >>> from sympy import atan, oo, pi
2045     >>> atan(0)
2046     0
2047     >>> atan(1)
2048     pi/4
2049     >>> atan(oo)
2050     pi/2
2051 
2052     See Also
2053     ========
2054 
2055     sin, csc, cos, sec, tan, cot
2056     asin, acsc, acos, asec, acot, atan2
2057 
2058     References
2059     ==========
2060 
2061     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2062     .. [2] http://dlmf.nist.gov/4.23
2063     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan
2064     """
2065 
2066     def fdiff(self, argindex=1):
2067         if argindex == 1:
2068             return 1/(1 + self.args[0]**2)
2069         else:
2070             raise ArgumentIndexError(self, argindex)
2071 
2072     def _eval_is_rational(self):
2073         s = self.func(*self.args)
2074         if s.func == self.func:
2075             if s.args[0].is_rational:
2076                 return False
2077         else:
2078             return s.is_rational
2079 
2080     def _eval_is_positive(self):
2081         return self.args[0].is_positive
2082 
2083     def _eval_is_nonnegative(self):
2084         return self.args[0].is_nonnegative
2085 
2086     @classmethod
2087     def eval(cls, arg):
2088         if arg.is_Number:
2089             if arg is S.NaN:
2090                 return S.NaN
2091             elif arg is S.Infinity:
2092                 return S.Pi / 2
2093             elif arg is S.NegativeInfinity:
2094                 return -S.Pi / 2
2095             elif arg is S.Zero:
2096                 return S.Zero
2097             elif arg is S.One:
2098                 return S.Pi / 4
2099             elif arg is S.NegativeOne:
2100                 return -S.Pi / 4
2101         if arg.could_extract_minus_sign():
2102             return -cls(-arg)
2103 
2104         if arg.is_number:
2105             cst_table = {
2106                 sqrt(3)/3: 6,
2107                 -sqrt(3)/3: -6,
2108                 1/sqrt(3): 6,
2109                 -1/sqrt(3): -6,
2110                 sqrt(3): 3,
2111                 -sqrt(3): -3,
2112                 (1 + sqrt(2)): S(8)/3,
2113                 -(1 + sqrt(2)): S(8)/3,
2114                 (sqrt(2) - 1): 8,
2115                 (1 - sqrt(2)): -8,
2116                 sqrt((5 + 2*sqrt(5))): S(5)/2,
2117                 -sqrt((5 + 2*sqrt(5))): -S(5)/2,
2118                 (2 - sqrt(3)): 12,
2119                 -(2 - sqrt(3)): -12
2120             }
2121 
2122             if arg in cst_table:
2123                 return S.Pi / cst_table[arg]
2124 
2125         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2126         if i_coeff is not None:
2127             return S.ImaginaryUnit * atanh(i_coeff)
2128 
2129     @staticmethod
2130     @cacheit
2131     def taylor_term(n, x, *previous_terms):
2132         if n < 0 or n % 2 == 0:
2133             return S.Zero
2134         else:
2135             x = sympify(x)
2136             return (-1)**((n - 1)//2) * x**n / n
2137 
2138     def _eval_as_leading_term(self, x):
2139         from sympy import Order
2140         arg = self.args[0].as_leading_term(x)
2141 
2142         if x in arg.free_symbols and Order(1, x).contains(arg):
2143             return arg
2144         else:
2145             return self.func(arg)
2146 
2147     def _eval_is_real(self):
2148         return self.args[0].is_real
2149 
2150     def _eval_rewrite_as_log(self, x):
2151         return S.ImaginaryUnit/2 * (log(
2152             (S(1) - S.ImaginaryUnit * x)/(S(1) + S.ImaginaryUnit * x)))
2153 
2154     def _eval_aseries(self, n, args0, x, logx):
2155         if args0[0] == S.Infinity:
2156             return (S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2157         elif args0[0] == S.NegativeInfinity:
2158             return (-S.Pi/2 - atan(1/self.args[0]))._eval_nseries(x, n, logx)
2159         else:
2160             return super(atan, self)._eval_aseries(n, args0, x, logx)
2161 
2162     def inverse(self, argindex=1):
2163         """
2164         Returns the inverse of this function.
2165         """
2166         return tan
2167 
2168     def _eval_rewrite_as_asin(self, arg):
2169         return sqrt(arg**2)/arg*(S.Pi/2 - asin(1/sqrt(1 + arg**2)))
2170 
2171     def _eval_rewrite_as_acos(self, arg):
2172         return sqrt(arg**2)/arg*acos(1/sqrt(1 + arg**2))
2173 
2174     def _eval_rewrite_as_acot(self, arg):
2175         return acot(1/arg)
2176 
2177     def _eval_rewrite_as_asec(self, arg):
2178         return sqrt(arg**2)/arg*asec(sqrt(1 + arg**2))
2179 
2180     def _eval_rewrite_as_acsc(self, arg):
2181         return sqrt(arg**2)/arg*(S.Pi/2 - acsc(sqrt(1 + arg**2)))
2182 
2183 
2184 class acot(InverseTrigonometricFunction):
2185     """
2186     The inverse cotangent function.
2187 
2188     Returns the arc cotangent of x (measured in radians).
2189 
2190     See Also
2191     ========
2192 
2193     sin, csc, cos, sec, tan, cot
2194     asin, acsc, acos, asec, atan, atan2
2195 
2196     References
2197     ==========
2198 
2199     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2200     .. [2] http://dlmf.nist.gov/4.23
2201     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCot
2202     """
2203 
2204     def fdiff(self, argindex=1):
2205         if argindex == 1:
2206             return -1 / (1 + self.args[0]**2)
2207         else:
2208             raise ArgumentIndexError(self, argindex)
2209 
2210     def _eval_is_rational(self):
2211         s = self.func(*self.args)
2212         if s.func == self.func:
2213             if s.args[0].is_rational:
2214                 return False
2215         else:
2216             return s.is_rational
2217 
2218     def _eval_is_positive(self):
2219         return self.args[0].is_real
2220 
2221     @classmethod
2222     def eval(cls, arg):
2223         if arg.is_Number:
2224             if arg is S.NaN:
2225                 return S.NaN
2226             elif arg is S.Infinity:
2227                 return S.Zero
2228             elif arg is S.NegativeInfinity:
2229                 return S.Zero
2230             elif arg is S.Zero:
2231                 return S.Pi/ 2
2232             elif arg is S.One:
2233                 return S.Pi / 4
2234             elif arg is S.NegativeOne:
2235                 return -S.Pi / 4
2236 
2237         if arg.could_extract_minus_sign():
2238             return -cls(-arg)
2239 
2240         if arg.is_number:
2241             cst_table = {
2242                 sqrt(3)/3: 3,
2243                 -sqrt(3)/3: -3,
2244                 1/sqrt(3): 3,
2245                 -1/sqrt(3): -3,
2246                 sqrt(3): 6,
2247                 -sqrt(3): -6,
2248                 (1 + sqrt(2)): 8,
2249                 -(1 + sqrt(2)): -8,
2250                 (1 - sqrt(2)): -S(8)/3,
2251                 (sqrt(2) - 1): S(8)/3,
2252                 sqrt(5 + 2*sqrt(5)): 10,
2253                 -sqrt(5 + 2*sqrt(5)): -10,
2254                 (2 + sqrt(3)): 12,
2255                 -(2 + sqrt(3)): -12,
2256                 (2 - sqrt(3)): S(12)/5,
2257                 -(2 - sqrt(3)): -S(12)/5,
2258             }
2259 
2260             if arg in cst_table:
2261                 return S.Pi / cst_table[arg]
2262 
2263         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
2264         if i_coeff is not None:
2265             return -S.ImaginaryUnit * acoth(i_coeff)
2266 
2267     @staticmethod
2268     @cacheit
2269     def taylor_term(n, x, *previous_terms):
2270         if n == 0:
2271             return S.Pi / 2  # FIX THIS
2272         elif n < 0 or n % 2 == 0:
2273             return S.Zero
2274         else:
2275             x = sympify(x)
2276             return (-1)**((n + 1)//2) * x**n / n
2277 
2278     def _eval_as_leading_term(self, x):
2279         from sympy import Order
2280         arg = self.args[0].as_leading_term(x)
2281 
2282         if x in arg.free_symbols and Order(1, x).contains(arg):
2283             return arg
2284         else:
2285             return self.func(arg)
2286 
2287     def _eval_is_real(self):
2288         return self.args[0].is_real
2289 
2290     def _eval_aseries(self, n, args0, x, logx):
2291         if args0[0] == S.Infinity:
2292             return (S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2293         elif args0[0] == S.NegativeInfinity:
2294             return (3*S.Pi/2 - acot(1/self.args[0]))._eval_nseries(x, n, logx)
2295         else:
2296             return super(atan, self)._eval_aseries(n, args0, x, logx)
2297 
2298     def _eval_rewrite_as_log(self, x):
2299         return S.ImaginaryUnit/2 * \
2300             (log((x - S.ImaginaryUnit)/(x + S.ImaginaryUnit)))
2301 
2302     def inverse(self, argindex=1):
2303         """
2304         Returns the inverse of this function.
2305         """
2306         return cot
2307 
2308     def _eval_rewrite_as_asin(self, arg):
2309         return (arg*sqrt(1/arg**2)*
2310                 (S.Pi/2 - asin(sqrt(-arg**2)/sqrt(-arg**2 - 1))))
2311 
2312     def _eval_rewrite_as_acos(self, arg):
2313         return arg*sqrt(1/arg**2)*acos(sqrt(-arg**2)/sqrt(-arg**2 - 1))
2314 
2315     def _eval_rewrite_as_atan(self, arg):
2316         return atan(1/arg)
2317 
2318     def _eval_rewrite_as_asec(self, arg):
2319         return arg*sqrt(1/arg**2)*asec(sqrt((1 + arg**2)/arg**2))
2320 
2321     def _eval_rewrite_as_acsc(self, arg):
2322         return arg*sqrt(1/arg**2)*(S.Pi/2 - acsc(sqrt((1 + arg**2)/arg**2)))
2323 
2324 
2325 class asec(InverseTrigonometricFunction):
2326     """
2327     The inverse secant function.
2328 
2329     Returns the arc secant of x (measured in radians).
2330 
2331     Notes
2332     =====
2333 
2334     ``asec(x)`` will evaluate automatically in the cases
2335     ``oo``, ``-oo``, ``0``, ``1``, ``-1``.
2336 
2337     ``asec(x)`` has branch cut in the interval [-1, 1]. For complex arguments,
2338     it can be defined [4]_ as
2339 
2340     .. math::
2341         sec^{-1}(z) = -i*(log(\sqrt{1 - z^2} + 1) / z)
2342 
2343     At ``x = 0``, for positive branch cut, the limit evaluates to ``zoo``. For
2344     negative branch cut, the limit
2345 
2346     .. math::
2347         \lim_{z \to 0}-i*(log(-\sqrt{1 - z^2} + 1) / z)
2348 
2349     simplifies to :math:`-i*log(z/2 + O(z^3))` which ultimately evaluates to
2350     ``zoo``.
2351 
2352     As ``asex(x)`` = ``asec(1/x)``, a similar argument can be given for
2353     ``acos(x)``.
2354 
2355     Examples
2356     ========
2357 
2358     >>> from sympy import asec, oo, pi
2359     >>> asec(1)
2360     0
2361     >>> asec(-1)
2362     pi
2363 
2364     See Also
2365     ========
2366 
2367     sin, csc, cos, sec, tan, cot
2368     asin, acsc, acos, atan, acot, atan2
2369 
2370     References
2371     ==========
2372 
2373     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2374     .. [2] http://dlmf.nist.gov/4.23
2375     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSec
2376     .. [4] http://refrence.wolfram.com/language/ref/ArcSec.html
2377     """
2378 
2379     @classmethod
2380     def eval(cls, arg):
2381         if arg.is_zero:
2382             return S.ComplexInfinity
2383         if arg.is_Number:
2384             if arg is S.NaN:
2385                 return S.NaN
2386             elif arg is S.One:
2387                 return S.Zero
2388             elif arg is S.NegativeOne:
2389                 return S.Pi
2390         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2391             return S.Pi/2
2392 
2393     def fdiff(self, argindex=1):
2394         if argindex == 1:
2395             return 1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2396         else:
2397             raise ArgumentIndexError(self, argindex)
2398 
2399     def inverse(self, argindex=1):
2400         """
2401         Returns the inverse of this function.
2402         """
2403         return sec
2404 
2405     def _eval_as_leading_term(self, x):
2406         from sympy import Order
2407         arg = self.args[0].as_leading_term(x)
2408         if Order(1,x).contains(arg):
2409             return log(arg)
2410         else:
2411             return self.func(arg)
2412 
2413     def _eval_is_real(self):
2414         x = self.args[0]
2415         if x.is_real is False:
2416             return False
2417         return (x - 1).is_nonnegative or (-x - 1).is_nonnegative
2418 
2419     def _eval_rewrite_as_log(self, arg):
2420         return S.Pi/2 + S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2421 
2422     def _eval_rewrite_as_asin(self, arg):
2423         return S.Pi/2 - asin(1/arg)
2424 
2425     def _eval_rewrite_as_acos(self, arg):
2426         return acos(1/arg)
2427 
2428     def _eval_rewrite_as_atan(self, arg):
2429         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*atan(arg + sqrt(arg**2 - 1)))
2430 
2431     def _eval_rewrite_as_acot(self, arg):
2432         return sqrt(arg**2)/arg*(-S.Pi/2 + 2*acot(arg - sqrt(arg**2 - 1)))
2433 
2434     def _eval_rewrite_as_acsc(self, arg):
2435         return S.Pi/2 - acsc(arg)
2436 
2437 
2438 class acsc(InverseTrigonometricFunction):
2439     """
2440     The inverse cosecant function.
2441 
2442     Returns the arc cosecant of x (measured in radians).
2443 
2444     Notes
2445     =====
2446 
2447     acsc(x) will evaluate automatically in the cases
2448     oo, -oo, 0, 1, -1.
2449 
2450     Examples
2451     ========
2452 
2453     >>> from sympy import acsc, oo, pi
2454     >>> acsc(1)
2455     pi/2
2456     >>> acsc(-1)
2457     -pi/2
2458 
2459     See Also
2460     ========
2461 
2462     sin, csc, cos, sec, tan, cot
2463     asin, acos, asec, atan, acot, atan2
2464 
2465     References
2466     ==========
2467 
2468     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2469     .. [2] http://dlmf.nist.gov/4.23
2470     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsc
2471     """
2472 
2473     @classmethod
2474     def eval(cls, arg):
2475         if arg.is_Number:
2476             if arg is S.NaN:
2477                 return S.NaN
2478             elif arg is S.One:
2479                 return S.Pi/2
2480             elif arg is S.NegativeOne:
2481                 return -S.Pi/2
2482         if arg in [S.Infinity, S.NegativeInfinity, S.ComplexInfinity]:
2483             return S.Zero
2484 
2485     def fdiff(self, argindex=1):
2486         if argindex == 1:
2487             return -1/(self.args[0]**2*sqrt(1 - 1/self.args[0]**2))
2488         else:
2489             raise ArgumentIndexError(self, argindex)
2490 
2491     def inverse(self, argindex=1):
2492         """
2493         Returns the inverse of this function.
2494         """
2495         return csc
2496 
2497     def _eval_as_leading_term(self, x):
2498         from sympy import Order
2499         arg = self.args[0].as_leading_term(x)
2500         if Order(1,x).contains(arg):
2501             return log(arg)
2502         else:
2503             return self.func(arg)
2504 
2505     def _eval_rewrite_as_log(self, arg):
2506         return -S.ImaginaryUnit*log(S.ImaginaryUnit/arg + sqrt(1 - 1/arg**2))
2507 
2508     def _eval_rewrite_as_asin(self, arg):
2509         return asin(1/arg)
2510 
2511     def _eval_rewrite_as_acos(self, arg):
2512         return S.Pi/2 - acos(1/arg)
2513 
2514     def _eval_rewrite_as_atan(self, arg):
2515         return sqrt(arg**2)/arg*(S.Pi/2 - atan(sqrt(arg**2 - 1)))
2516 
2517     def _eval_rewrite_as_acot(self, arg):
2518         return sqrt(arg**2)/arg*(S.Pi/2 - acot(1/sqrt(arg**2 - 1)))
2519 
2520     def _eval_rewrite_as_asec(self, arg):
2521         return S.Pi/2 - asec(arg)
2522 
2523 
2524 class atan2(InverseTrigonometricFunction):
2525     r"""
2526     The function ``atan2(y, x)`` computes `\operatorname{atan}(y/x)` taking
2527     two arguments `y` and `x`.  Signs of both `y` and `x` are considered to
2528     determine the appropriate quadrant of `\operatorname{atan}(y/x)`.
2529     The range is `(-\pi, \pi]`. The complete definition reads as follows:
2530 
2531     .. math::
2532 
2533         \operatorname{atan2}(y, x) =
2534         \begin{cases}
2535           \arctan\left(\frac y x\right) & \qquad x > 0 \\
2536           \arctan\left(\frac y x\right) + \pi& \qquad y \ge 0 , x < 0 \\
2537           \arctan\left(\frac y x\right) - \pi& \qquad y < 0 , x < 0 \\
2538           +\frac{\pi}{2} & \qquad y > 0 , x = 0 \\
2539           -\frac{\pi}{2} & \qquad y < 0 , x = 0 \\
2540           \text{undefined} & \qquad y = 0, x = 0
2541         \end{cases}
2542 
2543     Attention: Note the role reversal of both arguments. The `y`-coordinate
2544     is the first argument and the `x`-coordinate the second.
2545 
2546     Examples
2547     ========
2548 
2549     Going counter-clock wise around the origin we find the
2550     following angles:
2551 
2552     >>> from sympy import atan2
2553     >>> atan2(0, 1)
2554     0
2555     >>> atan2(1, 1)
2556     pi/4
2557     >>> atan2(1, 0)
2558     pi/2
2559     >>> atan2(1, -1)
2560     3*pi/4
2561     >>> atan2(0, -1)
2562     pi
2563     >>> atan2(-1, -1)
2564     -3*pi/4
2565     >>> atan2(-1, 0)
2566     -pi/2
2567     >>> atan2(-1, 1)
2568     -pi/4
2569 
2570     which are all correct. Compare this to the results of the ordinary
2571     `\operatorname{atan}` function for the point `(x, y) = (-1, 1)`
2572 
2573     >>> from sympy import atan, S
2574     >>> atan(S(1) / -1)
2575     -pi/4
2576     >>> atan2(1, -1)
2577     3*pi/4
2578 
2579     where only the `\operatorname{atan2}` function reurns what we expect.
2580     We can differentiate the function with respect to both arguments:
2581 
2582     >>> from sympy import diff
2583     >>> from sympy.abc import x, y
2584     >>> diff(atan2(y, x), x)
2585     -y/(x**2 + y**2)
2586 
2587     >>> diff(atan2(y, x), y)
2588     x/(x**2 + y**2)
2589 
2590     We can express the `\operatorname{atan2}` function in terms of
2591     complex logarithms:
2592 
2593     >>> from sympy import log
2594     >>> atan2(y, x).rewrite(log)
2595     -I*log((x + I*y)/sqrt(x**2 + y**2))
2596 
2597     and in terms of `\operatorname(atan)`:
2598 
2599     >>> from sympy import atan
2600     >>> atan2(y, x).rewrite(atan)
2601     2*atan(y/(x + sqrt(x**2 + y**2)))
2602 
2603     but note that this form is undefined on the negative real axis.
2604 
2605     See Also
2606     ========
2607 
2608     sin, csc, cos, sec, tan, cot
2609     asin, acsc, acos, asec, atan, acot
2610 
2611     References
2612     ==========
2613 
2614     .. [1] http://en.wikipedia.org/wiki/Inverse_trigonometric_functions
2615     .. [2] http://en.wikipedia.org/wiki/Atan2
2616     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcTan2
2617     """
2618 
2619     @classmethod
2620     def eval(cls, y, x):
2621         from sympy import Heaviside, im, re
2622         if x is S.NegativeInfinity:
2623             if y.is_zero:
2624                 # Special case y = 0 because we define Heaviside(0) = 1/2
2625                 return S.Pi
2626             return 2*S.Pi*(Heaviside(re(y))) - S.Pi
2627         elif x is S.Infinity:
2628             return S.Zero
2629         elif x.is_imaginary and y.is_imaginary and x.is_number and y.is_number:
2630             x = im(x)
2631             y = im(y)
2632 
2633         if x.is_real and y.is_real:
2634             if x.is_positive:
2635                 return atan(y / x)
2636             elif x.is_negative:
2637                 if y.is_negative:
2638                     return atan(y / x) - S.Pi
2639                 elif y.is_nonnegative:
2640                     return atan(y / x) + S.Pi
2641             elif x.is_zero:
2642                 if y.is_positive:
2643                     return S.Pi/2
2644                 elif y.is_negative:
2645                     return -S.Pi/2
2646                 elif y.is_zero:
2647                     return S.NaN
2648         if y.is_zero and x.is_real and fuzzy_not(x.is_zero):
2649             return S.Pi * (S.One - Heaviside(x))
2650         if x.is_number and y.is_number:
2651             return -S.ImaginaryUnit*log(
2652                 (x + S.ImaginaryUnit*y)/sqrt(x**2 + y**2))
2653 
2654     def _eval_rewrite_as_log(self, y, x):
2655         return -S.ImaginaryUnit*log((x + S.ImaginaryUnit*y) / sqrt(x**2 + y**2))
2656 
2657     def _eval_rewrite_as_atan(self, y, x):
2658         return 2*atan(y / (sqrt(x**2 + y**2) + x))
2659 
2660     def _eval_rewrite_as_arg(self, y, x):
2661         from sympy import arg
2662         if x.is_real and y.is_real:
2663             return arg(x + y*S.ImaginaryUnit)
2664         I = S.ImaginaryUnit
2665         n = x + I*y
2666         d = x**2 + y**2
2667         return arg(n/sqrt(d)) - I*log(abs(n)/sqrt(abs(d)))
2668 
2669     def _eval_is_real(self):
2670         return self.args[0].is_real and self.args[1].is_real
2671 
2672     def _eval_conjugate(self):
2673         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
2674 
2675     def fdiff(self, argindex):
2676         y, x = self.args
2677         if argindex == 1:
2678             # Diff wrt y
2679             return x/(x**2 + y**2)
2680         elif argindex == 2:
2681             # Diff wrt x
2682             return -y/(x**2 + y**2)
2683         else:
2684             raise ArgumentIndexError(self, argindex)
2685 
2686     def _eval_evalf(self, prec):
2687         y, x = self.args
2688         if x.is_real and y.is_real:
2689             super(atan2, self)._eval_evalf(prec)

</code><intended_behavior>Although not directly buggy, this file might need a review or update to ensure that the definition and handling of `sinc(x)` within SymPy are conducive to conversion to C code via `ccode`. Specifically, the documentation or meta-information of `sinc(x)` could include hints or properties that `ccode` can utilize to recognize and convert `sinc(x)` expressions more effectively. Enhancing how `sinc(x)` is represented in the context of SymPy's elementary trigonometric functions could aid in its conversion to C code, ensuring a seamless process when such expressions are encountered by `ccode`. If `sinc(x)` is treated specially in terms of symbolic manipulation or simplification, such properties should be documented or coded in a way that `ccode` (or any code-printing routine) can easily translate it into the target language's idioms or library function calls, if available, or into a manually specified piecewise expression otherwise. This may imply refining the symbolic properties of `sinc(x)` to ensure they align with the expectations and capabilities of the code conversion routines.</intended_behavior>]
2025-10-15 12:51:30.184 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 12:51:30.184 | INFO     | Search-only: skipping patch selection
2025-10-15 12:51:30.348 | INFO     | Task sympy__sympy-11400 completed successfully.
2025-10-15 12:51:30.349 | INFO     | No patch generated. You can try running ACR again.
