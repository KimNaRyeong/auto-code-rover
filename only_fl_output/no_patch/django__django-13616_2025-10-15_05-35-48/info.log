2025-10-15 05:35:49.164 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:35:53.657 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=250, output_tokens=12, cost=0.002860
2025-10-15 05:35:53.658 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 05:35:53.661 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:36:02.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=558, output_tokens=308, cost=0.014820
2025-10-15 05:36:02.237 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:36:05.417 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=662, output_tokens=55, cost=0.008270
2025-10-15 05:36:05.418 | DEBUG    | Extracted a valid json.
2025-10-15 05:36:05.419 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"makemessages\")",
        "search_code(\"LOCALE_PATHS\")",
        "search_code(\"Unable to find a locale path to store translations for file\")"
    ],
    "bug_locations": []
}
2025-10-15 05:36:05.479 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:36:05.479 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:36:20.482 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1183, output_tokens=663, cost=0.031720
2025-10-15 05:36:20.495 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:36:30.683 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2062, output_tokens=408, cost=0.032860
2025-10-15 05:36:30.691 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:36:36.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=762, output_tokens=201, cost=0.013650
2025-10-15 05:36:36.196 | DEBUG    | Extracted a valid json.
2025-10-15 05:36:36.196 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/management/commands/makemessages.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should better handle scenarios where the 'locale' directory does not exist by enhancing error handling to suggest creation of a 'locale' directory or updating 'LOCALE_PATHS' settings, and implementing a check or prompt to guide in rectifying the issue."
        },
        {
            "file": "django/utils/translation/trans_real.py",
            "class": "",
            "method": "",
            "intended_behavior": "Adjust to ensure proper handling and fallback for 'LOCALE_PATHS' to include sensible defaults, such as considering a 'locale' directory at the same level as 'manage.py' if not explicitly defined in 'LOCALE_PATHS'. Preserve current functionality while providing flexibility for translation file paths setup or adjustment."
        }
    ]
}
2025-10-15 05:36:36.202 | DEBUG    | Bug location extracted successfully: [<file>django/core/management/commands/makemessages.py</file>
<class>None</class>
<method>None</method>
<code>
1 import glob
2 import os
3 import re
4 import sys
5 from functools import total_ordering
6 from itertools import dropwhile
7 
8 import django
9 from django.conf import settings
10 from django.core.exceptions import ImproperlyConfigured
11 from django.core.files.temp import NamedTemporaryFile
12 from django.core.management.base import BaseCommand, CommandError
13 from django.core.management.utils import (
14     find_command, handle_extensions, is_ignored_path, popen_wrapper,
15 )
16 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
17 from django.utils.functional import cached_property
18 from django.utils.jslex import prepare_js_for_gettext
19 from django.utils.regex_helper import _lazy_re_compile
20 from django.utils.text import get_text_list
21 from django.utils.translation import templatize
22 
23 plural_forms_re = _lazy_re_compile(r'^(?P<value>"Plural-Forms.+?\\n")\s*$', re.MULTILINE | re.DOTALL)
24 STATUS_OK = 0
25 NO_LOCALE_DIR = object()
26 
27 
28 def check_programs(*programs):
29     for program in programs:
30         if find_command(program) is None:
31             raise CommandError(
32                 "Can't find %s. Make sure you have GNU gettext tools 0.15 or "
33                 "newer installed." % program
34             )
35 
36 
37 @total_ordering
38 class TranslatableFile:
39     def __init__(self, dirpath, file_name, locale_dir):
40         self.file = file_name
41         self.dirpath = dirpath
42         self.locale_dir = locale_dir
43 
44     def __repr__(self):
45         return "<%s: %s>" % (
46             self.__class__.__name__,
47             os.sep.join([self.dirpath, self.file]),
48         )
49 
50     def __eq__(self, other):
51         return self.path == other.path
52 
53     def __lt__(self, other):
54         return self.path < other.path
55 
56     @property
57     def path(self):
58         return os.path.join(self.dirpath, self.file)
59 
60 
61 class BuildFile:
62     """
63     Represent the state of a translatable file during the build process.
64     """
65     def __init__(self, command, domain, translatable):
66         self.command = command
67         self.domain = domain
68         self.translatable = translatable
69 
70     @cached_property
71     def is_templatized(self):
72         if self.domain == 'djangojs':
73             return self.command.gettext_version < (0, 18, 3)
74         elif self.domain == 'django':
75             file_ext = os.path.splitext(self.translatable.file)[1]
76             return file_ext != '.py'
77         return False
78 
79     @cached_property
80     def path(self):
81         return self.translatable.path
82 
83     @cached_property
84     def work_path(self):
85         """
86         Path to a file which is being fed into GNU gettext pipeline. This may
87         be either a translatable or its preprocessed version.
88         """
89         if not self.is_templatized:
90             return self.path
91         extension = {
92             'djangojs': 'c',
93             'django': 'py',
94         }.get(self.domain)
95         filename = '%s.%s' % (self.translatable.file, extension)
96         return os.path.join(self.translatable.dirpath, filename)
97 
98     def preprocess(self):
99         """
100         Preprocess (if necessary) a translatable file before passing it to
101         xgettext GNU gettext utility.
102         """
103         if not self.is_templatized:
104             return
105 
106         with open(self.path, encoding='utf-8') as fp:
107             src_data = fp.read()
108 
109         if self.domain == 'djangojs':
110             content = prepare_js_for_gettext(src_data)
111         elif self.domain == 'django':
112             content = templatize(src_data, origin=self.path[2:])
113 
114         with open(self.work_path, 'w', encoding='utf-8') as fp:
115             fp.write(content)
116 
117     def postprocess_messages(self, msgs):
118         """
119         Postprocess messages generated by xgettext GNU gettext utility.
120 
121         Transform paths as if these messages were generated from original
122         translatable files rather than from preprocessed versions.
123         """
124         if not self.is_templatized:
125             return msgs
126 
127         # Remove '.py' suffix
128         if os.name == 'nt':
129             # Preserve '.\' prefix on Windows to respect gettext behavior
130             old_path = self.work_path
131             new_path = self.path
132         else:
133             old_path = self.work_path[2:]
134             new_path = self.path[2:]
135 
136         return re.sub(
137             r'^(#: .*)(' + re.escape(old_path) + r')',
138             lambda match: match[0].replace(old_path, new_path),
139             msgs,
140             flags=re.MULTILINE
141         )
142 
143     def cleanup(self):
144         """
145         Remove a preprocessed copy of a translatable file (if any).
146         """
147         if self.is_templatized:
148             # This check is needed for the case of a symlinked file and its
149             # source being processed inside a single group (locale dir);
150             # removing either of those two removes both.
151             if os.path.exists(self.work_path):
152                 os.unlink(self.work_path)
153 
154 
155 def normalize_eols(raw_contents):
156     """
157     Take a block of raw text that will be passed through str.splitlines() to
158     get universal newlines treatment.
159 
160     Return the resulting block of text with normalized `\n` EOL sequences ready
161     to be written to disk using current platform's native EOLs.
162     """
163     lines_list = raw_contents.splitlines()
164     # Ensure last line has its EOL
165     if lines_list and lines_list[-1]:
166         lines_list.append('')
167     return '\n'.join(lines_list)
168 
169 
170 def write_pot_file(potfile, msgs):
171     """
172     Write the `potfile` with the `msgs` contents, making sure its format is
173     valid.
174     """
175     pot_lines = msgs.splitlines()
176     if os.path.exists(potfile):
177         # Strip the header
178         lines = dropwhile(len, pot_lines)
179     else:
180         lines = []
181         found, header_read = False, False
182         for line in pot_lines:
183             if not found and not header_read:
184                 if 'charset=CHARSET' in line:
185                     found = True
186                     line = line.replace('charset=CHARSET', 'charset=UTF-8')
187             if not line and not found:
188                 header_read = True
189             lines.append(line)
190     msgs = '\n'.join(lines)
191     # Force newlines of POT files to '\n' to work around
192     # https://savannah.gnu.org/bugs/index.php?52395
193     with open(potfile, 'a', encoding='utf-8', newline='\n') as fp:
194         fp.write(msgs)
195 
196 
197 class Command(BaseCommand):
198     help = (
199         "Runs over the entire source tree of the current directory and "
200         "pulls out all strings marked for translation. It creates (or updates) a message "
201         "file in the conf/locale (in the django tree) or locale (for projects and "
202         "applications) directory.\n\nYou must run this command with one of either the "
203         "--locale, --exclude, or --all options."
204     )
205 
206     translatable_file_class = TranslatableFile
207     build_file_class = BuildFile
208 
209     requires_system_checks = []
210 
211     msgmerge_options = ['-q', '--previous']
212     msguniq_options = ['--to-code=utf-8']
213     msgattrib_options = ['--no-obsolete']
214     xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators']
215 
216     def add_arguments(self, parser):
217         parser.add_argument(
218             '--locale', '-l', default=[], action='append',
219             help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '
220                  'Can be used multiple times.',
221         )
222         parser.add_argument(
223             '--exclude', '-x', default=[], action='append',
224             help='Locales to exclude. Default is none. Can be used multiple times.',
225         )
226         parser.add_argument(
227             '--domain', '-d', default='django',
228             help='The domain of the message files (default: "django").',
229         )
230         parser.add_argument(
231             '--all', '-a', action='store_true',
232             help='Updates the message files for all existing locales.',
233         )
234         parser.add_argument(
235             '--extension', '-e', dest='extensions', action='append',
236             help='The file extension(s) to examine (default: "html,txt,py", or "js" '
237                  'if the domain is "djangojs"). Separate multiple extensions with '
238                  'commas, or use -e multiple times.',
239         )
240         parser.add_argument(
241             '--symlinks', '-s', action='store_true',
242             help='Follows symlinks to directories when examining source code '
243                  'and templates for translation strings.',
244         )
245         parser.add_argument(
246             '--ignore', '-i', action='append', dest='ignore_patterns',
247             default=[], metavar='PATTERN',
248             help='Ignore files or directories matching this glob-style pattern. '
249                  'Use multiple times to ignore more.',
250         )
251         parser.add_argument(
252             '--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',
253             help="Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.",
254         )
255         parser.add_argument(
256             '--no-wrap', action='store_true',
257             help="Don't break long message lines into several lines.",
258         )
259         parser.add_argument(
260             '--no-location', action='store_true',
261             help="Don't write '#: filename:line' lines.",
262         )
263         parser.add_argument(
264             '--add-location',
265             choices=('full', 'file', 'never'), const='full', nargs='?',
266             help=(
267                 "Controls '#: filename:line' lines. If the option is 'full' "
268                 "(the default if not given), the lines  include both file name "
269                 "and line number. If it's 'file', the line number is omitted. If "
270                 "it's 'never', the lines are suppressed (same as --no-location). "
271                 "--add-location requires gettext 0.19 or newer."
272             ),
273         )
274         parser.add_argument(
275             '--no-obsolete', action='store_true',
276             help="Remove obsolete message strings.",
277         )
278         parser.add_argument(
279             '--keep-pot', action='store_true',
280             help="Keep .pot file after making messages. Useful when debugging.",
281         )
282 
283     def handle(self, *args, **options):
284         locale = options['locale']
285         exclude = options['exclude']
286         self.domain = options['domain']
287         self.verbosity = options['verbosity']
288         process_all = options['all']
289         extensions = options['extensions']
290         self.symlinks = options['symlinks']
291 
292         ignore_patterns = options['ignore_patterns']
293         if options['use_default_ignore_patterns']:
294             ignore_patterns += ['CVS', '.*', '*~', '*.pyc']
295         self.ignore_patterns = list(set(ignore_patterns))
296 
297         # Avoid messing with mutable class variables
298         if options['no_wrap']:
299             self.msgmerge_options = self.msgmerge_options[:] + ['--no-wrap']
300             self.msguniq_options = self.msguniq_options[:] + ['--no-wrap']
301             self.msgattrib_options = self.msgattrib_options[:] + ['--no-wrap']
302             self.xgettext_options = self.xgettext_options[:] + ['--no-wrap']
303         if options['no_location']:
304             self.msgmerge_options = self.msgmerge_options[:] + ['--no-location']
305             self.msguniq_options = self.msguniq_options[:] + ['--no-location']
306             self.msgattrib_options = self.msgattrib_options[:] + ['--no-location']
307             self.xgettext_options = self.xgettext_options[:] + ['--no-location']
308         if options['add_location']:
309             if self.gettext_version < (0, 19):
310                 raise CommandError(
311                     "The --add-location option requires gettext 0.19 or later. "
312                     "You have %s." % '.'.join(str(x) for x in self.gettext_version)
313                 )
314             arg_add_location = "--add-location=%s" % options['add_location']
315             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]
316             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]
317             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]
318             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]
319 
320         self.no_obsolete = options['no_obsolete']
321         self.keep_pot = options['keep_pot']
322 
323         if self.domain not in ('django', 'djangojs'):
324             raise CommandError("currently makemessages only supports domains "
325                                "'django' and 'djangojs'")
326         if self.domain == 'djangojs':
327             exts = extensions or ['js']
328         else:
329             exts = extensions or ['html', 'txt', 'py']
330         self.extensions = handle_extensions(exts)
331 
332         if (not locale and not exclude and not process_all) or self.domain is None:
333             raise CommandError(
334                 "Type '%s help %s' for usage information."
335                 % (os.path.basename(sys.argv[0]), sys.argv[1])
336             )
337 
338         if self.verbosity > 1:
339             self.stdout.write(
340                 'examining files with the extensions: %s'
341                 % get_text_list(list(self.extensions), 'and')
342             )
343 
344         self.invoked_for_django = False
345         self.locale_paths = []
346         self.default_locale_path = None
347         if os.path.isdir(os.path.join('conf', 'locale')):
348             self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'))]
349             self.default_locale_path = self.locale_paths[0]
350             self.invoked_for_django = True
351         else:
352             if self.settings_available:
353                 self.locale_paths.extend(settings.LOCALE_PATHS)
354             # Allow to run makemessages inside an app dir
355             if os.path.isdir('locale'):
356                 self.locale_paths.append(os.path.abspath('locale'))
357             if self.locale_paths:
358                 self.default_locale_path = self.locale_paths[0]
359                 os.makedirs(self.default_locale_path, exist_ok=True)
360 
361         # Build locale list
362         looks_like_locale = re.compile(r'[a-z]{2}')
363         locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path))
364         all_locales = [
365             lang_code for lang_code in map(os.path.basename, locale_dirs)
366             if looks_like_locale.match(lang_code)
367         ]
368 
369         # Account for excluded locales
370         if process_all:
371             locales = all_locales
372         else:
373             locales = locale or all_locales
374             locales = set(locales).difference(exclude)
375 
376         if locales:
377             check_programs('msguniq', 'msgmerge', 'msgattrib')
378 
379         check_programs('xgettext')
380 
381         try:
382             potfiles = self.build_potfiles()
383 
384             # Build po files for each selected locale
385             for locale in locales:
386                 if '-' in locale:
387                     self.stdout.write(
388                         'invalid locale %s, did you mean %s?' % (
389                             locale,
390                             locale.replace('-', '_'),
391                         ),
392                     )
393                     continue
394                 if self.verbosity > 0:
395                     self.stdout.write('processing locale %s' % locale)
396                 for potfile in potfiles:
397                     self.write_po_file(potfile, locale)
398         finally:
399             if not self.keep_pot:
400                 self.remove_potfiles()
401 
402     @cached_property
403     def gettext_version(self):
404         # Gettext tools will output system-encoded bytestrings instead of UTF-8,
405         # when looking up the version. It's especially a problem on Windows.
406         out, err, status = popen_wrapper(
407             ['xgettext', '--version'],
408             stdout_encoding=DEFAULT_LOCALE_ENCODING,
409         )
410         m = re.search(r'(\d+)\.(\d+)\.?(\d+)?', out)
411         if m:
412             return tuple(int(d) for d in m.groups() if d is not None)
413         else:
414             raise CommandError("Unable to get gettext version. Is it installed?")
415 
416     @cached_property
417     def settings_available(self):
418         try:
419             settings.LOCALE_PATHS
420         except ImproperlyConfigured:
421             if self.verbosity > 1:
422                 self.stderr.write("Running without configured settings.")
423             return False
424         return True
425 
426     def build_potfiles(self):
427         """
428         Build pot files and apply msguniq to them.
429         """
430         file_list = self.find_files(".")
431         self.remove_potfiles()
432         self.process_files(file_list)
433         potfiles = []
434         for path in self.locale_paths:
435             potfile = os.path.join(path, '%s.pot' % self.domain)
436             if not os.path.exists(potfile):
437                 continue
438             args = ['msguniq'] + self.msguniq_options + [potfile]
439             msgs, errors, status = popen_wrapper(args)
440             if errors:
441                 if status != STATUS_OK:
442                     raise CommandError(
443                         "errors happened while running msguniq\n%s" % errors)
444                 elif self.verbosity > 0:
445                     self.stdout.write(errors)
446             msgs = normalize_eols(msgs)
447             with open(potfile, 'w', encoding='utf-8') as fp:
448                 fp.write(msgs)
449             potfiles.append(potfile)
450         return potfiles
451 
452     def remove_potfiles(self):
453         for path in self.locale_paths:
454             pot_path = os.path.join(path, '%s.pot' % self.domain)
455             if os.path.exists(pot_path):
456                 os.unlink(pot_path)
457 
458     def find_files(self, root):
459         """
460         Get all files in the given root. Also check that there is a matching
461         locale dir for each file.
462         """
463         all_files = []
464         ignored_roots = []
465         if self.settings_available:
466             ignored_roots = [os.path.normpath(p) for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT) if p]
467         for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):
468             for dirname in dirnames[:]:
469                 if (is_ignored_path(os.path.normpath(os.path.join(dirpath, dirname)), self.ignore_patterns) or
470                         os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots):
471                     dirnames.remove(dirname)
472                     if self.verbosity > 1:
473                         self.stdout.write('ignoring directory %s' % dirname)
474                 elif dirname == 'locale':
475                     dirnames.remove(dirname)
476                     self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))
477             for filename in filenames:
478                 file_path = os.path.normpath(os.path.join(dirpath, filename))
479                 file_ext = os.path.splitext(filename)[1]
480                 if file_ext not in self.extensions or is_ignored_path(file_path, self.ignore_patterns):
481                     if self.verbosity > 1:
482                         self.stdout.write('ignoring file %s in %s' % (filename, dirpath))
483                 else:
484                     locale_dir = None
485                     for path in self.locale_paths:
486                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
487                             locale_dir = path
488                             break
489                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR
490                     all_files.append(self.translatable_file_class(dirpath, filename, locale_dir))
491         return sorted(all_files)
492 
493     def process_files(self, file_list):
494         """
495         Group translatable files by locale directory and run pot file build
496         process for each group.
497         """
498         file_groups = {}
499         for translatable in file_list:
500             file_group = file_groups.setdefault(translatable.locale_dir, [])
501             file_group.append(translatable)
502         for locale_dir, files in file_groups.items():
503             self.process_locale_dir(locale_dir, files)
504 
505     def process_locale_dir(self, locale_dir, files):
506         """
507         Extract translatable literals from the specified files, creating or
508         updating the POT file for a given locale directory.
509 
510         Use the xgettext GNU gettext utility.
511         """
512         build_files = []
513         for translatable in files:
514             if self.verbosity > 1:
515                 self.stdout.write('processing file %s in %s' % (
516                     translatable.file, translatable.dirpath
517                 ))
518             if self.domain not in ('djangojs', 'django'):
519                 continue
520             build_file = self.build_file_class(self, self.domain, translatable)
521             try:
522                 build_file.preprocess()
523             except UnicodeDecodeError as e:
524                 self.stdout.write(
525                     'UnicodeDecodeError: skipped file %s in %s (reason: %s)' % (
526                         translatable.file, translatable.dirpath, e,
527                     )
528                 )
529                 continue
530             build_files.append(build_file)
531 
532         if self.domain == 'djangojs':
533             is_templatized = build_file.is_templatized
534             args = [
535                 'xgettext',
536                 '-d', self.domain,
537                 '--language=%s' % ('C' if is_templatized else 'JavaScript',),
538                 '--keyword=gettext_noop',
539                 '--keyword=gettext_lazy',
540                 '--keyword=ngettext_lazy:1,2',
541                 '--keyword=pgettext:1c,2',
542                 '--keyword=npgettext:1c,2,3',
543                 '--output=-',
544             ]
545         elif self.domain == 'django':
546             args = [
547                 'xgettext',
548                 '-d', self.domain,
549                 '--language=Python',
550                 '--keyword=gettext_noop',
551                 '--keyword=gettext_lazy',
552                 '--keyword=ngettext_lazy:1,2',
553                 '--keyword=pgettext:1c,2',
554                 '--keyword=npgettext:1c,2,3',
555                 '--keyword=pgettext_lazy:1c,2',
556                 '--keyword=npgettext_lazy:1c,2,3',
557                 '--output=-',
558             ]
559         else:
560             return
561 
562         input_files = [bf.work_path for bf in build_files]
563         with NamedTemporaryFile(mode='w+') as input_files_list:
564             input_files_list.write('\n'.join(input_files))
565             input_files_list.flush()
566             args.extend(['--files-from', input_files_list.name])
567             args.extend(self.xgettext_options)
568             msgs, errors, status = popen_wrapper(args)
569 
570         if errors:
571             if status != STATUS_OK:
572                 for build_file in build_files:
573                     build_file.cleanup()
574                 raise CommandError(
575                     'errors happened while running xgettext on %s\n%s' %
576                     ('\n'.join(input_files), errors)
577                 )
578             elif self.verbosity > 0:
579                 # Print warnings
580                 self.stdout.write(errors)
581 
582         if msgs:
583             if locale_dir is NO_LOCALE_DIR:
584                 file_path = os.path.normpath(build_files[0].path)
585                 raise CommandError(
586                     'Unable to find a locale path to store translations for '
587                     'file %s' % file_path
588                 )
589             for build_file in build_files:
590                 msgs = build_file.postprocess_messages(msgs)
591             potfile = os.path.join(locale_dir, '%s.pot' % self.domain)
592             write_pot_file(potfile, msgs)
593 
594         for build_file in build_files:
595             build_file.cleanup()
596 
597     def write_po_file(self, potfile, locale):
598         """
599         Create or update the PO file for self.domain and `locale`.
600         Use contents of the existing `potfile`.
601 
602         Use msgmerge and msgattrib GNU gettext utilities.
603         """
604         basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')
605         os.makedirs(basedir, exist_ok=True)
606         pofile = os.path.join(basedir, '%s.po' % self.domain)
607 
608         if os.path.exists(pofile):
609             args = ['msgmerge'] + self.msgmerge_options + [pofile, potfile]
610             msgs, errors, status = popen_wrapper(args)
611             if errors:
612                 if status != STATUS_OK:
613                     raise CommandError(
614                         "errors happened while running msgmerge\n%s" % errors)
615                 elif self.verbosity > 0:
616                     self.stdout.write(errors)
617         else:
618             with open(potfile, encoding='utf-8') as fp:
619                 msgs = fp.read()
620             if not self.invoked_for_django:
621                 msgs = self.copy_plural_forms(msgs, locale)
622         msgs = normalize_eols(msgs)
623         msgs = msgs.replace(
624             "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self.domain, "")
625         with open(pofile, 'w', encoding='utf-8') as fp:
626             fp.write(msgs)
627 
628         if self.no_obsolete:
629             args = ['msgattrib'] + self.msgattrib_options + ['-o', pofile, pofile]
630             msgs, errors, status = popen_wrapper(args)
631             if errors:
632                 if status != STATUS_OK:
633                     raise CommandError(
634                         "errors happened while running msgattrib\n%s" % errors)
635                 elif self.verbosity > 0:
636                     self.stdout.write(errors)
637 
638     def copy_plural_forms(self, msgs, locale):
639         """
640         Copy plural forms header contents from a Django catalog of locale to
641         the msgs string, inserting it at the right place. msgs should be the
642         contents of a newly created .po file.
643         """
644         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))
645         if self.domain == 'djangojs':
646             domains = ('djangojs', 'django')
647         else:
648             domains = ('django',)
649         for domain in domains:
650             django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)
651             if os.path.exists(django_po):
652                 with open(django_po, encoding='utf-8') as fp:
653                     m = plural_forms_re.search(fp.read())
654                 if m:
655                     plural_form_line = m['value']
656                     if self.verbosity > 1:
657                         self.stdout.write('copying plural forms: %s' % plural_form_line)
658                     lines = []
659                     found = False
660                     for line in msgs.splitlines():
661                         if not found and (not line or plural_forms_re.search(line)):
662                             line = plural_form_line
663                             found = True
664                         lines.append(line)
665                     msgs = '\n'.join(lines)
666                     break
667         return msgs

</code><intended_behavior>This file should better handle scenarios where the 'locale' directory does not exist by enhancing error handling to suggest creation of a 'locale' directory or updating 'LOCALE_PATHS' settings, and implementing a check or prompt to guide in rectifying the issue.</intended_behavior>, <file>django/utils/translation/trans_real.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Translation helper functions."""
2 import functools
3 import gettext as gettext_module
4 import os
5 import re
6 import sys
7 import warnings
8 
9 from asgiref.local import Local
10 
11 from django.apps import apps
12 from django.conf import settings
13 from django.conf.locale import LANG_INFO
14 from django.core.exceptions import AppRegistryNotReady
15 from django.core.signals import setting_changed
16 from django.dispatch import receiver
17 from django.utils.regex_helper import _lazy_re_compile
18 from django.utils.safestring import SafeData, mark_safe
19 
20 from . import to_language, to_locale
21 
22 # Translations are cached in a dictionary for every language.
23 # The active translations are stored by threadid to make them thread local.
24 _translations = {}
25 _active = Local()
26 
27 # The default translation is based on the settings file.
28 _default = None
29 
30 # magic gettext number to separate context from message
31 CONTEXT_SEPARATOR = "\x04"
32 
33 # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9
34 # and RFC 3066, section 2.1
35 accept_language_re = _lazy_re_compile(r'''
36         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"
37         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:\.0{,3})?))?  # Optional "q=1.00", "q=0.8"
38         (?:\s*,\s*|$)                                 # Multiple accepts per header.
39         ''', re.VERBOSE)
40 
41 language_code_re = _lazy_re_compile(
42     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',
43     re.IGNORECASE
44 )
45 
46 language_code_prefix_re = _lazy_re_compile(r'^/(\w+([@-]\w+)?)(/|$)')
47 
48 
49 @receiver(setting_changed)
50 def reset_cache(**kwargs):
51     """
52     Reset global state when LANGUAGES setting has been changed, as some
53     languages should no longer be accepted.
54     """
55     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):
56         check_for_language.cache_clear()
57         get_languages.cache_clear()
58         get_supported_language_variant.cache_clear()
59 
60 
61 class TranslationCatalog:
62     """
63     Simulate a dict for DjangoTranslation._catalog so as multiple catalogs
64     with different plural equations are kept separate.
65     """
66     def __init__(self, trans=None):
67         self._catalogs = [trans._catalog.copy()] if trans else [{}]
68         self._plurals = [trans.plural] if trans else [lambda n: int(n != 1)]
69 
70     def __getitem__(self, key):
71         for cat in self._catalogs:
72             try:
73                 return cat[key]
74             except KeyError:
75                 pass
76         raise KeyError(key)
77 
78     def __setitem__(self, key, value):
79         self._catalogs[0][key] = value
80 
81     def __contains__(self, key):
82         return any(key in cat for cat in self._catalogs)
83 
84     def items(self):
85         for cat in self._catalogs:
86             yield from cat.items()
87 
88     def keys(self):
89         for cat in self._catalogs:
90             yield from cat.keys()
91 
92     def update(self, trans):
93         # Merge if plural function is the same, else prepend.
94         for cat, plural in zip(self._catalogs, self._plurals):
95             if trans.plural.__code__ == plural.__code__:
96                 cat.update(trans._catalog)
97                 break
98         else:
99             self._catalogs.insert(0, trans._catalog.copy())
100             self._plurals.insert(0, trans.plural)
101 
102     def get(self, key, default=None):
103         missing = object()
104         for cat in self._catalogs:
105             result = cat.get(key, missing)
106             if result is not missing:
107                 return result
108         return default
109 
110     def plural(self, msgid, num):
111         for cat, plural in zip(self._catalogs, self._plurals):
112             tmsg = cat.get((msgid, plural(num)))
113             if tmsg is not None:
114                 return tmsg
115         raise KeyError
116 
117 
118 class DjangoTranslation(gettext_module.GNUTranslations):
119     """
120     Set up the GNUTranslations context with regard to output charset.
121 
122     This translation object will be constructed out of multiple GNUTranslations
123     objects by merging their catalogs. It will construct an object for the
124     requested language and add a fallback to the default language, if it's
125     different from the requested language.
126     """
127     domain = 'django'
128 
129     def __init__(self, language, domain=None, localedirs=None):
130         """Create a GNUTranslations() using many locale directories"""
131         gettext_module.GNUTranslations.__init__(self)
132         if domain is not None:
133             self.domain = domain
134 
135         self.__language = language
136         self.__to_language = to_language(language)
137         self.__locale = to_locale(language)
138         self._catalog = None
139         # If a language doesn't have a catalog, use the Germanic default for
140         # pluralization: anything except one is pluralized.
141         self.plural = lambda n: int(n != 1)
142 
143         if self.domain == 'django':
144             if localedirs is not None:
145                 # A module-level cache is used for caching 'django' translations
146                 warnings.warn("localedirs is ignored when domain is 'django'.", RuntimeWarning)
147                 localedirs = None
148             self._init_translation_catalog()
149 
150         if localedirs:
151             for localedir in localedirs:
152                 translation = self._new_gnu_trans(localedir)
153                 self.merge(translation)
154         else:
155             self._add_installed_apps_translations()
156 
157         self._add_local_translations()
158         if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and self._catalog is None:
159             # default lang should have at least one translation file available.
160             raise OSError('No translation files found for default language %s.' % settings.LANGUAGE_CODE)
161         self._add_fallback(localedirs)
162         if self._catalog is None:
163             # No catalogs found for this language, set an empty catalog.
164             self._catalog = TranslationCatalog()
165 
166     def __repr__(self):
167         return "<DjangoTranslation lang:%s>" % self.__language
168 
169     def _new_gnu_trans(self, localedir, use_null_fallback=True):
170         """
171         Return a mergeable gettext.GNUTranslations instance.
172 
173         A convenience wrapper. By default gettext uses 'fallback=False'.
174         Using param `use_null_fallback` to avoid confusion with any other
175         references to 'fallback'.
176         """
177         return gettext_module.translation(
178             domain=self.domain,
179             localedir=localedir,
180             languages=[self.__locale],
181             fallback=use_null_fallback,
182         )
183 
184     def _init_translation_catalog(self):
185         """Create a base catalog using global django translations."""
186         settingsfile = sys.modules[settings.__module__].__file__
187         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')
188         translation = self._new_gnu_trans(localedir)
189         self.merge(translation)
190 
191     def _add_installed_apps_translations(self):
192         """Merge translations from each installed app."""
193         try:
194             app_configs = reversed(list(apps.get_app_configs()))
195         except AppRegistryNotReady:
196             raise AppRegistryNotReady(
197                 "The translation infrastructure cannot be initialized before the "
198                 "apps registry is ready. Check that you don't make non-lazy "
199                 "gettext calls at import time.")
200         for app_config in app_configs:
201             localedir = os.path.join(app_config.path, 'locale')
202             if os.path.exists(localedir):
203                 translation = self._new_gnu_trans(localedir)
204                 self.merge(translation)
205 
206     def _add_local_translations(self):
207         """Merge translations defined in LOCALE_PATHS."""
208         for localedir in reversed(settings.LOCALE_PATHS):
209             translation = self._new_gnu_trans(localedir)
210             self.merge(translation)
211 
212     def _add_fallback(self, localedirs=None):
213         """Set the GNUTranslations() fallback with the default language."""
214         # Don't set a fallback for the default language or any English variant
215         # (as it's empty, so it'll ALWAYS fall back to the default language)
216         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):
217             return
218         if self.domain == 'django':
219             # Get from cache
220             default_translation = translation(settings.LANGUAGE_CODE)
221         else:
222             default_translation = DjangoTranslation(
223                 settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs
224             )
225         self.add_fallback(default_translation)
226 
227     def merge(self, other):
228         """Merge another translation into this catalog."""
229         if not getattr(other, '_catalog', None):
230             return  # NullTranslations() has no _catalog
231         if self._catalog is None:
232             # Take plural and _info from first catalog found (generally Django's).
233             self.plural = other.plural
234             self._info = other._info.copy()
235             self._catalog = TranslationCatalog(other)
236         else:
237             self._catalog.update(other)
238         if other._fallback:
239             self.add_fallback(other._fallback)
240 
241     def language(self):
242         """Return the translation language."""
243         return self.__language
244 
245     def to_language(self):
246         """Return the translation language name."""
247         return self.__to_language
248 
249     def ngettext(self, msgid1, msgid2, n):
250         try:
251             tmsg = self._catalog.plural(msgid1, n)
252         except KeyError:
253             if self._fallback:
254                 return self._fallback.ngettext(msgid1, msgid2, n)
255             if n == 1:
256                 tmsg = msgid1
257             else:
258                 tmsg = msgid2
259         return tmsg
260 
261 
262 def translation(language):
263     """
264     Return a translation object in the default 'django' domain.
265     """
266     global _translations
267     if language not in _translations:
268         _translations[language] = DjangoTranslation(language)
269     return _translations[language]
270 
271 
272 def activate(language):
273     """
274     Fetch the translation object for a given language and install it as the
275     current translation object for the current thread.
276     """
277     if not language:
278         return
279     _active.value = translation(language)
280 
281 
282 def deactivate():
283     """
284     Uninstall the active translation object so that further _() calls resolve
285     to the default translation object.
286     """
287     if hasattr(_active, "value"):
288         del _active.value
289 
290 
291 def deactivate_all():
292     """
293     Make the active translation object a NullTranslations() instance. This is
294     useful when we want delayed translations to appear as the original string
295     for some reason.
296     """
297     _active.value = gettext_module.NullTranslations()
298     _active.value.to_language = lambda *args: None
299 
300 
301 def get_language():
302     """Return the currently selected language."""
303     t = getattr(_active, "value", None)
304     if t is not None:
305         try:
306             return t.to_language()
307         except AttributeError:
308             pass
309     # If we don't have a real translation object, assume it's the default language.
310     return settings.LANGUAGE_CODE
311 
312 
313 def get_language_bidi():
314     """
315     Return selected language's BiDi layout.
316 
317     * False = left-to-right layout
318     * True = right-to-left layout
319     """
320     lang = get_language()
321     if lang is None:
322         return False
323     else:
324         base_lang = get_language().split('-')[0]
325         return base_lang in settings.LANGUAGES_BIDI
326 
327 
328 def catalog():
329     """
330     Return the current active catalog for further processing.
331     This can be used if you need to modify the catalog or want to access the
332     whole message catalog instead of just translating one string.
333     """
334     global _default
335 
336     t = getattr(_active, "value", None)
337     if t is not None:
338         return t
339     if _default is None:
340         _default = translation(settings.LANGUAGE_CODE)
341     return _default
342 
343 
344 def gettext(message):
345     """
346     Translate the 'message' string. It uses the current thread to find the
347     translation object to use. If no current translation is activated, the
348     message will be run through the default translation object.
349     """
350     global _default
351 
352     eol_message = message.replace('\r\n', '\n').replace('\r', '\n')
353 
354     if eol_message:
355         _default = _default or translation(settings.LANGUAGE_CODE)
356         translation_object = getattr(_active, "value", _default)
357 
358         result = translation_object.gettext(eol_message)
359     else:
360         # Return an empty value of the corresponding type if an empty message
361         # is given, instead of metadata, which is the default gettext behavior.
362         result = type(message)('')
363 
364     if isinstance(message, SafeData):
365         return mark_safe(result)
366 
367     return result
368 
369 
370 def pgettext(context, message):
371     msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
372     result = gettext(msg_with_ctxt)
373     if CONTEXT_SEPARATOR in result:
374         # Translation not found
375         result = message
376     elif isinstance(message, SafeData):
377         result = mark_safe(result)
378     return result
379 
380 
381 def gettext_noop(message):
382     """
383     Mark strings for translation but don't translate them now. This can be
384     used to store strings in global variables that should stay in the base
385     language (because they might be used externally) and will be translated
386     later.
387     """
388     return message
389 
390 
391 def do_ntranslate(singular, plural, number, translation_function):
392     global _default
393 
394     t = getattr(_active, "value", None)
395     if t is not None:
396         return getattr(t, translation_function)(singular, plural, number)
397     if _default is None:
398         _default = translation(settings.LANGUAGE_CODE)
399     return getattr(_default, translation_function)(singular, plural, number)
400 
401 
402 def ngettext(singular, plural, number):
403     """
404     Return a string of the translation of either the singular or plural,
405     based on the number.
406     """
407     return do_ntranslate(singular, plural, number, 'ngettext')
408 
409 
410 def npgettext(context, singular, plural, number):
411     msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, singular),
412                       "%s%s%s" % (context, CONTEXT_SEPARATOR, plural),
413                       number)
414     result = ngettext(*msgs_with_ctxt)
415     if CONTEXT_SEPARATOR in result:
416         # Translation not found
417         result = ngettext(singular, plural, number)
418     return result
419 
420 
421 def all_locale_paths():
422     """
423     Return a list of paths to user-provides languages files.
424     """
425     globalpath = os.path.join(
426         os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')
427     app_paths = []
428     for app_config in apps.get_app_configs():
429         locale_path = os.path.join(app_config.path, 'locale')
430         if os.path.exists(locale_path):
431             app_paths.append(locale_path)
432     return [globalpath, *settings.LOCALE_PATHS, *app_paths]
433 
434 
435 @functools.lru_cache(maxsize=1000)
436 def check_for_language(lang_code):
437     """
438     Check whether there is a global language file for the given language
439     code. This is used to decide whether a user-provided language is
440     available.
441 
442     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
443     as the provided language codes are taken from the HTTP request. See also
444     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
445     """
446     # First, a quick check to make sure lang_code is well-formed (#21458)
447     if lang_code is None or not language_code_re.search(lang_code):
448         return False
449     return any(
450         gettext_module.find('django', path, [to_locale(lang_code)]) is not None
451         for path in all_locale_paths()
452     )
453 
454 
455 @functools.lru_cache()
456 def get_languages():
457     """
458     Cache of settings.LANGUAGES in a dictionary for easy lookups by key.
459     """
460     return dict(settings.LANGUAGES)
461 
462 
463 @functools.lru_cache(maxsize=1000)
464 def get_supported_language_variant(lang_code, strict=False):
465     """
466     Return the language code that's listed in supported languages, possibly
467     selecting a more generic variant. Raise LookupError if nothing is found.
468 
469     If `strict` is False (the default), look for a country-specific variant
470     when neither the language code nor its generic variant is found.
471 
472     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
473     as the provided language codes are taken from the HTTP request. See also
474     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
475     """
476     if lang_code:
477         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.
478         possible_lang_codes = [lang_code]
479         try:
480             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])
481         except KeyError:
482             pass
483         generic_lang_code = lang_code.split('-')[0]
484         possible_lang_codes.append(generic_lang_code)
485         supported_lang_codes = get_languages()
486 
487         for code in possible_lang_codes:
488             if code in supported_lang_codes and check_for_language(code):
489                 return code
490         if not strict:
491             # if fr-fr is not supported, try fr-ca.
492             for supported_code in supported_lang_codes:
493                 if supported_code.startswith(generic_lang_code + '-'):
494                     return supported_code
495     raise LookupError(lang_code)
496 
497 
498 def get_language_from_path(path, strict=False):
499     """
500     Return the language code if there's a valid language code found in `path`.
501 
502     If `strict` is False (the default), look for a country-specific variant
503     when neither the language code nor its generic variant is found.
504     """
505     regex_match = language_code_prefix_re.match(path)
506     if not regex_match:
507         return None
508     lang_code = regex_match[1]
509     try:
510         return get_supported_language_variant(lang_code, strict=strict)
511     except LookupError:
512         return None
513 
514 
515 def get_language_from_request(request, check_path=False):
516     """
517     Analyze the request to find what language the user wants the system to
518     show. Only languages listed in settings.LANGUAGES are taken into account.
519     If the user requests a sublanguage where we have a main language, we send
520     out the main language.
521 
522     If check_path is True, the URL path prefix will be checked for a language
523     code, otherwise this is skipped for backwards compatibility.
524     """
525     if check_path:
526         lang_code = get_language_from_path(request.path_info)
527         if lang_code is not None:
528             return lang_code
529 
530     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)
531     if lang_code is not None and lang_code in get_languages() and check_for_language(lang_code):
532         return lang_code
533 
534     try:
535         return get_supported_language_variant(lang_code)
536     except LookupError:
537         pass
538 
539     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
540     for accept_lang, unused in parse_accept_lang_header(accept):
541         if accept_lang == '*':
542             break
543 
544         if not language_code_re.search(accept_lang):
545             continue
546 
547         try:
548             return get_supported_language_variant(accept_lang)
549         except LookupError:
550             continue
551 
552     try:
553         return get_supported_language_variant(settings.LANGUAGE_CODE)
554     except LookupError:
555         return settings.LANGUAGE_CODE
556 
557 
558 @functools.lru_cache(maxsize=1000)
559 def parse_accept_lang_header(lang_string):
560     """
561     Parse the lang_string, which is the body of an HTTP Accept-Language
562     header, and return a tuple of (lang, q-value), ordered by 'q' values.
563 
564     Return an empty tuple if there are any format errors in lang_string.
565     """
566     result = []
567     pieces = accept_language_re.split(lang_string.lower())
568     if pieces[-1]:
569         return ()
570     for i in range(0, len(pieces) - 1, 3):
571         first, lang, priority = pieces[i:i + 3]
572         if first:
573             return ()
574         if priority:
575             priority = float(priority)
576         else:
577             priority = 1.0
578         result.append((lang, priority))
579     result.sort(key=lambda k: k[1], reverse=True)
580     return tuple(result)

</code><intended_behavior>Adjust to ensure proper handling and fallback for 'LOCALE_PATHS' to include sensible defaults, such as considering a 'locale' directory at the same level as 'manage.py' if not explicitly defined in 'LOCALE_PATHS'. Preserve current functionality while providing flexibility for translation file paths setup or adjustment.</intended_behavior>]
2025-10-15 05:36:36.202 | INFO     | Search completed. Bug locations: [<file>django/core/management/commands/makemessages.py</file>
<class>None</class>
<method>None</method>
<code>
1 import glob
2 import os
3 import re
4 import sys
5 from functools import total_ordering
6 from itertools import dropwhile
7 
8 import django
9 from django.conf import settings
10 from django.core.exceptions import ImproperlyConfigured
11 from django.core.files.temp import NamedTemporaryFile
12 from django.core.management.base import BaseCommand, CommandError
13 from django.core.management.utils import (
14     find_command, handle_extensions, is_ignored_path, popen_wrapper,
15 )
16 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
17 from django.utils.functional import cached_property
18 from django.utils.jslex import prepare_js_for_gettext
19 from django.utils.regex_helper import _lazy_re_compile
20 from django.utils.text import get_text_list
21 from django.utils.translation import templatize
22 
23 plural_forms_re = _lazy_re_compile(r'^(?P<value>"Plural-Forms.+?\\n")\s*$', re.MULTILINE | re.DOTALL)
24 STATUS_OK = 0
25 NO_LOCALE_DIR = object()
26 
27 
28 def check_programs(*programs):
29     for program in programs:
30         if find_command(program) is None:
31             raise CommandError(
32                 "Can't find %s. Make sure you have GNU gettext tools 0.15 or "
33                 "newer installed." % program
34             )
35 
36 
37 @total_ordering
38 class TranslatableFile:
39     def __init__(self, dirpath, file_name, locale_dir):
40         self.file = file_name
41         self.dirpath = dirpath
42         self.locale_dir = locale_dir
43 
44     def __repr__(self):
45         return "<%s: %s>" % (
46             self.__class__.__name__,
47             os.sep.join([self.dirpath, self.file]),
48         )
49 
50     def __eq__(self, other):
51         return self.path == other.path
52 
53     def __lt__(self, other):
54         return self.path < other.path
55 
56     @property
57     def path(self):
58         return os.path.join(self.dirpath, self.file)
59 
60 
61 class BuildFile:
62     """
63     Represent the state of a translatable file during the build process.
64     """
65     def __init__(self, command, domain, translatable):
66         self.command = command
67         self.domain = domain
68         self.translatable = translatable
69 
70     @cached_property
71     def is_templatized(self):
72         if self.domain == 'djangojs':
73             return self.command.gettext_version < (0, 18, 3)
74         elif self.domain == 'django':
75             file_ext = os.path.splitext(self.translatable.file)[1]
76             return file_ext != '.py'
77         return False
78 
79     @cached_property
80     def path(self):
81         return self.translatable.path
82 
83     @cached_property
84     def work_path(self):
85         """
86         Path to a file which is being fed into GNU gettext pipeline. This may
87         be either a translatable or its preprocessed version.
88         """
89         if not self.is_templatized:
90             return self.path
91         extension = {
92             'djangojs': 'c',
93             'django': 'py',
94         }.get(self.domain)
95         filename = '%s.%s' % (self.translatable.file, extension)
96         return os.path.join(self.translatable.dirpath, filename)
97 
98     def preprocess(self):
99         """
100         Preprocess (if necessary) a translatable file before passing it to
101         xgettext GNU gettext utility.
102         """
103         if not self.is_templatized:
104             return
105 
106         with open(self.path, encoding='utf-8') as fp:
107             src_data = fp.read()
108 
109         if self.domain == 'djangojs':
110             content = prepare_js_for_gettext(src_data)
111         elif self.domain == 'django':
112             content = templatize(src_data, origin=self.path[2:])
113 
114         with open(self.work_path, 'w', encoding='utf-8') as fp:
115             fp.write(content)
116 
117     def postprocess_messages(self, msgs):
118         """
119         Postprocess messages generated by xgettext GNU gettext utility.
120 
121         Transform paths as if these messages were generated from original
122         translatable files rather than from preprocessed versions.
123         """
124         if not self.is_templatized:
125             return msgs
126 
127         # Remove '.py' suffix
128         if os.name == 'nt':
129             # Preserve '.\' prefix on Windows to respect gettext behavior
130             old_path = self.work_path
131             new_path = self.path
132         else:
133             old_path = self.work_path[2:]
134             new_path = self.path[2:]
135 
136         return re.sub(
137             r'^(#: .*)(' + re.escape(old_path) + r')',
138             lambda match: match[0].replace(old_path, new_path),
139             msgs,
140             flags=re.MULTILINE
141         )
142 
143     def cleanup(self):
144         """
145         Remove a preprocessed copy of a translatable file (if any).
146         """
147         if self.is_templatized:
148             # This check is needed for the case of a symlinked file and its
149             # source being processed inside a single group (locale dir);
150             # removing either of those two removes both.
151             if os.path.exists(self.work_path):
152                 os.unlink(self.work_path)
153 
154 
155 def normalize_eols(raw_contents):
156     """
157     Take a block of raw text that will be passed through str.splitlines() to
158     get universal newlines treatment.
159 
160     Return the resulting block of text with normalized `\n` EOL sequences ready
161     to be written to disk using current platform's native EOLs.
162     """
163     lines_list = raw_contents.splitlines()
164     # Ensure last line has its EOL
165     if lines_list and lines_list[-1]:
166         lines_list.append('')
167     return '\n'.join(lines_list)
168 
169 
170 def write_pot_file(potfile, msgs):
171     """
172     Write the `potfile` with the `msgs` contents, making sure its format is
173     valid.
174     """
175     pot_lines = msgs.splitlines()
176     if os.path.exists(potfile):
177         # Strip the header
178         lines = dropwhile(len, pot_lines)
179     else:
180         lines = []
181         found, header_read = False, False
182         for line in pot_lines:
183             if not found and not header_read:
184                 if 'charset=CHARSET' in line:
185                     found = True
186                     line = line.replace('charset=CHARSET', 'charset=UTF-8')
187             if not line and not found:
188                 header_read = True
189             lines.append(line)
190     msgs = '\n'.join(lines)
191     # Force newlines of POT files to '\n' to work around
192     # https://savannah.gnu.org/bugs/index.php?52395
193     with open(potfile, 'a', encoding='utf-8', newline='\n') as fp:
194         fp.write(msgs)
195 
196 
197 class Command(BaseCommand):
198     help = (
199         "Runs over the entire source tree of the current directory and "
200         "pulls out all strings marked for translation. It creates (or updates) a message "
201         "file in the conf/locale (in the django tree) or locale (for projects and "
202         "applications) directory.\n\nYou must run this command with one of either the "
203         "--locale, --exclude, or --all options."
204     )
205 
206     translatable_file_class = TranslatableFile
207     build_file_class = BuildFile
208 
209     requires_system_checks = []
210 
211     msgmerge_options = ['-q', '--previous']
212     msguniq_options = ['--to-code=utf-8']
213     msgattrib_options = ['--no-obsolete']
214     xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators']
215 
216     def add_arguments(self, parser):
217         parser.add_argument(
218             '--locale', '-l', default=[], action='append',
219             help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '
220                  'Can be used multiple times.',
221         )
222         parser.add_argument(
223             '--exclude', '-x', default=[], action='append',
224             help='Locales to exclude. Default is none. Can be used multiple times.',
225         )
226         parser.add_argument(
227             '--domain', '-d', default='django',
228             help='The domain of the message files (default: "django").',
229         )
230         parser.add_argument(
231             '--all', '-a', action='store_true',
232             help='Updates the message files for all existing locales.',
233         )
234         parser.add_argument(
235             '--extension', '-e', dest='extensions', action='append',
236             help='The file extension(s) to examine (default: "html,txt,py", or "js" '
237                  'if the domain is "djangojs"). Separate multiple extensions with '
238                  'commas, or use -e multiple times.',
239         )
240         parser.add_argument(
241             '--symlinks', '-s', action='store_true',
242             help='Follows symlinks to directories when examining source code '
243                  'and templates for translation strings.',
244         )
245         parser.add_argument(
246             '--ignore', '-i', action='append', dest='ignore_patterns',
247             default=[], metavar='PATTERN',
248             help='Ignore files or directories matching this glob-style pattern. '
249                  'Use multiple times to ignore more.',
250         )
251         parser.add_argument(
252             '--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',
253             help="Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.",
254         )
255         parser.add_argument(
256             '--no-wrap', action='store_true',
257             help="Don't break long message lines into several lines.",
258         )
259         parser.add_argument(
260             '--no-location', action='store_true',
261             help="Don't write '#: filename:line' lines.",
262         )
263         parser.add_argument(
264             '--add-location',
265             choices=('full', 'file', 'never'), const='full', nargs='?',
266             help=(
267                 "Controls '#: filename:line' lines. If the option is 'full' "
268                 "(the default if not given), the lines  include both file name "
269                 "and line number. If it's 'file', the line number is omitted. If "
270                 "it's 'never', the lines are suppressed (same as --no-location). "
271                 "--add-location requires gettext 0.19 or newer."
272             ),
273         )
274         parser.add_argument(
275             '--no-obsolete', action='store_true',
276             help="Remove obsolete message strings.",
277         )
278         parser.add_argument(
279             '--keep-pot', action='store_true',
280             help="Keep .pot file after making messages. Useful when debugging.",
281         )
282 
283     def handle(self, *args, **options):
284         locale = options['locale']
285         exclude = options['exclude']
286         self.domain = options['domain']
287         self.verbosity = options['verbosity']
288         process_all = options['all']
289         extensions = options['extensions']
290         self.symlinks = options['symlinks']
291 
292         ignore_patterns = options['ignore_patterns']
293         if options['use_default_ignore_patterns']:
294             ignore_patterns += ['CVS', '.*', '*~', '*.pyc']
295         self.ignore_patterns = list(set(ignore_patterns))
296 
297         # Avoid messing with mutable class variables
298         if options['no_wrap']:
299             self.msgmerge_options = self.msgmerge_options[:] + ['--no-wrap']
300             self.msguniq_options = self.msguniq_options[:] + ['--no-wrap']
301             self.msgattrib_options = self.msgattrib_options[:] + ['--no-wrap']
302             self.xgettext_options = self.xgettext_options[:] + ['--no-wrap']
303         if options['no_location']:
304             self.msgmerge_options = self.msgmerge_options[:] + ['--no-location']
305             self.msguniq_options = self.msguniq_options[:] + ['--no-location']
306             self.msgattrib_options = self.msgattrib_options[:] + ['--no-location']
307             self.xgettext_options = self.xgettext_options[:] + ['--no-location']
308         if options['add_location']:
309             if self.gettext_version < (0, 19):
310                 raise CommandError(
311                     "The --add-location option requires gettext 0.19 or later. "
312                     "You have %s." % '.'.join(str(x) for x in self.gettext_version)
313                 )
314             arg_add_location = "--add-location=%s" % options['add_location']
315             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]
316             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]
317             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]
318             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]
319 
320         self.no_obsolete = options['no_obsolete']
321         self.keep_pot = options['keep_pot']
322 
323         if self.domain not in ('django', 'djangojs'):
324             raise CommandError("currently makemessages only supports domains "
325                                "'django' and 'djangojs'")
326         if self.domain == 'djangojs':
327             exts = extensions or ['js']
328         else:
329             exts = extensions or ['html', 'txt', 'py']
330         self.extensions = handle_extensions(exts)
331 
332         if (not locale and not exclude and not process_all) or self.domain is None:
333             raise CommandError(
334                 "Type '%s help %s' for usage information."
335                 % (os.path.basename(sys.argv[0]), sys.argv[1])
336             )
337 
338         if self.verbosity > 1:
339             self.stdout.write(
340                 'examining files with the extensions: %s'
341                 % get_text_list(list(self.extensions), 'and')
342             )
343 
344         self.invoked_for_django = False
345         self.locale_paths = []
346         self.default_locale_path = None
347         if os.path.isdir(os.path.join('conf', 'locale')):
348             self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'))]
349             self.default_locale_path = self.locale_paths[0]
350             self.invoked_for_django = True
351         else:
352             if self.settings_available:
353                 self.locale_paths.extend(settings.LOCALE_PATHS)
354             # Allow to run makemessages inside an app dir
355             if os.path.isdir('locale'):
356                 self.locale_paths.append(os.path.abspath('locale'))
357             if self.locale_paths:
358                 self.default_locale_path = self.locale_paths[0]
359                 os.makedirs(self.default_locale_path, exist_ok=True)
360 
361         # Build locale list
362         looks_like_locale = re.compile(r'[a-z]{2}')
363         locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path))
364         all_locales = [
365             lang_code for lang_code in map(os.path.basename, locale_dirs)
366             if looks_like_locale.match(lang_code)
367         ]
368 
369         # Account for excluded locales
370         if process_all:
371             locales = all_locales
372         else:
373             locales = locale or all_locales
374             locales = set(locales).difference(exclude)
375 
376         if locales:
377             check_programs('msguniq', 'msgmerge', 'msgattrib')
378 
379         check_programs('xgettext')
380 
381         try:
382             potfiles = self.build_potfiles()
383 
384             # Build po files for each selected locale
385             for locale in locales:
386                 if '-' in locale:
387                     self.stdout.write(
388                         'invalid locale %s, did you mean %s?' % (
389                             locale,
390                             locale.replace('-', '_'),
391                         ),
392                     )
393                     continue
394                 if self.verbosity > 0:
395                     self.stdout.write('processing locale %s' % locale)
396                 for potfile in potfiles:
397                     self.write_po_file(potfile, locale)
398         finally:
399             if not self.keep_pot:
400                 self.remove_potfiles()
401 
402     @cached_property
403     def gettext_version(self):
404         # Gettext tools will output system-encoded bytestrings instead of UTF-8,
405         # when looking up the version. It's especially a problem on Windows.
406         out, err, status = popen_wrapper(
407             ['xgettext', '--version'],
408             stdout_encoding=DEFAULT_LOCALE_ENCODING,
409         )
410         m = re.search(r'(\d+)\.(\d+)\.?(\d+)?', out)
411         if m:
412             return tuple(int(d) for d in m.groups() if d is not None)
413         else:
414             raise CommandError("Unable to get gettext version. Is it installed?")
415 
416     @cached_property
417     def settings_available(self):
418         try:
419             settings.LOCALE_PATHS
420         except ImproperlyConfigured:
421             if self.verbosity > 1:
422                 self.stderr.write("Running without configured settings.")
423             return False
424         return True
425 
426     def build_potfiles(self):
427         """
428         Build pot files and apply msguniq to them.
429         """
430         file_list = self.find_files(".")
431         self.remove_potfiles()
432         self.process_files(file_list)
433         potfiles = []
434         for path in self.locale_paths:
435             potfile = os.path.join(path, '%s.pot' % self.domain)
436             if not os.path.exists(potfile):
437                 continue
438             args = ['msguniq'] + self.msguniq_options + [potfile]
439             msgs, errors, status = popen_wrapper(args)
440             if errors:
441                 if status != STATUS_OK:
442                     raise CommandError(
443                         "errors happened while running msguniq\n%s" % errors)
444                 elif self.verbosity > 0:
445                     self.stdout.write(errors)
446             msgs = normalize_eols(msgs)
447             with open(potfile, 'w', encoding='utf-8') as fp:
448                 fp.write(msgs)
449             potfiles.append(potfile)
450         return potfiles
451 
452     def remove_potfiles(self):
453         for path in self.locale_paths:
454             pot_path = os.path.join(path, '%s.pot' % self.domain)
455             if os.path.exists(pot_path):
456                 os.unlink(pot_path)
457 
458     def find_files(self, root):
459         """
460         Get all files in the given root. Also check that there is a matching
461         locale dir for each file.
462         """
463         all_files = []
464         ignored_roots = []
465         if self.settings_available:
466             ignored_roots = [os.path.normpath(p) for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT) if p]
467         for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):
468             for dirname in dirnames[:]:
469                 if (is_ignored_path(os.path.normpath(os.path.join(dirpath, dirname)), self.ignore_patterns) or
470                         os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots):
471                     dirnames.remove(dirname)
472                     if self.verbosity > 1:
473                         self.stdout.write('ignoring directory %s' % dirname)
474                 elif dirname == 'locale':
475                     dirnames.remove(dirname)
476                     self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))
477             for filename in filenames:
478                 file_path = os.path.normpath(os.path.join(dirpath, filename))
479                 file_ext = os.path.splitext(filename)[1]
480                 if file_ext not in self.extensions or is_ignored_path(file_path, self.ignore_patterns):
481                     if self.verbosity > 1:
482                         self.stdout.write('ignoring file %s in %s' % (filename, dirpath))
483                 else:
484                     locale_dir = None
485                     for path in self.locale_paths:
486                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
487                             locale_dir = path
488                             break
489                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR
490                     all_files.append(self.translatable_file_class(dirpath, filename, locale_dir))
491         return sorted(all_files)
492 
493     def process_files(self, file_list):
494         """
495         Group translatable files by locale directory and run pot file build
496         process for each group.
497         """
498         file_groups = {}
499         for translatable in file_list:
500             file_group = file_groups.setdefault(translatable.locale_dir, [])
501             file_group.append(translatable)
502         for locale_dir, files in file_groups.items():
503             self.process_locale_dir(locale_dir, files)
504 
505     def process_locale_dir(self, locale_dir, files):
506         """
507         Extract translatable literals from the specified files, creating or
508         updating the POT file for a given locale directory.
509 
510         Use the xgettext GNU gettext utility.
511         """
512         build_files = []
513         for translatable in files:
514             if self.verbosity > 1:
515                 self.stdout.write('processing file %s in %s' % (
516                     translatable.file, translatable.dirpath
517                 ))
518             if self.domain not in ('djangojs', 'django'):
519                 continue
520             build_file = self.build_file_class(self, self.domain, translatable)
521             try:
522                 build_file.preprocess()
523             except UnicodeDecodeError as e:
524                 self.stdout.write(
525                     'UnicodeDecodeError: skipped file %s in %s (reason: %s)' % (
526                         translatable.file, translatable.dirpath, e,
527                     )
528                 )
529                 continue
530             build_files.append(build_file)
531 
532         if self.domain == 'djangojs':
533             is_templatized = build_file.is_templatized
534             args = [
535                 'xgettext',
536                 '-d', self.domain,
537                 '--language=%s' % ('C' if is_templatized else 'JavaScript',),
538                 '--keyword=gettext_noop',
539                 '--keyword=gettext_lazy',
540                 '--keyword=ngettext_lazy:1,2',
541                 '--keyword=pgettext:1c,2',
542                 '--keyword=npgettext:1c,2,3',
543                 '--output=-',
544             ]
545         elif self.domain == 'django':
546             args = [
547                 'xgettext',
548                 '-d', self.domain,
549                 '--language=Python',
550                 '--keyword=gettext_noop',
551                 '--keyword=gettext_lazy',
552                 '--keyword=ngettext_lazy:1,2',
553                 '--keyword=pgettext:1c,2',
554                 '--keyword=npgettext:1c,2,3',
555                 '--keyword=pgettext_lazy:1c,2',
556                 '--keyword=npgettext_lazy:1c,2,3',
557                 '--output=-',
558             ]
559         else:
560             return
561 
562         input_files = [bf.work_path for bf in build_files]
563         with NamedTemporaryFile(mode='w+') as input_files_list:
564             input_files_list.write('\n'.join(input_files))
565             input_files_list.flush()
566             args.extend(['--files-from', input_files_list.name])
567             args.extend(self.xgettext_options)
568             msgs, errors, status = popen_wrapper(args)
569 
570         if errors:
571             if status != STATUS_OK:
572                 for build_file in build_files:
573                     build_file.cleanup()
574                 raise CommandError(
575                     'errors happened while running xgettext on %s\n%s' %
576                     ('\n'.join(input_files), errors)
577                 )
578             elif self.verbosity > 0:
579                 # Print warnings
580                 self.stdout.write(errors)
581 
582         if msgs:
583             if locale_dir is NO_LOCALE_DIR:
584                 file_path = os.path.normpath(build_files[0].path)
585                 raise CommandError(
586                     'Unable to find a locale path to store translations for '
587                     'file %s' % file_path
588                 )
589             for build_file in build_files:
590                 msgs = build_file.postprocess_messages(msgs)
591             potfile = os.path.join(locale_dir, '%s.pot' % self.domain)
592             write_pot_file(potfile, msgs)
593 
594         for build_file in build_files:
595             build_file.cleanup()
596 
597     def write_po_file(self, potfile, locale):
598         """
599         Create or update the PO file for self.domain and `locale`.
600         Use contents of the existing `potfile`.
601 
602         Use msgmerge and msgattrib GNU gettext utilities.
603         """
604         basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')
605         os.makedirs(basedir, exist_ok=True)
606         pofile = os.path.join(basedir, '%s.po' % self.domain)
607 
608         if os.path.exists(pofile):
609             args = ['msgmerge'] + self.msgmerge_options + [pofile, potfile]
610             msgs, errors, status = popen_wrapper(args)
611             if errors:
612                 if status != STATUS_OK:
613                     raise CommandError(
614                         "errors happened while running msgmerge\n%s" % errors)
615                 elif self.verbosity > 0:
616                     self.stdout.write(errors)
617         else:
618             with open(potfile, encoding='utf-8') as fp:
619                 msgs = fp.read()
620             if not self.invoked_for_django:
621                 msgs = self.copy_plural_forms(msgs, locale)
622         msgs = normalize_eols(msgs)
623         msgs = msgs.replace(
624             "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self.domain, "")
625         with open(pofile, 'w', encoding='utf-8') as fp:
626             fp.write(msgs)
627 
628         if self.no_obsolete:
629             args = ['msgattrib'] + self.msgattrib_options + ['-o', pofile, pofile]
630             msgs, errors, status = popen_wrapper(args)
631             if errors:
632                 if status != STATUS_OK:
633                     raise CommandError(
634                         "errors happened while running msgattrib\n%s" % errors)
635                 elif self.verbosity > 0:
636                     self.stdout.write(errors)
637 
638     def copy_plural_forms(self, msgs, locale):
639         """
640         Copy plural forms header contents from a Django catalog of locale to
641         the msgs string, inserting it at the right place. msgs should be the
642         contents of a newly created .po file.
643         """
644         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))
645         if self.domain == 'djangojs':
646             domains = ('djangojs', 'django')
647         else:
648             domains = ('django',)
649         for domain in domains:
650             django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)
651             if os.path.exists(django_po):
652                 with open(django_po, encoding='utf-8') as fp:
653                     m = plural_forms_re.search(fp.read())
654                 if m:
655                     plural_form_line = m['value']
656                     if self.verbosity > 1:
657                         self.stdout.write('copying plural forms: %s' % plural_form_line)
658                     lines = []
659                     found = False
660                     for line in msgs.splitlines():
661                         if not found and (not line or plural_forms_re.search(line)):
662                             line = plural_form_line
663                             found = True
664                         lines.append(line)
665                     msgs = '\n'.join(lines)
666                     break
667         return msgs

</code><intended_behavior>This file should better handle scenarios where the 'locale' directory does not exist by enhancing error handling to suggest creation of a 'locale' directory or updating 'LOCALE_PATHS' settings, and implementing a check or prompt to guide in rectifying the issue.</intended_behavior>, <file>django/utils/translation/trans_real.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Translation helper functions."""
2 import functools
3 import gettext as gettext_module
4 import os
5 import re
6 import sys
7 import warnings
8 
9 from asgiref.local import Local
10 
11 from django.apps import apps
12 from django.conf import settings
13 from django.conf.locale import LANG_INFO
14 from django.core.exceptions import AppRegistryNotReady
15 from django.core.signals import setting_changed
16 from django.dispatch import receiver
17 from django.utils.regex_helper import _lazy_re_compile
18 from django.utils.safestring import SafeData, mark_safe
19 
20 from . import to_language, to_locale
21 
22 # Translations are cached in a dictionary for every language.
23 # The active translations are stored by threadid to make them thread local.
24 _translations = {}
25 _active = Local()
26 
27 # The default translation is based on the settings file.
28 _default = None
29 
30 # magic gettext number to separate context from message
31 CONTEXT_SEPARATOR = "\x04"
32 
33 # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9
34 # and RFC 3066, section 2.1
35 accept_language_re = _lazy_re_compile(r'''
36         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"
37         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:\.0{,3})?))?  # Optional "q=1.00", "q=0.8"
38         (?:\s*,\s*|$)                                 # Multiple accepts per header.
39         ''', re.VERBOSE)
40 
41 language_code_re = _lazy_re_compile(
42     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',
43     re.IGNORECASE
44 )
45 
46 language_code_prefix_re = _lazy_re_compile(r'^/(\w+([@-]\w+)?)(/|$)')
47 
48 
49 @receiver(setting_changed)
50 def reset_cache(**kwargs):
51     """
52     Reset global state when LANGUAGES setting has been changed, as some
53     languages should no longer be accepted.
54     """
55     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):
56         check_for_language.cache_clear()
57         get_languages.cache_clear()
58         get_supported_language_variant.cache_clear()
59 
60 
61 class TranslationCatalog:
62     """
63     Simulate a dict for DjangoTranslation._catalog so as multiple catalogs
64     with different plural equations are kept separate.
65     """
66     def __init__(self, trans=None):
67         self._catalogs = [trans._catalog.copy()] if trans else [{}]
68         self._plurals = [trans.plural] if trans else [lambda n: int(n != 1)]
69 
70     def __getitem__(self, key):
71         for cat in self._catalogs:
72             try:
73                 return cat[key]
74             except KeyError:
75                 pass
76         raise KeyError(key)
77 
78     def __setitem__(self, key, value):
79         self._catalogs[0][key] = value
80 
81     def __contains__(self, key):
82         return any(key in cat for cat in self._catalogs)
83 
84     def items(self):
85         for cat in self._catalogs:
86             yield from cat.items()
87 
88     def keys(self):
89         for cat in self._catalogs:
90             yield from cat.keys()
91 
92     def update(self, trans):
93         # Merge if plural function is the same, else prepend.
94         for cat, plural in zip(self._catalogs, self._plurals):
95             if trans.plural.__code__ == plural.__code__:
96                 cat.update(trans._catalog)
97                 break
98         else:
99             self._catalogs.insert(0, trans._catalog.copy())
100             self._plurals.insert(0, trans.plural)
101 
102     def get(self, key, default=None):
103         missing = object()
104         for cat in self._catalogs:
105             result = cat.get(key, missing)
106             if result is not missing:
107                 return result
108         return default
109 
110     def plural(self, msgid, num):
111         for cat, plural in zip(self._catalogs, self._plurals):
112             tmsg = cat.get((msgid, plural(num)))
113             if tmsg is not None:
114                 return tmsg
115         raise KeyError
116 
117 
118 class DjangoTranslation(gettext_module.GNUTranslations):
119     """
120     Set up the GNUTranslations context with regard to output charset.
121 
122     This translation object will be constructed out of multiple GNUTranslations
123     objects by merging their catalogs. It will construct an object for the
124     requested language and add a fallback to the default language, if it's
125     different from the requested language.
126     """
127     domain = 'django'
128 
129     def __init__(self, language, domain=None, localedirs=None):
130         """Create a GNUTranslations() using many locale directories"""
131         gettext_module.GNUTranslations.__init__(self)
132         if domain is not None:
133             self.domain = domain
134 
135         self.__language = language
136         self.__to_language = to_language(language)
137         self.__locale = to_locale(language)
138         self._catalog = None
139         # If a language doesn't have a catalog, use the Germanic default for
140         # pluralization: anything except one is pluralized.
141         self.plural = lambda n: int(n != 1)
142 
143         if self.domain == 'django':
144             if localedirs is not None:
145                 # A module-level cache is used for caching 'django' translations
146                 warnings.warn("localedirs is ignored when domain is 'django'.", RuntimeWarning)
147                 localedirs = None
148             self._init_translation_catalog()
149 
150         if localedirs:
151             for localedir in localedirs:
152                 translation = self._new_gnu_trans(localedir)
153                 self.merge(translation)
154         else:
155             self._add_installed_apps_translations()
156 
157         self._add_local_translations()
158         if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and self._catalog is None:
159             # default lang should have at least one translation file available.
160             raise OSError('No translation files found for default language %s.' % settings.LANGUAGE_CODE)
161         self._add_fallback(localedirs)
162         if self._catalog is None:
163             # No catalogs found for this language, set an empty catalog.
164             self._catalog = TranslationCatalog()
165 
166     def __repr__(self):
167         return "<DjangoTranslation lang:%s>" % self.__language
168 
169     def _new_gnu_trans(self, localedir, use_null_fallback=True):
170         """
171         Return a mergeable gettext.GNUTranslations instance.
172 
173         A convenience wrapper. By default gettext uses 'fallback=False'.
174         Using param `use_null_fallback` to avoid confusion with any other
175         references to 'fallback'.
176         """
177         return gettext_module.translation(
178             domain=self.domain,
179             localedir=localedir,
180             languages=[self.__locale],
181             fallback=use_null_fallback,
182         )
183 
184     def _init_translation_catalog(self):
185         """Create a base catalog using global django translations."""
186         settingsfile = sys.modules[settings.__module__].__file__
187         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')
188         translation = self._new_gnu_trans(localedir)
189         self.merge(translation)
190 
191     def _add_installed_apps_translations(self):
192         """Merge translations from each installed app."""
193         try:
194             app_configs = reversed(list(apps.get_app_configs()))
195         except AppRegistryNotReady:
196             raise AppRegistryNotReady(
197                 "The translation infrastructure cannot be initialized before the "
198                 "apps registry is ready. Check that you don't make non-lazy "
199                 "gettext calls at import time.")
200         for app_config in app_configs:
201             localedir = os.path.join(app_config.path, 'locale')
202             if os.path.exists(localedir):
203                 translation = self._new_gnu_trans(localedir)
204                 self.merge(translation)
205 
206     def _add_local_translations(self):
207         """Merge translations defined in LOCALE_PATHS."""
208         for localedir in reversed(settings.LOCALE_PATHS):
209             translation = self._new_gnu_trans(localedir)
210             self.merge(translation)
211 
212     def _add_fallback(self, localedirs=None):
213         """Set the GNUTranslations() fallback with the default language."""
214         # Don't set a fallback for the default language or any English variant
215         # (as it's empty, so it'll ALWAYS fall back to the default language)
216         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):
217             return
218         if self.domain == 'django':
219             # Get from cache
220             default_translation = translation(settings.LANGUAGE_CODE)
221         else:
222             default_translation = DjangoTranslation(
223                 settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs
224             )
225         self.add_fallback(default_translation)
226 
227     def merge(self, other):
228         """Merge another translation into this catalog."""
229         if not getattr(other, '_catalog', None):
230             return  # NullTranslations() has no _catalog
231         if self._catalog is None:
232             # Take plural and _info from first catalog found (generally Django's).
233             self.plural = other.plural
234             self._info = other._info.copy()
235             self._catalog = TranslationCatalog(other)
236         else:
237             self._catalog.update(other)
238         if other._fallback:
239             self.add_fallback(other._fallback)
240 
241     def language(self):
242         """Return the translation language."""
243         return self.__language
244 
245     def to_language(self):
246         """Return the translation language name."""
247         return self.__to_language
248 
249     def ngettext(self, msgid1, msgid2, n):
250         try:
251             tmsg = self._catalog.plural(msgid1, n)
252         except KeyError:
253             if self._fallback:
254                 return self._fallback.ngettext(msgid1, msgid2, n)
255             if n == 1:
256                 tmsg = msgid1
257             else:
258                 tmsg = msgid2
259         return tmsg
260 
261 
262 def translation(language):
263     """
264     Return a translation object in the default 'django' domain.
265     """
266     global _translations
267     if language not in _translations:
268         _translations[language] = DjangoTranslation(language)
269     return _translations[language]
270 
271 
272 def activate(language):
273     """
274     Fetch the translation object for a given language and install it as the
275     current translation object for the current thread.
276     """
277     if not language:
278         return
279     _active.value = translation(language)
280 
281 
282 def deactivate():
283     """
284     Uninstall the active translation object so that further _() calls resolve
285     to the default translation object.
286     """
287     if hasattr(_active, "value"):
288         del _active.value
289 
290 
291 def deactivate_all():
292     """
293     Make the active translation object a NullTranslations() instance. This is
294     useful when we want delayed translations to appear as the original string
295     for some reason.
296     """
297     _active.value = gettext_module.NullTranslations()
298     _active.value.to_language = lambda *args: None
299 
300 
301 def get_language():
302     """Return the currently selected language."""
303     t = getattr(_active, "value", None)
304     if t is not None:
305         try:
306             return t.to_language()
307         except AttributeError:
308             pass
309     # If we don't have a real translation object, assume it's the default language.
310     return settings.LANGUAGE_CODE
311 
312 
313 def get_language_bidi():
314     """
315     Return selected language's BiDi layout.
316 
317     * False = left-to-right layout
318     * True = right-to-left layout
319     """
320     lang = get_language()
321     if lang is None:
322         return False
323     else:
324         base_lang = get_language().split('-')[0]
325         return base_lang in settings.LANGUAGES_BIDI
326 
327 
328 def catalog():
329     """
330     Return the current active catalog for further processing.
331     This can be used if you need to modify the catalog or want to access the
332     whole message catalog instead of just translating one string.
333     """
334     global _default
335 
336     t = getattr(_active, "value", None)
337     if t is not None:
338         return t
339     if _default is None:
340         _default = translation(settings.LANGUAGE_CODE)
341     return _default
342 
343 
344 def gettext(message):
345     """
346     Translate the 'message' string. It uses the current thread to find the
347     translation object to use. If no current translation is activated, the
348     message will be run through the default translation object.
349     """
350     global _default
351 
352     eol_message = message.replace('\r\n', '\n').replace('\r', '\n')
353 
354     if eol_message:
355         _default = _default or translation(settings.LANGUAGE_CODE)
356         translation_object = getattr(_active, "value", _default)
357 
358         result = translation_object.gettext(eol_message)
359     else:
360         # Return an empty value of the corresponding type if an empty message
361         # is given, instead of metadata, which is the default gettext behavior.
362         result = type(message)('')
363 
364     if isinstance(message, SafeData):
365         return mark_safe(result)
366 
367     return result
368 
369 
370 def pgettext(context, message):
371     msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
372     result = gettext(msg_with_ctxt)
373     if CONTEXT_SEPARATOR in result:
374         # Translation not found
375         result = message
376     elif isinstance(message, SafeData):
377         result = mark_safe(result)
378     return result
379 
380 
381 def gettext_noop(message):
382     """
383     Mark strings for translation but don't translate them now. This can be
384     used to store strings in global variables that should stay in the base
385     language (because they might be used externally) and will be translated
386     later.
387     """
388     return message
389 
390 
391 def do_ntranslate(singular, plural, number, translation_function):
392     global _default
393 
394     t = getattr(_active, "value", None)
395     if t is not None:
396         return getattr(t, translation_function)(singular, plural, number)
397     if _default is None:
398         _default = translation(settings.LANGUAGE_CODE)
399     return getattr(_default, translation_function)(singular, plural, number)
400 
401 
402 def ngettext(singular, plural, number):
403     """
404     Return a string of the translation of either the singular or plural,
405     based on the number.
406     """
407     return do_ntranslate(singular, plural, number, 'ngettext')
408 
409 
410 def npgettext(context, singular, plural, number):
411     msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, singular),
412                       "%s%s%s" % (context, CONTEXT_SEPARATOR, plural),
413                       number)
414     result = ngettext(*msgs_with_ctxt)
415     if CONTEXT_SEPARATOR in result:
416         # Translation not found
417         result = ngettext(singular, plural, number)
418     return result
419 
420 
421 def all_locale_paths():
422     """
423     Return a list of paths to user-provides languages files.
424     """
425     globalpath = os.path.join(
426         os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')
427     app_paths = []
428     for app_config in apps.get_app_configs():
429         locale_path = os.path.join(app_config.path, 'locale')
430         if os.path.exists(locale_path):
431             app_paths.append(locale_path)
432     return [globalpath, *settings.LOCALE_PATHS, *app_paths]
433 
434 
435 @functools.lru_cache(maxsize=1000)
436 def check_for_language(lang_code):
437     """
438     Check whether there is a global language file for the given language
439     code. This is used to decide whether a user-provided language is
440     available.
441 
442     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
443     as the provided language codes are taken from the HTTP request. See also
444     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
445     """
446     # First, a quick check to make sure lang_code is well-formed (#21458)
447     if lang_code is None or not language_code_re.search(lang_code):
448         return False
449     return any(
450         gettext_module.find('django', path, [to_locale(lang_code)]) is not None
451         for path in all_locale_paths()
452     )
453 
454 
455 @functools.lru_cache()
456 def get_languages():
457     """
458     Cache of settings.LANGUAGES in a dictionary for easy lookups by key.
459     """
460     return dict(settings.LANGUAGES)
461 
462 
463 @functools.lru_cache(maxsize=1000)
464 def get_supported_language_variant(lang_code, strict=False):
465     """
466     Return the language code that's listed in supported languages, possibly
467     selecting a more generic variant. Raise LookupError if nothing is found.
468 
469     If `strict` is False (the default), look for a country-specific variant
470     when neither the language code nor its generic variant is found.
471 
472     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
473     as the provided language codes are taken from the HTTP request. See also
474     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
475     """
476     if lang_code:
477         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.
478         possible_lang_codes = [lang_code]
479         try:
480             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])
481         except KeyError:
482             pass
483         generic_lang_code = lang_code.split('-')[0]
484         possible_lang_codes.append(generic_lang_code)
485         supported_lang_codes = get_languages()
486 
487         for code in possible_lang_codes:
488             if code in supported_lang_codes and check_for_language(code):
489                 return code
490         if not strict:
491             # if fr-fr is not supported, try fr-ca.
492             for supported_code in supported_lang_codes:
493                 if supported_code.startswith(generic_lang_code + '-'):
494                     return supported_code
495     raise LookupError(lang_code)
496 
497 
498 def get_language_from_path(path, strict=False):
499     """
500     Return the language code if there's a valid language code found in `path`.
501 
502     If `strict` is False (the default), look for a country-specific variant
503     when neither the language code nor its generic variant is found.
504     """
505     regex_match = language_code_prefix_re.match(path)
506     if not regex_match:
507         return None
508     lang_code = regex_match[1]
509     try:
510         return get_supported_language_variant(lang_code, strict=strict)
511     except LookupError:
512         return None
513 
514 
515 def get_language_from_request(request, check_path=False):
516     """
517     Analyze the request to find what language the user wants the system to
518     show. Only languages listed in settings.LANGUAGES are taken into account.
519     If the user requests a sublanguage where we have a main language, we send
520     out the main language.
521 
522     If check_path is True, the URL path prefix will be checked for a language
523     code, otherwise this is skipped for backwards compatibility.
524     """
525     if check_path:
526         lang_code = get_language_from_path(request.path_info)
527         if lang_code is not None:
528             return lang_code
529 
530     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)
531     if lang_code is not None and lang_code in get_languages() and check_for_language(lang_code):
532         return lang_code
533 
534     try:
535         return get_supported_language_variant(lang_code)
536     except LookupError:
537         pass
538 
539     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
540     for accept_lang, unused in parse_accept_lang_header(accept):
541         if accept_lang == '*':
542             break
543 
544         if not language_code_re.search(accept_lang):
545             continue
546 
547         try:
548             return get_supported_language_variant(accept_lang)
549         except LookupError:
550             continue
551 
552     try:
553         return get_supported_language_variant(settings.LANGUAGE_CODE)
554     except LookupError:
555         return settings.LANGUAGE_CODE
556 
557 
558 @functools.lru_cache(maxsize=1000)
559 def parse_accept_lang_header(lang_string):
560     """
561     Parse the lang_string, which is the body of an HTTP Accept-Language
562     header, and return a tuple of (lang, q-value), ordered by 'q' values.
563 
564     Return an empty tuple if there are any format errors in lang_string.
565     """
566     result = []
567     pieces = accept_language_re.split(lang_string.lower())
568     if pieces[-1]:
569         return ()
570     for i in range(0, len(pieces) - 1, 3):
571         first, lang, priority = pieces[i:i + 3]
572         if first:
573             return ()
574         if priority:
575             priority = float(priority)
576         else:
577             priority = 1.0
578         result.append((lang, priority))
579     result.sort(key=lambda k: k[1], reverse=True)
580     return tuple(result)

</code><intended_behavior>Adjust to ensure proper handling and fallback for 'LOCALE_PATHS' to include sensible defaults, such as considering a 'locale' directory at the same level as 'manage.py' if not explicitly defined in 'LOCALE_PATHS'. Preserve current functionality while providing flexibility for translation file paths setup or adjustment.</intended_behavior>]
2025-10-15 05:36:36.202 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:36:36.203 | INFO     | Search-only: skipping patch selection
2025-10-15 05:36:36.334 | INFO     | Task django__django-13616 completed successfully.
2025-10-15 05:36:36.335 | INFO     | No patch generated. You can try running ACR again.
