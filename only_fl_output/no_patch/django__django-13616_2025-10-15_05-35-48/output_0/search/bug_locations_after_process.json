[
    {
        "rel_file_path": "django/core/management/commands/makemessages.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/management/commands/makemessages.py",
        "start": 1,
        "end": 667,
        "class_name": null,
        "method_name": null,
        "code": "1 import glob\n2 import os\n3 import re\n4 import sys\n5 from functools import total_ordering\n6 from itertools import dropwhile\n7 \n8 import django\n9 from django.conf import settings\n10 from django.core.exceptions import ImproperlyConfigured\n11 from django.core.files.temp import NamedTemporaryFile\n12 from django.core.management.base import BaseCommand, CommandError\n13 from django.core.management.utils import (\n14     find_command, handle_extensions, is_ignored_path, popen_wrapper,\n15 )\n16 from django.utils.encoding import DEFAULT_LOCALE_ENCODING\n17 from django.utils.functional import cached_property\n18 from django.utils.jslex import prepare_js_for_gettext\n19 from django.utils.regex_helper import _lazy_re_compile\n20 from django.utils.text import get_text_list\n21 from django.utils.translation import templatize\n22 \n23 plural_forms_re = _lazy_re_compile(r'^(?P<value>\"Plural-Forms.+?\\\\n\")\\s*$', re.MULTILINE | re.DOTALL)\n24 STATUS_OK = 0\n25 NO_LOCALE_DIR = object()\n26 \n27 \n28 def check_programs(*programs):\n29     for program in programs:\n30         if find_command(program) is None:\n31             raise CommandError(\n32                 \"Can't find %s. Make sure you have GNU gettext tools 0.15 or \"\n33                 \"newer installed.\" % program\n34             )\n35 \n36 \n37 @total_ordering\n38 class TranslatableFile:\n39     def __init__(self, dirpath, file_name, locale_dir):\n40         self.file = file_name\n41         self.dirpath = dirpath\n42         self.locale_dir = locale_dir\n43 \n44     def __repr__(self):\n45         return \"<%s: %s>\" % (\n46             self.__class__.__name__,\n47             os.sep.join([self.dirpath, self.file]),\n48         )\n49 \n50     def __eq__(self, other):\n51         return self.path == other.path\n52 \n53     def __lt__(self, other):\n54         return self.path < other.path\n55 \n56     @property\n57     def path(self):\n58         return os.path.join(self.dirpath, self.file)\n59 \n60 \n61 class BuildFile:\n62     \"\"\"\n63     Represent the state of a translatable file during the build process.\n64     \"\"\"\n65     def __init__(self, command, domain, translatable):\n66         self.command = command\n67         self.domain = domain\n68         self.translatable = translatable\n69 \n70     @cached_property\n71     def is_templatized(self):\n72         if self.domain == 'djangojs':\n73             return self.command.gettext_version < (0, 18, 3)\n74         elif self.domain == 'django':\n75             file_ext = os.path.splitext(self.translatable.file)[1]\n76             return file_ext != '.py'\n77         return False\n78 \n79     @cached_property\n80     def path(self):\n81         return self.translatable.path\n82 \n83     @cached_property\n84     def work_path(self):\n85         \"\"\"\n86         Path to a file which is being fed into GNU gettext pipeline. This may\n87         be either a translatable or its preprocessed version.\n88         \"\"\"\n89         if not self.is_templatized:\n90             return self.path\n91         extension = {\n92             'djangojs': 'c',\n93             'django': 'py',\n94         }.get(self.domain)\n95         filename = '%s.%s' % (self.translatable.file, extension)\n96         return os.path.join(self.translatable.dirpath, filename)\n97 \n98     def preprocess(self):\n99         \"\"\"\n100         Preprocess (if necessary) a translatable file before passing it to\n101         xgettext GNU gettext utility.\n102         \"\"\"\n103         if not self.is_templatized:\n104             return\n105 \n106         with open(self.path, encoding='utf-8') as fp:\n107             src_data = fp.read()\n108 \n109         if self.domain == 'djangojs':\n110             content = prepare_js_for_gettext(src_data)\n111         elif self.domain == 'django':\n112             content = templatize(src_data, origin=self.path[2:])\n113 \n114         with open(self.work_path, 'w', encoding='utf-8') as fp:\n115             fp.write(content)\n116 \n117     def postprocess_messages(self, msgs):\n118         \"\"\"\n119         Postprocess messages generated by xgettext GNU gettext utility.\n120 \n121         Transform paths as if these messages were generated from original\n122         translatable files rather than from preprocessed versions.\n123         \"\"\"\n124         if not self.is_templatized:\n125             return msgs\n126 \n127         # Remove '.py' suffix\n128         if os.name == 'nt':\n129             # Preserve '.\\' prefix on Windows to respect gettext behavior\n130             old_path = self.work_path\n131             new_path = self.path\n132         else:\n133             old_path = self.work_path[2:]\n134             new_path = self.path[2:]\n135 \n136         return re.sub(\n137             r'^(#: .*)(' + re.escape(old_path) + r')',\n138             lambda match: match[0].replace(old_path, new_path),\n139             msgs,\n140             flags=re.MULTILINE\n141         )\n142 \n143     def cleanup(self):\n144         \"\"\"\n145         Remove a preprocessed copy of a translatable file (if any).\n146         \"\"\"\n147         if self.is_templatized:\n148             # This check is needed for the case of a symlinked file and its\n149             # source being processed inside a single group (locale dir);\n150             # removing either of those two removes both.\n151             if os.path.exists(self.work_path):\n152                 os.unlink(self.work_path)\n153 \n154 \n155 def normalize_eols(raw_contents):\n156     \"\"\"\n157     Take a block of raw text that will be passed through str.splitlines() to\n158     get universal newlines treatment.\n159 \n160     Return the resulting block of text with normalized `\\n` EOL sequences ready\n161     to be written to disk using current platform's native EOLs.\n162     \"\"\"\n163     lines_list = raw_contents.splitlines()\n164     # Ensure last line has its EOL\n165     if lines_list and lines_list[-1]:\n166         lines_list.append('')\n167     return '\\n'.join(lines_list)\n168 \n169 \n170 def write_pot_file(potfile, msgs):\n171     \"\"\"\n172     Write the `potfile` with the `msgs` contents, making sure its format is\n173     valid.\n174     \"\"\"\n175     pot_lines = msgs.splitlines()\n176     if os.path.exists(potfile):\n177         # Strip the header\n178         lines = dropwhile(len, pot_lines)\n179     else:\n180         lines = []\n181         found, header_read = False, False\n182         for line in pot_lines:\n183             if not found and not header_read:\n184                 if 'charset=CHARSET' in line:\n185                     found = True\n186                     line = line.replace('charset=CHARSET', 'charset=UTF-8')\n187             if not line and not found:\n188                 header_read = True\n189             lines.append(line)\n190     msgs = '\\n'.join(lines)\n191     # Force newlines of POT files to '\\n' to work around\n192     # https://savannah.gnu.org/bugs/index.php?52395\n193     with open(potfile, 'a', encoding='utf-8', newline='\\n') as fp:\n194         fp.write(msgs)\n195 \n196 \n197 class Command(BaseCommand):\n198     help = (\n199         \"Runs over the entire source tree of the current directory and \"\n200         \"pulls out all strings marked for translation. It creates (or updates) a message \"\n201         \"file in the conf/locale (in the django tree) or locale (for projects and \"\n202         \"applications) directory.\\n\\nYou must run this command with one of either the \"\n203         \"--locale, --exclude, or --all options.\"\n204     )\n205 \n206     translatable_file_class = TranslatableFile\n207     build_file_class = BuildFile\n208 \n209     requires_system_checks = []\n210 \n211     msgmerge_options = ['-q', '--previous']\n212     msguniq_options = ['--to-code=utf-8']\n213     msgattrib_options = ['--no-obsolete']\n214     xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators']\n215 \n216     def add_arguments(self, parser):\n217         parser.add_argument(\n218             '--locale', '-l', default=[], action='append',\n219             help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '\n220                  'Can be used multiple times.',\n221         )\n222         parser.add_argument(\n223             '--exclude', '-x', default=[], action='append',\n224             help='Locales to exclude. Default is none. Can be used multiple times.',\n225         )\n226         parser.add_argument(\n227             '--domain', '-d', default='django',\n228             help='The domain of the message files (default: \"django\").',\n229         )\n230         parser.add_argument(\n231             '--all', '-a', action='store_true',\n232             help='Updates the message files for all existing locales.',\n233         )\n234         parser.add_argument(\n235             '--extension', '-e', dest='extensions', action='append',\n236             help='The file extension(s) to examine (default: \"html,txt,py\", or \"js\" '\n237                  'if the domain is \"djangojs\"). Separate multiple extensions with '\n238                  'commas, or use -e multiple times.',\n239         )\n240         parser.add_argument(\n241             '--symlinks', '-s', action='store_true',\n242             help='Follows symlinks to directories when examining source code '\n243                  'and templates for translation strings.',\n244         )\n245         parser.add_argument(\n246             '--ignore', '-i', action='append', dest='ignore_patterns',\n247             default=[], metavar='PATTERN',\n248             help='Ignore files or directories matching this glob-style pattern. '\n249                  'Use multiple times to ignore more.',\n250         )\n251         parser.add_argument(\n252             '--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',\n253             help=\"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.\",\n254         )\n255         parser.add_argument(\n256             '--no-wrap', action='store_true',\n257             help=\"Don't break long message lines into several lines.\",\n258         )\n259         parser.add_argument(\n260             '--no-location', action='store_true',\n261             help=\"Don't write '#: filename:line' lines.\",\n262         )\n263         parser.add_argument(\n264             '--add-location',\n265             choices=('full', 'file', 'never'), const='full', nargs='?',\n266             help=(\n267                 \"Controls '#: filename:line' lines. If the option is 'full' \"\n268                 \"(the default if not given), the lines  include both file name \"\n269                 \"and line number. If it's 'file', the line number is omitted. If \"\n270                 \"it's 'never', the lines are suppressed (same as --no-location). \"\n271                 \"--add-location requires gettext 0.19 or newer.\"\n272             ),\n273         )\n274         parser.add_argument(\n275             '--no-obsolete', action='store_true',\n276             help=\"Remove obsolete message strings.\",\n277         )\n278         parser.add_argument(\n279             '--keep-pot', action='store_true',\n280             help=\"Keep .pot file after making messages. Useful when debugging.\",\n281         )\n282 \n283     def handle(self, *args, **options):\n284         locale = options['locale']\n285         exclude = options['exclude']\n286         self.domain = options['domain']\n287         self.verbosity = options['verbosity']\n288         process_all = options['all']\n289         extensions = options['extensions']\n290         self.symlinks = options['symlinks']\n291 \n292         ignore_patterns = options['ignore_patterns']\n293         if options['use_default_ignore_patterns']:\n294             ignore_patterns += ['CVS', '.*', '*~', '*.pyc']\n295         self.ignore_patterns = list(set(ignore_patterns))\n296 \n297         # Avoid messing with mutable class variables\n298         if options['no_wrap']:\n299             self.msgmerge_options = self.msgmerge_options[:] + ['--no-wrap']\n300             self.msguniq_options = self.msguniq_options[:] + ['--no-wrap']\n301             self.msgattrib_options = self.msgattrib_options[:] + ['--no-wrap']\n302             self.xgettext_options = self.xgettext_options[:] + ['--no-wrap']\n303         if options['no_location']:\n304             self.msgmerge_options = self.msgmerge_options[:] + ['--no-location']\n305             self.msguniq_options = self.msguniq_options[:] + ['--no-location']\n306             self.msgattrib_options = self.msgattrib_options[:] + ['--no-location']\n307             self.xgettext_options = self.xgettext_options[:] + ['--no-location']\n308         if options['add_location']:\n309             if self.gettext_version < (0, 19):\n310                 raise CommandError(\n311                     \"The --add-location option requires gettext 0.19 or later. \"\n312                     \"You have %s.\" % '.'.join(str(x) for x in self.gettext_version)\n313                 )\n314             arg_add_location = \"--add-location=%s\" % options['add_location']\n315             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]\n316             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]\n317             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]\n318             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]\n319 \n320         self.no_obsolete = options['no_obsolete']\n321         self.keep_pot = options['keep_pot']\n322 \n323         if self.domain not in ('django', 'djangojs'):\n324             raise CommandError(\"currently makemessages only supports domains \"\n325                                \"'django' and 'djangojs'\")\n326         if self.domain == 'djangojs':\n327             exts = extensions or ['js']\n328         else:\n329             exts = extensions or ['html', 'txt', 'py']\n330         self.extensions = handle_extensions(exts)\n331 \n332         if (not locale and not exclude and not process_all) or self.domain is None:\n333             raise CommandError(\n334                 \"Type '%s help %s' for usage information.\"\n335                 % (os.path.basename(sys.argv[0]), sys.argv[1])\n336             )\n337 \n338         if self.verbosity > 1:\n339             self.stdout.write(\n340                 'examining files with the extensions: %s'\n341                 % get_text_list(list(self.extensions), 'and')\n342             )\n343 \n344         self.invoked_for_django = False\n345         self.locale_paths = []\n346         self.default_locale_path = None\n347         if os.path.isdir(os.path.join('conf', 'locale')):\n348             self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'))]\n349             self.default_locale_path = self.locale_paths[0]\n350             self.invoked_for_django = True\n351         else:\n352             if self.settings_available:\n353                 self.locale_paths.extend(settings.LOCALE_PATHS)\n354             # Allow to run makemessages inside an app dir\n355             if os.path.isdir('locale'):\n356                 self.locale_paths.append(os.path.abspath('locale'))\n357             if self.locale_paths:\n358                 self.default_locale_path = self.locale_paths[0]\n359                 os.makedirs(self.default_locale_path, exist_ok=True)\n360 \n361         # Build locale list\n362         looks_like_locale = re.compile(r'[a-z]{2}')\n363         locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path))\n364         all_locales = [\n365             lang_code for lang_code in map(os.path.basename, locale_dirs)\n366             if looks_like_locale.match(lang_code)\n367         ]\n368 \n369         # Account for excluded locales\n370         if process_all:\n371             locales = all_locales\n372         else:\n373             locales = locale or all_locales\n374             locales = set(locales).difference(exclude)\n375 \n376         if locales:\n377             check_programs('msguniq', 'msgmerge', 'msgattrib')\n378 \n379         check_programs('xgettext')\n380 \n381         try:\n382             potfiles = self.build_potfiles()\n383 \n384             # Build po files for each selected locale\n385             for locale in locales:\n386                 if '-' in locale:\n387                     self.stdout.write(\n388                         'invalid locale %s, did you mean %s?' % (\n389                             locale,\n390                             locale.replace('-', '_'),\n391                         ),\n392                     )\n393                     continue\n394                 if self.verbosity > 0:\n395                     self.stdout.write('processing locale %s' % locale)\n396                 for potfile in potfiles:\n397                     self.write_po_file(potfile, locale)\n398         finally:\n399             if not self.keep_pot:\n400                 self.remove_potfiles()\n401 \n402     @cached_property\n403     def gettext_version(self):\n404         # Gettext tools will output system-encoded bytestrings instead of UTF-8,\n405         # when looking up the version. It's especially a problem on Windows.\n406         out, err, status = popen_wrapper(\n407             ['xgettext', '--version'],\n408             stdout_encoding=DEFAULT_LOCALE_ENCODING,\n409         )\n410         m = re.search(r'(\\d+)\\.(\\d+)\\.?(\\d+)?', out)\n411         if m:\n412             return tuple(int(d) for d in m.groups() if d is not None)\n413         else:\n414             raise CommandError(\"Unable to get gettext version. Is it installed?\")\n415 \n416     @cached_property\n417     def settings_available(self):\n418         try:\n419             settings.LOCALE_PATHS\n420         except ImproperlyConfigured:\n421             if self.verbosity > 1:\n422                 self.stderr.write(\"Running without configured settings.\")\n423             return False\n424         return True\n425 \n426     def build_potfiles(self):\n427         \"\"\"\n428         Build pot files and apply msguniq to them.\n429         \"\"\"\n430         file_list = self.find_files(\".\")\n431         self.remove_potfiles()\n432         self.process_files(file_list)\n433         potfiles = []\n434         for path in self.locale_paths:\n435             potfile = os.path.join(path, '%s.pot' % self.domain)\n436             if not os.path.exists(potfile):\n437                 continue\n438             args = ['msguniq'] + self.msguniq_options + [potfile]\n439             msgs, errors, status = popen_wrapper(args)\n440             if errors:\n441                 if status != STATUS_OK:\n442                     raise CommandError(\n443                         \"errors happened while running msguniq\\n%s\" % errors)\n444                 elif self.verbosity > 0:\n445                     self.stdout.write(errors)\n446             msgs = normalize_eols(msgs)\n447             with open(potfile, 'w', encoding='utf-8') as fp:\n448                 fp.write(msgs)\n449             potfiles.append(potfile)\n450         return potfiles\n451 \n452     def remove_potfiles(self):\n453         for path in self.locale_paths:\n454             pot_path = os.path.join(path, '%s.pot' % self.domain)\n455             if os.path.exists(pot_path):\n456                 os.unlink(pot_path)\n457 \n458     def find_files(self, root):\n459         \"\"\"\n460         Get all files in the given root. Also check that there is a matching\n461         locale dir for each file.\n462         \"\"\"\n463         all_files = []\n464         ignored_roots = []\n465         if self.settings_available:\n466             ignored_roots = [os.path.normpath(p) for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT) if p]\n467         for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):\n468             for dirname in dirnames[:]:\n469                 if (is_ignored_path(os.path.normpath(os.path.join(dirpath, dirname)), self.ignore_patterns) or\n470                         os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots):\n471                     dirnames.remove(dirname)\n472                     if self.verbosity > 1:\n473                         self.stdout.write('ignoring directory %s' % dirname)\n474                 elif dirname == 'locale':\n475                     dirnames.remove(dirname)\n476                     self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))\n477             for filename in filenames:\n478                 file_path = os.path.normpath(os.path.join(dirpath, filename))\n479                 file_ext = os.path.splitext(filename)[1]\n480                 if file_ext not in self.extensions or is_ignored_path(file_path, self.ignore_patterns):\n481                     if self.verbosity > 1:\n482                         self.stdout.write('ignoring file %s in %s' % (filename, dirpath))\n483                 else:\n484                     locale_dir = None\n485                     for path in self.locale_paths:\n486                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):\n487                             locale_dir = path\n488                             break\n489                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR\n490                     all_files.append(self.translatable_file_class(dirpath, filename, locale_dir))\n491         return sorted(all_files)\n492 \n493     def process_files(self, file_list):\n494         \"\"\"\n495         Group translatable files by locale directory and run pot file build\n496         process for each group.\n497         \"\"\"\n498         file_groups = {}\n499         for translatable in file_list:\n500             file_group = file_groups.setdefault(translatable.locale_dir, [])\n501             file_group.append(translatable)\n502         for locale_dir, files in file_groups.items():\n503             self.process_locale_dir(locale_dir, files)\n504 \n505     def process_locale_dir(self, locale_dir, files):\n506         \"\"\"\n507         Extract translatable literals from the specified files, creating or\n508         updating the POT file for a given locale directory.\n509 \n510         Use the xgettext GNU gettext utility.\n511         \"\"\"\n512         build_files = []\n513         for translatable in files:\n514             if self.verbosity > 1:\n515                 self.stdout.write('processing file %s in %s' % (\n516                     translatable.file, translatable.dirpath\n517                 ))\n518             if self.domain not in ('djangojs', 'django'):\n519                 continue\n520             build_file = self.build_file_class(self, self.domain, translatable)\n521             try:\n522                 build_file.preprocess()\n523             except UnicodeDecodeError as e:\n524                 self.stdout.write(\n525                     'UnicodeDecodeError: skipped file %s in %s (reason: %s)' % (\n526                         translatable.file, translatable.dirpath, e,\n527                     )\n528                 )\n529                 continue\n530             build_files.append(build_file)\n531 \n532         if self.domain == 'djangojs':\n533             is_templatized = build_file.is_templatized\n534             args = [\n535                 'xgettext',\n536                 '-d', self.domain,\n537                 '--language=%s' % ('C' if is_templatized else 'JavaScript',),\n538                 '--keyword=gettext_noop',\n539                 '--keyword=gettext_lazy',\n540                 '--keyword=ngettext_lazy:1,2',\n541                 '--keyword=pgettext:1c,2',\n542                 '--keyword=npgettext:1c,2,3',\n543                 '--output=-',\n544             ]\n545         elif self.domain == 'django':\n546             args = [\n547                 'xgettext',\n548                 '-d', self.domain,\n549                 '--language=Python',\n550                 '--keyword=gettext_noop',\n551                 '--keyword=gettext_lazy',\n552                 '--keyword=ngettext_lazy:1,2',\n553                 '--keyword=pgettext:1c,2',\n554                 '--keyword=npgettext:1c,2,3',\n555                 '--keyword=pgettext_lazy:1c,2',\n556                 '--keyword=npgettext_lazy:1c,2,3',\n557                 '--output=-',\n558             ]\n559         else:\n560             return\n561 \n562         input_files = [bf.work_path for bf in build_files]\n563         with NamedTemporaryFile(mode='w+') as input_files_list:\n564             input_files_list.write('\\n'.join(input_files))\n565             input_files_list.flush()\n566             args.extend(['--files-from', input_files_list.name])\n567             args.extend(self.xgettext_options)\n568             msgs, errors, status = popen_wrapper(args)\n569 \n570         if errors:\n571             if status != STATUS_OK:\n572                 for build_file in build_files:\n573                     build_file.cleanup()\n574                 raise CommandError(\n575                     'errors happened while running xgettext on %s\\n%s' %\n576                     ('\\n'.join(input_files), errors)\n577                 )\n578             elif self.verbosity > 0:\n579                 # Print warnings\n580                 self.stdout.write(errors)\n581 \n582         if msgs:\n583             if locale_dir is NO_LOCALE_DIR:\n584                 file_path = os.path.normpath(build_files[0].path)\n585                 raise CommandError(\n586                     'Unable to find a locale path to store translations for '\n587                     'file %s' % file_path\n588                 )\n589             for build_file in build_files:\n590                 msgs = build_file.postprocess_messages(msgs)\n591             potfile = os.path.join(locale_dir, '%s.pot' % self.domain)\n592             write_pot_file(potfile, msgs)\n593 \n594         for build_file in build_files:\n595             build_file.cleanup()\n596 \n597     def write_po_file(self, potfile, locale):\n598         \"\"\"\n599         Create or update the PO file for self.domain and `locale`.\n600         Use contents of the existing `potfile`.\n601 \n602         Use msgmerge and msgattrib GNU gettext utilities.\n603         \"\"\"\n604         basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')\n605         os.makedirs(basedir, exist_ok=True)\n606         pofile = os.path.join(basedir, '%s.po' % self.domain)\n607 \n608         if os.path.exists(pofile):\n609             args = ['msgmerge'] + self.msgmerge_options + [pofile, potfile]\n610             msgs, errors, status = popen_wrapper(args)\n611             if errors:\n612                 if status != STATUS_OK:\n613                     raise CommandError(\n614                         \"errors happened while running msgmerge\\n%s\" % errors)\n615                 elif self.verbosity > 0:\n616                     self.stdout.write(errors)\n617         else:\n618             with open(potfile, encoding='utf-8') as fp:\n619                 msgs = fp.read()\n620             if not self.invoked_for_django:\n621                 msgs = self.copy_plural_forms(msgs, locale)\n622         msgs = normalize_eols(msgs)\n623         msgs = msgs.replace(\n624             \"#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n\" % self.domain, \"\")\n625         with open(pofile, 'w', encoding='utf-8') as fp:\n626             fp.write(msgs)\n627 \n628         if self.no_obsolete:\n629             args = ['msgattrib'] + self.msgattrib_options + ['-o', pofile, pofile]\n630             msgs, errors, status = popen_wrapper(args)\n631             if errors:\n632                 if status != STATUS_OK:\n633                     raise CommandError(\n634                         \"errors happened while running msgattrib\\n%s\" % errors)\n635                 elif self.verbosity > 0:\n636                     self.stdout.write(errors)\n637 \n638     def copy_plural_forms(self, msgs, locale):\n639         \"\"\"\n640         Copy plural forms header contents from a Django catalog of locale to\n641         the msgs string, inserting it at the right place. msgs should be the\n642         contents of a newly created .po file.\n643         \"\"\"\n644         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))\n645         if self.domain == 'djangojs':\n646             domains = ('djangojs', 'django')\n647         else:\n648             domains = ('django',)\n649         for domain in domains:\n650             django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)\n651             if os.path.exists(django_po):\n652                 with open(django_po, encoding='utf-8') as fp:\n653                     m = plural_forms_re.search(fp.read())\n654                 if m:\n655                     plural_form_line = m['value']\n656                     if self.verbosity > 1:\n657                         self.stdout.write('copying plural forms: %s' % plural_form_line)\n658                     lines = []\n659                     found = False\n660                     for line in msgs.splitlines():\n661                         if not found and (not line or plural_forms_re.search(line)):\n662                             line = plural_form_line\n663                             found = True\n664                         lines.append(line)\n665                     msgs = '\\n'.join(lines)\n666                     break\n667         return msgs\n",
        "intended_behavior": "This file should better handle scenarios where the 'locale' directory does not exist by enhancing error handling to suggest creation of a 'locale' directory or updating 'LOCALE_PATHS' settings, and implementing a check or prompt to guide in rectifying the issue."
    },
    {
        "rel_file_path": "django/utils/translation/trans_real.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/utils/translation/trans_real.py",
        "start": 1,
        "end": 580,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Translation helper functions.\"\"\"\n2 import functools\n3 import gettext as gettext_module\n4 import os\n5 import re\n6 import sys\n7 import warnings\n8 \n9 from asgiref.local import Local\n10 \n11 from django.apps import apps\n12 from django.conf import settings\n13 from django.conf.locale import LANG_INFO\n14 from django.core.exceptions import AppRegistryNotReady\n15 from django.core.signals import setting_changed\n16 from django.dispatch import receiver\n17 from django.utils.regex_helper import _lazy_re_compile\n18 from django.utils.safestring import SafeData, mark_safe\n19 \n20 from . import to_language, to_locale\n21 \n22 # Translations are cached in a dictionary for every language.\n23 # The active translations are stored by threadid to make them thread local.\n24 _translations = {}\n25 _active = Local()\n26 \n27 # The default translation is based on the settings file.\n28 _default = None\n29 \n30 # magic gettext number to separate context from message\n31 CONTEXT_SEPARATOR = \"\\x04\"\n32 \n33 # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9\n34 # and RFC 3066, section 2.1\n35 accept_language_re = _lazy_re_compile(r'''\n36         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\\*)      # \"en\", \"en-au\", \"x-y-z\", \"es-419\", \"*\"\n37         (?:\\s*;\\s*q=(0(?:\\.\\d{,3})?|1(?:\\.0{,3})?))?  # Optional \"q=1.00\", \"q=0.8\"\n38         (?:\\s*,\\s*|$)                                 # Multiple accepts per header.\n39         ''', re.VERBOSE)\n40 \n41 language_code_re = _lazy_re_compile(\n42     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',\n43     re.IGNORECASE\n44 )\n45 \n46 language_code_prefix_re = _lazy_re_compile(r'^/(\\w+([@-]\\w+)?)(/|$)')\n47 \n48 \n49 @receiver(setting_changed)\n50 def reset_cache(**kwargs):\n51     \"\"\"\n52     Reset global state when LANGUAGES setting has been changed, as some\n53     languages should no longer be accepted.\n54     \"\"\"\n55     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):\n56         check_for_language.cache_clear()\n57         get_languages.cache_clear()\n58         get_supported_language_variant.cache_clear()\n59 \n60 \n61 class TranslationCatalog:\n62     \"\"\"\n63     Simulate a dict for DjangoTranslation._catalog so as multiple catalogs\n64     with different plural equations are kept separate.\n65     \"\"\"\n66     def __init__(self, trans=None):\n67         self._catalogs = [trans._catalog.copy()] if trans else [{}]\n68         self._plurals = [trans.plural] if trans else [lambda n: int(n != 1)]\n69 \n70     def __getitem__(self, key):\n71         for cat in self._catalogs:\n72             try:\n73                 return cat[key]\n74             except KeyError:\n75                 pass\n76         raise KeyError(key)\n77 \n78     def __setitem__(self, key, value):\n79         self._catalogs[0][key] = value\n80 \n81     def __contains__(self, key):\n82         return any(key in cat for cat in self._catalogs)\n83 \n84     def items(self):\n85         for cat in self._catalogs:\n86             yield from cat.items()\n87 \n88     def keys(self):\n89         for cat in self._catalogs:\n90             yield from cat.keys()\n91 \n92     def update(self, trans):\n93         # Merge if plural function is the same, else prepend.\n94         for cat, plural in zip(self._catalogs, self._plurals):\n95             if trans.plural.__code__ == plural.__code__:\n96                 cat.update(trans._catalog)\n97                 break\n98         else:\n99             self._catalogs.insert(0, trans._catalog.copy())\n100             self._plurals.insert(0, trans.plural)\n101 \n102     def get(self, key, default=None):\n103         missing = object()\n104         for cat in self._catalogs:\n105             result = cat.get(key, missing)\n106             if result is not missing:\n107                 return result\n108         return default\n109 \n110     def plural(self, msgid, num):\n111         for cat, plural in zip(self._catalogs, self._plurals):\n112             tmsg = cat.get((msgid, plural(num)))\n113             if tmsg is not None:\n114                 return tmsg\n115         raise KeyError\n116 \n117 \n118 class DjangoTranslation(gettext_module.GNUTranslations):\n119     \"\"\"\n120     Set up the GNUTranslations context with regard to output charset.\n121 \n122     This translation object will be constructed out of multiple GNUTranslations\n123     objects by merging their catalogs. It will construct an object for the\n124     requested language and add a fallback to the default language, if it's\n125     different from the requested language.\n126     \"\"\"\n127     domain = 'django'\n128 \n129     def __init__(self, language, domain=None, localedirs=None):\n130         \"\"\"Create a GNUTranslations() using many locale directories\"\"\"\n131         gettext_module.GNUTranslations.__init__(self)\n132         if domain is not None:\n133             self.domain = domain\n134 \n135         self.__language = language\n136         self.__to_language = to_language(language)\n137         self.__locale = to_locale(language)\n138         self._catalog = None\n139         # If a language doesn't have a catalog, use the Germanic default for\n140         # pluralization: anything except one is pluralized.\n141         self.plural = lambda n: int(n != 1)\n142 \n143         if self.domain == 'django':\n144             if localedirs is not None:\n145                 # A module-level cache is used for caching 'django' translations\n146                 warnings.warn(\"localedirs is ignored when domain is 'django'.\", RuntimeWarning)\n147                 localedirs = None\n148             self._init_translation_catalog()\n149 \n150         if localedirs:\n151             for localedir in localedirs:\n152                 translation = self._new_gnu_trans(localedir)\n153                 self.merge(translation)\n154         else:\n155             self._add_installed_apps_translations()\n156 \n157         self._add_local_translations()\n158         if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and self._catalog is None:\n159             # default lang should have at least one translation file available.\n160             raise OSError('No translation files found for default language %s.' % settings.LANGUAGE_CODE)\n161         self._add_fallback(localedirs)\n162         if self._catalog is None:\n163             # No catalogs found for this language, set an empty catalog.\n164             self._catalog = TranslationCatalog()\n165 \n166     def __repr__(self):\n167         return \"<DjangoTranslation lang:%s>\" % self.__language\n168 \n169     def _new_gnu_trans(self, localedir, use_null_fallback=True):\n170         \"\"\"\n171         Return a mergeable gettext.GNUTranslations instance.\n172 \n173         A convenience wrapper. By default gettext uses 'fallback=False'.\n174         Using param `use_null_fallback` to avoid confusion with any other\n175         references to 'fallback'.\n176         \"\"\"\n177         return gettext_module.translation(\n178             domain=self.domain,\n179             localedir=localedir,\n180             languages=[self.__locale],\n181             fallback=use_null_fallback,\n182         )\n183 \n184     def _init_translation_catalog(self):\n185         \"\"\"Create a base catalog using global django translations.\"\"\"\n186         settingsfile = sys.modules[settings.__module__].__file__\n187         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')\n188         translation = self._new_gnu_trans(localedir)\n189         self.merge(translation)\n190 \n191     def _add_installed_apps_translations(self):\n192         \"\"\"Merge translations from each installed app.\"\"\"\n193         try:\n194             app_configs = reversed(list(apps.get_app_configs()))\n195         except AppRegistryNotReady:\n196             raise AppRegistryNotReady(\n197                 \"The translation infrastructure cannot be initialized before the \"\n198                 \"apps registry is ready. Check that you don't make non-lazy \"\n199                 \"gettext calls at import time.\")\n200         for app_config in app_configs:\n201             localedir = os.path.join(app_config.path, 'locale')\n202             if os.path.exists(localedir):\n203                 translation = self._new_gnu_trans(localedir)\n204                 self.merge(translation)\n205 \n206     def _add_local_translations(self):\n207         \"\"\"Merge translations defined in LOCALE_PATHS.\"\"\"\n208         for localedir in reversed(settings.LOCALE_PATHS):\n209             translation = self._new_gnu_trans(localedir)\n210             self.merge(translation)\n211 \n212     def _add_fallback(self, localedirs=None):\n213         \"\"\"Set the GNUTranslations() fallback with the default language.\"\"\"\n214         # Don't set a fallback for the default language or any English variant\n215         # (as it's empty, so it'll ALWAYS fall back to the default language)\n216         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):\n217             return\n218         if self.domain == 'django':\n219             # Get from cache\n220             default_translation = translation(settings.LANGUAGE_CODE)\n221         else:\n222             default_translation = DjangoTranslation(\n223                 settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs\n224             )\n225         self.add_fallback(default_translation)\n226 \n227     def merge(self, other):\n228         \"\"\"Merge another translation into this catalog.\"\"\"\n229         if not getattr(other, '_catalog', None):\n230             return  # NullTranslations() has no _catalog\n231         if self._catalog is None:\n232             # Take plural and _info from first catalog found (generally Django's).\n233             self.plural = other.plural\n234             self._info = other._info.copy()\n235             self._catalog = TranslationCatalog(other)\n236         else:\n237             self._catalog.update(other)\n238         if other._fallback:\n239             self.add_fallback(other._fallback)\n240 \n241     def language(self):\n242         \"\"\"Return the translation language.\"\"\"\n243         return self.__language\n244 \n245     def to_language(self):\n246         \"\"\"Return the translation language name.\"\"\"\n247         return self.__to_language\n248 \n249     def ngettext(self, msgid1, msgid2, n):\n250         try:\n251             tmsg = self._catalog.plural(msgid1, n)\n252         except KeyError:\n253             if self._fallback:\n254                 return self._fallback.ngettext(msgid1, msgid2, n)\n255             if n == 1:\n256                 tmsg = msgid1\n257             else:\n258                 tmsg = msgid2\n259         return tmsg\n260 \n261 \n262 def translation(language):\n263     \"\"\"\n264     Return a translation object in the default 'django' domain.\n265     \"\"\"\n266     global _translations\n267     if language not in _translations:\n268         _translations[language] = DjangoTranslation(language)\n269     return _translations[language]\n270 \n271 \n272 def activate(language):\n273     \"\"\"\n274     Fetch the translation object for a given language and install it as the\n275     current translation object for the current thread.\n276     \"\"\"\n277     if not language:\n278         return\n279     _active.value = translation(language)\n280 \n281 \n282 def deactivate():\n283     \"\"\"\n284     Uninstall the active translation object so that further _() calls resolve\n285     to the default translation object.\n286     \"\"\"\n287     if hasattr(_active, \"value\"):\n288         del _active.value\n289 \n290 \n291 def deactivate_all():\n292     \"\"\"\n293     Make the active translation object a NullTranslations() instance. This is\n294     useful when we want delayed translations to appear as the original string\n295     for some reason.\n296     \"\"\"\n297     _active.value = gettext_module.NullTranslations()\n298     _active.value.to_language = lambda *args: None\n299 \n300 \n301 def get_language():\n302     \"\"\"Return the currently selected language.\"\"\"\n303     t = getattr(_active, \"value\", None)\n304     if t is not None:\n305         try:\n306             return t.to_language()\n307         except AttributeError:\n308             pass\n309     # If we don't have a real translation object, assume it's the default language.\n310     return settings.LANGUAGE_CODE\n311 \n312 \n313 def get_language_bidi():\n314     \"\"\"\n315     Return selected language's BiDi layout.\n316 \n317     * False = left-to-right layout\n318     * True = right-to-left layout\n319     \"\"\"\n320     lang = get_language()\n321     if lang is None:\n322         return False\n323     else:\n324         base_lang = get_language().split('-')[0]\n325         return base_lang in settings.LANGUAGES_BIDI\n326 \n327 \n328 def catalog():\n329     \"\"\"\n330     Return the current active catalog for further processing.\n331     This can be used if you need to modify the catalog or want to access the\n332     whole message catalog instead of just translating one string.\n333     \"\"\"\n334     global _default\n335 \n336     t = getattr(_active, \"value\", None)\n337     if t is not None:\n338         return t\n339     if _default is None:\n340         _default = translation(settings.LANGUAGE_CODE)\n341     return _default\n342 \n343 \n344 def gettext(message):\n345     \"\"\"\n346     Translate the 'message' string. It uses the current thread to find the\n347     translation object to use. If no current translation is activated, the\n348     message will be run through the default translation object.\n349     \"\"\"\n350     global _default\n351 \n352     eol_message = message.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n353 \n354     if eol_message:\n355         _default = _default or translation(settings.LANGUAGE_CODE)\n356         translation_object = getattr(_active, \"value\", _default)\n357 \n358         result = translation_object.gettext(eol_message)\n359     else:\n360         # Return an empty value of the corresponding type if an empty message\n361         # is given, instead of metadata, which is the default gettext behavior.\n362         result = type(message)('')\n363 \n364     if isinstance(message, SafeData):\n365         return mark_safe(result)\n366 \n367     return result\n368 \n369 \n370 def pgettext(context, message):\n371     msg_with_ctxt = \"%s%s%s\" % (context, CONTEXT_SEPARATOR, message)\n372     result = gettext(msg_with_ctxt)\n373     if CONTEXT_SEPARATOR in result:\n374         # Translation not found\n375         result = message\n376     elif isinstance(message, SafeData):\n377         result = mark_safe(result)\n378     return result\n379 \n380 \n381 def gettext_noop(message):\n382     \"\"\"\n383     Mark strings for translation but don't translate them now. This can be\n384     used to store strings in global variables that should stay in the base\n385     language (because they might be used externally) and will be translated\n386     later.\n387     \"\"\"\n388     return message\n389 \n390 \n391 def do_ntranslate(singular, plural, number, translation_function):\n392     global _default\n393 \n394     t = getattr(_active, \"value\", None)\n395     if t is not None:\n396         return getattr(t, translation_function)(singular, plural, number)\n397     if _default is None:\n398         _default = translation(settings.LANGUAGE_CODE)\n399     return getattr(_default, translation_function)(singular, plural, number)\n400 \n401 \n402 def ngettext(singular, plural, number):\n403     \"\"\"\n404     Return a string of the translation of either the singular or plural,\n405     based on the number.\n406     \"\"\"\n407     return do_ntranslate(singular, plural, number, 'ngettext')\n408 \n409 \n410 def npgettext(context, singular, plural, number):\n411     msgs_with_ctxt = (\"%s%s%s\" % (context, CONTEXT_SEPARATOR, singular),\n412                       \"%s%s%s\" % (context, CONTEXT_SEPARATOR, plural),\n413                       number)\n414     result = ngettext(*msgs_with_ctxt)\n415     if CONTEXT_SEPARATOR in result:\n416         # Translation not found\n417         result = ngettext(singular, plural, number)\n418     return result\n419 \n420 \n421 def all_locale_paths():\n422     \"\"\"\n423     Return a list of paths to user-provides languages files.\n424     \"\"\"\n425     globalpath = os.path.join(\n426         os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')\n427     app_paths = []\n428     for app_config in apps.get_app_configs():\n429         locale_path = os.path.join(app_config.path, 'locale')\n430         if os.path.exists(locale_path):\n431             app_paths.append(locale_path)\n432     return [globalpath, *settings.LOCALE_PATHS, *app_paths]\n433 \n434 \n435 @functools.lru_cache(maxsize=1000)\n436 def check_for_language(lang_code):\n437     \"\"\"\n438     Check whether there is a global language file for the given language\n439     code. This is used to decide whether a user-provided language is\n440     available.\n441 \n442     lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n443     as the provided language codes are taken from the HTTP request. See also\n444     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n445     \"\"\"\n446     # First, a quick check to make sure lang_code is well-formed (#21458)\n447     if lang_code is None or not language_code_re.search(lang_code):\n448         return False\n449     return any(\n450         gettext_module.find('django', path, [to_locale(lang_code)]) is not None\n451         for path in all_locale_paths()\n452     )\n453 \n454 \n455 @functools.lru_cache()\n456 def get_languages():\n457     \"\"\"\n458     Cache of settings.LANGUAGES in a dictionary for easy lookups by key.\n459     \"\"\"\n460     return dict(settings.LANGUAGES)\n461 \n462 \n463 @functools.lru_cache(maxsize=1000)\n464 def get_supported_language_variant(lang_code, strict=False):\n465     \"\"\"\n466     Return the language code that's listed in supported languages, possibly\n467     selecting a more generic variant. Raise LookupError if nothing is found.\n468 \n469     If `strict` is False (the default), look for a country-specific variant\n470     when neither the language code nor its generic variant is found.\n471 \n472     lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n473     as the provided language codes are taken from the HTTP request. See also\n474     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n475     \"\"\"\n476     if lang_code:\n477         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.\n478         possible_lang_codes = [lang_code]\n479         try:\n480             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])\n481         except KeyError:\n482             pass\n483         generic_lang_code = lang_code.split('-')[0]\n484         possible_lang_codes.append(generic_lang_code)\n485         supported_lang_codes = get_languages()\n486 \n487         for code in possible_lang_codes:\n488             if code in supported_lang_codes and check_for_language(code):\n489                 return code\n490         if not strict:\n491             # if fr-fr is not supported, try fr-ca.\n492             for supported_code in supported_lang_codes:\n493                 if supported_code.startswith(generic_lang_code + '-'):\n494                     return supported_code\n495     raise LookupError(lang_code)\n496 \n497 \n498 def get_language_from_path(path, strict=False):\n499     \"\"\"\n500     Return the language code if there's a valid language code found in `path`.\n501 \n502     If `strict` is False (the default), look for a country-specific variant\n503     when neither the language code nor its generic variant is found.\n504     \"\"\"\n505     regex_match = language_code_prefix_re.match(path)\n506     if not regex_match:\n507         return None\n508     lang_code = regex_match[1]\n509     try:\n510         return get_supported_language_variant(lang_code, strict=strict)\n511     except LookupError:\n512         return None\n513 \n514 \n515 def get_language_from_request(request, check_path=False):\n516     \"\"\"\n517     Analyze the request to find what language the user wants the system to\n518     show. Only languages listed in settings.LANGUAGES are taken into account.\n519     If the user requests a sublanguage where we have a main language, we send\n520     out the main language.\n521 \n522     If check_path is True, the URL path prefix will be checked for a language\n523     code, otherwise this is skipped for backwards compatibility.\n524     \"\"\"\n525     if check_path:\n526         lang_code = get_language_from_path(request.path_info)\n527         if lang_code is not None:\n528             return lang_code\n529 \n530     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)\n531     if lang_code is not None and lang_code in get_languages() and check_for_language(lang_code):\n532         return lang_code\n533 \n534     try:\n535         return get_supported_language_variant(lang_code)\n536     except LookupError:\n537         pass\n538 \n539     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')\n540     for accept_lang, unused in parse_accept_lang_header(accept):\n541         if accept_lang == '*':\n542             break\n543 \n544         if not language_code_re.search(accept_lang):\n545             continue\n546 \n547         try:\n548             return get_supported_language_variant(accept_lang)\n549         except LookupError:\n550             continue\n551 \n552     try:\n553         return get_supported_language_variant(settings.LANGUAGE_CODE)\n554     except LookupError:\n555         return settings.LANGUAGE_CODE\n556 \n557 \n558 @functools.lru_cache(maxsize=1000)\n559 def parse_accept_lang_header(lang_string):\n560     \"\"\"\n561     Parse the lang_string, which is the body of an HTTP Accept-Language\n562     header, and return a tuple of (lang, q-value), ordered by 'q' values.\n563 \n564     Return an empty tuple if there are any format errors in lang_string.\n565     \"\"\"\n566     result = []\n567     pieces = accept_language_re.split(lang_string.lower())\n568     if pieces[-1]:\n569         return ()\n570     for i in range(0, len(pieces) - 1, 3):\n571         first, lang, priority = pieces[i:i + 3]\n572         if first:\n573             return ()\n574         if priority:\n575             priority = float(priority)\n576         else:\n577             priority = 1.0\n578         result.append((lang, priority))\n579     result.sort(key=lambda k: k[1], reverse=True)\n580     return tuple(result)\n",
        "intended_behavior": "Adjust to ensure proper handling and fallback for 'LOCALE_PATHS' to include sensible defaults, such as considering a 'locale' directory at the same level as 'manage.py' if not explicitly defined in 'LOCALE_PATHS'. Preserve current functionality while providing flexibility for translation file paths setup or adjustment."
    }
]