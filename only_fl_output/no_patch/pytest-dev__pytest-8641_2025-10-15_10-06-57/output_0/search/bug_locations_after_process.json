[
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.3/src/_pytest/logging.py",
        "start": 49,
        "end": 92,
        "class_name": "ColoredLevelFormatter",
        "method_name": null,
        "code": "49 class ColoredLevelFormatter(logging.Formatter):\n50     \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n51     log format passed to __init__.\"\"\"\n52 \n53     LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n54         logging.CRITICAL: {\"red\"},\n55         logging.ERROR: {\"red\", \"bold\"},\n56         logging.WARNING: {\"yellow\"},\n57         logging.WARN: {\"yellow\"},\n58         logging.INFO: {\"green\"},\n59         logging.DEBUG: {\"purple\"},\n60         logging.NOTSET: set(),\n61     }\n62     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n63 \n64     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n65         super().__init__(*args, **kwargs)\n66         self._original_fmt = self._style._fmt\n67         self._level_to_fmt_mapping: Dict[int, str] = {}\n68 \n69         assert self._fmt is not None\n70         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n71         if not levelname_fmt_match:\n72             return\n73         levelname_fmt = levelname_fmt_match.group()\n74 \n75         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n76             formatted_levelname = levelname_fmt % {\n77                 \"levelname\": logging.getLevelName(level)\n78             }\n79 \n80             # add ANSI escape sequences around the formatted levelname\n81             color_kwargs = {name: True for name in color_opts}\n82             colorized_formatted_levelname = terminalwriter.markup(\n83                 formatted_levelname, **color_kwargs\n84             )\n85             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n86                 colorized_formatted_levelname, self._fmt\n87             )\n88 \n89     def format(self, record: logging.LogRecord) -> str:\n90         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n91         self._style._fmt = fmt\n92         return super().format(record)\n",
        "intended_behavior": "The regex pattern LEVELNAME_FMT_REGEX should be updated to also match precision-format specifiers within format strings. This means modifying the regex to something that can handle the precision part (.) followed by a number within the formatting options. A potential update could be r\"%\\(levelname\\)([+-.]?\\d*\\.?\\d*s)\", which now includes an optional dot followed by optional digits, preceding the s specifier. This change is expected to enable the ColoredLevelFormatter to correctly identify and process levelname tokens with precision formatting, allowing for the intended colorful output of log level names even when precision formatting is used, hence preserving the existing functionality while fixing the issue of not coloring logs with precision-formatted level names."
    },
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.3/src/_pytest/logging.py",
        "start": 89,
        "end": 92,
        "class_name": "ColoredLevelFormatter",
        "method_name": "format",
        "code": "89     def format(self, record: logging.LogRecord) -> str:\n90         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n91         self._style._fmt = fmt\n92         return super().format(record)\n",
        "intended_behavior": "While the specific change in the regex might be sufficient to address the issue, ensuring that the format method properly utilizes the updated LEVELNAME_FMT_REGEX to detect and format level names with or without precision formatting correctly is crucial. While no specific change is suggested at this method based on the provided context, it's important to verify and ensure that after updating the regex, the format method applies the intended styling accurately and maintains compatibility with all possible logging format specifications. This ensures that the color formatting feature of pytest logging remains robust and flexible, accommodating a wider range of format string specifications."
    },
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.3/src/_pytest/logging.py",
        "start": 49,
        "end": 92,
        "class_name": "ColoredLevelFormatter",
        "method_name": null,
        "code": "49 class ColoredLevelFormatter(logging.Formatter):\n50     \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n51     log format passed to __init__.\"\"\"\n52 \n53     LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n54         logging.CRITICAL: {\"red\"},\n55         logging.ERROR: {\"red\", \"bold\"},\n56         logging.WARNING: {\"yellow\"},\n57         logging.WARN: {\"yellow\"},\n58         logging.INFO: {\"green\"},\n59         logging.DEBUG: {\"purple\"},\n60         logging.NOTSET: set(),\n61     }\n62     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n63 \n64     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n65         super().__init__(*args, **kwargs)\n66         self._original_fmt = self._style._fmt\n67         self._level_to_fmt_mapping: Dict[int, str] = {}\n68 \n69         assert self._fmt is not None\n70         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n71         if not levelname_fmt_match:\n72             return\n73         levelname_fmt = levelname_fmt_match.group()\n74 \n75         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n76             formatted_levelname = levelname_fmt % {\n77                 \"levelname\": logging.getLevelName(level)\n78             }\n79 \n80             # add ANSI escape sequences around the formatted levelname\n81             color_kwargs = {name: True for name in color_opts}\n82             colorized_formatted_levelname = terminalwriter.markup(\n83                 formatted_levelname, **color_kwargs\n84             )\n85             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n86                 colorized_formatted_levelname, self._fmt\n87             )\n88 \n89     def format(self, record: logging.LogRecord) -> str:\n90         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n91         self._style._fmt = fmt\n92         return super().format(record)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]