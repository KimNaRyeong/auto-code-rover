2025-10-15 04:37:03.347 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 04:37:08.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=164, output_tokens=12, cost=0.002000
2025-10-15 04:37:08.689 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 04:37:08.693 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:37:19.609 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=472, output_tokens=348, cost=0.015160
2025-10-15 04:37:19.615 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:37:22.092 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=53, cost=0.008610
2025-10-15 04:37:22.094 | DEBUG    | Extracted a valid json.
2025-10-15 04:37:22.094 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"DatabaseOperations\")",
        "search_method_in_class(\"execute_sql_flush\", \"DatabaseOperations\")",
        "search_code(\"execute_sql_flush(connection.alias\")"
    ],
    "bug_locations": []
}
2025-10-15 04:37:22.149 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 04:37:22.150 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 04:37:35.223 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1113, output_tokens=616, cost=0.029610
2025-10-15 04:37:35.235 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 04:37:46.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1945, output_tokens=444, cost=0.032770
2025-10-15 04:37:46.054 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 04:37:50.639 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=798, output_tokens=141, cost=0.012210
2025-10-15 04:37:50.640 | DEBUG    | Extracted a valid json.
2025-10-15 04:37:50.640 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/backends/<db_backend>/operations.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "Within each identified `execute_sql_flush` method across the different backends, the `using` parameter should be removed. The method's functionality should be preserved by relying on `self.connection.alias` to access the database alias internally. Ensure that all internal uses of `execute_sql_flush` are refactored to omit the previously required `using` argument, reflecting the simplification of the method's signature."
        }
    ]
}
2025-10-15 04:37:50.648 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     cast_char_field_without_max_length = 'text'
20     cast_data_types = {
21         'DateField': 'TEXT',
22         'DateTimeField': 'TEXT',
23     }
24     explain_prefix = 'EXPLAIN QUERY PLAN'
25 
26     def bulk_batch_size(self, fields, objs):
27         """
28         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of
29         999 variables per query.
30 
31         If there's only a single field to insert, the limit is 500
32         (SQLITE_MAX_COMPOUND_SELECT).
33         """
34         if len(fields) == 1:
35             return 500
36         elif len(fields) > 1:
37             return self.connection.features.max_query_params // len(fields)
38         else:
39             return len(objs)
40 
41     def check_expression_support(self, expression):
42         bad_fields = (models.DateField, models.DateTimeField, models.TimeField)
43         bad_aggregates = (models.Sum, models.Avg, models.Variance, models.StdDev)
44         if isinstance(expression, bad_aggregates):
45             for expr in expression.get_source_expressions():
46                 try:
47                     output_field = expr.output_field
48                 except (AttributeError, FieldError):
49                     # Not every subexpression has an output_field which is fine
50                     # to ignore.
51                     pass
52                 else:
53                     if isinstance(output_field, bad_fields):
54                         raise NotSupportedError(
55                             'You cannot use Sum, Avg, StdDev, and Variance '
56                             'aggregations on date/time fields in sqlite3 '
57                             'since date/time is saved as text.'
58                         )
59         if (
60             isinstance(expression, models.Aggregate) and
61             expression.distinct and
62             len(expression.source_expressions) > 1
63         ):
64             raise NotSupportedError(
65                 "SQLite doesn't support DISTINCT on aggregate functions "
66                 "accepting multiple arguments."
67             )
68 
69     def date_extract_sql(self, lookup_type, field_name):
70         """
71         Support EXTRACT with a user-defined function django_date_extract()
72         that's registered in connect(). Use single quotes because this is a
73         string and could otherwise cause a collision with a field name.
74         """
75         return "django_date_extract('%s', %s)" % (lookup_type.lower(), field_name)
76 
77     def date_interval_sql(self, timedelta):
78         return str(duration_microseconds(timedelta))
79 
80     def format_for_duration_arithmetic(self, sql):
81         """Do nothing since formatting is handled in the custom function."""
82         return sql
83 
84     def date_trunc_sql(self, lookup_type, field_name):
85         return "django_date_trunc('%s', %s)" % (lookup_type.lower(), field_name)
86 
87     def time_trunc_sql(self, lookup_type, field_name):
88         return "django_time_trunc('%s', %s)" % (lookup_type.lower(), field_name)
89 
90     def _convert_tznames_to_sql(self, tzname):
91         if settings.USE_TZ:
92             return "'%s'" % tzname, "'%s'" % self.connection.timezone_name
93         return 'NULL', 'NULL'
94 
95     def datetime_cast_date_sql(self, field_name, tzname):
96         return 'django_datetime_cast_date(%s, %s, %s)' % (
97             field_name, *self._convert_tznames_to_sql(tzname),
98         )
99 
100     def datetime_cast_time_sql(self, field_name, tzname):
101         return 'django_datetime_cast_time(%s, %s, %s)' % (
102             field_name, *self._convert_tznames_to_sql(tzname),
103         )
104 
105     def datetime_extract_sql(self, lookup_type, field_name, tzname):
106         return "django_datetime_extract('%s', %s, %s, %s)" % (
107             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
108         )
109 
110     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
111         return "django_datetime_trunc('%s', %s, %s, %s)" % (
112             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
113         )
114 
115     def time_extract_sql(self, lookup_type, field_name):
116         return "django_time_extract('%s', %s)" % (lookup_type.lower(), field_name)
117 
118     def pk_default_value(self):
119         return "NULL"
120 
121     def _quote_params_for_last_executed_query(self, params):
122         """
123         Only for last_executed_query! Don't use this to execute SQL queries!
124         """
125         # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the
126         # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the
127         # number of return values, default = 2000). Since Python's sqlite3
128         # module doesn't expose the get_limit() C API, assume the default
129         # limits are in effect and split the work in batches if needed.
130         BATCH_SIZE = 999
131         if len(params) > BATCH_SIZE:
132             results = ()
133             for index in range(0, len(params), BATCH_SIZE):
134                 chunk = params[index:index + BATCH_SIZE]
135                 results += self._quote_params_for_last_executed_query(chunk)
136             return results
137 
138         sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))
139         # Bypass Django's wrappers and use the underlying sqlite3 connection
140         # to avoid logging this query - it would trigger infinite recursion.
141         cursor = self.connection.connection.cursor()
142         # Native sqlite3 cursors cannot be used as context managers.
143         try:
144             return cursor.execute(sql, params).fetchone()
145         finally:
146             cursor.close()
147 
148     def last_executed_query(self, cursor, sql, params):
149         # Python substitutes parameters in Modules/_sqlite/cursor.c with:
150         # pysqlite_statement_bind_parameters(self->statement, parameters, allow_8bit_chars);
151         # Unfortunately there is no way to reach self->statement from Python,
152         # so we quote and substitute parameters manually.
153         if params:
154             if isinstance(params, (list, tuple)):
155                 params = self._quote_params_for_last_executed_query(params)
156             else:
157                 values = tuple(params.values())
158                 values = self._quote_params_for_last_executed_query(values)
159                 params = dict(zip(params, values))
160             return sql % params
161         # For consistency with SQLiteCursorWrapper.execute(), just return sql
162         # when there are no parameters. See #13648 and #17158.
163         else:
164             return sql
165 
166     def quote_name(self, name):
167         if name.startswith('"') and name.endswith('"'):
168             return name  # Quoting once is enough.
169         return '"%s"' % name
170 
171     def no_limit_value(self):
172         return -1
173 
174     def __references_graph(self, table_name):
175         query = """
176         WITH tables AS (
177             SELECT %s name
178             UNION
179             SELECT sqlite_master.name
180             FROM sqlite_master
181             JOIN tables ON (sql REGEXP %s || tables.name || %s)
182         ) SELECT name FROM tables;
183         """
184         params = (
185             table_name,
186             r'(?i)\s+references\s+("|\')?',
187             r'("|\')?\s*\(',
188         )
189         with self.connection.cursor() as cursor:
190             results = cursor.execute(query, params)
191             return [row[0] for row in results.fetchall()]
192 
193     @cached_property
194     def _references_graph(self):
195         # 512 is large enough to fit the ~330 tables (as of this writing) in
196         # Django's test suite.
197         return lru_cache(maxsize=512)(self.__references_graph)
198 
199     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
200         if tables and allow_cascade:
201             # Simulate TRUNCATE CASCADE by recursively collecting the tables
202             # referencing the tables to be flushed.
203             tables = set(chain.from_iterable(self._references_graph(table) for table in tables))
204         # Note: No requirement for reset of auto-incremented indices (cf. other
205         # sql_flush() implementations). Just return SQL at this point
206         return ['%s %s %s;' % (
207             style.SQL_KEYWORD('DELETE'),
208             style.SQL_KEYWORD('FROM'),
209             style.SQL_FIELD(self.quote_name(table))
210         ) for table in tables]
211 
212     def adapt_datetimefield_value(self, value):
213         if value is None:
214             return None
215 
216         # Expression values are adapted by the database.
217         if hasattr(value, 'resolve_expression'):
218             return value
219 
220         # SQLite doesn't support tz-aware datetimes
221         if timezone.is_aware(value):
222             if settings.USE_TZ:
223                 value = timezone.make_naive(value, self.connection.timezone)
224             else:
225                 raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False.")
226 
227         return str(value)
228 
229     def adapt_timefield_value(self, value):
230         if value is None:
231             return None
232 
233         # Expression values are adapted by the database.
234         if hasattr(value, 'resolve_expression'):
235             return value
236 
237         # SQLite doesn't support tz-aware datetimes
238         if timezone.is_aware(value):
239             raise ValueError("SQLite backend does not support timezone-aware times.")
240 
241         return str(value)
242 
243     def get_db_converters(self, expression):
244         converters = super().get_db_converters(expression)
245         internal_type = expression.output_field.get_internal_type()
246         if internal_type == 'DateTimeField':
247             converters.append(self.convert_datetimefield_value)
248         elif internal_type == 'DateField':
249             converters.append(self.convert_datefield_value)
250         elif internal_type == 'TimeField':
251             converters.append(self.convert_timefield_value)
252         elif internal_type == 'DecimalField':
253             converters.append(self.get_decimalfield_converter(expression))
254         elif internal_type == 'UUIDField':
255             converters.append(self.convert_uuidfield_value)
256         elif internal_type in ('NullBooleanField', 'BooleanField'):
257             converters.append(self.convert_booleanfield_value)
258         return converters
259 
260     def convert_datetimefield_value(self, value, expression, connection):
261         if value is not None:
262             if not isinstance(value, datetime.datetime):
263                 value = parse_datetime(value)
264             if settings.USE_TZ and not timezone.is_aware(value):
265                 value = timezone.make_aware(value, self.connection.timezone)
266         return value
267 
268     def convert_datefield_value(self, value, expression, connection):
269         if value is not None:
270             if not isinstance(value, datetime.date):
271                 value = parse_date(value)
272         return value
273 
274     def convert_timefield_value(self, value, expression, connection):
275         if value is not None:
276             if not isinstance(value, datetime.time):
277                 value = parse_time(value)
278         return value
279 
280     def get_decimalfield_converter(self, expression):
281         # SQLite stores only 15 significant digits. Digits coming from
282         # float inaccuracy must be removed.
283         create_decimal = decimal.Context(prec=15).create_decimal_from_float
284         if isinstance(expression, Col):
285             quantize_value = decimal.Decimal(1).scaleb(-expression.output_field.decimal_places)
286 
287             def converter(value, expression, connection):
288                 if value is not None:
289                     return create_decimal(value).quantize(quantize_value, context=expression.output_field.context)
290         else:
291             def converter(value, expression, connection):
292                 if value is not None:
293                     return create_decimal(value)
294         return converter
295 
296     def convert_uuidfield_value(self, value, expression, connection):
297         if value is not None:
298             value = uuid.UUID(value)
299         return value
300 
301     def convert_booleanfield_value(self, value, expression, connection):
302         return bool(value) if value in (1, 0) else value
303 
304     def bulk_insert_sql(self, fields, placeholder_rows):
305         return " UNION ALL ".join(
306             "SELECT %s" % ", ".join(row)
307             for row in placeholder_rows
308         )
309 
310     def combine_expression(self, connector, sub_expressions):
311         # SQLite doesn't have a ^ operator, so use the user-defined POWER
312         # function that's registered in connect().
313         if connector == '^':
314             return 'POWER(%s)' % ','.join(sub_expressions)
315         elif connector == '#':
316             return 'BITXOR(%s)' % ','.join(sub_expressions)
317         return super().combine_expression(connector, sub_expressions)
318 
319     def combine_duration_expression(self, connector, sub_expressions):
320         if connector not in ['+', '-']:
321             raise DatabaseError('Invalid connector for timedelta: %s.' % connector)
322         fn_params = ["'%s'" % connector] + sub_expressions
323         if len(fn_params) > 3:
324             raise ValueError('Too many params for timedelta operations.')
325         return "django_format_dtdelta(%s)" % ', '.join(fn_params)
326 
327     def integer_field_range(self, internal_type):
328         # SQLite doesn't enforce any integer constraints
329         return (None, None)
330 
331     def subtract_temporals(self, internal_type, lhs, rhs):
332         lhs_sql, lhs_params = lhs
333         rhs_sql, rhs_params = rhs
334         params = (*lhs_params, *rhs_params)
335         if internal_type == 'TimeField':
336             return 'django_time_diff(%s, %s)' % (lhs_sql, rhs_sql), params
337         return 'django_timestamp_diff(%s, %s)' % (lhs_sql, rhs_sql), params
338 
339     def insert_statement(self, ignore_conflicts=False):
340         return 'INSERT OR IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>Within each identified `execute_sql_flush` method across the different backends, the `using` parameter should be removed. The method's functionality should be preserved by relying on `self.connection.alias` to access the database alias internally. Ensure that all internal uses of `execute_sql_flush` are refactored to omit the previously required `using` argument, reflecting the simplification of the method's signature.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
21 class DatabaseOperations(BaseDatabaseOperations):
22     # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.
23     # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by
24     # SmallAutoField, to preserve backward compatibility.
25     integer_field_ranges = {
26         'SmallIntegerField': (-99999999999, 99999999999),
27         'IntegerField': (-99999999999, 99999999999),
28         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
29         'PositiveBigIntegerField': (0, 9999999999999999999),
30         'PositiveSmallIntegerField': (0, 99999999999),
31         'PositiveIntegerField': (0, 99999999999),
32         'SmallAutoField': (-99999, 99999),
33         'AutoField': (-99999999999, 99999999999),
34         'BigAutoField': (-9999999999999999999, 9999999999999999999),
35     }
36     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
37 
38     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
39     _sequence_reset_sql = """
40 DECLARE
41     table_value integer;
42     seq_value integer;
43     seq_name user_tab_identity_cols.sequence_name%%TYPE;
44 BEGIN
45     BEGIN
46         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
47         WHERE  table_name = '%(table_name)s' AND
48                column_name = '%(column_name)s';
49         EXCEPTION WHEN NO_DATA_FOUND THEN
50             seq_name := '%(no_autofield_sequence_name)s';
51     END;
52 
53     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
54     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
55            WHERE sequence_name = seq_name;
56     WHILE table_value > seq_value LOOP
57         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
58         INTO seq_value;
59     END LOOP;
60 END;
61 /"""
62 
63     # Oracle doesn't support string without precision; use the max string size.
64     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
65     cast_data_types = {
66         'AutoField': 'NUMBER(11)',
67         'BigAutoField': 'NUMBER(19)',
68         'SmallAutoField': 'NUMBER(5)',
69         'TextField': cast_char_field_without_max_length,
70     }
71 
72     def cache_key_culling_sql(self):
73         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
74 
75     def date_extract_sql(self, lookup_type, field_name):
76         if lookup_type == 'week_day':
77             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
78             return "TO_CHAR(%s, 'D')" % field_name
79         elif lookup_type == 'iso_week_day':
80             return "TO_CHAR(%s - 1, 'D')" % field_name
81         elif lookup_type == 'week':
82             # IW = ISO week number
83             return "TO_CHAR(%s, 'IW')" % field_name
84         elif lookup_type == 'quarter':
85             return "TO_CHAR(%s, 'Q')" % field_name
86         elif lookup_type == 'iso_year':
87             return "TO_CHAR(%s, 'IYYY')" % field_name
88         else:
89             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
90             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
91 
92     def date_trunc_sql(self, lookup_type, field_name):
93         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
94         if lookup_type in ('year', 'month'):
95             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
96         elif lookup_type == 'quarter':
97             return "TRUNC(%s, 'Q')" % field_name
98         elif lookup_type == 'week':
99             return "TRUNC(%s, 'IW')" % field_name
100         else:
101             return "TRUNC(%s)" % field_name
102 
103     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
104     # if the time zone name is passed in parameter. Use interpolation instead.
105     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
106     # This regexp matches all time zone names from the zoneinfo database.
107     _tzname_re = _lazy_re_compile(r'^[\w/:+-]+$')
108 
109     def _prepare_tzname_delta(self, tzname):
110         if '+' in tzname:
111             return tzname[tzname.find('+'):]
112         elif '-' in tzname:
113             return tzname[tzname.find('-'):]
114         return tzname
115 
116     def _convert_field_to_tz(self, field_name, tzname):
117         if not settings.USE_TZ:
118             return field_name
119         if not self._tzname_re.match(tzname):
120             raise ValueError("Invalid time zone name: %s" % tzname)
121         # Convert from connection timezone to the local time, returning
122         # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the
123         # TIME ZONE details.
124         if self.connection.timezone_name != tzname:
125             return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (
126                 field_name,
127                 self.connection.timezone_name,
128                 self._prepare_tzname_delta(tzname),
129             )
130         return field_name
131 
132     def datetime_cast_date_sql(self, field_name, tzname):
133         field_name = self._convert_field_to_tz(field_name, tzname)
134         return 'TRUNC(%s)' % field_name
135 
136     def datetime_cast_time_sql(self, field_name, tzname):
137         # Since `TimeField` values are stored as TIMESTAMP where only the date
138         # part is ignored, convert the field to the specified timezone.
139         return self._convert_field_to_tz(field_name, tzname)
140 
141     def datetime_extract_sql(self, lookup_type, field_name, tzname):
142         field_name = self._convert_field_to_tz(field_name, tzname)
143         return self.date_extract_sql(lookup_type, field_name)
144 
145     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
146         field_name = self._convert_field_to_tz(field_name, tzname)
147         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
148         if lookup_type in ('year', 'month'):
149             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
150         elif lookup_type == 'quarter':
151             sql = "TRUNC(%s, 'Q')" % field_name
152         elif lookup_type == 'week':
153             sql = "TRUNC(%s, 'IW')" % field_name
154         elif lookup_type == 'day':
155             sql = "TRUNC(%s)" % field_name
156         elif lookup_type == 'hour':
157             sql = "TRUNC(%s, 'HH24')" % field_name
158         elif lookup_type == 'minute':
159             sql = "TRUNC(%s, 'MI')" % field_name
160         else:
161             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
162         return sql
163 
164     def time_trunc_sql(self, lookup_type, field_name):
165         # The implementation is similar to `datetime_trunc_sql` as both
166         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
167         # the date part of the later is ignored.
168         if lookup_type == 'hour':
169             sql = "TRUNC(%s, 'HH24')" % field_name
170         elif lookup_type == 'minute':
171             sql = "TRUNC(%s, 'MI')" % field_name
172         elif lookup_type == 'second':
173             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
174         return sql
175 
176     def get_db_converters(self, expression):
177         converters = super().get_db_converters(expression)
178         internal_type = expression.output_field.get_internal_type()
179         if internal_type == 'TextField':
180             converters.append(self.convert_textfield_value)
181         elif internal_type == 'BinaryField':
182             converters.append(self.convert_binaryfield_value)
183         elif internal_type in ['BooleanField', 'NullBooleanField']:
184             converters.append(self.convert_booleanfield_value)
185         elif internal_type == 'DateTimeField':
186             if settings.USE_TZ:
187                 converters.append(self.convert_datetimefield_value)
188         elif internal_type == 'DateField':
189             converters.append(self.convert_datefield_value)
190         elif internal_type == 'TimeField':
191             converters.append(self.convert_timefield_value)
192         elif internal_type == 'UUIDField':
193             converters.append(self.convert_uuidfield_value)
194         # Oracle stores empty strings as null. If the field accepts the empty
195         # string, undo this to adhere to the Django convention of using
196         # the empty string instead of null.
197         if expression.field.empty_strings_allowed:
198             converters.append(
199                 self.convert_empty_bytes
200                 if internal_type == 'BinaryField' else
201                 self.convert_empty_string
202             )
203         return converters
204 
205     def convert_textfield_value(self, value, expression, connection):
206         if isinstance(value, Database.LOB):
207             value = value.read()
208         return value
209 
210     def convert_binaryfield_value(self, value, expression, connection):
211         if isinstance(value, Database.LOB):
212             value = force_bytes(value.read())
213         return value
214 
215     def convert_booleanfield_value(self, value, expression, connection):
216         if value in (0, 1):
217             value = bool(value)
218         return value
219 
220     # cx_Oracle always returns datetime.datetime objects for
221     # DATE and TIMESTAMP columns, but Django wants to see a
222     # python datetime.date, .time, or .datetime.
223 
224     def convert_datetimefield_value(self, value, expression, connection):
225         if value is not None:
226             value = timezone.make_aware(value, self.connection.timezone)
227         return value
228 
229     def convert_datefield_value(self, value, expression, connection):
230         if isinstance(value, Database.Timestamp):
231             value = value.date()
232         return value
233 
234     def convert_timefield_value(self, value, expression, connection):
235         if isinstance(value, Database.Timestamp):
236             value = value.time()
237         return value
238 
239     def convert_uuidfield_value(self, value, expression, connection):
240         if value is not None:
241             value = uuid.UUID(value)
242         return value
243 
244     @staticmethod
245     def convert_empty_string(value, expression, connection):
246         return '' if value is None else value
247 
248     @staticmethod
249     def convert_empty_bytes(value, expression, connection):
250         return b'' if value is None else value
251 
252     def deferrable_sql(self):
253         return " DEFERRABLE INITIALLY DEFERRED"
254 
255     def fetch_returned_insert_columns(self, cursor, returning_params):
256         columns = []
257         for param in returning_params:
258             value = param.get_value()
259             if value is None or value == []:
260                 # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
261                 raise DatabaseError(
262                     'The database did not return a new row id. Probably '
263                     '"ORA-1403: no data found" was raised internally but was '
264                     'hidden by the Oracle OCI library (see '
265                     'https://code.djangoproject.com/ticket/28859).'
266                 )
267             # cx_Oracle < 7 returns value, >= 7 returns list with single value.
268             columns.append(value[0] if isinstance(value, list) else value)
269         return tuple(columns)
270 
271     def field_cast_sql(self, db_type, internal_type):
272         if db_type and db_type.endswith('LOB'):
273             return "DBMS_LOB.SUBSTR(%s)"
274         else:
275             return "%s"
276 
277     def no_limit_value(self):
278         return None
279 
280     def limit_offset_sql(self, low_mark, high_mark):
281         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
282         return ' '.join(sql for sql in (
283             ('OFFSET %d ROWS' % offset) if offset else None,
284             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
285         ) if sql)
286 
287     def last_executed_query(self, cursor, sql, params):
288         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
289         # The DB API definition does not define this attribute.
290         statement = cursor.statement
291         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
292         # `statement` doesn't contain the query parameters. Substitute
293         # parameters manually.
294         if isinstance(params, (tuple, list)):
295             for i, param in enumerate(params):
296                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
297         elif isinstance(params, dict):
298             for key, param in params.items():
299                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
300         return statement
301 
302     def last_insert_id(self, cursor, table_name, pk_name):
303         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
304         cursor.execute('"%s".currval' % sq_name)
305         return cursor.fetchone()[0]
306 
307     def lookup_cast(self, lookup_type, internal_type=None):
308         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
309             return "UPPER(%s)"
310         return "%s"
311 
312     def max_in_list_size(self):
313         return 1000
314 
315     def max_name_length(self):
316         return 30
317 
318     def pk_default_value(self):
319         return "NULL"
320 
321     def prep_for_iexact_query(self, x):
322         return x
323 
324     def process_clob(self, value):
325         if value is None:
326             return ''
327         return value.read()
328 
329     def quote_name(self, name):
330         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
331         # not quoted, Oracle has case-insensitive behavior for identifiers, but
332         # always defaults to uppercase.
333         # We simplify things by making Oracle identifiers always uppercase.
334         if not name.startswith('"') and not name.endswith('"'):
335             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
336         # Oracle puts the query text into a (query % args) construct, so % signs
337         # in names need to be escaped. The '%%' will be collapsed back to '%' at
338         # that stage so we aren't really making the name longer here.
339         name = name.replace('%', '%%')
340         return name.upper()
341 
342     def random_function_sql(self):
343         return "DBMS_RANDOM.RANDOM"
344 
345     def regex_lookup(self, lookup_type):
346         if lookup_type == 'regex':
347             match_option = "'c'"
348         else:
349             match_option = "'i'"
350         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
351 
352     def return_insert_columns(self, fields):
353         if not fields:
354             return '', ()
355         field_names = []
356         params = []
357         for field in fields:
358             field_names.append('%s.%s' % (
359                 self.quote_name(field.model._meta.db_table),
360                 self.quote_name(field.column),
361             ))
362             params.append(InsertVar(field))
363         return 'RETURNING %s INTO %s' % (
364             ', '.join(field_names),
365             ', '.join(['%s'] * len(params)),
366         ), tuple(params)
367 
368     def __foreign_key_constraints(self, table_name, recursive):
369         with self.connection.cursor() as cursor:
370             if recursive:
371                 cursor.execute("""
372                     SELECT
373                         user_tables.table_name, rcons.constraint_name
374                     FROM
375                         user_tables
376                     JOIN
377                         user_constraints cons
378                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
379                     LEFT JOIN
380                         user_constraints rcons
381                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
382                     START WITH user_tables.table_name = UPPER(%s)
383                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
384                     GROUP BY
385                         user_tables.table_name, rcons.constraint_name
386                     HAVING user_tables.table_name != UPPER(%s)
387                     ORDER BY MAX(level) DESC
388                 """, (table_name, table_name))
389             else:
390                 cursor.execute("""
391                     SELECT
392                         cons.table_name, cons.constraint_name
393                     FROM
394                         user_constraints cons
395                     WHERE
396                         cons.constraint_type = 'R'
397                         AND cons.table_name = UPPER(%s)
398                 """, (table_name,))
399             return cursor.fetchall()
400 
401     @cached_property
402     def _foreign_key_constraints(self):
403         # 512 is large enough to fit the ~330 tables (as of this writing) in
404         # Django's test suite.
405         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
406 
407     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
408         if not tables:
409             return []
410 
411         truncated_tables = {table.upper() for table in tables}
412         constraints = set()
413         # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign
414         # keys which Django doesn't define. Emulate the PostgreSQL behavior
415         # which truncates all dependent tables by manually retrieving all
416         # foreign key constraints and resolving dependencies.
417         for table in tables:
418             for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
419                 if allow_cascade:
420                     truncated_tables.add(foreign_table)
421                 constraints.add((foreign_table, constraint))
422         sql = [
423             '%s %s %s %s %s %s %s %s;' % (
424                 style.SQL_KEYWORD('ALTER'),
425                 style.SQL_KEYWORD('TABLE'),
426                 style.SQL_FIELD(self.quote_name(table)),
427                 style.SQL_KEYWORD('DISABLE'),
428                 style.SQL_KEYWORD('CONSTRAINT'),
429                 style.SQL_FIELD(self.quote_name(constraint)),
430                 style.SQL_KEYWORD('KEEP'),
431                 style.SQL_KEYWORD('INDEX'),
432             ) for table, constraint in constraints
433         ] + [
434             '%s %s %s;' % (
435                 style.SQL_KEYWORD('TRUNCATE'),
436                 style.SQL_KEYWORD('TABLE'),
437                 style.SQL_FIELD(self.quote_name(table)),
438             ) for table in truncated_tables
439         ] + [
440             '%s %s %s %s %s %s;' % (
441                 style.SQL_KEYWORD('ALTER'),
442                 style.SQL_KEYWORD('TABLE'),
443                 style.SQL_FIELD(self.quote_name(table)),
444                 style.SQL_KEYWORD('ENABLE'),
445                 style.SQL_KEYWORD('CONSTRAINT'),
446                 style.SQL_FIELD(self.quote_name(constraint)),
447             ) for table, constraint in constraints
448         ]
449         if reset_sequences:
450             sequences = [
451                 sequence
452                 for sequence in self.connection.introspection.sequence_list()
453                 if sequence['table'].upper() in truncated_tables
454             ]
455             # Since we've just deleted all the rows, running our sequence ALTER
456             # code will reset the sequence to 0.
457             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
458         return sql
459 
460     def sequence_reset_by_name_sql(self, style, sequences):
461         sql = []
462         for sequence_info in sequences:
463             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
464             table = self.quote_name(sequence_info['table'])
465             column = self.quote_name(sequence_info['column'] or 'id')
466             query = self._sequence_reset_sql % {
467                 'no_autofield_sequence_name': no_autofield_sequence_name,
468                 'table': table,
469                 'column': column,
470                 'table_name': strip_quotes(table),
471                 'column_name': strip_quotes(column),
472             }
473             sql.append(query)
474         return sql
475 
476     def sequence_reset_sql(self, style, model_list):
477         output = []
478         query = self._sequence_reset_sql
479         for model in model_list:
480             for f in model._meta.local_fields:
481                 if isinstance(f, AutoField):
482                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
483                     table = self.quote_name(model._meta.db_table)
484                     column = self.quote_name(f.column)
485                     output.append(query % {
486                         'no_autofield_sequence_name': no_autofield_sequence_name,
487                         'table': table,
488                         'column': column,
489                         'table_name': strip_quotes(table),
490                         'column_name': strip_quotes(column),
491                     })
492                     # Only one AutoField is allowed per model, so don't
493                     # continue to loop
494                     break
495             for f in model._meta.many_to_many:
496                 if not f.remote_field.through:
497                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
498                     table = self.quote_name(f.m2m_db_table())
499                     column = self.quote_name('id')
500                     output.append(query % {
501                         'no_autofield_sequence_name': no_autofield_sequence_name,
502                         'table': table,
503                         'column': column,
504                         'table_name': strip_quotes(table),
505                         'column_name': 'ID',
506                     })
507         return output
508 
509     def start_transaction_sql(self):
510         return ''
511 
512     def tablespace_sql(self, tablespace, inline=False):
513         if inline:
514             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
515         else:
516             return "TABLESPACE %s" % self.quote_name(tablespace)
517 
518     def adapt_datefield_value(self, value):
519         """
520         Transform a date value to an object compatible with what is expected
521         by the backend driver for date columns.
522         The default implementation transforms the date to text, but that is not
523         necessary for Oracle.
524         """
525         return value
526 
527     def adapt_datetimefield_value(self, value):
528         """
529         Transform a datetime value to an object compatible with what is expected
530         by the backend driver for datetime columns.
531 
532         If naive datetime is passed assumes that is in UTC. Normally Django
533         models.DateTimeField makes sure that if USE_TZ is True passed datetime
534         is timezone aware.
535         """
536 
537         if value is None:
538             return None
539 
540         # Expression values are adapted by the database.
541         if hasattr(value, 'resolve_expression'):
542             return value
543 
544         # cx_Oracle doesn't support tz-aware datetimes
545         if timezone.is_aware(value):
546             if settings.USE_TZ:
547                 value = timezone.make_naive(value, self.connection.timezone)
548             else:
549                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
550 
551         return Oracle_datetime.from_datetime(value)
552 
553     def adapt_timefield_value(self, value):
554         if value is None:
555             return None
556 
557         # Expression values are adapted by the database.
558         if hasattr(value, 'resolve_expression'):
559             return value
560 
561         if isinstance(value, str):
562             return datetime.datetime.strptime(value, '%H:%M:%S')
563 
564         # Oracle doesn't support tz-aware times
565         if timezone.is_aware(value):
566             raise ValueError("Oracle backend does not support timezone-aware times.")
567 
568         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
569                                value.second, value.microsecond)
570 
571     def combine_expression(self, connector, sub_expressions):
572         lhs, rhs = sub_expressions
573         if connector == '%%':
574             return 'MOD(%s)' % ','.join(sub_expressions)
575         elif connector == '&':
576             return 'BITAND(%s)' % ','.join(sub_expressions)
577         elif connector == '|':
578             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
579         elif connector == '<<':
580             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
581         elif connector == '>>':
582             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
583         elif connector == '^':
584             return 'POWER(%s)' % ','.join(sub_expressions)
585         elif connector == '#':
586             raise NotSupportedError('Bitwise XOR is not supported in Oracle.')
587         return super().combine_expression(connector, sub_expressions)
588 
589     def _get_no_autofield_sequence_name(self, table):
590         """
591         Manually created sequence name to keep backward compatibility for
592         AutoFields that aren't Oracle identity columns.
593         """
594         name_length = self.max_name_length() - 3
595         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
596 
597     def _get_sequence_name(self, cursor, table, pk_name):
598         cursor.execute("""
599             SELECT sequence_name
600             FROM user_tab_identity_cols
601             WHERE table_name = UPPER(%s)
602             AND column_name = UPPER(%s)""", [table, pk_name])
603         row = cursor.fetchone()
604         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
605 
606     def bulk_insert_sql(self, fields, placeholder_rows):
607         query = []
608         for row in placeholder_rows:
609             select = []
610             for i, placeholder in enumerate(row):
611                 # A model without any fields has fields=[None].
612                 if fields[i]:
613                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
614                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
615                 # Add columns aliases to the first select to avoid "ORA-00918:
616                 # column ambiguously defined" when two or more columns in the
617                 # first select have the same value.
618                 if not query:
619                     placeholder = '%s col_%s' % (placeholder, i)
620                 select.append(placeholder)
621             query.append('SELECT %s FROM DUAL' % ', '.join(select))
622         # Bulk insert to tables with Oracle identity columns causes Oracle to
623         # add sequence.nextval to it. Sequence.nextval cannot be used with the
624         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
625         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
626 
627     def subtract_temporals(self, internal_type, lhs, rhs):
628         if internal_type == 'DateField':
629             lhs_sql, lhs_params = lhs
630             rhs_sql, rhs_params = rhs
631             params = (*lhs_params, *rhs_params)
632             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), params
633         return super().subtract_temporals(internal_type, lhs, rhs)
634 
635     def bulk_batch_size(self, fields, objs):
636         """Oracle restricts the number of parameters in a query."""
637         if fields:
638             return self.connection.features.max_query_params // len(fields)
639         return len(objs)
640 
641     def conditional_expression_supported_in_where_clause(self, expression):
642         """
643         Oracle supports only EXISTS(...) or filters in the WHERE clause, others
644         must be compared with True.
645         """
646         if isinstance(expression, (Exists, WhereNode)):
647             return True
648         if isinstance(expression, ExpressionWrapper) and expression.conditional:
649             return self.conditional_expression_supported_in_where_clause(expression.expression)
650         if isinstance(expression, RawSQL) and expression.conditional:
651             return True
652         return False

</code><intended_behavior>Within each identified `execute_sql_flush` method across the different backends, the `using` parameter should be removed. The method's functionality should be preserved by relying on `self.connection.alias` to access the database alias internally. Ensure that all internal uses of `execute_sql_flush` are refactored to omit the previously required `using` argument, reflecting the simplification of the method's signature.</intended_behavior>]
2025-10-15 04:37:50.648 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     cast_char_field_without_max_length = 'text'
20     cast_data_types = {
21         'DateField': 'TEXT',
22         'DateTimeField': 'TEXT',
23     }
24     explain_prefix = 'EXPLAIN QUERY PLAN'
25 
26     def bulk_batch_size(self, fields, objs):
27         """
28         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of
29         999 variables per query.
30 
31         If there's only a single field to insert, the limit is 500
32         (SQLITE_MAX_COMPOUND_SELECT).
33         """
34         if len(fields) == 1:
35             return 500
36         elif len(fields) > 1:
37             return self.connection.features.max_query_params // len(fields)
38         else:
39             return len(objs)
40 
41     def check_expression_support(self, expression):
42         bad_fields = (models.DateField, models.DateTimeField, models.TimeField)
43         bad_aggregates = (models.Sum, models.Avg, models.Variance, models.StdDev)
44         if isinstance(expression, bad_aggregates):
45             for expr in expression.get_source_expressions():
46                 try:
47                     output_field = expr.output_field
48                 except (AttributeError, FieldError):
49                     # Not every subexpression has an output_field which is fine
50                     # to ignore.
51                     pass
52                 else:
53                     if isinstance(output_field, bad_fields):
54                         raise NotSupportedError(
55                             'You cannot use Sum, Avg, StdDev, and Variance '
56                             'aggregations on date/time fields in sqlite3 '
57                             'since date/time is saved as text.'
58                         )
59         if (
60             isinstance(expression, models.Aggregate) and
61             expression.distinct and
62             len(expression.source_expressions) > 1
63         ):
64             raise NotSupportedError(
65                 "SQLite doesn't support DISTINCT on aggregate functions "
66                 "accepting multiple arguments."
67             )
68 
69     def date_extract_sql(self, lookup_type, field_name):
70         """
71         Support EXTRACT with a user-defined function django_date_extract()
72         that's registered in connect(). Use single quotes because this is a
73         string and could otherwise cause a collision with a field name.
74         """
75         return "django_date_extract('%s', %s)" % (lookup_type.lower(), field_name)
76 
77     def date_interval_sql(self, timedelta):
78         return str(duration_microseconds(timedelta))
79 
80     def format_for_duration_arithmetic(self, sql):
81         """Do nothing since formatting is handled in the custom function."""
82         return sql
83 
84     def date_trunc_sql(self, lookup_type, field_name):
85         return "django_date_trunc('%s', %s)" % (lookup_type.lower(), field_name)
86 
87     def time_trunc_sql(self, lookup_type, field_name):
88         return "django_time_trunc('%s', %s)" % (lookup_type.lower(), field_name)
89 
90     def _convert_tznames_to_sql(self, tzname):
91         if settings.USE_TZ:
92             return "'%s'" % tzname, "'%s'" % self.connection.timezone_name
93         return 'NULL', 'NULL'
94 
95     def datetime_cast_date_sql(self, field_name, tzname):
96         return 'django_datetime_cast_date(%s, %s, %s)' % (
97             field_name, *self._convert_tznames_to_sql(tzname),
98         )
99 
100     def datetime_cast_time_sql(self, field_name, tzname):
101         return 'django_datetime_cast_time(%s, %s, %s)' % (
102             field_name, *self._convert_tznames_to_sql(tzname),
103         )
104 
105     def datetime_extract_sql(self, lookup_type, field_name, tzname):
106         return "django_datetime_extract('%s', %s, %s, %s)" % (
107             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
108         )
109 
110     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
111         return "django_datetime_trunc('%s', %s, %s, %s)" % (
112             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
113         )
114 
115     def time_extract_sql(self, lookup_type, field_name):
116         return "django_time_extract('%s', %s)" % (lookup_type.lower(), field_name)
117 
118     def pk_default_value(self):
119         return "NULL"
120 
121     def _quote_params_for_last_executed_query(self, params):
122         """
123         Only for last_executed_query! Don't use this to execute SQL queries!
124         """
125         # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the
126         # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the
127         # number of return values, default = 2000). Since Python's sqlite3
128         # module doesn't expose the get_limit() C API, assume the default
129         # limits are in effect and split the work in batches if needed.
130         BATCH_SIZE = 999
131         if len(params) > BATCH_SIZE:
132             results = ()
133             for index in range(0, len(params), BATCH_SIZE):
134                 chunk = params[index:index + BATCH_SIZE]
135                 results += self._quote_params_for_last_executed_query(chunk)
136             return results
137 
138         sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))
139         # Bypass Django's wrappers and use the underlying sqlite3 connection
140         # to avoid logging this query - it would trigger infinite recursion.
141         cursor = self.connection.connection.cursor()
142         # Native sqlite3 cursors cannot be used as context managers.
143         try:
144             return cursor.execute(sql, params).fetchone()
145         finally:
146             cursor.close()
147 
148     def last_executed_query(self, cursor, sql, params):
149         # Python substitutes parameters in Modules/_sqlite/cursor.c with:
150         # pysqlite_statement_bind_parameters(self->statement, parameters, allow_8bit_chars);
151         # Unfortunately there is no way to reach self->statement from Python,
152         # so we quote and substitute parameters manually.
153         if params:
154             if isinstance(params, (list, tuple)):
155                 params = self._quote_params_for_last_executed_query(params)
156             else:
157                 values = tuple(params.values())
158                 values = self._quote_params_for_last_executed_query(values)
159                 params = dict(zip(params, values))
160             return sql % params
161         # For consistency with SQLiteCursorWrapper.execute(), just return sql
162         # when there are no parameters. See #13648 and #17158.
163         else:
164             return sql
165 
166     def quote_name(self, name):
167         if name.startswith('"') and name.endswith('"'):
168             return name  # Quoting once is enough.
169         return '"%s"' % name
170 
171     def no_limit_value(self):
172         return -1
173 
174     def __references_graph(self, table_name):
175         query = """
176         WITH tables AS (
177             SELECT %s name
178             UNION
179             SELECT sqlite_master.name
180             FROM sqlite_master
181             JOIN tables ON (sql REGEXP %s || tables.name || %s)
182         ) SELECT name FROM tables;
183         """
184         params = (
185             table_name,
186             r'(?i)\s+references\s+("|\')?',
187             r'("|\')?\s*\(',
188         )
189         with self.connection.cursor() as cursor:
190             results = cursor.execute(query, params)
191             return [row[0] for row in results.fetchall()]
192 
193     @cached_property
194     def _references_graph(self):
195         # 512 is large enough to fit the ~330 tables (as of this writing) in
196         # Django's test suite.
197         return lru_cache(maxsize=512)(self.__references_graph)
198 
199     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
200         if tables and allow_cascade:
201             # Simulate TRUNCATE CASCADE by recursively collecting the tables
202             # referencing the tables to be flushed.
203             tables = set(chain.from_iterable(self._references_graph(table) for table in tables))
204         # Note: No requirement for reset of auto-incremented indices (cf. other
205         # sql_flush() implementations). Just return SQL at this point
206         return ['%s %s %s;' % (
207             style.SQL_KEYWORD('DELETE'),
208             style.SQL_KEYWORD('FROM'),
209             style.SQL_FIELD(self.quote_name(table))
210         ) for table in tables]
211 
212     def adapt_datetimefield_value(self, value):
213         if value is None:
214             return None
215 
216         # Expression values are adapted by the database.
217         if hasattr(value, 'resolve_expression'):
218             return value
219 
220         # SQLite doesn't support tz-aware datetimes
221         if timezone.is_aware(value):
222             if settings.USE_TZ:
223                 value = timezone.make_naive(value, self.connection.timezone)
224             else:
225                 raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False.")
226 
227         return str(value)
228 
229     def adapt_timefield_value(self, value):
230         if value is None:
231             return None
232 
233         # Expression values are adapted by the database.
234         if hasattr(value, 'resolve_expression'):
235             return value
236 
237         # SQLite doesn't support tz-aware datetimes
238         if timezone.is_aware(value):
239             raise ValueError("SQLite backend does not support timezone-aware times.")
240 
241         return str(value)
242 
243     def get_db_converters(self, expression):
244         converters = super().get_db_converters(expression)
245         internal_type = expression.output_field.get_internal_type()
246         if internal_type == 'DateTimeField':
247             converters.append(self.convert_datetimefield_value)
248         elif internal_type == 'DateField':
249             converters.append(self.convert_datefield_value)
250         elif internal_type == 'TimeField':
251             converters.append(self.convert_timefield_value)
252         elif internal_type == 'DecimalField':
253             converters.append(self.get_decimalfield_converter(expression))
254         elif internal_type == 'UUIDField':
255             converters.append(self.convert_uuidfield_value)
256         elif internal_type in ('NullBooleanField', 'BooleanField'):
257             converters.append(self.convert_booleanfield_value)
258         return converters
259 
260     def convert_datetimefield_value(self, value, expression, connection):
261         if value is not None:
262             if not isinstance(value, datetime.datetime):
263                 value = parse_datetime(value)
264             if settings.USE_TZ and not timezone.is_aware(value):
265                 value = timezone.make_aware(value, self.connection.timezone)
266         return value
267 
268     def convert_datefield_value(self, value, expression, connection):
269         if value is not None:
270             if not isinstance(value, datetime.date):
271                 value = parse_date(value)
272         return value
273 
274     def convert_timefield_value(self, value, expression, connection):
275         if value is not None:
276             if not isinstance(value, datetime.time):
277                 value = parse_time(value)
278         return value
279 
280     def get_decimalfield_converter(self, expression):
281         # SQLite stores only 15 significant digits. Digits coming from
282         # float inaccuracy must be removed.
283         create_decimal = decimal.Context(prec=15).create_decimal_from_float
284         if isinstance(expression, Col):
285             quantize_value = decimal.Decimal(1).scaleb(-expression.output_field.decimal_places)
286 
287             def converter(value, expression, connection):
288                 if value is not None:
289                     return create_decimal(value).quantize(quantize_value, context=expression.output_field.context)
290         else:
291             def converter(value, expression, connection):
292                 if value is not None:
293                     return create_decimal(value)
294         return converter
295 
296     def convert_uuidfield_value(self, value, expression, connection):
297         if value is not None:
298             value = uuid.UUID(value)
299         return value
300 
301     def convert_booleanfield_value(self, value, expression, connection):
302         return bool(value) if value in (1, 0) else value
303 
304     def bulk_insert_sql(self, fields, placeholder_rows):
305         return " UNION ALL ".join(
306             "SELECT %s" % ", ".join(row)
307             for row in placeholder_rows
308         )
309 
310     def combine_expression(self, connector, sub_expressions):
311         # SQLite doesn't have a ^ operator, so use the user-defined POWER
312         # function that's registered in connect().
313         if connector == '^':
314             return 'POWER(%s)' % ','.join(sub_expressions)
315         elif connector == '#':
316             return 'BITXOR(%s)' % ','.join(sub_expressions)
317         return super().combine_expression(connector, sub_expressions)
318 
319     def combine_duration_expression(self, connector, sub_expressions):
320         if connector not in ['+', '-']:
321             raise DatabaseError('Invalid connector for timedelta: %s.' % connector)
322         fn_params = ["'%s'" % connector] + sub_expressions
323         if len(fn_params) > 3:
324             raise ValueError('Too many params for timedelta operations.')
325         return "django_format_dtdelta(%s)" % ', '.join(fn_params)
326 
327     def integer_field_range(self, internal_type):
328         # SQLite doesn't enforce any integer constraints
329         return (None, None)
330 
331     def subtract_temporals(self, internal_type, lhs, rhs):
332         lhs_sql, lhs_params = lhs
333         rhs_sql, rhs_params = rhs
334         params = (*lhs_params, *rhs_params)
335         if internal_type == 'TimeField':
336             return 'django_time_diff(%s, %s)' % (lhs_sql, rhs_sql), params
337         return 'django_timestamp_diff(%s, %s)' % (lhs_sql, rhs_sql), params
338 
339     def insert_statement(self, ignore_conflicts=False):
340         return 'INSERT OR IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>Within each identified `execute_sql_flush` method across the different backends, the `using` parameter should be removed. The method's functionality should be preserved by relying on `self.connection.alias` to access the database alias internally. Ensure that all internal uses of `execute_sql_flush` are refactored to omit the previously required `using` argument, reflecting the simplification of the method's signature.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
21 class DatabaseOperations(BaseDatabaseOperations):
22     # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.
23     # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by
24     # SmallAutoField, to preserve backward compatibility.
25     integer_field_ranges = {
26         'SmallIntegerField': (-99999999999, 99999999999),
27         'IntegerField': (-99999999999, 99999999999),
28         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
29         'PositiveBigIntegerField': (0, 9999999999999999999),
30         'PositiveSmallIntegerField': (0, 99999999999),
31         'PositiveIntegerField': (0, 99999999999),
32         'SmallAutoField': (-99999, 99999),
33         'AutoField': (-99999999999, 99999999999),
34         'BigAutoField': (-9999999999999999999, 9999999999999999999),
35     }
36     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
37 
38     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
39     _sequence_reset_sql = """
40 DECLARE
41     table_value integer;
42     seq_value integer;
43     seq_name user_tab_identity_cols.sequence_name%%TYPE;
44 BEGIN
45     BEGIN
46         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
47         WHERE  table_name = '%(table_name)s' AND
48                column_name = '%(column_name)s';
49         EXCEPTION WHEN NO_DATA_FOUND THEN
50             seq_name := '%(no_autofield_sequence_name)s';
51     END;
52 
53     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
54     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
55            WHERE sequence_name = seq_name;
56     WHILE table_value > seq_value LOOP
57         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
58         INTO seq_value;
59     END LOOP;
60 END;
61 /"""
62 
63     # Oracle doesn't support string without precision; use the max string size.
64     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
65     cast_data_types = {
66         'AutoField': 'NUMBER(11)',
67         'BigAutoField': 'NUMBER(19)',
68         'SmallAutoField': 'NUMBER(5)',
69         'TextField': cast_char_field_without_max_length,
70     }
71 
72     def cache_key_culling_sql(self):
73         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
74 
75     def date_extract_sql(self, lookup_type, field_name):
76         if lookup_type == 'week_day':
77             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
78             return "TO_CHAR(%s, 'D')" % field_name
79         elif lookup_type == 'iso_week_day':
80             return "TO_CHAR(%s - 1, 'D')" % field_name
81         elif lookup_type == 'week':
82             # IW = ISO week number
83             return "TO_CHAR(%s, 'IW')" % field_name
84         elif lookup_type == 'quarter':
85             return "TO_CHAR(%s, 'Q')" % field_name
86         elif lookup_type == 'iso_year':
87             return "TO_CHAR(%s, 'IYYY')" % field_name
88         else:
89             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
90             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
91 
92     def date_trunc_sql(self, lookup_type, field_name):
93         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
94         if lookup_type in ('year', 'month'):
95             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
96         elif lookup_type == 'quarter':
97             return "TRUNC(%s, 'Q')" % field_name
98         elif lookup_type == 'week':
99             return "TRUNC(%s, 'IW')" % field_name
100         else:
101             return "TRUNC(%s)" % field_name
102 
103     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
104     # if the time zone name is passed in parameter. Use interpolation instead.
105     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
106     # This regexp matches all time zone names from the zoneinfo database.
107     _tzname_re = _lazy_re_compile(r'^[\w/:+-]+$')
108 
109     def _prepare_tzname_delta(self, tzname):
110         if '+' in tzname:
111             return tzname[tzname.find('+'):]
112         elif '-' in tzname:
113             return tzname[tzname.find('-'):]
114         return tzname
115 
116     def _convert_field_to_tz(self, field_name, tzname):
117         if not settings.USE_TZ:
118             return field_name
119         if not self._tzname_re.match(tzname):
120             raise ValueError("Invalid time zone name: %s" % tzname)
121         # Convert from connection timezone to the local time, returning
122         # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the
123         # TIME ZONE details.
124         if self.connection.timezone_name != tzname:
125             return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (
126                 field_name,
127                 self.connection.timezone_name,
128                 self._prepare_tzname_delta(tzname),
129             )
130         return field_name
131 
132     def datetime_cast_date_sql(self, field_name, tzname):
133         field_name = self._convert_field_to_tz(field_name, tzname)
134         return 'TRUNC(%s)' % field_name
135 
136     def datetime_cast_time_sql(self, field_name, tzname):
137         # Since `TimeField` values are stored as TIMESTAMP where only the date
138         # part is ignored, convert the field to the specified timezone.
139         return self._convert_field_to_tz(field_name, tzname)
140 
141     def datetime_extract_sql(self, lookup_type, field_name, tzname):
142         field_name = self._convert_field_to_tz(field_name, tzname)
143         return self.date_extract_sql(lookup_type, field_name)
144 
145     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
146         field_name = self._convert_field_to_tz(field_name, tzname)
147         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
148         if lookup_type in ('year', 'month'):
149             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
150         elif lookup_type == 'quarter':
151             sql = "TRUNC(%s, 'Q')" % field_name
152         elif lookup_type == 'week':
153             sql = "TRUNC(%s, 'IW')" % field_name
154         elif lookup_type == 'day':
155             sql = "TRUNC(%s)" % field_name
156         elif lookup_type == 'hour':
157             sql = "TRUNC(%s, 'HH24')" % field_name
158         elif lookup_type == 'minute':
159             sql = "TRUNC(%s, 'MI')" % field_name
160         else:
161             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
162         return sql
163 
164     def time_trunc_sql(self, lookup_type, field_name):
165         # The implementation is similar to `datetime_trunc_sql` as both
166         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
167         # the date part of the later is ignored.
168         if lookup_type == 'hour':
169             sql = "TRUNC(%s, 'HH24')" % field_name
170         elif lookup_type == 'minute':
171             sql = "TRUNC(%s, 'MI')" % field_name
172         elif lookup_type == 'second':
173             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
174         return sql
175 
176     def get_db_converters(self, expression):
177         converters = super().get_db_converters(expression)
178         internal_type = expression.output_field.get_internal_type()
179         if internal_type == 'TextField':
180             converters.append(self.convert_textfield_value)
181         elif internal_type == 'BinaryField':
182             converters.append(self.convert_binaryfield_value)
183         elif internal_type in ['BooleanField', 'NullBooleanField']:
184             converters.append(self.convert_booleanfield_value)
185         elif internal_type == 'DateTimeField':
186             if settings.USE_TZ:
187                 converters.append(self.convert_datetimefield_value)
188         elif internal_type == 'DateField':
189             converters.append(self.convert_datefield_value)
190         elif internal_type == 'TimeField':
191             converters.append(self.convert_timefield_value)
192         elif internal_type == 'UUIDField':
193             converters.append(self.convert_uuidfield_value)
194         # Oracle stores empty strings as null. If the field accepts the empty
195         # string, undo this to adhere to the Django convention of using
196         # the empty string instead of null.
197         if expression.field.empty_strings_allowed:
198             converters.append(
199                 self.convert_empty_bytes
200                 if internal_type == 'BinaryField' else
201                 self.convert_empty_string
202             )
203         return converters
204 
205     def convert_textfield_value(self, value, expression, connection):
206         if isinstance(value, Database.LOB):
207             value = value.read()
208         return value
209 
210     def convert_binaryfield_value(self, value, expression, connection):
211         if isinstance(value, Database.LOB):
212             value = force_bytes(value.read())
213         return value
214 
215     def convert_booleanfield_value(self, value, expression, connection):
216         if value in (0, 1):
217             value = bool(value)
218         return value
219 
220     # cx_Oracle always returns datetime.datetime objects for
221     # DATE and TIMESTAMP columns, but Django wants to see a
222     # python datetime.date, .time, or .datetime.
223 
224     def convert_datetimefield_value(self, value, expression, connection):
225         if value is not None:
226             value = timezone.make_aware(value, self.connection.timezone)
227         return value
228 
229     def convert_datefield_value(self, value, expression, connection):
230         if isinstance(value, Database.Timestamp):
231             value = value.date()
232         return value
233 
234     def convert_timefield_value(self, value, expression, connection):
235         if isinstance(value, Database.Timestamp):
236             value = value.time()
237         return value
238 
239     def convert_uuidfield_value(self, value, expression, connection):
240         if value is not None:
241             value = uuid.UUID(value)
242         return value
243 
244     @staticmethod
245     def convert_empty_string(value, expression, connection):
246         return '' if value is None else value
247 
248     @staticmethod
249     def convert_empty_bytes(value, expression, connection):
250         return b'' if value is None else value
251 
252     def deferrable_sql(self):
253         return " DEFERRABLE INITIALLY DEFERRED"
254 
255     def fetch_returned_insert_columns(self, cursor, returning_params):
256         columns = []
257         for param in returning_params:
258             value = param.get_value()
259             if value is None or value == []:
260                 # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
261                 raise DatabaseError(
262                     'The database did not return a new row id. Probably '
263                     '"ORA-1403: no data found" was raised internally but was '
264                     'hidden by the Oracle OCI library (see '
265                     'https://code.djangoproject.com/ticket/28859).'
266                 )
267             # cx_Oracle < 7 returns value, >= 7 returns list with single value.
268             columns.append(value[0] if isinstance(value, list) else value)
269         return tuple(columns)
270 
271     def field_cast_sql(self, db_type, internal_type):
272         if db_type and db_type.endswith('LOB'):
273             return "DBMS_LOB.SUBSTR(%s)"
274         else:
275             return "%s"
276 
277     def no_limit_value(self):
278         return None
279 
280     def limit_offset_sql(self, low_mark, high_mark):
281         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
282         return ' '.join(sql for sql in (
283             ('OFFSET %d ROWS' % offset) if offset else None,
284             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
285         ) if sql)
286 
287     def last_executed_query(self, cursor, sql, params):
288         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
289         # The DB API definition does not define this attribute.
290         statement = cursor.statement
291         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
292         # `statement` doesn't contain the query parameters. Substitute
293         # parameters manually.
294         if isinstance(params, (tuple, list)):
295             for i, param in enumerate(params):
296                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
297         elif isinstance(params, dict):
298             for key, param in params.items():
299                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
300         return statement
301 
302     def last_insert_id(self, cursor, table_name, pk_name):
303         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
304         cursor.execute('"%s".currval' % sq_name)
305         return cursor.fetchone()[0]
306 
307     def lookup_cast(self, lookup_type, internal_type=None):
308         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
309             return "UPPER(%s)"
310         return "%s"
311 
312     def max_in_list_size(self):
313         return 1000
314 
315     def max_name_length(self):
316         return 30
317 
318     def pk_default_value(self):
319         return "NULL"
320 
321     def prep_for_iexact_query(self, x):
322         return x
323 
324     def process_clob(self, value):
325         if value is None:
326             return ''
327         return value.read()
328 
329     def quote_name(self, name):
330         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
331         # not quoted, Oracle has case-insensitive behavior for identifiers, but
332         # always defaults to uppercase.
333         # We simplify things by making Oracle identifiers always uppercase.
334         if not name.startswith('"') and not name.endswith('"'):
335             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
336         # Oracle puts the query text into a (query % args) construct, so % signs
337         # in names need to be escaped. The '%%' will be collapsed back to '%' at
338         # that stage so we aren't really making the name longer here.
339         name = name.replace('%', '%%')
340         return name.upper()
341 
342     def random_function_sql(self):
343         return "DBMS_RANDOM.RANDOM"
344 
345     def regex_lookup(self, lookup_type):
346         if lookup_type == 'regex':
347             match_option = "'c'"
348         else:
349             match_option = "'i'"
350         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
351 
352     def return_insert_columns(self, fields):
353         if not fields:
354             return '', ()
355         field_names = []
356         params = []
357         for field in fields:
358             field_names.append('%s.%s' % (
359                 self.quote_name(field.model._meta.db_table),
360                 self.quote_name(field.column),
361             ))
362             params.append(InsertVar(field))
363         return 'RETURNING %s INTO %s' % (
364             ', '.join(field_names),
365             ', '.join(['%s'] * len(params)),
366         ), tuple(params)
367 
368     def __foreign_key_constraints(self, table_name, recursive):
369         with self.connection.cursor() as cursor:
370             if recursive:
371                 cursor.execute("""
372                     SELECT
373                         user_tables.table_name, rcons.constraint_name
374                     FROM
375                         user_tables
376                     JOIN
377                         user_constraints cons
378                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
379                     LEFT JOIN
380                         user_constraints rcons
381                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
382                     START WITH user_tables.table_name = UPPER(%s)
383                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
384                     GROUP BY
385                         user_tables.table_name, rcons.constraint_name
386                     HAVING user_tables.table_name != UPPER(%s)
387                     ORDER BY MAX(level) DESC
388                 """, (table_name, table_name))
389             else:
390                 cursor.execute("""
391                     SELECT
392                         cons.table_name, cons.constraint_name
393                     FROM
394                         user_constraints cons
395                     WHERE
396                         cons.constraint_type = 'R'
397                         AND cons.table_name = UPPER(%s)
398                 """, (table_name,))
399             return cursor.fetchall()
400 
401     @cached_property
402     def _foreign_key_constraints(self):
403         # 512 is large enough to fit the ~330 tables (as of this writing) in
404         # Django's test suite.
405         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
406 
407     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
408         if not tables:
409             return []
410 
411         truncated_tables = {table.upper() for table in tables}
412         constraints = set()
413         # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign
414         # keys which Django doesn't define. Emulate the PostgreSQL behavior
415         # which truncates all dependent tables by manually retrieving all
416         # foreign key constraints and resolving dependencies.
417         for table in tables:
418             for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
419                 if allow_cascade:
420                     truncated_tables.add(foreign_table)
421                 constraints.add((foreign_table, constraint))
422         sql = [
423             '%s %s %s %s %s %s %s %s;' % (
424                 style.SQL_KEYWORD('ALTER'),
425                 style.SQL_KEYWORD('TABLE'),
426                 style.SQL_FIELD(self.quote_name(table)),
427                 style.SQL_KEYWORD('DISABLE'),
428                 style.SQL_KEYWORD('CONSTRAINT'),
429                 style.SQL_FIELD(self.quote_name(constraint)),
430                 style.SQL_KEYWORD('KEEP'),
431                 style.SQL_KEYWORD('INDEX'),
432             ) for table, constraint in constraints
433         ] + [
434             '%s %s %s;' % (
435                 style.SQL_KEYWORD('TRUNCATE'),
436                 style.SQL_KEYWORD('TABLE'),
437                 style.SQL_FIELD(self.quote_name(table)),
438             ) for table in truncated_tables
439         ] + [
440             '%s %s %s %s %s %s;' % (
441                 style.SQL_KEYWORD('ALTER'),
442                 style.SQL_KEYWORD('TABLE'),
443                 style.SQL_FIELD(self.quote_name(table)),
444                 style.SQL_KEYWORD('ENABLE'),
445                 style.SQL_KEYWORD('CONSTRAINT'),
446                 style.SQL_FIELD(self.quote_name(constraint)),
447             ) for table, constraint in constraints
448         ]
449         if reset_sequences:
450             sequences = [
451                 sequence
452                 for sequence in self.connection.introspection.sequence_list()
453                 if sequence['table'].upper() in truncated_tables
454             ]
455             # Since we've just deleted all the rows, running our sequence ALTER
456             # code will reset the sequence to 0.
457             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
458         return sql
459 
460     def sequence_reset_by_name_sql(self, style, sequences):
461         sql = []
462         for sequence_info in sequences:
463             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
464             table = self.quote_name(sequence_info['table'])
465             column = self.quote_name(sequence_info['column'] or 'id')
466             query = self._sequence_reset_sql % {
467                 'no_autofield_sequence_name': no_autofield_sequence_name,
468                 'table': table,
469                 'column': column,
470                 'table_name': strip_quotes(table),
471                 'column_name': strip_quotes(column),
472             }
473             sql.append(query)
474         return sql
475 
476     def sequence_reset_sql(self, style, model_list):
477         output = []
478         query = self._sequence_reset_sql
479         for model in model_list:
480             for f in model._meta.local_fields:
481                 if isinstance(f, AutoField):
482                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
483                     table = self.quote_name(model._meta.db_table)
484                     column = self.quote_name(f.column)
485                     output.append(query % {
486                         'no_autofield_sequence_name': no_autofield_sequence_name,
487                         'table': table,
488                         'column': column,
489                         'table_name': strip_quotes(table),
490                         'column_name': strip_quotes(column),
491                     })
492                     # Only one AutoField is allowed per model, so don't
493                     # continue to loop
494                     break
495             for f in model._meta.many_to_many:
496                 if not f.remote_field.through:
497                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
498                     table = self.quote_name(f.m2m_db_table())
499                     column = self.quote_name('id')
500                     output.append(query % {
501                         'no_autofield_sequence_name': no_autofield_sequence_name,
502                         'table': table,
503                         'column': column,
504                         'table_name': strip_quotes(table),
505                         'column_name': 'ID',
506                     })
507         return output
508 
509     def start_transaction_sql(self):
510         return ''
511 
512     def tablespace_sql(self, tablespace, inline=False):
513         if inline:
514             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
515         else:
516             return "TABLESPACE %s" % self.quote_name(tablespace)
517 
518     def adapt_datefield_value(self, value):
519         """
520         Transform a date value to an object compatible with what is expected
521         by the backend driver for date columns.
522         The default implementation transforms the date to text, but that is not
523         necessary for Oracle.
524         """
525         return value
526 
527     def adapt_datetimefield_value(self, value):
528         """
529         Transform a datetime value to an object compatible with what is expected
530         by the backend driver for datetime columns.
531 
532         If naive datetime is passed assumes that is in UTC. Normally Django
533         models.DateTimeField makes sure that if USE_TZ is True passed datetime
534         is timezone aware.
535         """
536 
537         if value is None:
538             return None
539 
540         # Expression values are adapted by the database.
541         if hasattr(value, 'resolve_expression'):
542             return value
543 
544         # cx_Oracle doesn't support tz-aware datetimes
545         if timezone.is_aware(value):
546             if settings.USE_TZ:
547                 value = timezone.make_naive(value, self.connection.timezone)
548             else:
549                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
550 
551         return Oracle_datetime.from_datetime(value)
552 
553     def adapt_timefield_value(self, value):
554         if value is None:
555             return None
556 
557         # Expression values are adapted by the database.
558         if hasattr(value, 'resolve_expression'):
559             return value
560 
561         if isinstance(value, str):
562             return datetime.datetime.strptime(value, '%H:%M:%S')
563 
564         # Oracle doesn't support tz-aware times
565         if timezone.is_aware(value):
566             raise ValueError("Oracle backend does not support timezone-aware times.")
567 
568         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
569                                value.second, value.microsecond)
570 
571     def combine_expression(self, connector, sub_expressions):
572         lhs, rhs = sub_expressions
573         if connector == '%%':
574             return 'MOD(%s)' % ','.join(sub_expressions)
575         elif connector == '&':
576             return 'BITAND(%s)' % ','.join(sub_expressions)
577         elif connector == '|':
578             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
579         elif connector == '<<':
580             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
581         elif connector == '>>':
582             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
583         elif connector == '^':
584             return 'POWER(%s)' % ','.join(sub_expressions)
585         elif connector == '#':
586             raise NotSupportedError('Bitwise XOR is not supported in Oracle.')
587         return super().combine_expression(connector, sub_expressions)
588 
589     def _get_no_autofield_sequence_name(self, table):
590         """
591         Manually created sequence name to keep backward compatibility for
592         AutoFields that aren't Oracle identity columns.
593         """
594         name_length = self.max_name_length() - 3
595         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
596 
597     def _get_sequence_name(self, cursor, table, pk_name):
598         cursor.execute("""
599             SELECT sequence_name
600             FROM user_tab_identity_cols
601             WHERE table_name = UPPER(%s)
602             AND column_name = UPPER(%s)""", [table, pk_name])
603         row = cursor.fetchone()
604         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
605 
606     def bulk_insert_sql(self, fields, placeholder_rows):
607         query = []
608         for row in placeholder_rows:
609             select = []
610             for i, placeholder in enumerate(row):
611                 # A model without any fields has fields=[None].
612                 if fields[i]:
613                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
614                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
615                 # Add columns aliases to the first select to avoid "ORA-00918:
616                 # column ambiguously defined" when two or more columns in the
617                 # first select have the same value.
618                 if not query:
619                     placeholder = '%s col_%s' % (placeholder, i)
620                 select.append(placeholder)
621             query.append('SELECT %s FROM DUAL' % ', '.join(select))
622         # Bulk insert to tables with Oracle identity columns causes Oracle to
623         # add sequence.nextval to it. Sequence.nextval cannot be used with the
624         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
625         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
626 
627     def subtract_temporals(self, internal_type, lhs, rhs):
628         if internal_type == 'DateField':
629             lhs_sql, lhs_params = lhs
630             rhs_sql, rhs_params = rhs
631             params = (*lhs_params, *rhs_params)
632             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), params
633         return super().subtract_temporals(internal_type, lhs, rhs)
634 
635     def bulk_batch_size(self, fields, objs):
636         """Oracle restricts the number of parameters in a query."""
637         if fields:
638             return self.connection.features.max_query_params // len(fields)
639         return len(objs)
640 
641     def conditional_expression_supported_in_where_clause(self, expression):
642         """
643         Oracle supports only EXISTS(...) or filters in the WHERE clause, others
644         must be compared with True.
645         """
646         if isinstance(expression, (Exists, WhereNode)):
647             return True
648         if isinstance(expression, ExpressionWrapper) and expression.conditional:
649             return self.conditional_expression_supported_in_where_clause(expression.expression)
650         if isinstance(expression, RawSQL) and expression.conditional:
651             return True
652         return False

</code><intended_behavior>Within each identified `execute_sql_flush` method across the different backends, the `using` parameter should be removed. The method's functionality should be preserved by relying on `self.connection.alias` to access the database alias internally. Ensure that all internal uses of `execute_sql_flush` are refactored to omit the previously required `using` argument, reflecting the simplification of the method's signature.</intended_behavior>]
2025-10-15 04:37:50.649 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 04:37:50.649 | INFO     | Search-only: skipping patch selection
2025-10-15 04:37:50.791 | INFO     | Task django__django-12741 completed successfully.
2025-10-15 04:37:50.791 | INFO     | No patch generated. You can try running ACR again.
