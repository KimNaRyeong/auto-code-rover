[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 1933,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import importlib\n14 import re\n15 import warnings\n16 from inspect import Parameter, Signature\n17 from types import ModuleType\n18 from typing import (\n19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union\n20 )\n21 \n22 from docutils.statemachine import StringList\n23 \n24 import sphinx\n25 from sphinx.application import Sphinx\n26 from sphinx.config import Config, ENUM\n27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n28 from sphinx.environment import BuildEnvironment\n29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members\n30 from sphinx.ext.autodoc.mock import mock\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect\n34 from sphinx.util import logging\n35 from sphinx.util import split_full_qualified_name\n36 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43     from sphinx.ext.autodoc.directive import DocumenterBridge\n44 \n45 \n46 logger = logging.getLogger(__name__)\n47 \n48 \n49 # This type isn't exposed directly in any modules, but can be found\n50 # here in most Python versions\n51 MethodDescriptorType = type(type.__subclasses__)\n52 \n53 \n54 #: extended signature RE: with explicit module name separated by ::\n55 py_ext_sig_re = re.compile(\n56     r'''^ ([\\w.]+::)?            # explicit module name\n57           ([\\w.]+\\.)?            # module and/or class name(s)\n58           (\\w+)  \\s*             # thing name\n59           (?: \\((.*)\\)           # optional: arguments\n60            (?:\\s* -> \\s* (.*))?  #           return annotation\n61           )? $                   # and nothing more\n62           ''', re.VERBOSE)\n63 \n64 \n65 def identity(x: Any) -> Any:\n66     return x\n67 \n68 \n69 ALL = object()\n70 UNINITIALIZED_ATTR = object()\n71 INSTANCEATTR = object()\n72 SLOTSATTR = object()\n73 \n74 \n75 def members_option(arg: Any) -> Union[object, List[str]]:\n76     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n77     if arg is None or arg is True:\n78         return ALL\n79     return [x.strip() for x in arg.split(',') if x.strip()]\n80 \n81 \n82 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n83     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n84     if arg is None:\n85         return ALL\n86     return {x.strip() for x in arg.split(',') if x.strip()}\n87 \n88 \n89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n90     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n91     if arg is None:\n92         return 'object'\n93     else:\n94         return arg\n95 \n96 \n97 def member_order_option(arg: Any) -> Optional[str]:\n98     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n99     if arg is None:\n100         return None\n101     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n102         return arg\n103     else:\n104         raise ValueError(__('invalid value for member-order option: %s') % arg)\n105 \n106 \n107 SUPPRESS = object()\n108 \n109 \n110 def annotation_option(arg: Any) -> Any:\n111     if arg is None:\n112         # suppress showing the representation of the object\n113         return SUPPRESS\n114     else:\n115         return arg\n116 \n117 \n118 def bool_option(arg: Any) -> bool:\n119     \"\"\"Used to convert flag options to auto directives.  (Instead of\n120     directives.flag(), which returns None).\n121     \"\"\"\n122     return True\n123 \n124 \n125 def merge_special_members_option(options: Dict) -> None:\n126     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n127     if 'special-members' in options and options['special-members'] is not ALL:\n128         if options.get('members') is ALL:\n129             pass\n130         elif options.get('members'):\n131             for member in options['special-members']:\n132                 if member not in options['members']:\n133                     options['members'].append(member)\n134         else:\n135             options['members'] = options['special-members']\n136 \n137 \n138 # Some useful event listener factories for autodoc-process-docstring.\n139 \n140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n141     \"\"\"Return a listener that removes the first *pre* and last *post*\n142     lines of every docstring.  If *what* is a sequence of strings,\n143     only docstrings of a type in *what* will be processed.\n144 \n145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n146 \n147        from sphinx.ext.autodoc import cut_lines\n148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n149 \n150     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n151     \"\"\"\n152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n153                 ) -> None:\n154         if what and what_ not in what:\n155             return\n156         del lines[:pre]\n157         if post:\n158             # remove one trailing blank line.\n159             if lines and not lines[-1]:\n160                 lines.pop(-1)\n161             del lines[-post:]\n162         # make sure there is a blank line at the end\n163         if lines and lines[-1]:\n164             lines.append('')\n165     return process\n166 \n167 \n168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n169             exclude: bool = False) -> Callable:\n170     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n171     lines between lines that match the *marker* regular expression.  If no line\n172     matches, the resulting docstring would be empty, so no change will be made\n173     unless *keepempty* is true.\n174 \n175     If *what* is a sequence of strings, only docstrings of a type in *what* will\n176     be processed.\n177     \"\"\"\n178     marker_re = re.compile(marker)\n179 \n180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n181                 ) -> None:\n182         if what and what_ not in what:\n183             return\n184         deleted = 0\n185         delete = not exclude\n186         orig_lines = lines[:]\n187         for i, line in enumerate(orig_lines):\n188             if delete:\n189                 lines.pop(i - deleted)\n190                 deleted += 1\n191             if marker_re.match(line):\n192                 delete = not delete\n193                 if delete:\n194                     lines.pop(i - deleted)\n195                     deleted += 1\n196         if not lines and not keepempty:\n197             lines[:] = orig_lines\n198         # make sure there is a blank line at the end\n199         if lines and lines[-1]:\n200             lines.append('')\n201     return process\n202 \n203 \n204 # This class is used only in ``sphinx.ext.autodoc.directive``,\n205 # But we define this class here to keep compatibility (see #4538)\n206 class Options(dict):\n207     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n208     def __getattr__(self, name: str) -> Any:\n209         try:\n210             return self[name.replace('_', '-')]\n211         except KeyError:\n212             return None\n213 \n214 \n215 class Documenter:\n216     \"\"\"\n217     A Documenter knows how to autodocument a single object type.  When\n218     registered with the AutoDirective, it will be used to document objects\n219     of that type when needed by autodoc.\n220 \n221     Its *objtype* attribute selects what auto directive it is assigned to\n222     (the directive name is 'auto' + objtype), and what directive it generates\n223     by default, though that can be overridden by an attribute called\n224     *directivetype*.\n225 \n226     A Documenter has an *option_spec* that works like a docutils directive's;\n227     in fact, it will be used to parse an auto directive's options that matches\n228     the documenter.\n229     \"\"\"\n230     #: name by which the directive is called (auto...) and the default\n231     #: generated directive name\n232     objtype = 'object'\n233     #: indentation by which to indent the directive content\n234     content_indent = '   '\n235     #: priority if multiple documenters return True from can_document_member\n236     priority = 0\n237     #: order if autodoc_member_order is set to 'groupwise'\n238     member_order = 0\n239     #: true if the generated content may contain titles\n240     titles_allowed = False\n241 \n242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n243 \n244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n245         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n247 \n248     @classmethod\n249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n250                             ) -> bool:\n251         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n252         raise NotImplementedError('must be implemented in subclasses')\n253 \n254     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n255         self.directive = directive\n256         self.env = directive.env    # type: BuildEnvironment\n257         self.options = directive.genopt\n258         self.name = name\n259         self.indent = indent\n260         # the module and object path within the module, and the fully\n261         # qualified name (all set after resolve_name succeeds)\n262         self.modname = None         # type: str\n263         self.module = None          # type: ModuleType\n264         self.objpath = None         # type: List[str]\n265         self.fullname = None        # type: str\n266         # extra signature items (arguments and return annotation,\n267         # also set after resolve_name succeeds)\n268         self.args = None            # type: str\n269         self.retann = None          # type: str\n270         # the object to document (set after import_object succeeds)\n271         self.object = None          # type: Any\n272         self.object_name = None     # type: str\n273         # the parent/owner of the object to document\n274         self.parent = None          # type: Any\n275         # the module analyzer to get at attribute docs, or None\n276         self.analyzer = None        # type: ModuleAnalyzer\n277 \n278     @property\n279     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n280         \"\"\"Returns registered Documenter classes\"\"\"\n281         return self.env.app.registry.documenters\n282 \n283     def add_line(self, line: str, source: str, *lineno: int) -> None:\n284         \"\"\"Append one line of generated reST to the output.\"\"\"\n285         if line.strip():  # not a blank line\n286             self.directive.result.append(self.indent + line, source, *lineno)\n287         else:\n288             self.directive.result.append('', source, *lineno)\n289 \n290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n291                      ) -> Tuple[str, List[str]]:\n292         \"\"\"Resolve the module and name of the object to document given by the\n293         arguments and the current module/class.\n294 \n295         Must return a pair of the module name and a chain of attributes; for\n296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n297         ``zipfile.ZipFile.open`` method.\n298         \"\"\"\n299         raise NotImplementedError('must be implemented in subclasses')\n300 \n301     def parse_name(self) -> bool:\n302         \"\"\"Determine what module to import and what attribute to document.\n303 \n304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n305         *self.args* and *self.retann* if parsing and resolving was successful.\n306         \"\"\"\n307         # first, parse the definition -- auto directives for classes and\n308         # functions can contain a signature which is then used instead of\n309         # an autogenerated one\n310         try:\n311             explicit_modname, path, base, args, retann = \\\n312                 py_ext_sig_re.match(self.name).groups()\n313         except AttributeError:\n314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n315                            type='autodoc')\n316             return False\n317 \n318         # support explicit module and class name separation via ::\n319         if explicit_modname is not None:\n320             modname = explicit_modname[:-2]\n321             parents = path.rstrip('.').split('.') if path else []\n322         else:\n323             modname = None\n324             parents = []\n325 \n326         with mock(self.env.config.autodoc_mock_imports):\n327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n328 \n329         if not self.modname:\n330             return False\n331 \n332         self.args = args\n333         self.retann = retann\n334         self.fullname = (self.modname or '') + \\\n335                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n336         return True\n337 \n338     def import_object(self) -> bool:\n339         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n340         it as *self.object*.\n341 \n342         Returns True if successful, False if an error occurred.\n343         \"\"\"\n344         with mock(self.env.config.autodoc_mock_imports):\n345             try:\n346                 ret = import_object(self.modname, self.objpath, self.objtype,\n347                                     attrgetter=self.get_attr,\n348                                     warningiserror=self.env.config.autodoc_warningiserror)\n349                 self.module, self.parent, self.object_name, self.object = ret\n350                 return True\n351             except ImportError as exc:\n352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n353                 self.env.note_reread()\n354                 return False\n355 \n356     def get_real_modname(self) -> str:\n357         \"\"\"Get the real module name of an object to document.\n358 \n359         It can differ from the name of the module through which the object was\n360         imported.\n361         \"\"\"\n362         return self.get_attr(self.object, '__module__', None) or self.modname\n363 \n364     def check_module(self) -> bool:\n365         \"\"\"Check if *self.object* is really defined in the module given by\n366         *self.modname*.\n367         \"\"\"\n368         if self.options.imported_members:\n369             return True\n370 \n371         subject = inspect.unpartial(self.object)\n372         modname = self.get_attr(subject, '__module__', None)\n373         if modname and modname != self.modname:\n374             return False\n375         return True\n376 \n377     def format_args(self, **kwargs: Any) -> str:\n378         \"\"\"Format the argument signature of *self.object*.\n379 \n380         Should return None if the object does not have a signature.\n381         \"\"\"\n382         return None\n383 \n384     def format_name(self) -> str:\n385         \"\"\"Format the name of *self.object*.\n386 \n387         This normally should be something that can be parsed by the generated\n388         directive, but doesn't need to be (Sphinx will display it unparsed\n389         then).\n390         \"\"\"\n391         # normally the name doesn't contain the module (except for module\n392         # directives of course)\n393         return '.'.join(self.objpath) or self.modname\n394 \n395     def _call_format_args(self, **kwargs: Any) -> str:\n396         if kwargs:\n397             try:\n398                 return self.format_args(**kwargs)\n399             except TypeError:\n400                 # avoid chaining exceptions, by putting nothing here\n401                 pass\n402 \n403         # retry without arguments for old documenters\n404         return self.format_args()\n405 \n406     def format_signature(self, **kwargs: Any) -> str:\n407         \"\"\"Format the signature (arguments and return annotation) of the object.\n408 \n409         Let the user process it via the ``autodoc-process-signature`` event.\n410         \"\"\"\n411         if self.args is not None:\n412             # signature given explicitly\n413             args = \"(%s)\" % self.args\n414             retann = self.retann\n415         else:\n416             # try to introspect the signature\n417             try:\n418                 retann = None\n419                 args = self._call_format_args(**kwargs)\n420                 if args:\n421                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n422                     if matched:\n423                         args = matched.group(1)\n424                         retann = matched.group(2)\n425             except Exception:\n426                 logger.warning(__('error while formatting arguments for %s:') %\n427                                self.fullname, type='autodoc', exc_info=True)\n428                 args = None\n429 \n430         result = self.env.events.emit_firstresult('autodoc-process-signature',\n431                                                   self.objtype, self.fullname,\n432                                                   self.object, self.options, args, retann)\n433         if result:\n434             args, retann = result\n435 \n436         if args is not None:\n437             return args + ((' -> %s' % retann) if retann else '')\n438         else:\n439             return ''\n440 \n441     def add_directive_header(self, sig: str) -> None:\n442         \"\"\"Add the directive header and options to the generated content.\"\"\"\n443         domain = getattr(self, 'domain', 'py')\n444         directive = getattr(self, 'directivetype', self.objtype)\n445         name = self.format_name()\n446         sourcename = self.get_sourcename()\n447 \n448         # one signature per line, indented by column\n449         prefix = '.. %s:%s:: ' % (domain, directive)\n450         for i, sig_line in enumerate(sig.split(\"\\n\")):\n451             self.add_line('%s%s%s' % (prefix, name, sig_line),\n452                           sourcename)\n453             if i == 0:\n454                 prefix = \" \" * len(prefix)\n455 \n456         if self.options.noindex:\n457             self.add_line('   :noindex:', sourcename)\n458         if self.objpath:\n459             # Be explicit about the module, this is necessary since .. class::\n460             # etc. don't support a prepended module name\n461             self.add_line('   :module: %s' % self.modname, sourcename)\n462 \n463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n464         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n465         if encoding is not None:\n466             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n467                           % self.__class__.__name__,\n468                           RemovedInSphinx40Warning, stacklevel=2)\n469         if ignore is not None:\n470             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n471                           % self.__class__.__name__,\n472                           RemovedInSphinx50Warning, stacklevel=2)\n473         docstring = getdoc(self.object, self.get_attr,\n474                            self.env.config.autodoc_inherit_docstrings,\n475                            self.parent, self.object_name)\n476         if docstring:\n477             tab_width = self.directive.state.document.settings.tab_width\n478             return [prepare_docstring(docstring, ignore, tab_width)]\n479         return []\n480 \n481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n482         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n483         for docstringlines in docstrings:\n484             if self.env.app:\n485                 # let extensions preprocess docstrings\n486                 self.env.app.emit('autodoc-process-docstring',\n487                                   self.objtype, self.fullname, self.object,\n488                                   self.options, docstringlines)\n489             yield from docstringlines\n490 \n491     def get_sourcename(self) -> str:\n492         if self.analyzer:\n493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n494         return 'docstring of %s' % self.fullname\n495 \n496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n497         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n498         # set sourcename and add content from attribute documentation\n499         sourcename = self.get_sourcename()\n500         if self.analyzer:\n501             attr_docs = self.analyzer.find_attr_docs()\n502             if self.objpath:\n503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n504                 if key in attr_docs:\n505                     no_docstring = True\n506                     # make a copy of docstring for attributes to avoid cache\n507                     # the change of autodoc-process-docstring event.\n508                     docstrings = [list(attr_docs[key])]\n509 \n510                     for i, line in enumerate(self.process_doc(docstrings)):\n511                         self.add_line(line, sourcename, i)\n512 \n513         # add content from docstrings\n514         if not no_docstring:\n515             docstrings = self.get_doc()\n516             if not docstrings:\n517                 # append at least a dummy docstring, so that the event\n518                 # autodoc-process-docstring is fired and can add some\n519                 # content if desired\n520                 docstrings.append([])\n521             for i, line in enumerate(self.process_doc(docstrings)):\n522                 self.add_line(line, sourcename, i)\n523 \n524         # add additional content (e.g. from document), if present\n525         if more_content:\n526             for line, src in zip(more_content.data, more_content.items):\n527                 self.add_line(line, src[0], src[1])\n528 \n529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n530         \"\"\"Return `(members_check_module, members)` where `members` is a\n531         list of `(membername, member)` pairs of the members of *self.object*.\n532 \n533         If *want_all* is True, return all members.  Else, only return those\n534         members given by *self.options.members* (which may also be none).\n535         \"\"\"\n536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n537         if not want_all:\n538             if not self.options.members:\n539                 return False, []\n540             # specific members given\n541             selected = []\n542             for name in self.options.members:\n543                 if name in members:\n544                     selected.append((name, members[name].value))\n545                 else:\n546                     logger.warning(__('missing attribute %s in object %s') %\n547                                    (name, self.fullname), type='autodoc')\n548             return False, selected\n549         elif self.options.inherited_members:\n550             return False, [(m.name, m.value) for m in members.values()]\n551         else:\n552             return False, [(m.name, m.value) for m in members.values()\n553                            if m.directly_defined]\n554 \n555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n556                        ) -> List[Tuple[str, Any, bool]]:\n557         \"\"\"Filter the given member list.\n558 \n559         Members are skipped if\n560 \n561         - they are private (except if given explicitly or the private-members\n562           option is set)\n563         - they are special methods (except if given explicitly or the\n564           special-members option is set)\n565         - they are undocumented (except if the undoc-members option is set)\n566 \n567         The user can override the skipping decision by connecting to the\n568         ``autodoc-skip-member`` event.\n569         \"\"\"\n570         def is_filtered_inherited_member(name: str) -> bool:\n571             if inspect.isclass(self.object):\n572                 for cls in self.object.__mro__:\n573                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n574                         # given member is a member of specified *super class*\n575                         return True\n576                     elif name in cls.__dict__:\n577                         return False\n578 \n579             return False\n580 \n581         ret = []\n582 \n583         # search for members in source code too\n584         namespace = '.'.join(self.objpath)  # will be empty for modules\n585 \n586         if self.analyzer:\n587             attr_docs = self.analyzer.find_attr_docs()\n588         else:\n589             attr_docs = {}\n590 \n591         # process members and determine which to skip\n592         for (membername, member) in members:\n593             # if isattr is True, the member is documented as an attribute\n594             if member is INSTANCEATTR:\n595                 isattr = True\n596             else:\n597                 isattr = False\n598 \n599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n600                          self.parent, self.object_name)\n601             if not isinstance(doc, str):\n602                 # Ignore non-string __doc__\n603                 doc = None\n604 \n605             # if the member __doc__ is the same as self's __doc__, it's just\n606             # inherited and therefore not the member's doc\n607             cls = self.get_attr(member, '__class__', None)\n608             if cls:\n609                 cls_doc = self.get_attr(cls, '__doc__', None)\n610                 if cls_doc == doc:\n611                     doc = None\n612             has_doc = bool(doc)\n613 \n614             metadata = extract_metadata(doc)\n615             if 'private' in metadata:\n616                 # consider a member private if docstring has \"private\" metadata\n617                 isprivate = True\n618             elif 'public' in metadata:\n619                 # consider a member public if docstring has \"public\" metadata\n620                 isprivate = False\n621             else:\n622                 isprivate = membername.startswith('_')\n623 \n624             keep = False\n625             if safe_getattr(member, '__sphinx_mock__', False):\n626                 # mocked module or object\n627                 pass\n628             elif want_all and membername.startswith('__') and \\\n629                     membername.endswith('__') and len(membername) > 4:\n630                 # special __methods__\n631                 if self.options.special_members is ALL:\n632                     if membername == '__doc__':\n633                         keep = False\n634                     elif is_filtered_inherited_member(membername):\n635                         keep = False\n636                     else:\n637                         keep = has_doc or self.options.undoc_members\n638                 elif self.options.special_members:\n639                     if membername in self.options.special_members:\n640                         keep = has_doc or self.options.undoc_members\n641             elif (namespace, membername) in attr_docs:\n642                 if want_all and isprivate:\n643                     # ignore members whose name starts with _ by default\n644                     keep = self.options.private_members\n645                 else:\n646                     # keep documented attributes\n647                     keep = True\n648                 isattr = True\n649             elif want_all and isprivate:\n650                 # ignore members whose name starts with _ by default\n651                 keep = self.options.private_members and \\\n652                     (has_doc or self.options.undoc_members)\n653             else:\n654                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n655                     keep = False\n656                 else:\n657                     # ignore undocumented members if :undoc-members: is not given\n658                     keep = has_doc or self.options.undoc_members\n659 \n660             # give the user a chance to decide whether this member\n661             # should be skipped\n662             if self.env.app:\n663                 # let extensions preprocess docstrings\n664                 try:\n665                     skip_user = self.env.app.emit_firstresult(\n666                         'autodoc-skip-member', self.objtype, membername, member,\n667                         not keep, self.options)\n668                     if skip_user is not None:\n669                         keep = not skip_user\n670                 except Exception as exc:\n671                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n672                                       'the following exception was raised:\\n%s'),\n673                                    member, exc, type='autodoc')\n674                     keep = False\n675 \n676             if keep:\n677                 ret.append((membername, member, isattr))\n678 \n679         return ret\n680 \n681     def document_members(self, all_members: bool = False) -> None:\n682         \"\"\"Generate reST for member documentation.\n683 \n684         If *all_members* is True, do all members, else those given by\n685         *self.options.members*.\n686         \"\"\"\n687         # set current namespace for finding members\n688         self.env.temp_data['autodoc:module'] = self.modname\n689         if self.objpath:\n690             self.env.temp_data['autodoc:class'] = self.objpath[0]\n691 \n692         want_all = all_members or self.options.inherited_members or \\\n693             self.options.members is ALL\n694         # find out which members are documentable\n695         members_check_module, members = self.get_object_members(want_all)\n696 \n697         # remove members given by exclude-members\n698         if self.options.exclude_members:\n699             members = [\n700                 (membername, member) for (membername, member) in members\n701                 if (\n702                     self.options.exclude_members is ALL or\n703                     membername not in self.options.exclude_members\n704                 )\n705             ]\n706 \n707         # document non-skipped members\n708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n709         for (mname, member, isattr) in self.filter_members(members, want_all):\n710             classes = [cls for cls in self.documenters.values()\n711                        if cls.can_document_member(member, mname, isattr, self)]\n712             if not classes:\n713                 # don't know how to document this member\n714                 continue\n715             # prefer the documenter with the highest priority\n716             classes.sort(key=lambda cls: cls.priority)\n717             # give explicitly separated module name, so that members\n718             # of inner classes can be documented\n719             full_mname = self.modname + '::' + \\\n720                 '.'.join(self.objpath + [mname])\n721             documenter = classes[-1](self.directive, full_mname, self.indent)\n722             memberdocumenters.append((documenter, isattr))\n723 \n724         member_order = self.options.member_order or self.env.config.autodoc_member_order\n725         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n726 \n727         for documenter, isattr in memberdocumenters:\n728             documenter.generate(\n729                 all_members=True, real_modname=self.real_modname,\n730                 check_module=members_check_module and not isattr)\n731 \n732         # reset current objects\n733         self.env.temp_data['autodoc:module'] = None\n734         self.env.temp_data['autodoc:class'] = None\n735 \n736     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n737                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n738         \"\"\"Sort the given member list.\"\"\"\n739         if order == 'groupwise':\n740             # sort by group; alphabetically within groups\n741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n742         elif order == 'bysource':\n743             if self.analyzer:\n744                 # sort by source order, by virtue of the module analyzer\n745                 tagorder = self.analyzer.tagorder\n746 \n747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n748                     fullname = entry[0].name.split('::')[1]\n749                     return tagorder.get(fullname, len(tagorder))\n750                 documenters.sort(key=keyfunc)\n751             else:\n752                 # Assume that member discovery order matches source order.\n753                 # This is a reasonable assumption in Python 3.6 and up, where\n754                 # module.__dict__ is insertion-ordered.\n755                 pass\n756         else:  # alphabetical\n757             documenters.sort(key=lambda e: e[0].name)\n758 \n759         return documenters\n760 \n761     def generate(self, more_content: Any = None, real_modname: str = None,\n762                  check_module: bool = False, all_members: bool = False) -> None:\n763         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n764         its members.\n765 \n766         If *more_content* is given, include that content. If *real_modname* is\n767         given, use that module name to find attribute docs. If *check_module* is\n768         True, only generate if the object is defined in the module name it is\n769         imported from. If *all_members* is True, document all members.\n770         \"\"\"\n771         if not self.parse_name():\n772             # need a module to import\n773             logger.warning(\n774                 __('don\\'t know which module to import for autodocumenting '\n775                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n776                    'in the document, or giving an explicit module name)') %\n777                 self.name, type='autodoc')\n778             return\n779 \n780         # now, import the module and get object to document\n781         if not self.import_object():\n782             return\n783 \n784         # If there is no real module defined, figure out which to use.\n785         # The real module is used in the module analyzer to look up the module\n786         # where the attribute documentation would actually be found in.\n787         # This is used for situations where you have a module that collects the\n788         # functions and classes of internal submodules.\n789         guess_modname = self.get_real_modname()\n790         self.real_modname = real_modname or guess_modname\n791 \n792         # try to also get a source code analyzer for attribute docs\n793         try:\n794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n795             # parse right now, to get PycodeErrors on parsing (results will\n796             # be cached anyway)\n797             self.analyzer.find_attr_docs()\n798         except PycodeError:\n799             logger.debug('[autodoc] module analyzer failed:', exc_info=True)\n800             # no source file -- e.g. for builtin and C modules\n801             self.analyzer = None\n802             # at least add the module.__file__ as a dependency\n803             if hasattr(self.module, '__file__') and self.module.__file__:\n804                 self.directive.filename_set.add(self.module.__file__)\n805         else:\n806             self.directive.filename_set.add(self.analyzer.srcname)\n807 \n808         if self.real_modname != guess_modname:\n809             # Add module to dependency list if target object is defined in other module.\n810             try:\n811                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n812                 self.directive.filename_set.add(analyzer.srcname)\n813             except PycodeError:\n814                 pass\n815 \n816         # check __module__ of object (for members not given explicitly)\n817         if check_module:\n818             if not self.check_module():\n819                 return\n820 \n821         sourcename = self.get_sourcename()\n822 \n823         # make sure that the result starts with an empty line.  This is\n824         # necessary for some situations where another directive preprocesses\n825         # reST and no starting newline is present\n826         self.add_line('', sourcename)\n827 \n828         # format the object's signature, if any\n829         sig = self.format_signature()\n830 \n831         # generate the directive header and options, if applicable\n832         self.add_directive_header(sig)\n833         self.add_line('', sourcename)\n834 \n835         # e.g. the module directive doesn't have content\n836         self.indent += self.content_indent\n837 \n838         # add all content (from docstrings, attribute docs etc.)\n839         self.add_content(more_content)\n840 \n841         # document members, if possible\n842         self.document_members(all_members)\n843 \n844 \n845 class ModuleDocumenter(Documenter):\n846     \"\"\"\n847     Specialized Documenter subclass for modules.\n848     \"\"\"\n849     objtype = 'module'\n850     content_indent = ''\n851     titles_allowed = True\n852 \n853     option_spec = {\n854         'members': members_option, 'undoc-members': bool_option,\n855         'noindex': bool_option, 'inherited-members': inherited_members_option,\n856         'show-inheritance': bool_option, 'synopsis': identity,\n857         'platform': identity, 'deprecated': bool_option,\n858         'member-order': member_order_option, 'exclude-members': members_set_option,\n859         'private-members': bool_option, 'special-members': members_option,\n860         'imported-members': bool_option, 'ignore-module-all': bool_option\n861     }  # type: Dict[str, Callable]\n862 \n863     def __init__(self, *args: Any) -> None:\n864         super().__init__(*args)\n865         merge_special_members_option(self.options)\n866         self.__all__ = None\n867 \n868     @classmethod\n869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n870                             ) -> bool:\n871         # don't document submodules automatically\n872         return False\n873 \n874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n875                      ) -> Tuple[str, List[str]]:\n876         if modname is not None:\n877             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n878                            type='autodoc')\n879         return (path or '') + base, []\n880 \n881     def parse_name(self) -> bool:\n882         ret = super().parse_name()\n883         if self.args or self.retann:\n884             logger.warning(__('signature arguments or return annotation '\n885                               'given for automodule %s') % self.fullname,\n886                            type='autodoc')\n887         return ret\n888 \n889     def import_object(self) -> Any:\n890         def is_valid_module_all(__all__: Any) -> bool:\n891             \"\"\"Check the given *__all__* is valid for a module.\"\"\"\n892             if (isinstance(__all__, (list, tuple)) and\n893                     all(isinstance(e, str) for e in __all__)):\n894                 return True\n895             else:\n896                 return False\n897 \n898         ret = super().import_object()\n899 \n900         if not self.options.ignore_module_all:\n901             __all__ = getattr(self.object, '__all__', None)\n902             if is_valid_module_all(__all__):\n903                 # valid __all__ found. copy it to self.__all__\n904                 self.__all__ = __all__\n905             elif __all__:\n906                 # invalid __all__ found.\n907                 logger.warning(__('__all__ should be a list of strings, not %r '\n908                                   '(in module %s) -- ignoring __all__') %\n909                                (__all__, self.fullname), type='autodoc')\n910 \n911         return ret\n912 \n913     def add_directive_header(self, sig: str) -> None:\n914         Documenter.add_directive_header(self, sig)\n915 \n916         sourcename = self.get_sourcename()\n917 \n918         # add some module-specific options\n919         if self.options.synopsis:\n920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n921         if self.options.platform:\n922             self.add_line('   :platform: ' + self.options.platform, sourcename)\n923         if self.options.deprecated:\n924             self.add_line('   :deprecated:', sourcename)\n925 \n926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n927         if want_all:\n928             if self.__all__:\n929                 memberlist = self.__all__\n930             else:\n931                 # for implicit module members, check __module__ to avoid\n932                 # documenting imported objects\n933                 return True, get_module_members(self.object)\n934         else:\n935             memberlist = self.options.members or []\n936         ret = []\n937         for mname in memberlist:\n938             try:\n939                 ret.append((mname, safe_getattr(self.object, mname)))\n940             except AttributeError:\n941                 logger.warning(\n942                     __('missing attribute mentioned in :members: or __all__: '\n943                        'module %s, attribute %s') %\n944                     (safe_getattr(self.object, '__name__', '???'), mname),\n945                     type='autodoc'\n946                 )\n947         return False, ret\n948 \n949     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n950                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n951         if order == 'bysource' and self.__all__:\n952             # Sort alphabetically first (for members not listed on the __all__)\n953             documenters.sort(key=lambda e: e[0].name)\n954 \n955             # Sort by __all__\n956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n957                 name = entry[0].name.split('::')[1]\n958                 if name in self.__all__:\n959                     return self.__all__.index(name)\n960                 else:\n961                     return len(self.__all__)\n962             documenters.sort(key=keyfunc)\n963 \n964             return documenters\n965         else:\n966             return super().sort_members(documenters, order)\n967 \n968 \n969 class ModuleLevelDocumenter(Documenter):\n970     \"\"\"\n971     Specialized Documenter subclass for objects on module level (functions,\n972     classes, data/constants).\n973     \"\"\"\n974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n975                      ) -> Tuple[str, List[str]]:\n976         if modname is None:\n977             if path:\n978                 stripped = path.rstrip('.')\n979                 modname, qualname = split_full_qualified_name(stripped)\n980                 if qualname:\n981                     parents = qualname.split(\".\")\n982                 else:\n983                     parents = []\n984 \n985             if modname is None:\n986                 # if documenting a toplevel object without explicit module,\n987                 # it can be contained in another auto directive ...\n988                 modname = self.env.temp_data.get('autodoc:module')\n989                 # ... or in the scope of a module directive\n990                 if not modname:\n991                     modname = self.env.ref_context.get('py:module')\n992                 # ... else, it stays None, which means invalid\n993         return modname, parents + [base]\n994 \n995 \n996 class ClassLevelDocumenter(Documenter):\n997     \"\"\"\n998     Specialized Documenter subclass for objects on class level (methods,\n999     attributes).\n1000     \"\"\"\n1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1002                      ) -> Tuple[str, List[str]]:\n1003         if modname is None:\n1004             if path:\n1005                 mod_cls = path.rstrip('.')\n1006             else:\n1007                 mod_cls = None\n1008                 # if documenting a class-level object without path,\n1009                 # there must be a current class, either from a parent\n1010                 # auto directive ...\n1011                 mod_cls = self.env.temp_data.get('autodoc:class')\n1012                 # ... or from a class directive\n1013                 if mod_cls is None:\n1014                     mod_cls = self.env.ref_context.get('py:class')\n1015                 # ... if still None, there's no way to know\n1016                 if mod_cls is None:\n1017                     return None, []\n1018 \n1019             try:\n1020                 modname, qualname = split_full_qualified_name(mod_cls)\n1021                 parents = qualname.split(\".\") if qualname else []\n1022             except ImportError:\n1023                 parents = mod_cls.split(\".\")\n1024 \n1025             # if the module name is still missing, get it like above\n1026             if not modname:\n1027                 modname = self.env.temp_data.get('autodoc:module')\n1028             if not modname:\n1029                 modname = self.env.ref_context.get('py:module')\n1030             # ... else, it stays None, which means invalid\n1031         return modname, parents + [base]\n1032 \n1033 \n1034 class DocstringSignatureMixin:\n1035     \"\"\"\n1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1037     feature of reading the signature from the docstring.\n1038     \"\"\"\n1039 \n1040     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1041         if encoding is not None:\n1042             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1043                           \"deprecated.\" % self.__class__.__name__,\n1044                           RemovedInSphinx40Warning, stacklevel=2)\n1045         docstrings = self.get_doc()\n1046         self._new_docstrings = docstrings[:]\n1047         result = None\n1048         for i, doclines in enumerate(docstrings):\n1049             # no lines in docstring, no match\n1050             if not doclines:\n1051                 continue\n1052             # match first line of docstring against signature RE\n1053             match = py_ext_sig_re.match(doclines[0])\n1054             if not match:\n1055                 continue\n1056             exmod, path, base, args, retann = match.groups()\n1057             # the base name must match ours\n1058             valid_names = [self.objpath[-1]]  # type: ignore\n1059             if isinstance(self, ClassDocumenter):\n1060                 valid_names.append('__init__')\n1061                 if hasattr(self.object, '__mro__'):\n1062                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1063             if base not in valid_names:\n1064                 continue\n1065             # re-prepare docstring to ignore more leading indentation\n1066             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1067             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n1068                                                         tabsize=tab_width)\n1069             result = args, retann\n1070             # don't look any further\n1071             break\n1072         return result\n1073 \n1074     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1075         if encoding is not None:\n1076             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1077                           % self.__class__.__name__,\n1078                           RemovedInSphinx40Warning, stacklevel=2)\n1079         lines = getattr(self, '_new_docstrings', None)\n1080         if lines is not None:\n1081             return lines\n1082         return super().get_doc(None, ignore)  # type: ignore\n1083 \n1084     def format_signature(self, **kwargs: Any) -> str:\n1085         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1086             # only act if a signature is not explicitly given already, and if\n1087             # the feature is enabled\n1088             result = self._find_signature()\n1089             if result is not None:\n1090                 self.args, self.retann = result\n1091         return super().format_signature(**kwargs)  # type: ignore\n1092 \n1093 \n1094 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1095     \"\"\"\n1096     Mixin for AttributeDocumenter to provide the\n1097     feature of stripping any function signature from the docstring.\n1098     \"\"\"\n1099     def format_signature(self, **kwargs: Any) -> str:\n1100         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1101             # only act if a signature is not explicitly given already, and if\n1102             # the feature is enabled\n1103             result = self._find_signature()\n1104             if result is not None:\n1105                 # Discarding _args is a only difference with\n1106                 # DocstringSignatureMixin.format_signature.\n1107                 # Documenter.format_signature use self.args value to format.\n1108                 _args, self.retann = result\n1109         return super().format_signature(**kwargs)\n1110 \n1111 \n1112 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1113     \"\"\"\n1114     Specialized Documenter subclass for functions.\n1115     \"\"\"\n1116     objtype = 'function'\n1117     member_order = 30\n1118 \n1119     @classmethod\n1120     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1121                             ) -> bool:\n1122         # supports functions, builtins and bound methods exported at the module level\n1123         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1124                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1125 \n1126     def format_args(self, **kwargs: Any) -> str:\n1127         if self.env.config.autodoc_typehints in ('none', 'description'):\n1128             kwargs.setdefault('show_annotation', False)\n1129 \n1130         try:\n1131             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1132             if inspect.is_singledispatch_function(self.object):\n1133                 sig = inspect.signature(self.object, follow_wrapped=True)\n1134             else:\n1135                 sig = inspect.signature(self.object)\n1136             args = stringify_signature(sig, **kwargs)\n1137         except TypeError as exc:\n1138             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1139                            self.fullname, exc)\n1140             return None\n1141         except ValueError:\n1142             args = ''\n1143 \n1144         if self.env.config.strip_signature_backslash:\n1145             # escape backslashes for reST\n1146             args = args.replace('\\\\', '\\\\\\\\')\n1147         return args\n1148 \n1149     def document_members(self, all_members: bool = False) -> None:\n1150         pass\n1151 \n1152     def add_directive_header(self, sig: str) -> None:\n1153         sourcename = self.get_sourcename()\n1154         super().add_directive_header(sig)\n1155 \n1156         if inspect.iscoroutinefunction(self.object):\n1157             self.add_line('   :async:', sourcename)\n1158 \n1159     def format_signature(self, **kwargs: Any) -> str:\n1160         sig = super().format_signature(**kwargs)\n1161         sigs = [sig]\n1162 \n1163         if inspect.is_singledispatch_function(self.object):\n1164             # append signature of singledispatch'ed functions\n1165             for typ, func in self.object.registry.items():\n1166                 if typ is object:\n1167                     pass  # default implementation. skipped.\n1168                 else:\n1169                     self.annotate_to_first_argument(func, typ)\n1170 \n1171                     documenter = FunctionDocumenter(self.directive, '')\n1172                     documenter.object = func\n1173                     sigs.append(documenter.format_signature())\n1174 \n1175         return \"\\n\".join(sigs)\n1176 \n1177     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1178         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1179         sig = inspect.signature(func)\n1180         if len(sig.parameters) == 0:\n1181             return\n1182 \n1183         params = list(sig.parameters.values())\n1184         if params[0].annotation is Parameter.empty:\n1185             params[0] = params[0].replace(annotation=typ)\n1186             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1187 \n1188 \n1189 class SingledispatchFunctionDocumenter(FunctionDocumenter):\n1190     \"\"\"\n1191     Used to be a specialized Documenter subclass for singledispatch'ed functions.\n1192 \n1193     Retained for backwards compatibility, now does the same as the FunctionDocumenter\n1194     \"\"\"\n1195 \n1196 \n1197 class DecoratorDocumenter(FunctionDocumenter):\n1198     \"\"\"\n1199     Specialized Documenter subclass for decorator functions.\n1200     \"\"\"\n1201     objtype = 'decorator'\n1202 \n1203     # must be lower than FunctionDocumenter\n1204     priority = -1\n1205 \n1206     def format_args(self, **kwargs: Any) -> Any:\n1207         args = super().format_args(**kwargs)\n1208         if ',' in args:\n1209             return args\n1210         else:\n1211             return None\n1212 \n1213 \n1214 # Types which have confusing metaclass signatures it would be best not to show.\n1215 # These are listed by name, rather than storing the objects themselves, to avoid\n1216 # needing to import the modules.\n1217 _METACLASS_CALL_BLACKLIST = [\n1218     'enum.EnumMeta.__call__',\n1219 ]\n1220 \n1221 \n1222 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1223     \"\"\"\n1224     Specialized Documenter subclass for classes.\n1225     \"\"\"\n1226     objtype = 'class'\n1227     member_order = 20\n1228     option_spec = {\n1229         'members': members_option, 'undoc-members': bool_option,\n1230         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1231         'show-inheritance': bool_option, 'member-order': member_order_option,\n1232         'exclude-members': members_set_option,\n1233         'private-members': bool_option, 'special-members': members_option,\n1234     }  # type: Dict[str, Callable]\n1235 \n1236     def __init__(self, *args: Any) -> None:\n1237         super().__init__(*args)\n1238         merge_special_members_option(self.options)\n1239 \n1240     @classmethod\n1241     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1242                             ) -> bool:\n1243         return isinstance(member, type)\n1244 \n1245     def import_object(self) -> Any:\n1246         ret = super().import_object()\n1247         # if the class is documented under another name, document it\n1248         # as data/attribute\n1249         if ret:\n1250             if hasattr(self.object, '__name__'):\n1251                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1252             else:\n1253                 self.doc_as_attr = True\n1254         return ret\n1255 \n1256     def _get_signature(self) -> Optional[Signature]:\n1257         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1258             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1259             if inspect.is_builtin_class_method(obj, attr):\n1260                 return None\n1261             attr = self.get_attr(obj, attr, None)\n1262             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1263                 return None\n1264             return attr\n1265 \n1266         # This sequence is copied from inspect._signature_from_callable.\n1267         # ValueError means that no signature could be found, so we keep going.\n1268 \n1269         # First, let's see if it has an overloaded __call__ defined\n1270         # in its metaclass\n1271         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1272 \n1273         if call is not None:\n1274             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1275                 call = None\n1276 \n1277         if call is not None:\n1278             self.env.app.emit('autodoc-before-process-signature', call, True)\n1279             try:\n1280                 return inspect.signature(call, bound_method=True)\n1281             except ValueError:\n1282                 pass\n1283 \n1284         # Now we check if the 'obj' class has a '__new__' method\n1285         new = get_user_defined_function_or_method(self.object, '__new__')\n1286         if new is not None:\n1287             self.env.app.emit('autodoc-before-process-signature', new, True)\n1288             try:\n1289                 return inspect.signature(new, bound_method=True)\n1290             except ValueError:\n1291                 pass\n1292 \n1293         # Finally, we should have at least __init__ implemented\n1294         init = get_user_defined_function_or_method(self.object, '__init__')\n1295         if init is not None:\n1296             self.env.app.emit('autodoc-before-process-signature', init, True)\n1297             try:\n1298                 return inspect.signature(init, bound_method=True)\n1299             except ValueError:\n1300                 pass\n1301 \n1302         # None of the attributes are user-defined, so fall back to let inspect\n1303         # handle it.\n1304         # We don't know the exact method that inspect.signature will read\n1305         # the signature from, so just pass the object itself to our hook.\n1306         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1307         try:\n1308             return inspect.signature(self.object, bound_method=False)\n1309         except ValueError:\n1310             pass\n1311 \n1312         # Still no signature: happens e.g. for old-style classes\n1313         # with __init__ in C and no `__text_signature__`.\n1314         return None\n1315 \n1316     def format_args(self, **kwargs: Any) -> str:\n1317         if self.env.config.autodoc_typehints in ('none', 'description'):\n1318             kwargs.setdefault('show_annotation', False)\n1319 \n1320         try:\n1321             sig = self._get_signature()\n1322         except TypeError as exc:\n1323             # __signature__ attribute contained junk\n1324             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1325                            self.fullname, exc)\n1326             return None\n1327 \n1328         if sig is None:\n1329             return None\n1330 \n1331         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1332 \n1333     def format_signature(self, **kwargs: Any) -> str:\n1334         if self.doc_as_attr:\n1335             return ''\n1336 \n1337         return super().format_signature(**kwargs)\n1338 \n1339     def add_directive_header(self, sig: str) -> None:\n1340         sourcename = self.get_sourcename()\n1341 \n1342         if self.doc_as_attr:\n1343             self.directivetype = 'attribute'\n1344         super().add_directive_header(sig)\n1345 \n1346         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1347             self.add_line('   :final:', sourcename)\n1348 \n1349         # add inheritance info, if wanted\n1350         if not self.doc_as_attr and self.options.show_inheritance:\n1351             sourcename = self.get_sourcename()\n1352             self.add_line('', sourcename)\n1353             if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1354                 bases = [':class:`%s`' % b.__name__\n1355                          if b.__module__ in ('__builtin__', 'builtins')\n1356                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)\n1357                          for b in self.object.__bases__]\n1358                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),\n1359                               sourcename)\n1360 \n1361     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1362         if encoding is not None:\n1363             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1364                           % self.__class__.__name__,\n1365                           RemovedInSphinx40Warning, stacklevel=2)\n1366         lines = getattr(self, '_new_docstrings', None)\n1367         if lines is not None:\n1368             return lines\n1369 \n1370         content = self.env.config.autoclass_content\n1371 \n1372         docstrings = []\n1373         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1374         if attrdocstring:\n1375             docstrings.append(attrdocstring)\n1376 \n1377         # for classes, what the \"docstring\" is can be controlled via a\n1378         # config value; the default is only the class docstring\n1379         if content in ('both', 'init'):\n1380             __init__ = self.get_attr(self.object, '__init__', None)\n1381             initdocstring = getdoc(__init__, self.get_attr,\n1382                                    self.env.config.autodoc_inherit_docstrings,\n1383                                    self.parent, self.object_name)\n1384             # for new-style classes, no __init__ means default __init__\n1385             if (initdocstring is not None and\n1386                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1387                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1388                 initdocstring = None\n1389             if not initdocstring:\n1390                 # try __new__\n1391                 __new__ = self.get_attr(self.object, '__new__', None)\n1392                 initdocstring = getdoc(__new__, self.get_attr,\n1393                                        self.env.config.autodoc_inherit_docstrings,\n1394                                        self.parent, self.object_name)\n1395                 # for new-style classes, no __new__ means default __new__\n1396                 if (initdocstring is not None and\n1397                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1398                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1399                     initdocstring = None\n1400             if initdocstring:\n1401                 if content == 'init':\n1402                     docstrings = [initdocstring]\n1403                 else:\n1404                     docstrings.append(initdocstring)\n1405 \n1406         tab_width = self.directive.state.document.settings.tab_width\n1407         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1408 \n1409     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1410         if self.doc_as_attr:\n1411             classname = safe_getattr(self.object, '__qualname__', None)\n1412             if not classname:\n1413                 classname = safe_getattr(self.object, '__name__', None)\n1414             if classname:\n1415                 module = safe_getattr(self.object, '__module__', None)\n1416                 parentmodule = safe_getattr(self.parent, '__module__', None)\n1417                 if module and module != parentmodule:\n1418                     classname = str(module) + '.' + str(classname)\n1419                 content = StringList([_('alias of :class:`%s`') % classname], source='')\n1420                 super().add_content(content, no_docstring=True)\n1421         else:\n1422             super().add_content(more_content)\n1423 \n1424     def document_members(self, all_members: bool = False) -> None:\n1425         if self.doc_as_attr:\n1426             return\n1427         super().document_members(all_members)\n1428 \n1429     def generate(self, more_content: Any = None, real_modname: str = None,\n1430                  check_module: bool = False, all_members: bool = False) -> None:\n1431         # Do not pass real_modname and use the name from the __module__\n1432         # attribute of the class.\n1433         # If a class gets imported into the module real_modname\n1434         # the analyzer won't find the source of the class, if\n1435         # it looks in real_modname.\n1436         return super().generate(more_content=more_content,\n1437                                 check_module=check_module,\n1438                                 all_members=all_members)\n1439 \n1440 \n1441 class ExceptionDocumenter(ClassDocumenter):\n1442     \"\"\"\n1443     Specialized ClassDocumenter subclass for exceptions.\n1444     \"\"\"\n1445     objtype = 'exception'\n1446     member_order = 10\n1447 \n1448     # needs a higher priority than ClassDocumenter\n1449     priority = 10\n1450 \n1451     @classmethod\n1452     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1453                             ) -> bool:\n1454         return isinstance(member, type) and issubclass(member, BaseException)\n1455 \n1456 \n1457 class DataDocumenter(ModuleLevelDocumenter):\n1458     \"\"\"\n1459     Specialized Documenter subclass for data items.\n1460     \"\"\"\n1461     objtype = 'data'\n1462     member_order = 40\n1463     priority = -10\n1464     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1465     option_spec[\"annotation\"] = annotation_option\n1466 \n1467     @classmethod\n1468     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1469                             ) -> bool:\n1470         return isinstance(parent, ModuleDocumenter) and isattr\n1471 \n1472     def add_directive_header(self, sig: str) -> None:\n1473         super().add_directive_header(sig)\n1474         sourcename = self.get_sourcename()\n1475         if not self.options.annotation:\n1476             # obtain annotation for this data\n1477             annotations = getattr(self.parent, '__annotations__', {})\n1478             if annotations and self.objpath[-1] in annotations:\n1479                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1480                 self.add_line('   :type: ' + objrepr, sourcename)\n1481             else:\n1482                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1483                 if self.analyzer and key in self.analyzer.annotations:\n1484                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1485                                   sourcename)\n1486 \n1487             try:\n1488                 if self.object is UNINITIALIZED_ATTR:\n1489                     pass\n1490                 else:\n1491                     objrepr = object_description(self.object)\n1492                     self.add_line('   :value: ' + objrepr, sourcename)\n1493             except ValueError:\n1494                 pass\n1495         elif self.options.annotation is SUPPRESS:\n1496             pass\n1497         else:\n1498             self.add_line('   :annotation: %s' % self.options.annotation,\n1499                           sourcename)\n1500 \n1501     def document_members(self, all_members: bool = False) -> None:\n1502         pass\n1503 \n1504     def get_real_modname(self) -> str:\n1505         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1506             or self.modname\n1507 \n1508 \n1509 class DataDeclarationDocumenter(DataDocumenter):\n1510     \"\"\"\n1511     Specialized Documenter subclass for data that cannot be imported\n1512     because they are declared without initial value (refs: PEP-526).\n1513     \"\"\"\n1514     objtype = 'datadecl'\n1515     directivetype = 'data'\n1516     member_order = 60\n1517 \n1518     # must be higher than AttributeDocumenter\n1519     priority = 11\n1520 \n1521     @classmethod\n1522     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1523                             ) -> bool:\n1524         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1525         return (isinstance(parent, ModuleDocumenter) and\n1526                 isattr and\n1527                 member is INSTANCEATTR)\n1528 \n1529     def import_object(self) -> bool:\n1530         \"\"\"Never import anything.\"\"\"\n1531         # disguise as a data\n1532         self.objtype = 'data'\n1533         self.object = UNINITIALIZED_ATTR\n1534         try:\n1535             # import module to obtain type annotation\n1536             self.parent = importlib.import_module(self.modname)\n1537         except ImportError:\n1538             pass\n1539 \n1540         return True\n1541 \n1542     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1543         \"\"\"Never try to get a docstring from the object.\"\"\"\n1544         super().add_content(more_content, no_docstring=True)\n1545 \n1546 \n1547 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1548     \"\"\"\n1549     Specialized Documenter subclass for methods (normal, static and class).\n1550     \"\"\"\n1551     objtype = 'method'\n1552     directivetype = 'method'\n1553     member_order = 50\n1554     priority = 1  # must be more than FunctionDocumenter\n1555 \n1556     @classmethod\n1557     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1558                             ) -> bool:\n1559         return inspect.isroutine(member) and \\\n1560             not isinstance(parent, ModuleDocumenter)\n1561 \n1562     def import_object(self) -> Any:\n1563         ret = super().import_object()\n1564         if not ret:\n1565             return ret\n1566 \n1567         # to distinguish classmethod/staticmethod\n1568         obj = self.parent.__dict__.get(self.object_name)\n1569         if obj is None:\n1570             obj = self.object\n1571 \n1572         if (inspect.isclassmethod(obj) or\n1573                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n1574             # document class and static members before ordinary ones\n1575             self.member_order = self.member_order - 1\n1576 \n1577         return ret\n1578 \n1579     def format_args(self, **kwargs: Any) -> str:\n1580         if self.env.config.autodoc_typehints in ('none', 'description'):\n1581             kwargs.setdefault('show_annotation', False)\n1582 \n1583         try:\n1584             if self.object == object.__init__ and self.parent != object:\n1585                 # Classes not having own __init__() method are shown as no arguments.\n1586                 #\n1587                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n1588                 #       But it makes users confused.\n1589                 args = '()'\n1590             else:\n1591                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n1592                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1593                     sig = inspect.signature(self.object, bound_method=False)\n1594                 else:\n1595                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n1596 \n1597                     meth = self.parent.__dict__.get(self.objpath[-1], None)\n1598                     if meth and inspect.is_singledispatch_method(meth):\n1599                         sig = inspect.signature(self.object, bound_method=True,\n1600                                                 follow_wrapped=True)\n1601                     else:\n1602                         sig = inspect.signature(self.object, bound_method=True)\n1603                 args = stringify_signature(sig, **kwargs)\n1604         except TypeError as exc:\n1605             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1606                            self.fullname, exc)\n1607             return None\n1608         except ValueError:\n1609             args = ''\n1610 \n1611         if self.env.config.strip_signature_backslash:\n1612             # escape backslashes for reST\n1613             args = args.replace('\\\\', '\\\\\\\\')\n1614         return args\n1615 \n1616     def add_directive_header(self, sig: str) -> None:\n1617         super().add_directive_header(sig)\n1618 \n1619         sourcename = self.get_sourcename()\n1620         obj = self.parent.__dict__.get(self.object_name, self.object)\n1621         if inspect.isabstractmethod(obj):\n1622             self.add_line('   :abstractmethod:', sourcename)\n1623         if inspect.iscoroutinefunction(obj):\n1624             self.add_line('   :async:', sourcename)\n1625         if inspect.isclassmethod(obj):\n1626             self.add_line('   :classmethod:', sourcename)\n1627         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n1628             self.add_line('   :staticmethod:', sourcename)\n1629         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1630             self.add_line('   :final:', sourcename)\n1631 \n1632     def document_members(self, all_members: bool = False) -> None:\n1633         pass\n1634 \n1635     def format_signature(self, **kwargs: Any) -> str:\n1636         sig = super().format_signature(**kwargs)\n1637         sigs = [sig]\n1638 \n1639         meth = self.parent.__dict__.get(self.objpath[-1])\n1640         if inspect.is_singledispatch_method(meth):\n1641             # append signature of singledispatch'ed functions\n1642             for typ, func in meth.dispatcher.registry.items():\n1643                 if typ is object:\n1644                     pass  # default implementation. skipped.\n1645                 else:\n1646                     self.annotate_to_first_argument(func, typ)\n1647 \n1648                     documenter = MethodDocumenter(self.directive, '')\n1649                     documenter.parent = self.parent\n1650                     documenter.object = func\n1651                     documenter.objpath = [None]\n1652                     sigs.append(documenter.format_signature())\n1653 \n1654         return \"\\n\".join(sigs)\n1655 \n1656     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1657         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1658         sig = inspect.signature(func)\n1659         if len(sig.parameters) == 1:\n1660             return\n1661 \n1662         params = list(sig.parameters.values())\n1663         if params[1].annotation is Parameter.empty:\n1664             params[1] = params[1].replace(annotation=typ)\n1665             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1666 \n1667 \n1668 class SingledispatchMethodDocumenter(MethodDocumenter):\n1669     \"\"\"\n1670     Used to be a specialized Documenter subclass for singledispatch'ed methods.\n1671 \n1672     Retained for backwards compatibility, now does the same as the MethodDocumenter\n1673     \"\"\"\n1674 \n1675 \n1676 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1677     \"\"\"\n1678     Specialized Documenter subclass for attributes.\n1679     \"\"\"\n1680     objtype = 'attribute'\n1681     member_order = 60\n1682     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1683     option_spec[\"annotation\"] = annotation_option\n1684 \n1685     # must be higher than the MethodDocumenter, else it will recognize\n1686     # some non-data descriptors as methods\n1687     priority = 10\n1688 \n1689     @staticmethod\n1690     def is_function_or_method(obj: Any) -> bool:\n1691         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n1692 \n1693     @classmethod\n1694     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1695                             ) -> bool:\n1696         if inspect.isattributedescriptor(member):\n1697             return True\n1698         elif (not isinstance(parent, ModuleDocumenter) and\n1699               not inspect.isroutine(member) and\n1700               not isinstance(member, type)):\n1701             return True\n1702         else:\n1703             return False\n1704 \n1705     def document_members(self, all_members: bool = False) -> None:\n1706         pass\n1707 \n1708     def import_object(self) -> Any:\n1709         ret = super().import_object()\n1710         if inspect.isenumattribute(self.object):\n1711             self.object = self.object.value\n1712         if inspect.isattributedescriptor(self.object):\n1713             self._datadescriptor = True\n1714         else:\n1715             # if it's not a data descriptor\n1716             self._datadescriptor = False\n1717         return ret\n1718 \n1719     def get_real_modname(self) -> str:\n1720         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1721             or self.modname\n1722 \n1723     def add_directive_header(self, sig: str) -> None:\n1724         super().add_directive_header(sig)\n1725         sourcename = self.get_sourcename()\n1726         if not self.options.annotation:\n1727             # obtain type annotation for this attribute\n1728             annotations = getattr(self.parent, '__annotations__', {})\n1729             if annotations and self.objpath[-1] in annotations:\n1730                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1731                 self.add_line('   :type: ' + objrepr, sourcename)\n1732             else:\n1733                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1734                 if self.analyzer and key in self.analyzer.annotations:\n1735                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1736                                   sourcename)\n1737 \n1738             # data descriptors do not have useful values\n1739             if not self._datadescriptor:\n1740                 try:\n1741                     if self.object is INSTANCEATTR:\n1742                         pass\n1743                     else:\n1744                         objrepr = object_description(self.object)\n1745                         self.add_line('   :value: ' + objrepr, sourcename)\n1746                 except ValueError:\n1747                     pass\n1748         elif self.options.annotation is SUPPRESS:\n1749             pass\n1750         else:\n1751             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n1752 \n1753     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1754         if not self._datadescriptor:\n1755             # if it's not a data descriptor, its docstring is very probably the\n1756             # wrong thing to display\n1757             no_docstring = True\n1758         super().add_content(more_content, no_docstring)\n1759 \n1760 \n1761 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1762     \"\"\"\n1763     Specialized Documenter subclass for properties.\n1764     \"\"\"\n1765     objtype = 'property'\n1766     directivetype = 'method'\n1767     member_order = 60\n1768 \n1769     # before AttributeDocumenter\n1770     priority = AttributeDocumenter.priority + 1\n1771 \n1772     @classmethod\n1773     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1774                             ) -> bool:\n1775         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n1776 \n1777     def document_members(self, all_members: bool = False) -> None:\n1778         pass\n1779 \n1780     def get_real_modname(self) -> str:\n1781         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1782             or self.modname\n1783 \n1784     def add_directive_header(self, sig: str) -> None:\n1785         super().add_directive_header(sig)\n1786         sourcename = self.get_sourcename()\n1787         if inspect.isabstractmethod(self.object):\n1788             self.add_line('   :abstractmethod:', sourcename)\n1789         self.add_line('   :property:', sourcename)\n1790 \n1791 \n1792 class InstanceAttributeDocumenter(AttributeDocumenter):\n1793     \"\"\"\n1794     Specialized Documenter subclass for attributes that cannot be imported\n1795     because they are instance attributes (e.g. assigned in __init__).\n1796     \"\"\"\n1797     objtype = 'instanceattribute'\n1798     directivetype = 'attribute'\n1799     member_order = 60\n1800 \n1801     # must be higher than AttributeDocumenter\n1802     priority = 11\n1803 \n1804     @classmethod\n1805     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1806                             ) -> bool:\n1807         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1808         return (not isinstance(parent, ModuleDocumenter) and\n1809                 isattr and\n1810                 member is INSTANCEATTR)\n1811 \n1812     def import_object(self) -> bool:\n1813         \"\"\"Never import anything.\"\"\"\n1814         # disguise as an attribute\n1815         self.objtype = 'attribute'\n1816         self.object = INSTANCEATTR\n1817         self._datadescriptor = False\n1818         return True\n1819 \n1820     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1821         \"\"\"Never try to get a docstring from the object.\"\"\"\n1822         super().add_content(more_content, no_docstring=True)\n1823 \n1824 \n1825 class SlotsAttributeDocumenter(AttributeDocumenter):\n1826     \"\"\"\n1827     Specialized Documenter subclass for attributes that cannot be imported\n1828     because they are attributes in __slots__.\n1829     \"\"\"\n1830     objtype = 'slotsattribute'\n1831     directivetype = 'attribute'\n1832     member_order = 60\n1833 \n1834     # must be higher than AttributeDocumenter\n1835     priority = 11\n1836 \n1837     @classmethod\n1838     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1839                             ) -> bool:\n1840         \"\"\"This documents only SLOTSATTR members.\"\"\"\n1841         return member is SLOTSATTR\n1842 \n1843     def import_object(self) -> Any:\n1844         \"\"\"Never import anything.\"\"\"\n1845         # disguise as an attribute\n1846         self.objtype = 'attribute'\n1847         self._datadescriptor = True\n1848 \n1849         with mock(self.env.config.autodoc_mock_imports):\n1850             try:\n1851                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n1852                                     attrgetter=self.get_attr,\n1853                                     warningiserror=self.env.config.autodoc_warningiserror)\n1854                 self.module, _, _, self.parent = ret\n1855                 return True\n1856             except ImportError as exc:\n1857                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1858                 self.env.note_reread()\n1859                 return False\n1860 \n1861     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1862         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n1863         if ignore is not None:\n1864             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1865                           % self.__class__.__name__,\n1866                           RemovedInSphinx50Warning, stacklevel=2)\n1867         name = self.objpath[-1]\n1868         __slots__ = safe_getattr(self.parent, '__slots__', [])\n1869         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):\n1870             docstring = prepare_docstring(__slots__[name])\n1871             return [docstring]\n1872         else:\n1873             return []\n1874 \n1875 \n1876 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n1877     \"\"\"Returns registered Documenter classes\"\"\"\n1878     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n1879     return app.registry.documenters\n1880 \n1881 \n1882 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n1883     \"\"\"Alternative getattr() for types\"\"\"\n1884     for typ, func in app.registry.autodoc_attrgettrs.items():\n1885         if isinstance(obj, typ):\n1886             return func(obj, name, *defargs)\n1887 \n1888     return safe_getattr(obj, name, *defargs)\n1889 \n1890 \n1891 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n1892     if config.autodoc_member_order == 'alphabetic':\n1893         # RemovedInSphinx50Warning\n1894         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n1895                           'instead of \"alphabetic\". Please update your setting.'))\n1896         config.autodoc_member_order = 'alphabetical'  # type: ignore\n1897 \n1898 \n1899 def setup(app: Sphinx) -> Dict[str, Any]:\n1900     app.add_autodocumenter(ModuleDocumenter)\n1901     app.add_autodocumenter(ClassDocumenter)\n1902     app.add_autodocumenter(ExceptionDocumenter)\n1903     app.add_autodocumenter(DataDocumenter)\n1904     app.add_autodocumenter(DataDeclarationDocumenter)\n1905     app.add_autodocumenter(FunctionDocumenter)\n1906     app.add_autodocumenter(DecoratorDocumenter)\n1907     app.add_autodocumenter(MethodDocumenter)\n1908     app.add_autodocumenter(AttributeDocumenter)\n1909     app.add_autodocumenter(PropertyDocumenter)\n1910     app.add_autodocumenter(InstanceAttributeDocumenter)\n1911     app.add_autodocumenter(SlotsAttributeDocumenter)\n1912 \n1913     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n1914     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n1915                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n1916     app.add_config_value('autodoc_default_options', {}, True)\n1917     app.add_config_value('autodoc_docstring_signature', True, True)\n1918     app.add_config_value('autodoc_mock_imports', [], True)\n1919     app.add_config_value('autodoc_typehints', \"signature\", True,\n1920                          ENUM(\"signature\", \"description\", \"none\"))\n1921     app.add_config_value('autodoc_warningiserror', True, True)\n1922     app.add_config_value('autodoc_inherit_docstrings', True, True)\n1923     app.add_event('autodoc-before-process-signature')\n1924     app.add_event('autodoc-process-docstring')\n1925     app.add_event('autodoc-process-signature')\n1926     app.add_event('autodoc-skip-member')\n1927 \n1928     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n1929 \n1930     app.setup_extension('sphinx.ext.autodoc.type_comment')\n1931     app.setup_extension('sphinx.ext.autodoc.typehints')\n1932 \n1933     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "Enhance or tweak the parsing logic so it can identify and correctly handle multiple signatures within a single docstring for overloaded methods, allowing for all detected signatures to be documented without affecting the documentation generation for non-overloaded methods."
    },
    {
        "rel_file_path": "sphinx/util/inspect.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/util/inspect.py",
        "start": 1,
        "end": 734,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.inspect\n3     ~~~~~~~~~~~~~~~~~~~\n4 \n5     Helpers for inspecting Python modules.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import builtins\n12 import enum\n13 import inspect\n14 import re\n15 import sys\n16 import typing\n17 import warnings\n18 from functools import partial, partialmethod\n19 from inspect import (  # NOQA\n20     Parameter, isclass, ismethod, ismethoddescriptor\n21 )\n22 from io import StringIO\n23 from typing import Any, Callable, Mapping, List, Optional, Tuple\n24 from typing import cast\n25 \n26 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n27 from sphinx.pycode.ast import ast  # for py35-37\n28 from sphinx.pycode.ast import unparse as ast_unparse\n29 from sphinx.util import logging\n30 from sphinx.util.typing import stringify as stringify_annotation\n31 \n32 if sys.version_info > (3, 7):\n33     from types import (\n34         ClassMethodDescriptorType,\n35         MethodDescriptorType,\n36         WrapperDescriptorType\n37     )\n38 else:\n39     ClassMethodDescriptorType = type(object.__init__)\n40     MethodDescriptorType = type(str.join)\n41     WrapperDescriptorType = type(dict.__dict__['fromkeys'])\n42 \n43 logger = logging.getLogger(__name__)\n44 \n45 memory_address_re = re.compile(r' at 0x[0-9a-f]{8,16}(?=>)', re.IGNORECASE)\n46 \n47 \n48 # Copied from the definition of inspect.getfullargspec from Python master,\n49 # and modified to remove the use of special flags that break decorated\n50 # callables and bound methods in the name of backwards compatibility. Used\n51 # under the terms of PSF license v2, which requires the above statement\n52 # and the following:\n53 #\n54 #   Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n55 #   2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017 Python Software\n56 #   Foundation; All Rights Reserved\n57 def getargspec(func: Callable) -> Any:\n58     \"\"\"Like inspect.getfullargspec but supports bound methods, and wrapped\n59     methods.\"\"\"\n60     warnings.warn('sphinx.ext.inspect.getargspec() is deprecated',\n61                   RemovedInSphinx50Warning, stacklevel=2)\n62     # On 3.5+, signature(int) or similar raises ValueError. On 3.4, it\n63     # succeeds with a bogus signature. We want a TypeError uniformly, to\n64     # match historical behavior.\n65     if (isinstance(func, type) and\n66             is_builtin_class_method(func, \"__new__\") and\n67             is_builtin_class_method(func, \"__init__\")):\n68         raise TypeError(\n69             \"can't compute signature for built-in type {}\".format(func))\n70 \n71     sig = inspect.signature(func)\n72 \n73     args = []\n74     varargs = None\n75     varkw = None\n76     kwonlyargs = []\n77     defaults = ()\n78     annotations = {}\n79     defaults = ()\n80     kwdefaults = {}\n81 \n82     if sig.return_annotation is not sig.empty:\n83         annotations['return'] = sig.return_annotation\n84 \n85     for param in sig.parameters.values():\n86         kind = param.kind\n87         name = param.name\n88 \n89         if kind is Parameter.POSITIONAL_ONLY:\n90             args.append(name)\n91         elif kind is Parameter.POSITIONAL_OR_KEYWORD:\n92             args.append(name)\n93             if param.default is not param.empty:\n94                 defaults += (param.default,)  # type: ignore\n95         elif kind is Parameter.VAR_POSITIONAL:\n96             varargs = name\n97         elif kind is Parameter.KEYWORD_ONLY:\n98             kwonlyargs.append(name)\n99             if param.default is not param.empty:\n100                 kwdefaults[name] = param.default\n101         elif kind is Parameter.VAR_KEYWORD:\n102             varkw = name\n103 \n104         if param.annotation is not param.empty:\n105             annotations[name] = param.annotation\n106 \n107     if not kwdefaults:\n108         # compatibility with 'func.__kwdefaults__'\n109         kwdefaults = None\n110 \n111     if not defaults:\n112         # compatibility with 'func.__defaults__'\n113         defaults = None\n114 \n115     return inspect.FullArgSpec(args, varargs, varkw, defaults,\n116                                kwonlyargs, kwdefaults, annotations)\n117 \n118 \n119 def unwrap(obj: Any) -> Any:\n120     \"\"\"Get an original object from wrapped object (wrapped functions).\"\"\"\n121     try:\n122         return inspect.unwrap(obj)\n123     except ValueError:\n124         # might be a mock object\n125         return obj\n126 \n127 \n128 def unwrap_all(obj: Any, *, stop: Callable = None) -> Any:\n129     \"\"\"\n130     Get an original object from wrapped object (unwrapping partials, wrapped\n131     functions, and other decorators).\n132     \"\"\"\n133     while True:\n134         if stop and stop(obj):\n135             return obj\n136         elif ispartial(obj):\n137             obj = obj.func\n138         elif inspect.isroutine(obj) and hasattr(obj, '__wrapped__'):\n139             obj = obj.__wrapped__\n140         elif isclassmethod(obj):\n141             obj = obj.__func__\n142         elif isstaticmethod(obj):\n143             obj = obj.__func__\n144         else:\n145             return obj\n146 \n147 \n148 def isenumclass(x: Any) -> bool:\n149     \"\"\"Check if the object is subclass of enum.\"\"\"\n150     return inspect.isclass(x) and issubclass(x, enum.Enum)\n151 \n152 \n153 def isenumattribute(x: Any) -> bool:\n154     \"\"\"Check if the object is attribute of enum.\"\"\"\n155     return isinstance(x, enum.Enum)\n156 \n157 \n158 def unpartial(obj: Any) -> Any:\n159     \"\"\"Get an original object from partial object.\n160 \n161     This returns given object itself if not partial.\n162     \"\"\"\n163     while ispartial(obj):\n164         obj = obj.func\n165 \n166     return obj\n167 \n168 \n169 def ispartial(obj: Any) -> bool:\n170     \"\"\"Check if the object is partial.\"\"\"\n171     return isinstance(obj, (partial, partialmethod))\n172 \n173 \n174 def isclassmethod(obj: Any) -> bool:\n175     \"\"\"Check if the object is classmethod.\"\"\"\n176     if isinstance(obj, classmethod):\n177         return True\n178     elif inspect.ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):\n179         return True\n180 \n181     return False\n182 \n183 \n184 def isstaticmethod(obj: Any, cls: Any = None, name: str = None) -> bool:\n185     \"\"\"Check if the object is staticmethod.\"\"\"\n186     if isinstance(obj, staticmethod):\n187         return True\n188     elif cls and name:\n189         # trace __mro__ if the method is defined in parent class\n190         #\n191         # .. note:: This only works well with new style classes.\n192         for basecls in getattr(cls, '__mro__', [cls]):\n193             meth = basecls.__dict__.get(name)\n194             if meth:\n195                 if isinstance(meth, staticmethod):\n196                     return True\n197                 else:\n198                     return False\n199 \n200     return False\n201 \n202 \n203 def isdescriptor(x: Any) -> bool:\n204     \"\"\"Check if the object is some kind of descriptor.\"\"\"\n205     for item in '__get__', '__set__', '__delete__':\n206         if hasattr(safe_getattr(x, item, None), '__call__'):\n207             return True\n208     return False\n209 \n210 \n211 def isabstractmethod(obj: Any) -> bool:\n212     \"\"\"Check if the object is an abstractmethod.\"\"\"\n213     return safe_getattr(obj, '__isabstractmethod__', False) is True\n214 \n215 \n216 def is_cython_function_or_method(obj: Any) -> bool:\n217     \"\"\"Check if the object is a function or method in cython.\"\"\"\n218     try:\n219         return obj.__class__.__name__ == 'cython_function_or_method'\n220     except AttributeError:\n221         return False\n222 \n223 \n224 def isattributedescriptor(obj: Any) -> bool:\n225     \"\"\"Check if the object is an attribute like descriptor.\"\"\"\n226     if inspect.isdatadescriptor(obj):\n227         # data descriptor is kind of attribute\n228         return True\n229     elif isdescriptor(obj):\n230         # non data descriptor\n231         unwrapped = unwrap(obj)\n232         if isfunction(unwrapped) or isbuiltin(unwrapped) or inspect.ismethod(unwrapped):\n233             # attribute must not be either function, builtin and method\n234             return False\n235         elif is_cython_function_or_method(unwrapped):\n236             # attribute must not be either function and method (for cython)\n237             return False\n238         elif inspect.isclass(unwrapped):\n239             # attribute must not be a class\n240             return False\n241         elif isinstance(unwrapped, (ClassMethodDescriptorType,\n242                                     MethodDescriptorType,\n243                                     WrapperDescriptorType)):\n244             # attribute must not be a method descriptor\n245             return False\n246         elif type(unwrapped).__name__ == \"instancemethod\":\n247             # attribute must not be an instancemethod (C-API)\n248             return False\n249         else:\n250             return True\n251     else:\n252         return False\n253 \n254 \n255 def is_singledispatch_function(obj: Any) -> bool:\n256     \"\"\"Check if the object is singledispatch function.\"\"\"\n257     if (inspect.isfunction(obj) and\n258             hasattr(obj, 'dispatch') and\n259             hasattr(obj, 'register') and\n260             obj.dispatch.__module__ == 'functools'):\n261         return True\n262     else:\n263         return False\n264 \n265 \n266 def is_singledispatch_method(obj: Any) -> bool:\n267     \"\"\"Check if the object is singledispatch method.\"\"\"\n268     try:\n269         from functools import singledispatchmethod  # type: ignore\n270         return isinstance(obj, singledispatchmethod)\n271     except ImportError:  # py35-37\n272         return False\n273 \n274 \n275 def isfunction(obj: Any) -> bool:\n276     \"\"\"Check if the object is function.\"\"\"\n277     return inspect.isfunction(unwrap_all(obj))\n278 \n279 \n280 def isbuiltin(obj: Any) -> bool:\n281     \"\"\"Check if the object is builtin.\"\"\"\n282     return inspect.isbuiltin(unwrap_all(obj))\n283 \n284 \n285 def isroutine(obj: Any) -> bool:\n286     \"\"\"Check is any kind of function or method.\"\"\"\n287     return inspect.isroutine(unwrap_all(obj))\n288 \n289 \n290 def iscoroutinefunction(obj: Any) -> bool:\n291     \"\"\"Check if the object is coroutine-function.\"\"\"\n292     # unwrap staticmethod, classmethod and partial (except wrappers)\n293     obj = unwrap_all(obj, stop=lambda o: hasattr(o, '__wrapped__'))\n294     if hasattr(obj, '__code__') and inspect.iscoroutinefunction(obj):\n295         # check obj.__code__ because iscoroutinefunction() crashes for custom method-like\n296         # objects (see https://github.com/sphinx-doc/sphinx/issues/6605)\n297         return True\n298     else:\n299         return False\n300 \n301 \n302 def isproperty(obj: Any) -> bool:\n303     \"\"\"Check if the object is property.\"\"\"\n304     return isinstance(obj, property)\n305 \n306 \n307 def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n308     \"\"\"A getattr() that turns all exceptions into AttributeErrors.\"\"\"\n309     try:\n310         return getattr(obj, name, *defargs)\n311     except Exception:\n312         # sometimes accessing a property raises an exception (e.g.\n313         # NotImplementedError), so let's try to read the attribute directly\n314         try:\n315             # In case the object does weird things with attribute access\n316             # such that accessing `obj.__dict__` may raise an exception\n317             return obj.__dict__[name]\n318         except Exception:\n319             pass\n320 \n321         # this is a catch-all for all the weird things that some modules do\n322         # with attribute access\n323         if defargs:\n324             return defargs[0]\n325 \n326         raise AttributeError(name)\n327 \n328 \n329 def safe_getmembers(object: Any, predicate: Callable[[str], bool] = None,\n330                     attr_getter: Callable = safe_getattr) -> List[Tuple[str, Any]]:\n331     \"\"\"A version of inspect.getmembers() that uses safe_getattr().\"\"\"\n332     warnings.warn('safe_getmembers() is deprecated', RemovedInSphinx40Warning, stacklevel=2)\n333 \n334     results = []  # type: List[Tuple[str, Any]]\n335     for key in dir(object):\n336         try:\n337             value = attr_getter(object, key, None)\n338         except AttributeError:\n339             continue\n340         if not predicate or predicate(value):\n341             results.append((key, value))\n342     results.sort()\n343     return results\n344 \n345 \n346 def object_description(object: Any) -> str:\n347     \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n348     if isinstance(object, dict):\n349         try:\n350             sorted_keys = sorted(object)\n351         except Exception:\n352             pass  # Cannot sort dict keys, fall back to generic repr\n353         else:\n354             items = (\"%s: %s\" %\n355                      (object_description(key), object_description(object[key]))\n356                      for key in sorted_keys)\n357             return \"{%s}\" % \", \".join(items)\n358     if isinstance(object, set):\n359         try:\n360             sorted_values = sorted(object)\n361         except TypeError:\n362             pass  # Cannot sort set values, fall back to generic repr\n363         else:\n364             return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n365     if isinstance(object, frozenset):\n366         try:\n367             sorted_values = sorted(object)\n368         except TypeError:\n369             pass  # Cannot sort frozenset values, fall back to generic repr\n370         else:\n371             return \"frozenset({%s})\" % \", \".join(object_description(x)\n372                                                  for x in sorted_values)\n373     try:\n374         s = repr(object)\n375     except Exception:\n376         raise ValueError\n377     # Strip non-deterministic memory addresses such as\n378     # ``<__main__.A at 0x7f68cb685710>``\n379     s = memory_address_re.sub('', s)\n380     return s.replace('\\n', ' ')\n381 \n382 \n383 def is_builtin_class_method(obj: Any, attr_name: str) -> bool:\n384     \"\"\"If attr_name is implemented at builtin class, return True.\n385 \n386         >>> is_builtin_class_method(int, '__init__')\n387         True\n388 \n389     Why this function needed? CPython implements int.__init__ by Descriptor\n390     but PyPy implements it by pure Python code.\n391     \"\"\"\n392     try:\n393         mro = inspect.getmro(obj)\n394     except AttributeError:\n395         # no __mro__, assume the object has no methods as we know them\n396         return False\n397 \n398     try:\n399         cls = next(c for c in mro if attr_name in safe_getattr(c, '__dict__', {}))\n400     except StopIteration:\n401         return False\n402 \n403     try:\n404         name = safe_getattr(cls, '__name__')\n405     except AttributeError:\n406         return False\n407 \n408     return getattr(builtins, name, None) is cls\n409 \n410 \n411 def signature(subject: Callable, bound_method: bool = False, follow_wrapped: bool = False\n412               ) -> inspect.Signature:\n413     \"\"\"Return a Signature object for the given *subject*.\n414 \n415     :param bound_method: Specify *subject* is a bound method or not\n416     :param follow_wrapped: Same as ``inspect.signature()``.\n417                            Defaults to ``False`` (get a signature of *subject*).\n418     \"\"\"\n419     try:\n420         try:\n421             signature = inspect.signature(subject, follow_wrapped=follow_wrapped)\n422         except ValueError:\n423             # follow built-in wrappers up (ex. functools.lru_cache)\n424             signature = inspect.signature(subject)\n425         parameters = list(signature.parameters.values())\n426         return_annotation = signature.return_annotation\n427     except IndexError:\n428         # Until python 3.6.4, cpython has been crashed on inspection for\n429         # partialmethods not having any arguments.\n430         # https://bugs.python.org/issue33009\n431         if hasattr(subject, '_partialmethod'):\n432             parameters = []\n433             return_annotation = Parameter.empty\n434         else:\n435             raise\n436 \n437     try:\n438         # Update unresolved annotations using ``get_type_hints()``.\n439         annotations = typing.get_type_hints(subject)\n440         for i, param in enumerate(parameters):\n441             if isinstance(param.annotation, str) and param.name in annotations:\n442                 parameters[i] = param.replace(annotation=annotations[param.name])\n443         if 'return' in annotations:\n444             return_annotation = annotations['return']\n445     except Exception:\n446         # ``get_type_hints()`` does not support some kind of objects like partial,\n447         # ForwardRef and so on.\n448         pass\n449 \n450     if bound_method:\n451         if inspect.ismethod(subject):\n452             # ``inspect.signature()`` considers the subject is a bound method and removes\n453             # first argument from signature.  Therefore no skips are needed here.\n454             pass\n455         else:\n456             if len(parameters) > 0:\n457                 parameters.pop(0)\n458 \n459     return inspect.Signature(parameters, return_annotation=return_annotation)\n460 \n461 \n462 def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n463                         show_return_annotation: bool = True) -> str:\n464     \"\"\"Stringify a Signature object.\n465 \n466     :param show_annotation: Show annotation in result\n467     \"\"\"\n468     args = []\n469     last_kind = None\n470     for param in sig.parameters.values():\n471         if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n472             # PEP-570: Separator for Positional Only Parameter: /\n473             args.append('/')\n474         if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n475                                                               param.POSITIONAL_ONLY,\n476                                                               None):\n477             # PEP-3102: Separator for Keyword Only Parameter: *\n478             args.append('*')\n479 \n480         arg = StringIO()\n481         if param.kind == param.VAR_POSITIONAL:\n482             arg.write('*' + param.name)\n483         elif param.kind == param.VAR_KEYWORD:\n484             arg.write('**' + param.name)\n485         else:\n486             arg.write(param.name)\n487 \n488         if show_annotation and param.annotation is not param.empty:\n489             arg.write(': ')\n490             arg.write(stringify_annotation(param.annotation))\n491         if param.default is not param.empty:\n492             if show_annotation and param.annotation is not param.empty:\n493                 arg.write(' = ')\n494             else:\n495                 arg.write('=')\n496             arg.write(object_description(param.default))\n497 \n498         args.append(arg.getvalue())\n499         last_kind = param.kind\n500 \n501     if last_kind == Parameter.POSITIONAL_ONLY:\n502         # PEP-570: Separator for Positional Only Parameter: /\n503         args.append('/')\n504 \n505     if (sig.return_annotation is Parameter.empty or\n506             show_annotation is False or\n507             show_return_annotation is False):\n508         return '(%s)' % ', '.join(args)\n509     else:\n510         annotation = stringify_annotation(sig.return_annotation)\n511         return '(%s) -> %s' % (', '.join(args), annotation)\n512 \n513 \n514 def signature_from_str(signature: str) -> inspect.Signature:\n515     \"\"\"Create a Signature object from string.\"\"\"\n516     module = ast.parse('def func' + signature + ': pass')\n517     definition = cast(ast.FunctionDef, module.body[0])  # type: ignore\n518 \n519     # parameters\n520     args = definition.args\n521     params = []\n522 \n523     if hasattr(args, \"posonlyargs\"):\n524         for arg in args.posonlyargs:  # type: ignore\n525             annotation = ast_unparse(arg.annotation) or Parameter.empty\n526             params.append(Parameter(arg.arg, Parameter.POSITIONAL_ONLY,\n527                                     annotation=annotation))\n528 \n529     for i, arg in enumerate(args.args):\n530         if len(args.args) - i <= len(args.defaults):\n531             default = ast_unparse(args.defaults[-len(args.args) + i])\n532         else:\n533             default = Parameter.empty\n534 \n535         annotation = ast_unparse(arg.annotation) or Parameter.empty\n536         params.append(Parameter(arg.arg, Parameter.POSITIONAL_OR_KEYWORD,\n537                                 default=default, annotation=annotation))\n538 \n539     if args.vararg:\n540         annotation = ast_unparse(args.vararg.annotation) or Parameter.empty\n541         params.append(Parameter(args.vararg.arg, Parameter.VAR_POSITIONAL,\n542                                 annotation=annotation))\n543 \n544     for i, arg in enumerate(args.kwonlyargs):\n545         default = ast_unparse(args.kw_defaults[i]) or Parameter.empty\n546         annotation = ast_unparse(arg.annotation) or Parameter.empty\n547         params.append(Parameter(arg.arg, Parameter.KEYWORD_ONLY, default=default,\n548                                 annotation=annotation))\n549 \n550     if args.kwarg:\n551         annotation = ast_unparse(args.kwarg.annotation) or Parameter.empty\n552         params.append(Parameter(args.kwarg.arg, Parameter.VAR_KEYWORD,\n553                                 annotation=annotation))\n554 \n555     return_annotation = ast_unparse(definition.returns) or Parameter.empty\n556 \n557     return inspect.Signature(params, return_annotation=return_annotation)\n558 \n559 \n560 class Signature:\n561     \"\"\"The Signature object represents the call signature of a callable object and\n562     its return annotation.\n563     \"\"\"\n564 \n565     empty = inspect.Signature.empty\n566 \n567     def __init__(self, subject: Callable, bound_method: bool = False,\n568                  has_retval: bool = True) -> None:\n569         warnings.warn('sphinx.util.inspect.Signature() is deprecated',\n570                       RemovedInSphinx40Warning, stacklevel=2)\n571 \n572         # check subject is not a built-in class (ex. int, str)\n573         if (isinstance(subject, type) and\n574                 is_builtin_class_method(subject, \"__new__\") and\n575                 is_builtin_class_method(subject, \"__init__\")):\n576             raise TypeError(\"can't compute signature for built-in type {}\".format(subject))\n577 \n578         self.subject = subject\n579         self.has_retval = has_retval\n580         self.partialmethod_with_noargs = False\n581 \n582         try:\n583             self.signature = inspect.signature(subject)  # type: Optional[inspect.Signature]\n584         except IndexError:\n585             # Until python 3.6.4, cpython has been crashed on inspection for\n586             # partialmethods not having any arguments.\n587             # https://bugs.python.org/issue33009\n588             if hasattr(subject, '_partialmethod'):\n589                 self.signature = None\n590                 self.partialmethod_with_noargs = True\n591             else:\n592                 raise\n593 \n594         try:\n595             self.annotations = typing.get_type_hints(subject)\n596         except Exception:\n597             # get_type_hints() does not support some kind of objects like partial,\n598             # ForwardRef and so on.  For them, it raises an exception. In that case,\n599             # we try to build annotations from argspec.\n600             self.annotations = {}\n601 \n602         if bound_method:\n603             # client gives a hint that the subject is a bound method\n604 \n605             if inspect.ismethod(subject):\n606                 # inspect.signature already considers the subject is bound method.\n607                 # So it is not need to skip first argument.\n608                 self.skip_first_argument = False\n609             else:\n610                 self.skip_first_argument = True\n611         else:\n612             # inspect.signature recognizes type of method properly without any hints\n613             self.skip_first_argument = False\n614 \n615     @property\n616     def parameters(self) -> Mapping:\n617         if self.partialmethod_with_noargs:\n618             return {}\n619         else:\n620             return self.signature.parameters\n621 \n622     @property\n623     def return_annotation(self) -> Any:\n624         if self.signature:\n625             if self.has_retval:\n626                 return self.signature.return_annotation\n627             else:\n628                 return Parameter.empty\n629         else:\n630             return None\n631 \n632     def format_args(self, show_annotation: bool = True) -> str:\n633         def get_annotation(param: Parameter) -> Any:\n634             if isinstance(param.annotation, str) and param.name in self.annotations:\n635                 return self.annotations[param.name]\n636             else:\n637                 return param.annotation\n638 \n639         args = []\n640         last_kind = None\n641         for i, param in enumerate(self.parameters.values()):\n642             # skip first argument if subject is bound method\n643             if self.skip_first_argument and i == 0:\n644                 continue\n645 \n646             arg = StringIO()\n647 \n648             # insert '*' between POSITIONAL args and KEYWORD_ONLY args::\n649             #     func(a, b, *, c, d):\n650             if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n651                                                                   param.POSITIONAL_ONLY,\n652                                                                   None):\n653                 args.append('*')\n654 \n655             if param.kind in (param.POSITIONAL_ONLY,\n656                               param.POSITIONAL_OR_KEYWORD,\n657                               param.KEYWORD_ONLY):\n658                 arg.write(param.name)\n659                 if show_annotation and param.annotation is not param.empty:\n660                     arg.write(': ')\n661                     arg.write(stringify_annotation(get_annotation(param)))\n662                 if param.default is not param.empty:\n663                     if param.annotation is param.empty or show_annotation is False:\n664                         arg.write('=')\n665                         arg.write(object_description(param.default))\n666                     else:\n667                         arg.write(' = ')\n668                         arg.write(object_description(param.default))\n669             elif param.kind == param.VAR_POSITIONAL:\n670                 arg.write('*')\n671                 arg.write(param.name)\n672                 if show_annotation and param.annotation is not param.empty:\n673                     arg.write(': ')\n674                     arg.write(stringify_annotation(get_annotation(param)))\n675             elif param.kind == param.VAR_KEYWORD:\n676                 arg.write('**')\n677                 arg.write(param.name)\n678                 if show_annotation and param.annotation is not param.empty:\n679                     arg.write(': ')\n680                     arg.write(stringify_annotation(get_annotation(param)))\n681 \n682             args.append(arg.getvalue())\n683             last_kind = param.kind\n684 \n685         if self.return_annotation is Parameter.empty or show_annotation is False:\n686             return '(%s)' % ', '.join(args)\n687         else:\n688             if 'return' in self.annotations:\n689                 annotation = stringify_annotation(self.annotations['return'])\n690             else:\n691                 annotation = stringify_annotation(self.return_annotation)\n692 \n693             return '(%s) -> %s' % (', '.join(args), annotation)\n694 \n695     def format_annotation(self, annotation: Any) -> str:\n696         \"\"\"Return formatted representation of a type annotation.\"\"\"\n697         return stringify_annotation(annotation)\n698 \n699     def format_annotation_new(self, annotation: Any) -> str:\n700         \"\"\"format_annotation() for py37+\"\"\"\n701         return stringify_annotation(annotation)\n702 \n703     def format_annotation_old(self, annotation: Any) -> str:\n704         \"\"\"format_annotation() for py36 or below\"\"\"\n705         return stringify_annotation(annotation)\n706 \n707 \n708 def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n709            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n710     \"\"\"Get the docstring for the object.\n711 \n712     This tries to obtain the docstring for some kind of objects additionally:\n713 \n714     * partial functions\n715     * inherited docstring\n716     * inherited decorated methods\n717     \"\"\"\n718     doc = attrgetter(obj, '__doc__', None)\n719     if ispartial(obj) and doc == obj.__class__.__doc__:\n720         return getdoc(obj.func)\n721     elif doc is None and allow_inherited:\n722         doc = inspect.getdoc(obj)\n723 \n724         if doc is None and cls:\n725             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n726             # This tries to obtain the docstring from super classes.\n727             for basecls in getattr(cls, '__mro__', []):\n728                 meth = safe_getattr(basecls, name, None)\n729                 if meth is not None:\n730                     doc = inspect.getdoc(meth)\n731                     if doc:\n732                         break\n733 \n734     return doc\n",
        "intended_behavior": "Ensure that the inspection logic can recognize and separate multiple signatures when present within a single docstring, and accurately pass this information onto the Sphinx autodoc extension for documentation generation."
    }
]