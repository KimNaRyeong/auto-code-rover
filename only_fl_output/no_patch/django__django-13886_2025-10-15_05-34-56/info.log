2025-10-15 05:34:56.594 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:34:59.626 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=168, output_tokens=12, cost=0.002040
2025-10-15 05:34:59.627 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 05:34:59.631 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:35:10.474 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=472, output_tokens=407, cost=0.016930
2025-10-15 05:35:10.481 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:35:13.956 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=761, output_tokens=64, cost=0.009530
2025-10-15 05:35:13.958 | DEBUG    | Extracted a valid json.
2025-10-15 05:35:13.958 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"check\")",
        "search_class(\"SystemCheck\")",
        "search_code(\"Meta.indexes\")",
        "search_method(\"Query._gen_cols\")",
        "search_code(\"#26167\")"
    ],
    "bug_locations": []
}
2025-10-15 05:35:14.030 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:35:14.030 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:35:33.818 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1574, output_tokens=781, cost=0.039170
2025-10-15 05:35:33.826 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:35:40.661 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2571, output_tokens=269, cost=0.033780
2025-10-15 05:35:40.667 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:35:48.170 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=623, output_tokens=189, cost=0.011900
2025-10-15 05:35:48.171 | DEBUG    | Extracted a valid json.
2025-10-15 05:35:48.171 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/backends/base/schema.py",
            "class": "BaseDatabaseSchemaEditor",
            "method": "_model_indexes_sql",
            "intended_behavior": "This method is responsible for generating SQL for all indexes of a model, including field indexes, index_together, and Meta.indexes. The intended behavior here would be to extend this method or add a preliminary step to it that performs a check on the validity of model field names within functional indexes defined in Meta.indexes. This check should ensure that any expressions used within functional indexes refer to valid fields on the model. If invalid fields are detected, the system should raise an appropriate warning or error before proceeding with SQL generation. This validation step should be designed to only affect models with functional indexes, preserving the existing functionality for all other models and index types."
        }
    ]
}
2025-10-15 05:35:48.183 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>_model_indexes_sql</method>
<code>
1053     def _model_indexes_sql(self, model):
1054         """
1055         Return a list of all index SQL statements (field indexes,
1056         index_together, Meta.indexes) for the specified model.
1057         """
1058         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1059             return []
1060         output = []
1061         for field in model._meta.local_fields:
1062             output.extend(self._field_indexes_sql(model, field))
1063 
1064         for field_names in model._meta.index_together:
1065             fields = [model._meta.get_field(field) for field in field_names]
1066             output.append(self._create_index_sql(model, fields=fields, suffix='_idx'))
1067 
1068         for index in model._meta.indexes:
1069             if (
1070                 not index.contains_expressions or
1071                 self.connection.features.supports_expression_indexes
1072             ):
1073                 output.append(index.create_sql(model, self))
1074         return output

</code><intended_behavior>This method is responsible for generating SQL for all indexes of a model, including field indexes, index_together, and Meta.indexes. The intended behavior here would be to extend this method or add a preliminary step to it that performs a check on the validity of model field names within functional indexes defined in Meta.indexes. This check should ensure that any expressions used within functional indexes refer to valid fields on the model. If invalid fields are detected, the system should raise an appropriate warning or error before proceeding with SQL generation. This validation step should be designed to only affect models with functional indexes, preserving the existing functionality for all other models and index types.</intended_behavior>, <file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>None</method>
<code>
45 class BaseDatabaseSchemaEditor:
46     """
47     This class and its subclasses are responsible for emitting schema-changing
48     statements to the databases - model creation/removal/alteration, field
49     renaming, index fiddling, and so on.
50     """
51 
52     # Overrideable SQL templates
53     sql_create_table = "CREATE TABLE %(table)s (%(definition)s)"
54     sql_rename_table = "ALTER TABLE %(old_table)s RENAME TO %(new_table)s"
55     sql_retablespace_table = "ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s"
56     sql_delete_table = "DROP TABLE %(table)s CASCADE"
57 
58     sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
59     sql_alter_column = "ALTER TABLE %(table)s %(changes)s"
60     sql_alter_column_type = "ALTER COLUMN %(column)s TYPE %(type)s"
61     sql_alter_column_null = "ALTER COLUMN %(column)s DROP NOT NULL"
62     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
63     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
64     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
65     sql_alter_column_collate = "ALTER COLUMN %(column)s TYPE %(type)s%(collation)s"
66     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
67     sql_rename_column = "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
68     sql_update_with_default = "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
69 
70     sql_unique_constraint = "UNIQUE (%(columns)s)%(deferrable)s"
71     sql_check_constraint = "CHECK (%(check)s)"
72     sql_delete_constraint = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
73     sql_constraint = "CONSTRAINT %(name)s %(constraint)s"
74 
75     sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
76     sql_delete_check = sql_delete_constraint
77 
78     sql_create_unique = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)%(deferrable)s"
79     sql_delete_unique = sql_delete_constraint
80 
81     sql_create_fk = (
82         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
83         "REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s"
84     )
85     sql_create_inline_fk = None
86     sql_create_column_inline_fk = None
87     sql_delete_fk = sql_delete_constraint
88 
89     sql_create_index = "CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(extra)s%(condition)s"
90     sql_create_unique_index = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(condition)s"
91     sql_delete_index = "DROP INDEX %(name)s"
92 
93     sql_create_pk = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
94     sql_delete_pk = sql_delete_constraint
95 
96     sql_delete_procedure = 'DROP PROCEDURE %(procedure)s'
97 
98     def __init__(self, connection, collect_sql=False, atomic=True):
99         self.connection = connection
100         self.collect_sql = collect_sql
101         if self.collect_sql:
102             self.collected_sql = []
103         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
104 
105     # State-managing methods
106 
107     def __enter__(self):
108         self.deferred_sql = []
109         if self.atomic_migration:
110             self.atomic = atomic(self.connection.alias)
111             self.atomic.__enter__()
112         return self
113 
114     def __exit__(self, exc_type, exc_value, traceback):
115         if exc_type is None:
116             for sql in self.deferred_sql:
117                 self.execute(sql)
118         if self.atomic_migration:
119             self.atomic.__exit__(exc_type, exc_value, traceback)
120 
121     # Core utility functions
122 
123     def execute(self, sql, params=()):
124         """Execute the given SQL statement, with optional parameters."""
125         # Don't perform the transactional DDL check if SQL is being collected
126         # as it's not going to be executed anyway.
127         if not self.collect_sql and self.connection.in_atomic_block and not self.connection.features.can_rollback_ddl:
128             raise TransactionManagementError(
129                 "Executing DDL statements while in a transaction on databases "
130                 "that can't perform a rollback is prohibited."
131             )
132         # Account for non-string statement objects.
133         sql = str(sql)
134         # Log the command we're running, then run it
135         logger.debug("%s; (params %r)", sql, params, extra={'params': params, 'sql': sql})
136         if self.collect_sql:
137             ending = "" if sql.endswith(";") else ";"
138             if params is not None:
139                 self.collected_sql.append((sql % tuple(map(self.quote_value, params))) + ending)
140             else:
141                 self.collected_sql.append(sql + ending)
142         else:
143             with self.connection.cursor() as cursor:
144                 cursor.execute(sql, params)
145 
146     def quote_name(self, name):
147         return self.connection.ops.quote_name(name)
148 
149     def table_sql(self, model):
150         """Take a model and return its table definition."""
151         # Add any unique_togethers (always deferred, as some fields might be
152         # created afterwards, like geometry fields with some backends).
153         for fields in model._meta.unique_together:
154             columns = [model._meta.get_field(field).column for field in fields]
155             self.deferred_sql.append(self._create_unique_sql(model, columns))
156         # Create column SQL, add FK deferreds if needed.
157         column_sqls = []
158         params = []
159         for field in model._meta.local_fields:
160             # SQL.
161             definition, extra_params = self.column_sql(model, field)
162             if definition is None:
163                 continue
164             # Check constraints can go on the column SQL here.
165             db_params = field.db_parameters(connection=self.connection)
166             if db_params['check']:
167                 definition += ' ' + self.sql_check_constraint % db_params
168             # Autoincrement SQL (for backends with inline variant).
169             col_type_suffix = field.db_type_suffix(connection=self.connection)
170             if col_type_suffix:
171                 definition += ' %s' % col_type_suffix
172             params.extend(extra_params)
173             # FK.
174             if field.remote_field and field.db_constraint:
175                 to_table = field.remote_field.model._meta.db_table
176                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
177                 if self.sql_create_inline_fk:
178                     definition += ' ' + self.sql_create_inline_fk % {
179                         'to_table': self.quote_name(to_table),
180                         'to_column': self.quote_name(to_column),
181                     }
182                 elif self.connection.features.supports_foreign_keys:
183                     self.deferred_sql.append(self._create_fk_sql(model, field, '_fk_%(to_table)s_%(to_column)s'))
184             # Add the SQL to our big list.
185             column_sqls.append('%s %s' % (
186                 self.quote_name(field.column),
187                 definition,
188             ))
189             # Autoincrement SQL (for backends with post table definition
190             # variant).
191             if field.get_internal_type() in ('AutoField', 'BigAutoField', 'SmallAutoField'):
192                 autoinc_sql = self.connection.ops.autoinc_sql(model._meta.db_table, field.column)
193                 if autoinc_sql:
194                     self.deferred_sql.extend(autoinc_sql)
195         constraints = [constraint.constraint_sql(model, self) for constraint in model._meta.constraints]
196         sql = self.sql_create_table % {
197             'table': self.quote_name(model._meta.db_table),
198             'definition': ', '.join(constraint for constraint in (*column_sqls, *constraints) if constraint),
199         }
200         if model._meta.db_tablespace:
201             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)
202             if tablespace_sql:
203                 sql += ' ' + tablespace_sql
204         return sql, params
205 
206     # Field <-> database mapping functions
207 
208     def column_sql(self, model, field, include_default=False):
209         """
210         Take a field and return its column definition.
211         The field must already have had set_attributes_from_name() called.
212         """
213         # Get the column's type and use that as the basis of the SQL
214         db_params = field.db_parameters(connection=self.connection)
215         sql = db_params['type']
216         params = []
217         # Check for fields that aren't actually columns (e.g. M2M)
218         if sql is None:
219             return None, None
220         # Collation.
221         collation = getattr(field, 'db_collation', None)
222         if collation:
223             sql += self._collate_sql(collation)
224         # Work out nullability
225         null = field.null
226         # If we were told to include a default value, do so
227         include_default = include_default and not self.skip_default(field)
228         if include_default:
229             default_value = self.effective_default(field)
230             column_default = ' DEFAULT ' + self._column_default_sql(field)
231             if default_value is not None:
232                 if self.connection.features.requires_literal_defaults:
233                     # Some databases can't take defaults as a parameter (oracle)
234                     # If this is the case, the individual schema backend should
235                     # implement prepare_default
236                     sql += column_default % self.prepare_default(default_value)
237                 else:
238                     sql += column_default
239                     params += [default_value]
240         # Oracle treats the empty string ('') as null, so coerce the null
241         # option whenever '' is a possible value.
242         if (field.empty_strings_allowed and not field.primary_key and
243                 self.connection.features.interprets_empty_strings_as_nulls):
244             null = True
245         if null and not self.connection.features.implied_column_null:
246             sql += " NULL"
247         elif not null:
248             sql += " NOT NULL"
249         # Primary key/unique outputs
250         if field.primary_key:
251             sql += " PRIMARY KEY"
252         elif field.unique:
253             sql += " UNIQUE"
254         # Optionally add the tablespace if it's an implicitly indexed column
255         tablespace = field.db_tablespace or model._meta.db_tablespace
256         if tablespace and self.connection.features.supports_tablespaces and field.unique:
257             sql += " %s" % self.connection.ops.tablespace_sql(tablespace, inline=True)
258         # Return the sql
259         return sql, params
260 
261     def skip_default(self, field):
262         """
263         Some backends don't accept default values for certain columns types
264         (i.e. MySQL longtext and longblob).
265         """
266         return False
267 
268     def prepare_default(self, value):
269         """
270         Only used for backends which have requires_literal_defaults feature
271         """
272         raise NotImplementedError(
273             'subclasses of BaseDatabaseSchemaEditor for backends which have '
274             'requires_literal_defaults must provide a prepare_default() method'
275         )
276 
277     def _column_default_sql(self, field):
278         """
279         Return the SQL to use in a DEFAULT clause. The resulting string should
280         contain a '%s' placeholder for a default value.
281         """
282         return '%s'
283 
284     @staticmethod
285     def _effective_default(field):
286         # This method allows testing its logic without a connection.
287         if field.has_default():
288             default = field.get_default()
289         elif not field.null and field.blank and field.empty_strings_allowed:
290             if field.get_internal_type() == "BinaryField":
291                 default = b''
292             else:
293                 default = ''
294         elif getattr(field, 'auto_now', False) or getattr(field, 'auto_now_add', False):
295             default = datetime.now()
296             internal_type = field.get_internal_type()
297             if internal_type == 'DateField':
298                 default = default.date()
299             elif internal_type == 'TimeField':
300                 default = default.time()
301             elif internal_type == 'DateTimeField':
302                 default = timezone.now()
303         else:
304             default = None
305         return default
306 
307     def effective_default(self, field):
308         """Return a field's effective database default value."""
309         return field.get_db_prep_save(self._effective_default(field), self.connection)
310 
311     def quote_value(self, value):
312         """
313         Return a quoted version of the value so it's safe to use in an SQL
314         string. This is not safe against injection from user code; it is
315         intended only for use in making SQL scripts or preparing default values
316         for particularly tricky backends (defaults are not user-defined, though,
317         so this is safe).
318         """
319         raise NotImplementedError()
320 
321     # Actions
322 
323     def create_model(self, model):
324         """
325         Create a table and any accompanying indexes or unique constraints for
326         the given `model`.
327         """
328         sql, params = self.table_sql(model)
329         # Prevent using [] as params, in the case a literal '%' is used in the definition
330         self.execute(sql, params or None)
331 
332         # Add any field index and index_together's (deferred as SQLite _remake_table needs it)
333         self.deferred_sql.extend(self._model_indexes_sql(model))
334 
335         # Make M2M tables
336         for field in model._meta.local_many_to_many:
337             if field.remote_field.through._meta.auto_created:
338                 self.create_model(field.remote_field.through)
339 
340     def delete_model(self, model):
341         """Delete a model from the database."""
342         # Handle auto-created intermediary models
343         for field in model._meta.local_many_to_many:
344             if field.remote_field.through._meta.auto_created:
345                 self.delete_model(field.remote_field.through)
346 
347         # Delete the table
348         self.execute(self.sql_delete_table % {
349             "table": self.quote_name(model._meta.db_table),
350         })
351         # Remove all deferred statements referencing the deleted table.
352         for sql in list(self.deferred_sql):
353             if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
354                 self.deferred_sql.remove(sql)
355 
356     def add_index(self, model, index):
357         """Add an index on a model."""
358         if (
359             index.contains_expressions and
360             not self.connection.features.supports_expression_indexes
361         ):
362             return None
363         self.execute(index.create_sql(model, self), params=None)
364 
365     def remove_index(self, model, index):
366         """Remove an index from a model."""
367         if (
368             index.contains_expressions and
369             not self.connection.features.supports_expression_indexes
370         ):
371             return None
372         self.execute(index.remove_sql(model, self))
373 
374     def add_constraint(self, model, constraint):
375         """Add a constraint to a model."""
376         sql = constraint.create_sql(model, self)
377         if sql:
378             self.execute(sql)
379 
380     def remove_constraint(self, model, constraint):
381         """Remove a constraint from a model."""
382         sql = constraint.remove_sql(model, self)
383         if sql:
384             self.execute(sql)
385 
386     def alter_unique_together(self, model, old_unique_together, new_unique_together):
387         """
388         Deal with a model changing its unique_together. The input
389         unique_togethers must be doubly-nested, not the single-nested
390         ["foo", "bar"] format.
391         """
392         olds = {tuple(fields) for fields in old_unique_together}
393         news = {tuple(fields) for fields in new_unique_together}
394         # Deleted uniques
395         for fields in olds.difference(news):
396             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)
397         # Created uniques
398         for fields in news.difference(olds):
399             columns = [model._meta.get_field(field).column for field in fields]
400             self.execute(self._create_unique_sql(model, columns))
401 
402     def alter_index_together(self, model, old_index_together, new_index_together):
403         """
404         Deal with a model changing its index_together. The input
405         index_togethers must be doubly-nested, not the single-nested
406         ["foo", "bar"] format.
407         """
408         olds = {tuple(fields) for fields in old_index_together}
409         news = {tuple(fields) for fields in new_index_together}
410         # Deleted indexes
411         for fields in olds.difference(news):
412             self._delete_composed_index(
413                 model,
414                 fields,
415                 {'index': True, 'unique': False},
416                 self.sql_delete_index,
417             )
418         # Created indexes
419         for field_names in news.difference(olds):
420             fields = [model._meta.get_field(field) for field in field_names]
421             self.execute(self._create_index_sql(model, fields=fields, suffix='_idx'))
422 
423     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):
424         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
425         meta_index_names = {constraint.name for constraint in model._meta.indexes}
426         columns = [model._meta.get_field(field).column for field in fields]
427         constraint_names = self._constraint_names(
428             model, columns, exclude=meta_constraint_names | meta_index_names,
429             **constraint_kwargs
430         )
431         if len(constraint_names) != 1:
432             raise ValueError("Found wrong number (%s) of constraints for %s(%s)" % (
433                 len(constraint_names),
434                 model._meta.db_table,
435                 ", ".join(columns),
436             ))
437         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
438 
439     def alter_db_table(self, model, old_db_table, new_db_table):
440         """Rename the table a model points to."""
441         if (old_db_table == new_db_table or
442             (self.connection.features.ignores_table_name_case and
443                 old_db_table.lower() == new_db_table.lower())):
444             return
445         self.execute(self.sql_rename_table % {
446             "old_table": self.quote_name(old_db_table),
447             "new_table": self.quote_name(new_db_table),
448         })
449         # Rename all references to the old table name.
450         for sql in self.deferred_sql:
451             if isinstance(sql, Statement):
452                 sql.rename_table_references(old_db_table, new_db_table)
453 
454     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):
455         """Move a model's table between tablespaces."""
456         self.execute(self.sql_retablespace_table % {
457             "table": self.quote_name(model._meta.db_table),
458             "old_tablespace": self.quote_name(old_db_tablespace),
459             "new_tablespace": self.quote_name(new_db_tablespace),
460         })
461 
462     def add_field(self, model, field):
463         """
464         Create a field on a model. Usually involves adding a column, but may
465         involve adding a table instead (for M2M fields).
466         """
467         # Special-case implicit M2M tables
468         if field.many_to_many and field.remote_field.through._meta.auto_created:
469             return self.create_model(field.remote_field.through)
470         # Get the column's definition
471         definition, params = self.column_sql(model, field, include_default=True)
472         # It might not actually have a column behind it
473         if definition is None:
474             return
475         # Check constraints can go on the column SQL here
476         db_params = field.db_parameters(connection=self.connection)
477         if db_params['check']:
478             definition += " " + self.sql_check_constraint % db_params
479         if field.remote_field and self.connection.features.supports_foreign_keys and field.db_constraint:
480             constraint_suffix = '_fk_%(to_table)s_%(to_column)s'
481             # Add FK constraint inline, if supported.
482             if self.sql_create_column_inline_fk:
483                 to_table = field.remote_field.model._meta.db_table
484                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
485                 namespace, _ = split_identifier(model._meta.db_table)
486                 definition += " " + self.sql_create_column_inline_fk % {
487                     'name': self._fk_constraint_name(model, field, constraint_suffix),
488                     'namespace': '%s.' % self.quote_name(namespace) if namespace else '',
489                     'column': self.quote_name(field.column),
490                     'to_table': self.quote_name(to_table),
491                     'to_column': self.quote_name(to_column),
492                     'deferrable': self.connection.ops.deferrable_sql()
493                 }
494             # Otherwise, add FK constraints later.
495             else:
496                 self.deferred_sql.append(self._create_fk_sql(model, field, constraint_suffix))
497         # Build the SQL and run it
498         sql = self.sql_create_column % {
499             "table": self.quote_name(model._meta.db_table),
500             "column": self.quote_name(field.column),
501             "definition": definition,
502         }
503         self.execute(sql, params)
504         # Drop the default if we need to
505         # (Django usually does not use in-database defaults)
506         if not self.skip_default(field) and self.effective_default(field) is not None:
507             changes_sql, params = self._alter_column_default_sql(model, None, field, drop=True)
508             sql = self.sql_alter_column % {
509                 "table": self.quote_name(model._meta.db_table),
510                 "changes": changes_sql,
511             }
512             self.execute(sql, params)
513         # Add an index, if required
514         self.deferred_sql.extend(self._field_indexes_sql(model, field))
515         # Reset connection if required
516         if self.connection.features.connection_persists_old_columns:
517             self.connection.close()
518 
519     def remove_field(self, model, field):
520         """
521         Remove a field from a model. Usually involves deleting a column,
522         but for M2Ms may involve deleting a table.
523         """
524         # Special-case implicit M2M tables
525         if field.many_to_many and field.remote_field.through._meta.auto_created:
526             return self.delete_model(field.remote_field.through)
527         # It might not actually have a column behind it
528         if field.db_parameters(connection=self.connection)['type'] is None:
529             return
530         # Drop any FK constraints, MySQL requires explicit deletion
531         if field.remote_field:
532             fk_names = self._constraint_names(model, [field.column], foreign_key=True)
533             for fk_name in fk_names:
534                 self.execute(self._delete_fk_sql(model, fk_name))
535         # Delete the column
536         sql = self.sql_delete_column % {
537             "table": self.quote_name(model._meta.db_table),
538             "column": self.quote_name(field.column),
539         }
540         self.execute(sql)
541         # Reset connection if required
542         if self.connection.features.connection_persists_old_columns:
543             self.connection.close()
544         # Remove all deferred statements referencing the deleted column.
545         for sql in list(self.deferred_sql):
546             if isinstance(sql, Statement) and sql.references_column(model._meta.db_table, field.column):
547                 self.deferred_sql.remove(sql)
548 
549     def alter_field(self, model, old_field, new_field, strict=False):
550         """
551         Allow a field's type, uniqueness, nullability, default, column,
552         constraints, etc. to be modified.
553         `old_field` is required to compute the necessary changes.
554         If `strict` is True, raise errors if the old column does not match
555         `old_field` precisely.
556         """
557         if not self._field_should_be_altered(old_field, new_field):
558             return
559         # Ensure this field is even column-based
560         old_db_params = old_field.db_parameters(connection=self.connection)
561         old_type = old_db_params['type']
562         new_db_params = new_field.db_parameters(connection=self.connection)
563         new_type = new_db_params['type']
564         if ((old_type is None and old_field.remote_field is None) or
565                 (new_type is None and new_field.remote_field is None)):
566             raise ValueError(
567                 "Cannot alter field %s into %s - they do not properly define "
568                 "db_type (are you using a badly-written custom field?)" %
569                 (old_field, new_field),
570             )
571         elif old_type is None and new_type is None and (
572                 old_field.remote_field.through and new_field.remote_field.through and
573                 old_field.remote_field.through._meta.auto_created and
574                 new_field.remote_field.through._meta.auto_created):
575             return self._alter_many_to_many(model, old_field, new_field, strict)
576         elif old_type is None and new_type is None and (
577                 old_field.remote_field.through and new_field.remote_field.through and
578                 not old_field.remote_field.through._meta.auto_created and
579                 not new_field.remote_field.through._meta.auto_created):
580             # Both sides have through models; this is a no-op.
581             return
582         elif old_type is None or new_type is None:
583             raise ValueError(
584                 "Cannot alter field %s into %s - they are not compatible types "
585                 "(you cannot alter to or from M2M fields, or add or remove "
586                 "through= on M2M fields)" % (old_field, new_field)
587             )
588 
589         self._alter_field(model, old_field, new_field, old_type, new_type,
590                           old_db_params, new_db_params, strict)
591 
592     def _alter_field(self, model, old_field, new_field, old_type, new_type,
593                      old_db_params, new_db_params, strict=False):
594         """Perform a "physical" (non-ManyToMany) field update."""
595         # Drop any FK constraints, we'll remake them later
596         fks_dropped = set()
597         if (
598             self.connection.features.supports_foreign_keys and
599             old_field.remote_field and
600             old_field.db_constraint
601         ):
602             fk_names = self._constraint_names(model, [old_field.column], foreign_key=True)
603             if strict and len(fk_names) != 1:
604                 raise ValueError("Found wrong number (%s) of foreign key constraints for %s.%s" % (
605                     len(fk_names),
606                     model._meta.db_table,
607                     old_field.column,
608                 ))
609             for fk_name in fk_names:
610                 fks_dropped.add((old_field.column,))
611                 self.execute(self._delete_fk_sql(model, fk_name))
612         # Has unique been removed?
613         if old_field.unique and (not new_field.unique or self._field_became_primary_key(old_field, new_field)):
614             # Find the unique constraint for this field
615             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
616             constraint_names = self._constraint_names(
617                 model, [old_field.column], unique=True, primary_key=False,
618                 exclude=meta_constraint_names,
619             )
620             if strict and len(constraint_names) != 1:
621                 raise ValueError("Found wrong number (%s) of unique constraints for %s.%s" % (
622                     len(constraint_names),
623                     model._meta.db_table,
624                     old_field.column,
625                 ))
626             for constraint_name in constraint_names:
627                 self.execute(self._delete_unique_sql(model, constraint_name))
628         # Drop incoming FK constraints if the field is a primary key or unique,
629         # which might be a to_field target, and things are going to change.
630         drop_foreign_keys = (
631             self.connection.features.supports_foreign_keys and (
632                 (old_field.primary_key and new_field.primary_key) or
633                 (old_field.unique and new_field.unique)
634             ) and old_type != new_type
635         )
636         if drop_foreign_keys:
637             # '_meta.related_field' also contains M2M reverse fields, these
638             # will be filtered out
639             for _old_rel, new_rel in _related_non_m2m_objects(old_field, new_field):
640                 rel_fk_names = self._constraint_names(
641                     new_rel.related_model, [new_rel.field.column], foreign_key=True
642                 )
643                 for fk_name in rel_fk_names:
644                     self.execute(self._delete_fk_sql(new_rel.related_model, fk_name))
645         # Removed an index? (no strict check, as multiple indexes are possible)
646         # Remove indexes if db_index switched to False or a unique constraint
647         # will now be used in lieu of an index. The following lines from the
648         # truth table show all True cases; the rest are False:
649         #
650         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
651         # ------------------------------------------------------------------------------
652         # True               | False            | False              | False
653         # True               | False            | False              | True
654         # True               | False            | True               | True
655         if old_field.db_index and not old_field.unique and (not new_field.db_index or new_field.unique):
656             # Find the index for this field
657             meta_index_names = {index.name for index in model._meta.indexes}
658             # Retrieve only BTREE indexes since this is what's created with
659             # db_index=True.
660             index_names = self._constraint_names(
661                 model, [old_field.column], index=True, type_=Index.suffix,
662                 exclude=meta_index_names,
663             )
664             for index_name in index_names:
665                 # The only way to check if an index was created with
666                 # db_index=True or with Index(['field'], name='foo')
667                 # is to look at its name (refs #28053).
668                 self.execute(self._delete_index_sql(model, index_name))
669         # Change check constraints?
670         if old_db_params['check'] != new_db_params['check'] and old_db_params['check']:
671             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
672             constraint_names = self._constraint_names(
673                 model, [old_field.column], check=True,
674                 exclude=meta_constraint_names,
675             )
676             if strict and len(constraint_names) != 1:
677                 raise ValueError("Found wrong number (%s) of check constraints for %s.%s" % (
678                     len(constraint_names),
679                     model._meta.db_table,
680                     old_field.column,
681                 ))
682             for constraint_name in constraint_names:
683                 self.execute(self._delete_check_sql(model, constraint_name))
684         # Have they renamed the column?
685         if old_field.column != new_field.column:
686             self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
687             # Rename all references to the renamed column.
688             for sql in self.deferred_sql:
689                 if isinstance(sql, Statement):
690                     sql.rename_column_references(model._meta.db_table, old_field.column, new_field.column)
691         # Next, start accumulating actions to do
692         actions = []
693         null_actions = []
694         post_actions = []
695         # Collation change?
696         old_collation = getattr(old_field, 'db_collation', None)
697         new_collation = getattr(new_field, 'db_collation', None)
698         if old_collation != new_collation:
699             # Collation change handles also a type change.
700             fragment = self._alter_column_collation_sql(model, new_field, new_type, new_collation)
701             actions.append(fragment)
702         # Type change?
703         elif old_type != new_type:
704             fragment, other_actions = self._alter_column_type_sql(model, old_field, new_field, new_type)
705             actions.append(fragment)
706             post_actions.extend(other_actions)
707         # When changing a column NULL constraint to NOT NULL with a given
708         # default value, we need to perform 4 steps:
709         #  1. Add a default for new incoming writes
710         #  2. Update existing NULL rows with new default
711         #  3. Replace NULL constraint with NOT NULL
712         #  4. Drop the default again.
713         # Default change?
714         needs_database_default = False
715         if old_field.null and not new_field.null:
716             old_default = self.effective_default(old_field)
717             new_default = self.effective_default(new_field)
718             if (
719                 not self.skip_default(new_field) and
720                 old_default != new_default and
721                 new_default is not None
722             ):
723                 needs_database_default = True
724                 actions.append(self._alter_column_default_sql(model, old_field, new_field))
725         # Nullability change?
726         if old_field.null != new_field.null:
727             fragment = self._alter_column_null_sql(model, old_field, new_field)
728             if fragment:
729                 null_actions.append(fragment)
730         # Only if we have a default and there is a change from NULL to NOT NULL
731         four_way_default_alteration = (
732             new_field.has_default() and
733             (old_field.null and not new_field.null)
734         )
735         if actions or null_actions:
736             if not four_way_default_alteration:
737                 # If we don't have to do a 4-way default alteration we can
738                 # directly run a (NOT) NULL alteration
739                 actions = actions + null_actions
740             # Combine actions together if we can (e.g. postgres)
741             if self.connection.features.supports_combined_alters and actions:
742                 sql, params = tuple(zip(*actions))
743                 actions = [(", ".join(sql), sum(params, []))]
744             # Apply those actions
745             for sql, params in actions:
746                 self.execute(
747                     self.sql_alter_column % {
748                         "table": self.quote_name(model._meta.db_table),
749                         "changes": sql,
750                     },
751                     params,
752                 )
753             if four_way_default_alteration:
754                 # Update existing rows with default value
755                 self.execute(
756                     self.sql_update_with_default % {
757                         "table": self.quote_name(model._meta.db_table),
758                         "column": self.quote_name(new_field.column),
759                         "default": "%s",
760                     },
761                     [new_default],
762                 )
763                 # Since we didn't run a NOT NULL change before we need to do it
764                 # now
765                 for sql, params in null_actions:
766                     self.execute(
767                         self.sql_alter_column % {
768                             "table": self.quote_name(model._meta.db_table),
769                             "changes": sql,
770                         },
771                         params,
772                     )
773         if post_actions:
774             for sql, params in post_actions:
775                 self.execute(sql, params)
776         # If primary_key changed to False, delete the primary key constraint.
777         if old_field.primary_key and not new_field.primary_key:
778             self._delete_primary_key(model, strict)
779         # Added a unique?
780         if self._unique_should_be_added(old_field, new_field):
781             self.execute(self._create_unique_sql(model, [new_field.column]))
782         # Added an index? Add an index if db_index switched to True or a unique
783         # constraint will no longer be used in lieu of an index. The following
784         # lines from the truth table show all True cases; the rest are False:
785         #
786         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
787         # ------------------------------------------------------------------------------
788         # False              | False            | True               | False
789         # False              | True             | True               | False
790         # True               | True             | True               | False
791         if (not old_field.db_index or old_field.unique) and new_field.db_index and not new_field.unique:
792             self.execute(self._create_index_sql(model, fields=[new_field]))
793         # Type alteration on primary key? Then we need to alter the column
794         # referring to us.
795         rels_to_update = []
796         if drop_foreign_keys:
797             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
798         # Changed to become primary key?
799         if self._field_became_primary_key(old_field, new_field):
800             # Make the new one
801             self.execute(self._create_primary_key_sql(model, new_field))
802             # Update all referencing columns
803             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
804         # Handle our type alters on the other end of rels from the PK stuff above
805         for old_rel, new_rel in rels_to_update:
806             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
807             rel_type = rel_db_params['type']
808             fragment, other_actions = self._alter_column_type_sql(
809                 new_rel.related_model, old_rel.field, new_rel.field, rel_type
810             )
811             self.execute(
812                 self.sql_alter_column % {
813                     "table": self.quote_name(new_rel.related_model._meta.db_table),
814                     "changes": fragment[0],
815                 },
816                 fragment[1],
817             )
818             for sql, params in other_actions:
819                 self.execute(sql, params)
820         # Does it have a foreign key?
821         if (self.connection.features.supports_foreign_keys and new_field.remote_field and
822                 (fks_dropped or not old_field.remote_field or not old_field.db_constraint) and
823                 new_field.db_constraint):
824             self.execute(self._create_fk_sql(model, new_field, "_fk_%(to_table)s_%(to_column)s"))
825         # Rebuild FKs that pointed to us if we previously had to drop them
826         if drop_foreign_keys:
827             for rel in new_field.model._meta.related_objects:
828                 if _is_relevant_relation(rel, new_field) and rel.field.db_constraint:
829                     self.execute(self._create_fk_sql(rel.related_model, rel.field, "_fk"))
830         # Does it have check constraints we need to add?
831         if old_db_params['check'] != new_db_params['check'] and new_db_params['check']:
832             constraint_name = self._create_index_name(model._meta.db_table, [new_field.column], suffix='_check')
833             self.execute(self._create_check_sql(model, constraint_name, new_db_params['check']))
834         # Drop the default if we need to
835         # (Django usually does not use in-database defaults)
836         if needs_database_default:
837             changes_sql, params = self._alter_column_default_sql(model, old_field, new_field, drop=True)
838             sql = self.sql_alter_column % {
839                 "table": self.quote_name(model._meta.db_table),
840                 "changes": changes_sql,
841             }
842             self.execute(sql, params)
843         # Reset connection if required
844         if self.connection.features.connection_persists_old_columns:
845             self.connection.close()
846 
847     def _alter_column_null_sql(self, model, old_field, new_field):
848         """
849         Hook to specialize column null alteration.
850 
851         Return a (sql, params) fragment to set a column to null or non-null
852         as required by new_field, or None if no changes are required.
853         """
854         if (self.connection.features.interprets_empty_strings_as_nulls and
855                 new_field.get_internal_type() in ("CharField", "TextField")):
856             # The field is nullable in the database anyway, leave it alone.
857             return
858         else:
859             new_db_params = new_field.db_parameters(connection=self.connection)
860             sql = self.sql_alter_column_null if new_field.null else self.sql_alter_column_not_null
861             return (
862                 sql % {
863                     'column': self.quote_name(new_field.column),
864                     'type': new_db_params['type'],
865                 },
866                 [],
867             )
868 
869     def _alter_column_default_sql(self, model, old_field, new_field, drop=False):
870         """
871         Hook to specialize column default alteration.
872 
873         Return a (sql, params) fragment to add or drop (depending on the drop
874         argument) a default to new_field's column.
875         """
876         new_default = self.effective_default(new_field)
877         default = self._column_default_sql(new_field)
878         params = [new_default]
879 
880         if drop:
881             params = []
882         elif self.connection.features.requires_literal_defaults:
883             # Some databases (Oracle) can't take defaults as a parameter
884             # If this is the case, the SchemaEditor for that database should
885             # implement prepare_default().
886             default = self.prepare_default(new_default)
887             params = []
888 
889         new_db_params = new_field.db_parameters(connection=self.connection)
890         sql = self.sql_alter_column_no_default if drop else self.sql_alter_column_default
891         return (
892             sql % {
893                 'column': self.quote_name(new_field.column),
894                 'type': new_db_params['type'],
895                 'default': default,
896             },
897             params,
898         )
899 
900     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
901         """
902         Hook to specialize column type alteration for different backends,
903         for cases when a creation type is different to an alteration type
904         (e.g. SERIAL in PostgreSQL, PostGIS fields).
905 
906         Return a two-tuple of: an SQL fragment of (sql, params) to insert into
907         an ALTER TABLE statement and a list of extra (sql, params) tuples to
908         run once the field is altered.
909         """
910         return (
911             (
912                 self.sql_alter_column_type % {
913                     "column": self.quote_name(new_field.column),
914                     "type": new_type,
915                 },
916                 [],
917             ),
918             [],
919         )
920 
921     def _alter_column_collation_sql(self, model, new_field, new_type, new_collation):
922         return (
923             self.sql_alter_column_collate % {
924                 'column': self.quote_name(new_field.column),
925                 'type': new_type,
926                 'collation': self._collate_sql(new_collation) if new_collation else '',
927             },
928             [],
929         )
930 
931     def _alter_many_to_many(self, model, old_field, new_field, strict):
932         """Alter M2Ms to repoint their to= endpoints."""
933         # Rename the through table
934         if old_field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:
935             self.alter_db_table(old_field.remote_field.through, old_field.remote_field.through._meta.db_table,
936                                 new_field.remote_field.through._meta.db_table)
937         # Repoint the FK to the other side
938         self.alter_field(
939             new_field.remote_field.through,
940             # We need the field that points to the target model, so we can tell alter_field to change it -
941             # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
942             old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
943             new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
944         )
945         self.alter_field(
946             new_field.remote_field.through,
947             # for self-referential models we need to alter field from the other end too
948             old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),
949             new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),
950         )
951 
952     def _create_index_name(self, table_name, column_names, suffix=""):
953         """
954         Generate a unique name for an index/unique constraint.
955 
956         The name is divided into 3 parts: the table name, the column names,
957         and a unique digest and suffix.
958         """
959         _, table_name = split_identifier(table_name)
960         hash_suffix_part = '%s%s' % (names_digest(table_name, *column_names, length=8), suffix)
961         max_length = self.connection.ops.max_name_length() or 200
962         # If everything fits into max_length, use that name.
963         index_name = '%s_%s_%s' % (table_name, '_'.join(column_names), hash_suffix_part)
964         if len(index_name) <= max_length:
965             return index_name
966         # Shorten a long suffix.
967         if len(hash_suffix_part) > max_length / 3:
968             hash_suffix_part = hash_suffix_part[:max_length // 3]
969         other_length = (max_length - len(hash_suffix_part)) // 2 - 1
970         index_name = '%s_%s_%s' % (
971             table_name[:other_length],
972             '_'.join(column_names)[:other_length],
973             hash_suffix_part,
974         )
975         # Prepend D if needed to prevent the name from starting with an
976         # underscore or a number (not permitted on Oracle).
977         if index_name[0] == "_" or index_name[0].isdigit():
978             index_name = "D%s" % index_name[:-1]
979         return index_name
980 
981     def _get_index_tablespace_sql(self, model, fields, db_tablespace=None):
982         if db_tablespace is None:
983             if len(fields) == 1 and fields[0].db_tablespace:
984                 db_tablespace = fields[0].db_tablespace
985             elif model._meta.db_tablespace:
986                 db_tablespace = model._meta.db_tablespace
987         if db_tablespace is not None:
988             return ' ' + self.connection.ops.tablespace_sql(db_tablespace)
989         return ''
990 
991     def _index_condition_sql(self, condition):
992         if condition:
993             return ' WHERE ' + condition
994         return ''
995 
996     def _index_include_sql(self, model, columns):
997         if not columns or not self.connection.features.supports_covering_indexes:
998             return ''
999         return Statement(
1000             ' INCLUDE (%(columns)s)',
1001             columns=Columns(model._meta.db_table, columns, self.quote_name),
1002         )
1003 
1004     def _create_index_sql(self, model, *, fields=None, name=None, suffix='', using='',
1005                           db_tablespace=None, col_suffixes=(), sql=None, opclasses=(),
1006                           condition=None, include=None, expressions=None):
1007         """
1008         Return the SQL statement to create the index for one or several fields
1009         or expressions. `sql` can be specified if the syntax differs from the
1010         standard (GIS indexes, ...).
1011         """
1012         fields = fields or []
1013         expressions = expressions or []
1014         compiler = Query(model, alias_cols=False).get_compiler(
1015             connection=self.connection,
1016         )
1017         tablespace_sql = self._get_index_tablespace_sql(model, fields, db_tablespace=db_tablespace)
1018         columns = [field.column for field in fields]
1019         sql_create_index = sql or self.sql_create_index
1020         table = model._meta.db_table
1021 
1022         def create_index_name(*args, **kwargs):
1023             nonlocal name
1024             if name is None:
1025                 name = self._create_index_name(*args, **kwargs)
1026             return self.quote_name(name)
1027 
1028         return Statement(
1029             sql_create_index,
1030             table=Table(table, self.quote_name),
1031             name=IndexName(table, columns, suffix, create_index_name),
1032             using=using,
1033             columns=(
1034                 self._index_columns(table, columns, col_suffixes, opclasses)
1035                 if columns
1036                 else Expressions(table, expressions, compiler, self.quote_value)
1037             ),
1038             extra=tablespace_sql,
1039             condition=self._index_condition_sql(condition),
1040             include=self._index_include_sql(model, include),
1041         )
1042 
1043     def _delete_index_sql(self, model, name, sql=None):
1044         return Statement(
1045             sql or self.sql_delete_index,
1046             table=Table(model._meta.db_table, self.quote_name),
1047             name=self.quote_name(name),
1048         )
1049 
1050     def _index_columns(self, table, columns, col_suffixes, opclasses):
1051         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
1052 
1053     def _model_indexes_sql(self, model):
1054         """
1055         Return a list of all index SQL statements (field indexes,
1056         index_together, Meta.indexes) for the specified model.
1057         """
1058         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1059             return []
1060         output = []
1061         for field in model._meta.local_fields:
1062             output.extend(self._field_indexes_sql(model, field))
1063 
1064         for field_names in model._meta.index_together:
1065             fields = [model._meta.get_field(field) for field in field_names]
1066             output.append(self._create_index_sql(model, fields=fields, suffix='_idx'))
1067 
1068         for index in model._meta.indexes:
1069             if (
1070                 not index.contains_expressions or
1071                 self.connection.features.supports_expression_indexes
1072             ):
1073                 output.append(index.create_sql(model, self))
1074         return output
1075 
1076     def _field_indexes_sql(self, model, field):
1077         """
1078         Return a list of all index SQL statements for the specified field.
1079         """
1080         output = []
1081         if self._field_should_be_indexed(model, field):
1082             output.append(self._create_index_sql(model, fields=[field]))
1083         return output
1084 
1085     def _field_should_be_altered(self, old_field, new_field):
1086         _, old_path, old_args, old_kwargs = old_field.deconstruct()
1087         _, new_path, new_args, new_kwargs = new_field.deconstruct()
1088         # Don't alter when:
1089         # - changing only a field name
1090         # - changing an attribute that doesn't affect the schema
1091         # - adding only a db_column and the column name is not changed
1092         non_database_attrs = [
1093             'blank',
1094             'db_column',
1095             'editable',
1096             'error_messages',
1097             'help_text',
1098             'limit_choices_to',
1099             # Database-level options are not supported, see #21961.
1100             'on_delete',
1101             'related_name',
1102             'related_query_name',
1103             'validators',
1104             'verbose_name',
1105         ]
1106         for attr in non_database_attrs:
1107             old_kwargs.pop(attr, None)
1108             new_kwargs.pop(attr, None)
1109         return (
1110             self.quote_name(old_field.column) != self.quote_name(new_field.column) or
1111             (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
1112         )
1113 
1114     def _field_should_be_indexed(self, model, field):
1115         return field.db_index and not field.unique
1116 
1117     def _field_became_primary_key(self, old_field, new_field):
1118         return not old_field.primary_key and new_field.primary_key
1119 
1120     def _unique_should_be_added(self, old_field, new_field):
1121         return (not old_field.unique and new_field.unique) or (
1122             old_field.primary_key and not new_field.primary_key and new_field.unique
1123         )
1124 
1125     def _rename_field_sql(self, table, old_field, new_field, new_type):
1126         return self.sql_rename_column % {
1127             "table": self.quote_name(table),
1128             "old_column": self.quote_name(old_field.column),
1129             "new_column": self.quote_name(new_field.column),
1130             "type": new_type,
1131         }
1132 
1133     def _create_fk_sql(self, model, field, suffix):
1134         table = Table(model._meta.db_table, self.quote_name)
1135         name = self._fk_constraint_name(model, field, suffix)
1136         column = Columns(model._meta.db_table, [field.column], self.quote_name)
1137         to_table = Table(field.target_field.model._meta.db_table, self.quote_name)
1138         to_column = Columns(field.target_field.model._meta.db_table, [field.target_field.column], self.quote_name)
1139         deferrable = self.connection.ops.deferrable_sql()
1140         return Statement(
1141             self.sql_create_fk,
1142             table=table,
1143             name=name,
1144             column=column,
1145             to_table=to_table,
1146             to_column=to_column,
1147             deferrable=deferrable,
1148         )
1149 
1150     def _fk_constraint_name(self, model, field, suffix):
1151         def create_fk_name(*args, **kwargs):
1152             return self.quote_name(self._create_index_name(*args, **kwargs))
1153 
1154         return ForeignKeyName(
1155             model._meta.db_table,
1156             [field.column],
1157             split_identifier(field.target_field.model._meta.db_table)[1],
1158             [field.target_field.column],
1159             suffix,
1160             create_fk_name,
1161         )
1162 
1163     def _delete_fk_sql(self, model, name):
1164         return self._delete_constraint_sql(self.sql_delete_fk, model, name)
1165 
1166     def _deferrable_constraint_sql(self, deferrable):
1167         if deferrable is None:
1168             return ''
1169         if deferrable == Deferrable.DEFERRED:
1170             return ' DEFERRABLE INITIALLY DEFERRED'
1171         if deferrable == Deferrable.IMMEDIATE:
1172             return ' DEFERRABLE INITIALLY IMMEDIATE'
1173 
1174     def _unique_sql(
1175         self, model, fields, name, condition=None, deferrable=None,
1176         include=None, opclasses=None,
1177     ):
1178         if (
1179             deferrable and
1180             not self.connection.features.supports_deferrable_unique_constraints
1181         ):
1182             return None
1183         if condition or include or opclasses:
1184             # Databases support conditional and covering unique constraints via
1185             # a unique index.
1186             sql = self._create_unique_sql(
1187                 model,
1188                 fields,
1189                 name=name,
1190                 condition=condition,
1191                 include=include,
1192                 opclasses=opclasses,
1193             )
1194             if sql:
1195                 self.deferred_sql.append(sql)
1196             return None
1197         constraint = self.sql_unique_constraint % {
1198             'columns': ', '.join(map(self.quote_name, fields)),
1199             'deferrable': self._deferrable_constraint_sql(deferrable),
1200         }
1201         return self.sql_constraint % {
1202             'name': self.quote_name(name),
1203             'constraint': constraint,
1204         }
1205 
1206     def _create_unique_sql(
1207         self, model, columns, name=None, condition=None, deferrable=None,
1208         include=None, opclasses=None,
1209     ):
1210         if (
1211             (
1212                 deferrable and
1213                 not self.connection.features.supports_deferrable_unique_constraints
1214             ) or
1215             (condition and not self.connection.features.supports_partial_indexes) or
1216             (include and not self.connection.features.supports_covering_indexes)
1217         ):
1218             return None
1219 
1220         def create_unique_name(*args, **kwargs):
1221             return self.quote_name(self._create_index_name(*args, **kwargs))
1222 
1223         table = Table(model._meta.db_table, self.quote_name)
1224         if name is None:
1225             name = IndexName(model._meta.db_table, columns, '_uniq', create_unique_name)
1226         else:
1227             name = self.quote_name(name)
1228         columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)
1229         if condition or include or opclasses:
1230             sql = self.sql_create_unique_index
1231         else:
1232             sql = self.sql_create_unique
1233         return Statement(
1234             sql,
1235             table=table,
1236             name=name,
1237             columns=columns,
1238             condition=self._index_condition_sql(condition),
1239             deferrable=self._deferrable_constraint_sql(deferrable),
1240             include=self._index_include_sql(model, include),
1241         )
1242 
1243     def _delete_unique_sql(
1244         self, model, name, condition=None, deferrable=None, include=None,
1245         opclasses=None,
1246     ):
1247         if (
1248             (
1249                 deferrable and
1250                 not self.connection.features.supports_deferrable_unique_constraints
1251             ) or
1252             (condition and not self.connection.features.supports_partial_indexes) or
1253             (include and not self.connection.features.supports_covering_indexes)
1254         ):
1255             return None
1256         if condition or include or opclasses:
1257             sql = self.sql_delete_index
1258         else:
1259             sql = self.sql_delete_unique
1260         return self._delete_constraint_sql(sql, model, name)
1261 
1262     def _check_sql(self, name, check):
1263         return self.sql_constraint % {
1264             'name': self.quote_name(name),
1265             'constraint': self.sql_check_constraint % {'check': check},
1266         }
1267 
1268     def _create_check_sql(self, model, name, check):
1269         return Statement(
1270             self.sql_create_check,
1271             table=Table(model._meta.db_table, self.quote_name),
1272             name=self.quote_name(name),
1273             check=check,
1274         )
1275 
1276     def _delete_check_sql(self, model, name):
1277         return self._delete_constraint_sql(self.sql_delete_check, model, name)
1278 
1279     def _delete_constraint_sql(self, template, model, name):
1280         return Statement(
1281             template,
1282             table=Table(model._meta.db_table, self.quote_name),
1283             name=self.quote_name(name),
1284         )
1285 
1286     def _constraint_names(self, model, column_names=None, unique=None,
1287                           primary_key=None, index=None, foreign_key=None,
1288                           check=None, type_=None, exclude=None):
1289         """Return all constraint names matching the columns and conditions."""
1290         if column_names is not None:
1291             column_names = [
1292                 self.connection.introspection.identifier_converter(name)
1293                 for name in column_names
1294             ]
1295         with self.connection.cursor() as cursor:
1296             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
1297         result = []
1298         for name, infodict in constraints.items():
1299             if column_names is None or column_names == infodict['columns']:
1300                 if unique is not None and infodict['unique'] != unique:
1301                     continue
1302                 if primary_key is not None and infodict['primary_key'] != primary_key:
1303                     continue
1304                 if index is not None and infodict['index'] != index:
1305                     continue
1306                 if check is not None and infodict['check'] != check:
1307                     continue
1308                 if foreign_key is not None and not infodict['foreign_key']:
1309                     continue
1310                 if type_ is not None and infodict['type'] != type_:
1311                     continue
1312                 if not exclude or name not in exclude:
1313                     result.append(name)
1314         return result
1315 
1316     def _delete_primary_key(self, model, strict=False):
1317         constraint_names = self._constraint_names(model, primary_key=True)
1318         if strict and len(constraint_names) != 1:
1319             raise ValueError('Found wrong number (%s) of PK constraints for %s' % (
1320                 len(constraint_names),
1321                 model._meta.db_table,
1322             ))
1323         for constraint_name in constraint_names:
1324             self.execute(self._delete_primary_key_sql(model, constraint_name))
1325 
1326     def _create_primary_key_sql(self, model, field):
1327         return Statement(
1328             self.sql_create_pk,
1329             table=Table(model._meta.db_table, self.quote_name),
1330             name=self.quote_name(
1331                 self._create_index_name(model._meta.db_table, [field.column], suffix="_pk")
1332             ),
1333             columns=Columns(model._meta.db_table, [field.column], self.quote_name),
1334         )
1335 
1336     def _delete_primary_key_sql(self, model, name):
1337         return self._delete_constraint_sql(self.sql_delete_pk, model, name)
1338 
1339     def _collate_sql(self, collation):
1340         return ' COLLATE ' + self.quote_name(collation)
1341 
1342     def remove_procedure(self, procedure_name, param_types=()):
1343         sql = self.sql_delete_procedure % {
1344             'procedure': self.quote_name(procedure_name),
1345             'param_types': ','.join(param_types),
1346         }
1347         self.execute(sql)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 05:35:48.183 | INFO     | Search completed. Bug locations: [<file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>_model_indexes_sql</method>
<code>
1053     def _model_indexes_sql(self, model):
1054         """
1055         Return a list of all index SQL statements (field indexes,
1056         index_together, Meta.indexes) for the specified model.
1057         """
1058         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1059             return []
1060         output = []
1061         for field in model._meta.local_fields:
1062             output.extend(self._field_indexes_sql(model, field))
1063 
1064         for field_names in model._meta.index_together:
1065             fields = [model._meta.get_field(field) for field in field_names]
1066             output.append(self._create_index_sql(model, fields=fields, suffix='_idx'))
1067 
1068         for index in model._meta.indexes:
1069             if (
1070                 not index.contains_expressions or
1071                 self.connection.features.supports_expression_indexes
1072             ):
1073                 output.append(index.create_sql(model, self))
1074         return output

</code><intended_behavior>This method is responsible for generating SQL for all indexes of a model, including field indexes, index_together, and Meta.indexes. The intended behavior here would be to extend this method or add a preliminary step to it that performs a check on the validity of model field names within functional indexes defined in Meta.indexes. This check should ensure that any expressions used within functional indexes refer to valid fields on the model. If invalid fields are detected, the system should raise an appropriate warning or error before proceeding with SQL generation. This validation step should be designed to only affect models with functional indexes, preserving the existing functionality for all other models and index types.</intended_behavior>, <file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>None</method>
<code>
45 class BaseDatabaseSchemaEditor:
46     """
47     This class and its subclasses are responsible for emitting schema-changing
48     statements to the databases - model creation/removal/alteration, field
49     renaming, index fiddling, and so on.
50     """
51 
52     # Overrideable SQL templates
53     sql_create_table = "CREATE TABLE %(table)s (%(definition)s)"
54     sql_rename_table = "ALTER TABLE %(old_table)s RENAME TO %(new_table)s"
55     sql_retablespace_table = "ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s"
56     sql_delete_table = "DROP TABLE %(table)s CASCADE"
57 
58     sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
59     sql_alter_column = "ALTER TABLE %(table)s %(changes)s"
60     sql_alter_column_type = "ALTER COLUMN %(column)s TYPE %(type)s"
61     sql_alter_column_null = "ALTER COLUMN %(column)s DROP NOT NULL"
62     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
63     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
64     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
65     sql_alter_column_collate = "ALTER COLUMN %(column)s TYPE %(type)s%(collation)s"
66     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
67     sql_rename_column = "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
68     sql_update_with_default = "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
69 
70     sql_unique_constraint = "UNIQUE (%(columns)s)%(deferrable)s"
71     sql_check_constraint = "CHECK (%(check)s)"
72     sql_delete_constraint = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
73     sql_constraint = "CONSTRAINT %(name)s %(constraint)s"
74 
75     sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
76     sql_delete_check = sql_delete_constraint
77 
78     sql_create_unique = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)%(deferrable)s"
79     sql_delete_unique = sql_delete_constraint
80 
81     sql_create_fk = (
82         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
83         "REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s"
84     )
85     sql_create_inline_fk = None
86     sql_create_column_inline_fk = None
87     sql_delete_fk = sql_delete_constraint
88 
89     sql_create_index = "CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(extra)s%(condition)s"
90     sql_create_unique_index = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(condition)s"
91     sql_delete_index = "DROP INDEX %(name)s"
92 
93     sql_create_pk = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
94     sql_delete_pk = sql_delete_constraint
95 
96     sql_delete_procedure = 'DROP PROCEDURE %(procedure)s'
97 
98     def __init__(self, connection, collect_sql=False, atomic=True):
99         self.connection = connection
100         self.collect_sql = collect_sql
101         if self.collect_sql:
102             self.collected_sql = []
103         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
104 
105     # State-managing methods
106 
107     def __enter__(self):
108         self.deferred_sql = []
109         if self.atomic_migration:
110             self.atomic = atomic(self.connection.alias)
111             self.atomic.__enter__()
112         return self
113 
114     def __exit__(self, exc_type, exc_value, traceback):
115         if exc_type is None:
116             for sql in self.deferred_sql:
117                 self.execute(sql)
118         if self.atomic_migration:
119             self.atomic.__exit__(exc_type, exc_value, traceback)
120 
121     # Core utility functions
122 
123     def execute(self, sql, params=()):
124         """Execute the given SQL statement, with optional parameters."""
125         # Don't perform the transactional DDL check if SQL is being collected
126         # as it's not going to be executed anyway.
127         if not self.collect_sql and self.connection.in_atomic_block and not self.connection.features.can_rollback_ddl:
128             raise TransactionManagementError(
129                 "Executing DDL statements while in a transaction on databases "
130                 "that can't perform a rollback is prohibited."
131             )
132         # Account for non-string statement objects.
133         sql = str(sql)
134         # Log the command we're running, then run it
135         logger.debug("%s; (params %r)", sql, params, extra={'params': params, 'sql': sql})
136         if self.collect_sql:
137             ending = "" if sql.endswith(";") else ";"
138             if params is not None:
139                 self.collected_sql.append((sql % tuple(map(self.quote_value, params))) + ending)
140             else:
141                 self.collected_sql.append(sql + ending)
142         else:
143             with self.connection.cursor() as cursor:
144                 cursor.execute(sql, params)
145 
146     def quote_name(self, name):
147         return self.connection.ops.quote_name(name)
148 
149     def table_sql(self, model):
150         """Take a model and return its table definition."""
151         # Add any unique_togethers (always deferred, as some fields might be
152         # created afterwards, like geometry fields with some backends).
153         for fields in model._meta.unique_together:
154             columns = [model._meta.get_field(field).column for field in fields]
155             self.deferred_sql.append(self._create_unique_sql(model, columns))
156         # Create column SQL, add FK deferreds if needed.
157         column_sqls = []
158         params = []
159         for field in model._meta.local_fields:
160             # SQL.
161             definition, extra_params = self.column_sql(model, field)
162             if definition is None:
163                 continue
164             # Check constraints can go on the column SQL here.
165             db_params = field.db_parameters(connection=self.connection)
166             if db_params['check']:
167                 definition += ' ' + self.sql_check_constraint % db_params
168             # Autoincrement SQL (for backends with inline variant).
169             col_type_suffix = field.db_type_suffix(connection=self.connection)
170             if col_type_suffix:
171                 definition += ' %s' % col_type_suffix
172             params.extend(extra_params)
173             # FK.
174             if field.remote_field and field.db_constraint:
175                 to_table = field.remote_field.model._meta.db_table
176                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
177                 if self.sql_create_inline_fk:
178                     definition += ' ' + self.sql_create_inline_fk % {
179                         'to_table': self.quote_name(to_table),
180                         'to_column': self.quote_name(to_column),
181                     }
182                 elif self.connection.features.supports_foreign_keys:
183                     self.deferred_sql.append(self._create_fk_sql(model, field, '_fk_%(to_table)s_%(to_column)s'))
184             # Add the SQL to our big list.
185             column_sqls.append('%s %s' % (
186                 self.quote_name(field.column),
187                 definition,
188             ))
189             # Autoincrement SQL (for backends with post table definition
190             # variant).
191             if field.get_internal_type() in ('AutoField', 'BigAutoField', 'SmallAutoField'):
192                 autoinc_sql = self.connection.ops.autoinc_sql(model._meta.db_table, field.column)
193                 if autoinc_sql:
194                     self.deferred_sql.extend(autoinc_sql)
195         constraints = [constraint.constraint_sql(model, self) for constraint in model._meta.constraints]
196         sql = self.sql_create_table % {
197             'table': self.quote_name(model._meta.db_table),
198             'definition': ', '.join(constraint for constraint in (*column_sqls, *constraints) if constraint),
199         }
200         if model._meta.db_tablespace:
201             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)
202             if tablespace_sql:
203                 sql += ' ' + tablespace_sql
204         return sql, params
205 
206     # Field <-> database mapping functions
207 
208     def column_sql(self, model, field, include_default=False):
209         """
210         Take a field and return its column definition.
211         The field must already have had set_attributes_from_name() called.
212         """
213         # Get the column's type and use that as the basis of the SQL
214         db_params = field.db_parameters(connection=self.connection)
215         sql = db_params['type']
216         params = []
217         # Check for fields that aren't actually columns (e.g. M2M)
218         if sql is None:
219             return None, None
220         # Collation.
221         collation = getattr(field, 'db_collation', None)
222         if collation:
223             sql += self._collate_sql(collation)
224         # Work out nullability
225         null = field.null
226         # If we were told to include a default value, do so
227         include_default = include_default and not self.skip_default(field)
228         if include_default:
229             default_value = self.effective_default(field)
230             column_default = ' DEFAULT ' + self._column_default_sql(field)
231             if default_value is not None:
232                 if self.connection.features.requires_literal_defaults:
233                     # Some databases can't take defaults as a parameter (oracle)
234                     # If this is the case, the individual schema backend should
235                     # implement prepare_default
236                     sql += column_default % self.prepare_default(default_value)
237                 else:
238                     sql += column_default
239                     params += [default_value]
240         # Oracle treats the empty string ('') as null, so coerce the null
241         # option whenever '' is a possible value.
242         if (field.empty_strings_allowed and not field.primary_key and
243                 self.connection.features.interprets_empty_strings_as_nulls):
244             null = True
245         if null and not self.connection.features.implied_column_null:
246             sql += " NULL"
247         elif not null:
248             sql += " NOT NULL"
249         # Primary key/unique outputs
250         if field.primary_key:
251             sql += " PRIMARY KEY"
252         elif field.unique:
253             sql += " UNIQUE"
254         # Optionally add the tablespace if it's an implicitly indexed column
255         tablespace = field.db_tablespace or model._meta.db_tablespace
256         if tablespace and self.connection.features.supports_tablespaces and field.unique:
257             sql += " %s" % self.connection.ops.tablespace_sql(tablespace, inline=True)
258         # Return the sql
259         return sql, params
260 
261     def skip_default(self, field):
262         """
263         Some backends don't accept default values for certain columns types
264         (i.e. MySQL longtext and longblob).
265         """
266         return False
267 
268     def prepare_default(self, value):
269         """
270         Only used for backends which have requires_literal_defaults feature
271         """
272         raise NotImplementedError(
273             'subclasses of BaseDatabaseSchemaEditor for backends which have '
274             'requires_literal_defaults must provide a prepare_default() method'
275         )
276 
277     def _column_default_sql(self, field):
278         """
279         Return the SQL to use in a DEFAULT clause. The resulting string should
280         contain a '%s' placeholder for a default value.
281         """
282         return '%s'
283 
284     @staticmethod
285     def _effective_default(field):
286         # This method allows testing its logic without a connection.
287         if field.has_default():
288             default = field.get_default()
289         elif not field.null and field.blank and field.empty_strings_allowed:
290             if field.get_internal_type() == "BinaryField":
291                 default = b''
292             else:
293                 default = ''
294         elif getattr(field, 'auto_now', False) or getattr(field, 'auto_now_add', False):
295             default = datetime.now()
296             internal_type = field.get_internal_type()
297             if internal_type == 'DateField':
298                 default = default.date()
299             elif internal_type == 'TimeField':
300                 default = default.time()
301             elif internal_type == 'DateTimeField':
302                 default = timezone.now()
303         else:
304             default = None
305         return default
306 
307     def effective_default(self, field):
308         """Return a field's effective database default value."""
309         return field.get_db_prep_save(self._effective_default(field), self.connection)
310 
311     def quote_value(self, value):
312         """
313         Return a quoted version of the value so it's safe to use in an SQL
314         string. This is not safe against injection from user code; it is
315         intended only for use in making SQL scripts or preparing default values
316         for particularly tricky backends (defaults are not user-defined, though,
317         so this is safe).
318         """
319         raise NotImplementedError()
320 
321     # Actions
322 
323     def create_model(self, model):
324         """
325         Create a table and any accompanying indexes or unique constraints for
326         the given `model`.
327         """
328         sql, params = self.table_sql(model)
329         # Prevent using [] as params, in the case a literal '%' is used in the definition
330         self.execute(sql, params or None)
331 
332         # Add any field index and index_together's (deferred as SQLite _remake_table needs it)
333         self.deferred_sql.extend(self._model_indexes_sql(model))
334 
335         # Make M2M tables
336         for field in model._meta.local_many_to_many:
337             if field.remote_field.through._meta.auto_created:
338                 self.create_model(field.remote_field.through)
339 
340     def delete_model(self, model):
341         """Delete a model from the database."""
342         # Handle auto-created intermediary models
343         for field in model._meta.local_many_to_many:
344             if field.remote_field.through._meta.auto_created:
345                 self.delete_model(field.remote_field.through)
346 
347         # Delete the table
348         self.execute(self.sql_delete_table % {
349             "table": self.quote_name(model._meta.db_table),
350         })
351         # Remove all deferred statements referencing the deleted table.
352         for sql in list(self.deferred_sql):
353             if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
354                 self.deferred_sql.remove(sql)
355 
356     def add_index(self, model, index):
357         """Add an index on a model."""
358         if (
359             index.contains_expressions and
360             not self.connection.features.supports_expression_indexes
361         ):
362             return None
363         self.execute(index.create_sql(model, self), params=None)
364 
365     def remove_index(self, model, index):
366         """Remove an index from a model."""
367         if (
368             index.contains_expressions and
369             not self.connection.features.supports_expression_indexes
370         ):
371             return None
372         self.execute(index.remove_sql(model, self))
373 
374     def add_constraint(self, model, constraint):
375         """Add a constraint to a model."""
376         sql = constraint.create_sql(model, self)
377         if sql:
378             self.execute(sql)
379 
380     def remove_constraint(self, model, constraint):
381         """Remove a constraint from a model."""
382         sql = constraint.remove_sql(model, self)
383         if sql:
384             self.execute(sql)
385 
386     def alter_unique_together(self, model, old_unique_together, new_unique_together):
387         """
388         Deal with a model changing its unique_together. The input
389         unique_togethers must be doubly-nested, not the single-nested
390         ["foo", "bar"] format.
391         """
392         olds = {tuple(fields) for fields in old_unique_together}
393         news = {tuple(fields) for fields in new_unique_together}
394         # Deleted uniques
395         for fields in olds.difference(news):
396             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)
397         # Created uniques
398         for fields in news.difference(olds):
399             columns = [model._meta.get_field(field).column for field in fields]
400             self.execute(self._create_unique_sql(model, columns))
401 
402     def alter_index_together(self, model, old_index_together, new_index_together):
403         """
404         Deal with a model changing its index_together. The input
405         index_togethers must be doubly-nested, not the single-nested
406         ["foo", "bar"] format.
407         """
408         olds = {tuple(fields) for fields in old_index_together}
409         news = {tuple(fields) for fields in new_index_together}
410         # Deleted indexes
411         for fields in olds.difference(news):
412             self._delete_composed_index(
413                 model,
414                 fields,
415                 {'index': True, 'unique': False},
416                 self.sql_delete_index,
417             )
418         # Created indexes
419         for field_names in news.difference(olds):
420             fields = [model._meta.get_field(field) for field in field_names]
421             self.execute(self._create_index_sql(model, fields=fields, suffix='_idx'))
422 
423     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):
424         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
425         meta_index_names = {constraint.name for constraint in model._meta.indexes}
426         columns = [model._meta.get_field(field).column for field in fields]
427         constraint_names = self._constraint_names(
428             model, columns, exclude=meta_constraint_names | meta_index_names,
429             **constraint_kwargs
430         )
431         if len(constraint_names) != 1:
432             raise ValueError("Found wrong number (%s) of constraints for %s(%s)" % (
433                 len(constraint_names),
434                 model._meta.db_table,
435                 ", ".join(columns),
436             ))
437         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
438 
439     def alter_db_table(self, model, old_db_table, new_db_table):
440         """Rename the table a model points to."""
441         if (old_db_table == new_db_table or
442             (self.connection.features.ignores_table_name_case and
443                 old_db_table.lower() == new_db_table.lower())):
444             return
445         self.execute(self.sql_rename_table % {
446             "old_table": self.quote_name(old_db_table),
447             "new_table": self.quote_name(new_db_table),
448         })
449         # Rename all references to the old table name.
450         for sql in self.deferred_sql:
451             if isinstance(sql, Statement):
452                 sql.rename_table_references(old_db_table, new_db_table)
453 
454     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):
455         """Move a model's table between tablespaces."""
456         self.execute(self.sql_retablespace_table % {
457             "table": self.quote_name(model._meta.db_table),
458             "old_tablespace": self.quote_name(old_db_tablespace),
459             "new_tablespace": self.quote_name(new_db_tablespace),
460         })
461 
462     def add_field(self, model, field):
463         """
464         Create a field on a model. Usually involves adding a column, but may
465         involve adding a table instead (for M2M fields).
466         """
467         # Special-case implicit M2M tables
468         if field.many_to_many and field.remote_field.through._meta.auto_created:
469             return self.create_model(field.remote_field.through)
470         # Get the column's definition
471         definition, params = self.column_sql(model, field, include_default=True)
472         # It might not actually have a column behind it
473         if definition is None:
474             return
475         # Check constraints can go on the column SQL here
476         db_params = field.db_parameters(connection=self.connection)
477         if db_params['check']:
478             definition += " " + self.sql_check_constraint % db_params
479         if field.remote_field and self.connection.features.supports_foreign_keys and field.db_constraint:
480             constraint_suffix = '_fk_%(to_table)s_%(to_column)s'
481             # Add FK constraint inline, if supported.
482             if self.sql_create_column_inline_fk:
483                 to_table = field.remote_field.model._meta.db_table
484                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
485                 namespace, _ = split_identifier(model._meta.db_table)
486                 definition += " " + self.sql_create_column_inline_fk % {
487                     'name': self._fk_constraint_name(model, field, constraint_suffix),
488                     'namespace': '%s.' % self.quote_name(namespace) if namespace else '',
489                     'column': self.quote_name(field.column),
490                     'to_table': self.quote_name(to_table),
491                     'to_column': self.quote_name(to_column),
492                     'deferrable': self.connection.ops.deferrable_sql()
493                 }
494             # Otherwise, add FK constraints later.
495             else:
496                 self.deferred_sql.append(self._create_fk_sql(model, field, constraint_suffix))
497         # Build the SQL and run it
498         sql = self.sql_create_column % {
499             "table": self.quote_name(model._meta.db_table),
500             "column": self.quote_name(field.column),
501             "definition": definition,
502         }
503         self.execute(sql, params)
504         # Drop the default if we need to
505         # (Django usually does not use in-database defaults)
506         if not self.skip_default(field) and self.effective_default(field) is not None:
507             changes_sql, params = self._alter_column_default_sql(model, None, field, drop=True)
508             sql = self.sql_alter_column % {
509                 "table": self.quote_name(model._meta.db_table),
510                 "changes": changes_sql,
511             }
512             self.execute(sql, params)
513         # Add an index, if required
514         self.deferred_sql.extend(self._field_indexes_sql(model, field))
515         # Reset connection if required
516         if self.connection.features.connection_persists_old_columns:
517             self.connection.close()
518 
519     def remove_field(self, model, field):
520         """
521         Remove a field from a model. Usually involves deleting a column,
522         but for M2Ms may involve deleting a table.
523         """
524         # Special-case implicit M2M tables
525         if field.many_to_many and field.remote_field.through._meta.auto_created:
526             return self.delete_model(field.remote_field.through)
527         # It might not actually have a column behind it
528         if field.db_parameters(connection=self.connection)['type'] is None:
529             return
530         # Drop any FK constraints, MySQL requires explicit deletion
531         if field.remote_field:
532             fk_names = self._constraint_names(model, [field.column], foreign_key=True)
533             for fk_name in fk_names:
534                 self.execute(self._delete_fk_sql(model, fk_name))
535         # Delete the column
536         sql = self.sql_delete_column % {
537             "table": self.quote_name(model._meta.db_table),
538             "column": self.quote_name(field.column),
539         }
540         self.execute(sql)
541         # Reset connection if required
542         if self.connection.features.connection_persists_old_columns:
543             self.connection.close()
544         # Remove all deferred statements referencing the deleted column.
545         for sql in list(self.deferred_sql):
546             if isinstance(sql, Statement) and sql.references_column(model._meta.db_table, field.column):
547                 self.deferred_sql.remove(sql)
548 
549     def alter_field(self, model, old_field, new_field, strict=False):
550         """
551         Allow a field's type, uniqueness, nullability, default, column,
552         constraints, etc. to be modified.
553         `old_field` is required to compute the necessary changes.
554         If `strict` is True, raise errors if the old column does not match
555         `old_field` precisely.
556         """
557         if not self._field_should_be_altered(old_field, new_field):
558             return
559         # Ensure this field is even column-based
560         old_db_params = old_field.db_parameters(connection=self.connection)
561         old_type = old_db_params['type']
562         new_db_params = new_field.db_parameters(connection=self.connection)
563         new_type = new_db_params['type']
564         if ((old_type is None and old_field.remote_field is None) or
565                 (new_type is None and new_field.remote_field is None)):
566             raise ValueError(
567                 "Cannot alter field %s into %s - they do not properly define "
568                 "db_type (are you using a badly-written custom field?)" %
569                 (old_field, new_field),
570             )
571         elif old_type is None and new_type is None and (
572                 old_field.remote_field.through and new_field.remote_field.through and
573                 old_field.remote_field.through._meta.auto_created and
574                 new_field.remote_field.through._meta.auto_created):
575             return self._alter_many_to_many(model, old_field, new_field, strict)
576         elif old_type is None and new_type is None and (
577                 old_field.remote_field.through and new_field.remote_field.through and
578                 not old_field.remote_field.through._meta.auto_created and
579                 not new_field.remote_field.through._meta.auto_created):
580             # Both sides have through models; this is a no-op.
581             return
582         elif old_type is None or new_type is None:
583             raise ValueError(
584                 "Cannot alter field %s into %s - they are not compatible types "
585                 "(you cannot alter to or from M2M fields, or add or remove "
586                 "through= on M2M fields)" % (old_field, new_field)
587             )
588 
589         self._alter_field(model, old_field, new_field, old_type, new_type,
590                           old_db_params, new_db_params, strict)
591 
592     def _alter_field(self, model, old_field, new_field, old_type, new_type,
593                      old_db_params, new_db_params, strict=False):
594         """Perform a "physical" (non-ManyToMany) field update."""
595         # Drop any FK constraints, we'll remake them later
596         fks_dropped = set()
597         if (
598             self.connection.features.supports_foreign_keys and
599             old_field.remote_field and
600             old_field.db_constraint
601         ):
602             fk_names = self._constraint_names(model, [old_field.column], foreign_key=True)
603             if strict and len(fk_names) != 1:
604                 raise ValueError("Found wrong number (%s) of foreign key constraints for %s.%s" % (
605                     len(fk_names),
606                     model._meta.db_table,
607                     old_field.column,
608                 ))
609             for fk_name in fk_names:
610                 fks_dropped.add((old_field.column,))
611                 self.execute(self._delete_fk_sql(model, fk_name))
612         # Has unique been removed?
613         if old_field.unique and (not new_field.unique or self._field_became_primary_key(old_field, new_field)):
614             # Find the unique constraint for this field
615             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
616             constraint_names = self._constraint_names(
617                 model, [old_field.column], unique=True, primary_key=False,
618                 exclude=meta_constraint_names,
619             )
620             if strict and len(constraint_names) != 1:
621                 raise ValueError("Found wrong number (%s) of unique constraints for %s.%s" % (
622                     len(constraint_names),
623                     model._meta.db_table,
624                     old_field.column,
625                 ))
626             for constraint_name in constraint_names:
627                 self.execute(self._delete_unique_sql(model, constraint_name))
628         # Drop incoming FK constraints if the field is a primary key or unique,
629         # which might be a to_field target, and things are going to change.
630         drop_foreign_keys = (
631             self.connection.features.supports_foreign_keys and (
632                 (old_field.primary_key and new_field.primary_key) or
633                 (old_field.unique and new_field.unique)
634             ) and old_type != new_type
635         )
636         if drop_foreign_keys:
637             # '_meta.related_field' also contains M2M reverse fields, these
638             # will be filtered out
639             for _old_rel, new_rel in _related_non_m2m_objects(old_field, new_field):
640                 rel_fk_names = self._constraint_names(
641                     new_rel.related_model, [new_rel.field.column], foreign_key=True
642                 )
643                 for fk_name in rel_fk_names:
644                     self.execute(self._delete_fk_sql(new_rel.related_model, fk_name))
645         # Removed an index? (no strict check, as multiple indexes are possible)
646         # Remove indexes if db_index switched to False or a unique constraint
647         # will now be used in lieu of an index. The following lines from the
648         # truth table show all True cases; the rest are False:
649         #
650         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
651         # ------------------------------------------------------------------------------
652         # True               | False            | False              | False
653         # True               | False            | False              | True
654         # True               | False            | True               | True
655         if old_field.db_index and not old_field.unique and (not new_field.db_index or new_field.unique):
656             # Find the index for this field
657             meta_index_names = {index.name for index in model._meta.indexes}
658             # Retrieve only BTREE indexes since this is what's created with
659             # db_index=True.
660             index_names = self._constraint_names(
661                 model, [old_field.column], index=True, type_=Index.suffix,
662                 exclude=meta_index_names,
663             )
664             for index_name in index_names:
665                 # The only way to check if an index was created with
666                 # db_index=True or with Index(['field'], name='foo')
667                 # is to look at its name (refs #28053).
668                 self.execute(self._delete_index_sql(model, index_name))
669         # Change check constraints?
670         if old_db_params['check'] != new_db_params['check'] and old_db_params['check']:
671             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
672             constraint_names = self._constraint_names(
673                 model, [old_field.column], check=True,
674                 exclude=meta_constraint_names,
675             )
676             if strict and len(constraint_names) != 1:
677                 raise ValueError("Found wrong number (%s) of check constraints for %s.%s" % (
678                     len(constraint_names),
679                     model._meta.db_table,
680                     old_field.column,
681                 ))
682             for constraint_name in constraint_names:
683                 self.execute(self._delete_check_sql(model, constraint_name))
684         # Have they renamed the column?
685         if old_field.column != new_field.column:
686             self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
687             # Rename all references to the renamed column.
688             for sql in self.deferred_sql:
689                 if isinstance(sql, Statement):
690                     sql.rename_column_references(model._meta.db_table, old_field.column, new_field.column)
691         # Next, start accumulating actions to do
692         actions = []
693         null_actions = []
694         post_actions = []
695         # Collation change?
696         old_collation = getattr(old_field, 'db_collation', None)
697         new_collation = getattr(new_field, 'db_collation', None)
698         if old_collation != new_collation:
699             # Collation change handles also a type change.
700             fragment = self._alter_column_collation_sql(model, new_field, new_type, new_collation)
701             actions.append(fragment)
702         # Type change?
703         elif old_type != new_type:
704             fragment, other_actions = self._alter_column_type_sql(model, old_field, new_field, new_type)
705             actions.append(fragment)
706             post_actions.extend(other_actions)
707         # When changing a column NULL constraint to NOT NULL with a given
708         # default value, we need to perform 4 steps:
709         #  1. Add a default for new incoming writes
710         #  2. Update existing NULL rows with new default
711         #  3. Replace NULL constraint with NOT NULL
712         #  4. Drop the default again.
713         # Default change?
714         needs_database_default = False
715         if old_field.null and not new_field.null:
716             old_default = self.effective_default(old_field)
717             new_default = self.effective_default(new_field)
718             if (
719                 not self.skip_default(new_field) and
720                 old_default != new_default and
721                 new_default is not None
722             ):
723                 needs_database_default = True
724                 actions.append(self._alter_column_default_sql(model, old_field, new_field))
725         # Nullability change?
726         if old_field.null != new_field.null:
727             fragment = self._alter_column_null_sql(model, old_field, new_field)
728             if fragment:
729                 null_actions.append(fragment)
730         # Only if we have a default and there is a change from NULL to NOT NULL
731         four_way_default_alteration = (
732             new_field.has_default() and
733             (old_field.null and not new_field.null)
734         )
735         if actions or null_actions:
736             if not four_way_default_alteration:
737                 # If we don't have to do a 4-way default alteration we can
738                 # directly run a (NOT) NULL alteration
739                 actions = actions + null_actions
740             # Combine actions together if we can (e.g. postgres)
741             if self.connection.features.supports_combined_alters and actions:
742                 sql, params = tuple(zip(*actions))
743                 actions = [(", ".join(sql), sum(params, []))]
744             # Apply those actions
745             for sql, params in actions:
746                 self.execute(
747                     self.sql_alter_column % {
748                         "table": self.quote_name(model._meta.db_table),
749                         "changes": sql,
750                     },
751                     params,
752                 )
753             if four_way_default_alteration:
754                 # Update existing rows with default value
755                 self.execute(
756                     self.sql_update_with_default % {
757                         "table": self.quote_name(model._meta.db_table),
758                         "column": self.quote_name(new_field.column),
759                         "default": "%s",
760                     },
761                     [new_default],
762                 )
763                 # Since we didn't run a NOT NULL change before we need to do it
764                 # now
765                 for sql, params in null_actions:
766                     self.execute(
767                         self.sql_alter_column % {
768                             "table": self.quote_name(model._meta.db_table),
769                             "changes": sql,
770                         },
771                         params,
772                     )
773         if post_actions:
774             for sql, params in post_actions:
775                 self.execute(sql, params)
776         # If primary_key changed to False, delete the primary key constraint.
777         if old_field.primary_key and not new_field.primary_key:
778             self._delete_primary_key(model, strict)
779         # Added a unique?
780         if self._unique_should_be_added(old_field, new_field):
781             self.execute(self._create_unique_sql(model, [new_field.column]))
782         # Added an index? Add an index if db_index switched to True or a unique
783         # constraint will no longer be used in lieu of an index. The following
784         # lines from the truth table show all True cases; the rest are False:
785         #
786         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
787         # ------------------------------------------------------------------------------
788         # False              | False            | True               | False
789         # False              | True             | True               | False
790         # True               | True             | True               | False
791         if (not old_field.db_index or old_field.unique) and new_field.db_index and not new_field.unique:
792             self.execute(self._create_index_sql(model, fields=[new_field]))
793         # Type alteration on primary key? Then we need to alter the column
794         # referring to us.
795         rels_to_update = []
796         if drop_foreign_keys:
797             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
798         # Changed to become primary key?
799         if self._field_became_primary_key(old_field, new_field):
800             # Make the new one
801             self.execute(self._create_primary_key_sql(model, new_field))
802             # Update all referencing columns
803             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
804         # Handle our type alters on the other end of rels from the PK stuff above
805         for old_rel, new_rel in rels_to_update:
806             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
807             rel_type = rel_db_params['type']
808             fragment, other_actions = self._alter_column_type_sql(
809                 new_rel.related_model, old_rel.field, new_rel.field, rel_type
810             )
811             self.execute(
812                 self.sql_alter_column % {
813                     "table": self.quote_name(new_rel.related_model._meta.db_table),
814                     "changes": fragment[0],
815                 },
816                 fragment[1],
817             )
818             for sql, params in other_actions:
819                 self.execute(sql, params)
820         # Does it have a foreign key?
821         if (self.connection.features.supports_foreign_keys and new_field.remote_field and
822                 (fks_dropped or not old_field.remote_field or not old_field.db_constraint) and
823                 new_field.db_constraint):
824             self.execute(self._create_fk_sql(model, new_field, "_fk_%(to_table)s_%(to_column)s"))
825         # Rebuild FKs that pointed to us if we previously had to drop them
826         if drop_foreign_keys:
827             for rel in new_field.model._meta.related_objects:
828                 if _is_relevant_relation(rel, new_field) and rel.field.db_constraint:
829                     self.execute(self._create_fk_sql(rel.related_model, rel.field, "_fk"))
830         # Does it have check constraints we need to add?
831         if old_db_params['check'] != new_db_params['check'] and new_db_params['check']:
832             constraint_name = self._create_index_name(model._meta.db_table, [new_field.column], suffix='_check')
833             self.execute(self._create_check_sql(model, constraint_name, new_db_params['check']))
834         # Drop the default if we need to
835         # (Django usually does not use in-database defaults)
836         if needs_database_default:
837             changes_sql, params = self._alter_column_default_sql(model, old_field, new_field, drop=True)
838             sql = self.sql_alter_column % {
839                 "table": self.quote_name(model._meta.db_table),
840                 "changes": changes_sql,
841             }
842             self.execute(sql, params)
843         # Reset connection if required
844         if self.connection.features.connection_persists_old_columns:
845             self.connection.close()
846 
847     def _alter_column_null_sql(self, model, old_field, new_field):
848         """
849         Hook to specialize column null alteration.
850 
851         Return a (sql, params) fragment to set a column to null or non-null
852         as required by new_field, or None if no changes are required.
853         """
854         if (self.connection.features.interprets_empty_strings_as_nulls and
855                 new_field.get_internal_type() in ("CharField", "TextField")):
856             # The field is nullable in the database anyway, leave it alone.
857             return
858         else:
859             new_db_params = new_field.db_parameters(connection=self.connection)
860             sql = self.sql_alter_column_null if new_field.null else self.sql_alter_column_not_null
861             return (
862                 sql % {
863                     'column': self.quote_name(new_field.column),
864                     'type': new_db_params['type'],
865                 },
866                 [],
867             )
868 
869     def _alter_column_default_sql(self, model, old_field, new_field, drop=False):
870         """
871         Hook to specialize column default alteration.
872 
873         Return a (sql, params) fragment to add or drop (depending on the drop
874         argument) a default to new_field's column.
875         """
876         new_default = self.effective_default(new_field)
877         default = self._column_default_sql(new_field)
878         params = [new_default]
879 
880         if drop:
881             params = []
882         elif self.connection.features.requires_literal_defaults:
883             # Some databases (Oracle) can't take defaults as a parameter
884             # If this is the case, the SchemaEditor for that database should
885             # implement prepare_default().
886             default = self.prepare_default(new_default)
887             params = []
888 
889         new_db_params = new_field.db_parameters(connection=self.connection)
890         sql = self.sql_alter_column_no_default if drop else self.sql_alter_column_default
891         return (
892             sql % {
893                 'column': self.quote_name(new_field.column),
894                 'type': new_db_params['type'],
895                 'default': default,
896             },
897             params,
898         )
899 
900     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
901         """
902         Hook to specialize column type alteration for different backends,
903         for cases when a creation type is different to an alteration type
904         (e.g. SERIAL in PostgreSQL, PostGIS fields).
905 
906         Return a two-tuple of: an SQL fragment of (sql, params) to insert into
907         an ALTER TABLE statement and a list of extra (sql, params) tuples to
908         run once the field is altered.
909         """
910         return (
911             (
912                 self.sql_alter_column_type % {
913                     "column": self.quote_name(new_field.column),
914                     "type": new_type,
915                 },
916                 [],
917             ),
918             [],
919         )
920 
921     def _alter_column_collation_sql(self, model, new_field, new_type, new_collation):
922         return (
923             self.sql_alter_column_collate % {
924                 'column': self.quote_name(new_field.column),
925                 'type': new_type,
926                 'collation': self._collate_sql(new_collation) if new_collation else '',
927             },
928             [],
929         )
930 
931     def _alter_many_to_many(self, model, old_field, new_field, strict):
932         """Alter M2Ms to repoint their to= endpoints."""
933         # Rename the through table
934         if old_field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:
935             self.alter_db_table(old_field.remote_field.through, old_field.remote_field.through._meta.db_table,
936                                 new_field.remote_field.through._meta.db_table)
937         # Repoint the FK to the other side
938         self.alter_field(
939             new_field.remote_field.through,
940             # We need the field that points to the target model, so we can tell alter_field to change it -
941             # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
942             old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
943             new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
944         )
945         self.alter_field(
946             new_field.remote_field.through,
947             # for self-referential models we need to alter field from the other end too
948             old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),
949             new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),
950         )
951 
952     def _create_index_name(self, table_name, column_names, suffix=""):
953         """
954         Generate a unique name for an index/unique constraint.
955 
956         The name is divided into 3 parts: the table name, the column names,
957         and a unique digest and suffix.
958         """
959         _, table_name = split_identifier(table_name)
960         hash_suffix_part = '%s%s' % (names_digest(table_name, *column_names, length=8), suffix)
961         max_length = self.connection.ops.max_name_length() or 200
962         # If everything fits into max_length, use that name.
963         index_name = '%s_%s_%s' % (table_name, '_'.join(column_names), hash_suffix_part)
964         if len(index_name) <= max_length:
965             return index_name
966         # Shorten a long suffix.
967         if len(hash_suffix_part) > max_length / 3:
968             hash_suffix_part = hash_suffix_part[:max_length // 3]
969         other_length = (max_length - len(hash_suffix_part)) // 2 - 1
970         index_name = '%s_%s_%s' % (
971             table_name[:other_length],
972             '_'.join(column_names)[:other_length],
973             hash_suffix_part,
974         )
975         # Prepend D if needed to prevent the name from starting with an
976         # underscore or a number (not permitted on Oracle).
977         if index_name[0] == "_" or index_name[0].isdigit():
978             index_name = "D%s" % index_name[:-1]
979         return index_name
980 
981     def _get_index_tablespace_sql(self, model, fields, db_tablespace=None):
982         if db_tablespace is None:
983             if len(fields) == 1 and fields[0].db_tablespace:
984                 db_tablespace = fields[0].db_tablespace
985             elif model._meta.db_tablespace:
986                 db_tablespace = model._meta.db_tablespace
987         if db_tablespace is not None:
988             return ' ' + self.connection.ops.tablespace_sql(db_tablespace)
989         return ''
990 
991     def _index_condition_sql(self, condition):
992         if condition:
993             return ' WHERE ' + condition
994         return ''
995 
996     def _index_include_sql(self, model, columns):
997         if not columns or not self.connection.features.supports_covering_indexes:
998             return ''
999         return Statement(
1000             ' INCLUDE (%(columns)s)',
1001             columns=Columns(model._meta.db_table, columns, self.quote_name),
1002         )
1003 
1004     def _create_index_sql(self, model, *, fields=None, name=None, suffix='', using='',
1005                           db_tablespace=None, col_suffixes=(), sql=None, opclasses=(),
1006                           condition=None, include=None, expressions=None):
1007         """
1008         Return the SQL statement to create the index for one or several fields
1009         or expressions. `sql` can be specified if the syntax differs from the
1010         standard (GIS indexes, ...).
1011         """
1012         fields = fields or []
1013         expressions = expressions or []
1014         compiler = Query(model, alias_cols=False).get_compiler(
1015             connection=self.connection,
1016         )
1017         tablespace_sql = self._get_index_tablespace_sql(model, fields, db_tablespace=db_tablespace)
1018         columns = [field.column for field in fields]
1019         sql_create_index = sql or self.sql_create_index
1020         table = model._meta.db_table
1021 
1022         def create_index_name(*args, **kwargs):
1023             nonlocal name
1024             if name is None:
1025                 name = self._create_index_name(*args, **kwargs)
1026             return self.quote_name(name)
1027 
1028         return Statement(
1029             sql_create_index,
1030             table=Table(table, self.quote_name),
1031             name=IndexName(table, columns, suffix, create_index_name),
1032             using=using,
1033             columns=(
1034                 self._index_columns(table, columns, col_suffixes, opclasses)
1035                 if columns
1036                 else Expressions(table, expressions, compiler, self.quote_value)
1037             ),
1038             extra=tablespace_sql,
1039             condition=self._index_condition_sql(condition),
1040             include=self._index_include_sql(model, include),
1041         )
1042 
1043     def _delete_index_sql(self, model, name, sql=None):
1044         return Statement(
1045             sql or self.sql_delete_index,
1046             table=Table(model._meta.db_table, self.quote_name),
1047             name=self.quote_name(name),
1048         )
1049 
1050     def _index_columns(self, table, columns, col_suffixes, opclasses):
1051         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
1052 
1053     def _model_indexes_sql(self, model):
1054         """
1055         Return a list of all index SQL statements (field indexes,
1056         index_together, Meta.indexes) for the specified model.
1057         """
1058         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1059             return []
1060         output = []
1061         for field in model._meta.local_fields:
1062             output.extend(self._field_indexes_sql(model, field))
1063 
1064         for field_names in model._meta.index_together:
1065             fields = [model._meta.get_field(field) for field in field_names]
1066             output.append(self._create_index_sql(model, fields=fields, suffix='_idx'))
1067 
1068         for index in model._meta.indexes:
1069             if (
1070                 not index.contains_expressions or
1071                 self.connection.features.supports_expression_indexes
1072             ):
1073                 output.append(index.create_sql(model, self))
1074         return output
1075 
1076     def _field_indexes_sql(self, model, field):
1077         """
1078         Return a list of all index SQL statements for the specified field.
1079         """
1080         output = []
1081         if self._field_should_be_indexed(model, field):
1082             output.append(self._create_index_sql(model, fields=[field]))
1083         return output
1084 
1085     def _field_should_be_altered(self, old_field, new_field):
1086         _, old_path, old_args, old_kwargs = old_field.deconstruct()
1087         _, new_path, new_args, new_kwargs = new_field.deconstruct()
1088         # Don't alter when:
1089         # - changing only a field name
1090         # - changing an attribute that doesn't affect the schema
1091         # - adding only a db_column and the column name is not changed
1092         non_database_attrs = [
1093             'blank',
1094             'db_column',
1095             'editable',
1096             'error_messages',
1097             'help_text',
1098             'limit_choices_to',
1099             # Database-level options are not supported, see #21961.
1100             'on_delete',
1101             'related_name',
1102             'related_query_name',
1103             'validators',
1104             'verbose_name',
1105         ]
1106         for attr in non_database_attrs:
1107             old_kwargs.pop(attr, None)
1108             new_kwargs.pop(attr, None)
1109         return (
1110             self.quote_name(old_field.column) != self.quote_name(new_field.column) or
1111             (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
1112         )
1113 
1114     def _field_should_be_indexed(self, model, field):
1115         return field.db_index and not field.unique
1116 
1117     def _field_became_primary_key(self, old_field, new_field):
1118         return not old_field.primary_key and new_field.primary_key
1119 
1120     def _unique_should_be_added(self, old_field, new_field):
1121         return (not old_field.unique and new_field.unique) or (
1122             old_field.primary_key and not new_field.primary_key and new_field.unique
1123         )
1124 
1125     def _rename_field_sql(self, table, old_field, new_field, new_type):
1126         return self.sql_rename_column % {
1127             "table": self.quote_name(table),
1128             "old_column": self.quote_name(old_field.column),
1129             "new_column": self.quote_name(new_field.column),
1130             "type": new_type,
1131         }
1132 
1133     def _create_fk_sql(self, model, field, suffix):
1134         table = Table(model._meta.db_table, self.quote_name)
1135         name = self._fk_constraint_name(model, field, suffix)
1136         column = Columns(model._meta.db_table, [field.column], self.quote_name)
1137         to_table = Table(field.target_field.model._meta.db_table, self.quote_name)
1138         to_column = Columns(field.target_field.model._meta.db_table, [field.target_field.column], self.quote_name)
1139         deferrable = self.connection.ops.deferrable_sql()
1140         return Statement(
1141             self.sql_create_fk,
1142             table=table,
1143             name=name,
1144             column=column,
1145             to_table=to_table,
1146             to_column=to_column,
1147             deferrable=deferrable,
1148         )
1149 
1150     def _fk_constraint_name(self, model, field, suffix):
1151         def create_fk_name(*args, **kwargs):
1152             return self.quote_name(self._create_index_name(*args, **kwargs))
1153 
1154         return ForeignKeyName(
1155             model._meta.db_table,
1156             [field.column],
1157             split_identifier(field.target_field.model._meta.db_table)[1],
1158             [field.target_field.column],
1159             suffix,
1160             create_fk_name,
1161         )
1162 
1163     def _delete_fk_sql(self, model, name):
1164         return self._delete_constraint_sql(self.sql_delete_fk, model, name)
1165 
1166     def _deferrable_constraint_sql(self, deferrable):
1167         if deferrable is None:
1168             return ''
1169         if deferrable == Deferrable.DEFERRED:
1170             return ' DEFERRABLE INITIALLY DEFERRED'
1171         if deferrable == Deferrable.IMMEDIATE:
1172             return ' DEFERRABLE INITIALLY IMMEDIATE'
1173 
1174     def _unique_sql(
1175         self, model, fields, name, condition=None, deferrable=None,
1176         include=None, opclasses=None,
1177     ):
1178         if (
1179             deferrable and
1180             not self.connection.features.supports_deferrable_unique_constraints
1181         ):
1182             return None
1183         if condition or include or opclasses:
1184             # Databases support conditional and covering unique constraints via
1185             # a unique index.
1186             sql = self._create_unique_sql(
1187                 model,
1188                 fields,
1189                 name=name,
1190                 condition=condition,
1191                 include=include,
1192                 opclasses=opclasses,
1193             )
1194             if sql:
1195                 self.deferred_sql.append(sql)
1196             return None
1197         constraint = self.sql_unique_constraint % {
1198             'columns': ', '.join(map(self.quote_name, fields)),
1199             'deferrable': self._deferrable_constraint_sql(deferrable),
1200         }
1201         return self.sql_constraint % {
1202             'name': self.quote_name(name),
1203             'constraint': constraint,
1204         }
1205 
1206     def _create_unique_sql(
1207         self, model, columns, name=None, condition=None, deferrable=None,
1208         include=None, opclasses=None,
1209     ):
1210         if (
1211             (
1212                 deferrable and
1213                 not self.connection.features.supports_deferrable_unique_constraints
1214             ) or
1215             (condition and not self.connection.features.supports_partial_indexes) or
1216             (include and not self.connection.features.supports_covering_indexes)
1217         ):
1218             return None
1219 
1220         def create_unique_name(*args, **kwargs):
1221             return self.quote_name(self._create_index_name(*args, **kwargs))
1222 
1223         table = Table(model._meta.db_table, self.quote_name)
1224         if name is None:
1225             name = IndexName(model._meta.db_table, columns, '_uniq', create_unique_name)
1226         else:
1227             name = self.quote_name(name)
1228         columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)
1229         if condition or include or opclasses:
1230             sql = self.sql_create_unique_index
1231         else:
1232             sql = self.sql_create_unique
1233         return Statement(
1234             sql,
1235             table=table,
1236             name=name,
1237             columns=columns,
1238             condition=self._index_condition_sql(condition),
1239             deferrable=self._deferrable_constraint_sql(deferrable),
1240             include=self._index_include_sql(model, include),
1241         )
1242 
1243     def _delete_unique_sql(
1244         self, model, name, condition=None, deferrable=None, include=None,
1245         opclasses=None,
1246     ):
1247         if (
1248             (
1249                 deferrable and
1250                 not self.connection.features.supports_deferrable_unique_constraints
1251             ) or
1252             (condition and not self.connection.features.supports_partial_indexes) or
1253             (include and not self.connection.features.supports_covering_indexes)
1254         ):
1255             return None
1256         if condition or include or opclasses:
1257             sql = self.sql_delete_index
1258         else:
1259             sql = self.sql_delete_unique
1260         return self._delete_constraint_sql(sql, model, name)
1261 
1262     def _check_sql(self, name, check):
1263         return self.sql_constraint % {
1264             'name': self.quote_name(name),
1265             'constraint': self.sql_check_constraint % {'check': check},
1266         }
1267 
1268     def _create_check_sql(self, model, name, check):
1269         return Statement(
1270             self.sql_create_check,
1271             table=Table(model._meta.db_table, self.quote_name),
1272             name=self.quote_name(name),
1273             check=check,
1274         )
1275 
1276     def _delete_check_sql(self, model, name):
1277         return self._delete_constraint_sql(self.sql_delete_check, model, name)
1278 
1279     def _delete_constraint_sql(self, template, model, name):
1280         return Statement(
1281             template,
1282             table=Table(model._meta.db_table, self.quote_name),
1283             name=self.quote_name(name),
1284         )
1285 
1286     def _constraint_names(self, model, column_names=None, unique=None,
1287                           primary_key=None, index=None, foreign_key=None,
1288                           check=None, type_=None, exclude=None):
1289         """Return all constraint names matching the columns and conditions."""
1290         if column_names is not None:
1291             column_names = [
1292                 self.connection.introspection.identifier_converter(name)
1293                 for name in column_names
1294             ]
1295         with self.connection.cursor() as cursor:
1296             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
1297         result = []
1298         for name, infodict in constraints.items():
1299             if column_names is None or column_names == infodict['columns']:
1300                 if unique is not None and infodict['unique'] != unique:
1301                     continue
1302                 if primary_key is not None and infodict['primary_key'] != primary_key:
1303                     continue
1304                 if index is not None and infodict['index'] != index:
1305                     continue
1306                 if check is not None and infodict['check'] != check:
1307                     continue
1308                 if foreign_key is not None and not infodict['foreign_key']:
1309                     continue
1310                 if type_ is not None and infodict['type'] != type_:
1311                     continue
1312                 if not exclude or name not in exclude:
1313                     result.append(name)
1314         return result
1315 
1316     def _delete_primary_key(self, model, strict=False):
1317         constraint_names = self._constraint_names(model, primary_key=True)
1318         if strict and len(constraint_names) != 1:
1319             raise ValueError('Found wrong number (%s) of PK constraints for %s' % (
1320                 len(constraint_names),
1321                 model._meta.db_table,
1322             ))
1323         for constraint_name in constraint_names:
1324             self.execute(self._delete_primary_key_sql(model, constraint_name))
1325 
1326     def _create_primary_key_sql(self, model, field):
1327         return Statement(
1328             self.sql_create_pk,
1329             table=Table(model._meta.db_table, self.quote_name),
1330             name=self.quote_name(
1331                 self._create_index_name(model._meta.db_table, [field.column], suffix="_pk")
1332             ),
1333             columns=Columns(model._meta.db_table, [field.column], self.quote_name),
1334         )
1335 
1336     def _delete_primary_key_sql(self, model, name):
1337         return self._delete_constraint_sql(self.sql_delete_pk, model, name)
1338 
1339     def _collate_sql(self, collation):
1340         return ' COLLATE ' + self.quote_name(collation)
1341 
1342     def remove_procedure(self, procedure_name, param_types=()):
1343         sql = self.sql_delete_procedure % {
1344             'procedure': self.quote_name(procedure_name),
1345             'param_types': ','.join(param_types),
1346         }
1347         self.execute(sql)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 05:35:48.183 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:35:48.183 | INFO     | Search-only: skipping patch selection
2025-10-15 05:35:48.340 | INFO     | Task django__django-13886 completed successfully.
2025-10-15 05:35:48.340 | INFO     | No patch generated. You can try running ACR again.
