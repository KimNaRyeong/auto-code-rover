[
    {
        "rel_file_path": "src/_pytest/hookspec.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/hookspec.py",
        "start": 1,
        "end": 972,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Hook specifications for pytest plugins which are invoked by pytest itself\n2 and by builtin plugins.\"\"\"\n3 from pathlib import Path\n4 from typing import Any\n5 from typing import Dict\n6 from typing import List\n7 from typing import Mapping\n8 from typing import Optional\n9 from typing import Sequence\n10 from typing import Tuple\n11 from typing import TYPE_CHECKING\n12 from typing import Union\n13 \n14 from pluggy import HookspecMarker\n15 \n16 from _pytest.deprecated import WARNING_CMDLINE_PREPARSE_HOOK\n17 \n18 if TYPE_CHECKING:\n19     import pdb\n20     import warnings\n21     from typing_extensions import Literal\n22 \n23     from _pytest._code.code import ExceptionRepr\n24     from _pytest.code import ExceptionInfo\n25     from _pytest.config import Config\n26     from _pytest.config import ExitCode\n27     from _pytest.config import PytestPluginManager\n28     from _pytest.config import _PluggyPlugin\n29     from _pytest.config.argparsing import Parser\n30     from _pytest.fixtures import FixtureDef\n31     from _pytest.fixtures import SubRequest\n32     from _pytest.main import Session\n33     from _pytest.nodes import Collector\n34     from _pytest.nodes import Item\n35     from _pytest.outcomes import Exit\n36     from _pytest.python import Class\n37     from _pytest.python import Function\n38     from _pytest.python import Metafunc\n39     from _pytest.python import Module\n40     from _pytest.reports import CollectReport\n41     from _pytest.reports import TestReport\n42     from _pytest.runner import CallInfo\n43     from _pytest.terminal import TerminalReporter\n44     from _pytest.compat import LEGACY_PATH\n45 \n46 \n47 hookspec = HookspecMarker(\"pytest\")\n48 \n49 # -------------------------------------------------------------------------\n50 # Initialization hooks called for every plugin\n51 # -------------------------------------------------------------------------\n52 \n53 \n54 @hookspec(historic=True)\n55 def pytest_addhooks(pluginmanager: \"PytestPluginManager\") -> None:\n56     \"\"\"Called at plugin registration time to allow adding new hooks via a call to\n57     ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n58 \n59     :param pytest.PytestPluginManager pluginmanager: The pytest plugin manager.\n60 \n61     .. note::\n62         This hook is incompatible with ``hookwrapper=True``.\n63     \"\"\"\n64 \n65 \n66 @hookspec(historic=True)\n67 def pytest_plugin_registered(\n68     plugin: \"_PluggyPlugin\", manager: \"PytestPluginManager\"\n69 ) -> None:\n70     \"\"\"A new pytest plugin got registered.\n71 \n72     :param plugin: The plugin module or instance.\n73     :param pytest.PytestPluginManager manager: pytest plugin manager.\n74 \n75     .. note::\n76         This hook is incompatible with ``hookwrapper=True``.\n77     \"\"\"\n78 \n79 \n80 @hookspec(historic=True)\n81 def pytest_addoption(parser: \"Parser\", pluginmanager: \"PytestPluginManager\") -> None:\n82     \"\"\"Register argparse-style options and ini-style config values,\n83     called once at the beginning of a test run.\n84 \n85     .. note::\n86 \n87         This function should be implemented only in plugins or ``conftest.py``\n88         files situated at the tests root directory due to how pytest\n89         :ref:`discovers plugins during startup <pluginorder>`.\n90 \n91     :param pytest.Parser parser:\n92         To add command line options, call\n93         :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.\n94         To add ini-file values call :py:func:`parser.addini(...)\n95         <pytest.Parser.addini>`.\n96 \n97     :param pytest.PytestPluginManager pluginmanager:\n98         The pytest plugin manager, which can be used to install :py:func:`hookspec`'s\n99         or :py:func:`hookimpl`'s and allow one plugin to call another plugin's hooks\n100         to change how command line options are added.\n101 \n102     Options can later be accessed through the\n103     :py:class:`config <pytest.Config>` object, respectively:\n104 \n105     - :py:func:`config.getoption(name) <pytest.Config.getoption>` to\n106       retrieve the value of a command line option.\n107 \n108     - :py:func:`config.getini(name) <pytest.Config.getini>` to retrieve\n109       a value read from an ini-style file.\n110 \n111     The config object is passed around on many internal objects via the ``.config``\n112     attribute or can be retrieved as the ``pytestconfig`` fixture.\n113 \n114     .. note::\n115         This hook is incompatible with ``hookwrapper=True``.\n116     \"\"\"\n117 \n118 \n119 @hookspec(historic=True)\n120 def pytest_configure(config: \"Config\") -> None:\n121     \"\"\"Allow plugins and conftest files to perform initial configuration.\n122 \n123     This hook is called for every plugin and initial conftest file\n124     after command line options have been parsed.\n125 \n126     After that, the hook is called for other conftest files as they are\n127     imported.\n128 \n129     .. note::\n130         This hook is incompatible with ``hookwrapper=True``.\n131 \n132     :param pytest.Config config: The pytest config object.\n133     \"\"\"\n134 \n135 \n136 # -------------------------------------------------------------------------\n137 # Bootstrapping hooks called for plugins registered early enough:\n138 # internal and 3rd party plugins.\n139 # -------------------------------------------------------------------------\n140 \n141 \n142 @hookspec(firstresult=True)\n143 def pytest_cmdline_parse(\n144     pluginmanager: \"PytestPluginManager\", args: List[str]\n145 ) -> Optional[\"Config\"]:\n146     \"\"\"Return an initialized :class:`~pytest.Config`, parsing the specified args.\n147 \n148     Stops at first non-None result, see :ref:`firstresult`.\n149 \n150     .. note::\n151         This hook will only be called for plugin classes passed to the\n152         ``plugins`` arg when using `pytest.main`_ to perform an in-process\n153         test run.\n154 \n155     :param pluginmanager: The pytest plugin manager.\n156     :param args: List of arguments passed on the command line.\n157     :returns: A pytest config object.\n158     \"\"\"\n159 \n160 \n161 @hookspec(warn_on_impl=WARNING_CMDLINE_PREPARSE_HOOK)\n162 def pytest_cmdline_preparse(config: \"Config\", args: List[str]) -> None:\n163     \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n164 \n165     This hook is considered deprecated and will be removed in a future pytest version. Consider\n166     using :hook:`pytest_load_initial_conftests` instead.\n167 \n168     .. note::\n169         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n170 \n171     :param config: The pytest config object.\n172     :param args: Arguments passed on the command line.\n173     \"\"\"\n174 \n175 \n176 @hookspec(firstresult=True)\n177 def pytest_cmdline_main(config: \"Config\") -> Optional[Union[\"ExitCode\", int]]:\n178     \"\"\"Called for performing the main command line action. The default\n179     implementation will invoke the configure hooks and runtest_mainloop.\n180 \n181     Stops at first non-None result, see :ref:`firstresult`.\n182 \n183     :param config: The pytest config object.\n184     :returns: The exit code.\n185     \"\"\"\n186 \n187 \n188 def pytest_load_initial_conftests(\n189     early_config: \"Config\", parser: \"Parser\", args: List[str]\n190 ) -> None:\n191     \"\"\"Called to implement the loading of initial conftest files ahead\n192     of command line option parsing.\n193 \n194     .. note::\n195         This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n196 \n197     :param early_config: The pytest config object.\n198     :param args: Arguments passed on the command line.\n199     :param parser: To add command line options.\n200     \"\"\"\n201 \n202 \n203 # -------------------------------------------------------------------------\n204 # collection hooks\n205 # -------------------------------------------------------------------------\n206 \n207 \n208 @hookspec(firstresult=True)\n209 def pytest_collection(session: \"Session\") -> Optional[object]:\n210     \"\"\"Perform the collection phase for the given session.\n211 \n212     Stops at first non-None result, see :ref:`firstresult`.\n213     The return value is not used, but only stops further processing.\n214 \n215     The default collection phase is this (see individual hooks for full details):\n216 \n217     1. Starting from ``session`` as the initial collector:\n218 \n219       1. ``pytest_collectstart(collector)``\n220       2. ``report = pytest_make_collect_report(collector)``\n221       3. ``pytest_exception_interact(collector, call, report)`` if an interactive exception occurred\n222       4. For each collected node:\n223 \n224         1. If an item, ``pytest_itemcollected(item)``\n225         2. If a collector, recurse into it.\n226 \n227       5. ``pytest_collectreport(report)``\n228 \n229     2. ``pytest_collection_modifyitems(session, config, items)``\n230 \n231       1. ``pytest_deselected(items)`` for any deselected items (may be called multiple times)\n232 \n233     3. ``pytest_collection_finish(session)``\n234     4. Set ``session.items`` to the list of collected items\n235     5. Set ``session.testscollected`` to the number of collected items\n236 \n237     You can implement this hook to only perform some action before collection,\n238     for example the terminal plugin uses it to start displaying the collection\n239     counter (and returns `None`).\n240 \n241     :param session: The pytest session object.\n242     \"\"\"\n243 \n244 \n245 def pytest_collection_modifyitems(\n246     session: \"Session\", config: \"Config\", items: List[\"Item\"]\n247 ) -> None:\n248     \"\"\"Called after collection has been performed. May filter or re-order\n249     the items in-place.\n250 \n251     :param session: The pytest session object.\n252     :param config: The pytest config object.\n253     :param items: List of item objects.\n254     \"\"\"\n255 \n256 \n257 def pytest_collection_finish(session: \"Session\") -> None:\n258     \"\"\"Called after collection has been performed and modified.\n259 \n260     :param session: The pytest session object.\n261     \"\"\"\n262 \n263 \n264 @hookspec(firstresult=True)\n265 def pytest_ignore_collect(\n266     collection_path: Path, path: \"LEGACY_PATH\", config: \"Config\"\n267 ) -> Optional[bool]:\n268     \"\"\"Return True to prevent considering this path for collection.\n269 \n270     This hook is consulted for all files and directories prior to calling\n271     more specific hooks.\n272 \n273     Stops at first non-None result, see :ref:`firstresult`.\n274 \n275     :param collection_path: The path to analyze.\n276     :param path: The path to analyze (deprecated).\n277     :param config: The pytest config object.\n278 \n279     .. versionchanged:: 7.0.0\n280         The ``collection_path`` parameter was added as a :class:`pathlib.Path`\n281         equivalent of the ``path`` parameter. The ``path`` parameter\n282         has been deprecated.\n283     \"\"\"\n284 \n285 \n286 def pytest_collect_file(\n287     file_path: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n288 ) -> \"Optional[Collector]\":\n289     \"\"\"Create a :class:`~pytest.Collector` for the given path, or None if not relevant.\n290 \n291     The new node needs to have the specified ``parent`` as a parent.\n292 \n293     :param file_path: The path to analyze.\n294     :param path: The path to collect (deprecated).\n295 \n296     .. versionchanged:: 7.0.0\n297         The ``file_path`` parameter was added as a :class:`pathlib.Path`\n298         equivalent of the ``path`` parameter. The ``path`` parameter\n299         has been deprecated.\n300     \"\"\"\n301 \n302 \n303 # logging hooks for collection\n304 \n305 \n306 def pytest_collectstart(collector: \"Collector\") -> None:\n307     \"\"\"Collector starts collecting.\n308 \n309     :param collector:\n310         The collector.\n311     \"\"\"\n312 \n313 \n314 def pytest_itemcollected(item: \"Item\") -> None:\n315     \"\"\"We just collected a test item.\n316 \n317     :param item:\n318         The item.\n319     \"\"\"\n320 \n321 \n322 def pytest_collectreport(report: \"CollectReport\") -> None:\n323     \"\"\"Collector finished collecting.\n324 \n325     :param report:\n326         The collect report.\n327     \"\"\"\n328 \n329 \n330 def pytest_deselected(items: Sequence[\"Item\"]) -> None:\n331     \"\"\"Called for deselected test items, e.g. by keyword.\n332 \n333     May be called multiple times.\n334 \n335     :param items:\n336         The items.\n337     \"\"\"\n338 \n339 \n340 @hookspec(firstresult=True)\n341 def pytest_make_collect_report(collector: \"Collector\") -> \"Optional[CollectReport]\":\n342     \"\"\"Perform :func:`collector.collect() <pytest.Collector.collect>` and return\n343     a :class:`~pytest.CollectReport`.\n344 \n345     Stops at first non-None result, see :ref:`firstresult`.\n346 \n347     :param collector:\n348         The collector.\n349     \"\"\"\n350 \n351 \n352 # -------------------------------------------------------------------------\n353 # Python test function related hooks\n354 # -------------------------------------------------------------------------\n355 \n356 \n357 @hookspec(firstresult=True)\n358 def pytest_pycollect_makemodule(\n359     module_path: Path, path: \"LEGACY_PATH\", parent\n360 ) -> Optional[\"Module\"]:\n361     \"\"\"Return a :class:`pytest.Module` collector or None for the given path.\n362 \n363     This hook will be called for each matching test module path.\n364     The :hook:`pytest_collect_file` hook needs to be used if you want to\n365     create test modules for files that do not match as a test module.\n366 \n367     Stops at first non-None result, see :ref:`firstresult`.\n368 \n369     :param module_path: The path of the module to collect.\n370     :param path: The path of the module to collect (deprecated).\n371 \n372     .. versionchanged:: 7.0.0\n373         The ``module_path`` parameter was added as a :class:`pathlib.Path`\n374         equivalent of the ``path`` parameter.\n375 \n376         The ``path`` parameter has been deprecated in favor of ``fspath``.\n377     \"\"\"\n378 \n379 \n380 @hookspec(firstresult=True)\n381 def pytest_pycollect_makeitem(\n382     collector: Union[\"Module\", \"Class\"], name: str, obj: object\n383 ) -> Union[None, \"Item\", \"Collector\", List[Union[\"Item\", \"Collector\"]]]:\n384     \"\"\"Return a custom item/collector for a Python object in a module, or None.\n385 \n386     Stops at first non-None result, see :ref:`firstresult`.\n387 \n388     :param collector:\n389         The module/class collector.\n390     :param name:\n391         The name of the object in the module/class.\n392     :param obj:\n393         The object.\n394     :returns:\n395         The created items/collectors.\n396     \"\"\"\n397 \n398 \n399 @hookspec(firstresult=True)\n400 def pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n401     \"\"\"Call underlying test function.\n402 \n403     Stops at first non-None result, see :ref:`firstresult`.\n404 \n405     :param pyfuncitem:\n406         The function item.\n407     \"\"\"\n408 \n409 \n410 def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n411     \"\"\"Generate (multiple) parametrized calls to a test function.\n412 \n413     :param metafunc:\n414         The :class:`~pytest.Metafunc` helper for the test function.\n415     \"\"\"\n416 \n417 \n418 @hookspec(firstresult=True)\n419 def pytest_make_parametrize_id(\n420     config: \"Config\", val: object, argname: str\n421 ) -> Optional[str]:\n422     \"\"\"Return a user-friendly string representation of the given ``val``\n423     that will be used by @pytest.mark.parametrize calls, or None if the hook\n424     doesn't know about ``val``.\n425 \n426     The parameter name is available as ``argname``, if required.\n427 \n428     Stops at first non-None result, see :ref:`firstresult`.\n429 \n430     :param config: The pytest config object.\n431     :param val: The parametrized value.\n432     :param str argname: The automatic parameter name produced by pytest.\n433     \"\"\"\n434 \n435 \n436 # -------------------------------------------------------------------------\n437 # runtest related hooks\n438 # -------------------------------------------------------------------------\n439 \n440 \n441 @hookspec(firstresult=True)\n442 def pytest_runtestloop(session: \"Session\") -> Optional[object]:\n443     \"\"\"Perform the main runtest loop (after collection finished).\n444 \n445     The default hook implementation performs the runtest protocol for all items\n446     collected in the session (``session.items``), unless the collection failed\n447     or the ``collectonly`` pytest option is set.\n448 \n449     If at any point :py:func:`pytest.exit` is called, the loop is\n450     terminated immediately.\n451 \n452     If at any point ``session.shouldfail`` or ``session.shouldstop`` are set, the\n453     loop is terminated after the runtest protocol for the current item is finished.\n454 \n455     :param session: The pytest session object.\n456 \n457     Stops at first non-None result, see :ref:`firstresult`.\n458     The return value is not used, but only stops further processing.\n459     \"\"\"\n460 \n461 \n462 @hookspec(firstresult=True)\n463 def pytest_runtest_protocol(\n464     item: \"Item\", nextitem: \"Optional[Item]\"\n465 ) -> Optional[object]:\n466     \"\"\"Perform the runtest protocol for a single test item.\n467 \n468     The default runtest protocol is this (see individual hooks for full details):\n469 \n470     - ``pytest_runtest_logstart(nodeid, location)``\n471 \n472     - Setup phase:\n473         - ``call = pytest_runtest_setup(item)`` (wrapped in ``CallInfo(when=\"setup\")``)\n474         - ``report = pytest_runtest_makereport(item, call)``\n475         - ``pytest_runtest_logreport(report)``\n476         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred\n477 \n478     - Call phase, if the the setup passed and the ``setuponly`` pytest option is not set:\n479         - ``call = pytest_runtest_call(item)`` (wrapped in ``CallInfo(when=\"call\")``)\n480         - ``report = pytest_runtest_makereport(item, call)``\n481         - ``pytest_runtest_logreport(report)``\n482         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred\n483 \n484     - Teardown phase:\n485         - ``call = pytest_runtest_teardown(item, nextitem)`` (wrapped in ``CallInfo(when=\"teardown\")``)\n486         - ``report = pytest_runtest_makereport(item, call)``\n487         - ``pytest_runtest_logreport(report)``\n488         - ``pytest_exception_interact(call, report)`` if an interactive exception occurred\n489 \n490     - ``pytest_runtest_logfinish(nodeid, location)``\n491 \n492     :param item: Test item for which the runtest protocol is performed.\n493     :param nextitem: The scheduled-to-be-next test item (or None if this is the end my friend).\n494 \n495     Stops at first non-None result, see :ref:`firstresult`.\n496     The return value is not used, but only stops further processing.\n497     \"\"\"\n498 \n499 \n500 def pytest_runtest_logstart(\n501     nodeid: str, location: Tuple[str, Optional[int], str]\n502 ) -> None:\n503     \"\"\"Called at the start of running the runtest protocol for a single item.\n504 \n505     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n506 \n507     :param nodeid: Full node ID of the item.\n508     :param location: A tuple of ``(filename, lineno, testname)``.\n509     \"\"\"\n510 \n511 \n512 def pytest_runtest_logfinish(\n513     nodeid: str, location: Tuple[str, Optional[int], str]\n514 ) -> None:\n515     \"\"\"Called at the end of running the runtest protocol for a single item.\n516 \n517     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n518 \n519     :param nodeid: Full node ID of the item.\n520     :param location: A tuple of ``(filename, lineno, testname)``.\n521     \"\"\"\n522 \n523 \n524 def pytest_runtest_setup(item: \"Item\") -> None:\n525     \"\"\"Called to perform the setup phase for a test item.\n526 \n527     The default implementation runs ``setup()`` on ``item`` and all of its\n528     parents (which haven't been setup yet). This includes obtaining the\n529     values of fixtures required by the item (which haven't been obtained\n530     yet).\n531 \n532     :param item:\n533         The item.\n534     \"\"\"\n535 \n536 \n537 def pytest_runtest_call(item: \"Item\") -> None:\n538     \"\"\"Called to run the test for test item (the call phase).\n539 \n540     The default implementation calls ``item.runtest()``.\n541 \n542     :param item:\n543         The item.\n544     \"\"\"\n545 \n546 \n547 def pytest_runtest_teardown(item: \"Item\", nextitem: Optional[\"Item\"]) -> None:\n548     \"\"\"Called to perform the teardown phase for a test item.\n549 \n550     The default implementation runs the finalizers and calls ``teardown()``\n551     on ``item`` and all of its parents (which need to be torn down). This\n552     includes running the teardown phase of fixtures required by the item (if\n553     they go out of scope).\n554 \n555     :param item:\n556         The item.\n557     :param nextitem:\n558         The scheduled-to-be-next test item (None if no further test item is\n559         scheduled). This argument is used to perform exact teardowns, i.e.\n560         calling just enough finalizers so that nextitem only needs to call\n561         setup functions.\n562     \"\"\"\n563 \n564 \n565 @hookspec(firstresult=True)\n566 def pytest_runtest_makereport(\n567     item: \"Item\", call: \"CallInfo[None]\"\n568 ) -> Optional[\"TestReport\"]:\n569     \"\"\"Called to create a :class:`~pytest.TestReport` for each of\n570     the setup, call and teardown runtest phases of a test item.\n571 \n572     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n573 \n574     :param item: The item.\n575     :param call: The :class:`~pytest.CallInfo` for the phase.\n576 \n577     Stops at first non-None result, see :ref:`firstresult`.\n578     \"\"\"\n579 \n580 \n581 def pytest_runtest_logreport(report: \"TestReport\") -> None:\n582     \"\"\"Process the :class:`~pytest.TestReport` produced for each\n583     of the setup, call and teardown runtest phases of an item.\n584 \n585     See :hook:`pytest_runtest_protocol` for a description of the runtest protocol.\n586     \"\"\"\n587 \n588 \n589 @hookspec(firstresult=True)\n590 def pytest_report_to_serializable(\n591     config: \"Config\",\n592     report: Union[\"CollectReport\", \"TestReport\"],\n593 ) -> Optional[Dict[str, Any]]:\n594     \"\"\"Serialize the given report object into a data structure suitable for\n595     sending over the wire, e.g. converted to JSON.\n596 \n597     :param config: The pytest config object.\n598     :param report: The report.\n599     \"\"\"\n600 \n601 \n602 @hookspec(firstresult=True)\n603 def pytest_report_from_serializable(\n604     config: \"Config\",\n605     data: Dict[str, Any],\n606 ) -> Optional[Union[\"CollectReport\", \"TestReport\"]]:\n607     \"\"\"Restore a report object previously serialized with\n608     :hook:`pytest_report_to_serializable`.\n609 \n610     :param config: The pytest config object.\n611     \"\"\"\n612 \n613 \n614 # -------------------------------------------------------------------------\n615 # Fixture related hooks\n616 # -------------------------------------------------------------------------\n617 \n618 \n619 @hookspec(firstresult=True)\n620 def pytest_fixture_setup(\n621     fixturedef: \"FixtureDef[Any]\", request: \"SubRequest\"\n622 ) -> Optional[object]:\n623     \"\"\"Perform fixture setup execution.\n624 \n625     :param fixturdef:\n626         The fixture definition object.\n627     :param request:\n628         The fixture request object.\n629     :returns:\n630         The return value of the call to the fixture function.\n631 \n632     Stops at first non-None result, see :ref:`firstresult`.\n633 \n634     .. note::\n635         If the fixture function returns None, other implementations of\n636         this hook function will continue to be called, according to the\n637         behavior of the :ref:`firstresult` option.\n638     \"\"\"\n639 \n640 \n641 def pytest_fixture_post_finalizer(\n642     fixturedef: \"FixtureDef[Any]\", request: \"SubRequest\"\n643 ) -> None:\n644     \"\"\"Called after fixture teardown, but before the cache is cleared, so\n645     the fixture result ``fixturedef.cached_result`` is still available (not\n646     ``None``).\n647 \n648     :param fixturdef:\n649         The fixture definition object.\n650     :param request:\n651         The fixture request object.\n652     \"\"\"\n653 \n654 \n655 # -------------------------------------------------------------------------\n656 # test session related hooks\n657 # -------------------------------------------------------------------------\n658 \n659 \n660 def pytest_sessionstart(session: \"Session\") -> None:\n661     \"\"\"Called after the ``Session`` object has been created and before performing collection\n662     and entering the run test loop.\n663 \n664     :param session: The pytest session object.\n665     \"\"\"\n666 \n667 \n668 def pytest_sessionfinish(\n669     session: \"Session\",\n670     exitstatus: Union[int, \"ExitCode\"],\n671 ) -> None:\n672     \"\"\"Called after whole test run finished, right before returning the exit status to the system.\n673 \n674     :param session: The pytest session object.\n675     :param exitstatus: The status which pytest will return to the system.\n676     \"\"\"\n677 \n678 \n679 def pytest_unconfigure(config: \"Config\") -> None:\n680     \"\"\"Called before test process is exited.\n681 \n682     :param config: The pytest config object.\n683     \"\"\"\n684 \n685 \n686 # -------------------------------------------------------------------------\n687 # hooks for customizing the assert methods\n688 # -------------------------------------------------------------------------\n689 \n690 \n691 def pytest_assertrepr_compare(\n692     config: \"Config\", op: str, left: object, right: object\n693 ) -> Optional[List[str]]:\n694     \"\"\"Return explanation for comparisons in failing assert expressions.\n695 \n696     Return None for no custom explanation, otherwise return a list\n697     of strings. The strings will be joined by newlines but any newlines\n698     *in* a string will be escaped. Note that all but the first line will\n699     be indented slightly, the intention is for the first line to be a summary.\n700 \n701     :param config: The pytest config object.\n702     :param op: The operator, e.g. `\"==\"`, `\"!=\"`, `\"not in\"`.\n703     :param left: The left operand.\n704     :param right: The right operand.\n705     \"\"\"\n706 \n707 \n708 def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n709     \"\"\"Called whenever an assertion passes.\n710 \n711     .. versionadded:: 5.0\n712 \n713     Use this hook to do some processing after a passing assertion.\n714     The original assertion information is available in the `orig` string\n715     and the pytest introspected assertion information is available in the\n716     `expl` string.\n717 \n718     This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n719     ini-file option:\n720 \n721     .. code-block:: ini\n722 \n723         [pytest]\n724         enable_assertion_pass_hook=true\n725 \n726     You need to **clean the .pyc** files in your project directory and interpreter libraries\n727     when enabling this option, as assertions will require to be re-written.\n728 \n729     :param item: pytest item object of current test.\n730     :param lineno: Line number of the assert statement.\n731     :param orig: String with the original assertion.\n732     :param expl: String with the assert explanation.\n733     \"\"\"\n734 \n735 \n736 # -------------------------------------------------------------------------\n737 # Hooks for influencing reporting (invoked from _pytest_terminal).\n738 # -------------------------------------------------------------------------\n739 \n740 \n741 def pytest_report_header(\n742     config: \"Config\", start_path: Path, startdir: \"LEGACY_PATH\"\n743 ) -> Union[str, List[str]]:\n744     \"\"\"Return a string or list of strings to be displayed as header info for terminal reporting.\n745 \n746     :param config: The pytest config object.\n747     :param start_path: The starting dir.\n748     :param startdir: The starting dir (deprecated).\n749 \n750     .. note::\n751 \n752         Lines returned by a plugin are displayed before those of plugins which\n753         ran before it.\n754         If you want to have your line(s) displayed first, use\n755         :ref:`trylast=True <plugin-hookorder>`.\n756 \n757     .. note::\n758 \n759         This function should be implemented only in plugins or ``conftest.py``\n760         files situated at the tests root directory due to how pytest\n761         :ref:`discovers plugins during startup <pluginorder>`.\n762 \n763     .. versionchanged:: 7.0.0\n764         The ``start_path`` parameter was added as a :class:`pathlib.Path`\n765         equivalent of the ``startdir`` parameter. The ``startdir`` parameter\n766         has been deprecated.\n767     \"\"\"\n768 \n769 \n770 def pytest_report_collectionfinish(\n771     config: \"Config\",\n772     start_path: Path,\n773     startdir: \"LEGACY_PATH\",\n774     items: Sequence[\"Item\"],\n775 ) -> Union[str, List[str]]:\n776     \"\"\"Return a string or list of strings to be displayed after collection\n777     has finished successfully.\n778 \n779     These strings will be displayed after the standard \"collected X items\" message.\n780 \n781     .. versionadded:: 3.2\n782 \n783     :param config: The pytest config object.\n784     :param start_path: The starting dir.\n785     :param startdir: The starting dir (deprecated).\n786     :param items: List of pytest items that are going to be executed; this list should not be modified.\n787 \n788     .. note::\n789 \n790         Lines returned by a plugin are displayed before those of plugins which\n791         ran before it.\n792         If you want to have your line(s) displayed first, use\n793         :ref:`trylast=True <plugin-hookorder>`.\n794 \n795     .. versionchanged:: 7.0.0\n796         The ``start_path`` parameter was added as a :class:`pathlib.Path`\n797         equivalent of the ``startdir`` parameter. The ``startdir`` parameter\n798         has been deprecated.\n799     \"\"\"\n800 \n801 \n802 @hookspec(firstresult=True)\n803 def pytest_report_teststatus(\n804     report: Union[\"CollectReport\", \"TestReport\"], config: \"Config\"\n805 ) -> Tuple[str, str, Union[str, Mapping[str, bool]]]:\n806     \"\"\"Return result-category, shortletter and verbose word for status\n807     reporting.\n808 \n809     The result-category is a category in which to count the result, for\n810     example \"passed\", \"skipped\", \"error\" or the empty string.\n811 \n812     The shortletter is shown as testing progresses, for example \".\", \"s\",\n813     \"E\" or the empty string.\n814 \n815     The verbose word is shown as testing progresses in verbose mode, for\n816     example \"PASSED\", \"SKIPPED\", \"ERROR\" or the empty string.\n817 \n818     pytest may style these implicitly according to the report outcome.\n819     To provide explicit styling, return a tuple for the verbose word,\n820     for example ``\"rerun\", \"R\", (\"RERUN\", {\"yellow\": True})``.\n821 \n822     :param report: The report object whose status is to be returned.\n823     :param config: The pytest config object.\n824     :returns: The test status.\n825 \n826     Stops at first non-None result, see :ref:`firstresult`.\n827     \"\"\"\n828 \n829 \n830 def pytest_terminal_summary(\n831     terminalreporter: \"TerminalReporter\",\n832     exitstatus: \"ExitCode\",\n833     config: \"Config\",\n834 ) -> None:\n835     \"\"\"Add a section to terminal summary reporting.\n836 \n837     :param terminalreporter: The internal terminal reporter object.\n838     :param exitstatus: The exit status that will be reported back to the OS.\n839     :param config: The pytest config object.\n840 \n841     .. versionadded:: 4.2\n842         The ``config`` parameter.\n843     \"\"\"\n844 \n845 \n846 @hookspec(historic=True)\n847 def pytest_warning_recorded(\n848     warning_message: \"warnings.WarningMessage\",\n849     when: \"Literal['config', 'collect', 'runtest']\",\n850     nodeid: str,\n851     location: Optional[Tuple[str, int, str]],\n852 ) -> None:\n853     \"\"\"Process a warning captured by the internal pytest warnings plugin.\n854 \n855     :param warning_message:\n856         The captured warning. This is the same object produced by :py:func:`warnings.catch_warnings`, and contains\n857         the same attributes as the parameters of :py:func:`warnings.showwarning`.\n858 \n859     :param when:\n860         Indicates when the warning was captured. Possible values:\n861 \n862         * ``\"config\"``: during pytest configuration/initialization stage.\n863         * ``\"collect\"``: during test collection.\n864         * ``\"runtest\"``: during test execution.\n865 \n866     :param nodeid:\n867         Full id of the item.\n868 \n869     :param location:\n870         When available, holds information about the execution context of the captured\n871         warning (filename, linenumber, function). ``function`` evaluates to <module>\n872         when the execution context is at the module level.\n873 \n874     .. versionadded:: 6.0\n875     \"\"\"\n876 \n877 \n878 # -------------------------------------------------------------------------\n879 # Hooks for influencing skipping\n880 # -------------------------------------------------------------------------\n881 \n882 \n883 def pytest_markeval_namespace(config: \"Config\") -> Dict[str, Any]:\n884     \"\"\"Called when constructing the globals dictionary used for\n885     evaluating string conditions in xfail/skipif markers.\n886 \n887     This is useful when the condition for a marker requires\n888     objects that are expensive or impossible to obtain during\n889     collection time, which is required by normal boolean\n890     conditions.\n891 \n892     .. versionadded:: 6.2\n893 \n894     :param config: The pytest config object.\n895     :returns: A dictionary of additional globals to add.\n896     \"\"\"\n897 \n898 \n899 # -------------------------------------------------------------------------\n900 # error handling and internal debugging hooks\n901 # -------------------------------------------------------------------------\n902 \n903 \n904 def pytest_internalerror(\n905     excrepr: \"ExceptionRepr\",\n906     excinfo: \"ExceptionInfo[BaseException]\",\n907 ) -> Optional[bool]:\n908     \"\"\"Called for internal errors.\n909 \n910     Return True to suppress the fallback handling of printing an\n911     INTERNALERROR message directly to sys.stderr.\n912 \n913     :param excrepr: The exception repr object.\n914     :param excinfo: The exception info.\n915     \"\"\"\n916 \n917 \n918 def pytest_keyboard_interrupt(\n919     excinfo: \"ExceptionInfo[Union[KeyboardInterrupt, Exit]]\",\n920 ) -> None:\n921     \"\"\"Called for keyboard interrupt.\n922 \n923     :param excinfo: The exception info.\n924     \"\"\"\n925 \n926 \n927 def pytest_exception_interact(\n928     node: Union[\"Item\", \"Collector\"],\n929     call: \"CallInfo[Any]\",\n930     report: Union[\"CollectReport\", \"TestReport\"],\n931 ) -> None:\n932     \"\"\"Called when an exception was raised which can potentially be\n933     interactively handled.\n934 \n935     May be called during collection (see :hook:`pytest_make_collect_report`),\n936     in which case ``report`` is a :class:`CollectReport`.\n937 \n938     May be called during runtest of an item (see :hook:`pytest_runtest_protocol`),\n939     in which case ``report`` is a :class:`TestReport`.\n940 \n941     This hook is not called if the exception that was raised is an internal\n942     exception like ``skip.Exception``.\n943 \n944     :param node:\n945         The item or collector.\n946     :param call:\n947         The call information. Contains the exception.\n948     :param report:\n949         The collection or test report.\n950     \"\"\"\n951 \n952 \n953 def pytest_enter_pdb(config: \"Config\", pdb: \"pdb.Pdb\") -> None:\n954     \"\"\"Called upon pdb.set_trace().\n955 \n956     Can be used by plugins to take special action just before the python\n957     debugger enters interactive mode.\n958 \n959     :param config: The pytest config object.\n960     :param pdb: The Pdb instance.\n961     \"\"\"\n962 \n963 \n964 def pytest_leave_pdb(config: \"Config\", pdb: \"pdb.Pdb\") -> None:\n965     \"\"\"Called when leaving pdb (e.g. with continue after pdb.set_trace()).\n966 \n967     Can be used by plugins to take special action just after the python\n968     debugger leaves interactive mode.\n969 \n970     :param config: The pytest config object.\n971     :param pdb: The Pdb instance.\n972     \"\"\"\n",
        "intended_behavior": "This file likely defines the `pytest_configure` hookspec or related mechanisms. To resolve the issue, the code that triggers the `PytestDeprecationWarning` for old-style `hookimpl` usage within this file (or within the system that processes these hookspecs) should be enhanced. It should not only check for and warn about deprecated usage but also include information about the source of the deprecation (i.e., the plugin or file defining the deprecated hook). This enhancement might involve capturing the `__file__` attribute of the function or module when the `hookimpl` is registered and including that information in the warning message. Preserving Existing Functionality: The update should maintain all existing functionality surrounding hook registration and warning issuance. The primary change is to augment the warning message with location information, without affecting the registration or execution of hooks themselves."
    },
    {
        "rel_file_path": "src/_pytest/config/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/config/__init__.py",
        "start": 1,
        "end": 1743,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Command line options, ini-file and conftest.py processing.\"\"\"\n2 import argparse\n3 import collections.abc\n4 import copy\n5 import enum\n6 import glob\n7 import inspect\n8 import os\n9 import re\n10 import shlex\n11 import sys\n12 import types\n13 import warnings\n14 from functools import lru_cache\n15 from pathlib import Path\n16 from textwrap import dedent\n17 from types import FunctionType\n18 from types import TracebackType\n19 from typing import Any\n20 from typing import Callable\n21 from typing import cast\n22 from typing import Dict\n23 from typing import Generator\n24 from typing import IO\n25 from typing import Iterable\n26 from typing import Iterator\n27 from typing import List\n28 from typing import Optional\n29 from typing import Sequence\n30 from typing import Set\n31 from typing import TextIO\n32 from typing import Tuple\n33 from typing import Type\n34 from typing import TYPE_CHECKING\n35 from typing import Union\n36 \n37 import attr\n38 from pluggy import HookimplMarker\n39 from pluggy import HookspecMarker\n40 from pluggy import PluginManager\n41 \n42 import _pytest._code\n43 import _pytest.deprecated\n44 import _pytest.hookspec\n45 from .exceptions import PrintHelp as PrintHelp\n46 from .exceptions import UsageError as UsageError\n47 from .findpaths import determine_setup\n48 from _pytest._code import ExceptionInfo\n49 from _pytest._code import filter_traceback\n50 from _pytest._io import TerminalWriter\n51 from _pytest.compat import final\n52 from _pytest.compat import importlib_metadata\n53 from _pytest.outcomes import fail\n54 from _pytest.outcomes import Skipped\n55 from _pytest.pathlib import absolutepath\n56 from _pytest.pathlib import bestrelpath\n57 from _pytest.pathlib import import_path\n58 from _pytest.pathlib import ImportMode\n59 from _pytest.pathlib import resolve_package_path\n60 from _pytest.stash import Stash\n61 from _pytest.warning_types import PytestConfigWarning\n62 from _pytest.warning_types import warn_explicit_for\n63 \n64 if TYPE_CHECKING:\n65 \n66     from _pytest._code.code import _TracebackStyle\n67     from _pytest.terminal import TerminalReporter\n68     from .argparsing import Argument\n69 \n70 \n71 _PluggyPlugin = object\n72 \"\"\"A type to represent plugin objects.\n73 \n74 Plugins can be any namespace, so we can't narrow it down much, but we use an\n75 alias to make the intent clear.\n76 \n77 Ideally this type would be provided by pluggy itself.\n78 \"\"\"\n79 \n80 \n81 hookimpl = HookimplMarker(\"pytest\")\n82 hookspec = HookspecMarker(\"pytest\")\n83 \n84 \n85 @final\n86 class ExitCode(enum.IntEnum):\n87     \"\"\"Encodes the valid exit codes by pytest.\n88 \n89     Currently users and plugins may supply other exit codes as well.\n90 \n91     .. versionadded:: 5.0\n92     \"\"\"\n93 \n94     #: Tests passed.\n95     OK = 0\n96     #: Tests failed.\n97     TESTS_FAILED = 1\n98     #: pytest was interrupted.\n99     INTERRUPTED = 2\n100     #: An internal error got in the way.\n101     INTERNAL_ERROR = 3\n102     #: pytest was misused.\n103     USAGE_ERROR = 4\n104     #: pytest couldn't find tests.\n105     NO_TESTS_COLLECTED = 5\n106 \n107 \n108 class ConftestImportFailure(Exception):\n109     def __init__(\n110         self,\n111         path: Path,\n112         excinfo: Tuple[Type[Exception], Exception, TracebackType],\n113     ) -> None:\n114         super().__init__(path, excinfo)\n115         self.path = path\n116         self.excinfo = excinfo\n117 \n118     def __str__(self) -> str:\n119         return \"{}: {} (from {})\".format(\n120             self.excinfo[0].__name__, self.excinfo[1], self.path\n121         )\n122 \n123 \n124 def filter_traceback_for_conftest_import_failure(\n125     entry: _pytest._code.TracebackEntry,\n126 ) -> bool:\n127     \"\"\"Filter tracebacks entries which point to pytest internals or importlib.\n128 \n129     Make a special case for importlib because we use it to import test modules and conftest files\n130     in _pytest.pathlib.import_path.\n131     \"\"\"\n132     return filter_traceback(entry) and \"importlib\" not in str(entry.path).split(os.sep)\n133 \n134 \n135 def main(\n136     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n137     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n138 ) -> Union[int, ExitCode]:\n139     \"\"\"Perform an in-process test run.\n140 \n141     :param args: List of command line arguments.\n142     :param plugins: List of plugin objects to be auto-registered during initialization.\n143 \n144     :returns: An exit code.\n145     \"\"\"\n146     try:\n147         try:\n148             config = _prepareconfig(args, plugins)\n149         except ConftestImportFailure as e:\n150             exc_info = ExceptionInfo.from_exc_info(e.excinfo)\n151             tw = TerminalWriter(sys.stderr)\n152             tw.line(f\"ImportError while loading conftest '{e.path}'.\", red=True)\n153             exc_info.traceback = exc_info.traceback.filter(\n154                 filter_traceback_for_conftest_import_failure\n155             )\n156             exc_repr = (\n157                 exc_info.getrepr(style=\"short\", chain=False)\n158                 if exc_info.traceback\n159                 else exc_info.exconly()\n160             )\n161             formatted_tb = str(exc_repr)\n162             for line in formatted_tb.splitlines():\n163                 tw.line(line.rstrip(), red=True)\n164             return ExitCode.USAGE_ERROR\n165         else:\n166             try:\n167                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\n168                     config=config\n169                 )\n170                 try:\n171                     return ExitCode(ret)\n172                 except ValueError:\n173                     return ret\n174             finally:\n175                 config._ensure_unconfigure()\n176     except UsageError as e:\n177         tw = TerminalWriter(sys.stderr)\n178         for msg in e.args:\n179             tw.line(f\"ERROR: {msg}\\n\", red=True)\n180         return ExitCode.USAGE_ERROR\n181 \n182 \n183 def console_main() -> int:\n184     \"\"\"The CLI entry point of pytest.\n185 \n186     This function is not meant for programmable use; use `main()` instead.\n187     \"\"\"\n188     # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n189     try:\n190         code = main()\n191         sys.stdout.flush()\n192         return code\n193     except BrokenPipeError:\n194         # Python flushes standard streams on exit; redirect remaining output\n195         # to devnull to avoid another BrokenPipeError at shutdown\n196         devnull = os.open(os.devnull, os.O_WRONLY)\n197         os.dup2(devnull, sys.stdout.fileno())\n198         return 1  # Python exits with error code 1 on EPIPE\n199 \n200 \n201 class cmdline:  # compatibility namespace\n202     main = staticmethod(main)\n203 \n204 \n205 def filename_arg(path: str, optname: str) -> str:\n206     \"\"\"Argparse type validator for filename arguments.\n207 \n208     :path: Path of filename.\n209     :optname: Name of the option.\n210     \"\"\"\n211     if os.path.isdir(path):\n212         raise UsageError(f\"{optname} must be a filename, given: {path}\")\n213     return path\n214 \n215 \n216 def directory_arg(path: str, optname: str) -> str:\n217     \"\"\"Argparse type validator for directory arguments.\n218 \n219     :path: Path of directory.\n220     :optname: Name of the option.\n221     \"\"\"\n222     if not os.path.isdir(path):\n223         raise UsageError(f\"{optname} must be a directory, given: {path}\")\n224     return path\n225 \n226 \n227 # Plugins that cannot be disabled via \"-p no:X\" currently.\n228 essential_plugins = (\n229     \"mark\",\n230     \"main\",\n231     \"runner\",\n232     \"fixtures\",\n233     \"helpconfig\",  # Provides -p.\n234 )\n235 \n236 default_plugins = essential_plugins + (\n237     \"python\",\n238     \"terminal\",\n239     \"debugging\",\n240     \"unittest\",\n241     \"capture\",\n242     \"skipping\",\n243     \"legacypath\",\n244     \"tmpdir\",\n245     \"monkeypatch\",\n246     \"recwarn\",\n247     \"pastebin\",\n248     \"nose\",\n249     \"assertion\",\n250     \"junitxml\",\n251     \"doctest\",\n252     \"cacheprovider\",\n253     \"freeze_support\",\n254     \"setuponly\",\n255     \"setupplan\",\n256     \"stepwise\",\n257     \"warnings\",\n258     \"logging\",\n259     \"reports\",\n260     \"python_path\",\n261     *([\"unraisableexception\", \"threadexception\"] if sys.version_info >= (3, 8) else []),\n262     \"faulthandler\",\n263 )\n264 \n265 builtin_plugins = set(default_plugins)\n266 builtin_plugins.add(\"pytester\")\n267 builtin_plugins.add(\"pytester_assertions\")\n268 \n269 \n270 def get_config(\n271     args: Optional[List[str]] = None,\n272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n273 ) -> \"Config\":\n274     # subsequent calls to main will create a fresh instance\n275     pluginmanager = PytestPluginManager()\n276     config = Config(\n277         pluginmanager,\n278         invocation_params=Config.InvocationParams(\n279             args=args or (),\n280             plugins=plugins,\n281             dir=Path.cwd(),\n282         ),\n283     )\n284 \n285     if args is not None:\n286         # Handle any \"-p no:plugin\" args.\n287         pluginmanager.consider_preparse(args, exclude_only=True)\n288 \n289     for spec in default_plugins:\n290         pluginmanager.import_plugin(spec)\n291 \n292     return config\n293 \n294 \n295 def get_plugin_manager() -> \"PytestPluginManager\":\n296     \"\"\"Obtain a new instance of the\n297     :py:class:`pytest.PytestPluginManager`, with default plugins\n298     already loaded.\n299 \n300     This function can be used by integration with other tools, like hooking\n301     into pytest to run tests into an IDE.\n302     \"\"\"\n303     return get_config().pluginmanager\n304 \n305 \n306 def _prepareconfig(\n307     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n309 ) -> \"Config\":\n310     if args is None:\n311         args = sys.argv[1:]\n312     elif isinstance(args, os.PathLike):\n313         args = [os.fspath(args)]\n314     elif not isinstance(args, list):\n315         msg = (  # type:ignore[unreachable]\n316             \"`args` parameter expected to be a list of strings, got: {!r} (type: {})\"\n317         )\n318         raise TypeError(msg.format(args, type(args)))\n319 \n320     config = get_config(args, plugins)\n321     pluginmanager = config.pluginmanager\n322     try:\n323         if plugins:\n324             for plugin in plugins:\n325                 if isinstance(plugin, str):\n326                     pluginmanager.consider_pluginarg(plugin)\n327                 else:\n328                     pluginmanager.register(plugin)\n329         config = pluginmanager.hook.pytest_cmdline_parse(\n330             pluginmanager=pluginmanager, args=args\n331         )\n332         return config\n333     except BaseException:\n334         config._ensure_unconfigure()\n335         raise\n336 \n337 \n338 def _get_directory(path: Path) -> Path:\n339     \"\"\"Get the directory of a path - itself if already a directory.\"\"\"\n340     if path.is_file():\n341         return path.parent\n342     else:\n343         return path\n344 \n345 \n346 def _get_legacy_hook_marks(\n347     method: Any,\n348     hook_type: str,\n349     opt_names: Tuple[str, ...],\n350 ) -> Dict[str, bool]:\n351     if TYPE_CHECKING:\n352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias\n353         assert inspect.isroutine(method)\n354     known_marks: set[str] = {m.name for m in getattr(method, \"pytestmark\", [])}\n355     must_warn: list[str] = []\n356     opts: dict[str, bool] = {}\n357     for opt_name in opt_names:\n358         opt_attr = getattr(method, opt_name, AttributeError)\n359         if opt_attr is not AttributeError:\n360             must_warn.append(f\"{opt_name}={opt_attr}\")\n361             opts[opt_name] = True\n362         elif opt_name in known_marks:\n363             must_warn.append(f\"{opt_name}=True\")\n364             opts[opt_name] = True\n365         else:\n366             opts[opt_name] = False\n367     if must_warn:\n368         hook_opts = \", \".join(must_warn)\n369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(\n370             type=hook_type,\n371             fullname=method.__qualname__,\n372             hook_opts=hook_opts,\n373         )\n374         warn_explicit_for(cast(FunctionType, method), message)\n375     return opts\n376 \n377 \n378 @final\n379 class PytestPluginManager(PluginManager):\n380     \"\"\"A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n381     additional pytest-specific functionality:\n382 \n383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n384       ``pytest_plugins`` global variables found in plugins being loaded.\n385     * ``conftest.py`` loading during start-up.\n386     \"\"\"\n387 \n388     def __init__(self) -> None:\n389         import _pytest.assertion\n390 \n391         super().__init__(\"pytest\")\n392 \n393         # -- State related to local conftest plugins.\n394         # All loaded conftest modules.\n395         self._conftest_plugins: Set[types.ModuleType] = set()\n396         # All conftest modules applicable for a directory.\n397         # This includes the directory's own conftest modules as well\n398         # as those of its parent directories.\n399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n400         # Cutoff directory above which conftests are no longer discovered.\n401         self._confcutdir: Optional[Path] = None\n402         # If set, conftest loading is skipped.\n403         self._noconftest = False\n404 \n405         # _getconftestmodules()'s call to _get_directory() causes a stat\n406         # storm when it's called potentially thousands of times in a test\n407         # session (#9478), often with the same path, so cache it.\n408         self._get_directory = lru_cache(256)(_get_directory)\n409 \n410         self._duplicatepaths: Set[Path] = set()\n411 \n412         # plugins that were explicitly skipped with pytest.skip\n413         # list of (module name, skip reason)\n414         # previously we would issue a warning when a plugin was skipped, but\n415         # since we refactored warnings as first citizens of Config, they are\n416         # just stored here to be used later.\n417         self.skipped_plugins: List[Tuple[str, str]] = []\n418 \n419         self.add_hookspecs(_pytest.hookspec)\n420         self.register(self)\n421         if os.environ.get(\"PYTEST_DEBUG\"):\n422             err: IO[str] = sys.stderr\n423             encoding: str = getattr(err, \"encoding\", \"utf8\")\n424             try:\n425                 err = open(\n426                     os.dup(err.fileno()),\n427                     mode=err.mode,\n428                     buffering=1,\n429                     encoding=encoding,\n430                 )\n431             except Exception:\n432                 pass\n433             self.trace.root.setwriter(err.write)\n434             self.enable_tracing()\n435 \n436         # Config._consider_importhook will set a real object if required.\n437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n438         # Used to know when we are importing conftests after the pytest_configure stage.\n439         self._configured = False\n440 \n441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n442         # pytest hooks are always prefixed with \"pytest_\",\n443         # so we avoid accessing possibly non-readable attributes\n444         # (see issue #1073).\n445         if not name.startswith(\"pytest_\"):\n446             return\n447         # Ignore names which can not be hooks.\n448         if name == \"pytest_plugins\":\n449             return\n450 \n451         opts = super().parse_hookimpl_opts(plugin, name)\n452         if opts is not None:\n453             return opts\n454 \n455         method = getattr(plugin, name)\n456         # Consider only actual functions for hooks (#3775).\n457         if not inspect.isroutine(method):\n458             return\n459         # Collect unmarked hooks as long as they have the `pytest_' prefix.\n460         return _get_legacy_hook_marks(\n461             method, \"impl\", (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\")\n462         )\n463 \n464     def parse_hookspec_opts(self, module_or_class, name: str):\n465         opts = super().parse_hookspec_opts(module_or_class, name)\n466         if opts is None:\n467             method = getattr(module_or_class, name)\n468             if name.startswith(\"pytest_\"):\n469                 opts = _get_legacy_hook_marks(\n470                     method,\n471                     \"spec\",\n472                     (\"firstresult\", \"historic\"),\n473                 )\n474         return opts\n475 \n476     def register(\n477         self, plugin: _PluggyPlugin, name: Optional[str] = None\n478     ) -> Optional[str]:\n479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n480             warnings.warn(\n481                 PytestConfigWarning(\n482                     \"{} plugin has been merged into the core, \"\n483                     \"please remove it from your requirements.\".format(\n484                         name.replace(\"_\", \"-\")\n485                     )\n486                 )\n487             )\n488             return None\n489         ret: Optional[str] = super().register(plugin, name)\n490         if ret:\n491             self.hook.pytest_plugin_registered.call_historic(\n492                 kwargs=dict(plugin=plugin, manager=self)\n493             )\n494 \n495             if isinstance(plugin, types.ModuleType):\n496                 self.consider_module(plugin)\n497         return ret\n498 \n499     def getplugin(self, name: str):\n500         # Support deprecated naming because plugins (xdist e.g.) use it.\n501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)\n502         return plugin\n503 \n504     def hasplugin(self, name: str) -> bool:\n505         \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n506         return bool(self.get_plugin(name))\n507 \n508     def pytest_configure(self, config: \"Config\") -> None:\n509         \"\"\":meta private:\"\"\"\n510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n511         # we should remove tryfirst/trylast as markers.\n512         config.addinivalue_line(\n513             \"markers\",\n514             \"tryfirst: mark a hook implementation function such that the \"\n515             \"plugin machinery will try to call it first/as early as possible.\",\n516         )\n517         config.addinivalue_line(\n518             \"markers\",\n519             \"trylast: mark a hook implementation function such that the \"\n520             \"plugin machinery will try to call it last/as late as possible.\",\n521         )\n522         self._configured = True\n523 \n524     #\n525     # Internal API for local conftest plugin handling.\n526     #\n527     def _set_initial_conftests(\n528         self, namespace: argparse.Namespace, rootpath: Path\n529     ) -> None:\n530         \"\"\"Load initial conftest files given a preparsed \"namespace\".\n531 \n532         As conftest files may add their own command line options which have\n533         arguments ('--my-opt somepath') we might get some false positives.\n534         All builtin and 3rd party plugins will have been loaded, however, so\n535         common options will not confuse our logic here.\n536         \"\"\"\n537         current = Path.cwd()\n538         self._confcutdir = (\n539             absolutepath(current / namespace.confcutdir)\n540             if namespace.confcutdir\n541             else None\n542         )\n543         self._noconftest = namespace.noconftest\n544         self._using_pyargs = namespace.pyargs\n545         testpaths = namespace.file_or_dir\n546         foundanchor = False\n547         for testpath in testpaths:\n548             path = str(testpath)\n549             # remove node-id syntax\n550             i = path.find(\"::\")\n551             if i != -1:\n552                 path = path[:i]\n553             anchor = absolutepath(current / path)\n554             if anchor.exists():  # we found some file object\n555                 self._try_load_conftest(anchor, namespace.importmode, rootpath)\n556                 foundanchor = True\n557         if not foundanchor:\n558             self._try_load_conftest(current, namespace.importmode, rootpath)\n559 \n560     def _is_in_confcutdir(self, path: Path) -> bool:\n561         \"\"\"Whether a path is within the confcutdir.\n562 \n563         When false, should not load conftest.\n564         \"\"\"\n565         if self._confcutdir is None:\n566             return True\n567         return path not in self._confcutdir.parents\n568 \n569     def _try_load_conftest(\n570         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path\n571     ) -> None:\n572         self._getconftestmodules(anchor, importmode, rootpath)\n573         # let's also consider test* subdirs\n574         if anchor.is_dir():\n575             for x in anchor.glob(\"test*\"):\n576                 if x.is_dir():\n577                     self._getconftestmodules(x, importmode, rootpath)\n578 \n579     def _getconftestmodules(\n580         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path\n581     ) -> Sequence[types.ModuleType]:\n582         if self._noconftest:\n583             return []\n584 \n585         directory = self._get_directory(path)\n586 \n587         # Optimization: avoid repeated searches in the same directory.\n588         # Assumes always called with same importmode and rootpath.\n589         existing_clist = self._dirpath2confmods.get(directory)\n590         if existing_clist is not None:\n591             return existing_clist\n592 \n593         # XXX these days we may rather want to use config.rootpath\n594         # and allow users to opt into looking into the rootdir parent\n595         # directories instead of requiring to specify confcutdir.\n596         clist = []\n597         for parent in reversed((directory, *directory.parents)):\n598             if self._is_in_confcutdir(parent):\n599                 conftestpath = parent / \"conftest.py\"\n600                 if conftestpath.is_file():\n601                     mod = self._importconftest(conftestpath, importmode, rootpath)\n602                     clist.append(mod)\n603         self._dirpath2confmods[directory] = clist\n604         return clist\n605 \n606     def _rget_with_confmod(\n607         self,\n608         name: str,\n609         path: Path,\n610         importmode: Union[str, ImportMode],\n611         rootpath: Path,\n612     ) -> Tuple[types.ModuleType, Any]:\n613         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)\n614         for mod in reversed(modules):\n615             try:\n616                 return mod, getattr(mod, name)\n617             except AttributeError:\n618                 continue\n619         raise KeyError(name)\n620 \n621     def _importconftest(\n622         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path\n623     ) -> types.ModuleType:\n624         existing = self.get_plugin(str(conftestpath))\n625         if existing is not None:\n626             return cast(types.ModuleType, existing)\n627 \n628         pkgpath = resolve_package_path(conftestpath)\n629         if pkgpath is None:\n630             _ensure_removed_sysmodule(conftestpath.stem)\n631 \n632         try:\n633             mod = import_path(conftestpath, mode=importmode, root=rootpath)\n634         except Exception as e:\n635             assert e.__traceback__ is not None\n636             exc_info = (type(e), e, e.__traceback__)\n637             raise ConftestImportFailure(conftestpath, exc_info) from e\n638 \n639         self._check_non_top_pytest_plugins(mod, conftestpath)\n640 \n641         self._conftest_plugins.add(mod)\n642         dirpath = conftestpath.parent\n643         if dirpath in self._dirpath2confmods:\n644             for path, mods in self._dirpath2confmods.items():\n645                 if dirpath in path.parents or path == dirpath:\n646                     assert mod not in mods\n647                     mods.append(mod)\n648         self.trace(f\"loading conftestmodule {mod!r}\")\n649         self.consider_conftest(mod)\n650         return mod\n651 \n652     def _check_non_top_pytest_plugins(\n653         self,\n654         mod: types.ModuleType,\n655         conftestpath: Path,\n656     ) -> None:\n657         if (\n658             hasattr(mod, \"pytest_plugins\")\n659             and self._configured\n660             and not self._using_pyargs\n661         ):\n662             msg = (\n663                 \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n664                 \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n665                 \"  {}\\n\"\n666                 \"Please move it to a top level conftest file at the rootdir:\\n\"\n667                 \"  {}\\n\"\n668                 \"For more information, visit:\\n\"\n669                 \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n670             )\n671             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)\n672 \n673     #\n674     # API for bootstrapping plugin loading\n675     #\n676     #\n677 \n678     def consider_preparse(\n679         self, args: Sequence[str], *, exclude_only: bool = False\n680     ) -> None:\n681         \"\"\":meta private:\"\"\"\n682         i = 0\n683         n = len(args)\n684         while i < n:\n685             opt = args[i]\n686             i += 1\n687             if isinstance(opt, str):\n688                 if opt == \"-p\":\n689                     try:\n690                         parg = args[i]\n691                     except IndexError:\n692                         return\n693                     i += 1\n694                 elif opt.startswith(\"-p\"):\n695                     parg = opt[2:]\n696                 else:\n697                     continue\n698                 if exclude_only and not parg.startswith(\"no:\"):\n699                     continue\n700                 self.consider_pluginarg(parg)\n701 \n702     def consider_pluginarg(self, arg: str) -> None:\n703         \"\"\":meta private:\"\"\"\n704         if arg.startswith(\"no:\"):\n705             name = arg[3:]\n706             if name in essential_plugins:\n707                 raise UsageError(\"plugin %s cannot be disabled\" % name)\n708 \n709             # PR #4304: remove stepwise if cacheprovider is blocked.\n710             if name == \"cacheprovider\":\n711                 self.set_blocked(\"stepwise\")\n712                 self.set_blocked(\"pytest_stepwise\")\n713 \n714             self.set_blocked(name)\n715             if not name.startswith(\"pytest_\"):\n716                 self.set_blocked(\"pytest_\" + name)\n717         else:\n718             name = arg\n719             # Unblock the plugin.  None indicates that it has been blocked.\n720             # There is no interface with pluggy for this.\n721             if self._name2plugin.get(name, -1) is None:\n722                 del self._name2plugin[name]\n723             if not name.startswith(\"pytest_\"):\n724                 if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n725                     del self._name2plugin[\"pytest_\" + name]\n726             self.import_plugin(arg, consider_entry_points=True)\n727 \n728     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:\n729         \"\"\":meta private:\"\"\"\n730         self.register(conftestmodule, name=conftestmodule.__file__)\n731 \n732     def consider_env(self) -> None:\n733         \"\"\":meta private:\"\"\"\n734         self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n735 \n736     def consider_module(self, mod: types.ModuleType) -> None:\n737         \"\"\":meta private:\"\"\"\n738         self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n739 \n740     def _import_plugin_specs(\n741         self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n742     ) -> None:\n743         plugins = _get_plugin_specs_as_list(spec)\n744         for import_spec in plugins:\n745             self.import_plugin(import_spec)\n746 \n747     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n748         \"\"\"Import a plugin with ``modname``.\n749 \n750         If ``consider_entry_points`` is True, entry point names are also\n751         considered to find a plugin.\n752         \"\"\"\n753         # Most often modname refers to builtin modules, e.g. \"pytester\",\n754         # \"terminal\" or \"capture\".  Those plugins are registered under their\n755         # basename for historic purposes but must be imported with the\n756         # _pytest prefix.\n757         assert isinstance(modname, str), (\n758             \"module name as text required, got %r\" % modname\n759         )\n760         if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n761             return\n762 \n763         importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n764         self.rewrite_hook.mark_rewrite(importspec)\n765 \n766         if consider_entry_points:\n767             loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n768             if loaded:\n769                 return\n770 \n771         try:\n772             __import__(importspec)\n773         except ImportError as e:\n774             raise ImportError(\n775                 f'Error importing plugin \"{modname}\": {e.args[0]}'\n776             ).with_traceback(e.__traceback__) from e\n777 \n778         except Skipped as e:\n779             self.skipped_plugins.append((modname, e.msg or \"\"))\n780         else:\n781             mod = sys.modules[importspec]\n782             self.register(mod, modname)\n783 \n784 \n785 def _get_plugin_specs_as_list(\n786     specs: Union[None, types.ModuleType, str, Sequence[str]]\n787 ) -> List[str]:\n788     \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n789     # None means empty.\n790     if specs is None:\n791         return []\n792     # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n793     if isinstance(specs, types.ModuleType):\n794         return []\n795     # Comma-separated list.\n796     if isinstance(specs, str):\n797         return specs.split(\",\") if specs else []\n798     # Direct specification.\n799     if isinstance(specs, collections.abc.Sequence):\n800         return list(specs)\n801     raise UsageError(\n802         \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n803         % specs\n804     )\n805 \n806 \n807 def _ensure_removed_sysmodule(modname: str) -> None:\n808     try:\n809         del sys.modules[modname]\n810     except KeyError:\n811         pass\n812 \n813 \n814 class Notset:\n815     def __repr__(self):\n816         return \"<NOTSET>\"\n817 \n818 \n819 notset = Notset()\n820 \n821 \n822 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:\n823     \"\"\"Given an iterable of file names in a source distribution, return the \"names\" that should\n824     be marked for assertion rewrite.\n825 \n826     For example the package \"pytest_mock/__init__.py\" should be added as \"pytest_mock\" in\n827     the assertion rewrite mechanism.\n828 \n829     This function has to deal with dist-info based distributions and egg based distributions\n830     (which are still very much in use for \"editable\" installs).\n831 \n832     Here are the file names as seen in a dist-info based distribution:\n833 \n834         pytest_mock/__init__.py\n835         pytest_mock/_version.py\n836         pytest_mock/plugin.py\n837         pytest_mock.egg-info/PKG-INFO\n838 \n839     Here are the file names as seen in an egg based distribution:\n840 \n841         src/pytest_mock/__init__.py\n842         src/pytest_mock/_version.py\n843         src/pytest_mock/plugin.py\n844         src/pytest_mock.egg-info/PKG-INFO\n845         LICENSE\n846         setup.py\n847 \n848     We have to take in account those two distribution flavors in order to determine which\n849     names should be considered for assertion rewriting.\n850 \n851     More information:\n852         https://github.com/pytest-dev/pytest-mock/issues/167\n853     \"\"\"\n854     package_files = list(package_files)\n855     seen_some = False\n856     for fn in package_files:\n857         is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n858         is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n859         if is_simple_module:\n860             module_name, _ = os.path.splitext(fn)\n861             # we ignore \"setup.py\" at the root of the distribution\n862             # as well as editable installation finder modules made by setuptools\n863             if module_name != \"setup\" and not module_name.startswith(\"__editable__\"):\n864                 seen_some = True\n865                 yield module_name\n866         elif is_package:\n867             package_name = os.path.dirname(fn)\n868             seen_some = True\n869             yield package_name\n870 \n871     if not seen_some:\n872         # At this point we did not find any packages or modules suitable for assertion\n873         # rewriting, so we try again by stripping the first path component (to account for\n874         # \"src\" based source trees for example).\n875         # This approach lets us have the common case continue to be fast, as egg-distributions\n876         # are rarer.\n877         new_package_files = []\n878         for fn in package_files:\n879             parts = fn.split(\"/\")\n880             new_fn = \"/\".join(parts[1:])\n881             if new_fn:\n882                 new_package_files.append(new_fn)\n883         if new_package_files:\n884             yield from _iter_rewritable_modules(new_package_files)\n885 \n886 \n887 def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:\n888     return tuple(args)\n889 \n890 \n891 @final\n892 class Config:\n893     \"\"\"Access to configuration values, pluginmanager and plugin hooks.\n894 \n895     :param PytestPluginManager pluginmanager:\n896         A pytest PluginManager.\n897 \n898     :param InvocationParams invocation_params:\n899         Object containing parameters regarding the :func:`pytest.main`\n900         invocation.\n901     \"\"\"\n902 \n903     @final\n904     @attr.s(frozen=True, auto_attribs=True)\n905     class InvocationParams:\n906         \"\"\"Holds parameters passed during :func:`pytest.main`.\n907 \n908         The object attributes are read-only.\n909 \n910         .. versionadded:: 5.1\n911 \n912         .. note::\n913 \n914             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n915             ini option are handled by pytest, not being included in the ``args`` attribute.\n916 \n917             Plugins accessing ``InvocationParams`` must be aware of that.\n918         \"\"\"\n919 \n920         args: Tuple[str, ...] = attr.ib(converter=_args_converter)\n921         \"\"\"The command-line arguments as passed to :func:`pytest.main`.\"\"\"\n922         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]\n923         \"\"\"Extra plugins, might be `None`.\"\"\"\n924         dir: Path\n925         \"\"\"The directory from which :func:`pytest.main` was invoked.\"\"\"\n926 \n927     class ArgsSource(enum.Enum):\n928         \"\"\"Indicates the source of the test arguments.\n929 \n930         .. versionadded:: 7.2\n931         \"\"\"\n932 \n933         #: Command line arguments.\n934         ARGS = enum.auto()\n935         #: Invocation directory.\n936         INCOVATION_DIR = enum.auto()\n937         #: 'testpaths' configuration value.\n938         TESTPATHS = enum.auto()\n939 \n940     def __init__(\n941         self,\n942         pluginmanager: PytestPluginManager,\n943         *,\n944         invocation_params: Optional[InvocationParams] = None,\n945     ) -> None:\n946         from .argparsing import Parser, FILE_OR_DIR\n947 \n948         if invocation_params is None:\n949             invocation_params = self.InvocationParams(\n950                 args=(), plugins=None, dir=Path.cwd()\n951             )\n952 \n953         self.option = argparse.Namespace()\n954         \"\"\"Access to command line option as attributes.\n955 \n956         :type: argparse.Namespace\n957         \"\"\"\n958 \n959         self.invocation_params = invocation_params\n960         \"\"\"The parameters with which pytest was invoked.\n961 \n962         :type: InvocationParams\n963         \"\"\"\n964 \n965         _a = FILE_OR_DIR\n966         self._parser = Parser(\n967             usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n968             processopt=self._processopt,\n969             _ispytest=True,\n970         )\n971         self.pluginmanager = pluginmanager\n972         \"\"\"The plugin manager handles plugin registration and hook invocation.\n973 \n974         :type: PytestPluginManager\n975         \"\"\"\n976 \n977         self.stash = Stash()\n978         \"\"\"A place where plugins can store information on the config for their\n979         own use.\n980 \n981         :type: Stash\n982         \"\"\"\n983         # Deprecated alias. Was never public. Can be removed in a few releases.\n984         self._store = self.stash\n985 \n986         from .compat import PathAwareHookProxy\n987 \n988         self.trace = self.pluginmanager.trace.root.get(\"config\")\n989         self.hook = PathAwareHookProxy(self.pluginmanager.hook)\n990         self._inicache: Dict[str, Any] = {}\n991         self._override_ini: Sequence[str] = ()\n992         self._opt2dest: Dict[str, str] = {}\n993         self._cleanup: List[Callable[[], None]] = []\n994         self.pluginmanager.register(self, \"pytestconfig\")\n995         self._configured = False\n996         self.hook.pytest_addoption.call_historic(\n997             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n998         )\n999 \n1000         if TYPE_CHECKING:\n1001             from _pytest.cacheprovider import Cache\n1002 \n1003             self.cache: Optional[Cache] = None\n1004 \n1005     @property\n1006     def rootpath(self) -> Path:\n1007         \"\"\"The path to the :ref:`rootdir <rootdir>`.\n1008 \n1009         :type: pathlib.Path\n1010 \n1011         .. versionadded:: 6.1\n1012         \"\"\"\n1013         return self._rootpath\n1014 \n1015     @property\n1016     def inipath(self) -> Optional[Path]:\n1017         \"\"\"The path to the :ref:`configfile <configfiles>`.\n1018 \n1019         :type: Optional[pathlib.Path]\n1020 \n1021         .. versionadded:: 6.1\n1022         \"\"\"\n1023         return self._inipath\n1024 \n1025     def add_cleanup(self, func: Callable[[], None]) -> None:\n1026         \"\"\"Add a function to be called when the config object gets out of\n1027         use (usually coinciding with pytest_unconfigure).\"\"\"\n1028         self._cleanup.append(func)\n1029 \n1030     def _do_configure(self) -> None:\n1031         assert not self._configured\n1032         self._configured = True\n1033         with warnings.catch_warnings():\n1034             warnings.simplefilter(\"default\")\n1035             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n1036 \n1037     def _ensure_unconfigure(self) -> None:\n1038         if self._configured:\n1039             self._configured = False\n1040             self.hook.pytest_unconfigure(config=self)\n1041             self.hook.pytest_configure._call_history = []\n1042         while self._cleanup:\n1043             fin = self._cleanup.pop()\n1044             fin()\n1045 \n1046     def get_terminal_writer(self) -> TerminalWriter:\n1047         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n1048             \"terminalreporter\"\n1049         )\n1050         return terminalreporter._tw\n1051 \n1052     def pytest_cmdline_parse(\n1053         self, pluginmanager: PytestPluginManager, args: List[str]\n1054     ) -> \"Config\":\n1055         try:\n1056             self.parse(args)\n1057         except UsageError:\n1058 \n1059             # Handle --version and --help here in a minimal fashion.\n1060             # This gets done via helpconfig normally, but its\n1061             # pytest_cmdline_main is not called in case of errors.\n1062             if getattr(self.option, \"version\", False) or \"--version\" in args:\n1063                 from _pytest.helpconfig import showversion\n1064 \n1065                 showversion(self)\n1066             elif (\n1067                 getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n1068             ):\n1069                 self._parser._getparser().print_help()\n1070                 sys.stdout.write(\n1071                     \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n1072                 )\n1073 \n1074             raise\n1075 \n1076         return self\n1077 \n1078     def notify_exception(\n1079         self,\n1080         excinfo: ExceptionInfo[BaseException],\n1081         option: Optional[argparse.Namespace] = None,\n1082     ) -> None:\n1083         if option and getattr(option, \"fulltrace\", False):\n1084             style: _TracebackStyle = \"long\"\n1085         else:\n1086             style = \"native\"\n1087         excrepr = excinfo.getrepr(\n1088             funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n1089         )\n1090         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n1091         if not any(res):\n1092             for line in str(excrepr).split(\"\\n\"):\n1093                 sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n1094                 sys.stderr.flush()\n1095 \n1096     def cwd_relative_nodeid(self, nodeid: str) -> str:\n1097         # nodeid's are relative to the rootpath, compute relative to cwd.\n1098         if self.invocation_params.dir != self.rootpath:\n1099             fullpath = self.rootpath / nodeid\n1100             nodeid = bestrelpath(self.invocation_params.dir, fullpath)\n1101         return nodeid\n1102 \n1103     @classmethod\n1104     def fromdictargs(cls, option_dict, args) -> \"Config\":\n1105         \"\"\"Constructor usable for subprocesses.\"\"\"\n1106         config = get_config(args)\n1107         config.option.__dict__.update(option_dict)\n1108         config.parse(args, addopts=False)\n1109         for x in config.option.plugins:\n1110             config.pluginmanager.consider_pluginarg(x)\n1111         return config\n1112 \n1113     def _processopt(self, opt: \"Argument\") -> None:\n1114         for name in opt._short_opts + opt._long_opts:\n1115             self._opt2dest[name] = opt.dest\n1116 \n1117         if hasattr(opt, \"default\"):\n1118             if not hasattr(self.option, opt.dest):\n1119                 setattr(self.option, opt.dest, opt.default)\n1120 \n1121     @hookimpl(trylast=True)\n1122     def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n1123         self.pluginmanager._set_initial_conftests(\n1124             early_config.known_args_namespace, rootpath=early_config.rootpath\n1125         )\n1126 \n1127     def _initini(self, args: Sequence[str]) -> None:\n1128         ns, unknown_args = self._parser.parse_known_and_unknown_args(\n1129             args, namespace=copy.copy(self.option)\n1130         )\n1131         rootpath, inipath, inicfg = determine_setup(\n1132             ns.inifilename,\n1133             ns.file_or_dir + unknown_args,\n1134             rootdir_cmd_arg=ns.rootdir or None,\n1135             config=self,\n1136         )\n1137         self._rootpath = rootpath\n1138         self._inipath = inipath\n1139         self.inicfg = inicfg\n1140         self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n1141         self._parser.extra_info[\"inifile\"] = str(self.inipath)\n1142         self._parser.addini(\"addopts\", \"Extra command line options\", \"args\")\n1143         self._parser.addini(\"minversion\", \"Minimally required pytest version\")\n1144         self._parser.addini(\n1145             \"required_plugins\",\n1146             \"Plugins that must be present for pytest to run\",\n1147             type=\"args\",\n1148             default=[],\n1149         )\n1150         self._override_ini = ns.override_ini or ()\n1151 \n1152     def _consider_importhook(self, args: Sequence[str]) -> None:\n1153         \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n1154 \n1155         Needs to parse the --assert=<mode> option from the commandline\n1156         and find all the installed plugins to mark them for rewriting\n1157         by the importhook.\n1158         \"\"\"\n1159         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n1160         mode = getattr(ns, \"assertmode\", \"plain\")\n1161         if mode == \"rewrite\":\n1162             import _pytest.assertion\n1163 \n1164             try:\n1165                 hook = _pytest.assertion.install_importhook(self)\n1166             except SystemError:\n1167                 mode = \"plain\"\n1168             else:\n1169                 self._mark_plugins_for_rewrite(hook)\n1170         self._warn_about_missing_assertion(mode)\n1171 \n1172     def _mark_plugins_for_rewrite(self, hook) -> None:\n1173         \"\"\"Given an importhook, mark for rewrite any top-level\n1174         modules or packages in the distribution package for\n1175         all pytest plugins.\"\"\"\n1176         self.pluginmanager.rewrite_hook = hook\n1177 \n1178         if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1179             # We don't autoload from setuptools entry points, no need to continue.\n1180             return\n1181 \n1182         package_files = (\n1183             str(file)\n1184             for dist in importlib_metadata.distributions()\n1185             if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n1186             for file in dist.files or []\n1187         )\n1188 \n1189         for name in _iter_rewritable_modules(package_files):\n1190             hook.mark_rewrite(name)\n1191 \n1192     def _validate_args(self, args: List[str], via: str) -> List[str]:\n1193         \"\"\"Validate known args.\"\"\"\n1194         self._parser._config_source_hint = via  # type: ignore\n1195         try:\n1196             self._parser.parse_known_and_unknown_args(\n1197                 args, namespace=copy.copy(self.option)\n1198             )\n1199         finally:\n1200             del self._parser._config_source_hint  # type: ignore\n1201 \n1202         return args\n1203 \n1204     def _preparse(self, args: List[str], addopts: bool = True) -> None:\n1205         if addopts:\n1206             env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n1207             if len(env_addopts):\n1208                 args[:] = (\n1209                     self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n1210                     + args\n1211                 )\n1212         self._initini(args)\n1213         if addopts:\n1214             args[:] = (\n1215                 self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n1216             )\n1217 \n1218         self.known_args_namespace = self._parser.parse_known_args(\n1219             args, namespace=copy.copy(self.option)\n1220         )\n1221         self._checkversion()\n1222         self._consider_importhook(args)\n1223         self.pluginmanager.consider_preparse(args, exclude_only=False)\n1224         if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1225             # Don't autoload from setuptools entry point. Only explicitly specified\n1226             # plugins are going to be loaded.\n1227             self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n1228         self.pluginmanager.consider_env()\n1229 \n1230         self.known_args_namespace = self._parser.parse_known_args(\n1231             args, namespace=copy.copy(self.known_args_namespace)\n1232         )\n1233 \n1234         self._validate_plugins()\n1235         self._warn_about_skipped_plugins()\n1236 \n1237         if self.known_args_namespace.strict:\n1238             self.issue_config_time_warning(\n1239                 _pytest.deprecated.STRICT_OPTION, stacklevel=2\n1240             )\n1241 \n1242         if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n1243             confcutdir = str(self.inipath.parent)\n1244             self.known_args_namespace.confcutdir = confcutdir\n1245         try:\n1246             self.hook.pytest_load_initial_conftests(\n1247                 early_config=self, args=args, parser=self._parser\n1248             )\n1249         except ConftestImportFailure as e:\n1250             if self.known_args_namespace.help or self.known_args_namespace.version:\n1251                 # we don't want to prevent --help/--version to work\n1252                 # so just let is pass and print a warning at the end\n1253                 self.issue_config_time_warning(\n1254                     PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n1255                     stacklevel=2,\n1256                 )\n1257             else:\n1258                 raise\n1259 \n1260     @hookimpl(hookwrapper=True)\n1261     def pytest_collection(self) -> Generator[None, None, None]:\n1262         # Validate invalid ini keys after collection is done so we take in account\n1263         # options added by late-loading conftest files.\n1264         yield\n1265         self._validate_config_options()\n1266 \n1267     def _checkversion(self) -> None:\n1268         import pytest\n1269 \n1270         minver = self.inicfg.get(\"minversion\", None)\n1271         if minver:\n1272             # Imported lazily to improve start-up time.\n1273             from packaging.version import Version\n1274 \n1275             if not isinstance(minver, str):\n1276                 raise pytest.UsageError(\n1277                     \"%s: 'minversion' must be a single value\" % self.inipath\n1278                 )\n1279 \n1280             if Version(minver) > Version(pytest.__version__):\n1281                 raise pytest.UsageError(\n1282                     \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n1283                     % (\n1284                         self.inipath,\n1285                         minver,\n1286                         pytest.__version__,\n1287                     )\n1288                 )\n1289 \n1290     def _validate_config_options(self) -> None:\n1291         for key in sorted(self._get_unknown_ini_keys()):\n1292             self._warn_or_fail_if_strict(f\"Unknown config option: {key}\\n\")\n1293 \n1294     def _validate_plugins(self) -> None:\n1295         required_plugins = sorted(self.getini(\"required_plugins\"))\n1296         if not required_plugins:\n1297             return\n1298 \n1299         # Imported lazily to improve start-up time.\n1300         from packaging.version import Version\n1301         from packaging.requirements import InvalidRequirement, Requirement\n1302 \n1303         plugin_info = self.pluginmanager.list_plugin_distinfo()\n1304         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n1305 \n1306         missing_plugins = []\n1307         for required_plugin in required_plugins:\n1308             try:\n1309                 req = Requirement(required_plugin)\n1310             except InvalidRequirement:\n1311                 missing_plugins.append(required_plugin)\n1312                 continue\n1313 \n1314             if req.name not in plugin_dist_info:\n1315                 missing_plugins.append(required_plugin)\n1316             elif not req.specifier.contains(\n1317                 Version(plugin_dist_info[req.name]), prereleases=True\n1318             ):\n1319                 missing_plugins.append(required_plugin)\n1320 \n1321         if missing_plugins:\n1322             raise UsageError(\n1323                 \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n1324             )\n1325 \n1326     def _warn_or_fail_if_strict(self, message: str) -> None:\n1327         if self.known_args_namespace.strict_config:\n1328             raise UsageError(message)\n1329 \n1330         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)\n1331 \n1332     def _get_unknown_ini_keys(self) -> List[str]:\n1333         parser_inicfg = self._parser._inidict\n1334         return [name for name in self.inicfg if name not in parser_inicfg]\n1335 \n1336     def parse(self, args: List[str], addopts: bool = True) -> None:\n1337         # Parse given cmdline arguments into this config object.\n1338         assert not hasattr(\n1339             self, \"args\"\n1340         ), \"can only parse cmdline args at most once per Config object\"\n1341         self.hook.pytest_addhooks.call_historic(\n1342             kwargs=dict(pluginmanager=self.pluginmanager)\n1343         )\n1344         self._preparse(args, addopts=addopts)\n1345         # XXX deprecated hook:\n1346         self.hook.pytest_cmdline_preparse(config=self, args=args)\n1347         self._parser.after_preparse = True  # type: ignore\n1348         try:\n1349             source = Config.ArgsSource.ARGS\n1350             args = self._parser.parse_setoption(\n1351                 args, self.option, namespace=self.option\n1352             )\n1353             if not args:\n1354                 if self.invocation_params.dir == self.rootpath:\n1355                     source = Config.ArgsSource.TESTPATHS\n1356                     testpaths: List[str] = self.getini(\"testpaths\")\n1357                     if self.known_args_namespace.pyargs:\n1358                         args = testpaths\n1359                     else:\n1360                         args = []\n1361                         for path in testpaths:\n1362                             args.extend(sorted(glob.iglob(path, recursive=True)))\n1363                 if not args:\n1364                     source = Config.ArgsSource.INCOVATION_DIR\n1365                     args = [str(self.invocation_params.dir)]\n1366             self.args = args\n1367             self.args_source = source\n1368         except PrintHelp:\n1369             pass\n1370 \n1371     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n1372         \"\"\"Issue and handle a warning during the \"configure\" stage.\n1373 \n1374         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n1375         function because it is not possible to have hookwrappers around ``pytest_configure``.\n1376 \n1377         This function is mainly intended for plugins that need to issue warnings during\n1378         ``pytest_configure`` (or similar stages).\n1379 \n1380         :param warning: The warning instance.\n1381         :param stacklevel: stacklevel forwarded to warnings.warn.\n1382         \"\"\"\n1383         if self.pluginmanager.is_blocked(\"warnings\"):\n1384             return\n1385 \n1386         cmdline_filters = self.known_args_namespace.pythonwarnings or []\n1387         config_filters = self.getini(\"filterwarnings\")\n1388 \n1389         with warnings.catch_warnings(record=True) as records:\n1390             warnings.simplefilter(\"always\", type(warning))\n1391             apply_warning_filters(config_filters, cmdline_filters)\n1392             warnings.warn(warning, stacklevel=stacklevel)\n1393 \n1394         if records:\n1395             frame = sys._getframe(stacklevel - 1)\n1396             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n1397             self.hook.pytest_warning_recorded.call_historic(\n1398                 kwargs=dict(\n1399                     warning_message=records[0],\n1400                     when=\"config\",\n1401                     nodeid=\"\",\n1402                     location=location,\n1403                 )\n1404             )\n1405 \n1406     def addinivalue_line(self, name: str, line: str) -> None:\n1407         \"\"\"Add a line to an ini-file option. The option must have been\n1408         declared but might not yet be set in which case the line becomes\n1409         the first line in its value.\"\"\"\n1410         x = self.getini(name)\n1411         assert isinstance(x, list)\n1412         x.append(line)  # modifies the cached list inline\n1413 \n1414     def getini(self, name: str):\n1415         \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n1416 \n1417         If the specified name hasn't been registered through a prior\n1418         :func:`parser.addini <pytest.Parser.addini>` call (usually from a\n1419         plugin), a ValueError is raised.\n1420         \"\"\"\n1421         try:\n1422             return self._inicache[name]\n1423         except KeyError:\n1424             self._inicache[name] = val = self._getini(name)\n1425             return val\n1426 \n1427     # Meant for easy monkeypatching by legacypath plugin.\n1428     # Can be inlined back (with no cover removed) once legacypath is gone.\n1429     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):\n1430         msg = f\"unknown configuration type: {type}\"\n1431         raise ValueError(msg, value)  # pragma: no cover\n1432 \n1433     def _getini(self, name: str):\n1434         try:\n1435             description, type, default = self._parser._inidict[name]\n1436         except KeyError as e:\n1437             raise ValueError(f\"unknown configuration value: {name!r}\") from e\n1438         override_value = self._get_override_ini_value(name)\n1439         if override_value is None:\n1440             try:\n1441                 value = self.inicfg[name]\n1442             except KeyError:\n1443                 if default is not None:\n1444                     return default\n1445                 if type is None:\n1446                     return \"\"\n1447                 return []\n1448         else:\n1449             value = override_value\n1450         # Coerce the values based on types.\n1451         #\n1452         # Note: some coercions are only required if we are reading from .ini files, because\n1453         # the file format doesn't contain type information, but when reading from toml we will\n1454         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n1455         # For example:\n1456         #\n1457         #   ini:\n1458         #     a_line_list = \"tests acceptance\"\n1459         #   in this case, we need to split the string to obtain a list of strings.\n1460         #\n1461         #   toml:\n1462         #     a_line_list = [\"tests\", \"acceptance\"]\n1463         #   in this case, we already have a list ready to use.\n1464         #\n1465         if type == \"paths\":\n1466             # TODO: This assert is probably not valid in all cases.\n1467             assert self.inipath is not None\n1468             dp = self.inipath.parent\n1469             input_values = shlex.split(value) if isinstance(value, str) else value\n1470             return [dp / x for x in input_values]\n1471         elif type == \"args\":\n1472             return shlex.split(value) if isinstance(value, str) else value\n1473         elif type == \"linelist\":\n1474             if isinstance(value, str):\n1475                 return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n1476             else:\n1477                 return value\n1478         elif type == \"bool\":\n1479             return _strtobool(str(value).strip())\n1480         elif type == \"string\":\n1481             return value\n1482         elif type is None:\n1483             return value\n1484         else:\n1485             return self._getini_unknown_type(name, type, value)\n1486 \n1487     def _getconftest_pathlist(\n1488         self, name: str, path: Path, rootpath: Path\n1489     ) -> Optional[List[Path]]:\n1490         try:\n1491             mod, relroots = self.pluginmanager._rget_with_confmod(\n1492                 name, path, self.getoption(\"importmode\"), rootpath\n1493             )\n1494         except KeyError:\n1495             return None\n1496         assert mod.__file__ is not None\n1497         modpath = Path(mod.__file__).parent\n1498         values: List[Path] = []\n1499         for relroot in relroots:\n1500             if isinstance(relroot, os.PathLike):\n1501                 relroot = Path(relroot)\n1502             else:\n1503                 relroot = relroot.replace(\"/\", os.sep)\n1504                 relroot = absolutepath(modpath / relroot)\n1505             values.append(relroot)\n1506         return values\n1507 \n1508     def _get_override_ini_value(self, name: str) -> Optional[str]:\n1509         value = None\n1510         # override_ini is a list of \"ini=value\" options.\n1511         # Always use the last item if multiple values are set for same ini-name,\n1512         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n1513         for ini_config in self._override_ini:\n1514             try:\n1515                 key, user_ini_value = ini_config.split(\"=\", 1)\n1516             except ValueError as e:\n1517                 raise UsageError(\n1518                     \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n1519                         ini_config\n1520                     )\n1521                 ) from e\n1522             else:\n1523                 if key == name:\n1524                     value = user_ini_value\n1525         return value\n1526 \n1527     def getoption(self, name: str, default=notset, skip: bool = False):\n1528         \"\"\"Return command line option value.\n1529 \n1530         :param name: Name of the option.  You may also specify\n1531             the literal ``--OPT`` option instead of the \"dest\" option name.\n1532         :param default: Default value if no option of that name exists.\n1533         :param skip: If True, raise pytest.skip if option does not exists\n1534             or has a None value.\n1535         \"\"\"\n1536         name = self._opt2dest.get(name, name)\n1537         try:\n1538             val = getattr(self.option, name)\n1539             if val is None and skip:\n1540                 raise AttributeError(name)\n1541             return val\n1542         except AttributeError as e:\n1543             if default is not notset:\n1544                 return default\n1545             if skip:\n1546                 import pytest\n1547 \n1548                 pytest.skip(f\"no {name!r} option found\")\n1549             raise ValueError(f\"no option named {name!r}\") from e\n1550 \n1551     def getvalue(self, name: str, path=None):\n1552         \"\"\"Deprecated, use getoption() instead.\"\"\"\n1553         return self.getoption(name)\n1554 \n1555     def getvalueorskip(self, name: str, path=None):\n1556         \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"\n1557         return self.getoption(name, skip=True)\n1558 \n1559     def _warn_about_missing_assertion(self, mode: str) -> None:\n1560         if not _assertion_supported():\n1561             if mode == \"plain\":\n1562                 warning_text = (\n1563                     \"ASSERTIONS ARE NOT EXECUTED\"\n1564                     \" and FAILING TESTS WILL PASS.  Are you\"\n1565                     \" using python -O?\"\n1566                 )\n1567             else:\n1568                 warning_text = (\n1569                     \"assertions not in test modules or\"\n1570                     \" plugins will be ignored\"\n1571                     \" because assert statements are not executed \"\n1572                     \"by the underlying Python interpreter \"\n1573                     \"(are you using python -O?)\\n\"\n1574                 )\n1575             self.issue_config_time_warning(\n1576                 PytestConfigWarning(warning_text),\n1577                 stacklevel=3,\n1578             )\n1579 \n1580     def _warn_about_skipped_plugins(self) -> None:\n1581         for module_name, msg in self.pluginmanager.skipped_plugins:\n1582             self.issue_config_time_warning(\n1583                 PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n1584                 stacklevel=2,\n1585             )\n1586 \n1587 \n1588 def _assertion_supported() -> bool:\n1589     try:\n1590         assert False\n1591     except AssertionError:\n1592         return True\n1593     else:\n1594         return False  # type: ignore[unreachable]\n1595 \n1596 \n1597 def create_terminal_writer(\n1598     config: Config, file: Optional[TextIO] = None\n1599 ) -> TerminalWriter:\n1600     \"\"\"Create a TerminalWriter instance configured according to the options\n1601     in the config object.\n1602 \n1603     Every code which requires a TerminalWriter object and has access to a\n1604     config object should use this function.\n1605     \"\"\"\n1606     tw = TerminalWriter(file=file)\n1607 \n1608     if config.option.color == \"yes\":\n1609         tw.hasmarkup = True\n1610     elif config.option.color == \"no\":\n1611         tw.hasmarkup = False\n1612 \n1613     if config.option.code_highlight == \"yes\":\n1614         tw.code_highlight = True\n1615     elif config.option.code_highlight == \"no\":\n1616         tw.code_highlight = False\n1617 \n1618     return tw\n1619 \n1620 \n1621 def _strtobool(val: str) -> bool:\n1622     \"\"\"Convert a string representation of truth to True or False.\n1623 \n1624     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n1625     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n1626     'val' is anything else.\n1627 \n1628     .. note:: Copied from distutils.util.\n1629     \"\"\"\n1630     val = val.lower()\n1631     if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n1632         return True\n1633     elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n1634         return False\n1635     else:\n1636         raise ValueError(f\"invalid truth value {val!r}\")\n1637 \n1638 \n1639 @lru_cache(maxsize=50)\n1640 def parse_warning_filter(\n1641     arg: str, *, escape: bool\n1642 ) -> Tuple[\"warnings._ActionKind\", str, Type[Warning], str, int]:\n1643     \"\"\"Parse a warnings filter string.\n1644 \n1645     This is copied from warnings._setoption with the following changes:\n1646 \n1647     * Does not apply the filter.\n1648     * Escaping is optional.\n1649     * Raises UsageError so we get nice error messages on failure.\n1650     \"\"\"\n1651     __tracebackhide__ = True\n1652     error_template = dedent(\n1653         f\"\"\"\\\n1654         while parsing the following warning configuration:\n1655 \n1656           {arg}\n1657 \n1658         This error occurred:\n1659 \n1660         {{error}}\n1661         \"\"\"\n1662     )\n1663 \n1664     parts = arg.split(\":\")\n1665     if len(parts) > 5:\n1666         doc_url = (\n1667             \"https://docs.python.org/3/library/warnings.html#describing-warning-filters\"\n1668         )\n1669         error = dedent(\n1670             f\"\"\"\\\n1671             Too many fields ({len(parts)}), expected at most 5 separated by colons:\n1672 \n1673               action:message:category:module:line\n1674 \n1675             For more information please consult: {doc_url}\n1676             \"\"\"\n1677         )\n1678         raise UsageError(error_template.format(error=error))\n1679 \n1680     while len(parts) < 5:\n1681         parts.append(\"\")\n1682     action_, message, category_, module, lineno_ = (s.strip() for s in parts)\n1683     try:\n1684         action: \"warnings._ActionKind\" = warnings._getaction(action_)  # type: ignore[attr-defined]\n1685     except warnings._OptionError as e:\n1686         raise UsageError(error_template.format(error=str(e)))\n1687     try:\n1688         category: Type[Warning] = _resolve_warning_category(category_)\n1689     except Exception:\n1690         exc_info = ExceptionInfo.from_current()\n1691         exception_text = exc_info.getrepr(style=\"native\")\n1692         raise UsageError(error_template.format(error=exception_text))\n1693     if message and escape:\n1694         message = re.escape(message)\n1695     if module and escape:\n1696         module = re.escape(module) + r\"\\Z\"\n1697     if lineno_:\n1698         try:\n1699             lineno = int(lineno_)\n1700             if lineno < 0:\n1701                 raise ValueError(\"number is negative\")\n1702         except ValueError as e:\n1703             raise UsageError(\n1704                 error_template.format(error=f\"invalid lineno {lineno_!r}: {e}\")\n1705             )\n1706     else:\n1707         lineno = 0\n1708     return action, message, category, module, lineno\n1709 \n1710 \n1711 def _resolve_warning_category(category: str) -> Type[Warning]:\n1712     \"\"\"\n1713     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)\n1714     propagate so we can get access to their tracebacks (#9218).\n1715     \"\"\"\n1716     __tracebackhide__ = True\n1717     if not category:\n1718         return Warning\n1719 \n1720     if \".\" not in category:\n1721         import builtins as m\n1722 \n1723         klass = category\n1724     else:\n1725         module, _, klass = category.rpartition(\".\")\n1726         m = __import__(module, None, None, [klass])\n1727     cat = getattr(m, klass)\n1728     if not issubclass(cat, Warning):\n1729         raise UsageError(f\"{cat} is not a Warning subclass\")\n1730     return cast(Type[Warning], cat)\n1731 \n1732 \n1733 def apply_warning_filters(\n1734     config_filters: Iterable[str], cmdline_filters: Iterable[str]\n1735 ) -> None:\n1736     \"\"\"Applies pytest-configured filters to the warnings module\"\"\"\n1737     # Filters should have this precedence: cmdline options, config.\n1738     # Filters should be applied in the inverse order of precedence.\n1739     for arg in config_filters:\n1740         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))\n1741 \n1742     for arg in cmdline_filters:\n1743         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))\n",
        "intended_behavior": "Since this file deals with the configuration of pytest, including the loading and registration of plugins, it's a plausible location where enhancements could be made to improve the issue at hand. Specifically, during the process where plugins are scanned for hook implementations, the system could be enhanced to record more detailed location information. When a deprecated `hookimpl` is found, the system should emit a `PytestDeprecationWarning` that includes this detailed location information, making it easier for users to identify and correct the source of the deprecation. Preserving Existing Functionality: The mechanism for loading, registering, and managing plugins and their hook implementations should remain untouched in terms of functionality. The enhancement should only extend the information provided in warnings related to deprecated hook usage."
    }
]