[
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/contrib/admin/options.py",
        "start": 1105,
        "end": 1107,
        "class_name": "ModelAdmin",
        "method_name": "delete_queryset",
        "code": "1105     def delete_queryset(self, request, queryset):\n1106         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1107         queryset.delete()\n",
        "intended_behavior": "This method needs to handle queryset deletion carefully when the queryset involves a distinct() call, especially in the context of the admin interface where searches can generate querysets that use distinct(). The intended behavior here is to ensure that the queryset handed over to delete_queryset can be safely deleted, possibly by re-evaluating the queryset without distinct() if it's not compatible with deletion. This adjustment must preserve the admin's ability to filter and search efficiently without causing errors during bulk delete actions."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/contrib/admin/options.py",
        "start": 551,
        "end": 1998,
        "class_name": "ModelAdmin",
        "method_name": null,
        "code": "551 class ModelAdmin(BaseModelAdmin):\n552     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n553 \n554     list_display = ('__str__',)\n555     list_display_links = ()\n556     list_filter = ()\n557     list_select_related = False\n558     list_per_page = 100\n559     list_max_show_all = 200\n560     list_editable = ()\n561     search_fields = ()\n562     date_hierarchy = None\n563     save_as = False\n564     save_as_continue = True\n565     save_on_top = False\n566     paginator = Paginator\n567     preserve_filters = True\n568     inlines = []\n569 \n570     # Custom templates (designed to be over-ridden in subclasses)\n571     add_form_template = None\n572     change_form_template = None\n573     change_list_template = None\n574     delete_confirmation_template = None\n575     delete_selected_confirmation_template = None\n576     object_history_template = None\n577     popup_response_template = None\n578 \n579     # Actions\n580     actions = []\n581     action_form = helpers.ActionForm\n582     actions_on_top = True\n583     actions_on_bottom = False\n584     actions_selection_counter = True\n585     checks_class = ModelAdminChecks\n586 \n587     def __init__(self, model, admin_site):\n588         self.model = model\n589         self.opts = model._meta\n590         self.admin_site = admin_site\n591         super().__init__()\n592 \n593     def __str__(self):\n594         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n595 \n596     def get_inline_instances(self, request, obj=None):\n597         inline_instances = []\n598         for inline_class in self.get_inlines(request, obj):\n599             inline = inline_class(self.model, self.admin_site)\n600             if request:\n601                 if not (inline.has_view_or_change_permission(request, obj) or\n602                         inline.has_add_permission(request, obj) or\n603                         inline.has_delete_permission(request, obj)):\n604                     continue\n605                 if not inline.has_add_permission(request, obj):\n606                     inline.max_num = 0\n607             inline_instances.append(inline)\n608 \n609         return inline_instances\n610 \n611     def get_urls(self):\n612         from django.urls import path\n613 \n614         def wrap(view):\n615             def wrapper(*args, **kwargs):\n616                 return self.admin_site.admin_view(view)(*args, **kwargs)\n617             wrapper.model_admin = self\n618             return update_wrapper(wrapper, view)\n619 \n620         info = self.model._meta.app_label, self.model._meta.model_name\n621 \n622         return [\n623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n625             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n626             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n627             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n628             # For backwards compatibility (was the change url before 1.9)\n629             path('<path:object_id>/', wrap(RedirectView.as_view(\n630                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n631             ))),\n632         ]\n633 \n634     @property\n635     def urls(self):\n636         return self.get_urls()\n637 \n638     @property\n639     def media(self):\n640         extra = '' if settings.DEBUG else '.min'\n641         js = [\n642             'vendor/jquery/jquery%s.js' % extra,\n643             'jquery.init.js',\n644             'core.js',\n645             'admin/RelatedObjectLookups.js',\n646             'actions.js',\n647             'urlify.js',\n648             'prepopulate.js',\n649             'vendor/xregexp/xregexp%s.js' % extra,\n650         ]\n651         return forms.Media(js=['admin/js/%s' % url for url in js])\n652 \n653     def get_model_perms(self, request):\n654         \"\"\"\n655         Return a dict of all perms for this model. This dict has the keys\n656         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n657         for each of those actions.\n658         \"\"\"\n659         return {\n660             'add': self.has_add_permission(request),\n661             'change': self.has_change_permission(request),\n662             'delete': self.has_delete_permission(request),\n663             'view': self.has_view_permission(request),\n664         }\n665 \n666     def _get_form_for_get_fields(self, request, obj):\n667         return self.get_form(request, obj, fields=None)\n668 \n669     def get_form(self, request, obj=None, change=False, **kwargs):\n670         \"\"\"\n671         Return a Form class for use in the admin add view. This is used by\n672         add_view and change_view.\n673         \"\"\"\n674         if 'fields' in kwargs:\n675             fields = kwargs.pop('fields')\n676         else:\n677             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n678         excluded = self.get_exclude(request, obj)\n679         exclude = [] if excluded is None else list(excluded)\n680         readonly_fields = self.get_readonly_fields(request, obj)\n681         exclude.extend(readonly_fields)\n682         # Exclude all fields if it's a change form and the user doesn't have\n683         # the change permission.\n684         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n685             exclude.extend(fields)\n686         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n687             # Take the custom ModelForm's Meta.exclude into account only if the\n688             # ModelAdmin doesn't define its own.\n689             exclude.extend(self.form._meta.exclude)\n690         # if exclude is an empty list we pass None to be consistent with the\n691         # default on modelform_factory\n692         exclude = exclude or None\n693 \n694         # Remove declared form fields which are in readonly_fields.\n695         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n696         form = type(self.form.__name__, (self.form,), new_attrs)\n697 \n698         defaults = {\n699             'form': form,\n700             'fields': fields,\n701             'exclude': exclude,\n702             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n703             **kwargs,\n704         }\n705 \n706         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n707             defaults['fields'] = forms.ALL_FIELDS\n708 \n709         try:\n710             return modelform_factory(self.model, **defaults)\n711         except FieldError as e:\n712             raise FieldError(\n713                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n714                 % (e, self.__class__.__name__)\n715             )\n716 \n717     def get_changelist(self, request, **kwargs):\n718         \"\"\"\n719         Return the ChangeList class for use on the changelist page.\n720         \"\"\"\n721         from django.contrib.admin.views.main import ChangeList\n722         return ChangeList\n723 \n724     def get_changelist_instance(self, request):\n725         \"\"\"\n726         Return a `ChangeList` instance based on `request`. May raise\n727         `IncorrectLookupParameters`.\n728         \"\"\"\n729         list_display = self.get_list_display(request)\n730         list_display_links = self.get_list_display_links(request, list_display)\n731         # Add the action checkboxes if any actions are available.\n732         if self.get_actions(request):\n733             list_display = ['action_checkbox', *list_display]\n734         sortable_by = self.get_sortable_by(request)\n735         ChangeList = self.get_changelist(request)\n736         return ChangeList(\n737             request,\n738             self.model,\n739             list_display,\n740             list_display_links,\n741             self.get_list_filter(request),\n742             self.date_hierarchy,\n743             self.get_search_fields(request),\n744             self.get_list_select_related(request),\n745             self.list_per_page,\n746             self.list_max_show_all,\n747             self.list_editable,\n748             self,\n749             sortable_by,\n750         )\n751 \n752     def get_object(self, request, object_id, from_field=None):\n753         \"\"\"\n754         Return an instance matching the field and value provided, the primary\n755         key is used if no field is provided. Return ``None`` if no match is\n756         found or the object_id fails validation.\n757         \"\"\"\n758         queryset = self.get_queryset(request)\n759         model = queryset.model\n760         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n761         try:\n762             object_id = field.to_python(object_id)\n763             return queryset.get(**{field.name: object_id})\n764         except (model.DoesNotExist, ValidationError, ValueError):\n765             return None\n766 \n767     def get_changelist_form(self, request, **kwargs):\n768         \"\"\"\n769         Return a Form class for use in the Formset on the changelist page.\n770         \"\"\"\n771         defaults = {\n772             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n773             **kwargs,\n774         }\n775         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n776             defaults['fields'] = forms.ALL_FIELDS\n777 \n778         return modelform_factory(self.model, **defaults)\n779 \n780     def get_changelist_formset(self, request, **kwargs):\n781         \"\"\"\n782         Return a FormSet class for use on the changelist page if list_editable\n783         is used.\n784         \"\"\"\n785         defaults = {\n786             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n787             **kwargs,\n788         }\n789         return modelformset_factory(\n790             self.model, self.get_changelist_form(request), extra=0,\n791             fields=self.list_editable, **defaults\n792         )\n793 \n794     def get_formsets_with_inlines(self, request, obj=None):\n795         \"\"\"\n796         Yield formsets and the corresponding inlines.\n797         \"\"\"\n798         for inline in self.get_inline_instances(request, obj):\n799             yield inline.get_formset(request, obj), inline\n800 \n801     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n802         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n803 \n804     def log_addition(self, request, object, message):\n805         \"\"\"\n806         Log that an object has been successfully added.\n807 \n808         The default implementation creates an admin LogEntry object.\n809         \"\"\"\n810         from django.contrib.admin.models import ADDITION, LogEntry\n811         return LogEntry.objects.log_action(\n812             user_id=request.user.pk,\n813             content_type_id=get_content_type_for_model(object).pk,\n814             object_id=object.pk,\n815             object_repr=str(object),\n816             action_flag=ADDITION,\n817             change_message=message,\n818         )\n819 \n820     def log_change(self, request, object, message):\n821         \"\"\"\n822         Log that an object has been successfully changed.\n823 \n824         The default implementation creates an admin LogEntry object.\n825         \"\"\"\n826         from django.contrib.admin.models import CHANGE, LogEntry\n827         return LogEntry.objects.log_action(\n828             user_id=request.user.pk,\n829             content_type_id=get_content_type_for_model(object).pk,\n830             object_id=object.pk,\n831             object_repr=str(object),\n832             action_flag=CHANGE,\n833             change_message=message,\n834         )\n835 \n836     def log_deletion(self, request, object, object_repr):\n837         \"\"\"\n838         Log that an object will be deleted. Note that this method must be\n839         called before the deletion.\n840 \n841         The default implementation creates an admin LogEntry object.\n842         \"\"\"\n843         from django.contrib.admin.models import DELETION, LogEntry\n844         return LogEntry.objects.log_action(\n845             user_id=request.user.pk,\n846             content_type_id=get_content_type_for_model(object).pk,\n847             object_id=object.pk,\n848             object_repr=object_repr,\n849             action_flag=DELETION,\n850         )\n851 \n852     @display(description=mark_safe('<input type=\"checkbox\" id=\"action-toggle\">'))\n853     def action_checkbox(self, obj):\n854         \"\"\"\n855         A list_display column containing a checkbox widget.\n856         \"\"\"\n857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n858 \n859     @staticmethod\n860     def _get_action_description(func, name):\n861         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))\n862 \n863     def _get_base_actions(self):\n864         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n865         actions = []\n866         base_actions = (self.get_action(action) for action in self.actions or [])\n867         # get_action might have returned None, so filter any of those out.\n868         base_actions = [action for action in base_actions if action]\n869         base_action_names = {name for _, name, _ in base_actions}\n870 \n871         # Gather actions from the admin site first\n872         for (name, func) in self.admin_site.actions:\n873             if name in base_action_names:\n874                 continue\n875             description = self._get_action_description(func, name)\n876             actions.append((func, name, description))\n877         # Add actions from this ModelAdmin.\n878         actions.extend(base_actions)\n879         return actions\n880 \n881     def _filter_actions_by_permissions(self, request, actions):\n882         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n883         filtered_actions = []\n884         for action in actions:\n885             callable = action[0]\n886             if not hasattr(callable, 'allowed_permissions'):\n887                 filtered_actions.append(action)\n888                 continue\n889             permission_checks = (\n890                 getattr(self, 'has_%s_permission' % permission)\n891                 for permission in callable.allowed_permissions\n892             )\n893             if any(has_permission(request) for has_permission in permission_checks):\n894                 filtered_actions.append(action)\n895         return filtered_actions\n896 \n897     def get_actions(self, request):\n898         \"\"\"\n899         Return a dictionary mapping the names of all actions for this\n900         ModelAdmin to a tuple of (callable, name, description) for each action.\n901         \"\"\"\n902         # If self.actions is set to None that means actions are disabled on\n903         # this page.\n904         if self.actions is None or IS_POPUP_VAR in request.GET:\n905             return {}\n906         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n907         return {name: (func, name, desc) for func, name, desc in actions}\n908 \n909     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n910         \"\"\"\n911         Return a list of choices for use in a form object.  Each choice is a\n912         tuple (name, description).\n913         \"\"\"\n914         choices = [] + default_choices\n915         for func, name, description in self.get_actions(request).values():\n916             choice = (name, description % model_format_dict(self.opts))\n917             choices.append(choice)\n918         return choices\n919 \n920     def get_action(self, action):\n921         \"\"\"\n922         Return a given action from a parameter, which can either be a callable,\n923         or the name of a method on the ModelAdmin.  Return is a tuple of\n924         (callable, name, description).\n925         \"\"\"\n926         # If the action is a callable, just use it.\n927         if callable(action):\n928             func = action\n929             action = action.__name__\n930 \n931         # Next, look for a method. Grab it off self.__class__ to get an unbound\n932         # method instead of a bound one; this ensures that the calling\n933         # conventions are the same for functions and methods.\n934         elif hasattr(self.__class__, action):\n935             func = getattr(self.__class__, action)\n936 \n937         # Finally, look for a named method on the admin site\n938         else:\n939             try:\n940                 func = self.admin_site.get_action(action)\n941             except KeyError:\n942                 return None\n943 \n944         description = self._get_action_description(func, action)\n945         return func, action, description\n946 \n947     def get_list_display(self, request):\n948         \"\"\"\n949         Return a sequence containing the fields to be displayed on the\n950         changelist.\n951         \"\"\"\n952         return self.list_display\n953 \n954     def get_list_display_links(self, request, list_display):\n955         \"\"\"\n956         Return a sequence containing the fields to be displayed as links\n957         on the changelist. The list_display parameter is the list of fields\n958         returned by get_list_display().\n959         \"\"\"\n960         if self.list_display_links or self.list_display_links is None or not list_display:\n961             return self.list_display_links\n962         else:\n963             # Use only the first item in list_display as link\n964             return list(list_display)[:1]\n965 \n966     def get_list_filter(self, request):\n967         \"\"\"\n968         Return a sequence containing the fields to be displayed as filters in\n969         the right sidebar of the changelist page.\n970         \"\"\"\n971         return self.list_filter\n972 \n973     def get_list_select_related(self, request):\n974         \"\"\"\n975         Return a list of fields to add to the select_related() part of the\n976         changelist items query.\n977         \"\"\"\n978         return self.list_select_related\n979 \n980     def get_search_fields(self, request):\n981         \"\"\"\n982         Return a sequence containing the fields to be searched whenever\n983         somebody submits a search query.\n984         \"\"\"\n985         return self.search_fields\n986 \n987     def get_search_results(self, request, queryset, search_term):\n988         \"\"\"\n989         Return a tuple containing a queryset to implement the search\n990         and a boolean indicating if the results may contain duplicates.\n991         \"\"\"\n992         # Apply keyword searches.\n993         def construct_search(field_name):\n994             if field_name.startswith('^'):\n995                 return \"%s__istartswith\" % field_name[1:]\n996             elif field_name.startswith('='):\n997                 return \"%s__iexact\" % field_name[1:]\n998             elif field_name.startswith('@'):\n999                 return \"%s__search\" % field_name[1:]\n1000             # Use field_name if it includes a lookup.\n1001             opts = queryset.model._meta\n1002             lookup_fields = field_name.split(LOOKUP_SEP)\n1003             # Go through the fields, following all relations.\n1004             prev_field = None\n1005             for path_part in lookup_fields:\n1006                 if path_part == 'pk':\n1007                     path_part = opts.pk.name\n1008                 try:\n1009                     field = opts.get_field(path_part)\n1010                 except FieldDoesNotExist:\n1011                     # Use valid query lookups.\n1012                     if prev_field and prev_field.get_lookup(path_part):\n1013                         return field_name\n1014                 else:\n1015                     prev_field = field\n1016                     if hasattr(field, 'get_path_info'):\n1017                         # Update opts to follow the relation.\n1018                         opts = field.get_path_info()[-1].to_opts\n1019             # Otherwise, use the field with icontains.\n1020             return \"%s__icontains\" % field_name\n1021 \n1022         use_distinct = False\n1023         search_fields = self.get_search_fields(request)\n1024         if search_fields and search_term:\n1025             orm_lookups = [construct_search(str(search_field))\n1026                            for search_field in search_fields]\n1027             for bit in smart_split(search_term):\n1028                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n1029                     bit = unescape_string_literal(bit)\n1030                 or_queries = [models.Q(**{orm_lookup: bit})\n1031                               for orm_lookup in orm_lookups]\n1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))\n1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)\n1034 \n1035         return queryset, use_distinct\n1036 \n1037     def get_preserved_filters(self, request):\n1038         \"\"\"\n1039         Return the preserved filters querystring.\n1040         \"\"\"\n1041         match = request.resolver_match\n1042         if self.preserve_filters and match:\n1043             opts = self.model._meta\n1044             current_url = '%s:%s' % (match.app_name, match.url_name)\n1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)\n1046             if current_url == changelist_url:\n1047                 preserved_filters = request.GET.urlencode()\n1048             else:\n1049                 preserved_filters = request.GET.get('_changelist_filters')\n1050 \n1051             if preserved_filters:\n1052                 return urlencode({'_changelist_filters': preserved_filters})\n1053         return ''\n1054 \n1055     def construct_change_message(self, request, form, formsets, add=False):\n1056         \"\"\"\n1057         Construct a JSON structure describing changes from a changed object.\n1058         \"\"\"\n1059         return construct_change_message(form, formsets, add)\n1060 \n1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',\n1062                      fail_silently=False):\n1063         \"\"\"\n1064         Send a message to the user. The default implementation\n1065         posts a message using the django.contrib.messages backend.\n1066 \n1067         Exposes almost the same API as messages.add_message(), but accepts the\n1068         positional arguments in a different order to maintain backwards\n1069         compatibility. For convenience, it accepts the `level` argument as\n1070         a string rather than the usual level number.\n1071         \"\"\"\n1072         if not isinstance(level, int):\n1073             # attempt to get the level if passed a string\n1074             try:\n1075                 level = getattr(messages.constants, level.upper())\n1076             except AttributeError:\n1077                 levels = messages.constants.DEFAULT_TAGS.values()\n1078                 levels_repr = ', '.join('`%s`' % level for level in levels)\n1079                 raise ValueError(\n1080                     'Bad message level string: `%s`. Possible values are: %s'\n1081                     % (level, levels_repr)\n1082                 )\n1083 \n1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)\n1085 \n1086     def save_form(self, request, form, change):\n1087         \"\"\"\n1088         Given a ModelForm return an unsaved instance. ``change`` is True if\n1089         the object is being changed, and False if it's being added.\n1090         \"\"\"\n1091         return form.save(commit=False)\n1092 \n1093     def save_model(self, request, obj, form, change):\n1094         \"\"\"\n1095         Given a model instance save it to the database.\n1096         \"\"\"\n1097         obj.save()\n1098 \n1099     def delete_model(self, request, obj):\n1100         \"\"\"\n1101         Given a model instance delete it from the database.\n1102         \"\"\"\n1103         obj.delete()\n1104 \n1105     def delete_queryset(self, request, queryset):\n1106         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1107         queryset.delete()\n1108 \n1109     def save_formset(self, request, form, formset, change):\n1110         \"\"\"\n1111         Given an inline formset save it to the database.\n1112         \"\"\"\n1113         formset.save()\n1114 \n1115     def save_related(self, request, form, formsets, change):\n1116         \"\"\"\n1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1118         list of inline formsets and a boolean value based on whether the\n1119         parent is being added or changed, save the related objects to the\n1120         database. Note that at this point save_form() and save_model() have\n1121         already been called.\n1122         \"\"\"\n1123         form.save_m2m()\n1124         for formset in formsets:\n1125             self.save_formset(request, form, formset, change=change)\n1126 \n1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):\n1128         opts = self.model._meta\n1129         app_label = opts.app_label\n1130         preserved_filters = self.get_preserved_filters(request)\n1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)\n1132         view_on_site_url = self.get_view_on_site_url(obj)\n1133         has_editable_inline_admin_formsets = False\n1134         for inline in context['inline_admin_formsets']:\n1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:\n1136                 has_editable_inline_admin_formsets = True\n1137                 break\n1138         context.update({\n1139             'add': add,\n1140             'change': change,\n1141             'has_view_permission': self.has_view_permission(request, obj),\n1142             'has_add_permission': self.has_add_permission(request),\n1143             'has_change_permission': self.has_change_permission(request, obj),\n1144             'has_delete_permission': self.has_delete_permission(request, obj),\n1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,\n1146             'has_file_field': context['adminform'].form.is_multipart() or any(\n1147                 admin_formset.formset.is_multipart()\n1148                 for admin_formset in context['inline_admin_formsets']\n1149             ),\n1150             'has_absolute_url': view_on_site_url is not None,\n1151             'absolute_url': view_on_site_url,\n1152             'form_url': form_url,\n1153             'opts': opts,\n1154             'content_type_id': get_content_type_for_model(self.model).pk,\n1155             'save_as': self.save_as,\n1156             'save_on_top': self.save_on_top,\n1157             'to_field_var': TO_FIELD_VAR,\n1158             'is_popup_var': IS_POPUP_VAR,\n1159             'app_label': app_label,\n1160         })\n1161         if add and self.add_form_template is not None:\n1162             form_template = self.add_form_template\n1163         else:\n1164             form_template = self.change_form_template\n1165 \n1166         request.current_app = self.admin_site.name\n1167 \n1168         return TemplateResponse(request, form_template or [\n1169             \"admin/%s/%s/change_form.html\" % (app_label, opts.model_name),\n1170             \"admin/%s/change_form.html\" % app_label,\n1171             \"admin/change_form.html\"\n1172         ], context)\n1173 \n1174     def response_add(self, request, obj, post_url_continue=None):\n1175         \"\"\"\n1176         Determine the HttpResponse for the add_view stage.\n1177         \"\"\"\n1178         opts = obj._meta\n1179         preserved_filters = self.get_preserved_filters(request)\n1180         obj_url = reverse(\n1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),\n1182             args=(quote(obj.pk),),\n1183             current_app=self.admin_site.name,\n1184         )\n1185         # Add a link to the object's change form if the user can edit the obj.\n1186         if self.has_change_permission(request, obj):\n1187             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1188         else:\n1189             obj_repr = str(obj)\n1190         msg_dict = {\n1191             'name': opts.verbose_name,\n1192             'obj': obj_repr,\n1193         }\n1194         # Here, we distinguish between different save types by checking for\n1195         # the presence of keys in request.POST.\n1196 \n1197         if IS_POPUP_VAR in request.POST:\n1198             to_field = request.POST.get(TO_FIELD_VAR)\n1199             if to_field:\n1200                 attr = str(to_field)\n1201             else:\n1202                 attr = obj._meta.pk.attname\n1203             value = obj.serializable_value(attr)\n1204             popup_response_data = json.dumps({\n1205                 'value': str(value),\n1206                 'obj': str(obj),\n1207             })\n1208             return TemplateResponse(request, self.popup_response_template or [\n1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1210                 'admin/%s/popup_response.html' % opts.app_label,\n1211                 'admin/popup_response.html',\n1212             ], {\n1213                 'popup_response_data': popup_response_data,\n1214             })\n1215 \n1216         elif \"_continue\" in request.POST or (\n1217                 # Redirecting after \"Save as new\".\n1218                 \"_saveasnew\" in request.POST and self.save_as_continue and\n1219                 self.has_change_permission(request, obj)\n1220         ):\n1221             msg = _('The {name} \u201c{obj}\u201d was added successfully.')\n1222             if self.has_change_permission(request, obj):\n1223                 msg += ' ' + _('You may edit it again below.')\n1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1225             if post_url_continue is None:\n1226                 post_url_continue = obj_url\n1227             post_url_continue = add_preserved_filters(\n1228                 {'preserved_filters': preserved_filters, 'opts': opts},\n1229                 post_url_continue\n1230             )\n1231             return HttpResponseRedirect(post_url_continue)\n1232 \n1233         elif \"_addanother\" in request.POST:\n1234             msg = format_html(\n1235                 _('The {name} \u201c{obj}\u201d was added successfully. You may add another {name} below.'),\n1236                 **msg_dict\n1237             )\n1238             self.message_user(request, msg, messages.SUCCESS)\n1239             redirect_url = request.path\n1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1241             return HttpResponseRedirect(redirect_url)\n1242 \n1243         else:\n1244             msg = format_html(\n1245                 _('The {name} \u201c{obj}\u201d was added successfully.'),\n1246                 **msg_dict\n1247             )\n1248             self.message_user(request, msg, messages.SUCCESS)\n1249             return self.response_post_save_add(request, obj)\n1250 \n1251     def response_change(self, request, obj):\n1252         \"\"\"\n1253         Determine the HttpResponse for the change_view stage.\n1254         \"\"\"\n1255 \n1256         if IS_POPUP_VAR in request.POST:\n1257             opts = obj._meta\n1258             to_field = request.POST.get(TO_FIELD_VAR)\n1259             attr = str(to_field) if to_field else opts.pk.attname\n1260             value = request.resolver_match.kwargs['object_id']\n1261             new_value = obj.serializable_value(attr)\n1262             popup_response_data = json.dumps({\n1263                 'action': 'change',\n1264                 'value': str(value),\n1265                 'obj': str(obj),\n1266                 'new_value': str(new_value),\n1267             })\n1268             return TemplateResponse(request, self.popup_response_template or [\n1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1270                 'admin/%s/popup_response.html' % opts.app_label,\n1271                 'admin/popup_response.html',\n1272             ], {\n1273                 'popup_response_data': popup_response_data,\n1274             })\n1275 \n1276         opts = self.model._meta\n1277         preserved_filters = self.get_preserved_filters(request)\n1278 \n1279         msg_dict = {\n1280             'name': opts.verbose_name,\n1281             'obj': format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1282         }\n1283         if \"_continue\" in request.POST:\n1284             msg = format_html(\n1285                 _('The {name} \u201c{obj}\u201d was changed successfully. You may edit it again below.'),\n1286                 **msg_dict\n1287             )\n1288             self.message_user(request, msg, messages.SUCCESS)\n1289             redirect_url = request.path\n1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1291             return HttpResponseRedirect(redirect_url)\n1292 \n1293         elif \"_saveasnew\" in request.POST:\n1294             msg = format_html(\n1295                 _('The {name} \u201c{obj}\u201d was added successfully. You may edit it again below.'),\n1296                 **msg_dict\n1297             )\n1298             self.message_user(request, msg, messages.SUCCESS)\n1299             redirect_url = reverse('admin:%s_%s_change' %\n1300                                    (opts.app_label, opts.model_name),\n1301                                    args=(obj.pk,),\n1302                                    current_app=self.admin_site.name)\n1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1304             return HttpResponseRedirect(redirect_url)\n1305 \n1306         elif \"_addanother\" in request.POST:\n1307             msg = format_html(\n1308                 _('The {name} \u201c{obj}\u201d was changed successfully. You may add another {name} below.'),\n1309                 **msg_dict\n1310             )\n1311             self.message_user(request, msg, messages.SUCCESS)\n1312             redirect_url = reverse('admin:%s_%s_add' %\n1313                                    (opts.app_label, opts.model_name),\n1314                                    current_app=self.admin_site.name)\n1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1316             return HttpResponseRedirect(redirect_url)\n1317 \n1318         else:\n1319             msg = format_html(\n1320                 _('The {name} \u201c{obj}\u201d was changed successfully.'),\n1321                 **msg_dict\n1322             )\n1323             self.message_user(request, msg, messages.SUCCESS)\n1324             return self.response_post_save_change(request, obj)\n1325 \n1326     def _response_post_save(self, request, obj):\n1327         opts = self.model._meta\n1328         if self.has_view_or_change_permission(request):\n1329             post_url = reverse('admin:%s_%s_changelist' %\n1330                                (opts.app_label, opts.model_name),\n1331                                current_app=self.admin_site.name)\n1332             preserved_filters = self.get_preserved_filters(request)\n1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)\n1334         else:\n1335             post_url = reverse('admin:index',\n1336                                current_app=self.admin_site.name)\n1337         return HttpResponseRedirect(post_url)\n1338 \n1339     def response_post_save_add(self, request, obj):\n1340         \"\"\"\n1341         Figure out where to redirect after the 'Save' button has been pressed\n1342         when adding a new object.\n1343         \"\"\"\n1344         return self._response_post_save(request, obj)\n1345 \n1346     def response_post_save_change(self, request, obj):\n1347         \"\"\"\n1348         Figure out where to redirect after the 'Save' button has been pressed\n1349         when editing an existing object.\n1350         \"\"\"\n1351         return self._response_post_save(request, obj)\n1352 \n1353     def response_action(self, request, queryset):\n1354         \"\"\"\n1355         Handle an admin action. This is called if a request is POSTed to the\n1356         changelist; it returns an HttpResponse if the action was handled, and\n1357         None otherwise.\n1358         \"\"\"\n1359 \n1360         # There can be multiple action forms on the page (at the top\n1361         # and bottom of the change list, for example). Get the action\n1362         # whose button was pushed.\n1363         try:\n1364             action_index = int(request.POST.get('index', 0))\n1365         except ValueError:\n1366             action_index = 0\n1367 \n1368         # Construct the action form.\n1369         data = request.POST.copy()\n1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1371         data.pop(\"index\", None)\n1372 \n1373         # Use the action whose button was pushed\n1374         try:\n1375             data.update({'action': data.getlist('action')[action_index]})\n1376         except IndexError:\n1377             # If we didn't get an action from the chosen form that's invalid\n1378             # POST data, so by deleting action it'll fail the validation check\n1379             # below. So no need to do anything here\n1380             pass\n1381 \n1382         action_form = self.action_form(data, auto_id=None)\n1383         action_form.fields['action'].choices = self.get_action_choices(request)\n1384 \n1385         # If the form's valid we can handle the action.\n1386         if action_form.is_valid():\n1387             action = action_form.cleaned_data['action']\n1388             select_across = action_form.cleaned_data['select_across']\n1389             func = self.get_actions(request)[action][0]\n1390 \n1391             # Get the list of selected PKs. If nothing's selected, we can't\n1392             # perform an action on it, so bail. Except we want to perform\n1393             # the action explicitly on all objects.\n1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1395             if not selected and not select_across:\n1396                 # Reminder that something needs to be selected or nothing will happen\n1397                 msg = _(\"Items must be selected in order to perform \"\n1398                         \"actions on them. No items have been changed.\")\n1399                 self.message_user(request, msg, messages.WARNING)\n1400                 return None\n1401 \n1402             if not select_across:\n1403                 # Perform the action only on the selected objects\n1404                 queryset = queryset.filter(pk__in=selected)\n1405 \n1406             response = func(self, request, queryset)\n1407 \n1408             # Actions may return an HttpResponse-like object, which will be\n1409             # used as the response from the POST. If not, we'll be a good\n1410             # little HTTP citizen and redirect back to the changelist page.\n1411             if isinstance(response, HttpResponseBase):\n1412                 return response\n1413             else:\n1414                 return HttpResponseRedirect(request.get_full_path())\n1415         else:\n1416             msg = _(\"No action selected.\")\n1417             self.message_user(request, msg, messages.WARNING)\n1418             return None\n1419 \n1420     def response_delete(self, request, obj_display, obj_id):\n1421         \"\"\"\n1422         Determine the HttpResponse for the delete_view stage.\n1423         \"\"\"\n1424         opts = self.model._meta\n1425 \n1426         if IS_POPUP_VAR in request.POST:\n1427             popup_response_data = json.dumps({\n1428                 'action': 'delete',\n1429                 'value': str(obj_id),\n1430             })\n1431             return TemplateResponse(request, self.popup_response_template or [\n1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1433                 'admin/%s/popup_response.html' % opts.app_label,\n1434                 'admin/popup_response.html',\n1435             ], {\n1436                 'popup_response_data': popup_response_data,\n1437             })\n1438 \n1439         self.message_user(\n1440             request,\n1441             _('The %(name)s \u201c%(obj)s\u201d was deleted successfully.') % {\n1442                 'name': opts.verbose_name,\n1443                 'obj': obj_display,\n1444             },\n1445             messages.SUCCESS,\n1446         )\n1447 \n1448         if self.has_change_permission(request, None):\n1449             post_url = reverse(\n1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),\n1451                 current_app=self.admin_site.name,\n1452             )\n1453             preserved_filters = self.get_preserved_filters(request)\n1454             post_url = add_preserved_filters(\n1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url\n1456             )\n1457         else:\n1458             post_url = reverse('admin:index', current_app=self.admin_site.name)\n1459         return HttpResponseRedirect(post_url)\n1460 \n1461     def render_delete_form(self, request, context):\n1462         opts = self.model._meta\n1463         app_label = opts.app_label\n1464 \n1465         request.current_app = self.admin_site.name\n1466         context.update(\n1467             to_field_var=TO_FIELD_VAR,\n1468             is_popup_var=IS_POPUP_VAR,\n1469             media=self.media,\n1470         )\n1471 \n1472         return TemplateResponse(\n1473             request,\n1474             self.delete_confirmation_template or [\n1475                 \"admin/{}/{}/delete_confirmation.html\".format(app_label, opts.model_name),\n1476                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1477                 \"admin/delete_confirmation.html\",\n1478             ],\n1479             context,\n1480         )\n1481 \n1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1483         # Edit permissions on parent model are required for editable inlines.\n1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)\n1485         inline_admin_formsets = []\n1486         for inline, formset in zip(inline_instances, formsets):\n1487             fieldsets = list(inline.get_fieldsets(request, obj))\n1488             readonly = list(inline.get_readonly_fields(request, obj))\n1489             if can_edit_parent:\n1490                 has_add_permission = inline.has_add_permission(request, obj)\n1491                 has_change_permission = inline.has_change_permission(request, obj)\n1492                 has_delete_permission = inline.has_delete_permission(request, obj)\n1493             else:\n1494                 # Disable all edit-permissions, and overide formset settings.\n1495                 has_add_permission = has_change_permission = has_delete_permission = False\n1496                 formset.extra = formset.max_num = 0\n1497             has_view_permission = inline.has_view_permission(request, obj)\n1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1499             inline_admin_formset = helpers.InlineAdminFormSet(\n1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,\n1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,\n1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,\n1503             )\n1504             inline_admin_formsets.append(inline_admin_formset)\n1505         return inline_admin_formsets\n1506 \n1507     def get_changeform_initial_data(self, request):\n1508         \"\"\"\n1509         Get the initial form data from the request's GET params.\n1510         \"\"\"\n1511         initial = dict(request.GET.items())\n1512         for k in initial:\n1513             try:\n1514                 f = self.model._meta.get_field(k)\n1515             except FieldDoesNotExist:\n1516                 continue\n1517             # We have to special-case M2Ms as a list of comma-separated PKs.\n1518             if isinstance(f, models.ManyToManyField):\n1519                 initial[k] = initial[k].split(\",\")\n1520         return initial\n1521 \n1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1523         \"\"\"\n1524         Create a message informing the user that the object doesn't exist\n1525         and return a redirect to the admin index page.\n1526         \"\"\"\n1527         msg = _('%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?') % {\n1528             'name': opts.verbose_name,\n1529             'key': unquote(object_id),\n1530         }\n1531         self.message_user(request, msg, messages.WARNING)\n1532         url = reverse('admin:index', current_app=self.admin_site.name)\n1533         return HttpResponseRedirect(url)\n1534 \n1535     @csrf_protect_m\n1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):\n1537         with transaction.atomic(using=router.db_for_write(self.model)):\n1538             return self._changeform_view(request, object_id, form_url, extra_context)\n1539 \n1540     def _changeform_view(self, request, object_id, form_url, extra_context):\n1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1542         if to_field and not self.to_field_allowed(request, to_field):\n1543             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1544 \n1545         model = self.model\n1546         opts = model._meta\n1547 \n1548         if request.method == 'POST' and '_saveasnew' in request.POST:\n1549             object_id = None\n1550 \n1551         add = object_id is None\n1552 \n1553         if add:\n1554             if not self.has_add_permission(request):\n1555                 raise PermissionDenied\n1556             obj = None\n1557 \n1558         else:\n1559             obj = self.get_object(request, unquote(object_id), to_field)\n1560 \n1561             if request.method == 'POST':\n1562                 if not self.has_change_permission(request, obj):\n1563                     raise PermissionDenied\n1564             else:\n1565                 if not self.has_view_or_change_permission(request, obj):\n1566                     raise PermissionDenied\n1567 \n1568             if obj is None:\n1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1570 \n1571         fieldsets = self.get_fieldsets(request, obj)\n1572         ModelForm = self.get_form(\n1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1574         )\n1575         if request.method == 'POST':\n1576             form = ModelForm(request.POST, request.FILES, instance=obj)\n1577             form_validated = form.is_valid()\n1578             if form_validated:\n1579                 new_object = self.save_form(request, form, change=not add)\n1580             else:\n1581                 new_object = form.instance\n1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)\n1583             if all_valid(formsets) and form_validated:\n1584                 self.save_model(request, new_object, form, not add)\n1585                 self.save_related(request, form, formsets, not add)\n1586                 change_message = self.construct_change_message(request, form, formsets, add)\n1587                 if add:\n1588                     self.log_addition(request, new_object, change_message)\n1589                     return self.response_add(request, new_object)\n1590                 else:\n1591                     self.log_change(request, new_object, change_message)\n1592                     return self.response_change(request, new_object)\n1593             else:\n1594                 form_validated = False\n1595         else:\n1596             if add:\n1597                 initial = self.get_changeform_initial_data(request)\n1598                 form = ModelForm(initial=initial)\n1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)\n1600             else:\n1601                 form = ModelForm(instance=obj)\n1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)\n1603 \n1604         if not add and not self.has_change_permission(request, obj):\n1605             readonly_fields = flatten_fieldsets(fieldsets)\n1606         else:\n1607             readonly_fields = self.get_readonly_fields(request, obj)\n1608         adminForm = helpers.AdminForm(\n1609             form,\n1610             list(fieldsets),\n1611             # Clear prepopulated fields on a view-only form to avoid a crash.\n1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},\n1613             readonly_fields,\n1614             model_admin=self)\n1615         media = self.media + adminForm.media\n1616 \n1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)\n1618         for inline_formset in inline_formsets:\n1619             media = media + inline_formset.media\n1620 \n1621         if add:\n1622             title = _('Add %s')\n1623         elif self.has_change_permission(request, obj):\n1624             title = _('Change %s')\n1625         else:\n1626             title = _('View %s')\n1627         context = {\n1628             **self.admin_site.each_context(request),\n1629             'title': title % opts.verbose_name,\n1630             'subtitle': str(obj) if obj else None,\n1631             'adminform': adminForm,\n1632             'object_id': object_id,\n1633             'original': obj,\n1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1635             'to_field': to_field,\n1636             'media': media,\n1637             'inline_admin_formsets': inline_formsets,\n1638             'errors': helpers.AdminErrorList(form, formsets),\n1639             'preserved_filters': self.get_preserved_filters(request),\n1640         }\n1641 \n1642         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1643         # previously chosen to prevent the interface from getting confusing.\n1644         if request.method == 'POST' and not form_validated and \"_saveasnew\" in request.POST:\n1645             context['show_save'] = False\n1646             context['show_save_and_continue'] = False\n1647             # Use the change template instead of the add template.\n1648             add = False\n1649 \n1650         context.update(extra_context or {})\n1651 \n1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)\n1653 \n1654     def add_view(self, request, form_url='', extra_context=None):\n1655         return self.changeform_view(request, None, form_url, extra_context)\n1656 \n1657     def change_view(self, request, object_id, form_url='', extra_context=None):\n1658         return self.changeform_view(request, object_id, form_url, extra_context)\n1659 \n1660     def _get_edited_object_pks(self, request, prefix):\n1661         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1662         pk_pattern = re.compile(\n1663             r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)\n1664         )\n1665         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1666 \n1667     def _get_list_editable_queryset(self, request, prefix):\n1668         \"\"\"\n1669         Based on POST data, return a queryset of the objects that were edited\n1670         via list_editable.\n1671         \"\"\"\n1672         object_pks = self._get_edited_object_pks(request, prefix)\n1673         queryset = self.get_queryset(request)\n1674         validate = queryset.model._meta.pk.to_python\n1675         try:\n1676             for pk in object_pks:\n1677                 validate(pk)\n1678         except ValidationError:\n1679             # Disable the optimization if the POST data was tampered with.\n1680             return queryset\n1681         return queryset.filter(pk__in=object_pks)\n1682 \n1683     @csrf_protect_m\n1684     def changelist_view(self, request, extra_context=None):\n1685         \"\"\"\n1686         The 'change list' admin view for this model.\n1687         \"\"\"\n1688         from django.contrib.admin.views.main import ERROR_FLAG\n1689         opts = self.model._meta\n1690         app_label = opts.app_label\n1691         if not self.has_view_or_change_permission(request):\n1692             raise PermissionDenied\n1693 \n1694         try:\n1695             cl = self.get_changelist_instance(request)\n1696         except IncorrectLookupParameters:\n1697             # Wacky lookup parameters were given, so redirect to the main\n1698             # changelist page, without parameters, and pass an 'invalid=1'\n1699             # parameter via the query string. If wacky parameters were given\n1700             # and the 'invalid=1' parameter was already in the query string,\n1701             # something is screwed up with the database, so display an error\n1702             # page.\n1703             if ERROR_FLAG in request.GET:\n1704                 return SimpleTemplateResponse('admin/invalid_setup.html', {\n1705                     'title': _('Database error'),\n1706                 })\n1707             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')\n1708 \n1709         # If the request was POSTed, this might be a bulk action or a bulk\n1710         # edit. Try to look up an action or confirmation first, but if this\n1711         # isn't an action the POST will fall through to the bulk edit check,\n1712         # below.\n1713         action_failed = False\n1714         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1715 \n1716         actions = self.get_actions(request)\n1717         # Actions with no confirmation\n1718         if (actions and request.method == 'POST' and\n1719                 'index' in request.POST and '_save' not in request.POST):\n1720             if selected:\n1721                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1722                 if response:\n1723                     return response\n1724                 else:\n1725                     action_failed = True\n1726             else:\n1727                 msg = _(\"Items must be selected in order to perform \"\n1728                         \"actions on them. No items have been changed.\")\n1729                 self.message_user(request, msg, messages.WARNING)\n1730                 action_failed = True\n1731 \n1732         # Actions with confirmation\n1733         if (actions and request.method == 'POST' and\n1734                 helpers.ACTION_CHECKBOX_NAME in request.POST and\n1735                 'index' not in request.POST and '_save' not in request.POST):\n1736             if selected:\n1737                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1738                 if response:\n1739                     return response\n1740                 else:\n1741                     action_failed = True\n1742 \n1743         if action_failed:\n1744             # Redirect back to the changelist page to avoid resubmitting the\n1745             # form if the user refreshes the browser or uses the \"No, take\n1746             # me back\" button on the action confirmation page.\n1747             return HttpResponseRedirect(request.get_full_path())\n1748 \n1749         # If we're allowing changelist editing, we need to construct a formset\n1750         # for the changelist given all the fields to be edited. Then we'll\n1751         # use the formset to validate/process POSTed data.\n1752         formset = cl.formset = None\n1753 \n1754         # Handle POSTed bulk-edit data.\n1755         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:\n1756             if not self.has_change_permission(request):\n1757                 raise PermissionDenied\n1758             FormSet = self.get_changelist_formset(request)\n1759             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())\n1760             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)\n1761             if formset.is_valid():\n1762                 changecount = 0\n1763                 for form in formset.forms:\n1764                     if form.has_changed():\n1765                         obj = self.save_form(request, form, change=True)\n1766                         self.save_model(request, obj, form, change=True)\n1767                         self.save_related(request, form, formsets=[], change=True)\n1768                         change_msg = self.construct_change_message(request, form, None)\n1769                         self.log_change(request, obj, change_msg)\n1770                         changecount += 1\n1771 \n1772                 if changecount:\n1773                     msg = ngettext(\n1774                         \"%(count)s %(name)s was changed successfully.\",\n1775                         \"%(count)s %(name)s were changed successfully.\",\n1776                         changecount\n1777                     ) % {\n1778                         'count': changecount,\n1779                         'name': model_ngettext(opts, changecount),\n1780                     }\n1781                     self.message_user(request, msg, messages.SUCCESS)\n1782 \n1783                 return HttpResponseRedirect(request.get_full_path())\n1784 \n1785         # Handle GET -- construct a formset for display.\n1786         elif cl.list_editable and self.has_change_permission(request):\n1787             FormSet = self.get_changelist_formset(request)\n1788             formset = cl.formset = FormSet(queryset=cl.result_list)\n1789 \n1790         # Build the list of media to be used by the formset.\n1791         if formset:\n1792             media = self.media + formset.media\n1793         else:\n1794             media = self.media\n1795 \n1796         # Build the action form and populate it with available actions.\n1797         if actions:\n1798             action_form = self.action_form(auto_id=None)\n1799             action_form.fields['action'].choices = self.get_action_choices(request)\n1800             media += action_form.media\n1801         else:\n1802             action_form = None\n1803 \n1804         selection_note_all = ngettext(\n1805             '%(total_count)s selected',\n1806             'All %(total_count)s selected',\n1807             cl.result_count\n1808         )\n1809 \n1810         context = {\n1811             **self.admin_site.each_context(request),\n1812             'module_name': str(opts.verbose_name_plural),\n1813             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},\n1814             'selection_note_all': selection_note_all % {'total_count': cl.result_count},\n1815             'title': cl.title,\n1816             'subtitle': None,\n1817             'is_popup': cl.is_popup,\n1818             'to_field': cl.to_field,\n1819             'cl': cl,\n1820             'media': media,\n1821             'has_add_permission': self.has_add_permission(request),\n1822             'opts': cl.opts,\n1823             'action_form': action_form,\n1824             'actions_on_top': self.actions_on_top,\n1825             'actions_on_bottom': self.actions_on_bottom,\n1826             'actions_selection_counter': self.actions_selection_counter,\n1827             'preserved_filters': self.get_preserved_filters(request),\n1828             **(extra_context or {}),\n1829         }\n1830 \n1831         request.current_app = self.admin_site.name\n1832 \n1833         return TemplateResponse(request, self.change_list_template or [\n1834             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),\n1835             'admin/%s/change_list.html' % app_label,\n1836             'admin/change_list.html'\n1837         ], context)\n1838 \n1839     def get_deleted_objects(self, objs, request):\n1840         \"\"\"\n1841         Hook for customizing the delete process for the delete view and the\n1842         \"delete selected\" action.\n1843         \"\"\"\n1844         return get_deleted_objects(objs, request, self.admin_site)\n1845 \n1846     @csrf_protect_m\n1847     def delete_view(self, request, object_id, extra_context=None):\n1848         with transaction.atomic(using=router.db_for_write(self.model)):\n1849             return self._delete_view(request, object_id, extra_context)\n1850 \n1851     def _delete_view(self, request, object_id, extra_context):\n1852         \"The 'delete' admin view for this model.\"\n1853         opts = self.model._meta\n1854         app_label = opts.app_label\n1855 \n1856         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1857         if to_field and not self.to_field_allowed(request, to_field):\n1858             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1859 \n1860         obj = self.get_object(request, unquote(object_id), to_field)\n1861 \n1862         if not self.has_delete_permission(request, obj):\n1863             raise PermissionDenied\n1864 \n1865         if obj is None:\n1866             return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1867 \n1868         # Populate deleted_objects, a data structure of all related objects that\n1869         # will also be deleted.\n1870         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)\n1871 \n1872         if request.POST and not protected:  # The user has confirmed the deletion.\n1873             if perms_needed:\n1874                 raise PermissionDenied\n1875             obj_display = str(obj)\n1876             attr = str(to_field) if to_field else opts.pk.attname\n1877             obj_id = obj.serializable_value(attr)\n1878             self.log_deletion(request, obj, obj_display)\n1879             self.delete_model(request, obj)\n1880 \n1881             return self.response_delete(request, obj_display, obj_id)\n1882 \n1883         object_name = str(opts.verbose_name)\n1884 \n1885         if perms_needed or protected:\n1886             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n1887         else:\n1888             title = _(\"Are you sure?\")\n1889 \n1890         context = {\n1891             **self.admin_site.each_context(request),\n1892             'title': title,\n1893             'subtitle': None,\n1894             'object_name': object_name,\n1895             'object': obj,\n1896             'deleted_objects': deleted_objects,\n1897             'model_count': dict(model_count).items(),\n1898             'perms_lacking': perms_needed,\n1899             'protected': protected,\n1900             'opts': opts,\n1901             'app_label': app_label,\n1902             'preserved_filters': self.get_preserved_filters(request),\n1903             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1904             'to_field': to_field,\n1905             **(extra_context or {}),\n1906         }\n1907 \n1908         return self.render_delete_form(request, context)\n1909 \n1910     def history_view(self, request, object_id, extra_context=None):\n1911         \"The 'history' admin view for this model.\"\n1912         from django.contrib.admin.models import LogEntry\n1913 \n1914         # First check if the user can see this history.\n1915         model = self.model\n1916         obj = self.get_object(request, unquote(object_id))\n1917         if obj is None:\n1918             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)\n1919 \n1920         if not self.has_view_or_change_permission(request, obj):\n1921             raise PermissionDenied\n1922 \n1923         # Then get the history for this object.\n1924         opts = model._meta\n1925         app_label = opts.app_label\n1926         action_list = LogEntry.objects.filter(\n1927             object_id=unquote(object_id),\n1928             content_type=get_content_type_for_model(model)\n1929         ).select_related().order_by('action_time')\n1930 \n1931         context = {\n1932             **self.admin_site.each_context(request),\n1933             'title': _('Change history: %s') % obj,\n1934             'subtitle': None,\n1935             'action_list': action_list,\n1936             'module_name': str(capfirst(opts.verbose_name_plural)),\n1937             'object': obj,\n1938             'opts': opts,\n1939             'preserved_filters': self.get_preserved_filters(request),\n1940             **(extra_context or {}),\n1941         }\n1942 \n1943         request.current_app = self.admin_site.name\n1944 \n1945         return TemplateResponse(request, self.object_history_template or [\n1946             \"admin/%s/%s/object_history.html\" % (app_label, opts.model_name),\n1947             \"admin/%s/object_history.html\" % app_label,\n1948             \"admin/object_history.html\"\n1949         ], context)\n1950 \n1951     def get_formset_kwargs(self, request, obj, inline, prefix):\n1952         formset_params = {\n1953             'instance': obj,\n1954             'prefix': prefix,\n1955             'queryset': inline.get_queryset(request),\n1956         }\n1957         if request.method == 'POST':\n1958             formset_params.update({\n1959                 'data': request.POST.copy(),\n1960                 'files': request.FILES,\n1961                 'save_as_new': '_saveasnew' in request.POST\n1962             })\n1963         return formset_params\n1964 \n1965     def _create_formsets(self, request, obj, change):\n1966         \"Helper function to generate formsets for add/change_view.\"\n1967         formsets = []\n1968         inline_instances = []\n1969         prefixes = {}\n1970         get_formsets_args = [request]\n1971         if change:\n1972             get_formsets_args.append(obj)\n1973         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n1974             prefix = FormSet.get_default_prefix()\n1975             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n1976             if prefixes[prefix] != 1 or not prefix:\n1977                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n1978             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)\n1979             formset = FormSet(**formset_params)\n1980 \n1981             def user_deleted_form(request, obj, formset, index):\n1982                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n1983                 return (\n1984                     inline.has_delete_permission(request, obj) and\n1985                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST\n1986                 )\n1987 \n1988             # Bypass validation of each view-only inline form (since the form's\n1989             # data won't be in request.POST), unless the form was deleted.\n1990             if not inline.has_change_permission(request, obj if change else None):\n1991                 for index, form in enumerate(formset.initial_forms):\n1992                     if user_deleted_form(request, obj, formset, index):\n1993                         continue\n1994                     form._errors = {}\n1995                     form.cleaned_data = form.initial\n1996             formsets.append(formset)\n1997             inline_instances.append(inline)\n1998         return formsets, inline_instances\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/contrib/admin/views/main.py",
        "start": 1,
        "end": 526,
        "class_name": null,
        "method_name": null,
        "code": "1 from datetime import datetime, timedelta\n2 \n3 from django import forms\n4 from django.conf import settings\n5 from django.contrib import messages\n6 from django.contrib.admin import FieldListFilter\n7 from django.contrib.admin.exceptions import (\n8     DisallowedModelAdminLookup, DisallowedModelAdminToField,\n9 )\n10 from django.contrib.admin.options import (\n11     IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,\n12 )\n13 from django.contrib.admin.utils import (\n14     get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,\n15 )\n16 from django.core.exceptions import (\n17     FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,\n18 )\n19 from django.core.paginator import InvalidPage\n20 from django.db.models import F, Field, ManyToOneRel, OrderBy\n21 from django.db.models.expressions import Combinable\n22 from django.urls import reverse\n23 from django.utils.http import urlencode\n24 from django.utils.timezone import make_aware\n25 from django.utils.translation import gettext\n26 \n27 # Changelist settings\n28 ALL_VAR = 'all'\n29 ORDER_VAR = 'o'\n30 ORDER_TYPE_VAR = 'ot'\n31 PAGE_VAR = 'p'\n32 SEARCH_VAR = 'q'\n33 ERROR_FLAG = 'e'\n34 \n35 IGNORED_PARAMS = (\n36     ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)\n37 \n38 \n39 class ChangeListSearchForm(forms.Form):\n40     def __init__(self, *args, **kwargs):\n41         super().__init__(*args, **kwargs)\n42         # Populate \"fields\" dynamically because SEARCH_VAR is a variable:\n43         self.fields = {\n44             SEARCH_VAR: forms.CharField(required=False, strip=False),\n45         }\n46 \n47 \n48 class ChangeList:\n49     search_form_class = ChangeListSearchForm\n50 \n51     def __init__(self, request, model, list_display, list_display_links,\n52                  list_filter, date_hierarchy, search_fields, list_select_related,\n53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):\n54         self.model = model\n55         self.opts = model._meta\n56         self.lookup_opts = self.opts\n57         self.root_queryset = model_admin.get_queryset(request)\n58         self.list_display = list_display\n59         self.list_display_links = list_display_links\n60         self.list_filter = list_filter\n61         self.has_filters = None\n62         self.has_active_filters = None\n63         self.clear_all_filters_qs = None\n64         self.date_hierarchy = date_hierarchy\n65         self.search_fields = search_fields\n66         self.list_select_related = list_select_related\n67         self.list_per_page = list_per_page\n68         self.list_max_show_all = list_max_show_all\n69         self.model_admin = model_admin\n70         self.preserved_filters = model_admin.get_preserved_filters(request)\n71         self.sortable_by = sortable_by\n72 \n73         # Get search parameters from the query string.\n74         _search_form = self.search_form_class(request.GET)\n75         if not _search_form.is_valid():\n76             for error in _search_form.errors.values():\n77                 messages.error(request, ', '.join(error))\n78         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''\n79         try:\n80             self.page_num = int(request.GET.get(PAGE_VAR, 1))\n81         except ValueError:\n82             self.page_num = 1\n83         self.show_all = ALL_VAR in request.GET\n84         self.is_popup = IS_POPUP_VAR in request.GET\n85         to_field = request.GET.get(TO_FIELD_VAR)\n86         if to_field and not model_admin.to_field_allowed(request, to_field):\n87             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n88         self.to_field = to_field\n89         self.params = dict(request.GET.items())\n90         if PAGE_VAR in self.params:\n91             del self.params[PAGE_VAR]\n92         if ERROR_FLAG in self.params:\n93             del self.params[ERROR_FLAG]\n94 \n95         if self.is_popup:\n96             self.list_editable = ()\n97         else:\n98             self.list_editable = list_editable\n99         self.queryset = self.get_queryset(request)\n100         self.get_results(request)\n101         if self.is_popup:\n102             title = gettext('Select %s')\n103         elif self.model_admin.has_change_permission(request):\n104             title = gettext('Select %s to change')\n105         else:\n106             title = gettext('Select %s to view')\n107         self.title = title % self.opts.verbose_name\n108         self.pk_attname = self.lookup_opts.pk.attname\n109 \n110     def get_filters_params(self, params=None):\n111         \"\"\"\n112         Return all params except IGNORED_PARAMS.\n113         \"\"\"\n114         params = params or self.params\n115         lookup_params = params.copy()  # a dictionary of the query string\n116         # Remove all the parameters that are globally and systematically\n117         # ignored.\n118         for ignored in IGNORED_PARAMS:\n119             if ignored in lookup_params:\n120                 del lookup_params[ignored]\n121         return lookup_params\n122 \n123     def get_filters(self, request):\n124         lookup_params = self.get_filters_params()\n125         use_distinct = False\n126         has_active_filters = False\n127 \n128         for key, value in lookup_params.items():\n129             if not self.model_admin.lookup_allowed(key, value):\n130                 raise DisallowedModelAdminLookup(\"Filtering by %s not allowed\" % key)\n131 \n132         filter_specs = []\n133         for list_filter in self.list_filter:\n134             lookup_params_count = len(lookup_params)\n135             if callable(list_filter):\n136                 # This is simply a custom list filter class.\n137                 spec = list_filter(request, lookup_params, self.model, self.model_admin)\n138             else:\n139                 field_path = None\n140                 if isinstance(list_filter, (tuple, list)):\n141                     # This is a custom FieldListFilter class for a given field.\n142                     field, field_list_filter_class = list_filter\n143                 else:\n144                     # This is simply a field name, so use the default\n145                     # FieldListFilter class that has been registered for the\n146                     # type of the given field.\n147                     field, field_list_filter_class = list_filter, FieldListFilter.create\n148                 if not isinstance(field, Field):\n149                     field_path = field\n150                     field = get_fields_from_path(self.model, field_path)[-1]\n151 \n152                 spec = field_list_filter_class(\n153                     field, request, lookup_params,\n154                     self.model, self.model_admin, field_path=field_path,\n155                 )\n156                 # field_list_filter_class removes any lookup_params it\n157                 # processes. If that happened, check if distinct() is needed to\n158                 # remove duplicate results.\n159                 if lookup_params_count > len(lookup_params):\n160                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)\n161             if spec and spec.has_output():\n162                 filter_specs.append(spec)\n163                 if lookup_params_count > len(lookup_params):\n164                     has_active_filters = True\n165 \n166         if self.date_hierarchy:\n167             # Create bounded lookup parameters so that the query is more\n168             # efficient.\n169             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)\n170             if year is not None:\n171                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)\n172                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)\n173                 try:\n174                     from_date = datetime(\n175                         int(year),\n176                         int(month if month is not None else 1),\n177                         int(day if day is not None else 1),\n178                     )\n179                 except ValueError as e:\n180                     raise IncorrectLookupParameters(e) from e\n181                 if day:\n182                     to_date = from_date + timedelta(days=1)\n183                 elif month:\n184                     # In this branch, from_date will always be the first of a\n185                     # month, so advancing 32 days gives the next month.\n186                     to_date = (from_date + timedelta(days=32)).replace(day=1)\n187                 else:\n188                     to_date = from_date.replace(year=from_date.year + 1)\n189                 if settings.USE_TZ:\n190                     from_date = make_aware(from_date)\n191                     to_date = make_aware(to_date)\n192                 lookup_params.update({\n193                     '%s__gte' % self.date_hierarchy: from_date,\n194                     '%s__lt' % self.date_hierarchy: to_date,\n195                 })\n196 \n197         # At this point, all the parameters used by the various ListFilters\n198         # have been removed from lookup_params, which now only contains other\n199         # parameters passed via the query string. We now loop through the\n200         # remaining parameters both to ensure that all the parameters are valid\n201         # fields and to determine if at least one of them needs distinct(). If\n202         # the lookup parameters aren't real fields, then bail out.\n203         try:\n204             for key, value in lookup_params.items():\n205                 lookup_params[key] = prepare_lookup_value(key, value)\n206                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)\n207             return (\n208                 filter_specs, bool(filter_specs), lookup_params, use_distinct,\n209                 has_active_filters,\n210             )\n211         except FieldDoesNotExist as e:\n212             raise IncorrectLookupParameters(e) from e\n213 \n214     def get_query_string(self, new_params=None, remove=None):\n215         if new_params is None:\n216             new_params = {}\n217         if remove is None:\n218             remove = []\n219         p = self.params.copy()\n220         for r in remove:\n221             for k in list(p):\n222                 if k.startswith(r):\n223                     del p[k]\n224         for k, v in new_params.items():\n225             if v is None:\n226                 if k in p:\n227                     del p[k]\n228             else:\n229                 p[k] = v\n230         return '?%s' % urlencode(sorted(p.items()))\n231 \n232     def get_results(self, request):\n233         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)\n234         # Get the number of objects, with admin filters applied.\n235         result_count = paginator.count\n236 \n237         # Get the total number of objects, with no admin filters applied.\n238         if self.model_admin.show_full_result_count:\n239             full_result_count = self.root_queryset.count()\n240         else:\n241             full_result_count = None\n242         can_show_all = result_count <= self.list_max_show_all\n243         multi_page = result_count > self.list_per_page\n244 \n245         # Get the list of objects to display on this page.\n246         if (self.show_all and can_show_all) or not multi_page:\n247             result_list = self.queryset._clone()\n248         else:\n249             try:\n250                 result_list = paginator.page(self.page_num).object_list\n251             except InvalidPage:\n252                 raise IncorrectLookupParameters\n253 \n254         self.result_count = result_count\n255         self.show_full_result_count = self.model_admin.show_full_result_count\n256         # Admin actions are shown if there is at least one entry\n257         # or if entries are not counted because show_full_result_count is disabled\n258         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)\n259         self.full_result_count = full_result_count\n260         self.result_list = result_list\n261         self.can_show_all = can_show_all\n262         self.multi_page = multi_page\n263         self.paginator = paginator\n264 \n265     def _get_default_ordering(self):\n266         ordering = []\n267         if self.model_admin.ordering:\n268             ordering = self.model_admin.ordering\n269         elif self.lookup_opts.ordering:\n270             ordering = self.lookup_opts.ordering\n271         return ordering\n272 \n273     def get_ordering_field(self, field_name):\n274         \"\"\"\n275         Return the proper model field name corresponding to the given\n276         field_name to use for ordering. field_name may either be the name of a\n277         proper model field or the name of a method (on the admin or model) or a\n278         callable with the 'admin_order_field' attribute. Return None if no\n279         proper model field name can be matched.\n280         \"\"\"\n281         try:\n282             field = self.lookup_opts.get_field(field_name)\n283             return field.name\n284         except FieldDoesNotExist:\n285             # See whether field_name is a name of a non-field\n286             # that allows sorting.\n287             if callable(field_name):\n288                 attr = field_name\n289             elif hasattr(self.model_admin, field_name):\n290                 attr = getattr(self.model_admin, field_name)\n291             else:\n292                 attr = getattr(self.model, field_name)\n293             if isinstance(attr, property) and hasattr(attr, 'fget'):\n294                 attr = attr.fget\n295             return getattr(attr, 'admin_order_field', None)\n296 \n297     def get_ordering(self, request, queryset):\n298         \"\"\"\n299         Return the list of ordering fields for the change list.\n300         First check the get_ordering() method in model admin, then check\n301         the object's default ordering. Then, any manually-specified ordering\n302         from the query string overrides anything. Finally, a deterministic\n303         order is guaranteed by calling _get_deterministic_ordering() with the\n304         constructed ordering.\n305         \"\"\"\n306         params = self.params\n307         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())\n308         if ORDER_VAR in params:\n309             # Clear ordering and used params\n310             ordering = []\n311             order_params = params[ORDER_VAR].split('.')\n312             for p in order_params:\n313                 try:\n314                     none, pfx, idx = p.rpartition('-')\n315                     field_name = self.list_display[int(idx)]\n316                     order_field = self.get_ordering_field(field_name)\n317                     if not order_field:\n318                         continue  # No 'admin_order_field', skip it\n319                     if isinstance(order_field, OrderBy):\n320                         if pfx == '-':\n321                             order_field = order_field.copy()\n322                             order_field.reverse_ordering()\n323                         ordering.append(order_field)\n324                     elif hasattr(order_field, 'resolve_expression'):\n325                         # order_field is an expression.\n326                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())\n327                     # reverse order if order_field has already \"-\" as prefix\n328                     elif order_field.startswith('-') and pfx == '-':\n329                         ordering.append(order_field[1:])\n330                     else:\n331                         ordering.append(pfx + order_field)\n332                 except (IndexError, ValueError):\n333                     continue  # Invalid ordering specified, skip it.\n334 \n335         # Add the given query's ordering fields, if any.\n336         ordering.extend(queryset.query.order_by)\n337 \n338         return self._get_deterministic_ordering(ordering)\n339 \n340     def _get_deterministic_ordering(self, ordering):\n341         \"\"\"\n342         Ensure a deterministic order across all database backends. Search for a\n343         single field or unique together set of fields providing a total\n344         ordering. If these are missing, augment the ordering with a descendant\n345         primary key.\n346         \"\"\"\n347         ordering = list(ordering)\n348         ordering_fields = set()\n349         total_ordering_fields = {'pk'} | {\n350             field.attname for field in self.lookup_opts.fields\n351             if field.unique and not field.null\n352         }\n353         for part in ordering:\n354             # Search for single field providing a total ordering.\n355             field_name = None\n356             if isinstance(part, str):\n357                 field_name = part.lstrip('-')\n358             elif isinstance(part, F):\n359                 field_name = part.name\n360             elif isinstance(part, OrderBy) and isinstance(part.expression, F):\n361                 field_name = part.expression.name\n362             if field_name:\n363                 # Normalize attname references by using get_field().\n364                 try:\n365                     field = self.lookup_opts.get_field(field_name)\n366                 except FieldDoesNotExist:\n367                     # Could be \"?\" for random ordering or a related field\n368                     # lookup. Skip this part of introspection for now.\n369                     continue\n370                 # Ordering by a related field name orders by the referenced\n371                 # model's ordering. Skip this part of introspection for now.\n372                 if field.remote_field and field_name == field.name:\n373                     continue\n374                 if field.attname in total_ordering_fields:\n375                     break\n376                 ordering_fields.add(field.attname)\n377         else:\n378             # No single total ordering field, try unique_together and total\n379             # unique constraints.\n380             constraint_field_names = (\n381                 *self.lookup_opts.unique_together,\n382                 *(\n383                     constraint.fields\n384                     for constraint in self.lookup_opts.total_unique_constraints\n385                 ),\n386             )\n387             for field_names in constraint_field_names:\n388                 # Normalize attname references by using get_field().\n389                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]\n390                 # Composite unique constraints containing a nullable column\n391                 # cannot ensure total ordering.\n392                 if any(field.null for field in fields):\n393                     continue\n394                 if ordering_fields.issuperset(field.attname for field in fields):\n395                     break\n396             else:\n397                 # If no set of unique fields is present in the ordering, rely\n398                 # on the primary key to provide total ordering.\n399                 ordering.append('-pk')\n400         return ordering\n401 \n402     def get_ordering_field_columns(self):\n403         \"\"\"\n404         Return a dictionary of ordering field column numbers and asc/desc.\n405         \"\"\"\n406         # We must cope with more than one column having the same underlying sort\n407         # field, so we base things on column numbers.\n408         ordering = self._get_default_ordering()\n409         ordering_fields = {}\n410         if ORDER_VAR not in self.params:\n411             # for ordering specified on ModelAdmin or model Meta, we don't know\n412             # the right column numbers absolutely, because there might be more\n413             # than one column associated with that ordering, so we guess.\n414             for field in ordering:\n415                 if isinstance(field, (Combinable, OrderBy)):\n416                     if not isinstance(field, OrderBy):\n417                         field = field.asc()\n418                     if isinstance(field.expression, F):\n419                         order_type = 'desc' if field.descending else 'asc'\n420                         field = field.expression.name\n421                     else:\n422                         continue\n423                 elif field.startswith('-'):\n424                     field = field[1:]\n425                     order_type = 'desc'\n426                 else:\n427                     order_type = 'asc'\n428                 for index, attr in enumerate(self.list_display):\n429                     if self.get_ordering_field(attr) == field:\n430                         ordering_fields[index] = order_type\n431                         break\n432         else:\n433             for p in self.params[ORDER_VAR].split('.'):\n434                 none, pfx, idx = p.rpartition('-')\n435                 try:\n436                     idx = int(idx)\n437                 except ValueError:\n438                     continue  # skip it\n439                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'\n440         return ordering_fields\n441 \n442     def get_queryset(self, request):\n443         # First, we collect all the declared list filters.\n444         (\n445             self.filter_specs,\n446             self.has_filters,\n447             remaining_lookup_params,\n448             filters_use_distinct,\n449             self.has_active_filters,\n450         ) = self.get_filters(request)\n451         # Then, we let every list filter modify the queryset to its liking.\n452         qs = self.root_queryset\n453         for filter_spec in self.filter_specs:\n454             new_qs = filter_spec.queryset(request, qs)\n455             if new_qs is not None:\n456                 qs = new_qs\n457 \n458         try:\n459             # Finally, we apply the remaining lookup parameters from the query\n460             # string (i.e. those that haven't already been processed by the\n461             # filters).\n462             qs = qs.filter(**remaining_lookup_params)\n463         except (SuspiciousOperation, ImproperlyConfigured):\n464             # Allow certain types of errors to be re-raised as-is so that the\n465             # caller can treat them in a special way.\n466             raise\n467         except Exception as e:\n468             # Every other error is caught with a naked except, because we don't\n469             # have any other way of validating lookup parameters. They might be\n470             # invalid if the keyword arguments are incorrect, or if the values\n471             # are not in the correct type, so we might get FieldError,\n472             # ValueError, ValidationError, or ?.\n473             raise IncorrectLookupParameters(e)\n474 \n475         if not qs.query.select_related:\n476             qs = self.apply_select_related(qs)\n477 \n478         # Set ordering.\n479         ordering = self.get_ordering(request, qs)\n480         qs = qs.order_by(*ordering)\n481 \n482         # Apply search results\n483         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)\n484 \n485         # Set query string for clearing all filters.\n486         self.clear_all_filters_qs = self.get_query_string(\n487             new_params=remaining_lookup_params,\n488             remove=self.get_filters_params(),\n489         )\n490         # Remove duplicates from results, if necessary\n491         if filters_use_distinct | search_use_distinct:\n492             return qs.distinct()\n493         else:\n494             return qs\n495 \n496     def apply_select_related(self, qs):\n497         if self.list_select_related is True:\n498             return qs.select_related()\n499 \n500         if self.list_select_related is False:\n501             if self.has_related_field_in_list_display():\n502                 return qs.select_related()\n503 \n504         if self.list_select_related:\n505             return qs.select_related(*self.list_select_related)\n506         return qs\n507 \n508     def has_related_field_in_list_display(self):\n509         for field_name in self.list_display:\n510             try:\n511                 field = self.lookup_opts.get_field(field_name)\n512             except FieldDoesNotExist:\n513                 pass\n514             else:\n515                 if isinstance(field.remote_field, ManyToOneRel):\n516                     # <FK>_id field names don't require a join.\n517                     if field_name != field.get_attname():\n518                         return True\n519         return False\n520 \n521     def url_for_result(self, result):\n522         pk = getattr(result, self.pk_attname)\n523         return reverse('admin:%s_%s_change' % (self.opts.app_label,\n524                                                self.opts.model_name),\n525                        args=(quote(pk),),\n526                        current_app=self.model_admin.admin_site.name)\n",
        "intended_behavior": "The code handling search queries in the admin page that involves many-to-many fields (directly or indirectly) needs to ensure that the operations following a search, such as delete, do not fail because of intermediate query modifications like distinct(). Here, the solution might involve reworking how search querysets are prepared or offering an alternative path for delete actions that does not rely on potentially modified querysets containing distinct(). This ensures the admin interface remains robust, supporting both complex searches and bulk actions without leading to exceptions."
    }
]