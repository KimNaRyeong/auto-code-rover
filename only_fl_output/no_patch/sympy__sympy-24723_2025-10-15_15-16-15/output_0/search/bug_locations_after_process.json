[
    {
        "rel_file_path": "sympy/stats/matrix_distributions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.12/sympy/stats/matrix_distributions.py",
        "start": 1,
        "end": 610,
        "class_name": null,
        "method_name": null,
        "code": "1 from math import prod\n2 \n3 from sympy.core.basic import Basic\n4 from sympy.core.numbers import pi\n5 from sympy.core.singleton import S\n6 from sympy.functions.elementary.exponential import exp\n7 from sympy.functions.special.gamma_functions import multigamma\n8 from sympy.core.sympify import sympify, _sympify\n9 from sympy.matrices import (ImmutableMatrix, Inverse, Trace, Determinant,\n10                             MatrixSymbol, MatrixBase, Transpose, MatrixSet,\n11                             matrix2numpy)\n12 from sympy.stats.rv import (_value_check, RandomMatrixSymbol, NamedArgsMixin, PSpace,\n13                             _symbol_converter, MatrixDomain, Distribution)\n14 from sympy.external import import_module\n15 \n16 \n17 ################################################################################\n18 #------------------------Matrix Probability Space------------------------------#\n19 ################################################################################\n20 class MatrixPSpace(PSpace):\n21     \"\"\"\n22     Represents probability space for\n23     Matrix Distributions.\n24     \"\"\"\n25     def __new__(cls, sym, distribution, dim_n, dim_m):\n26         sym = _symbol_converter(sym)\n27         dim_n, dim_m = _sympify(dim_n), _sympify(dim_m)\n28         if not (dim_n.is_integer and dim_m.is_integer):\n29             raise ValueError(\"Dimensions should be integers\")\n30         return Basic.__new__(cls, sym, distribution, dim_n, dim_m)\n31 \n32     distribution = property(lambda self: self.args[1])\n33     symbol = property(lambda self: self.args[0])\n34 \n35     @property\n36     def domain(self):\n37         return MatrixDomain(self.symbol, self.distribution.set)\n38 \n39     @property\n40     def value(self):\n41         return RandomMatrixSymbol(self.symbol, self.args[2], self.args[3], self)\n42 \n43     @property\n44     def values(self):\n45         return {self.value}\n46 \n47     def compute_density(self, expr, *args):\n48         rms = expr.atoms(RandomMatrixSymbol)\n49         if len(rms) > 1 or (not isinstance(expr, RandomMatrixSymbol)):\n50             raise NotImplementedError(\"Currently, no algorithm has been \"\n51                     \"implemented to handle general expressions containing \"\n52                     \"multiple matrix distributions.\")\n53         return self.distribution.pdf(expr)\n54 \n55     def sample(self, size=(), library='scipy', seed=None):\n56         \"\"\"\n57         Internal sample method\n58 \n59         Returns dictionary mapping RandomMatrixSymbol to realization value.\n60         \"\"\"\n61         return {self.value: self.distribution.sample(size, library=library, seed=seed)}\n62 \n63 \n64 def rv(symbol, cls, args):\n65     args = list(map(sympify, args))\n66     dist = cls(*args)\n67     dist.check(*args)\n68     dim = dist.dimension\n69     pspace = MatrixPSpace(symbol, dist, dim[0], dim[1])\n70     return pspace.value\n71 \n72 \n73 class SampleMatrixScipy:\n74     \"\"\"Returns the sample from scipy of the given distribution\"\"\"\n75     def __new__(cls, dist, size, seed=None):\n76         return cls._sample_scipy(dist, size, seed)\n77 \n78     @classmethod\n79     def _sample_scipy(cls, dist, size, seed):\n80         \"\"\"Sample from SciPy.\"\"\"\n81 \n82         from scipy import stats as scipy_stats\n83         import numpy\n84         scipy_rv_map = {\n85             'WishartDistribution': lambda dist, size, rand_state: scipy_stats.wishart.rvs(\n86                 df=int(dist.n), scale=matrix2numpy(dist.scale_matrix, float), size=size),\n87             'MatrixNormalDistribution': lambda dist, size, rand_state: scipy_stats.matrix_normal.rvs(\n88                 mean=matrix2numpy(dist.location_matrix, float),\n89                 rowcov=matrix2numpy(dist.scale_matrix_1, float),\n90                 colcov=matrix2numpy(dist.scale_matrix_2, float), size=size, random_state=rand_state)\n91         }\n92 \n93         sample_shape = {\n94             'WishartDistribution': lambda dist: dist.scale_matrix.shape,\n95             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape\n96         }\n97 \n98         dist_list = scipy_rv_map.keys()\n99 \n100         if dist.__class__.__name__ not in dist_list:\n101             return None\n102 \n103         if seed is None or isinstance(seed, int):\n104             rand_state = numpy.random.default_rng(seed=seed)\n105         else:\n106             rand_state = seed\n107         samp = scipy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)\n108         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))\n109 \n110 \n111 class SampleMatrixNumpy:\n112     \"\"\"Returns the sample from numpy of the given distribution\"\"\"\n113 \n114     ### TODO: Add tests after adding matrix distributions in numpy_rv_map\n115     def __new__(cls, dist, size, seed=None):\n116         return cls._sample_numpy(dist, size, seed)\n117 \n118     @classmethod\n119     def _sample_numpy(cls, dist, size, seed):\n120         \"\"\"Sample from NumPy.\"\"\"\n121 \n122         numpy_rv_map = {\n123         }\n124 \n125         sample_shape = {\n126         }\n127 \n128         dist_list = numpy_rv_map.keys()\n129 \n130         if dist.__class__.__name__ not in dist_list:\n131             return None\n132 \n133         import numpy\n134         if seed is None or isinstance(seed, int):\n135             rand_state = numpy.random.default_rng(seed=seed)\n136         else:\n137             rand_state = seed\n138         samp = numpy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)\n139         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))\n140 \n141 \n142 class SampleMatrixPymc:\n143     \"\"\"Returns the sample from pymc of the given distribution\"\"\"\n144 \n145     def __new__(cls, dist, size, seed=None):\n146         return cls._sample_pymc(dist, size, seed)\n147 \n148     @classmethod\n149     def _sample_pymc(cls, dist, size, seed):\n150         \"\"\"Sample from PyMC.\"\"\"\n151 \n152         try:\n153             import pymc\n154         except ImportError:\n155             import pymc3 as pymc\n156         pymc_rv_map = {\n157             'MatrixNormalDistribution': lambda dist: pymc.MatrixNormal('X',\n158                 mu=matrix2numpy(dist.location_matrix, float),\n159                 rowcov=matrix2numpy(dist.scale_matrix_1, float),\n160                 colcov=matrix2numpy(dist.scale_matrix_2, float),\n161                 shape=dist.location_matrix.shape),\n162             'WishartDistribution': lambda dist: pymc.WishartBartlett('X',\n163                 nu=int(dist.n), S=matrix2numpy(dist.scale_matrix, float))\n164         }\n165 \n166         sample_shape = {\n167             'WishartDistribution': lambda dist: dist.scale_matrix.shape,\n168             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape\n169         }\n170 \n171         dist_list = pymc_rv_map.keys()\n172 \n173         if dist.__class__.__name__ not in dist_list:\n174             return None\n175         import logging\n176         logging.getLogger(\"pymc\").setLevel(logging.ERROR)\n177         with pymc.Model():\n178             pymc_rv_map[dist.__class__.__name__](dist)\n179             samps = pymc.sample(draws=prod(size), chains=1, progressbar=False, random_seed=seed, return_inferencedata=False, compute_convergence_checks=False)['X']\n180         return samps.reshape(size + sample_shape[dist.__class__.__name__](dist))\n181 \n182 _get_sample_class_matrixrv = {\n183     'scipy': SampleMatrixScipy,\n184     'pymc3': SampleMatrixPymc,\n185     'pymc': SampleMatrixPymc,\n186     'numpy': SampleMatrixNumpy\n187 }\n188 \n189 ################################################################################\n190 #-------------------------Matrix Distribution----------------------------------#\n191 ################################################################################\n192 \n193 class MatrixDistribution(Distribution, NamedArgsMixin):\n194     \"\"\"\n195     Abstract class for Matrix Distribution.\n196     \"\"\"\n197     def __new__(cls, *args):\n198         args = [ImmutableMatrix(arg) if isinstance(arg, list)\n199                 else _sympify(arg) for arg in args]\n200         return Basic.__new__(cls, *args)\n201 \n202     @staticmethod\n203     def check(*args):\n204         pass\n205 \n206     def __call__(self, expr):\n207         if isinstance(expr, list):\n208             expr = ImmutableMatrix(expr)\n209         return self.pdf(expr)\n210 \n211     def sample(self, size=(), library='scipy', seed=None):\n212         \"\"\"\n213         Internal sample method\n214 \n215         Returns dictionary mapping RandomSymbol to realization value.\n216         \"\"\"\n217 \n218         libraries = ['scipy', 'numpy', 'pymc3', 'pymc']\n219         if library not in libraries:\n220             raise NotImplementedError(\"Sampling from %s is not supported yet.\"\n221                                         % str(library))\n222         if not import_module(library):\n223             raise ValueError(\"Failed to import %s\" % library)\n224 \n225         samps = _get_sample_class_matrixrv[library](self, size, seed)\n226 \n227         if samps is not None:\n228             return samps\n229         raise NotImplementedError(\n230                 \"Sampling for %s is not currently implemented from %s\"\n231                 % (self.__class__.__name__, library)\n232                 )\n233 \n234 ################################################################################\n235 #------------------------Matrix Distribution Types-----------------------------#\n236 ################################################################################\n237 \n238 #-------------------------------------------------------------------------------\n239 # Matrix Gamma distribution ----------------------------------------------------\n240 \n241 class MatrixGammaDistribution(MatrixDistribution):\n242 \n243     _argnames = ('alpha', 'beta', 'scale_matrix')\n244 \n245     @staticmethod\n246     def check(alpha, beta, scale_matrix):\n247         if not isinstance(scale_matrix, MatrixSymbol):\n248             _value_check(scale_matrix.is_positive_definite, \"The shape \"\n249                 \"matrix must be positive definite.\")\n250         _value_check(scale_matrix.is_square, \"Should \"\n251         \"be square matrix\")\n252         _value_check(alpha.is_positive, \"Shape parameter should be positive.\")\n253         _value_check(beta.is_positive, \"Scale parameter should be positive.\")\n254 \n255     @property\n256     def set(self):\n257         k = self.scale_matrix.shape[0]\n258         return MatrixSet(k, k, S.Reals)\n259 \n260     @property\n261     def dimension(self):\n262         return self.scale_matrix.shape\n263 \n264     def pdf(self, x):\n265         alpha, beta, scale_matrix = self.alpha, self.beta, self.scale_matrix\n266         p = scale_matrix.shape[0]\n267         if isinstance(x, list):\n268             x = ImmutableMatrix(x)\n269         if not isinstance(x, (MatrixBase, MatrixSymbol)):\n270             raise ValueError(\"%s should be an isinstance of Matrix \"\n271                     \"or MatrixSymbol\" % str(x))\n272         sigma_inv_x = - Inverse(scale_matrix)*x / beta\n273         term1 = exp(Trace(sigma_inv_x))/((beta**(p*alpha)) * multigamma(alpha, p))\n274         term2 = (Determinant(scale_matrix))**(-alpha)\n275         term3 = (Determinant(x))**(alpha - S(p + 1)/2)\n276         return term1 * term2 * term3\n277 \n278 def MatrixGamma(symbol, alpha, beta, scale_matrix):\n279     \"\"\"\n280     Creates a random variable with Matrix Gamma Distribution.\n281 \n282     The density of the said distribution can be found at [1].\n283 \n284     Parameters\n285     ==========\n286 \n287     alpha: Positive Real number\n288         Shape Parameter\n289     beta: Positive Real number\n290         Scale Parameter\n291     scale_matrix: Positive definite real square matrix\n292         Scale Matrix\n293 \n294     Returns\n295     =======\n296 \n297     RandomSymbol\n298 \n299     Examples\n300     ========\n301 \n302     >>> from sympy.stats import density, MatrixGamma\n303     >>> from sympy import MatrixSymbol, symbols\n304     >>> a, b = symbols('a b', positive=True)\n305     >>> M = MatrixGamma('M', a, b, [[2, 1], [1, 2]])\n306     >>> X = MatrixSymbol('X', 2, 2)\n307     >>> density(M)(X).doit()\n308     exp(Trace(Matrix([\n309     [-2/3,  1/3],\n310     [ 1/3, -2/3]])*X)/b)*Determinant(X)**(a - 3/2)/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))\n311     >>> density(M)([[1, 0], [0, 1]]).doit()\n312     exp(-4/(3*b))/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))\n313 \n314 \n315     References\n316     ==========\n317 \n318     .. [1] https://en.wikipedia.org/wiki/Matrix_gamma_distribution\n319 \n320     \"\"\"\n321     if isinstance(scale_matrix, list):\n322         scale_matrix = ImmutableMatrix(scale_matrix)\n323     return rv(symbol, MatrixGammaDistribution, (alpha, beta, scale_matrix))\n324 \n325 #-------------------------------------------------------------------------------\n326 # Wishart Distribution ---------------------------------------------------------\n327 \n328 class WishartDistribution(MatrixDistribution):\n329 \n330     _argnames = ('n', 'scale_matrix')\n331 \n332     @staticmethod\n333     def check(n, scale_matrix):\n334         if not isinstance(scale_matrix, MatrixSymbol):\n335             _value_check(scale_matrix.is_positive_definite, \"The shape \"\n336                 \"matrix must be positive definite.\")\n337         _value_check(scale_matrix.is_square, \"Should \"\n338         \"be square matrix\")\n339         _value_check(n.is_positive, \"Shape parameter should be positive.\")\n340 \n341     @property\n342     def set(self):\n343         k = self.scale_matrix.shape[0]\n344         return MatrixSet(k, k, S.Reals)\n345 \n346     @property\n347     def dimension(self):\n348         return self.scale_matrix.shape\n349 \n350     def pdf(self, x):\n351         n, scale_matrix = self.n, self.scale_matrix\n352         p = scale_matrix.shape[0]\n353         if isinstance(x, list):\n354             x = ImmutableMatrix(x)\n355         if not isinstance(x, (MatrixBase, MatrixSymbol)):\n356             raise ValueError(\"%s should be an isinstance of Matrix \"\n357                     \"or MatrixSymbol\" % str(x))\n358         sigma_inv_x = - Inverse(scale_matrix)*x / S(2)\n359         term1 = exp(Trace(sigma_inv_x))/((2**(p*n/S(2))) * multigamma(n/S(2), p))\n360         term2 = (Determinant(scale_matrix))**(-n/S(2))\n361         term3 = (Determinant(x))**(S(n - p - 1)/2)\n362         return term1 * term2 * term3\n363 \n364 def Wishart(symbol, n, scale_matrix):\n365     \"\"\"\n366     Creates a random variable with Wishart Distribution.\n367 \n368     The density of the said distribution can be found at [1].\n369 \n370     Parameters\n371     ==========\n372 \n373     n: Positive Real number\n374         Represents degrees of freedom\n375     scale_matrix: Positive definite real square matrix\n376         Scale Matrix\n377 \n378     Returns\n379     =======\n380 \n381     RandomSymbol\n382 \n383     Examples\n384     ========\n385 \n386     >>> from sympy.stats import density, Wishart\n387     >>> from sympy import MatrixSymbol, symbols\n388     >>> n = symbols('n', positive=True)\n389     >>> W = Wishart('W', n, [[2, 1], [1, 2]])\n390     >>> X = MatrixSymbol('X', 2, 2)\n391     >>> density(W)(X).doit()\n392     exp(Trace(Matrix([\n393     [-1/3,  1/6],\n394     [ 1/6, -1/3]])*X))*Determinant(X)**(n/2 - 3/2)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))\n395     >>> density(W)([[1, 0], [0, 1]]).doit()\n396     exp(-2/3)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))\n397 \n398     References\n399     ==========\n400 \n401     .. [1] https://en.wikipedia.org/wiki/Wishart_distribution\n402 \n403     \"\"\"\n404     if isinstance(scale_matrix, list):\n405         scale_matrix = ImmutableMatrix(scale_matrix)\n406     return rv(symbol, WishartDistribution, (n, scale_matrix))\n407 \n408 #-------------------------------------------------------------------------------\n409 # Matrix Normal distribution ---------------------------------------------------\n410 \n411 class MatrixNormalDistribution(MatrixDistribution):\n412 \n413     _argnames = ('location_matrix', 'scale_matrix_1', 'scale_matrix_2')\n414 \n415     @staticmethod\n416     def check(location_matrix, scale_matrix_1, scale_matrix_2):\n417         if not isinstance(scale_matrix_1, MatrixSymbol):\n418             _value_check(scale_matrix_1.is_positive_definite, \"The shape \"\n419                 \"matrix must be positive definite.\")\n420         if not isinstance(scale_matrix_2, MatrixSymbol):\n421             _value_check(scale_matrix_2.is_positive_definite, \"The shape \"\n422                 \"matrix must be positive definite.\")\n423         _value_check(scale_matrix_1.is_square, \"Scale matrix 1 should be \"\n424         \"be square matrix\")\n425         _value_check(scale_matrix_2.is_square, \"Scale matrix 2 should be \"\n426         \"be square matrix\")\n427         n = location_matrix.shape[0]\n428         p = location_matrix.shape[1]\n429         _value_check(scale_matrix_1.shape[0] == n, \"Scale matrix 1 should be\"\n430         \" of shape %s x %s\"% (str(n), str(n)))\n431         _value_check(scale_matrix_2.shape[0] == p, \"Scale matrix 2 should be\"\n432         \" of shape %s x %s\"% (str(p), str(p)))\n433 \n434     @property\n435     def set(self):\n436         n, p = self.location_matrix.shape\n437         return MatrixSet(n, p, S.Reals)\n438 \n439     @property\n440     def dimension(self):\n441         return self.location_matrix.shape\n442 \n443     def pdf(self, x):\n444         M, U, V = self.location_matrix, self.scale_matrix_1, self.scale_matrix_2\n445         n, p = M.shape\n446         if isinstance(x, list):\n447             x = ImmutableMatrix(x)\n448         if not isinstance(x, (MatrixBase, MatrixSymbol)):\n449             raise ValueError(\"%s should be an isinstance of Matrix \"\n450                     \"or MatrixSymbol\" % str(x))\n451         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)\n452         num = exp(-Trace(term1)/S(2))\n453         den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2\n454         return num/den\n455 \n456 def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):\n457     \"\"\"\n458     Creates a random variable with Matrix Normal Distribution.\n459 \n460     The density of the said distribution can be found at [1].\n461 \n462     Parameters\n463     ==========\n464 \n465     location_matrix: Real ``n x p`` matrix\n466         Represents degrees of freedom\n467     scale_matrix_1: Positive definite matrix\n468         Scale Matrix of shape ``n x n``\n469     scale_matrix_2: Positive definite matrix\n470         Scale Matrix of shape ``p x p``\n471 \n472     Returns\n473     =======\n474 \n475     RandomSymbol\n476 \n477     Examples\n478     ========\n479 \n480     >>> from sympy import MatrixSymbol\n481     >>> from sympy.stats import density, MatrixNormal\n482     >>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])\n483     >>> X = MatrixSymbol('X', 1, 2)\n484     >>> density(M)(X).doit()\n485     2*exp(-Trace((Matrix([\n486     [-1],\n487     [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/pi\n488     >>> density(M)([[3, 4]]).doit()\n489     2*exp(-4)/pi\n490 \n491     References\n492     ==========\n493 \n494     .. [1] https://en.wikipedia.org/wiki/Matrix_normal_distribution\n495 \n496     \"\"\"\n497     if isinstance(location_matrix, list):\n498         location_matrix = ImmutableMatrix(location_matrix)\n499     if isinstance(scale_matrix_1, list):\n500         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)\n501     if isinstance(scale_matrix_2, list):\n502         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)\n503     args = (location_matrix, scale_matrix_1, scale_matrix_2)\n504     return rv(symbol, MatrixNormalDistribution, args)\n505 \n506 #-------------------------------------------------------------------------------\n507 # Matrix Student's T distribution ---------------------------------------------------\n508 \n509 class MatrixStudentTDistribution(MatrixDistribution):\n510 \n511     _argnames = ('nu', 'location_matrix', 'scale_matrix_1', 'scale_matrix_2')\n512 \n513     @staticmethod\n514     def check(nu, location_matrix, scale_matrix_1, scale_matrix_2):\n515         if not isinstance(scale_matrix_1, MatrixSymbol):\n516             _value_check(scale_matrix_1.is_positive_definite != False, \"The shape \"\n517                                                               \"matrix must be positive definite.\")\n518         if not isinstance(scale_matrix_2, MatrixSymbol):\n519             _value_check(scale_matrix_2.is_positive_definite != False, \"The shape \"\n520                                                               \"matrix must be positive definite.\")\n521         _value_check(scale_matrix_1.is_square != False, \"Scale matrix 1 should be \"\n522                                                \"be square matrix\")\n523         _value_check(scale_matrix_2.is_square != False, \"Scale matrix 2 should be \"\n524                                                \"be square matrix\")\n525         n = location_matrix.shape[0]\n526         p = location_matrix.shape[1]\n527         _value_check(scale_matrix_1.shape[0] == p, \"Scale matrix 1 should be\"\n528                                                    \" of shape %s x %s\" % (str(p), str(p)))\n529         _value_check(scale_matrix_2.shape[0] == n, \"Scale matrix 2 should be\"\n530                                                    \" of shape %s x %s\" % (str(n), str(n)))\n531         _value_check(nu.is_positive != False, \"Degrees of freedom must be positive\")\n532 \n533     @property\n534     def set(self):\n535         n, p = self.location_matrix.shape\n536         return MatrixSet(n, p, S.Reals)\n537 \n538     @property\n539     def dimension(self):\n540         return self.location_matrix.shape\n541 \n542     def pdf(self, x):\n543         from sympy.matrices.dense import eye\n544         if isinstance(x, list):\n545             x = ImmutableMatrix(x)\n546         if not isinstance(x, (MatrixBase, MatrixSymbol)):\n547             raise ValueError(\"%s should be an isinstance of Matrix \"\n548                              \"or MatrixSymbol\" % str(x))\n549         nu, M, Omega, Sigma = self.nu, self.location_matrix, self.scale_matrix_1, self.scale_matrix_2\n550         n, p = M.shape\n551 \n552         K = multigamma((nu + n + p - 1)/2, p) * Determinant(Omega)**(-n/2) * Determinant(Sigma)**(-p/2) \\\n553             / ((pi)**(n*p/2) * multigamma((nu + p - 1)/2, p))\n554         return K * (Determinant(eye(n) + Inverse(Sigma)*(x - M)*Inverse(Omega)*Transpose(x - M))) \\\n555                **(-(nu + n + p -1)/2)\n556 \n557 \n558 \n559 def MatrixStudentT(symbol, nu, location_matrix, scale_matrix_1, scale_matrix_2):\n560     \"\"\"\n561     Creates a random variable with Matrix Gamma Distribution.\n562 \n563     The density of the said distribution can be found at [1].\n564 \n565     Parameters\n566     ==========\n567 \n568     nu: Positive Real number\n569         degrees of freedom\n570     location_matrix: Positive definite real square matrix\n571         Location Matrix of shape ``n x p``\n572     scale_matrix_1: Positive definite real square matrix\n573         Scale Matrix of shape ``p x p``\n574     scale_matrix_2: Positive definite real square matrix\n575         Scale Matrix of shape ``n x n``\n576 \n577     Returns\n578     =======\n579 \n580     RandomSymbol\n581 \n582     Examples\n583     ========\n584 \n585     >>> from sympy import MatrixSymbol,symbols\n586     >>> from sympy.stats import density, MatrixStudentT\n587     >>> v = symbols('v',positive=True)\n588     >>> M = MatrixStudentT('M', v, [[1, 2]], [[1, 0], [0, 1]], [1])\n589     >>> X = MatrixSymbol('X', 1, 2)\n590     >>> density(M)(X)\n591     gamma(v/2 + 1)*Determinant((Matrix([[-1, -2]]) + X)*(Matrix([\n592     [-1],\n593     [-2]]) + X.T) + Matrix([[1]]))**(-v/2 - 1)/(pi**1.0*gamma(v/2)*Determinant(Matrix([[1]]))**1.0*Determinant(Matrix([\n594     [1, 0],\n595     [0, 1]]))**0.5)\n596 \n597     References\n598     ==========\n599 \n600     .. [1] https://en.wikipedia.org/wiki/Matrix_t-distribution\n601 \n602     \"\"\"\n603     if isinstance(location_matrix, list):\n604         location_matrix = ImmutableMatrix(location_matrix)\n605     if isinstance(scale_matrix_1, list):\n606         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)\n607     if isinstance(scale_matrix_2, list):\n608         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)\n609     args = (nu, location_matrix, scale_matrix_1, scale_matrix_2)\n610     return rv(symbol, MatrixStudentTDistribution, args)\n",
        "intended_behavior": "The intended behavior of the code at this location is to accurately compute the probability density function (PDF) for the `MatrixNormal` distribution according to its mathematical definition. Specifically, the issue points out an incorrect constant in the denominator of the PDF expression. The correct formula, as per the issue description and mathematical standards, should incorporate a constant that correctly reflects the dimensions of matrices involved and matches the formula specified on the referenced Wikipedia page. The correction should ensure that the constant in the denominator aligns with the \\(2\\pi\\) (for each variable in the matrix) component of the formula, which may require adjusting how the determinant and trace operations contribute to the formula, especially in their relationship to the exponential component. This adjustment will not only rectify the reported issue but also preserve the existing functionality by ensuring that the PDF computation remains accurate for any given parameters of a `MatrixNormal` distribution. The exact correction would involve revising the computation of the normalization constant in the PDF expression to ensure it accurately represents the mathematical formula for any dimensionality of the input matrices."
    }
]