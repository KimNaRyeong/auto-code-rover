2025-10-15 07:50:12.000 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:50:16.025 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=12, cost=0.004520
2025-10-15 07:50:16.026 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 07:50:16.029 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:50:22.163 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=230, cost=0.013910
2025-10-15 07:50:22.167 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:50:25.093 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=38, cost=0.006980
2025-10-15 07:50:25.094 | DEBUG    | Extracted a valid json.
2025-10-15 07:50:25.094 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"imshow\")",
        "search_method_in_class(\"set_aspect\", \"Axes\")"
    ],
    "bug_locations": []
}
2025-10-15 07:50:25.175 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:50:25.176 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:50:42.785 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7020, output_tokens=765, cost=0.093150
2025-10-15 07:50:42.800 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:50:52.533 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8001, output_tokens=273, cost=0.088200
2025-10-15 07:50:52.539 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:51:02.503 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=627, output_tokens=252, cost=0.013830
2025-10-15 07:51:02.504 | DEBUG    | Extracted a valid json.
2025-10-15 07:51:02.504 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Axes\")",
        "search_method_in_file(\"set_aspect\", \"lib/matplotlib/axes/_base.py\")"
    ],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "imshow",
            "intended_behavior": "The method `imshow` should consider the `transform` parameter when setting the aspect ratio of the image. The current behavior automatically applies the aspect ratio based on `mpl.rcParams['image.aspect']` when `aspect` is `None`, defaulting to `'equal'` which makes pixels square. The intended behavior is to modify this logic to check if a custom `transform` is provided and, if so, to avoid modifying the aspect ratio unless explicitly requested by the user. This change should preserve the existing functionality where the transform is the default (`ax.transData`), thus not altering the behavior for existing code that relies on this method without specifying a custom transform. The modification should specifically target scenarios where a transform other than `ax.transData` is used, in which case the automatic assumption of square pixels might not be appropriate."
        }
    ]
}
2025-10-15 07:51:02.615 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:51:02.616 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:51:23.352 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=13747, output_tokens=617, cost=0.155980
2025-10-15 07:51:23.365 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:51:34.812 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14580, output_tokens=361, cost=0.156630
2025-10-15 07:51:34.819 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:51:45.158 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=715, output_tokens=382, cost=0.018610
2025-10-15 07:51:45.159 | DEBUG    | Extracted a valid json.
2025-10-15 07:51:45.159 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "imshow",
            "intended_behavior": "The `imshow` method should include logic to assess if a custom `transform` is provided that is different from the default `ax.transData`. If such a custom `transform` is detected, the method of setting the aspect ratio (either through direct calls to `set_aspect` or through the logic that leads to its invocation) should be modulated to ensure that it does not enforce an aspect control that assumes square pixels by default. This means the aspect ratio should only be adjusted if explicitly requested by the user in the context of a custom transform. The method should preserve its current functionality for cases where the `transform` is set to `ax.transData` or not provided by the user, thus maintaining backward compatibility and expected behavior in standard usage scenarios."
        },
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "_AxesBase",
            "method": "set_aspect",
            "intended_behavior": "While the core functionality of `set_aspect` does not inherently contain a bug related to the issue, an enhancement could be considered to support conditional aspect ratio adjustments based on additional context (such as transformation information). This would potentially involve expanding the method signature to accept a new parameter indicating whether the aspect ratio setting should be conditional on the type of transformation applied. However, this approach would require careful consideration to ensure compatibility with the existing codebase and would likely involve adjustments upstream (e.g., in how `imshow` invokes `set_aspect`) to pass down the necessary context. The primary modification remains in how `imshow` interacts with this method rather than changing `set_aspect` itself."
        }
    ]
}
2025-10-15 07:51:45.198 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>imshow</method>
<code>
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im

</code><intended_behavior>The `imshow` method should include logic to assess if a custom `transform` is provided that is different from the default `ax.transData`. If such a custom `transform` is detected, the method of setting the aspect ratio (either through direct calls to `set_aspect` or through the logic that leads to its invocation) should be modulated to ensure that it does not enforce an aspect control that assumes square pixels by default. This means the aspect ratio should only be adjusted if explicitly requested by the user in the context of a custom transform. The method should preserve its current functionality for cases where the `transform` is set to `ax.transData` or not provided by the user, thus maintaining backward compatibility and expected behavior in standard usage scenarios.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `~matplotlib.text.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, kwargs = mlegend._parse_legend_args([self], *args, **kwargs)
320         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
321         self.legend_._remove_method = self._remove_legend
322         return self.legend_
323 
324     def _remove_legend(self, legend):
325         self.legend_ = None
326 
327     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
328         """
329         Add a child inset Axes to this existing Axes.
330 
331         Warnings
332         --------
333         This method is experimental as of 3.0, and the API may change.
334 
335         Parameters
336         ----------
337         bounds : [x0, y0, width, height]
338             Lower-left corner of inset Axes, and its width and height.
339 
340         transform : `.Transform`
341             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
342             Axes-relative coordinates.
343 
344         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
345 'polar', 'rectilinear', str}, optional
346             The projection type of the inset `~.axes.Axes`. *str* is the name
347             of a custom projection, see `~matplotlib.projections`. The default
348             None results in a 'rectilinear' projection.
349 
350         polar : bool, default: False
351             If True, equivalent to projection='polar'.
352 
353         axes_class : subclass type of `~.axes.Axes`, optional
354             The `.axes.Axes` subclass that is instantiated.  This parameter
355             is incompatible with *projection* and *polar*.  See
356             :ref:`axisartist_users-guide-index` for examples.
357 
358         zorder : number
359             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
360             to change whether it is above or below data plotted on the
361             parent Axes.
362 
363         **kwargs
364             Other keyword arguments are passed on to the inset Axes class.
365 
366         Returns
367         -------
368         ax
369             The created `~.axes.Axes` instance.
370 
371         Examples
372         --------
373         This example makes two inset Axes, the first is in Axes-relative
374         coordinates, and the second in data-coordinates::
375 
376             fig, ax = plt.subplots()
377             ax.plot(range(10))
378             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
379             axin2 = ax.inset_axes(
380                     [5, 7, 2.3, 2.3], transform=ax.transData)
381 
382         """
383         if transform is None:
384             transform = self.transAxes
385         kwargs.setdefault('label', 'inset_axes')
386 
387         # This puts the rectangle into figure-relative coordinates.
388         inset_locator = _TransformedBoundsLocator(bounds, transform)
389         bounds = inset_locator(self, None).bounds
390         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
391         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
392 
393         # this locator lets the axes move if in data coordinates.
394         # it gets called in `ax.apply_aspect() (of all places)
395         inset_ax.set_axes_locator(inset_locator)
396 
397         self.add_child_axes(inset_ax)
398 
399         return inset_ax
400 
401     @_docstring.dedent_interpd
402     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
403                        facecolor='none', edgecolor='0.5', alpha=0.5,
404                        zorder=4.99, **kwargs):
405         """
406         Add an inset indicator to the Axes.  This is a rectangle on the plot
407         at the position indicated by *bounds* that optionally has lines that
408         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
409 
410         Warnings
411         --------
412         This method is experimental as of 3.0, and the API may change.
413 
414         Parameters
415         ----------
416         bounds : [x0, y0, width, height]
417             Lower-left corner of rectangle to be marked, and its width
418             and height.
419 
420         inset_ax : `.Axes`
421             An optional inset Axes to draw connecting lines to.  Two lines are
422             drawn connecting the indicator box to the inset Axes on corners
423             chosen so as to not overlap with the indicator box.
424 
425         transform : `.Transform`
426             Transform for the rectangle coordinates. Defaults to
427             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
428             coordinates.
429 
430         facecolor : color, default: 'none'
431             Facecolor of the rectangle.
432 
433         edgecolor : color, default: '0.5'
434             Color of the rectangle and color of the connecting lines.
435 
436         alpha : float, default: 0.5
437             Transparency of the rectangle and connector lines.
438 
439         zorder : float, default: 4.99
440             Drawing order of the rectangle and connector lines.  The default,
441             4.99, is just below the default level of inset Axes.
442 
443         **kwargs
444             Other keyword arguments are passed on to the `.Rectangle` patch:
445 
446             %(Rectangle:kwdoc)s
447 
448         Returns
449         -------
450         rectangle_patch : `.patches.Rectangle`
451              The indicator frame.
452 
453         connector_lines : 4-tuple of `.patches.ConnectionPatch`
454             The four connector lines connecting to (lower_left, upper_left,
455             lower_right upper_right) corners of *inset_ax*. Two lines are
456             set with visibility to *False*,  but the user can set the
457             visibility to True if the automatic choice is not deemed correct.
458 
459         """
460         # to make the axes connectors work, we need to apply the aspect to
461         # the parent axes.
462         self.apply_aspect()
463 
464         if transform is None:
465             transform = self.transData
466         kwargs.setdefault('label', '_indicate_inset')
467 
468         x, y, width, height = bounds
469         rectangle_patch = mpatches.Rectangle(
470             (x, y), width, height,
471             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
472             zorder=zorder, transform=transform, **kwargs)
473         self.add_patch(rectangle_patch)
474 
475         connects = []
476 
477         if inset_ax is not None:
478             # connect the inset_axes to the rectangle
479             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
480                 # inset_ax positions are in axes coordinates
481                 # The 0, 1 values define the four edges if the inset_ax
482                 # lower_left, upper_left, lower_right upper_right.
483                 ex, ey = xy_inset_ax
484                 if self.xaxis.get_inverted():
485                     ex = 1 - ex
486                 if self.yaxis.get_inverted():
487                     ey = 1 - ey
488                 xy_data = x + ex * width, y + ey * height
489                 p = mpatches.ConnectionPatch(
490                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
491                     xyB=xy_data, coordsB=self.transData,
492                     arrowstyle="-", zorder=zorder,
493                     edgecolor=edgecolor, alpha=alpha)
494                 connects.append(p)
495                 self.add_patch(p)
496 
497             # decide which two of the lines to keep visible....
498             pos = inset_ax.get_position()
499             bboxins = pos.transformed(self.figure.transSubfigure)
500             rectbbox = mtransforms.Bbox.from_bounds(
501                 *bounds
502             ).transformed(transform)
503             x0 = rectbbox.x0 < bboxins.x0
504             x1 = rectbbox.x1 < bboxins.x1
505             y0 = rectbbox.y0 < bboxins.y0
506             y1 = rectbbox.y1 < bboxins.y1
507             connects[0].set_visible(x0 ^ y0)
508             connects[1].set_visible(x0 == y1)
509             connects[2].set_visible(x1 == y0)
510             connects[3].set_visible(x1 ^ y1)
511 
512         return rectangle_patch, tuple(connects) if connects else None
513 
514     def indicate_inset_zoom(self, inset_ax, **kwargs):
515         """
516         Add an inset indicator rectangle to the Axes based on the axis
517         limits for an *inset_ax* and draw connectors between *inset_ax*
518         and the rectangle.
519 
520         Warnings
521         --------
522         This method is experimental as of 3.0, and the API may change.
523 
524         Parameters
525         ----------
526         inset_ax : `.Axes`
527             Inset Axes to draw connecting lines to.  Two lines are
528             drawn connecting the indicator box to the inset Axes on corners
529             chosen so as to not overlap with the indicator box.
530 
531         **kwargs
532             Other keyword arguments are passed on to `.Axes.indicate_inset`
533 
534         Returns
535         -------
536         rectangle_patch : `.patches.Rectangle`
537              Rectangle artist.
538 
539         connector_lines : 4-tuple of `.patches.ConnectionPatch`
540             Each of four connector lines coming from the rectangle drawn on
541             this axis, in the order lower left, upper left, lower right,
542             upper right.
543             Two are set with visibility to *False*,  but the user can
544             set the visibility to *True* if the automatic choice is not deemed
545             correct.
546         """
547 
548         xlim = inset_ax.get_xlim()
549         ylim = inset_ax.get_ylim()
550         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
551         return self.indicate_inset(rect, inset_ax, **kwargs)
552 
553     @_docstring.dedent_interpd
554     def secondary_xaxis(self, location, *, functions=None, **kwargs):
555         """
556         Add a second x-axis to this `~.axes.Axes`.
557 
558         For example if we want to have a second scale for the data plotted on
559         the xaxis.
560 
561         %(_secax_docstring)s
562 
563         Examples
564         --------
565         The main axis shows frequency, and the secondary axis shows period.
566 
567         .. plot::
568 
569             fig, ax = plt.subplots()
570             ax.loglog(range(1, 360, 5), range(1, 360, 5))
571             ax.set_xlabel('frequency [Hz]')
572 
573             def invert(x):
574                 # 1/x with special treatment of x == 0
575                 x = np.array(x).astype(float)
576                 near_zero = np.isclose(x, 0)
577                 x[near_zero] = np.inf
578                 x[~near_zero] = 1 / x[~near_zero]
579                 return x
580 
581             # the inverse of 1/x is itself
582             secax = ax.secondary_xaxis('top', functions=(invert, invert))
583             secax.set_xlabel('Period [s]')
584             plt.show()
585         """
586         if location in ['top', 'bottom'] or isinstance(location, Real):
587             secondary_ax = SecondaryAxis(self, 'x', location, functions,
588                                          **kwargs)
589             self.add_child_axes(secondary_ax)
590             return secondary_ax
591         else:
592             raise ValueError('secondary_xaxis location must be either '
593                              'a float or "top"/"bottom"')
594 
595     @_docstring.dedent_interpd
596     def secondary_yaxis(self, location, *, functions=None, **kwargs):
597         """
598         Add a second y-axis to this `~.axes.Axes`.
599 
600         For example if we want to have a second scale for the data plotted on
601         the yaxis.
602 
603         %(_secax_docstring)s
604 
605         Examples
606         --------
607         Add a secondary Axes that converts from radians to degrees
608 
609         .. plot::
610 
611             fig, ax = plt.subplots()
612             ax.plot(range(1, 360, 5), range(1, 360, 5))
613             ax.set_ylabel('degrees')
614             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
615                                                            np.rad2deg))
616             secax.set_ylabel('radians')
617         """
618         if location in ['left', 'right'] or isinstance(location, Real):
619             secondary_ax = SecondaryAxis(self, 'y', location,
620                                          functions, **kwargs)
621             self.add_child_axes(secondary_ax)
622             return secondary_ax
623         else:
624             raise ValueError('secondary_yaxis location must be either '
625                              'a float or "left"/"right"')
626 
627     @_docstring.dedent_interpd
628     def text(self, x, y, s, fontdict=None, **kwargs):
629         """
630         Add text to the Axes.
631 
632         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
633 
634         Parameters
635         ----------
636         x, y : float
637             The position to place the text. By default, this is in data
638             coordinates. The coordinate system can be changed using the
639             *transform* parameter.
640 
641         s : str
642             The text.
643 
644         fontdict : dict, default: None
645 
646             .. admonition:: Discouraged
647 
648                The use of *fontdict* is discouraged. Parameters should be passed as
649                individual keyword arguments or using dictionary-unpacking
650                ``text(..., **fontdict)``.
651 
652             A dictionary to override the default text properties. If fontdict
653             is None, the defaults are determined by `.rcParams`.
654 
655         Returns
656         -------
657         `.Text`
658             The created `.Text` instance.
659 
660         Other Parameters
661         ----------------
662         **kwargs : `~matplotlib.text.Text` properties.
663             Other miscellaneous text parameters.
664 
665             %(Text:kwdoc)s
666 
667         Examples
668         --------
669         Individual keyword arguments can be used to override any given
670         parameter::
671 
672             >>> text(x, y, s, fontsize=12)
673 
674         The default transform specifies that text is in data coords,
675         alternatively, you can specify text in axis coords ((0, 0) is
676         lower-left and (1, 1) is upper-right).  The example below places
677         text in the center of the Axes::
678 
679             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
680             ...      verticalalignment='center', transform=ax.transAxes)
681 
682         You can put a rectangular box around the text instance (e.g., to
683         set a background color) by using the keyword *bbox*.  *bbox* is
684         a dictionary of `~matplotlib.patches.Rectangle`
685         properties.  For example::
686 
687             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
688         """
689         effective_kwargs = {
690             'verticalalignment': 'baseline',
691             'horizontalalignment': 'left',
692             'transform': self.transData,
693             'clip_on': False,
694             **(fontdict if fontdict is not None else {}),
695             **kwargs,
696         }
697         t = mtext.Text(x, y, text=s, **effective_kwargs)
698         if t.get_clip_path() is None:
699             t.set_clip_path(self.patch)
700         self._add_text(t)
701         return t
702 
703     @_docstring.dedent_interpd
704     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
705                  arrowprops=None, annotation_clip=None, **kwargs):
706         # Signature must match Annotation. This is verified in
707         # test_annotate_signature().
708         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
709                              textcoords=textcoords, arrowprops=arrowprops,
710                              annotation_clip=annotation_clip, **kwargs)
711         a.set_transform(mtransforms.IdentityTransform())
712         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
713             a.set_clip_path(self.patch)
714         self._add_text(a)
715         return a
716     annotate.__doc__ = mtext.Annotation.__init__.__doc__
717     #### Lines and spans
718 
719     @_docstring.dedent_interpd
720     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
721         """
722         Add a horizontal line across the Axes.
723 
724         Parameters
725         ----------
726         y : float, default: 0
727             y position in data coordinates of the horizontal line.
728 
729         xmin : float, default: 0
730             Should be between 0 and 1, 0 being the far left of the plot, 1 the
731             far right of the plot.
732 
733         xmax : float, default: 1
734             Should be between 0 and 1, 0 being the far left of the plot, 1 the
735             far right of the plot.
736 
737         Returns
738         -------
739         `~matplotlib.lines.Line2D`
740 
741         Other Parameters
742         ----------------
743         **kwargs
744             Valid keyword arguments are `.Line2D` properties, except for
745             'transform':
746 
747             %(Line2D:kwdoc)s
748 
749         See Also
750         --------
751         hlines : Add horizontal lines in data coordinates.
752         axhspan : Add a horizontal span (rectangle) across the axis.
753         axline : Add a line with an arbitrary slope.
754 
755         Examples
756         --------
757         * draw a thick red hline at 'y' = 0 that spans the xrange::
758 
759             >>> axhline(linewidth=4, color='r')
760 
761         * draw a default hline at 'y' = 1 that spans the xrange::
762 
763             >>> axhline(y=1)
764 
765         * draw a default hline at 'y' = .5 that spans the middle half of
766           the xrange::
767 
768             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
769         """
770         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
771         if "transform" in kwargs:
772             raise ValueError("'transform' is not allowed as a keyword "
773                              "argument; axhline generates its own transform.")
774         ymin, ymax = self.get_ybound()
775 
776         # Strip away the units for comparison with non-unitized bounds.
777         yy, = self._process_unit_info([("y", y)], kwargs)
778         scaley = (yy < ymin) or (yy > ymax)
779 
780         trans = self.get_yaxis_transform(which='grid')
781         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
782         self.add_line(l)
783         if scaley:
784             self._request_autoscale_view("y")
785         return l
786 
787     @_docstring.dedent_interpd
788     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
789         """
790         Add a vertical line across the Axes.
791 
792         Parameters
793         ----------
794         x : float, default: 0
795             x position in data coordinates of the vertical line.
796 
797         ymin : float, default: 0
798             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
799             top of the plot.
800 
801         ymax : float, default: 1
802             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
803             top of the plot.
804 
805         Returns
806         -------
807         `~matplotlib.lines.Line2D`
808 
809         Other Parameters
810         ----------------
811         **kwargs
812             Valid keyword arguments are `.Line2D` properties, except for
813             'transform':
814 
815             %(Line2D:kwdoc)s
816 
817         See Also
818         --------
819         vlines : Add vertical lines in data coordinates.
820         axvspan : Add a vertical span (rectangle) across the axis.
821         axline : Add a line with an arbitrary slope.
822 
823         Examples
824         --------
825         * draw a thick red vline at *x* = 0 that spans the yrange::
826 
827             >>> axvline(linewidth=4, color='r')
828 
829         * draw a default vline at *x* = 1 that spans the yrange::
830 
831             >>> axvline(x=1)
832 
833         * draw a default vline at *x* = .5 that spans the middle half of
834           the yrange::
835 
836             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
837         """
838         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
839         if "transform" in kwargs:
840             raise ValueError("'transform' is not allowed as a keyword "
841                              "argument; axvline generates its own transform.")
842         xmin, xmax = self.get_xbound()
843 
844         # Strip away the units for comparison with non-unitized bounds.
845         xx, = self._process_unit_info([("x", x)], kwargs)
846         scalex = (xx < xmin) or (xx > xmax)
847 
848         trans = self.get_xaxis_transform(which='grid')
849         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
850         self.add_line(l)
851         if scalex:
852             self._request_autoscale_view("x")
853         return l
854 
855     @staticmethod
856     def _check_no_units(vals, names):
857         # Helper method to check that vals are not unitized
858         for val, name in zip(vals, names):
859             if not munits._is_natively_supported(val):
860                 raise ValueError(f"{name} must be a single scalar value, "
861                                  f"but got {val}")
862 
863     @_docstring.dedent_interpd
864     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
865         """
866         Add an infinitely long straight line.
867 
868         The line can be defined either by two points *xy1* and *xy2*, or
869         by one point *xy1* and a *slope*.
870 
871         This draws a straight line "on the screen", regardless of the x and y
872         scales, and is thus also suitable for drawing exponential decays in
873         semilog plots, power laws in loglog plots, etc. However, *slope*
874         should only be used with linear scales; It has no clear meaning for
875         all other scales, and thus the behavior is undefined. Please specify
876         the line using the points *xy1*, *xy2* for non-linear scales.
877 
878         The *transform* keyword argument only applies to the points *xy1*,
879         *xy2*. The *slope* (if given) is always in data coordinates. This can
880         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
881         slope.
882 
883         Parameters
884         ----------
885         xy1, xy2 : (float, float)
886             Points for the line to pass through.
887             Either *xy2* or *slope* has to be given.
888         slope : float, optional
889             The slope of the line. Either *xy2* or *slope* has to be given.
890 
891         Returns
892         -------
893         `.Line2D`
894 
895         Other Parameters
896         ----------------
897         **kwargs
898             Valid kwargs are `.Line2D` properties
899 
900             %(Line2D:kwdoc)s
901 
902         See Also
903         --------
904         axhline : for horizontal lines
905         axvline : for vertical lines
906 
907         Examples
908         --------
909         Draw a thick red line passing through (0, 0) and (1, 1)::
910 
911             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
912         """
913         if slope is not None and (self.get_xscale() != 'linear' or
914                                   self.get_yscale() != 'linear'):
915             raise TypeError("'slope' cannot be used with non-linear scales")
916 
917         datalim = [xy1] if xy2 is None else [xy1, xy2]
918         if "transform" in kwargs:
919             # if a transform is passed (i.e. line points not in data space),
920             # data limits should not be adjusted.
921             datalim = []
922 
923         line = mlines.AxLine(xy1, xy2, slope, **kwargs)
924         # Like add_line, but correctly handling data limits.
925         self._set_artist_props(line)
926         if line.get_clip_path() is None:
927             line.set_clip_path(self.patch)
928         if not line.get_label():
929             line.set_label(f"_child{len(self._children)}")
930         self._children.append(line)
931         line._remove_method = self._children.remove
932         self.update_datalim(datalim)
933 
934         self._request_autoscale_view()
935         return line
936 
937     @_docstring.dedent_interpd
938     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
939         """
940         Add a horizontal span (rectangle) across the Axes.
941 
942         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
943         the whole x-axis horizontally.  The x-span can be set using *xmin*
944         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
945         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
946         the limits set by `~.Axes.set_xlim`.
947 
948         Parameters
949         ----------
950         ymin : float
951             Lower y-coordinate of the span, in data units.
952         ymax : float
953             Upper y-coordinate of the span, in data units.
954         xmin : float, default: 0
955             Lower x-coordinate of the span, in x-axis (0-1) units.
956         xmax : float, default: 1
957             Upper x-coordinate of the span, in x-axis (0-1) units.
958 
959         Returns
960         -------
961         `~matplotlib.patches.Polygon`
962             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
963 
964         Other Parameters
965         ----------------
966         **kwargs : `~matplotlib.patches.Polygon` properties
967 
968         %(Polygon:kwdoc)s
969 
970         See Also
971         --------
972         axvspan : Add a vertical span across the Axes.
973         """
974         # Strip units away.
975         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
976         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
977 
978         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
979         p = mpatches.Polygon(verts, **kwargs)
980         p.set_transform(self.get_yaxis_transform(which="grid"))
981         self.add_patch(p)
982         self._request_autoscale_view("y")
983         return p
984 
985     @_docstring.dedent_interpd
986     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
987         """
988         Add a vertical span (rectangle) across the Axes.
989 
990         The rectangle spans from *xmin* to *xmax* horizontally, and, by
991         default, the whole y-axis vertically.  The y-span can be set using
992         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
993         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
994         regardless of the limits set by `~.Axes.set_ylim`.
995 
996         Parameters
997         ----------
998         xmin : float
999             Lower x-coordinate of the span, in data units.
1000         xmax : float
1001             Upper x-coordinate of the span, in data units.
1002         ymin : float, default: 0
1003             Lower y-coordinate of the span, in y-axis units (0-1).
1004         ymax : float, default: 1
1005             Upper y-coordinate of the span, in y-axis units (0-1).
1006 
1007         Returns
1008         -------
1009         `~matplotlib.patches.Polygon`
1010             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1011 
1012         Other Parameters
1013         ----------------
1014         **kwargs : `~matplotlib.patches.Polygon` properties
1015 
1016         %(Polygon:kwdoc)s
1017 
1018         See Also
1019         --------
1020         axhspan : Add a horizontal span across the Axes.
1021 
1022         Examples
1023         --------
1024         Draw a vertical, green, translucent rectangle from x = 1.25 to
1025         x = 1.55 that spans the yrange of the Axes.
1026 
1027         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1028 
1029         """
1030         # Strip units away.
1031         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1032         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1033 
1034         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1035         p = mpatches.Polygon(verts, **kwargs)
1036         p.set_transform(self.get_xaxis_transform(which="grid"))
1037         p.get_path()._interpolation_steps = 100
1038         self.add_patch(p)
1039         self._request_autoscale_view("x")
1040         return p
1041 
1042     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1043                       label_namer="y")
1044     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1045                label='', **kwargs):
1046         """
1047         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1048 
1049         Parameters
1050         ----------
1051         y : float or array-like
1052             y-indexes where to plot the lines.
1053 
1054         xmin, xmax : float or array-like
1055             Respective beginning and end of each line. If scalars are
1056             provided, all lines will have the same length.
1057 
1058         colors : color or list of colors, default: :rc:`lines.color`
1059 
1060         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1061 
1062         label : str, default: ''
1063 
1064         Returns
1065         -------
1066         `~matplotlib.collections.LineCollection`
1067 
1068         Other Parameters
1069         ----------------
1070         data : indexable object, optional
1071             DATA_PARAMETER_PLACEHOLDER
1072         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1073 
1074         See Also
1075         --------
1076         vlines : vertical lines
1077         axhline : horizontal line across the Axes
1078         """
1079 
1080         # We do the conversion first since not all unitized data is uniform
1081         xmin, xmax, y = self._process_unit_info(
1082             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1083 
1084         if not np.iterable(y):
1085             y = [y]
1086         if not np.iterable(xmin):
1087             xmin = [xmin]
1088         if not np.iterable(xmax):
1089             xmax = [xmax]
1090 
1091         # Create and combine masked_arrays from input
1092         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1093         y = np.ravel(y)
1094         xmin = np.ravel(xmin)
1095         xmax = np.ravel(xmax)
1096 
1097         masked_verts = np.ma.empty((len(y), 2, 2))
1098         masked_verts[:, 0, 0] = xmin
1099         masked_verts[:, 0, 1] = y
1100         masked_verts[:, 1, 0] = xmax
1101         masked_verts[:, 1, 1] = y
1102 
1103         lines = mcoll.LineCollection(masked_verts, colors=colors,
1104                                      linestyles=linestyles, label=label)
1105         self.add_collection(lines, autolim=False)
1106         lines._internal_update(kwargs)
1107 
1108         if len(y) > 0:
1109             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1110             # the case of y being a masked *object* array (as can be generated
1111             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1112             updatex = True
1113             updatey = True
1114             if self.name == "rectilinear":
1115                 datalim = lines.get_datalim(self.transData)
1116                 t = lines.get_transform()
1117                 updatex, updatey = t.contains_branch_seperately(self.transData)
1118                 minx = np.nanmin(datalim.xmin)
1119                 maxx = np.nanmax(datalim.xmax)
1120                 miny = np.nanmin(datalim.ymin)
1121                 maxy = np.nanmax(datalim.ymax)
1122             else:
1123                 minx = np.nanmin(masked_verts[..., 0])
1124                 maxx = np.nanmax(masked_verts[..., 0])
1125                 miny = np.nanmin(masked_verts[..., 1])
1126                 maxy = np.nanmax(masked_verts[..., 1])
1127 
1128             corners = (minx, miny), (maxx, maxy)
1129             self.update_datalim(corners, updatex, updatey)
1130             self._request_autoscale_view()
1131         return lines
1132 
1133     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1134                       label_namer="x")
1135     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1136                label='', **kwargs):
1137         """
1138         Plot vertical lines at each *x* from *ymin* to *ymax*.
1139 
1140         Parameters
1141         ----------
1142         x : float or array-like
1143             x-indexes where to plot the lines.
1144 
1145         ymin, ymax : float or array-like
1146             Respective beginning and end of each line. If scalars are
1147             provided, all lines will have the same length.
1148 
1149         colors : color or list of colors, default: :rc:`lines.color`
1150 
1151         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1152 
1153         label : str, default: ''
1154 
1155         Returns
1156         -------
1157         `~matplotlib.collections.LineCollection`
1158 
1159         Other Parameters
1160         ----------------
1161         data : indexable object, optional
1162             DATA_PARAMETER_PLACEHOLDER
1163         **kwargs : `~matplotlib.collections.LineCollection` properties.
1164 
1165         See Also
1166         --------
1167         hlines : horizontal lines
1168         axvline : vertical line across the Axes
1169         """
1170 
1171         # We do the conversion first since not all unitized data is uniform
1172         x, ymin, ymax = self._process_unit_info(
1173             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1174 
1175         if not np.iterable(x):
1176             x = [x]
1177         if not np.iterable(ymin):
1178             ymin = [ymin]
1179         if not np.iterable(ymax):
1180             ymax = [ymax]
1181 
1182         # Create and combine masked_arrays from input
1183         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1184         x = np.ravel(x)
1185         ymin = np.ravel(ymin)
1186         ymax = np.ravel(ymax)
1187 
1188         masked_verts = np.ma.empty((len(x), 2, 2))
1189         masked_verts[:, 0, 0] = x
1190         masked_verts[:, 0, 1] = ymin
1191         masked_verts[:, 1, 0] = x
1192         masked_verts[:, 1, 1] = ymax
1193 
1194         lines = mcoll.LineCollection(masked_verts, colors=colors,
1195                                      linestyles=linestyles, label=label)
1196         self.add_collection(lines, autolim=False)
1197         lines._internal_update(kwargs)
1198 
1199         if len(x) > 0:
1200             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1201             # the case of x being a masked *object* array (as can be generated
1202             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1203             updatex = True
1204             updatey = True
1205             if self.name == "rectilinear":
1206                 datalim = lines.get_datalim(self.transData)
1207                 t = lines.get_transform()
1208                 updatex, updatey = t.contains_branch_seperately(self.transData)
1209                 minx = np.nanmin(datalim.xmin)
1210                 maxx = np.nanmax(datalim.xmax)
1211                 miny = np.nanmin(datalim.ymin)
1212                 maxy = np.nanmax(datalim.ymax)
1213             else:
1214                 minx = np.nanmin(masked_verts[..., 0])
1215                 maxx = np.nanmax(masked_verts[..., 0])
1216                 miny = np.nanmin(masked_verts[..., 1])
1217                 maxy = np.nanmax(masked_verts[..., 1])
1218 
1219             corners = (minx, miny), (maxx, maxy)
1220             self.update_datalim(corners, updatex, updatey)
1221             self._request_autoscale_view()
1222         return lines
1223 
1224     @_preprocess_data(replace_names=["positions", "lineoffsets",
1225                                      "linelengths", "linewidths",
1226                                      "colors", "linestyles"])
1227     @_docstring.dedent_interpd
1228     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1229                   linelengths=1, linewidths=None, colors=None, alpha=None,
1230                   linestyles='solid', **kwargs):
1231         """
1232         Plot identical parallel lines at the given positions.
1233 
1234         This type of plot is commonly used in neuroscience for representing
1235         neural events, where it is usually called a spike raster, dot raster,
1236         or raster plot.
1237 
1238         However, it is useful in any situation where you wish to show the
1239         timing or position of multiple sets of discrete events, such as the
1240         arrival times of people to a business on each day of the month or the
1241         date of hurricanes each year of the last century.
1242 
1243         Parameters
1244         ----------
1245         positions : array-like or list of array-like
1246             A 1D array-like defines the positions of one sequence of events.
1247 
1248             Multiple groups of events may be passed as a list of array-likes.
1249             Each group can be styled independently by passing lists of values
1250             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1251             *linestyles*.
1252 
1253             Note that *positions* can be a 2D array, but in practice different
1254             event groups usually have different counts so that one will use a
1255             list of different-length arrays rather than a 2D array.
1256 
1257         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1258             The direction of the event sequence:
1259 
1260             - 'horizontal': the events are arranged horizontally.
1261               The indicator lines are vertical.
1262             - 'vertical': the events are arranged vertically.
1263               The indicator lines are horizontal.
1264 
1265         lineoffsets : float or array-like, default: 1
1266             The offset of the center of the lines from the origin, in the
1267             direction orthogonal to *orientation*.
1268 
1269             If *positions* is 2D, this can be a sequence with length matching
1270             the length of *positions*.
1271 
1272         linelengths : float or array-like, default: 1
1273             The total height of the lines (i.e. the lines stretches from
1274             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1275 
1276             If *positions* is 2D, this can be a sequence with length matching
1277             the length of *positions*.
1278 
1279         linewidths : float or array-like, default: :rc:`lines.linewidth`
1280             The line width(s) of the event lines, in points.
1281 
1282             If *positions* is 2D, this can be a sequence with length matching
1283             the length of *positions*.
1284 
1285         colors : color or list of colors, default: :rc:`lines.color`
1286             The color(s) of the event lines.
1287 
1288             If *positions* is 2D, this can be a sequence with length matching
1289             the length of *positions*.
1290 
1291         alpha : float or array-like, default: 1
1292             The alpha blending value(s), between 0 (transparent) and 1
1293             (opaque).
1294 
1295             If *positions* is 2D, this can be a sequence with length matching
1296             the length of *positions*.
1297 
1298         linestyles : str or tuple or list of such values, default: 'solid'
1299             Default is 'solid'. Valid strings are ['solid', 'dashed',
1300             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1301             should be of the form::
1302 
1303                 (offset, onoffseq),
1304 
1305             where *onoffseq* is an even length tuple of on and off ink
1306             in points.
1307 
1308             If *positions* is 2D, this can be a sequence with length matching
1309             the length of *positions*.
1310 
1311         data : indexable object, optional
1312             DATA_PARAMETER_PLACEHOLDER
1313 
1314         **kwargs
1315             Other keyword arguments are line collection properties.  See
1316             `.LineCollection` for a list of the valid properties.
1317 
1318         Returns
1319         -------
1320         list of `.EventCollection`
1321             The `.EventCollection` that were added.
1322 
1323         Notes
1324         -----
1325         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1326         only a single value is given, that value is applied to all lines. If an
1327         array-like is given, it must have the same length as *positions*, and
1328         each value will be applied to the corresponding row of the array.
1329 
1330         Examples
1331         --------
1332         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1333         """
1334 
1335         lineoffsets, linelengths = self._process_unit_info(
1336                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1337 
1338         # fix positions, noting that it can be a list of lists:
1339         if not np.iterable(positions):
1340             positions = [positions]
1341         elif any(np.iterable(position) for position in positions):
1342             positions = [np.asanyarray(position) for position in positions]
1343         else:
1344             positions = [np.asanyarray(positions)]
1345 
1346         poss = []
1347         for position in positions:
1348             poss += self._process_unit_info([("x", position)], kwargs)
1349         positions = poss
1350 
1351         # prevent 'singular' keys from **kwargs dict from overriding the effect
1352         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1353         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1354         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1355         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1356 
1357         if not np.iterable(lineoffsets):
1358             lineoffsets = [lineoffsets]
1359         if not np.iterable(linelengths):
1360             linelengths = [linelengths]
1361         if not np.iterable(linewidths):
1362             linewidths = [linewidths]
1363         if not np.iterable(colors):
1364             colors = [colors]
1365         if not np.iterable(alpha):
1366             alpha = [alpha]
1367         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1368             linestyles = [linestyles]
1369 
1370         lineoffsets = np.asarray(lineoffsets)
1371         linelengths = np.asarray(linelengths)
1372         linewidths = np.asarray(linewidths)
1373 
1374         if len(lineoffsets) == 0:
1375             raise ValueError('lineoffsets cannot be empty')
1376         if len(linelengths) == 0:
1377             raise ValueError('linelengths cannot be empty')
1378         if len(linestyles) == 0:
1379             raise ValueError('linestyles cannot be empty')
1380         if len(linewidths) == 0:
1381             raise ValueError('linewidths cannot be empty')
1382         if len(alpha) == 0:
1383             raise ValueError('alpha cannot be empty')
1384         if len(colors) == 0:
1385             colors = [None]
1386         try:
1387             # Early conversion of the colors into RGBA values to take care
1388             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1389             colors = mcolors.to_rgba_array(colors)
1390         except ValueError:
1391             # Will fail if any element of *colors* is None. But as long
1392             # as len(colors) == 1 or len(positions), the rest of the
1393             # code should process *colors* properly.
1394             pass
1395 
1396         if len(lineoffsets) == 1 and len(positions) != 1:
1397             lineoffsets = np.tile(lineoffsets, len(positions))
1398             lineoffsets[0] = 0
1399             lineoffsets = np.cumsum(lineoffsets)
1400         if len(linelengths) == 1:
1401             linelengths = np.tile(linelengths, len(positions))
1402         if len(linewidths) == 1:
1403             linewidths = np.tile(linewidths, len(positions))
1404         if len(colors) == 1:
1405             colors = list(colors) * len(positions)
1406         if len(alpha) == 1:
1407             alpha = list(alpha) * len(positions)
1408         if len(linestyles) == 1:
1409             linestyles = [linestyles] * len(positions)
1410 
1411         if len(lineoffsets) != len(positions):
1412             raise ValueError('lineoffsets and positions are unequal sized '
1413                              'sequences')
1414         if len(linelengths) != len(positions):
1415             raise ValueError('linelengths and positions are unequal sized '
1416                              'sequences')
1417         if len(linewidths) != len(positions):
1418             raise ValueError('linewidths and positions are unequal sized '
1419                              'sequences')
1420         if len(colors) != len(positions):
1421             raise ValueError('colors and positions are unequal sized '
1422                              'sequences')
1423         if len(alpha) != len(positions):
1424             raise ValueError('alpha and positions are unequal sized '
1425                              'sequences')
1426         if len(linestyles) != len(positions):
1427             raise ValueError('linestyles and positions are unequal sized '
1428                              'sequences')
1429 
1430         colls = []
1431         for position, lineoffset, linelength, linewidth, color, alpha_, \
1432             linestyle in \
1433                 zip(positions, lineoffsets, linelengths, linewidths,
1434                     colors, alpha, linestyles):
1435             coll = mcoll.EventCollection(position,
1436                                          orientation=orientation,
1437                                          lineoffset=lineoffset,
1438                                          linelength=linelength,
1439                                          linewidth=linewidth,
1440                                          color=color,
1441                                          alpha=alpha_,
1442                                          linestyle=linestyle)
1443             self.add_collection(coll, autolim=False)
1444             coll._internal_update(kwargs)
1445             colls.append(coll)
1446 
1447         if len(positions) > 0:
1448             # try to get min/max
1449             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1450                        if len(_p) > 0]
1451             # if we have any non-empty positions, try to autoscale
1452             if len(min_max) > 0:
1453                 mins, maxes = zip(*min_max)
1454                 minpos = np.min(mins)
1455                 maxpos = np.max(maxes)
1456 
1457                 minline = (lineoffsets - linelengths).min()
1458                 maxline = (lineoffsets + linelengths).max()
1459 
1460                 if orientation == "vertical":
1461                     corners = (minline, minpos), (maxline, maxpos)
1462                 else:  # "horizontal"
1463                     corners = (minpos, minline), (maxpos, maxline)
1464                 self.update_datalim(corners)
1465                 self._request_autoscale_view()
1466 
1467         return colls
1468 
1469     #### Basic plotting
1470 
1471     # Uses a custom implementation of data-kwarg handling in
1472     # _process_plot_var_args.
1473     @_docstring.dedent_interpd
1474     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1475         """
1476         Plot y versus x as lines and/or markers.
1477 
1478         Call signatures::
1479 
1480             plot([x], y, [fmt], *, data=None, **kwargs)
1481             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1482 
1483         The coordinates of the points or line nodes are given by *x*, *y*.
1484 
1485         The optional parameter *fmt* is a convenient way for defining basic
1486         formatting like color, marker and linestyle. It's a shortcut string
1487         notation described in the *Notes* section below.
1488 
1489         >>> plot(x, y)        # plot x and y using default line style and color
1490         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1491         >>> plot(y)           # plot y using x as index array 0..N-1
1492         >>> plot(y, 'r+')     # ditto, but with red plusses
1493 
1494         You can use `.Line2D` properties as keyword arguments for more
1495         control on the appearance. Line properties and *fmt* can be mixed.
1496         The following two calls yield identical results:
1497 
1498         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1499         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1500         ...      linewidth=2, markersize=12)
1501 
1502         When conflicting with *fmt*, keyword arguments take precedence.
1503 
1504 
1505         **Plotting labelled data**
1506 
1507         There's a convenient way for plotting objects with labelled data (i.e.
1508         data that can be accessed by index ``obj['y']``). Instead of giving
1509         the data in *x* and *y*, you can provide the object in the *data*
1510         parameter and just give the labels for *x* and *y*::
1511 
1512         >>> plot('xlabel', 'ylabel', data=obj)
1513 
1514         All indexable objects are supported. This could e.g. be a `dict`, a
1515         `pandas.DataFrame` or a structured numpy array.
1516 
1517 
1518         **Plotting multiple sets of data**
1519 
1520         There are various ways to plot multiple sets of data.
1521 
1522         - The most straight forward way is just to call `plot` multiple times.
1523           Example:
1524 
1525           >>> plot(x1, y1, 'bo')
1526           >>> plot(x2, y2, 'go')
1527 
1528         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1529           for every column. If both *x* and *y* are 2D, they must have the
1530           same shape. If only one of them is 2D with shape (N, m) the other
1531           must have length N and will be used for every data set m.
1532 
1533           Example:
1534 
1535           >>> x = [1, 2, 3]
1536           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1537           >>> plot(x, y)
1538 
1539           is equivalent to:
1540 
1541           >>> for col in range(y.shape[1]):
1542           ...     plot(x, y[:, col])
1543 
1544         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1545           groups::
1546 
1547           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1548 
1549           In this case, any additional keyword argument applies to all
1550           datasets. Also, this syntax cannot be combined with the *data*
1551           parameter.
1552 
1553         By default, each line is assigned a different style specified by a
1554         'style cycle'. The *fmt* and line property parameters are only
1555         necessary if you want explicit deviations from these defaults.
1556         Alternatively, you can also change the style cycle using
1557         :rc:`axes.prop_cycle`.
1558 
1559 
1560         Parameters
1561         ----------
1562         x, y : array-like or scalar
1563             The horizontal / vertical coordinates of the data points.
1564             *x* values are optional and default to ``range(len(y))``.
1565 
1566             Commonly, these parameters are 1D arrays.
1567 
1568             They can also be scalars, or two-dimensional (in that case, the
1569             columns represent separate data sets).
1570 
1571             These arguments cannot be passed as keywords.
1572 
1573         fmt : str, optional
1574             A format string, e.g. 'ro' for red circles. See the *Notes*
1575             section for a full description of the format strings.
1576 
1577             Format strings are just an abbreviation for quickly setting
1578             basic line properties. All of these and more can also be
1579             controlled by keyword arguments.
1580 
1581             This argument cannot be passed as keyword.
1582 
1583         data : indexable object, optional
1584             An object with labelled data. If given, provide the label names to
1585             plot in *x* and *y*.
1586 
1587             .. note::
1588                 Technically there's a slight ambiguity in calls where the
1589                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1590                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1591                 the former interpretation is chosen, but a warning is issued.
1592                 You may suppress the warning by adding an empty format string
1593                 ``plot('n', 'o', '', data=obj)``.
1594 
1595         Returns
1596         -------
1597         list of `.Line2D`
1598             A list of lines representing the plotted data.
1599 
1600         Other Parameters
1601         ----------------
1602         scalex, scaley : bool, default: True
1603             These parameters determine if the view limits are adapted to the
1604             data limits. The values are passed on to
1605             `~.axes.Axes.autoscale_view`.
1606 
1607         **kwargs : `~matplotlib.lines.Line2D` properties, optional
1608             *kwargs* are used to specify properties like a line label (for
1609             auto legends), linewidth, antialiasing, marker face color.
1610             Example::
1611 
1612             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1613             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1614 
1615             If you specify multiple lines with one plot call, the kwargs apply
1616             to all those lines. In case the label object is iterable, each
1617             element is used as labels for each set of data.
1618 
1619             Here is a list of available `.Line2D` properties:
1620 
1621             %(Line2D:kwdoc)s
1622 
1623         See Also
1624         --------
1625         scatter : XY scatter plot with markers of varying size and/or color (
1626             sometimes also called bubble chart).
1627 
1628         Notes
1629         -----
1630         **Format Strings**
1631 
1632         A format string consists of a part for color, marker and line::
1633 
1634             fmt = '[marker][line][color]'
1635 
1636         Each of them is optional. If not provided, the value from the style
1637         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1638         the data will be a line without markers.
1639 
1640         Other combinations such as ``[color][marker][line]`` are also
1641         supported, but note that their parsing may be ambiguous.
1642 
1643         **Markers**
1644 
1645         =============   ===============================
1646         character       description
1647         =============   ===============================
1648         ``'.'``         point marker
1649         ``','``         pixel marker
1650         ``'o'``         circle marker
1651         ``'v'``         triangle_down marker
1652         ``'^'``         triangle_up marker
1653         ``'<'``         triangle_left marker
1654         ``'>'``         triangle_right marker
1655         ``'1'``         tri_down marker
1656         ``'2'``         tri_up marker
1657         ``'3'``         tri_left marker
1658         ``'4'``         tri_right marker
1659         ``'8'``         octagon marker
1660         ``'s'``         square marker
1661         ``'p'``         pentagon marker
1662         ``'P'``         plus (filled) marker
1663         ``'*'``         star marker
1664         ``'h'``         hexagon1 marker
1665         ``'H'``         hexagon2 marker
1666         ``'+'``         plus marker
1667         ``'x'``         x marker
1668         ``'X'``         x (filled) marker
1669         ``'D'``         diamond marker
1670         ``'d'``         thin_diamond marker
1671         ``'|'``         vline marker
1672         ``'_'``         hline marker
1673         =============   ===============================
1674 
1675         **Line Styles**
1676 
1677         =============    ===============================
1678         character        description
1679         =============    ===============================
1680         ``'-'``          solid line style
1681         ``'--'``         dashed line style
1682         ``'-.'``         dash-dot line style
1683         ``':'``          dotted line style
1684         =============    ===============================
1685 
1686         Example format strings::
1687 
1688             'b'    # blue markers with default shape
1689             'or'   # red circles
1690             '-g'   # green solid line
1691             '--'   # dashed line with default color
1692             '^k:'  # black triangle_up markers connected by a dotted line
1693 
1694         **Colors**
1695 
1696         The supported color abbreviations are the single letter codes
1697 
1698         =============    ===============================
1699         character        color
1700         =============    ===============================
1701         ``'b'``          blue
1702         ``'g'``          green
1703         ``'r'``          red
1704         ``'c'``          cyan
1705         ``'m'``          magenta
1706         ``'y'``          yellow
1707         ``'k'``          black
1708         ``'w'``          white
1709         =============    ===============================
1710 
1711         and the ``'CN'`` colors that index into the default property cycle.
1712 
1713         If the color is the only part of the format string, you can
1714         additionally use any  `matplotlib.colors` spec, e.g. full names
1715         (``'green'``) or hex strings (``'#008000'``).
1716         """
1717         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1718         lines = [*self._get_lines(*args, data=data, **kwargs)]
1719         for line in lines:
1720             self.add_line(line)
1721         if scalex:
1722             self._request_autoscale_view("x")
1723         if scaley:
1724             self._request_autoscale_view("y")
1725         return lines
1726 
1727     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1728     @_docstring.dedent_interpd
1729     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1730                   **kwargs):
1731         """
1732         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1733 
1734         .. admonition:: Discouraged
1735 
1736             This method exists for historic reasons and will be deprecated in
1737             the future.
1738 
1739             - ``datetime``-like data should directly be plotted using
1740               `~.Axes.plot`.
1741             -  If you need to plot plain numeric data as :ref:`date-format` or
1742                need to set a timezone, call ``ax.xaxis.axis_date`` /
1743                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1744                `.Axis.axis_date`.
1745 
1746         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1747         However, the axis labels are formatted as dates depending on *xdate*
1748         and *ydate*.  Note that `.plot` will work with `datetime` and
1749         `numpy.datetime64` objects without resorting to this method.
1750 
1751         Parameters
1752         ----------
1753         x, y : array-like
1754             The coordinates of the data points. If *xdate* or *ydate* is
1755             *True*, the respective values *x* or *y* are interpreted as
1756             :ref:`Matplotlib dates <date-format>`.
1757 
1758         fmt : str, optional
1759             The plot format string. For details, see the corresponding
1760             parameter in `.plot`.
1761 
1762         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1763             The time zone to use in labeling dates.
1764 
1765         xdate : bool, default: True
1766             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1767 
1768         ydate : bool, default: False
1769             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1770 
1771         Returns
1772         -------
1773         list of `.Line2D`
1774             Objects representing the plotted data.
1775 
1776         Other Parameters
1777         ----------------
1778         data : indexable object, optional
1779             DATA_PARAMETER_PLACEHOLDER
1780         **kwargs
1781             Keyword arguments control the `.Line2D` properties:
1782 
1783             %(Line2D:kwdoc)s
1784 
1785         See Also
1786         --------
1787         matplotlib.dates : Helper functions on dates.
1788         matplotlib.dates.date2num : Convert dates to num.
1789         matplotlib.dates.num2date : Convert num to dates.
1790         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1791 
1792         Notes
1793         -----
1794         If you are using custom date tickers and formatters, it may be
1795         necessary to set the formatters/locators after the call to
1796         `.plot_date`. `.plot_date` will set the default tick locator to
1797         `.AutoDateLocator` (if the tick locator is not already set to a
1798         `.DateLocator` instance) and the default tick formatter to
1799         `.AutoDateFormatter` (if the tick formatter is not already set to a
1800         `.DateFormatter` instance).
1801         """
1802         if xdate:
1803             self.xaxis_date(tz)
1804         if ydate:
1805             self.yaxis_date(tz)
1806         return self.plot(x, y, fmt, **kwargs)
1807 
1808     # @_preprocess_data() # let 'plot' do the unpacking..
1809     @_docstring.dedent_interpd
1810     def loglog(self, *args, **kwargs):
1811         """
1812         Make a plot with log scaling on both the x- and y-axis.
1813 
1814         Call signatures::
1815 
1816             loglog([x], y, [fmt], data=None, **kwargs)
1817             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1818 
1819         This is just a thin wrapper around `.plot` which additionally changes
1820         both the x-axis and the y-axis to log scaling. All the concepts and
1821         parameters of plot can be used here as well.
1822 
1823         The additional parameters *base*, *subs* and *nonpositive* control the
1824         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1825         `.Axes.set_yscale`. To use different properties on the x-axis and the
1826         y-axis, use e.g.
1827         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1828 
1829         Parameters
1830         ----------
1831         base : float, default: 10
1832             Base of the logarithm.
1833 
1834         subs : sequence, optional
1835             The location of the minor ticks. If *None*, reasonable locations
1836             are automatically chosen depending on the number of decades in the
1837             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1838 
1839         nonpositive : {'mask', 'clip'}, default: 'clip'
1840             Non-positive values can be masked as invalid, or clipped to a very
1841             small positive number.
1842 
1843         **kwargs
1844             All parameters supported by `.plot`.
1845 
1846         Returns
1847         -------
1848         list of `.Line2D`
1849             Objects representing the plotted data.
1850         """
1851         dx = {k: v for k, v in kwargs.items()
1852               if k in ['base', 'subs', 'nonpositive',
1853                        'basex', 'subsx', 'nonposx']}
1854         self.set_xscale('log', **dx)
1855         dy = {k: v for k, v in kwargs.items()
1856               if k in ['base', 'subs', 'nonpositive',
1857                        'basey', 'subsy', 'nonposy']}
1858         self.set_yscale('log', **dy)
1859         return self.plot(
1860             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1861 
1862     # @_preprocess_data() # let 'plot' do the unpacking..
1863     @_docstring.dedent_interpd
1864     def semilogx(self, *args, **kwargs):
1865         """
1866         Make a plot with log scaling on the x-axis.
1867 
1868         Call signatures::
1869 
1870             semilogx([x], y, [fmt], data=None, **kwargs)
1871             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1872 
1873         This is just a thin wrapper around `.plot` which additionally changes
1874         the x-axis to log scaling. All the concepts and parameters of plot can
1875         be used here as well.
1876 
1877         The additional parameters *base*, *subs*, and *nonpositive* control the
1878         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1879 
1880         Parameters
1881         ----------
1882         base : float, default: 10
1883             Base of the x logarithm.
1884 
1885         subs : array-like, optional
1886             The location of the minor xticks. If *None*, reasonable locations
1887             are automatically chosen depending on the number of decades in the
1888             plot. See `.Axes.set_xscale` for details.
1889 
1890         nonpositive : {'mask', 'clip'}, default: 'clip'
1891             Non-positive values in x can be masked as invalid, or clipped to a
1892             very small positive number.
1893 
1894         **kwargs
1895             All parameters supported by `.plot`.
1896 
1897         Returns
1898         -------
1899         list of `.Line2D`
1900             Objects representing the plotted data.
1901         """
1902         d = {k: v for k, v in kwargs.items()
1903              if k in ['base', 'subs', 'nonpositive',
1904                       'basex', 'subsx', 'nonposx']}
1905         self.set_xscale('log', **d)
1906         return self.plot(
1907             *args, **{k: v for k, v in kwargs.items() if k not in d})
1908 
1909     # @_preprocess_data() # let 'plot' do the unpacking..
1910     @_docstring.dedent_interpd
1911     def semilogy(self, *args, **kwargs):
1912         """
1913         Make a plot with log scaling on the y-axis.
1914 
1915         Call signatures::
1916 
1917             semilogy([x], y, [fmt], data=None, **kwargs)
1918             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1919 
1920         This is just a thin wrapper around `.plot` which additionally changes
1921         the y-axis to log scaling. All the concepts and parameters of plot can
1922         be used here as well.
1923 
1924         The additional parameters *base*, *subs*, and *nonpositive* control the
1925         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1926 
1927         Parameters
1928         ----------
1929         base : float, default: 10
1930             Base of the y logarithm.
1931 
1932         subs : array-like, optional
1933             The location of the minor yticks. If *None*, reasonable locations
1934             are automatically chosen depending on the number of decades in the
1935             plot. See `.Axes.set_yscale` for details.
1936 
1937         nonpositive : {'mask', 'clip'}, default: 'clip'
1938             Non-positive values in y can be masked as invalid, or clipped to a
1939             very small positive number.
1940 
1941         **kwargs
1942             All parameters supported by `.plot`.
1943 
1944         Returns
1945         -------
1946         list of `.Line2D`
1947             Objects representing the plotted data.
1948         """
1949         d = {k: v for k, v in kwargs.items()
1950              if k in ['base', 'subs', 'nonpositive',
1951                       'basey', 'subsy', 'nonposy']}
1952         self.set_yscale('log', **d)
1953         return self.plot(
1954             *args, **{k: v for k, v in kwargs.items() if k not in d})
1955 
1956     @_preprocess_data(replace_names=["x"], label_namer="x")
1957     def acorr(self, x, **kwargs):
1958         """
1959         Plot the autocorrelation of *x*.
1960 
1961         Parameters
1962         ----------
1963         x : array-like
1964 
1965         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1966             A detrending function applied to *x*.  It must have the
1967             signature ::
1968 
1969                 detrend(x: np.ndarray) -> np.ndarray
1970 
1971         normed : bool, default: True
1972             If ``True``, input vectors are normalised to unit length.
1973 
1974         usevlines : bool, default: True
1975             Determines the plot style.
1976 
1977             If ``True``, vertical lines are plotted from 0 to the acorr value
1978             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1979             at y=0 using `.Axes.axhline`.
1980 
1981             If ``False``, markers are plotted at the acorr values using
1982             `.Axes.plot`.
1983 
1984         maxlags : int, default: 10
1985             Number of lags to show. If ``None``, will return all
1986             ``2 * len(x) - 1`` lags.
1987 
1988         Returns
1989         -------
1990         lags : array (length ``2*maxlags+1``)
1991             The lag vector.
1992         c : array  (length ``2*maxlags+1``)
1993             The auto correlation vector.
1994         line : `.LineCollection` or `.Line2D`
1995             `.Artist` added to the Axes of the correlation:
1996 
1997             - `.LineCollection` if *usevlines* is True.
1998             - `.Line2D` if *usevlines* is False.
1999         b : `~matplotlib.lines.Line2D` or None
2000             Horizontal line at 0 if *usevlines* is True
2001             None *usevlines* is False.
2002 
2003         Other Parameters
2004         ----------------
2005         linestyle : `~matplotlib.lines.Line2D` property, optional
2006             The linestyle for plotting the data points.
2007             Only used if *usevlines* is ``False``.
2008 
2009         marker : str, default: 'o'
2010             The marker for plotting the data points.
2011             Only used if *usevlines* is ``False``.
2012 
2013         data : indexable object, optional
2014             DATA_PARAMETER_PLACEHOLDER
2015 
2016         **kwargs
2017             Additional parameters are passed to `.Axes.vlines` and
2018             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2019             passed to `.Axes.plot`.
2020 
2021         Notes
2022         -----
2023         The cross correlation is performed with `numpy.correlate` with
2024         ``mode = "full"``.
2025         """
2026         return self.xcorr(x, x, **kwargs)
2027 
2028     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2029     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2030               usevlines=True, maxlags=10, **kwargs):
2031         r"""
2032         Plot the cross correlation between *x* and *y*.
2033 
2034         The correlation with lag k is defined as
2035         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2036         conjugate of :math:`y`.
2037 
2038         Parameters
2039         ----------
2040         x, y : array-like of length n
2041 
2042         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2043             A detrending function applied to *x* and *y*.  It must have the
2044             signature ::
2045 
2046                 detrend(x: np.ndarray) -> np.ndarray
2047 
2048         normed : bool, default: True
2049             If ``True``, input vectors are normalised to unit length.
2050 
2051         usevlines : bool, default: True
2052             Determines the plot style.
2053 
2054             If ``True``, vertical lines are plotted from 0 to the xcorr value
2055             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2056             at y=0 using `.Axes.axhline`.
2057 
2058             If ``False``, markers are plotted at the xcorr values using
2059             `.Axes.plot`.
2060 
2061         maxlags : int, default: 10
2062             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2063             lags.
2064 
2065         Returns
2066         -------
2067         lags : array (length ``2*maxlags+1``)
2068             The lag vector.
2069         c : array  (length ``2*maxlags+1``)
2070             The auto correlation vector.
2071         line : `.LineCollection` or `.Line2D`
2072             `.Artist` added to the Axes of the correlation:
2073 
2074             - `.LineCollection` if *usevlines* is True.
2075             - `.Line2D` if *usevlines* is False.
2076         b : `~matplotlib.lines.Line2D` or None
2077             Horizontal line at 0 if *usevlines* is True
2078             None *usevlines* is False.
2079 
2080         Other Parameters
2081         ----------------
2082         linestyle : `~matplotlib.lines.Line2D` property, optional
2083             The linestyle for plotting the data points.
2084             Only used if *usevlines* is ``False``.
2085 
2086         marker : str, default: 'o'
2087             The marker for plotting the data points.
2088             Only used if *usevlines* is ``False``.
2089 
2090         data : indexable object, optional
2091             DATA_PARAMETER_PLACEHOLDER
2092 
2093         **kwargs
2094             Additional parameters are passed to `.Axes.vlines` and
2095             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2096             passed to `.Axes.plot`.
2097 
2098         Notes
2099         -----
2100         The cross correlation is performed with `numpy.correlate` with
2101         ``mode = "full"``.
2102         """
2103         Nx = len(x)
2104         if Nx != len(y):
2105             raise ValueError('x and y must be equal length')
2106 
2107         x = detrend(np.asarray(x))
2108         y = detrend(np.asarray(y))
2109 
2110         correls = np.correlate(x, y, mode="full")
2111 
2112         if normed:
2113             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2114 
2115         if maxlags is None:
2116             maxlags = Nx - 1
2117 
2118         if maxlags >= Nx or maxlags < 1:
2119             raise ValueError('maxlags must be None or strictly '
2120                              'positive < %d' % Nx)
2121 
2122         lags = np.arange(-maxlags, maxlags + 1)
2123         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2124 
2125         if usevlines:
2126             a = self.vlines(lags, [0], correls, **kwargs)
2127             # Make label empty so only vertical lines get a legend entry
2128             kwargs.pop('label', '')
2129             b = self.axhline(**kwargs)
2130         else:
2131             kwargs.setdefault('marker', 'o')
2132             kwargs.setdefault('linestyle', 'None')
2133             a, = self.plot(lags, correls, **kwargs)
2134             b = None
2135         return lags, correls, a, b
2136 
2137     #### Specialized plotting
2138 
2139     # @_preprocess_data() # let 'plot' do the unpacking..
2140     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2141         """
2142         Make a step plot.
2143 
2144         Call signatures::
2145 
2146             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2147             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2148 
2149         This is just a thin wrapper around `.plot` which changes some
2150         formatting options. Most of the concepts and parameters of plot can be
2151         used here as well.
2152 
2153         .. note::
2154 
2155             This method uses a standard plot with a step drawstyle: The *x*
2156             values are the reference positions and steps extend left/right/both
2157             directions depending on *where*.
2158 
2159             For the common case where you know the values and edges of the
2160             steps, use `~.Axes.stairs` instead.
2161 
2162         Parameters
2163         ----------
2164         x : array-like
2165             1D sequence of x positions. It is assumed, but not checked, that
2166             it is uniformly increasing.
2167 
2168         y : array-like
2169             1D sequence of y levels.
2170 
2171         fmt : str, optional
2172             A format string, e.g. 'g' for a green line. See `.plot` for a more
2173             detailed description.
2174 
2175             Note: While full format strings are accepted, it is recommended to
2176             only specify the color. Line styles are currently ignored (use
2177             the keyword argument *linestyle* instead). Markers are accepted
2178             and plotted on the given positions, however, this is a rarely
2179             needed feature for step plots.
2180 
2181         where : {'pre', 'post', 'mid'}, default: 'pre'
2182             Define where the steps should be placed:
2183 
2184             - 'pre': The y value is continued constantly to the left from
2185               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2186               value ``y[i]``.
2187             - 'post': The y value is continued constantly to the right from
2188               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2189               value ``y[i]``.
2190             - 'mid': Steps occur half-way between the *x* positions.
2191 
2192         data : indexable object, optional
2193             An object with labelled data. If given, provide the label names to
2194             plot in *x* and *y*.
2195 
2196         **kwargs
2197             Additional parameters are the same as those for `.plot`.
2198 
2199         Returns
2200         -------
2201         list of `.Line2D`
2202             Objects representing the plotted data.
2203         """
2204         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2205         kwargs['drawstyle'] = 'steps-' + where
2206         return self.plot(x, y, *args, data=data, **kwargs)
2207 
2208     @staticmethod
2209     def _convert_dx(dx, x0, xconv, convert):
2210         """
2211         Small helper to do logic of width conversion flexibly.
2212 
2213         *dx* and *x0* have units, but *xconv* has already been converted
2214         to unitless (and is an ndarray).  This allows the *dx* to have units
2215         that are different from *x0*, but are still accepted by the
2216         ``__add__`` operator of *x0*.
2217         """
2218 
2219         # x should be an array...
2220         assert type(xconv) is np.ndarray
2221 
2222         if xconv.size == 0:
2223             # xconv has already been converted, but maybe empty...
2224             return convert(dx)
2225 
2226         try:
2227             # attempt to add the width to x0; this works for
2228             # datetime+timedelta, for instance
2229 
2230             # only use the first element of x and x0.  This saves
2231             # having to be sure addition works across the whole
2232             # vector.  This is particularly an issue if
2233             # x0 and dx are lists so x0 + dx just concatenates the lists.
2234             # We can't just cast x0 and dx to numpy arrays because that
2235             # removes the units from unit packages like `pint` that
2236             # wrap numpy arrays.
2237             try:
2238                 x0 = cbook._safe_first_finite(x0)
2239             except (TypeError, IndexError, KeyError):
2240                 pass
2241 
2242             try:
2243                 x = cbook._safe_first_finite(xconv)
2244             except (TypeError, IndexError, KeyError):
2245                 x = xconv
2246 
2247             delist = False
2248             if not np.iterable(dx):
2249                 dx = [dx]
2250                 delist = True
2251             dx = [convert(x0 + ddx) - x for ddx in dx]
2252             if delist:
2253                 dx = dx[0]
2254         except (ValueError, TypeError, AttributeError):
2255             # if the above fails (for any reason) just fallback to what
2256             # we do by default and convert dx by itself.
2257             dx = convert(dx)
2258         return dx
2259 
2260     @_preprocess_data()
2261     @_docstring.dedent_interpd
2262     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2263             **kwargs):
2264         r"""
2265         Make a bar plot.
2266 
2267         The bars are positioned at *x* with the given *align*\ment. Their
2268         dimensions are given by *height* and *width*. The vertical baseline
2269         is *bottom* (default 0).
2270 
2271         Many parameters can take either a single value applying to all bars
2272         or a sequence of values, one for each bar.
2273 
2274         Parameters
2275         ----------
2276         x : float or array-like
2277             The x coordinates of the bars. See also *align* for the
2278             alignment of the bars to the coordinates.
2279 
2280         height : float or array-like
2281             The height(s) of the bars.
2282 
2283             Note that if *bottom* has units (e.g. datetime), *height* should be in
2284             units that are a difference from the value of *bottom* (e.g. timedelta).
2285 
2286         width : float or array-like, default: 0.8
2287             The width(s) of the bars.
2288 
2289             Note that if *x* has units (e.g. datetime), then *width* should be in
2290             units that are a difference (e.g. timedelta) around the *x* values.
2291 
2292         bottom : float or array-like, default: 0
2293             The y coordinate(s) of the bottom side(s) of the bars.
2294 
2295             Note that if *bottom* has units, then the y-axis will get a Locator and
2296             Formatter appropriate for the units (e.g. dates, or categorical).
2297 
2298         align : {'center', 'edge'}, default: 'center'
2299             Alignment of the bars to the *x* coordinates:
2300 
2301             - 'center': Center the base on the *x* positions.
2302             - 'edge': Align the left edges of the bars with the *x* positions.
2303 
2304             To align the bars on the right edge pass a negative *width* and
2305             ``align='edge'``.
2306 
2307         Returns
2308         -------
2309         `.BarContainer`
2310             Container with all the bars and optionally errorbars.
2311 
2312         Other Parameters
2313         ----------------
2314         color : color or list of color, optional
2315             The colors of the bar faces.
2316 
2317         edgecolor : color or list of color, optional
2318             The colors of the bar edges.
2319 
2320         linewidth : float or array-like, optional
2321             Width of the bar edge(s). If 0, don't draw edges.
2322 
2323         tick_label : str or list of str, optional
2324             The tick labels of the bars.
2325             Default: None (Use default numeric labels.)
2326 
2327         label : str or list of str, optional
2328             A single label is attached to the resulting `.BarContainer` as a
2329             label for the whole dataset.
2330             If a list is provided, it must be the same length as *x* and
2331             labels the individual bars. Repeated labels are not de-duplicated
2332             and will cause repeated label entries, so this is best used when
2333             bars also differ in style (e.g., by passing a list to *color*.)
2334 
2335         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2336             If not *None*, add horizontal / vertical errorbars to the bar tips.
2337             The values are +/- sizes relative to the data:
2338 
2339             - scalar: symmetric +/- values for all bars
2340             - shape(N,): symmetric +/- values for each bar
2341             - shape(2, N): Separate - and + values for each bar. First row
2342               contains the lower errors, the second row contains the upper
2343               errors.
2344             - *None*: No errorbar. (Default)
2345 
2346             See :doc:`/gallery/statistics/errorbar_features` for an example on
2347             the usage of *xerr* and *yerr*.
2348 
2349         ecolor : color or list of color, default: 'black'
2350             The line color of the errorbars.
2351 
2352         capsize : float, default: :rc:`errorbar.capsize`
2353            The length of the error bar caps in points.
2354 
2355         error_kw : dict, optional
2356             Dictionary of keyword arguments to be passed to the
2357             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2358             here take precedence over the independent keyword arguments.
2359 
2360         log : bool, default: False
2361             If *True*, set the y-axis to be log scale.
2362 
2363         data : indexable object, optional
2364             DATA_PARAMETER_PLACEHOLDER
2365 
2366         **kwargs : `.Rectangle` properties
2367 
2368         %(Rectangle:kwdoc)s
2369 
2370         See Also
2371         --------
2372         barh : Plot a horizontal bar plot.
2373 
2374         Notes
2375         -----
2376         Stacked bars can be achieved by passing individual *bottom* values per
2377         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2378         """
2379         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2380         color = kwargs.pop('color', None)
2381         if color is None:
2382             color = self._get_patches_for_fill.get_next_color()
2383         edgecolor = kwargs.pop('edgecolor', None)
2384         linewidth = kwargs.pop('linewidth', None)
2385         hatch = kwargs.pop('hatch', None)
2386 
2387         # Because xerr and yerr will be passed to errorbar, most dimension
2388         # checking and processing will be left to the errorbar method.
2389         xerr = kwargs.pop('xerr', None)
2390         yerr = kwargs.pop('yerr', None)
2391         error_kw = kwargs.pop('error_kw', {})
2392         ezorder = error_kw.pop('zorder', None)
2393         if ezorder is None:
2394             ezorder = kwargs.get('zorder', None)
2395             if ezorder is not None:
2396                 # If using the bar zorder, increment slightly to make sure
2397                 # errorbars are drawn on top of bars
2398                 ezorder += 0.01
2399         error_kw.setdefault('zorder', ezorder)
2400         ecolor = kwargs.pop('ecolor', 'k')
2401         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2402         error_kw.setdefault('ecolor', ecolor)
2403         error_kw.setdefault('capsize', capsize)
2404 
2405         # The keyword argument *orientation* is used by barh() to defer all
2406         # logic and drawing to bar(). It is considered internal and is
2407         # intentionally not mentioned in the docstring.
2408         orientation = kwargs.pop('orientation', 'vertical')
2409         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2410         log = kwargs.pop('log', False)
2411         label = kwargs.pop('label', '')
2412         tick_labels = kwargs.pop('tick_label', None)
2413 
2414         y = bottom  # Matches barh call signature.
2415         if orientation == 'vertical':
2416             if y is None:
2417                 y = 0
2418         else:  # horizontal
2419             if x is None:
2420                 x = 0
2421 
2422         if orientation == 'vertical':
2423             # It is possible for y (bottom) to contain unit information.
2424             # However, it is also possible for y=0 for the default and height
2425             # to contain unit information.  This will prioritize the units of y.
2426             self._process_unit_info(
2427                 [("x", x), ("y", y), ("y", height)], kwargs, convert=False)
2428             if log:
2429                 self.set_yscale('log', nonpositive='clip')
2430         else:  # horizontal
2431             # It is possible for x (left) to contain unit information.
2432             # However, it is also possible for x=0 for the default and width
2433             # to contain unit information.  This will prioritize the units of x.
2434             self._process_unit_info(
2435                 [("x", x), ("x", width), ("y", y)], kwargs, convert=False)
2436             if log:
2437                 self.set_xscale('log', nonpositive='clip')
2438 
2439         # lets do some conversions now since some types cannot be
2440         # subtracted uniformly
2441         if self.xaxis is not None:
2442             x0 = x
2443             x = np.asarray(self.convert_xunits(x))
2444             width = self._convert_dx(width, x0, x, self.convert_xunits)
2445             if xerr is not None:
2446                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2447         if self.yaxis is not None:
2448             y0 = y
2449             y = np.asarray(self.convert_yunits(y))
2450             height = self._convert_dx(height, y0, y, self.convert_yunits)
2451             if yerr is not None:
2452                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2453 
2454         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2455             # Make args iterable too.
2456             np.atleast_1d(x), height, width, y, linewidth, hatch)
2457 
2458         # Now that units have been converted, set the tick locations.
2459         if orientation == 'vertical':
2460             tick_label_axis = self.xaxis
2461             tick_label_position = x
2462         else:  # horizontal
2463             tick_label_axis = self.yaxis
2464             tick_label_position = y
2465 
2466         if not isinstance(label, str) and np.iterable(label):
2467             bar_container_label = '_nolegend_'
2468             patch_labels = label
2469         else:
2470             bar_container_label = label
2471             patch_labels = ['_nolegend_'] * len(x)
2472         if len(patch_labels) != len(x):
2473             raise ValueError(f'number of labels ({len(patch_labels)}) '
2474                              f'does not match number of bars ({len(x)}).')
2475 
2476         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2477         hatch = itertools.cycle(np.atleast_1d(hatch))
2478         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2479                                 # Fallback if color == "none".
2480                                 itertools.repeat('none'))
2481         if edgecolor is None:
2482             edgecolor = itertools.repeat(None)
2483         else:
2484             edgecolor = itertools.chain(
2485                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2486                 # Fallback if edgecolor == "none".
2487                 itertools.repeat('none'))
2488 
2489         # We will now resolve the alignment and really have
2490         # left, bottom, width, height vectors
2491         _api.check_in_list(['center', 'edge'], align=align)
2492         if align == 'center':
2493             if orientation == 'vertical':
2494                 try:
2495                     left = x - width / 2
2496                 except TypeError as e:
2497                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2498                                     f'and width ({width.dtype}) '
2499                                     f'are incompatible') from e
2500                 bottom = y
2501             else:  # horizontal
2502                 try:
2503                     bottom = y - height / 2
2504                 except TypeError as e:
2505                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2506                                     f'and height ({height.dtype}) '
2507                                     f'are incompatible') from e
2508                 left = x
2509         else:  # edge
2510             left = x
2511             bottom = y
2512 
2513         patches = []
2514         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2515                    hatch, patch_labels)
2516         for l, b, w, h, c, e, lw, htch, lbl in args:
2517             r = mpatches.Rectangle(
2518                 xy=(l, b), width=w, height=h,
2519                 facecolor=c,
2520                 edgecolor=e,
2521                 linewidth=lw,
2522                 label=lbl,
2523                 hatch=htch,
2524                 )
2525             r._internal_update(kwargs)
2526             r.get_path()._interpolation_steps = 100
2527             if orientation == 'vertical':
2528                 r.sticky_edges.y.append(b)
2529             else:  # horizontal
2530                 r.sticky_edges.x.append(l)
2531             self.add_patch(r)
2532             patches.append(r)
2533 
2534         if xerr is not None or yerr is not None:
2535             if orientation == 'vertical':
2536                 # using list comps rather than arrays to preserve unit info
2537                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2538                 ey = [b + h for b, h in zip(bottom, height)]
2539 
2540             else:  # horizontal
2541                 # using list comps rather than arrays to preserve unit info
2542                 ex = [l + w for l, w in zip(left, width)]
2543                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2544 
2545             error_kw.setdefault("label", '_nolegend_')
2546 
2547             errorbar = self.errorbar(ex, ey,
2548                                      yerr=yerr, xerr=xerr,
2549                                      fmt='none', **error_kw)
2550         else:
2551             errorbar = None
2552 
2553         self._request_autoscale_view()
2554 
2555         if orientation == 'vertical':
2556             datavalues = height
2557         else:  # horizontal
2558             datavalues = width
2559 
2560         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2561                                      orientation=orientation,
2562                                      label=bar_container_label)
2563         self.add_container(bar_container)
2564 
2565         if tick_labels is not None:
2566             tick_labels = np.broadcast_to(tick_labels, len(patches))
2567             tick_label_axis.set_ticks(tick_label_position)
2568             tick_label_axis.set_ticklabels(tick_labels)
2569 
2570         return bar_container
2571 
2572     # @_preprocess_data() # let 'bar' do the unpacking..
2573     @_docstring.dedent_interpd
2574     def barh(self, y, width, height=0.8, left=None, *, align="center",
2575              data=None, **kwargs):
2576         r"""
2577         Make a horizontal bar plot.
2578 
2579         The bars are positioned at *y* with the given *align*\ment. Their
2580         dimensions are given by *width* and *height*. The horizontal baseline
2581         is *left* (default 0).
2582 
2583         Many parameters can take either a single value applying to all bars
2584         or a sequence of values, one for each bar.
2585 
2586         Parameters
2587         ----------
2588         y : float or array-like
2589             The y coordinates of the bars. See also *align* for the
2590             alignment of the bars to the coordinates.
2591 
2592         width : float or array-like
2593             The width(s) of the bars.
2594 
2595             Note that if *left* has units (e.g. datetime), *width* should be in
2596             units that are a difference from the value of *left* (e.g. timedelta).
2597 
2598         height : float or array-like, default: 0.8
2599             The heights of the bars.
2600 
2601             Note that if *y* has units (e.g. datetime), then *height* should be in
2602             units that are a difference (e.g. timedelta) around the *y* values.
2603 
2604         left : float or array-like, default: 0
2605             The x coordinates of the left side(s) of the bars.
2606 
2607             Note that if *left* has units, then the x-axis will get a Locator and
2608             Formatter appropriate for the units (e.g. dates, or categorical).
2609 
2610         align : {'center', 'edge'}, default: 'center'
2611             Alignment of the base to the *y* coordinates*:
2612 
2613             - 'center': Center the bars on the *y* positions.
2614             - 'edge': Align the bottom edges of the bars with the *y*
2615               positions.
2616 
2617             To align the bars on the top edge pass a negative *height* and
2618             ``align='edge'``.
2619 
2620         Returns
2621         -------
2622         `.BarContainer`
2623             Container with all the bars and optionally errorbars.
2624 
2625         Other Parameters
2626         ----------------
2627         color : color or list of color, optional
2628             The colors of the bar faces.
2629 
2630         edgecolor : color or list of color, optional
2631             The colors of the bar edges.
2632 
2633         linewidth : float or array-like, optional
2634             Width of the bar edge(s). If 0, don't draw edges.
2635 
2636         tick_label : str or list of str, optional
2637             The tick labels of the bars.
2638             Default: None (Use default numeric labels.)
2639 
2640         label : str or list of str, optional
2641             A single label is attached to the resulting `.BarContainer` as a
2642             label for the whole dataset.
2643             If a list is provided, it must be the same length as *y* and
2644             labels the individual bars. Repeated labels are not de-duplicated
2645             and will cause repeated label entries, so this is best used when
2646             bars also differ in style (e.g., by passing a list to *color*.)
2647 
2648         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2649             If not *None*, add horizontal / vertical errorbars to the bar tips.
2650             The values are +/- sizes relative to the data:
2651 
2652             - scalar: symmetric +/- values for all bars
2653             - shape(N,): symmetric +/- values for each bar
2654             - shape(2, N): Separate - and + values for each bar. First row
2655               contains the lower errors, the second row contains the upper
2656               errors.
2657             - *None*: No errorbar. (default)
2658 
2659             See :doc:`/gallery/statistics/errorbar_features` for an example on
2660             the usage of *xerr* and *yerr*.
2661 
2662         ecolor : color or list of color, default: 'black'
2663             The line color of the errorbars.
2664 
2665         capsize : float, default: :rc:`errorbar.capsize`
2666            The length of the error bar caps in points.
2667 
2668         error_kw : dict, optional
2669             Dictionary of keyword arguments to be passed to the
2670             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2671             here take precedence over the independent keyword arguments.
2672 
2673         log : bool, default: False
2674             If ``True``, set the x-axis to be log scale.
2675 
2676         data : indexable object, optional
2677             If given, all parameters also accept a string ``s``, which is
2678             interpreted as ``data[s]`` (unless this raises an exception).
2679 
2680         **kwargs : `.Rectangle` properties
2681 
2682         %(Rectangle:kwdoc)s
2683 
2684         See Also
2685         --------
2686         bar : Plot a vertical bar plot.
2687 
2688         Notes
2689         -----
2690         Stacked bars can be achieved by passing individual *left* values per
2691         bar. See
2692         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2693         """
2694         kwargs.setdefault('orientation', 'horizontal')
2695         patches = self.bar(x=left, height=height, width=width, bottom=y,
2696                            align=align, data=data, **kwargs)
2697         return patches
2698 
2699     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2700                   padding=0, **kwargs):
2701         """
2702         Label a bar plot.
2703 
2704         Adds labels to bars in the given `.BarContainer`.
2705         You may need to adjust the axis limits to fit the labels.
2706 
2707         Parameters
2708         ----------
2709         container : `.BarContainer`
2710             Container with all the bars and optionally errorbars, likely
2711             returned from `.bar` or `.barh`.
2712 
2713         labels : array-like, optional
2714             A list of label texts, that should be displayed. If not given, the
2715             label texts will be the data values formatted with *fmt*.
2716 
2717         fmt : str or callable, default: '%g'
2718             An unnamed %-style or {}-style format string for the label or a
2719             function to call with the value as the first argument.
2720             When *fmt* is a string and can be interpreted in both formats,
2721             %-style takes precedence over {}-style.
2722 
2723             .. versionadded:: 3.7
2724                Support for {}-style format string and callables.
2725 
2726         label_type : {'edge', 'center'}, default: 'edge'
2727             The label type. Possible values:
2728 
2729             - 'edge': label placed at the end-point of the bar segment, and the
2730               value displayed will be the position of that end-point.
2731             - 'center': label placed in the center of the bar segment, and the
2732               value displayed will be the length of that segment.
2733               (useful for stacked bars, i.e.,
2734               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2735 
2736         padding : float, default: 0
2737             Distance of label from the end of the bar, in points.
2738 
2739         **kwargs
2740             Any remaining keyword arguments are passed through to
2741             `.Axes.annotate`. The alignment parameters (
2742             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2743             not supported because the labels are automatically aligned to
2744             the bars.
2745 
2746         Returns
2747         -------
2748         list of `.Text`
2749             A list of `.Text` instances for the labels.
2750         """
2751         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2752             if key in kwargs:
2753                 raise ValueError(
2754                     f"Passing {key!r} to bar_label() is not supported.")
2755 
2756         a, b = self.yaxis.get_view_interval()
2757         y_inverted = a > b
2758         c, d = self.xaxis.get_view_interval()
2759         x_inverted = c > d
2760 
2761         # want to know whether to put label on positive or negative direction
2762         # cannot use np.sign here because it will return 0 if x == 0
2763         def sign(x):
2764             return 1 if x >= 0 else -1
2765 
2766         _api.check_in_list(['edge', 'center'], label_type=label_type)
2767 
2768         bars = container.patches
2769         errorbar = container.errorbar
2770         datavalues = container.datavalues
2771         orientation = container.orientation
2772 
2773         if errorbar:
2774             # check "ErrorbarContainer" for the definition of these elements
2775             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2776             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2777             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2778             errs = barlinecol.get_segments()
2779         else:
2780             errs = []
2781 
2782         if labels is None:
2783             labels = []
2784 
2785         annotations = []
2786 
2787         for bar, err, dat, lbl in itertools.zip_longest(
2788                 bars, errs, datavalues, labels
2789         ):
2790             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2791             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2792 
2793             if orientation == "vertical":
2794                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2795                 length = abs(y0 - y1)
2796             else:  # horizontal
2797                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2798                 length = abs(x0 - x1)
2799 
2800             if err is None or np.size(err) == 0:
2801                 endpt = extrema
2802             elif orientation == "vertical":
2803                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2804             else:  # horizontal
2805                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2806 
2807             if label_type == "center":
2808                 value = sign(dat) * length
2809             else:  # edge
2810                 value = extrema
2811 
2812             if label_type == "center":
2813                 xy = (0.5, 0.5)
2814                 kwargs["xycoords"] = (
2815                     lambda r, b=bar:
2816                         mtransforms.Bbox.intersection(
2817                             b.get_window_extent(r), b.get_clip_box()
2818                         ) or mtransforms.Bbox.null()
2819                 )
2820             else:  # edge
2821                 if orientation == "vertical":
2822                     xy = xc, endpt
2823                 else:  # horizontal
2824                     xy = endpt, yc
2825 
2826             if orientation == "vertical":
2827                 y_direction = -1 if y_inverted else 1
2828                 xytext = 0, y_direction * sign(dat) * padding
2829             else:  # horizontal
2830                 x_direction = -1 if x_inverted else 1
2831                 xytext = x_direction * sign(dat) * padding, 0
2832 
2833             if label_type == "center":
2834                 ha, va = "center", "center"
2835             else:  # edge
2836                 if orientation == "vertical":
2837                     ha = 'center'
2838                     if y_inverted:
2839                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2840                     else:
2841                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2842                 else:  # horizontal
2843                     if x_inverted:
2844                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2845                     else:
2846                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2847                     va = 'center'
2848 
2849             if np.isnan(dat):
2850                 lbl = ''
2851 
2852             if lbl is None:
2853                 if isinstance(fmt, str):
2854                     lbl = cbook._auto_format_str(fmt, value)
2855                 elif callable(fmt):
2856                     lbl = fmt(value)
2857                 else:
2858                     raise TypeError("fmt must be a str or callable")
2859             annotation = self.annotate(lbl,
2860                                        xy, xytext, textcoords="offset points",
2861                                        ha=ha, va=va, **kwargs)
2862             annotations.append(annotation)
2863 
2864         return annotations
2865 
2866     @_preprocess_data()
2867     @_docstring.dedent_interpd
2868     def broken_barh(self, xranges, yrange, **kwargs):
2869         """
2870         Plot a horizontal sequence of rectangles.
2871 
2872         A rectangle is drawn for each element of *xranges*. All rectangles
2873         have the same vertical position and size defined by *yrange*.
2874 
2875         Parameters
2876         ----------
2877         xranges : sequence of tuples (*xmin*, *xwidth*)
2878             The x-positions and extents of the rectangles. For each tuple
2879             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2880             *xwidth*.
2881         yrange : (*ymin*, *yheight*)
2882             The y-position and extent for all the rectangles.
2883 
2884         Returns
2885         -------
2886         `~.collections.PolyCollection`
2887 
2888         Other Parameters
2889         ----------------
2890         data : indexable object, optional
2891             DATA_PARAMETER_PLACEHOLDER
2892         **kwargs : `.PolyCollection` properties
2893 
2894             Each *kwarg* can be either a single argument applying to all
2895             rectangles, e.g.::
2896 
2897                 facecolors='black'
2898 
2899             or a sequence of arguments over which is cycled, e.g.::
2900 
2901                 facecolors=('black', 'blue')
2902 
2903             would create interleaving black and blue rectangles.
2904 
2905             Supported keywords:
2906 
2907             %(PolyCollection:kwdoc)s
2908         """
2909         # process the unit information
2910         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2911         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2912         self._process_unit_info(
2913             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2914 
2915         vertices = []
2916         y0, dy = yrange
2917         y0, y1 = self.convert_yunits((y0, y0 + dy))
2918         for xr in xranges:  # convert the absolute values, not the x and dx
2919             try:
2920                 x0, dx = xr
2921             except Exception:
2922                 raise ValueError(
2923                     "each range in xrange must be a sequence with two "
2924                     "elements (i.e. xrange must be an (N, 2) array)") from None
2925             x0, x1 = self.convert_xunits((x0, x0 + dx))
2926             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2927 
2928         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2929         self.add_collection(col, autolim=True)
2930         self._request_autoscale_view()
2931 
2932         return col
2933 
2934     @_preprocess_data()
2935     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2936              label=None, orientation='vertical'):
2937         """
2938         Create a stem plot.
2939 
2940         A stem plot draws lines perpendicular to a baseline at each location
2941         *locs* from the baseline to *heads*, and places a marker there. For
2942         vertical stem plots (the default), the *locs* are *x* positions, and
2943         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2944         *y* positions, and the *heads* are *x* values.
2945 
2946         Call signature::
2947 
2948           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2949 
2950         The *locs*-positions are optional. *linefmt* may be provided as
2951         positional, but all other formats must be provided as keyword
2952         arguments.
2953 
2954         Parameters
2955         ----------
2956         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2957             For vertical stem plots, the x-positions of the stems.
2958             For horizontal stem plots, the y-positions of the stems.
2959 
2960         heads : array-like
2961             For vertical stem plots, the y-values of the stem heads.
2962             For horizontal stem plots, the x-values of the stem heads.
2963 
2964         linefmt : str, optional
2965             A string defining the color and/or linestyle of the vertical lines:
2966 
2967             =========  =============
2968             Character  Line Style
2969             =========  =============
2970             ``'-'``    solid line
2971             ``'--'``   dashed line
2972             ``'-.'``   dash-dot line
2973             ``':'``    dotted line
2974             =========  =============
2975 
2976             Default: 'C0-', i.e. solid line with the first color of the color
2977             cycle.
2978 
2979             Note: Markers specified through this parameter (e.g. 'x') will be
2980             silently ignored. Instead, markers should be specified using
2981             *markerfmt*.
2982 
2983         markerfmt : str, optional
2984             A string defining the color and/or shape of the markers at the stem
2985             heads. If the marker is not given, use the marker 'o', i.e. filled
2986             circles. If the color is not given, use the color from *linefmt*.
2987 
2988         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2989             A format string defining the properties of the baseline.
2990 
2991         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2992             If 'vertical', will produce a plot with stems oriented vertically,
2993             If 'horizontal', the stems will be oriented horizontally.
2994 
2995         bottom : float, default: 0
2996             The y/x-position of the baseline (depending on orientation).
2997 
2998         label : str, default: None
2999             The label to use for the stems in legends.
3000 
3001         data : indexable object, optional
3002             DATA_PARAMETER_PLACEHOLDER
3003 
3004         Returns
3005         -------
3006         `.StemContainer`
3007             The container may be treated like a tuple
3008             (*markerline*, *stemlines*, *baseline*)
3009 
3010         Notes
3011         -----
3012         .. seealso::
3013             The MATLAB function
3014             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
3015             which inspired this method.
3016         """
3017         if not 1 <= len(args) <= 3:
3018             raise _api.nargs_error('stem', '1-3', len(args))
3019         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3020 
3021         if len(args) == 1:
3022             heads, = args
3023             locs = np.arange(len(heads))
3024             args = ()
3025         elif isinstance(args[1], str):
3026             heads, *args = args
3027             locs = np.arange(len(heads))
3028         else:
3029             locs, heads, *args = args
3030 
3031         if orientation == 'vertical':
3032             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3033         else:  # horizontal
3034             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3035 
3036         # resolve line format
3037         if linefmt is None:
3038             linefmt = args[0] if len(args) > 0 else "C0-"
3039         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3040 
3041         # resolve marker format
3042         if markerfmt is None:
3043             # if not given as kwarg, fall back to 'o'
3044             markerfmt = "o"
3045         if markerfmt == '':
3046             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3047         markerstyle, markermarker, markercolor = \
3048             _process_plot_format(markerfmt)
3049         if markermarker is None:
3050             markermarker = 'o'
3051         if markerstyle is None:
3052             markerstyle = 'None'
3053         if markercolor is None:
3054             markercolor = linecolor
3055 
3056         # resolve baseline format
3057         if basefmt is None:
3058             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3059                        "C3-")
3060         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3061 
3062         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3063         if linestyle is None:
3064             linestyle = mpl.rcParams['lines.linestyle']
3065         xlines = self.vlines if orientation == "vertical" else self.hlines
3066         stemlines = xlines(
3067             locs, bottom, heads,
3068             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3069 
3070         if orientation == 'horizontal':
3071             marker_x = heads
3072             marker_y = locs
3073             baseline_x = [bottom, bottom]
3074             baseline_y = [np.min(locs), np.max(locs)]
3075         else:
3076             marker_x = locs
3077             marker_y = heads
3078             baseline_x = [np.min(locs), np.max(locs)]
3079             baseline_y = [bottom, bottom]
3080 
3081         markerline, = self.plot(marker_x, marker_y,
3082                                 color=markercolor, linestyle=markerstyle,
3083                                 marker=markermarker, label="_nolegend_")
3084 
3085         baseline, = self.plot(baseline_x, baseline_y,
3086                               color=basecolor, linestyle=basestyle,
3087                               marker=basemarker, label="_nolegend_")
3088 
3089         stem_container = StemContainer((markerline, stemlines, baseline),
3090                                        label=label)
3091         self.add_container(stem_container)
3092         return stem_container
3093 
3094     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3095     def pie(self, x, explode=None, labels=None, colors=None,
3096             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3097             startangle=0, radius=1, counterclock=True,
3098             wedgeprops=None, textprops=None, center=(0, 0),
3099             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3100         """
3101         Plot a pie chart.
3102 
3103         Make a pie chart of array *x*.  The fractional area of each wedge is
3104         given by ``x/sum(x)``.
3105 
3106         The wedges are plotted counterclockwise, by default starting from the
3107         x-axis.
3108 
3109         Parameters
3110         ----------
3111         x : 1D array-like
3112             The wedge sizes.
3113 
3114         explode : array-like, default: None
3115             If not *None*, is a ``len(x)`` array which specifies the fraction
3116             of the radius with which to offset each wedge.
3117 
3118         labels : list, default: None
3119             A sequence of strings providing the labels for each wedge
3120 
3121         colors : color or array-like of color, default: None
3122             A sequence of colors through which the pie chart will cycle.  If
3123             *None*, will use the colors in the currently active cycle.
3124 
3125         hatch : str or list, default: None
3126             Hatching pattern applied to all pie wedges or sequence of patterns
3127             through which the chart will cycle. For a list of valid patterns,
3128             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3129 
3130             .. versionadded:: 3.7
3131 
3132         autopct : None or str or callable, default: None
3133             If not *None*, *autopct* is a string or function used to label the
3134             wedges with their numeric value. The label will be placed inside
3135             the wedge. If *autopct* is a format string, the label will be
3136             ``fmt % pct``. If *autopct* is a function, then it will be called.
3137 
3138         pctdistance : float, default: 0.6
3139             The relative distance along the radius at which the text
3140             generated by *autopct* is drawn. To draw the text outside the pie,
3141             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3142             ``None``.
3143 
3144         labeldistance : float or None, default: 1.1
3145             The relative distance along the radius at which the labels are
3146             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3147             If set to ``None``, labels are not drawn but are still stored for
3148             use in `.legend`.
3149 
3150         shadow : bool or dict, default: False
3151             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3152             passing the properties in the dict to `.Shadow`.
3153 
3154             .. versionadded:: 3.8
3155                 *shadow* can be a dict.
3156 
3157         startangle : float, default: 0 degrees
3158             The angle by which the start of the pie is rotated,
3159             counterclockwise from the x-axis.
3160 
3161         radius : float, default: 1
3162             The radius of the pie.
3163 
3164         counterclock : bool, default: True
3165             Specify fractions direction, clockwise or counterclockwise.
3166 
3167         wedgeprops : dict, default: None
3168             Dict of arguments passed to each `.patches.Wedge` of the pie.
3169             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3170             the wedge border lines equal to 3. By default, ``clip_on=False``.
3171             When there is a conflict between these properties and other
3172             keywords, properties passed to *wedgeprops* take precedence.
3173 
3174         textprops : dict, default: None
3175             Dict of arguments to pass to the text objects.
3176 
3177         center : (float, float), default: (0, 0)
3178             The coordinates of the center of the chart.
3179 
3180         frame : bool, default: False
3181             Plot Axes frame with the chart if true.
3182 
3183         rotatelabels : bool, default: False
3184             Rotate each label to the angle of the corresponding slice if true.
3185 
3186         normalize : bool, default: True
3187             When *True*, always make a full pie by normalizing x so that
3188             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3189             and raises a `ValueError` for ``sum(x) > 1``.
3190 
3191         data : indexable object, optional
3192             DATA_PARAMETER_PLACEHOLDER
3193 
3194         Returns
3195         -------
3196         patches : list
3197             A sequence of `matplotlib.patches.Wedge` instances
3198 
3199         texts : list
3200             A list of the label `.Text` instances.
3201 
3202         autotexts : list
3203             A list of `.Text` instances for the numeric labels. This will only
3204             be returned if the parameter *autopct* is not *None*.
3205 
3206         Notes
3207         -----
3208         The pie chart will probably look best if the figure and Axes are
3209         square, or the Axes aspect is equal.
3210         This method sets the aspect ratio of the axis to "equal".
3211         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3212         """
3213         self.set_aspect('equal')
3214         # The use of float32 is "historical", but can't be changed without
3215         # regenerating the test baselines.
3216         x = np.asarray(x, np.float32)
3217         if x.ndim > 1:
3218             raise ValueError("x must be 1D")
3219 
3220         if np.any(x < 0):
3221             raise ValueError("Wedge sizes 'x' must be non negative values")
3222 
3223         sx = x.sum()
3224 
3225         if normalize:
3226             x = x / sx
3227         elif sx > 1:
3228             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3229         if labels is None:
3230             labels = [''] * len(x)
3231         if explode is None:
3232             explode = [0] * len(x)
3233         if len(x) != len(labels):
3234             raise ValueError("'label' must be of length 'x'")
3235         if len(x) != len(explode):
3236             raise ValueError("'explode' must be of length 'x'")
3237         if colors is None:
3238             get_next_color = self._get_patches_for_fill.get_next_color
3239         else:
3240             color_cycle = itertools.cycle(colors)
3241 
3242             def get_next_color():
3243                 return next(color_cycle)
3244 
3245         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3246 
3247         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3248         if radius <= 0:
3249             raise ValueError(f'radius must be a positive number, not {radius}')
3250 
3251         # Starting theta1 is the start fraction of the circle
3252         theta1 = startangle / 360
3253 
3254         if wedgeprops is None:
3255             wedgeprops = {}
3256         if textprops is None:
3257             textprops = {}
3258 
3259         texts = []
3260         slices = []
3261         autotexts = []
3262 
3263         for frac, label, expl in zip(x, labels, explode):
3264             x, y = center
3265             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3266             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3267             x += expl * math.cos(thetam)
3268             y += expl * math.sin(thetam)
3269 
3270             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3271                                360. * max(theta1, theta2),
3272                                facecolor=get_next_color(),
3273                                hatch=next(hatch_cycle),
3274                                clip_on=False,
3275                                label=label)
3276             w.set(**wedgeprops)
3277             slices.append(w)
3278             self.add_patch(w)
3279 
3280             if shadow:
3281                 # Make sure to add a shadow after the call to add_patch so the
3282                 # figure and transform props will be set.
3283                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3284                 if isinstance(shadow, dict):
3285                     shadow_dict.update(shadow)
3286                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3287 
3288             if labeldistance is not None:
3289                 xt = x + labeldistance * radius * math.cos(thetam)
3290                 yt = y + labeldistance * radius * math.sin(thetam)
3291                 label_alignment_h = 'left' if xt > 0 else 'right'
3292                 label_alignment_v = 'center'
3293                 label_rotation = 'horizontal'
3294                 if rotatelabels:
3295                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3296                     label_rotation = (np.rad2deg(thetam)
3297                                       + (0 if xt > 0 else 180))
3298                 t = self.text(xt, yt, label,
3299                               clip_on=False,
3300                               horizontalalignment=label_alignment_h,
3301                               verticalalignment=label_alignment_v,
3302                               rotation=label_rotation,
3303                               size=mpl.rcParams['xtick.labelsize'])
3304                 t.set(**textprops)
3305                 texts.append(t)
3306 
3307             if autopct is not None:
3308                 xt = x + pctdistance * radius * math.cos(thetam)
3309                 yt = y + pctdistance * radius * math.sin(thetam)
3310                 if isinstance(autopct, str):
3311                     s = autopct % (100. * frac)
3312                 elif callable(autopct):
3313                     s = autopct(100. * frac)
3314                 else:
3315                     raise TypeError(
3316                         'autopct must be callable or a format string')
3317                 t = self.text(xt, yt, s,
3318                               clip_on=False,
3319                               horizontalalignment='center',
3320                               verticalalignment='center')
3321                 t.set(**textprops)
3322                 autotexts.append(t)
3323 
3324             theta1 = theta2
3325 
3326         if frame:
3327             self._request_autoscale_view()
3328         else:
3329             self.set(frame_on=False, xticks=[], yticks=[],
3330                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3331                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3332 
3333         if autopct is None:
3334             return slices, texts
3335         else:
3336             return slices, texts, autotexts
3337 
3338     @staticmethod
3339     def _errorevery_to_mask(x, errorevery):
3340         """
3341         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3342 
3343         This function is split out to be usable both by 2D and 3D errorbars.
3344         """
3345         if isinstance(errorevery, Integral):
3346             errorevery = (0, errorevery)
3347         if isinstance(errorevery, tuple):
3348             if (len(errorevery) == 2 and
3349                     isinstance(errorevery[0], Integral) and
3350                     isinstance(errorevery[1], Integral)):
3351                 errorevery = slice(errorevery[0], None, errorevery[1])
3352             else:
3353                 raise ValueError(
3354                     f'{errorevery=!r} is a not a tuple of two integers')
3355         elif isinstance(errorevery, slice):
3356             pass
3357         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3358             try:
3359                 x[errorevery]  # fancy indexing
3360             except (ValueError, IndexError) as err:
3361                 raise ValueError(
3362                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3363                     "index to match 'xerr'/'yerr'") from err
3364         else:
3365             raise ValueError(f"{errorevery=!r} is not a recognized value")
3366         everymask = np.zeros(len(x), bool)
3367         everymask[errorevery] = True
3368         return everymask
3369 
3370     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3371                       label_namer="y")
3372     @_docstring.dedent_interpd
3373     def errorbar(self, x, y, yerr=None, xerr=None,
3374                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3375                  barsabove=False, lolims=False, uplims=False,
3376                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3377                  **kwargs):
3378         """
3379         Plot y versus x as lines and/or markers with attached errorbars.
3380 
3381         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3382         sizes. By default, this draws the data markers/lines as well the
3383         errorbars. Use fmt='none' to draw errorbars without any data markers.
3384 
3385         .. versionadded:: 3.7
3386            Caps and error lines are drawn in polar coordinates on polar plots.
3387 
3388 
3389         Parameters
3390         ----------
3391         x, y : float or array-like
3392             The data positions.
3393 
3394         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3395             The errorbar sizes:
3396 
3397             - scalar: Symmetric +/- values for all data points.
3398             - shape(N,): Symmetric +/-values for each data point.
3399             - shape(2, N): Separate - and + values for each bar. First row
3400               contains the lower errors, the second row contains the upper
3401               errors.
3402             - *None*: No errorbar.
3403 
3404             All values must be >= 0.
3405 
3406             See :doc:`/gallery/statistics/errorbar_features`
3407             for an example on the usage of ``xerr`` and ``yerr``.
3408 
3409         fmt : str, default: ''
3410             The format for the data points / data lines. See `.plot` for
3411             details.
3412 
3413             Use 'none' (case-insensitive) to plot errorbars without any data
3414             markers.
3415 
3416         ecolor : color, default: None
3417             The color of the errorbar lines.  If None, use the color of the
3418             line connecting the markers.
3419 
3420         elinewidth : float, default: None
3421             The linewidth of the errorbar lines. If None, the linewidth of
3422             the current style is used.
3423 
3424         capsize : float, default: :rc:`errorbar.capsize`
3425             The length of the error bar caps in points.
3426 
3427         capthick : float, default: None
3428             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3429             This setting is a more sensible name for the property that
3430             controls the thickness of the error bar cap in points. For
3431             backwards compatibility, if *mew* or *markeredgewidth* are given,
3432             then they will over-ride *capthick*. This may change in future
3433             releases.
3434 
3435         barsabove : bool, default: False
3436             If True, will plot the errorbars above the plot
3437             symbols. Default is below.
3438 
3439         lolims, uplims, xlolims, xuplims : bool, default: False
3440             These arguments can be used to indicate that a value gives only
3441             upper/lower limits.  In that case a caret symbol is used to
3442             indicate this. *lims*-arguments may be scalars, or array-likes of
3443             the same length as *xerr* and *yerr*.  To use limits with inverted
3444             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3445             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3446             *lolims* to True means that the y-value is a *lower* limit of the
3447             True value, so, only an *upward*-pointing arrow will be drawn!
3448 
3449         errorevery : int or (int, int), default: 1
3450             draws error bars on a subset of the data. *errorevery* =N draws
3451             error bars on the points (x[::N], y[::N]).
3452             *errorevery* =(start, N) draws error bars on the points
3453             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3454             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3455             Used to avoid overlapping error bars when two series share x-axis
3456             values.
3457 
3458         Returns
3459         -------
3460         `.ErrorbarContainer`
3461             The container contains:
3462 
3463             - plotline: `~matplotlib.lines.Line2D` instance of x, y plot markers
3464               and/or line.
3465             - caplines: A tuple of `~matplotlib.lines.Line2D` instances of the error
3466               bar caps.
3467             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3468               vertical error ranges.
3469 
3470         Other Parameters
3471         ----------------
3472         data : indexable object, optional
3473             DATA_PARAMETER_PLACEHOLDER
3474 
3475         **kwargs
3476             All other keyword arguments are passed on to the `~.Axes.plot` call
3477             drawing the markers. For example, this code makes big red squares
3478             with thick green edges::
3479 
3480                 x, y, yerr = rand(3, 10)
3481                 errorbar(x, y, yerr, marker='s', mfc='red',
3482                          mec='green', ms=20, mew=4)
3483 
3484             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3485             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3486             and *markeredgewidth*.
3487 
3488             Valid kwargs for the marker properties are:
3489 
3490             - *dashes*
3491             - *dash_capstyle*
3492             - *dash_joinstyle*
3493             - *drawstyle*
3494             - *fillstyle*
3495             - *linestyle*
3496             - *marker*
3497             - *markeredgecolor*
3498             - *markeredgewidth*
3499             - *markerfacecolor*
3500             - *markerfacecoloralt*
3501             - *markersize*
3502             - *markevery*
3503             - *solid_capstyle*
3504             - *solid_joinstyle*
3505 
3506             Refer to the corresponding `.Line2D` property for more details:
3507 
3508             %(Line2D:kwdoc)s
3509         """
3510         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3511         # Drop anything that comes in as None to use the default instead.
3512         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3513         kwargs.setdefault('zorder', 2)
3514 
3515         # Casting to object arrays preserves units.
3516         if not isinstance(x, np.ndarray):
3517             x = np.asarray(x, dtype=object)
3518         if not isinstance(y, np.ndarray):
3519             y = np.asarray(y, dtype=object)
3520 
3521         def _upcast_err(err):
3522             """
3523             Safely handle tuple of containers that carry units.
3524 
3525             This function covers the case where the input to the xerr/yerr is a
3526             length 2 tuple of equal length ndarray-subclasses that carry the
3527             unit information in the container.
3528 
3529             If we have a tuple of nested numpy array (subclasses), we defer
3530             coercing the units to be consistent to the underlying unit
3531             library (and implicitly the broadcasting).
3532 
3533             Otherwise, fallback to casting to an object array.
3534             """
3535 
3536             if (
3537                     # make sure it is not a scalar
3538                     np.iterable(err) and
3539                     # and it is not empty
3540                     len(err) > 0 and
3541                     # and the first element is an array sub-class use
3542                     # safe_first_element because getitem is index-first not
3543                     # location first on pandas objects so err[0] almost always
3544                     # fails.
3545                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3546             ):
3547                 # Get the type of the first element
3548                 atype = type(cbook._safe_first_finite(err))
3549                 # Promote the outer container to match the inner container
3550                 if atype is np.ndarray:
3551                     # Converts using np.asarray, because data cannot
3552                     # be directly passed to init of np.ndarray
3553                     return np.asarray(err, dtype=object)
3554                 # If atype is not np.ndarray, directly pass data to init.
3555                 # This works for types such as unyts and astropy units
3556                 return atype(err)
3557             # Otherwise wrap it in an object array
3558             return np.asarray(err, dtype=object)
3559 
3560         if xerr is not None and not isinstance(xerr, np.ndarray):
3561             xerr = _upcast_err(xerr)
3562         if yerr is not None and not isinstance(yerr, np.ndarray):
3563             yerr = _upcast_err(yerr)
3564         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3565         if len(x) != len(y):
3566             raise ValueError("'x' and 'y' must have the same size")
3567 
3568         everymask = self._errorevery_to_mask(x, errorevery)
3569 
3570         label = kwargs.pop("label", None)
3571         kwargs['label'] = '_nolegend_'
3572 
3573         # Create the main line and determine overall kwargs for child artists.
3574         # We avoid calling self.plot() directly, or self._get_lines(), because
3575         # that would call self._process_unit_info again, and do other indirect
3576         # data processing.
3577         (data_line, base_style), = self._get_lines._plot_args(
3578             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3579 
3580         # Do this after creating `data_line` to avoid modifying `base_style`.
3581         if barsabove:
3582             data_line.set_zorder(kwargs['zorder'] - .1)
3583         else:
3584             data_line.set_zorder(kwargs['zorder'] + .1)
3585 
3586         # Add line to plot, or throw it away and use it to determine kwargs.
3587         if fmt.lower() != 'none':
3588             self.add_line(data_line)
3589         else:
3590             data_line = None
3591             # Remove alpha=0 color that _get_lines._plot_args returns for
3592             # 'none' format, and replace it with user-specified color, if
3593             # supplied.
3594             base_style.pop('color')
3595             if 'color' in kwargs:
3596                 base_style['color'] = kwargs.pop('color')
3597 
3598         if 'color' not in base_style:
3599             base_style['color'] = 'C0'
3600         if ecolor is None:
3601             ecolor = base_style['color']
3602 
3603         # Eject any line-specific information from format string, as it's not
3604         # needed for bars or caps.
3605         for key in ['marker', 'markersize', 'markerfacecolor',
3606                     'markerfacecoloralt',
3607                     'markeredgewidth', 'markeredgecolor', 'markevery',
3608                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3609                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3610                     'dashes']:
3611             base_style.pop(key, None)
3612 
3613         # Make the style dict for the line collections (the bars).
3614         eb_lines_style = {**base_style, 'color': ecolor}
3615 
3616         if elinewidth is not None:
3617             eb_lines_style['linewidth'] = elinewidth
3618         elif 'linewidth' in kwargs:
3619             eb_lines_style['linewidth'] = kwargs['linewidth']
3620 
3621         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3622             if key in kwargs:
3623                 eb_lines_style[key] = kwargs[key]
3624 
3625         # Make the style dict for caps (the "hats").
3626         eb_cap_style = {**base_style, 'linestyle': 'none'}
3627         if capsize is None:
3628             capsize = mpl.rcParams["errorbar.capsize"]
3629         if capsize > 0:
3630             eb_cap_style['markersize'] = 2. * capsize
3631         if capthick is not None:
3632             eb_cap_style['markeredgewidth'] = capthick
3633 
3634         # For backwards-compat, allow explicit setting of
3635         # 'markeredgewidth' to over-ride capthick.
3636         for key in ('markeredgewidth', 'transform', 'alpha',
3637                     'zorder', 'rasterized'):
3638             if key in kwargs:
3639                 eb_cap_style[key] = kwargs[key]
3640         eb_cap_style['color'] = ecolor
3641 
3642         barcols = []
3643         caplines = {'x': [], 'y': []}
3644 
3645         # Vectorized fancy-indexer.
3646         def apply_mask(arrays, mask):
3647             return [array[mask] for array in arrays]
3648 
3649         # dep: dependent dataset, indep: independent dataset
3650         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3651              marker, lomarker, himarker) in [
3652                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3653                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3654                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3655                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3656         ]:
3657             if err is None:
3658                 continue
3659             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3660             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3661             try:
3662                 np.broadcast_to(err, (2, len(dep)))
3663             except ValueError:
3664                 raise ValueError(
3665                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3666                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3667                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3668             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3669             if np.any(np.less(err, -err, out=res, where=(err == err))):
3670                 # like err<0, but also works for timedelta and nan.
3671                 raise ValueError(
3672                     f"'{dep_axis}err' must not contain negative values")
3673             # This is like
3674             #     elow, ehigh = np.broadcast_to(...)
3675             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3676             # except that broadcast_to would strip units.
3677             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3678             barcols.append(lines_func(
3679                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3680             if self.name == "polar" and dep_axis == "x":
3681                 for b in barcols:
3682                     for p in b.get_paths():
3683                         p._interpolation_steps = 2
3684             # Normal errorbars for points without upper/lower limits.
3685             nolims = ~(lolims | uplims)
3686             if nolims.any() and capsize > 0:
3687                 indep_masked, lo_masked, hi_masked = apply_mask(
3688                     [indep, low, high], nolims & everymask)
3689                 for lh_masked in [lo_masked, hi_masked]:
3690                     # Since this has to work for x and y as dependent data, we
3691                     # first set both x and y to the independent variable and
3692                     # overwrite the respective dependent data in a second step.
3693                     line = mlines.Line2D(indep_masked, indep_masked,
3694                                          marker=marker, **eb_cap_style)
3695                     line.set(**{f"{dep_axis}data": lh_masked})
3696                     caplines[dep_axis].append(line)
3697             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3698                 if not lims.any():
3699                     continue
3700                 hlmarker = (
3701                     himarker
3702                     if self._axis_map[dep_axis].get_inverted() ^ idx
3703                     else lomarker)
3704                 x_masked, y_masked, hl_masked = apply_mask(
3705                     [x, y, hl], lims & everymask)
3706                 # As above, we set the dependent data in a second step.
3707                 line = mlines.Line2D(x_masked, y_masked,
3708                                      marker=hlmarker, **eb_cap_style)
3709                 line.set(**{f"{dep_axis}data": hl_masked})
3710                 caplines[dep_axis].append(line)
3711                 if capsize > 0:
3712                     caplines[dep_axis].append(mlines.Line2D(
3713                         x_masked, y_masked, marker=marker, **eb_cap_style))
3714         if self.name == 'polar':
3715             for axis in caplines:
3716                 for l in caplines[axis]:
3717                     # Rotate caps to be perpendicular to the error bars
3718                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3719                         rotation = mtransforms.Affine2D().rotate(theta)
3720                         if axis == 'y':
3721                             rotation.rotate(-np.pi / 2)
3722                         ms = mmarkers.MarkerStyle(marker=marker,
3723                                                   transform=rotation)
3724                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3725                                                     **eb_cap_style))
3726         else:
3727             for axis in caplines:
3728                 for l in caplines[axis]:
3729                     self.add_line(l)
3730 
3731         self._request_autoscale_view()
3732         caplines = caplines['x'] + caplines['y']
3733         errorbar_container = ErrorbarContainer(
3734             (data_line, tuple(caplines), tuple(barcols)),
3735             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3736             label=label)
3737         self.containers.append(errorbar_container)
3738 
3739         return errorbar_container  # (l0, caplines, barcols)
3740 
3741     @_preprocess_data()
3742     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3743                 positions=None, widths=None, patch_artist=None,
3744                 bootstrap=None, usermedians=None, conf_intervals=None,
3745                 meanline=None, showmeans=None, showcaps=None,
3746                 showbox=None, showfliers=None, boxprops=None,
3747                 labels=None, flierprops=None, medianprops=None,
3748                 meanprops=None, capprops=None, whiskerprops=None,
3749                 manage_ticks=True, autorange=False, zorder=None,
3750                 capwidths=None):
3751         """
3752         Draw a box and whisker plot.
3753 
3754         The box extends from the first quartile (Q1) to the third
3755         quartile (Q3) of the data, with a line at the median.
3756         The whiskers extend from the box to the farthest data point
3757         lying within 1.5x the inter-quartile range (IQR) from the box.
3758         Flier points are those past the end of the whiskers.
3759         See https://en.wikipedia.org/wiki/Box_plot for reference.
3760 
3761         .. code-block:: none
3762 
3763                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3764                                |-----:-----|
3765                o      |--------|     :     |--------|    o  o
3766                                |-----:-----|
3767              flier             <----------->            fliers
3768                                     IQR
3769 
3770 
3771         Parameters
3772         ----------
3773         x : Array or a sequence of vectors.
3774             The input data.  If a 2D array, a boxplot is drawn for each column
3775             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3776             array in *x*.
3777 
3778         notch : bool, default: False
3779             Whether to draw a notched boxplot (`True`), or a rectangular
3780             boxplot (`False`).  The notches represent the confidence interval
3781             (CI) around the median.  The documentation for *bootstrap*
3782             describes how the locations of the notches are computed by
3783             default, but their locations may also be overridden by setting the
3784             *conf_intervals* parameter.
3785 
3786             .. note::
3787 
3788                 In cases where the values of the CI are less than the
3789                 lower quartile or greater than the upper quartile, the
3790                 notches will extend beyond the box, giving it a
3791                 distinctive "flipped" appearance. This is expected
3792                 behavior and consistent with other statistical
3793                 visualization packages.
3794 
3795         sym : str, optional
3796             The default symbol for flier points.  An empty string ('') hides
3797             the fliers.  If `None`, then the fliers default to 'b+'.  More
3798             control is provided by the *flierprops* parameter.
3799 
3800         vert : bool, default: True
3801             If `True`, draws vertical boxes.
3802             If `False`, draw horizontal boxes.
3803 
3804         whis : float or (float, float), default: 1.5
3805             The position of the whiskers.
3806 
3807             If a float, the lower whisker is at the lowest datum above
3808             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3809             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3810             third quartiles.  The default value of ``whis = 1.5`` corresponds
3811             to Tukey's original definition of boxplots.
3812 
3813             If a pair of floats, they indicate the percentiles at which to
3814             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3815             (0, 100) results in whiskers covering the whole range of the data.
3816 
3817             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3818             to (0, 100) (cover the whole range of the data) if *autorange* is
3819             True.
3820 
3821             Beyond the whiskers, data are considered outliers and are plotted
3822             as individual points.
3823 
3824         bootstrap : int, optional
3825             Specifies whether to bootstrap the confidence intervals
3826             around the median for notched boxplots. If *bootstrap* is
3827             None, no bootstrapping is performed, and notches are
3828             calculated using a Gaussian-based asymptotic approximation
3829             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3830             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3831             the number of times to bootstrap the median to determine its
3832             95% confidence intervals. Values between 1000 and 10000 are
3833             recommended.
3834 
3835         usermedians : 1D array-like, optional
3836             A 1D array-like of length ``len(x)``.  Each entry that is not
3837             `None` forces the value of the median for the corresponding
3838             dataset.  For entries that are `None`, the medians are computed
3839             by Matplotlib as normal.
3840 
3841         conf_intervals : array-like, optional
3842             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3843             None forces the location of the corresponding notch (which is
3844             only drawn if *notch* is `True`).  For entries that are `None`,
3845             the notches are computed by the method specified by the other
3846             parameters (e.g., *bootstrap*).
3847 
3848         positions : array-like, optional
3849             The positions of the boxes. The ticks and limits are
3850             automatically set to match the positions. Defaults to
3851             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3852 
3853         widths : float or array-like
3854             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3855             between extreme positions)``, if that is smaller.
3856 
3857         patch_artist : bool, default: False
3858             If `False` produces boxes with the Line2D artist. Otherwise,
3859             boxes are drawn with Patch artists.
3860 
3861         labels : sequence, optional
3862             Labels for each dataset (one per dataset).
3863 
3864         manage_ticks : bool, default: True
3865             If True, the tick locations and labels will be adjusted to match
3866             the boxplot positions.
3867 
3868         autorange : bool, default: False
3869             When `True` and the data are distributed such that the 25th and
3870             75th percentiles are equal, *whis* is set to (0, 100) such
3871             that the whisker ends are at the minimum and maximum of the data.
3872 
3873         meanline : bool, default: False
3874             If `True` (and *showmeans* is `True`), will try to render the
3875             mean as a line spanning the full width of the box according to
3876             *meanprops* (see below).  Not recommended if *shownotches* is also
3877             True.  Otherwise, means will be shown as points.
3878 
3879         zorder : float, default: ``Line2D.zorder = 2``
3880             The zorder of the boxplot.
3881 
3882         Returns
3883         -------
3884         dict
3885           A dictionary mapping each component of the boxplot to a list
3886           of the `.Line2D` instances created. That dictionary has the
3887           following keys (assuming vertical boxplots):
3888 
3889           - ``boxes``: the main body of the boxplot showing the
3890             quartiles and the median's confidence intervals if
3891             enabled.
3892 
3893           - ``medians``: horizontal lines at the median of each box.
3894 
3895           - ``whiskers``: the vertical lines extending to the most
3896             extreme, non-outlier data points.
3897 
3898           - ``caps``: the horizontal lines at the ends of the
3899             whiskers.
3900 
3901           - ``fliers``: points representing data that extend beyond
3902             the whiskers (fliers).
3903 
3904           - ``means``: points or lines representing the means.
3905 
3906         Other Parameters
3907         ----------------
3908         showcaps : bool, default: True
3909             Show the caps on the ends of whiskers.
3910         showbox : bool, default: True
3911             Show the central box.
3912         showfliers : bool, default: True
3913             Show the outliers beyond the caps.
3914         showmeans : bool, default: False
3915             Show the arithmetic means.
3916         capprops : dict, default: None
3917             The style of the caps.
3918         capwidths : float or array, default: None
3919             The widths of the caps.
3920         boxprops : dict, default: None
3921             The style of the box.
3922         whiskerprops : dict, default: None
3923             The style of the whiskers.
3924         flierprops : dict, default: None
3925             The style of the fliers.
3926         medianprops : dict, default: None
3927             The style of the median.
3928         meanprops : dict, default: None
3929             The style of the mean.
3930         data : indexable object, optional
3931             DATA_PARAMETER_PLACEHOLDER
3932 
3933         See Also
3934         --------
3935         violinplot : Draw an estimate of the probability density function.
3936         """
3937 
3938         # Missing arguments default to rcParams.
3939         if whis is None:
3940             whis = mpl.rcParams['boxplot.whiskers']
3941         if bootstrap is None:
3942             bootstrap = mpl.rcParams['boxplot.bootstrap']
3943 
3944         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3945                                        labels=labels, autorange=autorange)
3946         if notch is None:
3947             notch = mpl.rcParams['boxplot.notch']
3948         if vert is None:
3949             vert = mpl.rcParams['boxplot.vertical']
3950         if patch_artist is None:
3951             patch_artist = mpl.rcParams['boxplot.patchartist']
3952         if meanline is None:
3953             meanline = mpl.rcParams['boxplot.meanline']
3954         if showmeans is None:
3955             showmeans = mpl.rcParams['boxplot.showmeans']
3956         if showcaps is None:
3957             showcaps = mpl.rcParams['boxplot.showcaps']
3958         if showbox is None:
3959             showbox = mpl.rcParams['boxplot.showbox']
3960         if showfliers is None:
3961             showfliers = mpl.rcParams['boxplot.showfliers']
3962 
3963         if boxprops is None:
3964             boxprops = {}
3965         if whiskerprops is None:
3966             whiskerprops = {}
3967         if capprops is None:
3968             capprops = {}
3969         if medianprops is None:
3970             medianprops = {}
3971         if meanprops is None:
3972             meanprops = {}
3973         if flierprops is None:
3974             flierprops = {}
3975 
3976         if patch_artist:
3977             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3978             if 'color' in boxprops:
3979                 boxprops['edgecolor'] = boxprops.pop('color')
3980 
3981         # if non-default sym value, put it into the flier dictionary
3982         # the logic for providing the default symbol ('b+') now lives
3983         # in bxp in the initial value of flierkw
3984         # handle all of the *sym* related logic here so we only have to pass
3985         # on the flierprops dict.
3986         if sym is not None:
3987             # no-flier case, which should really be done with
3988             # 'showfliers=False' but none-the-less deal with it to keep back
3989             # compatibility
3990             if sym == '':
3991                 # blow away existing dict and make one for invisible markers
3992                 flierprops = dict(linestyle='none', marker='', color='none')
3993                 # turn the fliers off just to be safe
3994                 showfliers = False
3995             # now process the symbol string
3996             else:
3997                 # process the symbol string
3998                 # discarded linestyle
3999                 _, marker, color = _process_plot_format(sym)
4000                 # if we have a marker, use it
4001                 if marker is not None:
4002                     flierprops['marker'] = marker
4003                 # if we have a color, use it
4004                 if color is not None:
4005                     # assume that if color is passed in the user want
4006                     # filled symbol, if the users want more control use
4007                     # flierprops
4008                     flierprops['color'] = color
4009                     flierprops['markerfacecolor'] = color
4010                     flierprops['markeredgecolor'] = color
4011 
4012         # replace medians if necessary:
4013         if usermedians is not None:
4014             if (len(np.ravel(usermedians)) != len(bxpstats) or
4015                     np.shape(usermedians)[0] != len(bxpstats)):
4016                 raise ValueError(
4017                     "'usermedians' and 'x' have different lengths")
4018             else:
4019                 # reassign medians as necessary
4020                 for stats, med in zip(bxpstats, usermedians):
4021                     if med is not None:
4022                         stats['med'] = med
4023 
4024         if conf_intervals is not None:
4025             if len(conf_intervals) != len(bxpstats):
4026                 raise ValueError(
4027                     "'conf_intervals' and 'x' have different lengths")
4028             else:
4029                 for stats, ci in zip(bxpstats, conf_intervals):
4030                     if ci is not None:
4031                         if len(ci) != 2:
4032                             raise ValueError('each confidence interval must '
4033                                              'have two values')
4034                         else:
4035                             if ci[0] is not None:
4036                                 stats['cilo'] = ci[0]
4037                             if ci[1] is not None:
4038                                 stats['cihi'] = ci[1]
4039 
4040         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4041                            vert=vert, patch_artist=patch_artist,
4042                            shownotches=notch, showmeans=showmeans,
4043                            showcaps=showcaps, showbox=showbox,
4044                            boxprops=boxprops, flierprops=flierprops,
4045                            medianprops=medianprops, meanprops=meanprops,
4046                            meanline=meanline, showfliers=showfliers,
4047                            capprops=capprops, whiskerprops=whiskerprops,
4048                            manage_ticks=manage_ticks, zorder=zorder,
4049                            capwidths=capwidths)
4050         return artists
4051 
4052     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4053             patch_artist=False, shownotches=False, showmeans=False,
4054             showcaps=True, showbox=True, showfliers=True,
4055             boxprops=None, whiskerprops=None, flierprops=None,
4056             medianprops=None, capprops=None, meanprops=None,
4057             meanline=False, manage_ticks=True, zorder=None,
4058             capwidths=None):
4059         """
4060         Drawing function for box and whisker plots.
4061 
4062         Make a box and whisker plot for each column of *x* or each
4063         vector in sequence *x*.  The box extends from the lower to
4064         upper quartile values of the data, with a line at the median.
4065         The whiskers extend from the box to show the range of the
4066         data.  Flier points are those past the end of the whiskers.
4067 
4068         Parameters
4069         ----------
4070         bxpstats : list of dicts
4071           A list of dictionaries containing stats for each boxplot.
4072           Required keys are:
4073 
4074           - ``med``: Median (scalar).
4075           - ``q1``, ``q3``: First & third quartiles (scalars).
4076           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4077 
4078           Optional keys are:
4079 
4080           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4081           - ``fliers``: Data beyond the whiskers (array-like).
4082             Needed if ``showfliers=True``.
4083           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4084             about the median. Needed if ``shownotches=True``.
4085           - ``label``: Name of the dataset (str).  If available,
4086             this will be used a tick label for the boxplot
4087 
4088         positions : array-like, default: [1, 2, ..., n]
4089           The positions of the boxes. The ticks and limits
4090           are automatically set to match the positions.
4091 
4092         widths : float or array-like, default: None
4093           The widths of the boxes.  The default is
4094           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4095 
4096         capwidths : float or array-like, default: None
4097           Either a scalar or a vector and sets the width of each cap.
4098           The default is ``0.5*(with of the box)``, see *widths*.
4099 
4100         vert : bool, default: True
4101           If `True` (default), makes the boxes vertical.
4102           If `False`, makes horizontal boxes.
4103 
4104         patch_artist : bool, default: False
4105           If `False` produces boxes with the `.Line2D` artist.
4106           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4107 
4108         shownotches, showmeans, showcaps, showbox, showfliers : bool
4109           Whether to draw the CI notches, the mean value (both default to
4110           False), the caps, the box, and the fliers (all three default to
4111           True).
4112 
4113         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4114  dict, optional
4115           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4116           means.
4117 
4118         meanline : bool, default: False
4119           If `True` (and *showmeans* is `True`), will try to render the mean
4120           as a line spanning the full width of the box according to
4121           *meanprops*. Not recommended if *shownotches* is also True.
4122           Otherwise, means will be shown as points.
4123 
4124         manage_ticks : bool, default: True
4125           If True, the tick locations and labels will be adjusted to match the
4126           boxplot positions.
4127 
4128         zorder : float, default: ``Line2D.zorder = 2``
4129           The zorder of the resulting boxplot.
4130 
4131         Returns
4132         -------
4133         dict
4134           A dictionary mapping each component of the boxplot to a list
4135           of the `.Line2D` instances created. That dictionary has the
4136           following keys (assuming vertical boxplots):
4137 
4138           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4139             the median's confidence intervals if enabled.
4140           - ``medians``: horizontal lines at the median of each box.
4141           - ``whiskers``: vertical lines up to the last non-outlier data.
4142           - ``caps``: horizontal lines at the ends of the whiskers.
4143           - ``fliers``: points representing data beyond the whiskers (fliers).
4144           - ``means``: points or lines representing the means.
4145 
4146         Examples
4147         --------
4148         .. plot:: gallery/statistics/bxp.py
4149         """
4150 
4151         # lists of artists to be output
4152         whiskers = []
4153         caps = []
4154         boxes = []
4155         medians = []
4156         means = []
4157         fliers = []
4158 
4159         # empty list of xticklabels
4160         datalabels = []
4161 
4162         # Use default zorder if none specified
4163         if zorder is None:
4164             zorder = mlines.Line2D.zorder
4165 
4166         zdelta = 0.1
4167 
4168         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4169             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4170                  if k.startswith(f'boxplot.{subkey}props')}
4171             d['zorder'] = zorder + zdelta
4172             if not usemarker:
4173                 d['marker'] = ''
4174             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4175             return d
4176 
4177         box_kw = {
4178             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4179             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4180             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4181             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4182                           else mpl.rcParams['patch.facecolor']),
4183             'zorder': zorder,
4184             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4185         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4186         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4187         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4188         flier_kw = merge_kw_rc('flier', flierprops)
4189         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4190         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4191         removed_prop = 'marker' if meanline else 'linestyle'
4192         # Only remove the property if it's not set explicitly as a parameter.
4193         if meanprops is None or removed_prop not in meanprops:
4194             mean_kw[removed_prop] = ''
4195 
4196         # vertical or horizontal plot?
4197         maybe_swap = slice(None) if vert else slice(None, None, -1)
4198 
4199         def do_plot(xs, ys, **kwargs):
4200             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4201 
4202         def do_patch(xs, ys, **kwargs):
4203             path = mpath.Path._create_closed(
4204                 np.column_stack([xs, ys][maybe_swap]))
4205             patch = mpatches.PathPatch(path, **kwargs)
4206             self.add_artist(patch)
4207             return patch
4208 
4209         # input validation
4210         N = len(bxpstats)
4211         datashape_message = ("List of boxplot statistics and `{0}` "
4212                              "values must have same the length")
4213         # check position
4214         if positions is None:
4215             positions = list(range(1, N + 1))
4216         elif len(positions) != N:
4217             raise ValueError(datashape_message.format("positions"))
4218 
4219         positions = np.array(positions)
4220         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4221             raise TypeError("positions should be an iterable of numbers")
4222 
4223         # width
4224         if widths is None:
4225             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4226         elif np.isscalar(widths):
4227             widths = [widths] * N
4228         elif len(widths) != N:
4229             raise ValueError(datashape_message.format("widths"))
4230 
4231         # capwidth
4232         if capwidths is None:
4233             capwidths = 0.5 * np.array(widths)
4234         elif np.isscalar(capwidths):
4235             capwidths = [capwidths] * N
4236         elif len(capwidths) != N:
4237             raise ValueError(datashape_message.format("capwidths"))
4238 
4239         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4240                                                capwidths):
4241             # try to find a new label
4242             datalabels.append(stats.get('label', pos))
4243 
4244             # whisker coords
4245             whis_x = [pos, pos]
4246             whislo_y = [stats['q1'], stats['whislo']]
4247             whishi_y = [stats['q3'], stats['whishi']]
4248             # cap coords
4249             cap_left = pos - capwidth * 0.5
4250             cap_right = pos + capwidth * 0.5
4251             cap_x = [cap_left, cap_right]
4252             cap_lo = np.full(2, stats['whislo'])
4253             cap_hi = np.full(2, stats['whishi'])
4254             # box and median coords
4255             box_left = pos - width * 0.5
4256             box_right = pos + width * 0.5
4257             med_y = [stats['med'], stats['med']]
4258             # notched boxes
4259             if shownotches:
4260                 notch_left = pos - width * 0.25
4261                 notch_right = pos + width * 0.25
4262                 box_x = [box_left, box_right, box_right, notch_right,
4263                          box_right, box_right, box_left, box_left, notch_left,
4264                          box_left, box_left]
4265                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4266                          stats['med'], stats['cihi'], stats['q3'],
4267                          stats['q3'], stats['cihi'], stats['med'],
4268                          stats['cilo'], stats['q1']]
4269                 med_x = [notch_left, notch_right]
4270             # plain boxes
4271             else:
4272                 box_x = [box_left, box_right, box_right, box_left, box_left]
4273                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4274                          stats['q1']]
4275                 med_x = [box_left, box_right]
4276 
4277             # maybe draw the box
4278             if showbox:
4279                 do_box = do_patch if patch_artist else do_plot
4280                 boxes.append(do_box(box_x, box_y, **box_kw))
4281             # draw the whiskers
4282             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4283             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4284             # maybe draw the caps
4285             if showcaps:
4286                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4287                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4288             # draw the medians
4289             medians.append(do_plot(med_x, med_y, **median_kw))
4290             # maybe draw the means
4291             if showmeans:
4292                 if meanline:
4293                     means.append(do_plot(
4294                         [box_left, box_right], [stats['mean'], stats['mean']],
4295                         **mean_kw
4296                     ))
4297                 else:
4298                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4299             # maybe draw the fliers
4300             if showfliers:
4301                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4302                 flier_y = stats['fliers']
4303                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4304 
4305         if manage_ticks:
4306             axis_name = "x" if vert else "y"
4307             interval = getattr(self.dataLim, f"interval{axis_name}")
4308             axis = self._axis_map[axis_name]
4309             positions = axis.convert_units(positions)
4310             # The 0.5 additional padding ensures reasonable-looking boxes
4311             # even when drawing a single box.  We set the sticky edge to
4312             # prevent margins expansion, in order to match old behavior (back
4313             # when separate calls to boxplot() would completely reset the axis
4314             # limits regardless of what was drawn before).  The sticky edges
4315             # are attached to the median lines, as they are always present.
4316             interval[:] = (min(interval[0], min(positions) - .5),
4317                            max(interval[1], max(positions) + .5))
4318             for median, position in zip(medians, positions):
4319                 getattr(median.sticky_edges, axis_name).extend(
4320                     [position - .5, position + .5])
4321             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4322             locator = axis.get_major_locator()
4323             if not isinstance(axis.get_major_locator(),
4324                               mticker.FixedLocator):
4325                 locator = mticker.FixedLocator([])
4326                 axis.set_major_locator(locator)
4327             locator.locs = np.array([*locator.locs, *positions])
4328             formatter = axis.get_major_formatter()
4329             if not isinstance(axis.get_major_formatter(),
4330                               mticker.FixedFormatter):
4331                 formatter = mticker.FixedFormatter([])
4332                 axis.set_major_formatter(formatter)
4333             formatter.seq = [*formatter.seq, *datalabels]
4334 
4335             self._request_autoscale_view()
4336 
4337         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4338                     medians=medians, fliers=fliers, means=means)
4339 
4340     @staticmethod
4341     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4342                                   get_next_color_func):
4343         """
4344         Helper function to process color related arguments of `.Axes.scatter`.
4345 
4346         Argument precedence for facecolors:
4347 
4348         - c (if not None)
4349         - kwargs['facecolor']
4350         - kwargs['facecolors']
4351         - kwargs['color'] (==kwcolor)
4352         - 'b' if in classic mode else the result of ``get_next_color_func()``
4353 
4354         Argument precedence for edgecolors:
4355 
4356         - kwargs['edgecolor']
4357         - edgecolors (is an explicit kw argument in scatter())
4358         - kwargs['color'] (==kwcolor)
4359         - 'face' if not in classic mode else None
4360 
4361         Parameters
4362         ----------
4363         c : color or sequence or sequence of color or None
4364             See argument description of `.Axes.scatter`.
4365         edgecolors : color or sequence of color or {'face', 'none'} or None
4366             See argument description of `.Axes.scatter`.
4367         kwargs : dict
4368             Additional kwargs. If these keys exist, we pop and process them:
4369             'facecolors', 'facecolor', 'edgecolor', 'color'
4370             Note: The dict is modified by this function.
4371         xsize : int
4372             The size of the x and y arrays passed to `.Axes.scatter`.
4373         get_next_color_func : callable
4374             A callable that returns a color. This color is used as facecolor
4375             if no other color is provided.
4376 
4377             Note, that this is a function rather than a fixed color value to
4378             support conditional evaluation of the next color.  As of the
4379             current implementation obtaining the next color from the
4380             property cycle advances the cycle. This must only happen if we
4381             actually use the color, which will only be decided within this
4382             method.
4383 
4384         Returns
4385         -------
4386         c
4387             The input *c* if it was not *None*, else a color derived from the
4388             other inputs or defaults.
4389         colors : array(N, 4) or None
4390             The facecolors as RGBA values, or *None* if a colormap is used.
4391         edgecolors
4392             The edgecolor.
4393 
4394         """
4395         facecolors = kwargs.pop('facecolors', None)
4396         facecolors = kwargs.pop('facecolor', facecolors)
4397         edgecolors = kwargs.pop('edgecolor', edgecolors)
4398 
4399         kwcolor = kwargs.pop('color', None)
4400 
4401         if kwcolor is not None and c is not None:
4402             raise ValueError("Supply a 'c' argument or a 'color'"
4403                              " kwarg but not both; they differ but"
4404                              " their functionalities overlap.")
4405 
4406         if kwcolor is not None:
4407             try:
4408                 mcolors.to_rgba_array(kwcolor)
4409             except ValueError as err:
4410                 raise ValueError(
4411                     "'color' kwarg must be a color or sequence of color "
4412                     "specs.  For a sequence of values to be color-mapped, use "
4413                     "the 'c' argument instead.") from err
4414             if edgecolors is None:
4415                 edgecolors = kwcolor
4416             if facecolors is None:
4417                 facecolors = kwcolor
4418 
4419         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4420             edgecolors = mpl.rcParams['scatter.edgecolors']
4421 
4422         c_was_none = c is None
4423         if c is None:
4424             c = (facecolors if facecolors is not None
4425                  else "b" if mpl.rcParams['_internal.classic_mode']
4426                  else get_next_color_func())
4427         c_is_string_or_strings = (
4428             isinstance(c, str)
4429             or (np.iterable(c) and len(c) > 0
4430                 and isinstance(cbook._safe_first_finite(c), str)))
4431 
4432         def invalid_shape_exception(csize, xsize):
4433             return ValueError(
4434                 f"'c' argument has {csize} elements, which is inconsistent "
4435                 f"with 'x' and 'y' with size {xsize}.")
4436 
4437         c_is_mapped = False  # Unless proven otherwise below.
4438         valid_shape = True  # Unless proven otherwise below.
4439         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4440             try:  # First, does 'c' look suitable for value-mapping?
4441                 c = np.asanyarray(c, dtype=float)
4442             except ValueError:
4443                 pass  # Failed to convert to float array; must be color specs.
4444             else:
4445                 # handle the documented special case of a 2D array with 1
4446                 # row which as RGB(A) to broadcast.
4447                 if c.shape == (1, 4) or c.shape == (1, 3):
4448                     c_is_mapped = False
4449                     if c.size != xsize:
4450                         valid_shape = False
4451                 # If c can be either mapped values or an RGB(A) color, prefer
4452                 # the former if shapes match, the latter otherwise.
4453                 elif c.size == xsize:
4454                     c = c.ravel()
4455                     c_is_mapped = True
4456                 else:  # Wrong size; it must not be intended for mapping.
4457                     if c.shape in ((3,), (4,)):
4458                         _api.warn_external(
4459                             "*c* argument looks like a single numeric RGB or "
4460                             "RGBA sequence, which should be avoided as value-"
4461                             "mapping will have precedence in case its length "
4462                             "matches with *x* & *y*.  Please use the *color* "
4463                             "keyword-argument or provide a 2D array "
4464                             "with a single row if you intend to specify "
4465                             "the same RGB or RGBA value for all points.")
4466                     valid_shape = False
4467         if not c_is_mapped:
4468             try:  # Is 'c' acceptable as PathCollection facecolors?
4469                 colors = mcolors.to_rgba_array(c)
4470             except (TypeError, ValueError) as err:
4471                 if "RGBA values should be within 0-1 range" in str(err):
4472                     raise
4473                 else:
4474                     if not valid_shape:
4475                         raise invalid_shape_exception(c.size, xsize) from err
4476                     # Both the mapping *and* the RGBA conversion failed: pretty
4477                     # severe failure => one may appreciate a verbose feedback.
4478                     raise ValueError(
4479                         f"'c' argument must be a color, a sequence of colors, "
4480                         f"or a sequence of numbers, not {c!r}") from err
4481             else:
4482                 if len(colors) not in (0, 1, xsize):
4483                     # NB: remember that a single color is also acceptable.
4484                     # Besides *colors* will be an empty array if c == 'none'.
4485                     raise invalid_shape_exception(len(colors), xsize)
4486         else:
4487             colors = None  # use cmap, norm after collection is created
4488         return c, colors, edgecolors
4489 
4490     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4491                                      "edgecolors", "c", "facecolor",
4492                                      "facecolors", "color"],
4493                       label_namer="y")
4494     @_docstring.interpd
4495     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4496                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4497                 edgecolors=None, plotnonfinite=False, **kwargs):
4498         """
4499         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4500 
4501         Parameters
4502         ----------
4503         x, y : float or array-like, shape (n, )
4504             The data positions.
4505 
4506         s : float or array-like, shape (n, ), optional
4507             The marker size in points**2 (typographic points are 1/72 in.).
4508             Default is ``rcParams['lines.markersize'] ** 2``.
4509 
4510             The linewidth and edgecolor can visually interact with the marker
4511             size, and can lead to artifacts if the marker size is smaller than
4512             the linewidth.
4513 
4514             If the linewidth is greater than 0 and the edgecolor is anything
4515             but *'none'*, then the effective size of the marker will be
4516             increased by half the linewidth because the stroke will be centered
4517             on the edge of the shape.
4518 
4519             To eliminate the marker edge either set *linewidth=0* or
4520             *edgecolor='none'*.
4521 
4522         c : array-like or list of colors or color, optional
4523             The marker colors. Possible values:
4524 
4525             - A scalar or sequence of n numbers to be mapped to colors using
4526               *cmap* and *norm*.
4527             - A 2D array in which the rows are RGB or RGBA.
4528             - A sequence of colors of length n.
4529             - A single color format string.
4530 
4531             Note that *c* should not be a single numeric RGB or RGBA sequence
4532             because that is indistinguishable from an array of values to be
4533             colormapped. If you want to specify the same RGB or RGBA value for
4534             all points, use a 2D array with a single row.  Otherwise,
4535             value-matching will have precedence in case of a size matching with
4536             *x* and *y*.
4537 
4538             If you wish to specify a single color for all points
4539             prefer the *color* keyword argument.
4540 
4541             Defaults to `None`. In that case the marker color is determined
4542             by the value of *color*, *facecolor* or *facecolors*. In case
4543             those are not specified or `None`, the marker color is determined
4544             by the next color of the ``Axes``' current "shape and fill" color
4545             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4546 
4547         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4548             The marker style. *marker* can be either an instance of the class
4549             or the text shorthand for a particular marker.
4550             See :mod:`matplotlib.markers` for more information about marker
4551             styles.
4552 
4553         %(cmap_doc)s
4554 
4555             This parameter is ignored if *c* is RGB(A).
4556 
4557         %(norm_doc)s
4558 
4559             This parameter is ignored if *c* is RGB(A).
4560 
4561         %(vmin_vmax_doc)s
4562 
4563             This parameter is ignored if *c* is RGB(A).
4564 
4565         alpha : float, default: None
4566             The alpha blending value, between 0 (transparent) and 1 (opaque).
4567 
4568         linewidths : float or array-like, default: :rc:`lines.linewidth`
4569             The linewidth of the marker edges. Note: The default *edgecolors*
4570             is 'face'. You may want to change this as well.
4571 
4572         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4573 default: :rc:`scatter.edgecolors`
4574             The edge color of the marker. Possible values:
4575 
4576             - 'face': The edge color will always be the same as the face color.
4577             - 'none': No patch boundary will be drawn.
4578             - A color or sequence of colors.
4579 
4580             For non-filled markers, *edgecolors* is ignored. Instead, the color
4581             is determined like with 'face', i.e. from *c*, *colors*, or
4582             *facecolors*.
4583 
4584         plotnonfinite : bool, default: False
4585             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4586             or ``nan``). If ``True`` the points are drawn with the *bad*
4587             colormap color (see `.Colormap.set_bad`).
4588 
4589         Returns
4590         -------
4591         `~matplotlib.collections.PathCollection`
4592 
4593         Other Parameters
4594         ----------------
4595         data : indexable object, optional
4596             DATA_PARAMETER_PLACEHOLDER
4597         **kwargs : `~matplotlib.collections.Collection` properties
4598 
4599         See Also
4600         --------
4601         plot : To plot scatter plots when markers are identical in size and
4602             color.
4603 
4604         Notes
4605         -----
4606         * The `.plot` function will be faster for scatterplots where markers
4607           don't vary in size or color.
4608 
4609         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4610           case all masks will be combined and only unmasked points will be
4611           plotted.
4612 
4613         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4614           may be input as N-D arrays, but within scatter they will be
4615           flattened. The exception is *c*, which will be flattened only if its
4616           size matches the size of *x* and *y*.
4617 
4618         """
4619         # add edgecolors and linewidths to kwargs so they
4620         # can be processed by normailze_kwargs
4621         if edgecolors is not None:
4622             kwargs.update({'edgecolors': edgecolors})
4623         if linewidths is not None:
4624             kwargs.update({'linewidths': linewidths})
4625 
4626         kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
4627         # re direct linewidth and edgecolor so it can be
4628         # further processed by the rest of the function
4629         linewidths = kwargs.pop('linewidth', None)
4630         edgecolors = kwargs.pop('edgecolor', None)
4631         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4632         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4633         # np.ma.ravel yields an ndarray, not a masked array,
4634         # unless its argument is a masked array.
4635         x = np.ma.ravel(x)
4636         y = np.ma.ravel(y)
4637         if x.size != y.size:
4638             raise ValueError("x and y must be the same size")
4639 
4640         if s is None:
4641             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4642                  mpl.rcParams['lines.markersize'] ** 2.0)
4643         s = np.ma.ravel(s)
4644         if (len(s) not in (1, x.size) or
4645                 (not np.issubdtype(s.dtype, np.floating) and
4646                  not np.issubdtype(s.dtype, np.integer))):
4647             raise ValueError(
4648                 "s must be a scalar, "
4649                 "or float array-like with the same size as x and y")
4650 
4651         # get the original edgecolor the user passed before we normalize
4652         orig_edgecolor = edgecolors
4653         if edgecolors is None:
4654             orig_edgecolor = kwargs.get('edgecolor', None)
4655         c, colors, edgecolors = \
4656             self._parse_scatter_color_args(
4657                 c, edgecolors, kwargs, x.size,
4658                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4659 
4660         if plotnonfinite and colors is None:
4661             c = np.ma.masked_invalid(c)
4662             x, y, s, edgecolors, linewidths = \
4663                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4664         else:
4665             x, y, s, c, colors, edgecolors, linewidths = \
4666                 cbook._combine_masks(
4667                     x, y, s, c, colors, edgecolors, linewidths)
4668         # Unmask edgecolors if it was actually a single RGB or RGBA.
4669         if (x.size in (3, 4)
4670                 and np.ma.is_masked(edgecolors)
4671                 and not np.ma.is_masked(orig_edgecolor)):
4672             edgecolors = edgecolors.data
4673 
4674         scales = s   # Renamed for readability below.
4675 
4676         # load default marker from rcParams
4677         if marker is None:
4678             marker = mpl.rcParams['scatter.marker']
4679 
4680         if isinstance(marker, mmarkers.MarkerStyle):
4681             marker_obj = marker
4682         else:
4683             marker_obj = mmarkers.MarkerStyle(marker)
4684 
4685         path = marker_obj.get_path().transformed(
4686             marker_obj.get_transform())
4687         if not marker_obj.is_filled():
4688             if orig_edgecolor is not None:
4689                 _api.warn_external(
4690                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4691                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4692                     "ignoring the edgecolor in favor of the facecolor.  This "
4693                     "behavior may change in the future."
4694                 )
4695             # We need to handle markers that cannot be filled (like
4696             # '+' and 'x') differently than markers that can be
4697             # filled, but have their fillstyle set to 'none'.  This is
4698             # to get:
4699             #
4700             #  - respecting the fillestyle if set
4701             #  - maintaining back-compatibility for querying the facecolor of
4702             #    the un-fillable markers.
4703             #
4704             # While not an ideal situation, but is better than the
4705             # alternatives.
4706             if marker_obj.get_fillstyle() == 'none':
4707                 # promote the facecolor to be the edgecolor
4708                 edgecolors = colors
4709                 # set the facecolor to 'none' (at the last chance) because
4710                 # we cannot fill a path if the facecolor is non-null
4711                 # (which is defendable at the renderer level).
4712                 colors = 'none'
4713             else:
4714                 # if we are not nulling the face color we can do this
4715                 # simpler
4716                 edgecolors = 'face'
4717 
4718             if linewidths is None:
4719                 linewidths = mpl.rcParams['lines.linewidth']
4720             elif np.iterable(linewidths):
4721                 linewidths = [
4722                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4723                     for lw in linewidths]
4724 
4725         offsets = np.ma.column_stack([x, y])
4726 
4727         collection = mcoll.PathCollection(
4728             (path,), scales,
4729             facecolors=colors,
4730             edgecolors=edgecolors,
4731             linewidths=linewidths,
4732             offsets=offsets,
4733             offset_transform=kwargs.pop('transform', self.transData),
4734             alpha=alpha,
4735         )
4736         collection.set_transform(mtransforms.IdentityTransform())
4737         if colors is None:
4738             collection.set_array(c)
4739             collection.set_cmap(cmap)
4740             collection.set_norm(norm)
4741             collection._scale_norm(norm, vmin, vmax)
4742         else:
4743             extra_kwargs = {
4744                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4745                     }
4746             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4747             if any(extra_keys):
4748                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4749                 _api.warn_external(
4750                     "No data for colormapping provided via 'c'. "
4751                     f"Parameters {keys_str} will be ignored")
4752         collection._internal_update(kwargs)
4753 
4754         # Classic mode only:
4755         # ensure there are margins to allow for the
4756         # finite size of the symbols.  In v2.x, margins
4757         # are present by default, so we disable this
4758         # scatter-specific override.
4759         if mpl.rcParams['_internal.classic_mode']:
4760             if self._xmargin < 0.05 and x.size > 0:
4761                 self.set_xmargin(0.05)
4762             if self._ymargin < 0.05 and x.size > 0:
4763                 self.set_ymargin(0.05)
4764 
4765         self.add_collection(collection)
4766         self._request_autoscale_view()
4767 
4768         return collection
4769 
4770     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4771     @_docstring.dedent_interpd
4772     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4773                xscale='linear', yscale='linear', extent=None,
4774                cmap=None, norm=None, vmin=None, vmax=None,
4775                alpha=None, linewidths=None, edgecolors='face',
4776                reduce_C_function=np.mean, mincnt=None, marginals=False,
4777                **kwargs):
4778         """
4779         Make a 2D hexagonal binning plot of points *x*, *y*.
4780 
4781         If *C* is *None*, the value of the hexagon is determined by the number
4782         of points in the hexagon. Otherwise, *C* specifies values at the
4783         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4784         using *reduce_C_function*.
4785 
4786         Parameters
4787         ----------
4788         x, y : array-like
4789             The data positions. *x* and *y* must be of the same length.
4790 
4791         C : array-like, optional
4792             If given, these values are accumulated in the bins. Otherwise,
4793             every point has a value of 1. Must be of the same length as *x*
4794             and *y*.
4795 
4796         gridsize : int or (int, int), default: 100
4797             If a single int, the number of hexagons in the *x*-direction.
4798             The number of hexagons in the *y*-direction is chosen such that
4799             the hexagons are approximately regular.
4800 
4801             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4802             in the *x*-direction and the *y*-direction. In the
4803             *y*-direction, counting is done along vertically aligned
4804             hexagons, not along the zig-zag chains of hexagons; see the
4805             following illustration.
4806 
4807             .. plot::
4808 
4809                import numpy
4810                import matplotlib.pyplot as plt
4811 
4812                np.random.seed(19680801)
4813                n= 300
4814                x = np.random.standard_normal(n)
4815                y = np.random.standard_normal(n)
4816 
4817                fig, ax = plt.subplots(figsize=(4, 4))
4818                h = ax.hexbin(x, y, gridsize=(5, 3))
4819                hx, hy = h.get_offsets().T
4820                ax.plot(hx[24::3], hy[24::3], 'ro-')
4821                ax.plot(hx[-3:], hy[-3:], 'ro-')
4822                ax.set_title('gridsize=(5, 3)')
4823                ax.axis('off')
4824 
4825             To get approximately regular hexagons, choose
4826             :math:`n_x = \\sqrt{3}\\,n_y`.
4827 
4828         bins : 'log' or int or sequence, default: None
4829             Discretization of the hexagon values.
4830 
4831             - If *None*, no binning is applied; the color of each hexagon
4832               directly corresponds to its count value.
4833             - If 'log', use a logarithmic scale for the colormap.
4834               Internally, :math:`log_{10}(i+1)` is used to determine the
4835               hexagon color. This is equivalent to ``norm=LogNorm()``.
4836             - If an integer, divide the counts in the specified number
4837               of bins, and color the hexagons accordingly.
4838             - If a sequence of values, the values of the lower bound of
4839               the bins to be used.
4840 
4841         xscale : {'linear', 'log'}, default: 'linear'
4842             Use a linear or log10 scale on the horizontal axis.
4843 
4844         yscale : {'linear', 'log'}, default: 'linear'
4845             Use a linear or log10 scale on the vertical axis.
4846 
4847         mincnt : int > 0, default: *None*
4848             If not *None*, only display cells with more than *mincnt*
4849             number of points in the cell.
4850 
4851         marginals : bool, default: *False*
4852             If marginals is *True*, plot the marginal density as
4853             colormapped rectangles along the bottom of the x-axis and
4854             left of the y-axis.
4855 
4856         extent : 4-tuple of float, default: *None*
4857             The limits of the bins (xmin, xmax, ymin, ymax).
4858             The default assigns the limits based on
4859             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4860 
4861             If *xscale* or *yscale* is set to 'log', the limits are
4862             expected to be the exponent for a power of 10. E.g. for
4863             x-limits of 1 and 50 in 'linear' scale and y-limits
4864             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4865 
4866         Returns
4867         -------
4868         `~matplotlib.collections.PolyCollection`
4869             A `.PolyCollection` defining the hexagonal bins.
4870 
4871             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4872               the x, y positions of the M hexagon centers.
4873             - `.PolyCollection.get_array` contains the values of the M
4874               hexagons.
4875 
4876             If *marginals* is *True*, horizontal
4877             bar and vertical bar (both PolyCollections) will be attached
4878             to the return collection as attributes *hbar* and *vbar*.
4879 
4880         Other Parameters
4881         ----------------
4882         %(cmap_doc)s
4883 
4884         %(norm_doc)s
4885 
4886         %(vmin_vmax_doc)s
4887 
4888         alpha : float between 0 and 1, optional
4889             The alpha blending value, between 0 (transparent) and 1 (opaque).
4890 
4891         linewidths : float, default: *None*
4892             If *None*, defaults to :rc:`patch.linewidth`.
4893 
4894         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4895             The color of the hexagon edges. Possible values are:
4896 
4897             - 'face': Draw the edges in the same color as the fill color.
4898             - 'none': No edges are drawn. This can sometimes lead to unsightly
4899               unpainted pixels between the hexagons.
4900             - *None*: Draw outlines in the default color.
4901             - An explicit color.
4902 
4903         reduce_C_function : callable, default: `numpy.mean`
4904             The function to aggregate *C* within the bins. It is ignored if
4905             *C* is not given. This must have the signature::
4906 
4907                 def reduce_C_function(C: array) -> float
4908 
4909             Commonly used functions are:
4910 
4911             - `numpy.mean`: average of the points
4912             - `numpy.sum`: integral of the point values
4913             - `numpy.amax`: value taken from the largest point
4914 
4915         data : indexable object, optional
4916             DATA_PARAMETER_PLACEHOLDER
4917 
4918         **kwargs : `~matplotlib.collections.PolyCollection` properties
4919             All other keyword arguments are passed on to `.PolyCollection`:
4920 
4921             %(PolyCollection:kwdoc)s
4922 
4923         See Also
4924         --------
4925         hist2d : 2D histogram rectangular bins
4926         """
4927         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4928 
4929         x, y, C = cbook.delete_masked_points(x, y, C)
4930 
4931         # Set the size of the hexagon grid
4932         if np.iterable(gridsize):
4933             nx, ny = gridsize
4934         else:
4935             nx = gridsize
4936             ny = int(nx / math.sqrt(3))
4937         # Count the number of data in each hexagon
4938         x = np.asarray(x, float)
4939         y = np.asarray(y, float)
4940 
4941         # Will be log()'d if necessary, and then rescaled.
4942         tx = x
4943         ty = y
4944 
4945         if xscale == 'log':
4946             if np.any(x <= 0.0):
4947                 raise ValueError(
4948                     "x contains non-positive values, so cannot be log-scaled")
4949             tx = np.log10(tx)
4950         if yscale == 'log':
4951             if np.any(y <= 0.0):
4952                 raise ValueError(
4953                     "y contains non-positive values, so cannot be log-scaled")
4954             ty = np.log10(ty)
4955         if extent is not None:
4956             xmin, xmax, ymin, ymax = extent
4957         else:
4958             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4959             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4960 
4961             # to avoid issues with singular data, expand the min/max pairs
4962             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4963             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4964 
4965         nx1 = nx + 1
4966         ny1 = ny + 1
4967         nx2 = nx
4968         ny2 = ny
4969         n = nx1 * ny1 + nx2 * ny2
4970 
4971         # In the x-direction, the hexagons exactly cover the region from
4972         # xmin to xmax. Need some padding to avoid roundoff errors.
4973         padding = 1.e-9 * (xmax - xmin)
4974         xmin -= padding
4975         xmax += padding
4976         sx = (xmax - xmin) / nx
4977         sy = (ymax - ymin) / ny
4978         # Positions in hexagon index coordinates.
4979         ix = (tx - xmin) / sx
4980         iy = (ty - ymin) / sy
4981         ix1 = np.round(ix).astype(int)
4982         iy1 = np.round(iy).astype(int)
4983         ix2 = np.floor(ix).astype(int)
4984         iy2 = np.floor(iy).astype(int)
4985         # flat indices, plus one so that out-of-range points go to position 0.
4986         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4987                       ix1 * ny1 + iy1 + 1, 0)
4988         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4989                       ix2 * ny2 + iy2 + 1, 0)
4990 
4991         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4992         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4993         bdist = (d1 < d2)
4994 
4995         if C is None:  # [1:] drops out-of-range points.
4996             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4997             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4998             accum = np.concatenate([counts1, counts2]).astype(float)
4999             if mincnt is not None:
5000                 accum[accum < mincnt] = np.nan
5001             C = np.ones(len(x))
5002         else:
5003             # store the C values in a list per hexagon index
5004             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
5005             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
5006             for i in range(len(x)):
5007                 if bdist[i]:
5008                     Cs_at_i1[i1[i]].append(C[i])
5009                 else:
5010                     Cs_at_i2[i2[i]].append(C[i])
5011             if mincnt is None:
5012                 mincnt = 0
5013             accum = np.array(
5014                 [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
5015                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
5016                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
5017                 float)
5018 
5019         good_idxs = ~np.isnan(accum)
5020 
5021         offsets = np.zeros((n, 2), float)
5022         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
5023         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
5024         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
5025         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
5026         offsets[:, 0] *= sx
5027         offsets[:, 1] *= sy
5028         offsets[:, 0] += xmin
5029         offsets[:, 1] += ymin
5030         # remove accumulation bins with no data
5031         offsets = offsets[good_idxs, :]
5032         accum = accum[good_idxs]
5033 
5034         polygon = [sx, sy / 3] * np.array(
5035             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5036 
5037         if linewidths is None:
5038             linewidths = [mpl.rcParams['patch.linewidth']]
5039 
5040         if xscale == 'log' or yscale == 'log':
5041             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5042             if xscale == 'log':
5043                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5044                 xmin = 10.0 ** xmin
5045                 xmax = 10.0 ** xmax
5046                 self.set_xscale(xscale)
5047             if yscale == 'log':
5048                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5049                 ymin = 10.0 ** ymin
5050                 ymax = 10.0 ** ymax
5051                 self.set_yscale(yscale)
5052             collection = mcoll.PolyCollection(
5053                 polygons,
5054                 edgecolors=edgecolors,
5055                 linewidths=linewidths,
5056                 )
5057         else:
5058             collection = mcoll.PolyCollection(
5059                 [polygon],
5060                 edgecolors=edgecolors,
5061                 linewidths=linewidths,
5062                 offsets=offsets,
5063                 offset_transform=mtransforms.AffineDeltaTransform(
5064                     self.transData),
5065             )
5066 
5067         # Set normalizer if bins is 'log'
5068         if bins == 'log':
5069             if norm is not None:
5070                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5071                                    f"can be supplied, ignoring bins={bins}")
5072             else:
5073                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5074                 vmin = vmax = None
5075             bins = None
5076 
5077         # autoscale the norm with current accum values if it hasn't been set
5078         if norm is not None:
5079             if norm.vmin is None and norm.vmax is None:
5080                 norm.autoscale(accum)
5081 
5082         if bins is not None:
5083             if not np.iterable(bins):
5084                 minimum, maximum = min(accum), max(accum)
5085                 bins -= 1  # one less edge than bins
5086                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5087             bins = np.sort(bins)
5088             accum = bins.searchsorted(accum)
5089 
5090         collection.set_array(accum)
5091         collection.set_cmap(cmap)
5092         collection.set_norm(norm)
5093         collection.set_alpha(alpha)
5094         collection._internal_update(kwargs)
5095         collection._scale_norm(norm, vmin, vmax)
5096 
5097         corners = ((xmin, ymin), (xmax, ymax))
5098         self.update_datalim(corners)
5099         self._request_autoscale_view(tight=True)
5100 
5101         # add the collection last
5102         self.add_collection(collection, autolim=False)
5103         if not marginals:
5104             return collection
5105 
5106         # Process marginals
5107         bars = []
5108         for zname, z, zmin, zmax, zscale, nbins in [
5109                 ("x", x, xmin, xmax, xscale, nx),
5110                 ("y", y, ymin, ymax, yscale, 2 * ny),
5111         ]:
5112 
5113             if zscale == "log":
5114                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5115             else:
5116                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5117 
5118             verts = np.empty((nbins, 4, 2))
5119             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5120             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5121             verts[:, 0, 1] = verts[:, 3, 1] = .00
5122             verts[:, 1, 1] = verts[:, 2, 1] = .05
5123             if zname == "y":
5124                 verts = verts[:, :, ::-1]  # Swap x and y.
5125 
5126             # Sort z-values into bins defined by bin_edges.
5127             bin_idxs = np.searchsorted(bin_edges, z) - 1
5128             values = np.empty(nbins)
5129             for i in range(nbins):
5130                 # Get C-values for each bin, and compute bin value with
5131                 # reduce_C_function.
5132                 ci = C[bin_idxs == i]
5133                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5134 
5135             mask = ~np.isnan(values)
5136             verts = verts[mask]
5137             values = values[mask]
5138 
5139             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5140             bar = mcoll.PolyCollection(
5141                 verts, transform=trans, edgecolors="face")
5142             bar.set_array(values)
5143             bar.set_cmap(cmap)
5144             bar.set_norm(norm)
5145             bar.set_alpha(alpha)
5146             bar._internal_update(kwargs)
5147             bars.append(self.add_collection(bar, autolim=False))
5148 
5149         collection.hbar, collection.vbar = bars
5150 
5151         def on_changed(collection):
5152             collection.hbar.set_cmap(collection.get_cmap())
5153             collection.hbar.set_cmap(collection.get_cmap())
5154             collection.vbar.set_clim(collection.get_clim())
5155             collection.vbar.set_clim(collection.get_clim())
5156 
5157         collection.callbacks.connect('changed', on_changed)
5158 
5159         return collection
5160 
5161     @_docstring.dedent_interpd
5162     def arrow(self, x, y, dx, dy, **kwargs):
5163         """
5164         Add an arrow to the Axes.
5165 
5166         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5167 
5168         Parameters
5169         ----------
5170         %(FancyArrow)s
5171 
5172         Returns
5173         -------
5174         `.FancyArrow`
5175             The created `.FancyArrow` object.
5176 
5177         Notes
5178         -----
5179         The resulting arrow is affected by the Axes aspect ratio and limits.
5180         This may produce an arrow whose head is not square with its stem. To
5181         create an arrow whose head is square with its stem,
5182         use :meth:`annotate` for example:
5183 
5184         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5185         ...             arrowprops=dict(arrowstyle="->"))
5186 
5187         """
5188         # Strip away units for the underlying patch since units
5189         # do not make sense to most patch-like code
5190         x = self.convert_xunits(x)
5191         y = self.convert_yunits(y)
5192         dx = self.convert_xunits(dx)
5193         dy = self.convert_yunits(dy)
5194 
5195         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5196         self.add_patch(a)
5197         self._request_autoscale_view()
5198         return a
5199 
5200     @_docstring.copy(mquiver.QuiverKey.__init__)
5201     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5202         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5203         self.add_artist(qk)
5204         return qk
5205 
5206     # Handle units for x and y, if they've been passed
5207     def _quiver_units(self, args, kwargs):
5208         if len(args) > 3:
5209             x, y = args[0:2]
5210             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5211             return (x, y) + args[2:]
5212         return args
5213 
5214     # args can be a combination of X, Y, U, V, C and all should be replaced
5215     @_preprocess_data()
5216     @_docstring.dedent_interpd
5217     def quiver(self, *args, **kwargs):
5218         """%(quiver_doc)s"""
5219         # Make sure units are handled for x and y values
5220         args = self._quiver_units(args, kwargs)
5221         q = mquiver.Quiver(self, *args, **kwargs)
5222         self.add_collection(q, autolim=True)
5223         self._request_autoscale_view()
5224         return q
5225 
5226     # args can be some combination of X, Y, U, V, C and all should be replaced
5227     @_preprocess_data()
5228     @_docstring.dedent_interpd
5229     def barbs(self, *args, **kwargs):
5230         """%(barbs_doc)s"""
5231         # Make sure units are handled for x and y values
5232         args = self._quiver_units(args, kwargs)
5233         b = mquiver.Barbs(self, *args, **kwargs)
5234         self.add_collection(b, autolim=True)
5235         self._request_autoscale_view()
5236         return b
5237 
5238     # Uses a custom implementation of data-kwarg handling in
5239     # _process_plot_var_args.
5240     def fill(self, *args, data=None, **kwargs):
5241         """
5242         Plot filled polygons.
5243 
5244         Parameters
5245         ----------
5246         *args : sequence of x, y, [color]
5247             Each polygon is defined by the lists of *x* and *y* positions of
5248             its nodes, optionally followed by a *color* specifier. See
5249             :mod:`matplotlib.colors` for supported color specifiers. The
5250             standard color cycle is used for polygons without a color
5251             specifier.
5252 
5253             You can plot multiple polygons by providing multiple *x*, *y*,
5254             *[color]* groups.
5255 
5256             For example, each of the following is legal::
5257 
5258                 ax.fill(x, y)                    # a polygon with default color
5259                 ax.fill(x, y, "b")               # a blue polygon
5260                 ax.fill(x, y, x2, y2)            # two polygons
5261                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5262 
5263         data : indexable object, optional
5264             An object with labelled data. If given, provide the label names to
5265             plot in *x* and *y*, e.g.::
5266 
5267                 ax.fill("time", "signal",
5268                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5269 
5270         Returns
5271         -------
5272         list of `~matplotlib.patches.Polygon`
5273 
5274         Other Parameters
5275         ----------------
5276         **kwargs : `~matplotlib.patches.Polygon` properties
5277 
5278         Notes
5279         -----
5280         Use :meth:`fill_between` if you would like to fill the region between
5281         two curves.
5282         """
5283         # For compatibility(!), get aliases from Line2D rather than Patch.
5284         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5285         # _get_patches_for_fill returns a generator, convert it to a list.
5286         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5287         for poly in patches:
5288             self.add_patch(poly)
5289         self._request_autoscale_view()
5290         return patches
5291 
5292     def _fill_between_x_or_y(
5293             self, ind_dir, ind, dep1, dep2=0, *,
5294             where=None, interpolate=False, step=None, **kwargs):
5295         # Common implementation between fill_between (*ind_dir*="x") and
5296         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5297         # *dep* the dependent variable.  The docstring below is interpolated
5298         # to generate both methods' docstrings.
5299         """
5300         Fill the area between two {dir} curves.
5301 
5302         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5303         *{dep}2*).  This creates one or multiple polygons describing the filled
5304         area.
5305 
5306         You may exclude some {dir} sections from filling using *where*.
5307 
5308         By default, the edges connect the given points directly.  Use *step*
5309         if the filling should be a step function, i.e. constant in between
5310         *{ind}*.
5311 
5312         Parameters
5313         ----------
5314         {ind} : array (length N)
5315             The {ind} coordinates of the nodes defining the curves.
5316 
5317         {dep}1 : array (length N) or scalar
5318             The {dep} coordinates of the nodes defining the first curve.
5319 
5320         {dep}2 : array (length N) or scalar, default: 0
5321             The {dep} coordinates of the nodes defining the second curve.
5322 
5323         where : array of bool (length N), optional
5324             Define *where* to exclude some {dir} regions from being filled.
5325             The filled regions are defined by the coordinates ``{ind}[where]``.
5326             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5327             ``where[i] and where[i+1]``.  Note that this definition implies
5328             that an isolated *True* value between two *False* values in *where*
5329             will not result in filling.  Both sides of the *True* position
5330             remain unfilled due to the adjacent *False* values.
5331 
5332         interpolate : bool, default: False
5333             This option is only relevant if *where* is used and the two curves
5334             are crossing each other.
5335 
5336             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5337             similar.  By default, the nodes of the polygon defining the filled
5338             region will only be placed at the positions in the *{ind}* array.
5339             Such a polygon cannot describe the above semantics close to the
5340             intersection.  The {ind}-sections containing the intersection are
5341             simply clipped.
5342 
5343             Setting *interpolate* to *True* will calculate the actual
5344             intersection point and extend the filled region up to this point.
5345 
5346         step : {{'pre', 'post', 'mid'}}, optional
5347             Define *step* if the filling should be a step function,
5348             i.e. constant in between *{ind}*.  The value determines where the
5349             step will occur:
5350 
5351             - 'pre': The y value is continued constantly to the left from
5352               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5353               value ``y[i]``.
5354             - 'post': The y value is continued constantly to the right from
5355               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5356               value ``y[i]``.
5357             - 'mid': Steps occur half-way between the *x* positions.
5358 
5359         Returns
5360         -------
5361         `.PolyCollection`
5362             A `.PolyCollection` containing the plotted polygons.
5363 
5364         Other Parameters
5365         ----------------
5366         data : indexable object, optional
5367             DATA_PARAMETER_PLACEHOLDER
5368 
5369         **kwargs
5370             All other keyword arguments are passed on to `.PolyCollection`.
5371             They control the `.Polygon` properties:
5372 
5373             %(PolyCollection:kwdoc)s
5374 
5375         See Also
5376         --------
5377         fill_between : Fill between two sets of y-values.
5378         fill_betweenx : Fill between two sets of x-values.
5379         """
5380 
5381         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5382 
5383         if not mpl.rcParams["_internal.classic_mode"]:
5384             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5385             if not any(c in kwargs for c in ("color", "facecolor")):
5386                 kwargs["facecolor"] = \
5387                     self._get_patches_for_fill.get_next_color()
5388 
5389         # Handle united data, such as dates
5390         ind, dep1, dep2 = map(
5391             ma.masked_invalid, self._process_unit_info(
5392                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5393 
5394         for name, array in [
5395                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5396             if array.ndim > 1:
5397                 raise ValueError(f"{name!r} is not 1-dimensional")
5398 
5399         if where is None:
5400             where = True
5401         else:
5402             where = np.asarray(where, dtype=bool)
5403             if where.size != ind.size:
5404                 raise ValueError(f"where size ({where.size}) does not match "
5405                                  f"{ind_dir} size ({ind.size})")
5406         where = where & ~functools.reduce(
5407             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5408 
5409         ind, dep1, dep2 = np.broadcast_arrays(
5410             np.atleast_1d(ind), dep1, dep2, subok=True)
5411 
5412         polys = []
5413         for idx0, idx1 in cbook.contiguous_regions(where):
5414             indslice = ind[idx0:idx1]
5415             dep1slice = dep1[idx0:idx1]
5416             dep2slice = dep2[idx0:idx1]
5417             if step is not None:
5418                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5419                 indslice, dep1slice, dep2slice = \
5420                     step_func(indslice, dep1slice, dep2slice)
5421 
5422             if not len(indslice):
5423                 continue
5424 
5425             N = len(indslice)
5426             pts = np.zeros((2 * N + 2, 2))
5427 
5428             if interpolate:
5429                 def get_interp_point(idx):
5430                     im1 = max(idx - 1, 0)
5431                     ind_values = ind[im1:idx+1]
5432                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5433                     dep1_values = dep1[im1:idx+1]
5434 
5435                     if len(diff_values) == 2:
5436                         if np.ma.is_masked(diff_values[1]):
5437                             return ind[im1], dep1[im1]
5438                         elif np.ma.is_masked(diff_values[0]):
5439                             return ind[idx], dep1[idx]
5440 
5441                     diff_order = diff_values.argsort()
5442                     diff_root_ind = np.interp(
5443                         0, diff_values[diff_order], ind_values[diff_order])
5444                     ind_order = ind_values.argsort()
5445                     diff_root_dep = np.interp(
5446                         diff_root_ind,
5447                         ind_values[ind_order], dep1_values[ind_order])
5448                     return diff_root_ind, diff_root_dep
5449 
5450                 start = get_interp_point(idx0)
5451                 end = get_interp_point(idx1)
5452             else:
5453                 # Handle scalar dep2 (e.g. 0): the fill should go all
5454                 # the way down to 0 even if none of the dep1 sample points do.
5455                 start = indslice[0], dep2slice[0]
5456                 end = indslice[-1], dep2slice[-1]
5457 
5458             pts[0] = start
5459             pts[N + 1] = end
5460 
5461             pts[1:N+1, 0] = indslice
5462             pts[1:N+1, 1] = dep1slice
5463             pts[N+2:, 0] = indslice[::-1]
5464             pts[N+2:, 1] = dep2slice[::-1]
5465 
5466             if ind_dir == "y":
5467                 pts = pts[:, ::-1]
5468 
5469             polys.append(pts)
5470 
5471         collection = mcoll.PolyCollection(polys, **kwargs)
5472 
5473         # now update the datalim and autoscale
5474         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5475                             np.column_stack([ind[where], dep2[where]])])
5476         if ind_dir == "y":
5477             pts = pts[:, ::-1]
5478 
5479         up_x = up_y = True
5480         if "transform" in kwargs:
5481             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5482         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5483 
5484         self.add_collection(collection, autolim=False)
5485         self._request_autoscale_view()
5486         return collection
5487 
5488     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5489                      step=None, **kwargs):
5490         return self._fill_between_x_or_y(
5491             "x", x, y1, y2,
5492             where=where, interpolate=interpolate, step=step, **kwargs)
5493 
5494     if _fill_between_x_or_y.__doc__:
5495         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5496             dir="horizontal", ind="x", dep="y"
5497         )
5498     fill_between = _preprocess_data(
5499         _docstring.dedent_interpd(fill_between),
5500         replace_names=["x", "y1", "y2", "where"])
5501 
5502     def fill_betweenx(self, y, x1, x2=0, where=None,
5503                       step=None, interpolate=False, **kwargs):
5504         return self._fill_between_x_or_y(
5505             "y", y, x1, x2,
5506             where=where, interpolate=interpolate, step=step, **kwargs)
5507 
5508     if _fill_between_x_or_y.__doc__:
5509         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5510             dir="vertical", ind="y", dep="x"
5511         )
5512     fill_betweenx = _preprocess_data(
5513         _docstring.dedent_interpd(fill_betweenx),
5514         replace_names=["y", "x1", "x2", "where"])
5515 
5516     #### plotting z(x, y): imshow, pcolor and relatives, contour
5517 
5518     @_preprocess_data()
5519     @_docstring.interpd
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im
5742 
5743     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5744         # - create X and Y if not present;
5745         # - reshape X and Y as needed if they are 1-D;
5746         # - check for proper sizes based on `shading` kwarg;
5747         # - reset shading if shading='auto' to flat or nearest
5748         #   depending on size;
5749 
5750         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5751         try:
5752             _api.check_in_list(_valid_shading, shading=shading)
5753         except ValueError:
5754             _api.warn_external(f"shading value '{shading}' not in list of "
5755                                f"valid values {_valid_shading}. Setting "
5756                                "shading='auto'.")
5757             shading = 'auto'
5758 
5759         if len(args) == 1:
5760             C = np.asanyarray(args[0])
5761             nrows, ncols = C.shape[:2]
5762             if shading in ['gouraud', 'nearest']:
5763                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5764             else:
5765                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5766                 shading = 'flat'
5767             C = cbook.safe_masked_invalid(C, copy=True)
5768             return X, Y, C, shading
5769 
5770         if len(args) == 3:
5771             # Check x and y for bad data...
5772             C = np.asanyarray(args[2])
5773             # unit conversion allows e.g. datetime objects as axis values
5774             X, Y = args[:2]
5775             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5776             X, Y = [cbook.safe_masked_invalid(a, copy=True) for a in [X, Y]]
5777 
5778             if funcname == 'pcolormesh':
5779                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5780                     raise ValueError(
5781                         'x and y arguments to pcolormesh cannot have '
5782                         'non-finite values or be of type '
5783                         'numpy.ma.MaskedArray with masked values')
5784             nrows, ncols = C.shape[:2]
5785         else:
5786             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5787 
5788         Nx = X.shape[-1]
5789         Ny = Y.shape[0]
5790         if X.ndim != 2 or X.shape[0] == 1:
5791             x = X.reshape(1, Nx)
5792             X = x.repeat(Ny, axis=0)
5793         if Y.ndim != 2 or Y.shape[1] == 1:
5794             y = Y.reshape(Ny, 1)
5795             Y = y.repeat(Nx, axis=1)
5796         if X.shape != Y.shape:
5797             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5798                             f'see help({funcname})')
5799 
5800         if shading == 'auto':
5801             if ncols == Nx and nrows == Ny:
5802                 shading = 'nearest'
5803             else:
5804                 shading = 'flat'
5805 
5806         if shading == 'flat':
5807             if (Nx, Ny) != (ncols + 1, nrows + 1):
5808                 raise TypeError(f"Dimensions of C {C.shape} should"
5809                                 f" be one smaller than X({Nx}) and Y({Ny})"
5810                                 f" while using shading='flat'"
5811                                 f" see help({funcname})")
5812         else:    # ['nearest', 'gouraud']:
5813             if (Nx, Ny) != (ncols, nrows):
5814                 raise TypeError('Dimensions of C %s are incompatible with'
5815                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5816                                     C.shape, Nx, Ny, funcname))
5817             if shading == 'nearest':
5818                 # grid is specified at the center, so define corners
5819                 # at the midpoints between the grid centers and then use the
5820                 # flat algorithm.
5821                 def _interp_grid(X):
5822                     # helper for below
5823                     if np.shape(X)[1] > 1:
5824                         dX = np.diff(X, axis=1)/2.
5825                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5826                             _api.warn_external(
5827                                 f"The input coordinates to {funcname} are "
5828                                 "interpreted as cell centers, but are not "
5829                                 "monotonically increasing or decreasing. "
5830                                 "This may lead to incorrectly calculated cell "
5831                                 "edges, in which case, please supply "
5832                                 f"explicit cell edges to {funcname}.")
5833 
5834                         hstack = np.ma.hstack if np.ma.isMA(X) else np.hstack
5835                         X = hstack((X[:, [0]] - dX[:, [0]],
5836                                     X[:, :-1] + dX,
5837                                     X[:, [-1]] + dX[:, [-1]]))
5838                     else:
5839                         # This is just degenerate, but we can't reliably guess
5840                         # a dX if there is just one value.
5841                         X = np.hstack((X, X))
5842                     return X
5843 
5844                 if ncols == Nx:
5845                     X = _interp_grid(X)
5846                     Y = _interp_grid(Y)
5847                 if nrows == Ny:
5848                     X = _interp_grid(X.T).T
5849                     Y = _interp_grid(Y.T).T
5850                 shading = 'flat'
5851 
5852         C = cbook.safe_masked_invalid(C, copy=True)
5853         return X, Y, C, shading
5854 
5855     @_preprocess_data()
5856     @_docstring.dedent_interpd
5857     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5858                vmin=None, vmax=None, **kwargs):
5859         r"""
5860         Create a pseudocolor plot with a non-regular rectangular grid.
5861 
5862         Call signature::
5863 
5864             pcolor([X, Y,] C, **kwargs)
5865 
5866         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5867 
5868         .. hint::
5869 
5870             ``pcolor()`` can be very slow for large arrays. In most
5871             cases you should use the similar but much faster
5872             `~.Axes.pcolormesh` instead. See
5873             :ref:`Differences between pcolor() and pcolormesh()
5874             <differences-pcolor-pcolormesh>` for a discussion of the
5875             differences.
5876 
5877         Parameters
5878         ----------
5879         C : 2D array-like
5880             The color-mapped values.  Color-mapping is controlled by *cmap*,
5881             *norm*, *vmin*, and *vmax*.
5882 
5883         X, Y : array-like, optional
5884             The coordinates of the corners of quadrilaterals of a pcolormesh::
5885 
5886                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5887                                       ●╶───╴●
5888                                       │     │
5889                                       ●╶───╴●
5890                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5891 
5892             Note that the column index corresponds to the x-coordinate, and
5893             the row index corresponds to y. For details, see the
5894             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5895 
5896             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5897             greater than those of *C*, and the quadrilateral is colored due
5898             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5899             dimensions, a warning will be raised and the last row and column
5900             of *C* will be ignored.
5901 
5902             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5903             the same as those of *C* (if not, a ValueError will be raised). The
5904             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5905 
5906             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5907             expanded as needed into the appropriate 2D arrays, making a
5908             rectangular grid.
5909 
5910         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5911             The fill style for the quadrilateral. Possible values:
5912 
5913             - 'flat': A solid color is used for each quad. The color of the
5914               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5915               ``C[i, j]``. The dimensions of *X* and *Y* should be
5916               one greater than those of *C*; if they are the same as *C*,
5917               then a deprecation warning is raised, and the last row
5918               and column of *C* are dropped.
5919             - 'nearest': Each grid point will have a color centered on it,
5920               extending halfway between the adjacent grid centers.  The
5921               dimensions of *X* and *Y* must be the same as *C*.
5922             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5923               larger than *C*.  Choose 'nearest' if dimensions are the same.
5924 
5925             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5926             for more description.
5927 
5928         %(cmap_doc)s
5929 
5930         %(norm_doc)s
5931 
5932         %(vmin_vmax_doc)s
5933 
5934         edgecolors : {'none', None, 'face', color, color sequence}, optional
5935             The color of the edges. Defaults to 'none'. Possible values:
5936 
5937             - 'none' or '': No edge.
5938             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5939               :rc:`patch.force_edgecolor` has to be True for this to work.
5940             - 'face': Use the adjacent face color.
5941             - A color or sequence of colors will set the edge color.
5942 
5943             The singular form *edgecolor* works as an alias.
5944 
5945         alpha : float, default: None
5946             The alpha blending value of the face color, between 0 (transparent)
5947             and 1 (opaque). Note: The edgecolor is currently not affected by
5948             this.
5949 
5950         snap : bool, default: False
5951             Whether to snap the mesh to pixel boundaries.
5952 
5953         Returns
5954         -------
5955         `matplotlib.collections.PolyQuadMesh`
5956 
5957         Other Parameters
5958         ----------------
5959         antialiaseds : bool, default: False
5960             The default *antialiaseds* is False if the default
5961             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5962             at patch boundaries, and works regardless of the value of alpha.
5963             If *edgecolors* is not "none", then the default *antialiaseds*
5964             is taken from :rc:`patch.antialiased`.
5965             Stroking the edges may be preferred if *alpha* is 1, but will
5966             cause artifacts otherwise.
5967 
5968         data : indexable object, optional
5969             DATA_PARAMETER_PLACEHOLDER
5970 
5971         **kwargs
5972             Additionally, the following arguments are allowed. They are passed
5973             along to the `~matplotlib.collections.PolyQuadMesh` constructor:
5974 
5975         %(PolyCollection:kwdoc)s
5976 
5977         See Also
5978         --------
5979         pcolormesh : for an explanation of the differences between
5980             pcolor and pcolormesh.
5981         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5982             faster alternative.
5983 
5984         Notes
5985         -----
5986         **Masked arrays**
5987 
5988         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5989         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5990         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5991         plotted.
5992 
5993         .. _axes-pcolor-grid-orientation:
5994 
5995         **Grid orientation**
5996 
5997         The grid orientation follows the standard matrix convention: An array
5998         *C* with shape (nrows, ncolumns) is plotted with the column number as
5999         *X* and the row number as *Y*.
6000         """
6001 
6002         if shading is None:
6003             shading = mpl.rcParams['pcolor.shading']
6004         shading = shading.lower()
6005         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
6006                                             kwargs=kwargs)
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiaseds' in kwargs:
6021             kwargs['antialiased'] = kwargs.pop('antialiaseds')
6022         if 'antialiased' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiased'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         if np.ma.isMaskedArray(X) or np.ma.isMaskedArray(Y):
6028             stack = np.ma.stack
6029             X = np.ma.asarray(X)
6030             Y = np.ma.asarray(Y)
6031             # For bounds collections later
6032             x = X.compressed()
6033             y = Y.compressed()
6034         else:
6035             stack = np.stack
6036             x = X
6037             y = Y
6038         coords = stack([X, Y], axis=-1)
6039 
6040         collection = mcoll.PolyQuadMesh(
6041             coords, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6042         collection._scale_norm(norm, vmin, vmax)
6043 
6044         # Transform from native to data coordinates?
6045         t = collection._transform
6046         if (not isinstance(t, mtransforms.Transform) and
6047                 hasattr(t, '_as_mpl_transform')):
6048             t = t._as_mpl_transform(self.axes)
6049 
6050         if t and any(t.contains_branch_seperately(self.transData)):
6051             trans_to_data = t - self.transData
6052             pts = np.vstack([x, y]).T.astype(float)
6053             transformed_pts = trans_to_data.transform(pts)
6054             x = transformed_pts[..., 0]
6055             y = transformed_pts[..., 1]
6056 
6057         self.add_collection(collection, autolim=False)
6058 
6059         minx = np.min(x)
6060         maxx = np.max(x)
6061         miny = np.min(y)
6062         maxy = np.max(y)
6063         collection.sticky_edges.x[:] = [minx, maxx]
6064         collection.sticky_edges.y[:] = [miny, maxy]
6065         corners = (minx, miny), (maxx, maxy)
6066         self.update_datalim(corners)
6067         self._request_autoscale_view()
6068         return collection
6069 
6070     @_preprocess_data()
6071     @_docstring.dedent_interpd
6072     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6073                    vmax=None, shading=None, antialiased=False, **kwargs):
6074         """
6075         Create a pseudocolor plot with a non-regular rectangular grid.
6076 
6077         Call signature::
6078 
6079             pcolormesh([X, Y,] C, **kwargs)
6080 
6081         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6082 
6083         .. hint::
6084 
6085            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6086            and preferred in most cases. For a detailed discussion on the
6087            differences see :ref:`Differences between pcolor() and pcolormesh()
6088            <differences-pcolor-pcolormesh>`.
6089 
6090         Parameters
6091         ----------
6092         C : array-like
6093             The mesh data. Supported array shapes are:
6094 
6095             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6096               colors using normalization and a colormap. See parameters *norm*,
6097               *cmap*, *vmin*, *vmax*.
6098             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6099             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6100               i.e. including transparency.
6101 
6102             The first two dimensions (M, N) define the rows and columns of
6103             the mesh data.
6104 
6105         X, Y : array-like, optional
6106             The coordinates of the corners of quadrilaterals of a pcolormesh::
6107 
6108                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6109                                       ●╶───╴●
6110                                       │     │
6111                                       ●╶───╴●
6112                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6113 
6114             Note that the column index corresponds to the x-coordinate, and
6115             the row index corresponds to y. For details, see the
6116             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6117 
6118             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6119             greater than those of *C*, and the quadrilateral is colored due
6120             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6121             dimensions, a warning will be raised and the last row and column
6122             of *C* will be ignored.
6123 
6124             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6125             and *Y* should be the same as those of *C* (if not, a ValueError
6126             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6127             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6128             interpolation is caried out between the quadrilateral corners.
6129 
6130             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6131             expanded as needed into the appropriate 2D arrays, making a
6132             rectangular grid.
6133 
6134         %(cmap_doc)s
6135 
6136         %(norm_doc)s
6137 
6138         %(vmin_vmax_doc)s
6139 
6140         edgecolors : {'none', None, 'face', color, color sequence}, optional
6141             The color of the edges. Defaults to 'none'. Possible values:
6142 
6143             - 'none' or '': No edge.
6144             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6145               :rc:`patch.force_edgecolor` has to be True for this to work.
6146             - 'face': Use the adjacent face color.
6147             - A color or sequence of colors will set the edge color.
6148 
6149             The singular form *edgecolor* works as an alias.
6150 
6151         alpha : float, default: None
6152             The alpha blending value, between 0 (transparent) and 1 (opaque).
6153 
6154         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6155             The fill style for the quadrilateral; defaults to
6156             :rc:`pcolor.shading`. Possible values:
6157 
6158             - 'flat': A solid color is used for each quad. The color of the
6159               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6160               ``C[i, j]``. The dimensions of *X* and *Y* should be
6161               one greater than those of *C*; if they are the same as *C*,
6162               then a deprecation warning is raised, and the last row
6163               and column of *C* are dropped.
6164             - 'nearest': Each grid point will have a color centered on it,
6165               extending halfway between the adjacent grid centers.  The
6166               dimensions of *X* and *Y* must be the same as *C*.
6167             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6168               corners (i', j') are given by ``C[i', j']``. The color values of
6169               the area in between is interpolated from the corner values.
6170               The dimensions of *X* and *Y* must be the same as *C*. When
6171               Gouraud shading is used, *edgecolors* is ignored.
6172             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6173               larger than *C*.  Choose 'nearest' if dimensions are the same.
6174 
6175             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6176             for more description.
6177 
6178         snap : bool, default: False
6179             Whether to snap the mesh to pixel boundaries.
6180 
6181         rasterized : bool, optional
6182             Rasterize the pcolormesh when drawing vector graphics.  This can
6183             speed up rendering and produce smaller files for large data sets.
6184             See also :doc:`/gallery/misc/rasterization_demo`.
6185 
6186         Returns
6187         -------
6188         `matplotlib.collections.QuadMesh`
6189 
6190         Other Parameters
6191         ----------------
6192         data : indexable object, optional
6193             DATA_PARAMETER_PLACEHOLDER
6194 
6195         **kwargs
6196             Additionally, the following arguments are allowed. They are passed
6197             along to the `~matplotlib.collections.QuadMesh` constructor:
6198 
6199         %(QuadMesh:kwdoc)s
6200 
6201         See Also
6202         --------
6203         pcolor : An alternative implementation with slightly different
6204             features. For a detailed discussion on the differences see
6205             :ref:`Differences between pcolor() and pcolormesh()
6206             <differences-pcolor-pcolormesh>`.
6207         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6208             faster alternative.
6209 
6210         Notes
6211         -----
6212         **Masked arrays**
6213 
6214         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6215         quadrilateral will be transparent. Masking of *X* and *Y* is not
6216         supported. Use `~.Axes.pcolor` if you need this functionality.
6217 
6218         .. _axes-pcolormesh-grid-orientation:
6219 
6220         **Grid orientation**
6221 
6222         The grid orientation follows the standard matrix convention: An array
6223         *C* with shape (nrows, ncolumns) is plotted with the column number as
6224         *X* and the row number as *Y*.
6225 
6226         .. _differences-pcolor-pcolormesh:
6227 
6228         **Differences between pcolor() and pcolormesh()**
6229 
6230         Both methods are used to create a pseudocolor plot of a 2D array
6231         using quadrilaterals.
6232 
6233         The main difference lies in the created object and internal data
6234         handling:
6235         While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`
6236         returns a `.QuadMesh`. The latter is more specialized for the given
6237         purpose and thus is faster. It should almost always be preferred.
6238 
6239         There is also a slight difference in the handling of masked arrays.
6240         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6241         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6242         and *Y*. The reason lies in the internal handling of the masked values.
6243         `~.Axes.pcolor` leaves out the respective polygons from the
6244         PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked
6245         elements to transparent. You can see the difference when using
6246         edgecolors. While all edges are drawn irrespective of masking in a
6247         QuadMesh, the edge between two adjacent masked quadrilaterals in
6248         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6249         exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual
6250         polygon, it also supports applying hatches and linestyles to the collection.
6251 
6252         Another difference is the support of Gouraud shading in
6253         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6254 
6255         """
6256         if shading is None:
6257             shading = mpl.rcParams['pcolor.shading']
6258         shading = shading.lower()
6259         kwargs.setdefault('edgecolors', 'none')
6260 
6261         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6262                                             shading=shading, kwargs=kwargs)
6263         coords = np.stack([X, Y], axis=-1)
6264 
6265         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6266 
6267         collection = mcoll.QuadMesh(
6268             coords, antialiased=antialiased, shading=shading,
6269             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6270         collection._scale_norm(norm, vmin, vmax)
6271 
6272         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6273 
6274         # Transform from native to data coordinates?
6275         t = collection._transform
6276         if (not isinstance(t, mtransforms.Transform) and
6277                 hasattr(t, '_as_mpl_transform')):
6278             t = t._as_mpl_transform(self.axes)
6279 
6280         if t and any(t.contains_branch_seperately(self.transData)):
6281             trans_to_data = t - self.transData
6282             coords = trans_to_data.transform(coords)
6283 
6284         self.add_collection(collection, autolim=False)
6285 
6286         minx, miny = np.min(coords, axis=0)
6287         maxx, maxy = np.max(coords, axis=0)
6288         collection.sticky_edges.x[:] = [minx, maxx]
6289         collection.sticky_edges.y[:] = [miny, maxy]
6290         corners = (minx, miny), (maxx, maxy)
6291         self.update_datalim(corners)
6292         self._request_autoscale_view()
6293         return collection
6294 
6295     @_preprocess_data()
6296     @_docstring.dedent_interpd
6297     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6298                    vmax=None, **kwargs):
6299         """
6300         Create a pseudocolor plot with a non-regular rectangular grid.
6301 
6302         Call signature::
6303 
6304           ax.pcolorfast([X, Y], C, /, **kwargs)
6305 
6306         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6307         It's designed to provide the fastest pcolor-type plotting with the
6308         Agg backend. To achieve this, it uses different algorithms internally
6309         depending on the complexity of the input grid (regular rectangular,
6310         non-regular rectangular or arbitrary quadrilateral).
6311 
6312         .. warning::
6313 
6314            This method is experimental. Compared to `~.Axes.pcolor` or
6315            `~.Axes.pcolormesh` it has some limitations:
6316 
6317            - It supports only flat shading (no outlines)
6318            - It lacks support for log scaling of the axes.
6319            - It does not have a pyplot wrapper.
6320 
6321         Parameters
6322         ----------
6323         C : array-like
6324             The image data. Supported array shapes are:
6325 
6326             - (M, N): an image with scalar data.  Color-mapping is controlled
6327               by *cmap*, *norm*, *vmin*, and *vmax*.
6328             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6329             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6330               i.e. including transparency.
6331 
6332             The first two dimensions (M, N) define the rows and columns of
6333             the image.
6334 
6335             This parameter can only be passed positionally.
6336 
6337         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6338             *X* and *Y* are used to specify the coordinates of the
6339             quadrilaterals. There are different ways to do this:
6340 
6341             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6342               a *uniform rectangular grid*.
6343 
6344               The tuples define the outer edges of the grid. All individual
6345               quadrilaterals will be of the same size. This is the fastest
6346               version.
6347 
6348             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6349               grid*.
6350 
6351               In this case *X* and *Y* have to be monotonic 1D arrays of length
6352               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6353 
6354               The speed is intermediate. Note: The grid is checked, and if
6355               found to be uniform the fast version is used.
6356 
6357             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6358               grid* (i.e. if the quadrilaterals are not rectangular).
6359 
6360               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6361               specifying the x and y coordinates of the corners of the colored
6362               quadrilaterals.
6363 
6364               This is the most general, but the slowest to render.  It may
6365               produce faster and more compact output using ps, pdf, and
6366               svg backends, however.
6367 
6368             These arguments can only be passed positionally.
6369 
6370         %(cmap_doc)s
6371 
6372             This parameter is ignored if *C* is RGB(A).
6373 
6374         %(norm_doc)s
6375 
6376             This parameter is ignored if *C* is RGB(A).
6377 
6378         %(vmin_vmax_doc)s
6379 
6380             This parameter is ignored if *C* is RGB(A).
6381 
6382         alpha : float, default: None
6383             The alpha blending value, between 0 (transparent) and 1 (opaque).
6384 
6385         snap : bool, default: False
6386             Whether to snap the mesh to pixel boundaries.
6387 
6388         Returns
6389         -------
6390         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6391             The return type depends on the type of grid:
6392 
6393             - `.AxesImage` for a regular rectangular grid.
6394             - `.PcolorImage` for a non-regular rectangular grid.
6395             - `.QuadMesh` for a non-rectangular grid.
6396 
6397         Other Parameters
6398         ----------------
6399         data : indexable object, optional
6400             DATA_PARAMETER_PLACEHOLDER
6401 
6402         **kwargs
6403             Supported additional parameters depend on the type of grid.
6404             See return types of *image* for further description.
6405         """
6406 
6407         C = args[-1]
6408         nr, nc = np.shape(C)[:2]
6409         if len(args) == 1:
6410             style = "image"
6411             x = [0, nc]
6412             y = [0, nr]
6413         elif len(args) == 3:
6414             x, y = args[:2]
6415             x = np.asarray(x)
6416             y = np.asarray(y)
6417             if x.ndim == 1 and y.ndim == 1:
6418                 if x.size == 2 and y.size == 2:
6419                     style = "image"
6420                 else:
6421                     dx = np.diff(x)
6422                     dy = np.diff(y)
6423                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6424                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6425                         style = "image"
6426                     else:
6427                         style = "pcolorimage"
6428             elif x.ndim == 2 and y.ndim == 2:
6429                 style = "quadmesh"
6430             else:
6431                 raise TypeError("arguments do not match valid signatures")
6432         else:
6433             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6434 
6435         if style == "quadmesh":
6436             # data point in each cell is value at lower left corner
6437             coords = np.stack([x, y], axis=-1)
6438             if np.ndim(C) not in {2, 3}:
6439                 raise ValueError("C must be 2D or 3D")
6440             collection = mcoll.QuadMesh(
6441                 coords, array=C,
6442                 alpha=alpha, cmap=cmap, norm=norm,
6443                 antialiased=False, edgecolors="none")
6444             self.add_collection(collection, autolim=False)
6445             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6446             ret = collection
6447 
6448         else:  # It's one of the two image styles.
6449             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6450             if style == "image":
6451                 im = mimage.AxesImage(
6452                     self, cmap=cmap, norm=norm,
6453                     data=C, alpha=alpha, extent=extent,
6454                     interpolation='nearest', origin='lower',
6455                     **kwargs)
6456             elif style == "pcolorimage":
6457                 im = mimage.PcolorImage(
6458                     self, x, y, C,
6459                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6460                     **kwargs)
6461             self.add_image(im)
6462             ret = im
6463 
6464         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6465             ret._scale_norm(norm, vmin, vmax)
6466 
6467         if ret.get_clip_path() is None:
6468             # image does not already have clipping set, clip to axes patch
6469             ret.set_clip_path(self.patch)
6470 
6471         ret.sticky_edges.x[:] = [xl, xr]
6472         ret.sticky_edges.y[:] = [yb, yt]
6473         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6474         self._request_autoscale_view(tight=True)
6475         return ret
6476 
6477     @_preprocess_data()
6478     @_docstring.dedent_interpd
6479     def contour(self, *args, **kwargs):
6480         """
6481         Plot contour lines.
6482 
6483         Call signature::
6484 
6485             contour([X, Y,] Z, [levels], **kwargs)
6486         %(contour_doc)s
6487         """
6488         kwargs['filled'] = False
6489         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6490         self._request_autoscale_view()
6491         return contours
6492 
6493     @_preprocess_data()
6494     @_docstring.dedent_interpd
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours
6508 
6509     def clabel(self, CS, levels=None, **kwargs):
6510         """
6511         Label a contour plot.
6512 
6513         Adds labels to line contours in given `.ContourSet`.
6514 
6515         Parameters
6516         ----------
6517         CS : `.ContourSet` instance
6518             Line contours to label.
6519 
6520         levels : array-like, optional
6521             A list of level values, that should be labeled. The list must be
6522             a subset of ``CS.levels``. If not given, all levels are labeled.
6523 
6524         **kwargs
6525             All other parameters are documented in `~.ContourLabeler.clabel`.
6526         """
6527         return CS.clabel(levels, **kwargs)
6528 
6529     #### Data analysis
6530 
6531     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6532     def hist(self, x, bins=None, range=None, density=False, weights=None,
6533              cumulative=False, bottom=None, histtype='bar', align='mid',
6534              orientation='vertical', rwidth=None, log=False,
6535              color=None, label=None, stacked=False, **kwargs):
6536         """
6537         Compute and plot a histogram.
6538 
6539         This method uses `numpy.histogram` to bin the data in *x* and count the
6540         number of values in each bin, then draws the distribution either as a
6541         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6542         *weights* parameters are forwarded to `numpy.histogram`.
6543 
6544         If the data has already been binned and counted, use `~.bar` or
6545         `~.stairs` to plot the distribution::
6546 
6547             counts, bins = np.histogram(x)
6548             plt.stairs(counts, bins)
6549 
6550         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6551         treating each bin as a single point with a weight equal to its count::
6552 
6553             plt.hist(bins[:-1], bins, weights=counts)
6554 
6555         The data input *x* can be a singular array, a list of datasets of
6556         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6557         which each column is a dataset. Note that the ndarray form is
6558         transposed relative to the list form. If the input is an array, then
6559         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6560         sequence of arrays, then the return value is a tuple
6561         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6562 
6563         Masked arrays are not supported.
6564 
6565         Parameters
6566         ----------
6567         x : (n,) array or sequence of (n,) arrays
6568             Input values, this takes either a single array or a sequence of
6569             arrays which are not required to be of the same length.
6570 
6571         bins : int or sequence or str, default: :rc:`hist.bins`
6572             If *bins* is an integer, it defines the number of equal-width bins
6573             in the range.
6574 
6575             If *bins* is a sequence, it defines the bin edges, including the
6576             left edge of the first bin and the right edge of the last bin;
6577             in this case, bins may be unequally spaced.  All but the last
6578             (righthand-most) bin is half-open.  In other words, if *bins* is::
6579 
6580                 [1, 2, 3, 4]
6581 
6582             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6583             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6584             *includes* 4.
6585 
6586             If *bins* is a string, it is one of the binning strategies
6587             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6588             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6589 
6590         range : tuple or None, default: None
6591             The lower and upper range of the bins. Lower and upper outliers
6592             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6593             Range has no effect if *bins* is a sequence.
6594 
6595             If *bins* is a sequence or *range* is specified, autoscaling
6596             is based on the specified bin range instead of the
6597             range of x.
6598 
6599         density : bool, default: False
6600             If ``True``, draw and return a probability density: each bin
6601             will display the bin's raw count divided by the total number of
6602             counts *and the bin width*
6603             (``density = counts / (sum(counts) * np.diff(bins))``),
6604             so that the area under the histogram integrates to 1
6605             (``np.sum(density * np.diff(bins)) == 1``).
6606 
6607             If *stacked* is also ``True``, the sum of the histograms is
6608             normalized to 1.
6609 
6610         weights : (n,) array-like or None, default: None
6611             An array of weights, of the same shape as *x*.  Each value in
6612             *x* only contributes its associated weight towards the bin count
6613             (instead of 1).  If *density* is ``True``, the weights are
6614             normalized, so that the integral of the density over the range
6615             remains 1.
6616 
6617         cumulative : bool or -1, default: False
6618             If ``True``, then a histogram is computed where each bin gives the
6619             counts in that bin plus all bins for smaller values. The last bin
6620             gives the total number of datapoints.
6621 
6622             If *density* is also ``True`` then the histogram is normalized such
6623             that the last bin equals 1.
6624 
6625             If *cumulative* is a number less than 0 (e.g., -1), the direction
6626             of accumulation is reversed.  In this case, if *density* is also
6627             ``True``, then the histogram is normalized such that the first bin
6628             equals 1.
6629 
6630         bottom : array-like, scalar, or None, default: None
6631             Location of the bottom of each bin, i.e. bins are drawn from
6632             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6633             of each bin is shifted by the same amount. If an array, each bin
6634             is shifted independently and the length of bottom must match the
6635             number of bins. If None, defaults to 0.
6636 
6637         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6638             The type of histogram to draw.
6639 
6640             - 'bar' is a traditional bar-type histogram.  If multiple data
6641               are given the bars are arranged side by side.
6642             - 'barstacked' is a bar-type histogram where multiple
6643               data are stacked on top of each other.
6644             - 'step' generates a lineplot that is by default unfilled.
6645             - 'stepfilled' generates a lineplot that is by default filled.
6646 
6647         align : {'left', 'mid', 'right'}, default: 'mid'
6648             The horizontal alignment of the histogram bars.
6649 
6650             - 'left': bars are centered on the left bin edges.
6651             - 'mid': bars are centered between the bin edges.
6652             - 'right': bars are centered on the right bin edges.
6653 
6654         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6655             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6656             and the *bottom* kwarg will be the left edges.
6657 
6658         rwidth : float or None, default: None
6659             The relative width of the bars as a fraction of the bin width.  If
6660             ``None``, automatically compute the width.
6661 
6662             Ignored if *histtype* is 'step' or 'stepfilled'.
6663 
6664         log : bool, default: False
6665             If ``True``, the histogram axis will be set to a log scale.
6666 
6667         color : color or array-like of colors or None, default: None
6668             Color or sequence of colors, one per dataset.  Default (``None``)
6669             uses the standard line color sequence.
6670 
6671         label : str or None, default: None
6672             String, or sequence of strings to match multiple datasets.  Bar
6673             charts yield multiple patches per dataset, but only the first gets
6674             the label, so that `~.Axes.legend` will work as expected.
6675 
6676         stacked : bool, default: False
6677             If ``True``, multiple data are stacked on top of each other If
6678             ``False`` multiple data are arranged side by side if histtype is
6679             'bar' or on top of each other if histtype is 'step'
6680 
6681         Returns
6682         -------
6683         n : array or list of arrays
6684             The values of the histogram bins. See *density* and *weights* for a
6685             description of the possible semantics.  If input *x* is an array,
6686             then this is an array of length *nbins*. If input is a sequence of
6687             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6688             the values of the histograms for each of the arrays in the same
6689             order.  The dtype of the array *n* (or of its element arrays) will
6690             always be float even if no weighting or normalization is used.
6691 
6692         bins : array
6693             The edges of the bins. Length nbins + 1 (nbins left edges and right
6694             edge of last bin).  Always a single array even when multiple data
6695             sets are passed in.
6696 
6697         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6698 such objects
6699             Container of individual artists used to create the histogram
6700             or list of such containers if there are multiple input datasets.
6701 
6702         Other Parameters
6703         ----------------
6704         data : indexable object, optional
6705             DATA_PARAMETER_PLACEHOLDER
6706 
6707         **kwargs
6708             `~matplotlib.patches.Patch` properties
6709 
6710         See Also
6711         --------
6712         hist2d : 2D histogram with rectangular bins
6713         hexbin : 2D histogram with hexagonal bins
6714         stairs : Plot a pre-computed histogram
6715         bar : Plot a pre-computed histogram
6716 
6717         Notes
6718         -----
6719         For large numbers of bins (>1000), plotting can be significantly
6720         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6721         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6722         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6723         """
6724         # Avoid shadowing the builtin.
6725         bin_range = range
6726         from builtins import range
6727 
6728         if np.isscalar(x):
6729             x = [x]
6730 
6731         if bins is None:
6732             bins = mpl.rcParams['hist.bins']
6733 
6734         # Validate string inputs here to avoid cluttering subsequent code.
6735         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6736                            histtype=histtype)
6737         _api.check_in_list(['left', 'mid', 'right'], align=align)
6738         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6739 
6740         if histtype == 'barstacked' and not stacked:
6741             stacked = True
6742 
6743         # Massage 'x' for processing.
6744         x = cbook._reshape_2D(x, 'x')
6745         nx = len(x)  # number of datasets
6746 
6747         # Process unit information.  _process_unit_info sets the unit and
6748         # converts the first dataset; then we convert each following dataset
6749         # one at a time.
6750         if orientation == "vertical":
6751             convert_units = self.convert_xunits
6752             x = [*self._process_unit_info([("x", x[0])], kwargs),
6753                  *map(convert_units, x[1:])]
6754         else:  # horizontal
6755             convert_units = self.convert_yunits
6756             x = [*self._process_unit_info([("y", x[0])], kwargs),
6757                  *map(convert_units, x[1:])]
6758 
6759         if bin_range is not None:
6760             bin_range = convert_units(bin_range)
6761 
6762         if not cbook.is_scalar_or_string(bins):
6763             bins = convert_units(bins)
6764 
6765         # We need to do to 'weights' what was done to 'x'
6766         if weights is not None:
6767             w = cbook._reshape_2D(weights, 'weights')
6768         else:
6769             w = [None] * nx
6770 
6771         if len(w) != nx:
6772             raise ValueError('weights should have the same shape as x')
6773 
6774         input_empty = True
6775         for xi, wi in zip(x, w):
6776             len_xi = len(xi)
6777             if wi is not None and len(wi) != len_xi:
6778                 raise ValueError('weights should have the same shape as x')
6779             if len_xi:
6780                 input_empty = False
6781 
6782         if color is None:
6783             colors = [self._get_lines.get_next_color() for i in range(nx)]
6784         else:
6785             colors = mcolors.to_rgba_array(color)
6786             if len(colors) != nx:
6787                 raise ValueError(f"The 'color' keyword argument must have one "
6788                                  f"color per dataset, but {nx} datasets and "
6789                                  f"{len(colors)} colors were provided")
6790 
6791         hist_kwargs = dict()
6792 
6793         # if the bin_range is not given, compute without nan numpy
6794         # does not do this for us when guessing the range (but will
6795         # happily ignore nans when computing the histogram).
6796         if bin_range is None:
6797             xmin = np.inf
6798             xmax = -np.inf
6799             for xi in x:
6800                 if len(xi):
6801                     # python's min/max ignore nan,
6802                     # np.minnan returns nan for all nan input
6803                     xmin = min(xmin, np.nanmin(xi))
6804                     xmax = max(xmax, np.nanmax(xi))
6805             if xmin <= xmax:  # Only happens if we have seen a finite value.
6806                 bin_range = (xmin, xmax)
6807 
6808         # If bins are not specified either explicitly or via range,
6809         # we need to figure out the range required for all datasets,
6810         # and supply that to np.histogram.
6811         if not input_empty and len(x) > 1:
6812             if weights is not None:
6813                 _w = np.concatenate(w)
6814             else:
6815                 _w = None
6816             bins = np.histogram_bin_edges(
6817                 np.concatenate(x), bins, bin_range, _w)
6818         else:
6819             hist_kwargs['range'] = bin_range
6820 
6821         density = bool(density)
6822         if density and not stacked:
6823             hist_kwargs['density'] = density
6824 
6825         # List to store all the top coordinates of the histograms
6826         tops = []  # Will have shape (n_datasets, n_bins).
6827         # Loop through datasets
6828         for i in range(nx):
6829             # this will automatically overwrite bins,
6830             # so that each histogram uses the same bins
6831             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6832             tops.append(m)
6833         tops = np.array(tops, float)  # causes problems later if it's an int
6834         bins = np.array(bins, float)  # causes problems if float16
6835         if stacked:
6836             tops = tops.cumsum(axis=0)
6837             # If a stacked density plot, normalize so the area of all the
6838             # stacked histograms together is 1
6839             if density:
6840                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6841         if cumulative:
6842             slc = slice(None)
6843             if isinstance(cumulative, Number) and cumulative < 0:
6844                 slc = slice(None, None, -1)
6845             if density:
6846                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6847             else:
6848                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6849 
6850         patches = []
6851 
6852         if histtype.startswith('bar'):
6853 
6854             totwidth = np.diff(bins)
6855 
6856             if rwidth is not None:
6857                 dr = np.clip(rwidth, 0, 1)
6858             elif (len(tops) > 1 and
6859                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6860                 dr = 0.8
6861             else:
6862                 dr = 1.0
6863 
6864             if histtype == 'bar' and not stacked:
6865                 width = dr * totwidth / nx
6866                 dw = width
6867                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6868             elif histtype == 'barstacked' or stacked:
6869                 width = dr * totwidth
6870                 boffset, dw = 0.0, 0.0
6871 
6872             if align == 'mid':
6873                 boffset += 0.5 * totwidth
6874             elif align == 'right':
6875                 boffset += totwidth
6876 
6877             if orientation == 'horizontal':
6878                 _barfunc = self.barh
6879                 bottom_kwarg = 'left'
6880             else:  # orientation == 'vertical'
6881                 _barfunc = self.bar
6882                 bottom_kwarg = 'bottom'
6883 
6884             for top, color in zip(tops, colors):
6885                 if bottom is None:
6886                     bottom = np.zeros(len(top))
6887                 if stacked:
6888                     height = top - bottom
6889                 else:
6890                     height = top
6891                 bars = _barfunc(bins[:-1]+boffset, height, width,
6892                                 align='center', log=log,
6893                                 color=color, **{bottom_kwarg: bottom})
6894                 patches.append(bars)
6895                 if stacked:
6896                     bottom = top
6897                 boffset += dw
6898             # Remove stickies from all bars but the lowest ones, as otherwise
6899             # margin expansion would be unable to cross the stickies in the
6900             # middle of the bars.
6901             for bars in patches[1:]:
6902                 for patch in bars:
6903                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6904 
6905         elif histtype.startswith('step'):
6906             # these define the perimeter of the polygon
6907             x = np.zeros(4 * len(bins) - 3)
6908             y = np.zeros(4 * len(bins) - 3)
6909 
6910             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6911             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6912 
6913             if bottom is None:
6914                 bottom = 0
6915 
6916             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6917             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6918 
6919             if log:
6920                 if orientation == 'horizontal':
6921                     self.set_xscale('log', nonpositive='clip')
6922                 else:  # orientation == 'vertical'
6923                     self.set_yscale('log', nonpositive='clip')
6924 
6925             if align == 'left':
6926                 x -= 0.5*(bins[1]-bins[0])
6927             elif align == 'right':
6928                 x += 0.5*(bins[1]-bins[0])
6929 
6930             # If fill kwarg is set, it will be passed to the patch collection,
6931             # overriding this
6932             fill = (histtype == 'stepfilled')
6933 
6934             xvals, yvals = [], []
6935             for top in tops:
6936                 if stacked:
6937                     # top of the previous polygon becomes the bottom
6938                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6939                 # set the top of this polygon
6940                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6941 
6942                 # The starting point of the polygon has not yet been
6943                 # updated. So far only the endpoint was adjusted. This
6944                 # assignment closes the polygon. The redundant endpoint is
6945                 # later discarded (for step and stepfilled).
6946                 y[0] = y[-1]
6947 
6948                 if orientation == 'horizontal':
6949                     xvals.append(y.copy())
6950                     yvals.append(x.copy())
6951                 else:
6952                     xvals.append(x.copy())
6953                     yvals.append(y.copy())
6954 
6955             # stepfill is closed, step is not
6956             split = -1 if fill else 2 * len(bins)
6957             # add patches in reverse order so that when stacking,
6958             # items lower in the stack are plotted on top of
6959             # items higher in the stack
6960             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6961                 patches.append(self.fill(
6962                     x[:split], y[:split],
6963                     closed=True if fill else None,
6964                     facecolor=color,
6965                     edgecolor=None if fill else color,
6966                     fill=fill if fill else None,
6967                     zorder=None if fill else mlines.Line2D.zorder))
6968             for patch_list in patches:
6969                 for patch in patch_list:
6970                     if orientation == 'vertical':
6971                         patch.sticky_edges.y.append(0)
6972                     elif orientation == 'horizontal':
6973                         patch.sticky_edges.x.append(0)
6974 
6975             # we return patches, so put it back in the expected order
6976             patches.reverse()
6977 
6978         # If None, make all labels None (via zip_longest below); otherwise,
6979         # cast each element to str, but keep a single str as it.
6980         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6981         for patch, lbl in itertools.zip_longest(patches, labels):
6982             if patch:
6983                 p = patch[0]
6984                 p._internal_update(kwargs)
6985                 if lbl is not None:
6986                     p.set_label(lbl)
6987                 for p in patch[1:]:
6988                     p._internal_update(kwargs)
6989                     p.set_label('_nolegend_')
6990 
6991         if nx == 1:
6992             return tops[0], bins, patches[0]
6993         else:
6994             patch_type = ("BarContainer" if histtype.startswith("bar")
6995                           else "list[Polygon]")
6996             return tops, bins, cbook.silent_list(patch_type, patches)
6997 
6998     @_preprocess_data()
6999     def stairs(self, values, edges=None, *,
7000                orientation='vertical', baseline=0, fill=False, **kwargs):
7001         """
7002         A stepwise constant function as a line with bounding edges
7003         or a filled plot.
7004 
7005         Parameters
7006         ----------
7007         values : array-like
7008             The step heights.
7009 
7010         edges : array-like
7011             The edge positions, with ``len(edges) == len(vals) + 1``,
7012             between which the curve takes on vals values.
7013 
7014         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7015             The direction of the steps. Vertical means that *values* are along
7016             the y-axis, and edges are along the x-axis.
7017 
7018         baseline : float, array-like or None, default: 0
7019             The bottom value of the bounding edges or when
7020             ``fill=True``, position of lower edge. If *fill* is
7021             True or an array is passed to *baseline*, a closed
7022             path is drawn.
7023 
7024         fill : bool, default: False
7025             Whether the area under the step curve should be filled.
7026 
7027         Returns
7028         -------
7029         StepPatch : `~matplotlib.patches.StepPatch`
7030 
7031         Other Parameters
7032         ----------------
7033         data : indexable object, optional
7034             DATA_PARAMETER_PLACEHOLDER
7035 
7036         **kwargs
7037             `~matplotlib.patches.StepPatch` properties
7038 
7039         """
7040 
7041         if 'color' in kwargs:
7042             _color = kwargs.pop('color')
7043         else:
7044             _color = self._get_lines.get_next_color()
7045         if fill:
7046             kwargs.setdefault('linewidth', 0)
7047             kwargs.setdefault('facecolor', _color)
7048         else:
7049             kwargs.setdefault('edgecolor', _color)
7050 
7051         if edges is None:
7052             edges = np.arange(len(values) + 1)
7053 
7054         edges, values, baseline = self._process_unit_info(
7055             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7056 
7057         patch = mpatches.StepPatch(values,
7058                                    edges,
7059                                    baseline=baseline,
7060                                    orientation=orientation,
7061                                    fill=fill,
7062                                    **kwargs)
7063         self.add_patch(patch)
7064         if baseline is None:
7065             baseline = 0
7066         if orientation == 'vertical':
7067             patch.sticky_edges.y.append(np.min(baseline))
7068             self.update_datalim([(edges[0], np.min(baseline))])
7069         else:
7070             patch.sticky_edges.x.append(np.min(baseline))
7071             self.update_datalim([(np.min(baseline), edges[0])])
7072         self._request_autoscale_view()
7073         return patch
7074 
7075     @_preprocess_data(replace_names=["x", "y", "weights"])
7076     @_docstring.dedent_interpd
7077     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7078                cmin=None, cmax=None, **kwargs):
7079         """
7080         Make a 2D histogram plot.
7081 
7082         Parameters
7083         ----------
7084         x, y : array-like, shape (n, )
7085             Input values
7086 
7087         bins : None or int or [int, int] or array-like or [array, array]
7088 
7089             The bin specification:
7090 
7091             - If int, the number of bins for the two dimensions
7092               (nx=ny=bins).
7093             - If ``[int, int]``, the number of bins in each dimension
7094               (nx, ny = bins).
7095             - If array-like, the bin edges for the two dimensions
7096               (x_edges=y_edges=bins).
7097             - If ``[array, array]``, the bin edges in each dimension
7098               (x_edges, y_edges = bins).
7099 
7100             The default value is 10.
7101 
7102         range : array-like shape(2, 2), optional
7103             The leftmost and rightmost edges of the bins along each dimension
7104             (if not specified explicitly in the bins parameters): ``[[xmin,
7105             xmax], [ymin, ymax]]``. All values outside of this range will be
7106             considered outliers and not tallied in the histogram.
7107 
7108         density : bool, default: False
7109             Normalize histogram.  See the documentation for the *density*
7110             parameter of `~.Axes.hist` for more details.
7111 
7112         weights : array-like, shape (n, ), optional
7113             An array of values w_i weighing each sample (x_i, y_i).
7114 
7115         cmin, cmax : float, default: None
7116             All bins that has count less than *cmin* or more than *cmax* will
7117             not be displayed (set to NaN before passing to imshow) and these
7118             count values in the return value count histogram will also be set
7119             to nan upon return.
7120 
7121         Returns
7122         -------
7123         h : 2D array
7124             The bi-dimensional histogram of samples x and y. Values in x are
7125             histogrammed along the first dimension and values in y are
7126             histogrammed along the second dimension.
7127         xedges : 1D array
7128             The bin edges along the x-axis.
7129         yedges : 1D array
7130             The bin edges along the y-axis.
7131         image : `~.matplotlib.collections.QuadMesh`
7132 
7133         Other Parameters
7134         ----------------
7135         %(cmap_doc)s
7136 
7137         %(norm_doc)s
7138 
7139         %(vmin_vmax_doc)s
7140 
7141         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7142             The alpha blending value.
7143 
7144         data : indexable object, optional
7145             DATA_PARAMETER_PLACEHOLDER
7146 
7147         **kwargs
7148             Additional parameters are passed along to the
7149             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7150             constructor.
7151 
7152         See Also
7153         --------
7154         hist : 1D histogram plotting
7155         hexbin : 2D histogram with hexagonal bins
7156 
7157         Notes
7158         -----
7159         - Currently ``hist2d`` calculates its own axis limits, and any limits
7160           previously set are ignored.
7161         - Rendering the histogram with a logarithmic color scale is
7162           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7163           keyword argument. Likewise, power-law normalization (similar
7164           in effect to gamma correction) can be accomplished with
7165           `.colors.PowerNorm`.
7166         """
7167 
7168         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7169                                            density=density, weights=weights)
7170 
7171         if cmin is not None:
7172             h[h < cmin] = None
7173         if cmax is not None:
7174             h[h > cmax] = None
7175 
7176         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7177         self.set_xlim(xedges[0], xedges[-1])
7178         self.set_ylim(yedges[0], yedges[-1])
7179 
7180         return h, xedges, yedges, pc
7181 
7182     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7183     @_docstring.dedent_interpd
7184     def ecdf(self, x, weights=None, *, complementary=False,
7185              orientation="vertical", compress=False, **kwargs):
7186         """
7187         Compute and plot the empirical cumulative distribution function of *x*.
7188 
7189         .. versionadded:: 3.8
7190 
7191         Parameters
7192         ----------
7193         x : 1d array-like
7194             The input data.  Infinite entries are kept (and move the relevant
7195             end of the ecdf from 0/1), but NaNs and masked values are errors.
7196 
7197         weights : 1d array-like or None, default: None
7198             The weights of the entries; must have the same shape as *x*.
7199             Weights corresponding to NaN data points are dropped, and then the
7200             remaining weights are normalized to sum to 1.  If unset, all
7201             entries have the same weight.
7202 
7203         complementary : bool, default: False
7204             Whether to plot a cumulative distribution function, which increases
7205             from 0 to 1 (the default), or a complementary cumulative
7206             distribution function, which decreases from 1 to 0.
7207 
7208         orientation : {"vertical", "horizontal"}, default: "vertical"
7209             Whether the entries are plotted along the x-axis ("vertical", the
7210             default) or the y-axis ("horizontal").  This parameter takes the
7211             same values as in `~.Axes.hist`.
7212 
7213         compress : bool, default: False
7214             Whether multiple entries with the same values are grouped together
7215             (with a summed weight) before plotting.  This is mainly useful if
7216             *x* contains many identical data points, to decrease the rendering
7217             complexity of the plot. If *x* contains no duplicate points, this
7218             has no effect and just uses some time and memory.
7219 
7220         Other Parameters
7221         ----------------
7222         data : indexable object, optional
7223             DATA_PARAMETER_PLACEHOLDER
7224 
7225         **kwargs
7226             Keyword arguments control the `.Line2D` properties:
7227 
7228             %(Line2D:kwdoc)s
7229 
7230         Returns
7231         -------
7232         `.Line2D`
7233 
7234         Notes
7235         -----
7236         The ecdf plot can be thought of as a cumulative histogram with one bin
7237         per data entry; i.e. it reports on the entire dataset without any
7238         arbitrary binning.
7239 
7240         If *x* contains NaNs or masked entries, either remove them first from
7241         the array (if they should not taken into account), or replace them by
7242         -inf or +inf (if they should be sorted at the beginning or the end of
7243         the array).
7244         """
7245         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7246         if "drawstyle" in kwargs or "ds" in kwargs:
7247             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7248         if np.ma.getmask(x).any():
7249             raise ValueError("ecdf() does not support masked entries")
7250         x = np.asarray(x)
7251         if np.isnan(x).any():
7252             raise ValueError("ecdf() does not support NaNs")
7253         argsort = np.argsort(x)
7254         x = x[argsort]
7255         if weights is None:
7256             # Ensure that we end at exactly 1, avoiding floating point errors.
7257             cum_weights = (1 + np.arange(len(x))) / len(x)
7258         else:
7259             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7260             cum_weights = np.cumsum(weights / np.sum(weights))
7261         if compress:
7262             # Get indices of unique x values.
7263             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7264             x = x[compress_idxs]
7265             cum_weights = cum_weights[compress_idxs]
7266         if orientation == "vertical":
7267             if not complementary:
7268                 line, = self.plot([x[0], *x], [0, *cum_weights],
7269                                   drawstyle="steps-post", **kwargs)
7270             else:
7271                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7272                                   drawstyle="steps-pre", **kwargs)
7273             line.sticky_edges.y[:] = [0, 1]
7274         else:  # orientation == "horizontal":
7275             if not complementary:
7276                 line, = self.plot([0, *cum_weights], [x[0], *x],
7277                                   drawstyle="steps-pre", **kwargs)
7278             else:
7279                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7280                                   drawstyle="steps-post", **kwargs)
7281             line.sticky_edges.x[:] = [0, 1]
7282         return line
7283 
7284     @_preprocess_data(replace_names=["x"])
7285     @_docstring.dedent_interpd
7286     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7287             window=None, noverlap=None, pad_to=None,
7288             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7289         r"""
7290         Plot the power spectral density.
7291 
7292         The power spectral density :math:`P_{xx}` by Welch's average
7293         periodogram method.  The vector *x* is divided into *NFFT* length
7294         segments.  Each segment is detrended by function *detrend* and
7295         windowed by function *window*.  *noverlap* gives the length of
7296         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7297         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7298         with a scaling to correct for power loss due to windowing.
7299 
7300         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7301 
7302         Parameters
7303         ----------
7304         x : 1-D array or sequence
7305             Array or sequence containing the data
7306 
7307         %(Spectral)s
7308 
7309         %(PSD)s
7310 
7311         noverlap : int, default: 0 (no overlap)
7312             The number of points of overlap between segments.
7313 
7314         Fc : int, default: 0
7315             The center frequency of *x*, which offsets the x extents of the
7316             plot to reflect the frequency range used when a signal is acquired
7317             and then filtered and downsampled to baseband.
7318 
7319         return_line : bool, default: False
7320             Whether to include the line object plotted in the returned values.
7321 
7322         Returns
7323         -------
7324         Pxx : 1-D array
7325             The values for the power spectrum :math:`P_{xx}` before scaling
7326             (real valued).
7327 
7328         freqs : 1-D array
7329             The frequencies corresponding to the elements in *Pxx*.
7330 
7331         line : `~matplotlib.lines.Line2D`
7332             The line created by this function.
7333             Only returned if *return_line* is True.
7334 
7335         Other Parameters
7336         ----------------
7337         data : indexable object, optional
7338             DATA_PARAMETER_PLACEHOLDER
7339 
7340         **kwargs
7341             Keyword arguments control the `.Line2D` properties:
7342 
7343             %(Line2D:kwdoc)s
7344 
7345         See Also
7346         --------
7347         specgram
7348             Differs in the default overlap; in not returning the mean of the
7349             segment periodograms; in returning the times of the segments; and
7350             in plotting a colormap instead of a line.
7351         magnitude_spectrum
7352             Plots the magnitude spectrum.
7353         csd
7354             Plots the spectral density between two signals.
7355 
7356         Notes
7357         -----
7358         For plotting, the power is plotted as
7359         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7360         is returned.
7361 
7362         References
7363         ----------
7364         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7365         John Wiley & Sons (1986)
7366         """
7367         if Fc is None:
7368             Fc = 0
7369 
7370         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7371                               window=window, noverlap=noverlap, pad_to=pad_to,
7372                               sides=sides, scale_by_freq=scale_by_freq)
7373         freqs += Fc
7374 
7375         if scale_by_freq in (None, True):
7376             psd_units = 'dB/Hz'
7377         else:
7378             psd_units = 'dB'
7379 
7380         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7381         self.set_xlabel('Frequency')
7382         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7383         self.grid(True)
7384 
7385         vmin, vmax = self.get_ybound()
7386         step = max(10 * int(np.log10(vmax - vmin)), 1)
7387         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7388         self.set_yticks(ticks)
7389 
7390         if return_line is None or not return_line:
7391             return pxx, freqs
7392         else:
7393             return pxx, freqs, line
7394 
7395     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7396     @_docstring.dedent_interpd
7397     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7398             window=None, noverlap=None, pad_to=None,
7399             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7400         r"""
7401         Plot the cross-spectral density.
7402 
7403         The cross spectral density :math:`P_{xy}` by Welch's average
7404         periodogram method.  The vectors *x* and *y* are divided into
7405         *NFFT* length segments.  Each segment is detrended by function
7406         *detrend* and windowed by function *window*.  *noverlap* gives
7407         the length of the overlap between segments.  The product of
7408         the direct FFTs of *x* and *y* are averaged over each segment
7409         to compute :math:`P_{xy}`, with a scaling to correct for power
7410         loss due to windowing.
7411 
7412         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7413         padded to *NFFT*.
7414 
7415         Parameters
7416         ----------
7417         x, y : 1-D arrays or sequences
7418             Arrays or sequences containing the data.
7419 
7420         %(Spectral)s
7421 
7422         %(PSD)s
7423 
7424         noverlap : int, default: 0 (no overlap)
7425             The number of points of overlap between segments.
7426 
7427         Fc : int, default: 0
7428             The center frequency of *x*, which offsets the x extents of the
7429             plot to reflect the frequency range used when a signal is acquired
7430             and then filtered and downsampled to baseband.
7431 
7432         return_line : bool, default: False
7433             Whether to include the line object plotted in the returned values.
7434 
7435         Returns
7436         -------
7437         Pxy : 1-D array
7438             The values for the cross spectrum :math:`P_{xy}` before scaling
7439             (complex valued).
7440 
7441         freqs : 1-D array
7442             The frequencies corresponding to the elements in *Pxy*.
7443 
7444         line : `~matplotlib.lines.Line2D`
7445             The line created by this function.
7446             Only returned if *return_line* is True.
7447 
7448         Other Parameters
7449         ----------------
7450         data : indexable object, optional
7451             DATA_PARAMETER_PLACEHOLDER
7452 
7453         **kwargs
7454             Keyword arguments control the `.Line2D` properties:
7455 
7456             %(Line2D:kwdoc)s
7457 
7458         See Also
7459         --------
7460         psd : is equivalent to setting ``y = x``.
7461 
7462         Notes
7463         -----
7464         For plotting, the power is plotted as
7465         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7466         is returned.
7467 
7468         References
7469         ----------
7470         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7471         John Wiley & Sons (1986)
7472         """
7473         if Fc is None:
7474             Fc = 0
7475 
7476         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7477                               window=window, noverlap=noverlap, pad_to=pad_to,
7478                               sides=sides, scale_by_freq=scale_by_freq)
7479         # pxy is complex
7480         freqs += Fc
7481 
7482         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7483         self.set_xlabel('Frequency')
7484         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7485         self.grid(True)
7486 
7487         vmin, vmax = self.get_ybound()
7488         step = max(10 * int(np.log10(vmax - vmin)), 1)
7489         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7490         self.set_yticks(ticks)
7491 
7492         if return_line is None or not return_line:
7493             return pxy, freqs
7494         else:
7495             return pxy, freqs, line
7496 
7497     @_preprocess_data(replace_names=["x"])
7498     @_docstring.dedent_interpd
7499     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7500                            pad_to=None, sides=None, scale=None,
7501                            **kwargs):
7502         """
7503         Plot the magnitude spectrum.
7504 
7505         Compute the magnitude spectrum of *x*.  Data is padded to a
7506         length of *pad_to* and the windowing function *window* is applied to
7507         the signal.
7508 
7509         Parameters
7510         ----------
7511         x : 1-D array or sequence
7512             Array or sequence containing the data.
7513 
7514         %(Spectral)s
7515 
7516         %(Single_Spectrum)s
7517 
7518         scale : {'default', 'linear', 'dB'}
7519             The scaling of the values in the *spec*.  'linear' is no scaling.
7520             'dB' returns the values in dB scale, i.e., the dB amplitude
7521             (20 * log10). 'default' is 'linear'.
7522 
7523         Fc : int, default: 0
7524             The center frequency of *x*, which offsets the x extents of the
7525             plot to reflect the frequency range used when a signal is acquired
7526             and then filtered and downsampled to baseband.
7527 
7528         Returns
7529         -------
7530         spectrum : 1-D array
7531             The values for the magnitude spectrum before scaling (real valued).
7532 
7533         freqs : 1-D array
7534             The frequencies corresponding to the elements in *spectrum*.
7535 
7536         line : `~matplotlib.lines.Line2D`
7537             The line created by this function.
7538 
7539         Other Parameters
7540         ----------------
7541         data : indexable object, optional
7542             DATA_PARAMETER_PLACEHOLDER
7543 
7544         **kwargs
7545             Keyword arguments control the `.Line2D` properties:
7546 
7547             %(Line2D:kwdoc)s
7548 
7549         See Also
7550         --------
7551         psd
7552             Plots the power spectral density.
7553         angle_spectrum
7554             Plots the angles of the corresponding frequencies.
7555         phase_spectrum
7556             Plots the phase (unwrapped angle) of the corresponding frequencies.
7557         specgram
7558             Can plot the magnitude spectrum of segments within the signal in a
7559             colormap.
7560         """
7561         if Fc is None:
7562             Fc = 0
7563 
7564         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7565                                               pad_to=pad_to, sides=sides)
7566         freqs += Fc
7567 
7568         yunits = _api.check_getitem(
7569             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7570              'dB': 'dB'},
7571             scale=scale)
7572         if yunits == 'energy':
7573             Z = spec
7574         else:  # yunits == 'dB'
7575             Z = 20. * np.log10(spec)
7576 
7577         line, = self.plot(freqs, Z, **kwargs)
7578         self.set_xlabel('Frequency')
7579         self.set_ylabel('Magnitude (%s)' % yunits)
7580 
7581         return spec, freqs, line
7582 
7583     @_preprocess_data(replace_names=["x"])
7584     @_docstring.dedent_interpd
7585     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7586                        pad_to=None, sides=None, **kwargs):
7587         """
7588         Plot the angle spectrum.
7589 
7590         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7591         Data is padded to a length of *pad_to* and the windowing function
7592         *window* is applied to the signal.
7593 
7594         Parameters
7595         ----------
7596         x : 1-D array or sequence
7597             Array or sequence containing the data.
7598 
7599         %(Spectral)s
7600 
7601         %(Single_Spectrum)s
7602 
7603         Fc : int, default: 0
7604             The center frequency of *x*, which offsets the x extents of the
7605             plot to reflect the frequency range used when a signal is acquired
7606             and then filtered and downsampled to baseband.
7607 
7608         Returns
7609         -------
7610         spectrum : 1-D array
7611             The values for the angle spectrum in radians (real valued).
7612 
7613         freqs : 1-D array
7614             The frequencies corresponding to the elements in *spectrum*.
7615 
7616         line : `~matplotlib.lines.Line2D`
7617             The line created by this function.
7618 
7619         Other Parameters
7620         ----------------
7621         data : indexable object, optional
7622             DATA_PARAMETER_PLACEHOLDER
7623 
7624         **kwargs
7625             Keyword arguments control the `.Line2D` properties:
7626 
7627             %(Line2D:kwdoc)s
7628 
7629         See Also
7630         --------
7631         magnitude_spectrum
7632             Plots the magnitudes of the corresponding frequencies.
7633         phase_spectrum
7634             Plots the unwrapped version of this function.
7635         specgram
7636             Can plot the angle spectrum of segments within the signal in a
7637             colormap.
7638         """
7639         if Fc is None:
7640             Fc = 0
7641 
7642         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7643                                           pad_to=pad_to, sides=sides)
7644         freqs += Fc
7645 
7646         lines = self.plot(freqs, spec, **kwargs)
7647         self.set_xlabel('Frequency')
7648         self.set_ylabel('Angle (radians)')
7649 
7650         return spec, freqs, lines[0]
7651 
7652     @_preprocess_data(replace_names=["x"])
7653     @_docstring.dedent_interpd
7654     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7655                        pad_to=None, sides=None, **kwargs):
7656         """
7657         Plot the phase spectrum.
7658 
7659         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7660         Data is padded to a length of *pad_to* and the windowing function
7661         *window* is applied to the signal.
7662 
7663         Parameters
7664         ----------
7665         x : 1-D array or sequence
7666             Array or sequence containing the data
7667 
7668         %(Spectral)s
7669 
7670         %(Single_Spectrum)s
7671 
7672         Fc : int, default: 0
7673             The center frequency of *x*, which offsets the x extents of the
7674             plot to reflect the frequency range used when a signal is acquired
7675             and then filtered and downsampled to baseband.
7676 
7677         Returns
7678         -------
7679         spectrum : 1-D array
7680             The values for the phase spectrum in radians (real valued).
7681 
7682         freqs : 1-D array
7683             The frequencies corresponding to the elements in *spectrum*.
7684 
7685         line : `~matplotlib.lines.Line2D`
7686             The line created by this function.
7687 
7688         Other Parameters
7689         ----------------
7690         data : indexable object, optional
7691             DATA_PARAMETER_PLACEHOLDER
7692 
7693         **kwargs
7694             Keyword arguments control the `.Line2D` properties:
7695 
7696             %(Line2D:kwdoc)s
7697 
7698         See Also
7699         --------
7700         magnitude_spectrum
7701             Plots the magnitudes of the corresponding frequencies.
7702         angle_spectrum
7703             Plots the wrapped version of this function.
7704         specgram
7705             Can plot the phase spectrum of segments within the signal in a
7706             colormap.
7707         """
7708         if Fc is None:
7709             Fc = 0
7710 
7711         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7712                                           pad_to=pad_to, sides=sides)
7713         freqs += Fc
7714 
7715         lines = self.plot(freqs, spec, **kwargs)
7716         self.set_xlabel('Frequency')
7717         self.set_ylabel('Phase (radians)')
7718 
7719         return spec, freqs, lines[0]
7720 
7721     @_preprocess_data(replace_names=["x", "y"])
7722     @_docstring.dedent_interpd
7723     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7724                window=mlab.window_hanning, noverlap=0, pad_to=None,
7725                sides='default', scale_by_freq=None, **kwargs):
7726         r"""
7727         Plot the coherence between *x* and *y*.
7728 
7729         Coherence is the normalized cross spectral density:
7730 
7731         .. math::
7732 
7733           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7734 
7735         Parameters
7736         ----------
7737         %(Spectral)s
7738 
7739         %(PSD)s
7740 
7741         noverlap : int, default: 0 (no overlap)
7742             The number of points of overlap between blocks.
7743 
7744         Fc : int, default: 0
7745             The center frequency of *x*, which offsets the x extents of the
7746             plot to reflect the frequency range used when a signal is acquired
7747             and then filtered and downsampled to baseband.
7748 
7749         Returns
7750         -------
7751         Cxy : 1-D array
7752             The coherence vector.
7753 
7754         freqs : 1-D array
7755             The frequencies for the elements in *Cxy*.
7756 
7757         Other Parameters
7758         ----------------
7759         data : indexable object, optional
7760             DATA_PARAMETER_PLACEHOLDER
7761 
7762         **kwargs
7763             Keyword arguments control the `.Line2D` properties:
7764 
7765             %(Line2D:kwdoc)s
7766 
7767         References
7768         ----------
7769         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7770         John Wiley & Sons (1986)
7771         """
7772         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7773                                  window=window, noverlap=noverlap,
7774                                  scale_by_freq=scale_by_freq, sides=sides,
7775                                  pad_to=pad_to)
7776         freqs += Fc
7777 
7778         self.plot(freqs, cxy, **kwargs)
7779         self.set_xlabel('Frequency')
7780         self.set_ylabel('Coherence')
7781         self.grid(True)
7782 
7783         return cxy, freqs
7784 
7785     @_preprocess_data(replace_names=["x"])
7786     @_docstring.dedent_interpd
7787     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7788                  window=None, noverlap=None,
7789                  cmap=None, xextent=None, pad_to=None, sides=None,
7790                  scale_by_freq=None, mode=None, scale=None,
7791                  vmin=None, vmax=None, **kwargs):
7792         """
7793         Plot a spectrogram.
7794 
7795         Compute and plot a spectrogram of data in *x*.  Data are split into
7796         *NFFT* length segments and the spectrum of each section is
7797         computed.  The windowing function *window* is applied to each
7798         segment, and the amount of overlap of each segment is
7799         specified with *noverlap*. The spectrogram is plotted as a colormap
7800         (using imshow).
7801 
7802         Parameters
7803         ----------
7804         x : 1-D array or sequence
7805             Array or sequence containing the data.
7806 
7807         %(Spectral)s
7808 
7809         %(PSD)s
7810 
7811         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7812             What sort of spectrum to use.  Default is 'psd', which takes the
7813             power spectral density.  'magnitude' returns the magnitude
7814             spectrum.  'angle' returns the phase spectrum without unwrapping.
7815             'phase' returns the phase spectrum with unwrapping.
7816 
7817         noverlap : int, default: 128
7818             The number of points of overlap between blocks.
7819 
7820         scale : {'default', 'linear', 'dB'}
7821             The scaling of the values in the *spec*.  'linear' is no scaling.
7822             'dB' returns the values in dB scale.  When *mode* is 'psd',
7823             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7824             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7825             'magnitude' and 'linear' otherwise.  This must be 'linear'
7826             if *mode* is 'angle' or 'phase'.
7827 
7828         Fc : int, default: 0
7829             The center frequency of *x*, which offsets the x extents of the
7830             plot to reflect the frequency range used when a signal is acquired
7831             and then filtered and downsampled to baseband.
7832 
7833         cmap : `.Colormap`, default: :rc:`image.cmap`
7834 
7835         xextent : *None* or (xmin, xmax)
7836             The image extent along the x-axis. The default sets *xmin* to the
7837             left border of the first bin (*spectrum* column) and *xmax* to the
7838             right border of the last bin. Note that for *noverlap>0* the width
7839             of the bins is smaller than those of the segments.
7840 
7841         data : indexable object, optional
7842             DATA_PARAMETER_PLACEHOLDER
7843 
7844         **kwargs
7845             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7846             which makes the specgram image. The origin keyword argument
7847             is not supported.
7848 
7849         Returns
7850         -------
7851         spectrum : 2D array
7852             Columns are the periodograms of successive segments.
7853 
7854         freqs : 1-D array
7855             The frequencies corresponding to the rows in *spectrum*.
7856 
7857         t : 1-D array
7858             The times corresponding to midpoints of segments (i.e., the columns
7859             in *spectrum*).
7860 
7861         im : `.AxesImage`
7862             The image created by imshow containing the spectrogram.
7863 
7864         See Also
7865         --------
7866         psd
7867             Differs in the default overlap; in returning the mean of the
7868             segment periodograms; in not returning times; and in generating a
7869             line plot instead of colormap.
7870         magnitude_spectrum
7871             A single spectrum, similar to having a single segment when *mode*
7872             is 'magnitude'. Plots a line instead of a colormap.
7873         angle_spectrum
7874             A single spectrum, similar to having a single segment when *mode*
7875             is 'angle'. Plots a line instead of a colormap.
7876         phase_spectrum
7877             A single spectrum, similar to having a single segment when *mode*
7878             is 'phase'. Plots a line instead of a colormap.
7879 
7880         Notes
7881         -----
7882         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7883         is set to 'psd'.
7884         """
7885         if NFFT is None:
7886             NFFT = 256  # same default as in mlab.specgram()
7887         if Fc is None:
7888             Fc = 0  # same default as in mlab._spectral_helper()
7889         if noverlap is None:
7890             noverlap = 128  # same default as in mlab.specgram()
7891         if Fs is None:
7892             Fs = 2  # same default as in mlab._spectral_helper()
7893 
7894         if mode == 'complex':
7895             raise ValueError('Cannot plot a complex specgram')
7896 
7897         if scale is None or scale == 'default':
7898             if mode in ['angle', 'phase']:
7899                 scale = 'linear'
7900             else:
7901                 scale = 'dB'
7902         elif mode in ['angle', 'phase'] and scale == 'dB':
7903             raise ValueError('Cannot use dB scale with angle or phase mode')
7904 
7905         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7906                                        detrend=detrend, window=window,
7907                                        noverlap=noverlap, pad_to=pad_to,
7908                                        sides=sides,
7909                                        scale_by_freq=scale_by_freq,
7910                                        mode=mode)
7911 
7912         if scale == 'linear':
7913             Z = spec
7914         elif scale == 'dB':
7915             if mode is None or mode == 'default' or mode == 'psd':
7916                 Z = 10. * np.log10(spec)
7917             else:
7918                 Z = 20. * np.log10(spec)
7919         else:
7920             raise ValueError(f'Unknown scale {scale!r}')
7921 
7922         Z = np.flipud(Z)
7923 
7924         if xextent is None:
7925             # padding is needed for first and last segment:
7926             pad_xextent = (NFFT-noverlap) / Fs / 2
7927             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7928         xmin, xmax = xextent
7929         freqs += Fc
7930         extent = xmin, xmax, freqs[0], freqs[-1]
7931 
7932         if 'origin' in kwargs:
7933             raise _api.kwarg_error("specgram", "origin")
7934 
7935         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7936                          origin='upper', **kwargs)
7937         self.axis('auto')
7938 
7939         return spec, freqs, t, im
7940 
7941     @_docstring.dedent_interpd
7942     def spy(self, Z, precision=0, marker=None, markersize=None,
7943             aspect='equal', origin="upper", **kwargs):
7944         """
7945         Plot the sparsity pattern of a 2D array.
7946 
7947         This visualizes the non-zero values of the array.
7948 
7949         Two plotting styles are available: image and marker. Both
7950         are available for full arrays, but only the marker style
7951         works for `scipy.sparse.spmatrix` instances.
7952 
7953         **Image style**
7954 
7955         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7956         extra remaining keyword arguments are passed to this method.
7957 
7958         **Marker style**
7959 
7960         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7961         *None*, a `.Line2D` object will be returned with the value of marker
7962         determining the marker type, and any remaining keyword arguments
7963         passed to `~.Axes.plot`.
7964 
7965         Parameters
7966         ----------
7967         Z : (M, N) array-like
7968             The array to be plotted.
7969 
7970         precision : float or 'present', default: 0
7971             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7972             values of :math:`|Z| > precision` will be plotted.
7973 
7974             For `scipy.sparse.spmatrix` instances, you can also
7975             pass 'present'. In this case any value present in the array
7976             will be plotted, even if it is identically zero.
7977 
7978         aspect : {'equal', 'auto', None} or float, default: 'equal'
7979             The aspect ratio of the Axes.  This parameter is particularly
7980             relevant for images since it determines whether data pixels are
7981             square.
7982 
7983             This parameter is a shortcut for explicitly calling
7984             `.Axes.set_aspect`. See there for further details.
7985 
7986             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7987             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7988               that the data fit in the Axes. In general, this will result in
7989               non-square pixels.
7990             - *None*: Use :rc:`image.aspect`.
7991 
7992         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7993             Place the [0, 0] index of the array in the upper left or lower left
7994             corner of the Axes. The convention 'upper' is typically used for
7995             matrices and images.
7996 
7997         Returns
7998         -------
7999         `~matplotlib.image.AxesImage` or `.Line2D`
8000             The return type depends on the plotting style (see above).
8001 
8002         Other Parameters
8003         ----------------
8004         **kwargs
8005             The supported additional parameters depend on the plotting style.
8006 
8007             For the image style, you can pass the following additional
8008             parameters of `~.Axes.imshow`:
8009 
8010             - *cmap*
8011             - *alpha*
8012             - *url*
8013             - any `.Artist` properties (passed on to the `.AxesImage`)
8014 
8015             For the marker style, you can pass any `.Line2D` property except
8016             for *linestyle*:
8017 
8018             %(Line2D:kwdoc)s
8019         """
8020         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8021             marker = 's'
8022         _api.check_in_list(["upper", "lower"], origin=origin)
8023         if marker is None and markersize is None:
8024             Z = np.asarray(Z)
8025             mask = np.abs(Z) > precision
8026 
8027             if 'cmap' not in kwargs:
8028                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8029                                                         name='binary')
8030             if 'interpolation' in kwargs:
8031                 raise _api.kwarg_error("spy", "interpolation")
8032             if 'norm' not in kwargs:
8033                 kwargs['norm'] = mcolors.NoNorm()
8034             ret = self.imshow(mask, interpolation='nearest',
8035                               aspect=aspect, origin=origin,
8036                               **kwargs)
8037         else:
8038             if hasattr(Z, 'tocoo'):
8039                 c = Z.tocoo()
8040                 if precision == 'present':
8041                     y = c.row
8042                     x = c.col
8043                 else:
8044                     nonzero = np.abs(c.data) > precision
8045                     y = c.row[nonzero]
8046                     x = c.col[nonzero]
8047             else:
8048                 Z = np.asarray(Z)
8049                 nonzero = np.abs(Z) > precision
8050                 y, x = np.nonzero(nonzero)
8051             if marker is None:
8052                 marker = 's'
8053             if markersize is None:
8054                 markersize = 10
8055             if 'linestyle' in kwargs:
8056                 raise _api.kwarg_error("spy", "linestyle")
8057             ret = mlines.Line2D(
8058                 x, y, linestyle='None', marker=marker, markersize=markersize,
8059                 **kwargs)
8060             self.add_line(ret)
8061             nr, nc = Z.shape
8062             self.set_xlim(-0.5, nc - 0.5)
8063             if origin == "upper":
8064                 self.set_ylim(nr - 0.5, -0.5)
8065             else:
8066                 self.set_ylim(-0.5, nr - 0.5)
8067             self.set_aspect(aspect)
8068         self.title.set_y(1.05)
8069         if origin == "upper":
8070             self.xaxis.tick_top()
8071         else:  # lower
8072             self.xaxis.tick_bottom()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return ret
8079 
8080     def matshow(self, Z, **kwargs):
8081         """
8082         Plot the values of a 2D matrix or array as color-coded image.
8083 
8084         The matrix will be shown the way it would be printed, with the first
8085         row at the top.  Row and column numbering is zero-based.
8086 
8087         Parameters
8088         ----------
8089         Z : (M, N) array-like
8090             The matrix to be displayed.
8091 
8092         Returns
8093         -------
8094         `~matplotlib.image.AxesImage`
8095 
8096         Other Parameters
8097         ----------------
8098         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8099 
8100         See Also
8101         --------
8102         imshow : More general function to plot data on a 2D regular raster.
8103 
8104         Notes
8105         -----
8106         This is just a convenience function wrapping `.imshow` to set useful
8107         defaults for displaying a matrix. In particular:
8108 
8109         - Set ``origin='upper'``.
8110         - Set ``interpolation='nearest'``.
8111         - Set ``aspect='equal'``.
8112         - Ticks are placed to the left and above.
8113         - Ticks are formatted to show integer indices.
8114 
8115         """
8116         Z = np.asanyarray(Z)
8117         kw = {'origin': 'upper',
8118               'interpolation': 'nearest',
8119               'aspect': 'equal',          # (already the imshow default)
8120               **kwargs}
8121         im = self.imshow(Z, **kw)
8122         self.title.set_y(1.05)
8123         self.xaxis.tick_top()
8124         self.xaxis.set_ticks_position('both')
8125         self.xaxis.set_major_locator(
8126             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8127         self.yaxis.set_major_locator(
8128             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8129         return im
8130 
8131     @_preprocess_data(replace_names=["dataset"])
8132     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8133                    showmeans=False, showextrema=True, showmedians=False,
8134                    quantiles=None, points=100, bw_method=None):
8135         """
8136         Make a violin plot.
8137 
8138         Make a violin plot for each column of *dataset* or each vector in
8139         sequence *dataset*.  Each filled area extends to represent the
8140         entire data range, with optional lines at the mean, the median,
8141         the minimum, the maximum, and user-specified quantiles.
8142 
8143         Parameters
8144         ----------
8145         dataset : Array or a sequence of vectors.
8146           The input data.
8147 
8148         positions : array-like, default: [1, 2, ..., n]
8149           The positions of the violins. The ticks and limits are
8150           automatically set to match the positions.
8151 
8152         vert : bool, default: True.
8153           If true, creates a vertical violin plot.
8154           Otherwise, creates a horizontal violin plot.
8155 
8156         widths : array-like, default: 0.5
8157           Either a scalar or a vector that sets the maximal width of
8158           each violin. The default is 0.5, which uses about half of the
8159           available horizontal space.
8160 
8161         showmeans : bool, default: False
8162           If `True`, will toggle rendering of the means.
8163 
8164         showextrema : bool, default: True
8165           If `True`, will toggle rendering of the extrema.
8166 
8167         showmedians : bool, default: False
8168           If `True`, will toggle rendering of the medians.
8169 
8170         quantiles : array-like, default: None
8171           If not None, set a list of floats in interval [0, 1] for each violin,
8172           which stands for the quantiles that will be rendered for that
8173           violin.
8174 
8175         points : int, default: 100
8176           Defines the number of points to evaluate each of the
8177           gaussian kernel density estimations at.
8178 
8179         bw_method : str, scalar or callable, optional
8180           The method used to calculate the estimator bandwidth.  This can be
8181           'scott', 'silverman', a scalar constant or a callable.  If a
8182           scalar, this will be used directly as `kde.factor`.  If a
8183           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8184           its only parameter and return a scalar. If None (default), 'scott'
8185           is used.
8186 
8187         data : indexable object, optional
8188             DATA_PARAMETER_PLACEHOLDER
8189 
8190         Returns
8191         -------
8192         dict
8193           A dictionary mapping each component of the violinplot to a
8194           list of the corresponding collection instances created. The
8195           dictionary has the following keys:
8196 
8197           - ``bodies``: A list of the `~.collections.PolyCollection`
8198             instances containing the filled area of each violin.
8199 
8200           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8201             the mean values of each of the violin's distribution.
8202 
8203           - ``cmins``: A `~.collections.LineCollection` instance that marks
8204             the bottom of each violin's distribution.
8205 
8206           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8207             the top of each violin's distribution.
8208 
8209           - ``cbars``: A `~.collections.LineCollection` instance that marks
8210             the centers of each violin's distribution.
8211 
8212           - ``cmedians``: A `~.collections.LineCollection` instance that
8213             marks the median values of each of the violin's distribution.
8214 
8215           - ``cquantiles``: A `~.collections.LineCollection` instance created
8216             to identify the quantile values of each of the violin's
8217             distribution.
8218 
8219         """
8220 
8221         def _kde_method(X, coords):
8222             # Unpack in case of e.g. Pandas or xarray object
8223             X = cbook._unpack_to_numpy(X)
8224             # fallback gracefully if the vector contains only one value
8225             if np.all(X[0] == X):
8226                 return (X[0] == coords).astype(float)
8227             kde = mlab.GaussianKDE(X, bw_method)
8228             return kde.evaluate(coords)
8229 
8230         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8231                                      quantiles=quantiles)
8232         return self.violin(vpstats, positions=positions, vert=vert,
8233                            widths=widths, showmeans=showmeans,
8234                            showextrema=showextrema, showmedians=showmedians)
8235 
8236     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8237                showmeans=False, showextrema=True, showmedians=False):
8238         """
8239         Drawing function for violin plots.
8240 
8241         Draw a violin plot for each column of *vpstats*. Each filled area
8242         extends to represent the entire data range, with optional lines at the
8243         mean, the median, the minimum, the maximum, and the quantiles values.
8244 
8245         Parameters
8246         ----------
8247         vpstats : list of dicts
8248           A list of dictionaries containing stats for each violin plot.
8249           Required keys are:
8250 
8251           - ``coords``: A list of scalars containing the coordinates that
8252             the violin's kernel density estimate were evaluated at.
8253 
8254           - ``vals``: A list of scalars containing the values of the
8255             kernel density estimate at each of the coordinates given
8256             in *coords*.
8257 
8258           - ``mean``: The mean value for this violin's dataset.
8259 
8260           - ``median``: The median value for this violin's dataset.
8261 
8262           - ``min``: The minimum value for this violin's dataset.
8263 
8264           - ``max``: The maximum value for this violin's dataset.
8265 
8266           Optional keys are:
8267 
8268           - ``quantiles``: A list of scalars containing the quantile values
8269             for this violin's dataset.
8270 
8271         positions : array-like, default: [1, 2, ..., n]
8272           The positions of the violins. The ticks and limits are
8273           automatically set to match the positions.
8274 
8275         vert : bool, default: True.
8276           If true, plots the violins vertically.
8277           Otherwise, plots the violins horizontally.
8278 
8279         widths : array-like, default: 0.5
8280           Either a scalar or a vector that sets the maximal width of
8281           each violin. The default is 0.5, which uses about half of the
8282           available horizontal space.
8283 
8284         showmeans : bool, default: False
8285           If true, will toggle rendering of the means.
8286 
8287         showextrema : bool, default: True
8288           If true, will toggle rendering of the extrema.
8289 
8290         showmedians : bool, default: False
8291           If true, will toggle rendering of the medians.
8292 
8293         Returns
8294         -------
8295         dict
8296           A dictionary mapping each component of the violinplot to a
8297           list of the corresponding collection instances created. The
8298           dictionary has the following keys:
8299 
8300           - ``bodies``: A list of the `~.collections.PolyCollection`
8301             instances containing the filled area of each violin.
8302 
8303           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8304             the mean values of each of the violin's distribution.
8305 
8306           - ``cmins``: A `~.collections.LineCollection` instance that marks
8307             the bottom of each violin's distribution.
8308 
8309           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8310             the top of each violin's distribution.
8311 
8312           - ``cbars``: A `~.collections.LineCollection` instance that marks
8313             the centers of each violin's distribution.
8314 
8315           - ``cmedians``: A `~.collections.LineCollection` instance that
8316             marks the median values of each of the violin's distribution.
8317 
8318           - ``cquantiles``: A `~.collections.LineCollection` instance created
8319             to identify the quantiles values of each of the violin's
8320             distribution.
8321         """
8322 
8323         # Statistical quantities to be plotted on the violins
8324         means = []
8325         mins = []
8326         maxes = []
8327         medians = []
8328         quantiles = []
8329 
8330         qlens = []  # Number of quantiles in each dataset.
8331 
8332         artists = {}  # Collections to be returned
8333 
8334         N = len(vpstats)
8335         datashape_message = ("List of violinplot statistics and `{0}` "
8336                              "values must have the same length")
8337 
8338         # Validate positions
8339         if positions is None:
8340             positions = range(1, N + 1)
8341         elif len(positions) != N:
8342             raise ValueError(datashape_message.format("positions"))
8343 
8344         # Validate widths
8345         if np.isscalar(widths):
8346             widths = [widths] * N
8347         elif len(widths) != N:
8348             raise ValueError(datashape_message.format("widths"))
8349 
8350         # Calculate ranges for statistics lines (shape (2, N)).
8351         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8352 
8353         # Colors.
8354         if mpl.rcParams['_internal.classic_mode']:
8355             fillcolor = 'y'
8356             linecolor = 'r'
8357         else:
8358             fillcolor = linecolor = self._get_lines.get_next_color()
8359 
8360         # Check whether we are rendering vertically or horizontally
8361         if vert:
8362             fill = self.fill_betweenx
8363             perp_lines = functools.partial(self.hlines, colors=linecolor)
8364             par_lines = functools.partial(self.vlines, colors=linecolor)
8365         else:
8366             fill = self.fill_between
8367             perp_lines = functools.partial(self.vlines, colors=linecolor)
8368             par_lines = functools.partial(self.hlines, colors=linecolor)
8369 
8370         # Render violins
8371         bodies = []
8372         for stats, pos, width in zip(vpstats, positions, widths):
8373             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8374             vals = np.array(stats['vals'])
8375             vals = 0.5 * width * vals / vals.max()
8376             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8377                             facecolor=fillcolor, alpha=0.3)]
8378             means.append(stats['mean'])
8379             mins.append(stats['min'])
8380             maxes.append(stats['max'])
8381             medians.append(stats['median'])
8382             q = stats.get('quantiles')  # a list of floats, or None
8383             if q is None:
8384                 q = []
8385             quantiles.extend(q)
8386             qlens.append(len(q))
8387         artists['bodies'] = bodies
8388 
8389         if showmeans:  # Render means
8390             artists['cmeans'] = perp_lines(means, *line_ends)
8391         if showextrema:  # Render extrema
8392             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8393             artists['cmins'] = perp_lines(mins, *line_ends)
8394             artists['cbars'] = par_lines(positions, mins, maxes)
8395         if showmedians:  # Render medians
8396             artists['cmedians'] = perp_lines(medians, *line_ends)
8397         if quantiles:  # Render quantiles: each width is repeated qlen times.
8398             artists['cquantiles'] = perp_lines(
8399                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8400 
8401         return artists
8402 
8403     # Methods that are entirely implemented in other modules.
8404 
8405     table = mtable.table
8406 
8407     # args can be either Y or y1, y2, ... and all should be replaced
8408     stackplot = _preprocess_data()(mstack.stackplot)
8409 
8410     streamplot = _preprocess_data(
8411         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8412 
8413     tricontour = mtri.tricontour
8414     tricontourf = mtri.tricontourf
8415     tripcolor = mtri.tripcolor
8416     triplot = mtri.triplot
8417 
8418     def _get_aspect_ratio(self):
8419         """
8420         Convenience method to calculate the aspect ratio of the axes in
8421         the display coordinate system.
8422         """
8423         figure_size = self.get_figure().get_size_inches()
8424         ll, ur = self.get_position() * figure_size
8425         width, height = ur - ll
8426         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>set_aspect</method>
<code>
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True

</code><intended_behavior>While the core functionality of `set_aspect` does not inherently contain a bug related to the issue, an enhancement could be considered to support conditional aspect ratio adjustments based on additional context (such as transformation information). This would potentially involve expanding the method signature to accept a new parameter indicating whether the aspect ratio setting should be conditional on the type of transformation applied. However, this approach would require careful consideration to ensure compatibility with the existing codebase and would likely involve adjustments upstream (e.g., in how `imshow` invokes `set_aspect`) to pass down the necessary context. The primary modification remains in how `imshow` interacts with this method rather than changing `set_aspect` itself.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~matplotlib.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self, clear=False)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self, clear=False)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine._clear()  # Use _clear to not clear Axis again
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than ´None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                ┌─────────────────┬─────────────────┬─────────────────┐
1829                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1830                ├─────────────────┼─────────────────┼─────────────────┤
1831                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1832                ├─────────────────┼─────────────────┼─────────────────┤
1833                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1834                └─────────────────┴─────────────────┴─────────────────┘
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance((mcoll.Collection, mimage.AxesImage), im=im)
2175         if im not in self._children:
2176             raise ValueError("Argument must be an image or collection in this Axes")
2177         self._current_image = im
2178 
2179     def _gci(self):
2180         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2181         return self._current_image
2182 
2183     def has_data(self):
2184         """
2185         Return whether any artists have been added to the Axes.
2186 
2187         This should not be used to determine whether the *dataLim*
2188         need to be updated, and may not actually be useful for
2189         anything.
2190         """
2191         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2192                                   mlines.Line2D, mpatches.Patch))
2193                    for a in self._children)
2194 
2195     def add_artist(self, a):
2196         """
2197         Add an `.Artist` to the Axes; return the artist.
2198 
2199         Use `add_artist` only for artists for which there is no dedicated
2200         "add" method; and if necessary, use a method such as `update_datalim`
2201         to manually update the dataLim if the artist is to be included in
2202         autoscaling.
2203 
2204         If no ``transform`` has been specified when creating the artist (e.g.
2205         ``artist.get_transform() == None``) then the transform is set to
2206         ``ax.transData``.
2207         """
2208         a.axes = self
2209         self._children.append(a)
2210         a._remove_method = self._children.remove
2211         self._set_artist_props(a)
2212         if a.get_clip_path() is None:
2213             a.set_clip_path(self.patch)
2214         self.stale = True
2215         return a
2216 
2217     def add_child_axes(self, ax):
2218         """
2219         Add an `.AxesBase` to the Axes' children; return the child Axes.
2220 
2221         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2222         """
2223 
2224         # normally Axes have themselves as the Axes, but these need to have
2225         # their parent...
2226         # Need to bypass the getter...
2227         ax._axes = self
2228         ax.stale_callback = martist._stale_axes_callback
2229 
2230         self.child_axes.append(ax)
2231         ax._remove_method = self.child_axes.remove
2232         self.stale = True
2233         return ax
2234 
2235     def add_collection(self, collection, autolim=True):
2236         """
2237         Add a `.Collection` to the Axes; return the collection.
2238         """
2239         _api.check_isinstance(mcoll.Collection, collection=collection)
2240         label = collection.get_label()
2241         if not label:
2242             collection.set_label(f'_child{len(self._children)}')
2243         self._children.append(collection)
2244         collection._remove_method = self._children.remove
2245         self._set_artist_props(collection)
2246 
2247         if collection.get_clip_path() is None:
2248             collection.set_clip_path(self.patch)
2249 
2250         if autolim:
2251             # Make sure viewLim is not stale (mostly to match
2252             # pre-lazy-autoscale behavior, which is not really better).
2253             self._unstale_viewLim()
2254             datalim = collection.get_datalim(self.transData)
2255             points = datalim.get_points()
2256             if not np.isinf(datalim.minpos).all():
2257                 # By definition, if minpos (minimum positive value) is set
2258                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2259                 # and minpos would be superfluous. However, we add minpos to
2260                 # the call so that self.dataLim will update its own minpos.
2261                 # This ensures that log scales see the correct minimum.
2262                 points = np.concatenate([points, [datalim.minpos]])
2263             self.update_datalim(points)
2264 
2265         self.stale = True
2266         return collection
2267 
2268     def add_image(self, image):
2269         """
2270         Add an `.AxesImage` to the Axes; return the image.
2271         """
2272         _api.check_isinstance(mimage.AxesImage, image=image)
2273         self._set_artist_props(image)
2274         if not image.get_label():
2275             image.set_label(f'_child{len(self._children)}')
2276         self._children.append(image)
2277         image._remove_method = self._children.remove
2278         self.stale = True
2279         return image
2280 
2281     def _update_image_limits(self, image):
2282         xmin, xmax, ymin, ymax = image.get_extent()
2283         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2284 
2285     def add_line(self, line):
2286         """
2287         Add a `.Line2D` to the Axes; return the line.
2288         """
2289         _api.check_isinstance(mlines.Line2D, line=line)
2290         self._set_artist_props(line)
2291         if line.get_clip_path() is None:
2292             line.set_clip_path(self.patch)
2293 
2294         self._update_line_limits(line)
2295         if not line.get_label():
2296             line.set_label(f'_child{len(self._children)}')
2297         self._children.append(line)
2298         line._remove_method = self._children.remove
2299         self.stale = True
2300         return line
2301 
2302     def _add_text(self, txt):
2303         """
2304         Add a `.Text` to the Axes; return the text.
2305         """
2306         _api.check_isinstance(mtext.Text, txt=txt)
2307         self._set_artist_props(txt)
2308         self._children.append(txt)
2309         txt._remove_method = self._children.remove
2310         self.stale = True
2311         return txt
2312 
2313     def _update_line_limits(self, line):
2314         """
2315         Figures out the data limit of the given line, updating self.dataLim.
2316         """
2317         path = line.get_path()
2318         if path.vertices.size == 0:
2319             return
2320 
2321         line_trf = line.get_transform()
2322 
2323         if line_trf == self.transData:
2324             data_path = path
2325         elif any(line_trf.contains_branch_seperately(self.transData)):
2326             # Compute the transform from line coordinates to data coordinates.
2327             trf_to_data = line_trf - self.transData
2328             # If transData is affine we can use the cached non-affine component
2329             # of line's path (since the non-affine part of line_trf is
2330             # entirely encapsulated in trf_to_data).
2331             if self.transData.is_affine:
2332                 line_trans_path = line._get_transformed_path()
2333                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2334                 data_path = trf_to_data.transform_path_affine(na_path)
2335             else:
2336                 data_path = trf_to_data.transform_path(path)
2337         else:
2338             # For backwards compatibility we update the dataLim with the
2339             # coordinate range of the given path, even though the coordinate
2340             # systems are completely different. This may occur in situations
2341             # such as when ax.transAxes is passed through for absolute
2342             # positioning.
2343             data_path = path
2344 
2345         if not data_path.vertices.size:
2346             return
2347 
2348         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2349         if self.name != "rectilinear":
2350             # This block is mostly intended to handle axvline in polar plots,
2351             # for which updatey would otherwise be True.
2352             if updatex and line_trf == self.get_yaxis_transform():
2353                 updatex = False
2354             if updatey and line_trf == self.get_xaxis_transform():
2355                 updatey = False
2356         self.dataLim.update_from_path(data_path,
2357                                       self.ignore_existing_data_limits,
2358                                       updatex=updatex, updatey=updatey)
2359         self.ignore_existing_data_limits = False
2360 
2361     def add_patch(self, p):
2362         """
2363         Add a `.Patch` to the Axes; return the patch.
2364         """
2365         _api.check_isinstance(mpatches.Patch, p=p)
2366         self._set_artist_props(p)
2367         if p.get_clip_path() is None:
2368             p.set_clip_path(self.patch)
2369         self._update_patch_limits(p)
2370         self._children.append(p)
2371         p._remove_method = self._children.remove
2372         return p
2373 
2374     def _update_patch_limits(self, patch):
2375         """Update the data limits for the given patch."""
2376         # hist can add zero height Rectangles, which is useful to keep
2377         # the bins, counts and patches lined up, but it throws off log
2378         # scaling.  We'll ignore rects with zero height or width in
2379         # the auto-scaling
2380 
2381         # cannot check for '==0' since unitized data may not compare to zero
2382         # issue #2150 - we update the limits if patch has non zero width
2383         # or height.
2384         if (isinstance(patch, mpatches.Rectangle) and
2385                 ((not patch.get_width()) and (not patch.get_height()))):
2386             return
2387         p = patch.get_path()
2388         # Get all vertices on the path
2389         # Loop through each segment to get extrema for Bezier curve sections
2390         vertices = []
2391         for curve, code in p.iter_bezier(simplify=False):
2392             # Get distance along the curve of any extrema
2393             _, dzeros = curve.axis_aligned_extrema()
2394             # Calculate vertices of start, end and any extrema in between
2395             vertices.append(curve([0, *dzeros, 1]))
2396 
2397         if len(vertices):
2398             vertices = np.row_stack(vertices)
2399 
2400         patch_trf = patch.get_transform()
2401         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2402         if not (updatex or updatey):
2403             return
2404         if self.name != "rectilinear":
2405             # As in _update_line_limits, but for axvspan.
2406             if updatex and patch_trf == self.get_yaxis_transform():
2407                 updatex = False
2408             if updatey and patch_trf == self.get_xaxis_transform():
2409                 updatey = False
2410         trf_to_data = patch_trf - self.transData
2411         xys = trf_to_data.transform(vertices)
2412         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2413 
2414     def add_table(self, tab):
2415         """
2416         Add a `.Table` to the Axes; return the table.
2417         """
2418         _api.check_isinstance(mtable.Table, tab=tab)
2419         self._set_artist_props(tab)
2420         self._children.append(tab)
2421         if tab.get_clip_path() is None:
2422             tab.set_clip_path(self.patch)
2423         tab._remove_method = self._children.remove
2424         return tab
2425 
2426     def add_container(self, container):
2427         """
2428         Add a `.Container` to the Axes' containers; return the container.
2429         """
2430         label = container.get_label()
2431         if not label:
2432             container.set_label('_container%d' % len(self.containers))
2433         self.containers.append(container)
2434         container._remove_method = self.containers.remove
2435         return container
2436 
2437     def _unit_change_handler(self, axis_name, event=None):
2438         """
2439         Process axis units changes: requests updates to data and view limits.
2440         """
2441         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2442             return functools.partial(
2443                 self._unit_change_handler, axis_name, event=object())
2444         _api.check_in_list(self._axis_map, axis_name=axis_name)
2445         for line in self.lines:
2446             line.recache_always()
2447         self.relim()
2448         self._request_autoscale_view(axis_name)
2449 
2450     def relim(self, visible_only=False):
2451         """
2452         Recompute the data limits based on current artists.
2453 
2454         At present, `.Collection` instances are not supported.
2455 
2456         Parameters
2457         ----------
2458         visible_only : bool, default: False
2459             Whether to exclude invisible artists.
2460         """
2461         # Collections are deliberately not supported (yet); see
2462         # the TODO note in artists.py.
2463         self.dataLim.ignore(True)
2464         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2465         self.ignore_existing_data_limits = True
2466 
2467         for artist in self._children:
2468             if not visible_only or artist.get_visible():
2469                 if isinstance(artist, mlines.Line2D):
2470                     self._update_line_limits(artist)
2471                 elif isinstance(artist, mpatches.Patch):
2472                     self._update_patch_limits(artist)
2473                 elif isinstance(artist, mimage.AxesImage):
2474                     self._update_image_limits(artist)
2475 
2476     def update_datalim(self, xys, updatex=True, updatey=True):
2477         """
2478         Extend the `~.Axes.dataLim` Bbox to include the given points.
2479 
2480         If no data is set currently, the Bbox will ignore its limits and set
2481         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2482         compute the bounds of the union of its current data and the data in
2483         *xys*.
2484 
2485         Parameters
2486         ----------
2487         xys : 2D array-like
2488             The points to include in the data limits Bbox. This can be either
2489             a list of (x, y) tuples or a (N, 2) array.
2490 
2491         updatex, updatey : bool, default: True
2492             Whether to update the x/y limits.
2493         """
2494         xys = np.asarray(xys)
2495         if not np.any(np.isfinite(xys)):
2496             return
2497         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2498                                          updatex=updatex, updatey=updatey)
2499         self.ignore_existing_data_limits = False
2500 
2501     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2502         """
2503         Set axis units based on *datasets* and *kwargs*, and optionally apply
2504         unit conversions to *datasets*.
2505 
2506         Parameters
2507         ----------
2508         datasets : list
2509             List of (axis_name, dataset) pairs (where the axis name is defined
2510             as in `._axis_map`).  Individual datasets can also be None
2511             (which gets passed through).
2512         kwargs : dict
2513             Other parameters from which unit info (i.e., the *xunits*,
2514             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2515             polar) entries) is popped, if present.  Note that this dict is
2516             mutated in-place!
2517         convert : bool, default: True
2518             Whether to return the original datasets or the converted ones.
2519 
2520         Returns
2521         -------
2522         list
2523             Either the original datasets if *convert* is False, or the
2524             converted ones if *convert* is True (the default).
2525         """
2526         # The API makes datasets a list of pairs rather than an axis_name to
2527         # dataset mapping because it is sometimes necessary to process multiple
2528         # datasets for a single axis, and concatenating them may be tricky
2529         # (e.g. if some are scalars, etc.).
2530         datasets = datasets or []
2531         kwargs = kwargs or {}
2532         axis_map = self._axis_map
2533         for axis_name, data in datasets:
2534             try:
2535                 axis = axis_map[axis_name]
2536             except KeyError:
2537                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2538             # Update from data if axis is already set but no unit is set yet.
2539             if axis is not None and data is not None and not axis.have_units():
2540                 axis.update_units(data)
2541         for axis_name, axis in axis_map.items():
2542             # Return if no axis is set.
2543             if axis is None:
2544                 continue
2545             # Check for units in the kwargs, and if present update axis.
2546             units = kwargs.pop(f"{axis_name}units", axis.units)
2547             if self.name == "polar":
2548                 # Special case: polar supports "thetaunits"/"runits".
2549                 polar_units = {"x": "thetaunits", "y": "runits"}
2550                 units = kwargs.pop(polar_units[axis_name], units)
2551             if units != axis.units and units is not None:
2552                 axis.set_units(units)
2553                 # If the units being set imply a different converter,
2554                 # we need to update again.
2555                 for dataset_axis_name, data in datasets:
2556                     if dataset_axis_name == axis_name and data is not None:
2557                         axis.update_units(data)
2558         return [axis_map[axis_name].convert_units(data)
2559                 if convert and data is not None else data
2560                 for axis_name, data in datasets]
2561 
2562     def in_axes(self, mouseevent):
2563         """
2564         Return whether the given event (in display coords) is in the Axes.
2565         """
2566         return self.patch.contains(mouseevent)[0]
2567 
2568     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2569     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2570     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2571     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2572 
2573     def get_autoscale_on(self):
2574         """Return True if each axis is autoscaled, False otherwise."""
2575         return all(axis._get_autoscale_on()
2576                    for axis in self._axis_map.values())
2577 
2578     def set_autoscale_on(self, b):
2579         """
2580         Set whether autoscaling is applied to each axis on the next draw or
2581         call to `.Axes.autoscale_view`.
2582 
2583         Parameters
2584         ----------
2585         b : bool
2586         """
2587         for axis in self._axis_map.values():
2588             axis._set_autoscale_on(b)
2589 
2590     @property
2591     def use_sticky_edges(self):
2592         """
2593         When autoscaling, whether to obey all `Artist.sticky_edges`.
2594 
2595         Default is ``True``.
2596 
2597         Setting this to ``False`` ensures that the specified margins
2598         will be applied, even if the plot includes an image, for
2599         example, which would otherwise force a view limit to coincide
2600         with its data limit.
2601 
2602         The changing this property does not change the plot until
2603         `autoscale` or `autoscale_view` is called.
2604         """
2605         return self._use_sticky_edges
2606 
2607     @use_sticky_edges.setter
2608     def use_sticky_edges(self, b):
2609         self._use_sticky_edges = bool(b)
2610         # No effect until next autoscaling, which will mark the Axes as stale.
2611 
2612     def set_xmargin(self, m):
2613         """
2614         Set padding of X data limits prior to autoscaling.
2615 
2616         *m* times the data interval will be added to each end of that interval
2617         before it is used in autoscaling.  If *m* is negative, this will clip
2618         the data range instead of expanding it.
2619 
2620         For example, if your data is in the range [0, 2], a margin of 0.1 will
2621         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2622         of [0.2, 1.8].
2623 
2624         Parameters
2625         ----------
2626         m : float greater than -0.5
2627         """
2628         if m <= -0.5:
2629             raise ValueError("margin must be greater than -0.5")
2630         self._xmargin = m
2631         self._request_autoscale_view("x")
2632         self.stale = True
2633 
2634     def set_ymargin(self, m):
2635         """
2636         Set padding of Y data limits prior to autoscaling.
2637 
2638         *m* times the data interval will be added to each end of that interval
2639         before it is used in autoscaling.  If *m* is negative, this will clip
2640         the data range instead of expanding it.
2641 
2642         For example, if your data is in the range [0, 2], a margin of 0.1 will
2643         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2644         of [0.2, 1.8].
2645 
2646         Parameters
2647         ----------
2648         m : float greater than -0.5
2649         """
2650         if m <= -0.5:
2651             raise ValueError("margin must be greater than -0.5")
2652         self._ymargin = m
2653         self._request_autoscale_view("y")
2654         self.stale = True
2655 
2656     def margins(self, *margins, x=None, y=None, tight=True):
2657         """
2658         Set or retrieve autoscaling margins.
2659 
2660         The padding added to each limit of the Axes is the *margin*
2661         times the data interval. All input parameters must be floats
2662         greater than -0.5. Passing both positional and keyword
2663         arguments is invalid and will raise a TypeError. If no
2664         arguments (positional or otherwise) are provided, the current
2665         margins will remain unchanged and simply be returned.
2666 
2667         Specifying any margin changes only the autoscaling; for example,
2668         if *xmargin* is not None, then *xmargin* times the X data
2669         interval will be added to each end of that interval before
2670         it is used in autoscaling.
2671 
2672         Parameters
2673         ----------
2674         *margins : float, optional
2675             If a single positional argument is provided, it specifies
2676             both margins of the x-axis and y-axis limits. If two
2677             positional arguments are provided, they will be interpreted
2678             as *xmargin*, *ymargin*. If setting the margin on a single
2679             axis is desired, use the keyword arguments described below.
2680 
2681         x, y : float, optional
2682             Specific margin values for the x-axis and y-axis,
2683             respectively. These cannot be used with positional
2684             arguments, but can be used individually to alter on e.g.,
2685             only the y-axis.
2686 
2687         tight : bool or None, default: True
2688             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2689             which is executed after a margin is changed; the default
2690             here is *True*, on the assumption that when margins are
2691             specified, no additional padding to match tick marks is
2692             usually desired.  Setting *tight* to *None* preserves
2693             the previous setting.
2694 
2695         Returns
2696         -------
2697         xmargin, ymargin : float
2698 
2699         Notes
2700         -----
2701         If a previously used Axes method such as :meth:`pcolor` has set
2702         :attr:`use_sticky_edges` to `True`, only the limits not set by
2703         the "sticky artists" will be modified. To force all of the
2704         margins to be set, set :attr:`use_sticky_edges` to `False`
2705         before calling :meth:`margins`.
2706         """
2707 
2708         if margins and (x is not None or y is not None):
2709             raise TypeError('Cannot pass both positional and keyword '
2710                             'arguments for x and/or y.')
2711         elif len(margins) == 1:
2712             x = y = margins[0]
2713         elif len(margins) == 2:
2714             x, y = margins
2715         elif margins:
2716             raise TypeError('Must pass a single positional argument for all '
2717                             'margins, or one for each margin (x, y).')
2718 
2719         if x is None and y is None:
2720             if tight is not True:
2721                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2722             return self._xmargin, self._ymargin
2723 
2724         if tight is not None:
2725             self._tight = tight
2726         if x is not None:
2727             self.set_xmargin(x)
2728         if y is not None:
2729             self.set_ymargin(y)
2730 
2731     def set_rasterization_zorder(self, z):
2732         """
2733         Set the zorder threshold for rasterization for vector graphics output.
2734 
2735         All artists with a zorder below the given value will be rasterized if
2736         they support rasterization.
2737 
2738         This setting is ignored for pixel-based output.
2739 
2740         See also :doc:`/gallery/misc/rasterization_demo`.
2741 
2742         Parameters
2743         ----------
2744         z : float or None
2745             The zorder below which artists are rasterized.
2746             If ``None`` rasterization based on zorder is deactivated.
2747         """
2748         self._rasterization_zorder = z
2749         self.stale = True
2750 
2751     def get_rasterization_zorder(self):
2752         """Return the zorder value below which artists will be rasterized."""
2753         return self._rasterization_zorder
2754 
2755     def autoscale(self, enable=True, axis='both', tight=None):
2756         """
2757         Autoscale the axis view to the data (toggle).
2758 
2759         Convenience method for simple axis view autoscaling.
2760         It turns autoscaling on or off, and then,
2761         if autoscaling for either axis is on, it performs
2762         the autoscaling on the specified axis or Axes.
2763 
2764         Parameters
2765         ----------
2766         enable : bool or None, default: True
2767             True turns autoscaling on, False turns it off.
2768             None leaves the autoscaling state unchanged.
2769         axis : {'both', 'x', 'y'}, default: 'both'
2770             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2771             to 'z', and 'both' refers to all three axes.)
2772         tight : bool or None, default: None
2773             If True, first set the margins to zero.  Then, this argument is
2774             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2775             its value); see the description of its behavior there.
2776         """
2777         if enable is None:
2778             scalex = True
2779             scaley = True
2780         else:
2781             if axis in ['x', 'both']:
2782                 self.set_autoscalex_on(bool(enable))
2783                 scalex = self.get_autoscalex_on()
2784             else:
2785                 scalex = False
2786             if axis in ['y', 'both']:
2787                 self.set_autoscaley_on(bool(enable))
2788                 scaley = self.get_autoscaley_on()
2789             else:
2790                 scaley = False
2791         if tight and scalex:
2792             self._xmargin = 0
2793         if tight and scaley:
2794             self._ymargin = 0
2795         if scalex:
2796             self._request_autoscale_view("x", tight=tight)
2797         if scaley:
2798             self._request_autoscale_view("y", tight=tight)
2799 
2800     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2801         """
2802         Autoscale the view limits using the data limits.
2803 
2804         Parameters
2805         ----------
2806         tight : bool or None
2807             If *True*, only expand the axis limits using the margins.  Note
2808             that unlike for `autoscale`, ``tight=True`` does *not* set the
2809             margins to zero.
2810 
2811             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2812             after expansion by the margins, further expand the axis limits
2813             using the axis major locator.
2814 
2815             If None (the default), reuse the value set in the previous call to
2816             `autoscale_view` (the initial value is False, but the default style
2817             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2818             behaves like True).
2819 
2820         scalex : bool, default: True
2821             Whether to autoscale the x-axis.
2822 
2823         scaley : bool, default: True
2824             Whether to autoscale the y-axis.
2825 
2826         Notes
2827         -----
2828         The autoscaling preserves any preexisting axis direction reversal.
2829 
2830         The data limits are not updated automatically when artist data are
2831         changed after the artist has been added to an Axes instance.  In that
2832         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2833         autoscale_view.
2834 
2835         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2836         not be changed by autoscale_view().
2837         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2838         """
2839         if tight is not None:
2840             self._tight = bool(tight)
2841 
2842         x_stickies = y_stickies = np.array([])
2843         if self.use_sticky_edges:
2844             if self._xmargin and scalex and self.get_autoscalex_on():
2845                 x_stickies = np.sort(np.concatenate([
2846                     artist.sticky_edges.x
2847                     for ax in self._shared_axes["x"].get_siblings(self)
2848                     for artist in ax.get_children()]))
2849             if self._ymargin and scaley and self.get_autoscaley_on():
2850                 y_stickies = np.sort(np.concatenate([
2851                     artist.sticky_edges.y
2852                     for ax in self._shared_axes["y"].get_siblings(self)
2853                     for artist in ax.get_children()]))
2854         if self.get_xscale() == 'log':
2855             x_stickies = x_stickies[x_stickies > 0]
2856         if self.get_yscale() == 'log':
2857             y_stickies = y_stickies[y_stickies > 0]
2858 
2859         def handle_single_axis(
2860                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2861 
2862             if not (scale and axis._get_autoscale_on()):
2863                 return  # nothing to do...
2864 
2865             shared = shared_axes.get_siblings(self)
2866             # Base autoscaling on finite data limits when there is at least one
2867             # finite data limit among all the shared_axes and intervals.
2868             values = [val for ax in shared
2869                       for val in getattr(ax.dataLim, f"interval{name}")
2870                       if np.isfinite(val)]
2871             if values:
2872                 x0, x1 = (min(values), max(values))
2873             elif getattr(self._viewLim, f"mutated{name}")():
2874                 # No data, but explicit viewLims already set:
2875                 # in mutatedx or mutatedy.
2876                 return
2877             else:
2878                 x0, x1 = (-np.inf, np.inf)
2879             # If x0 and x1 are nonfinite, get default limits from the locator.
2880             locator = axis.get_major_locator()
2881             x0, x1 = locator.nonsingular(x0, x1)
2882             # Find the minimum minpos for use in the margin calculation.
2883             minimum_minpos = min(
2884                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2885 
2886             # Prevent margin addition from crossing a sticky value.  A small
2887             # tolerance must be added due to floating point issues with
2888             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2889             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2890             # datasets where all values are tiny (less than 1e-8).
2891             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2892             # Index of largest element < x0 + tol, if any.
2893             i0 = stickies.searchsorted(x0 + tol) - 1
2894             x0bound = stickies[i0] if i0 != -1 else None
2895             # Index of smallest element > x1 - tol, if any.
2896             i1 = stickies.searchsorted(x1 - tol)
2897             x1bound = stickies[i1] if i1 != len(stickies) else None
2898 
2899             # Add the margin in figure space and then transform back, to handle
2900             # non-linear scales.
2901             transform = axis.get_transform()
2902             inverse_trans = transform.inverted()
2903             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2904             x0t, x1t = transform.transform([x0, x1])
2905             delta = (x1t - x0t) * margin
2906             if not np.isfinite(delta):
2907                 delta = 0  # If a bound isn't finite, set margin to zero.
2908             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2909 
2910             # Apply sticky bounds.
2911             if x0bound is not None:
2912                 x0 = max(x0, x0bound)
2913             if x1bound is not None:
2914                 x1 = min(x1, x1bound)
2915 
2916             if not self._tight:
2917                 x0, x1 = locator.view_limits(x0, x1)
2918             set_bound(x0, x1)
2919             # End of definition of internal function 'handle_single_axis'.
2920 
2921         handle_single_axis(
2922             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2923             x_stickies, self.set_xbound)
2924         handle_single_axis(
2925             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2926             y_stickies, self.set_ybound)
2927 
2928     def _update_title_position(self, renderer):
2929         """
2930         Update the title position based on the bounding box enclosing
2931         all the ticklabels and x-axis spine and xlabel...
2932         """
2933         if self._autotitlepos is not None and not self._autotitlepos:
2934             _log.debug('title position was updated manually, not adjusting')
2935             return
2936 
2937         titles = (self.title, self._left_title, self._right_title)
2938 
2939         # Need to check all our twins too, and all the children as well.
2940         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2941         for ax in self.child_axes:  # Child positions must be updated first.
2942             locator = ax.get_axes_locator()
2943             ax.apply_aspect(locator(self, renderer) if locator else None)
2944 
2945         for title in titles:
2946             x, _ = title.get_position()
2947             # need to start again in case of window resizing
2948             title.set_position((x, 1.0))
2949             top = -np.inf
2950             for ax in axs:
2951                 bb = None
2952                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2953                         or ax.xaxis.get_label_position() == 'top'):
2954                     bb = ax.xaxis.get_tightbbox(renderer)
2955                 if bb is None:
2956                     if 'outline' in ax.spines:
2957                         # Special case for colorbars:
2958                         bb = ax.spines['outline'].get_window_extent()
2959                     else:
2960                         bb = ax.get_window_extent(renderer)
2961                 top = max(top, bb.ymax)
2962                 if title.get_text():
2963                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2964                     if ax.yaxis.offsetText.get_text():
2965                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2966                         if bb.intersection(title.get_tightbbox(renderer), bb):
2967                             top = bb.ymax
2968             if top < 0:
2969                 # the top of Axes is not even on the figure, so don't try and
2970                 # automatically place it.
2971                 _log.debug('top of Axes not in the figure, so title not moved')
2972                 return
2973             if title.get_window_extent(renderer).ymin < top:
2974                 _, y = self.transAxes.inverted().transform((0, top))
2975                 title.set_position((x, y))
2976                 # empirically, this doesn't always get the min to top,
2977                 # so we need to adjust again.
2978                 if title.get_window_extent(renderer).ymin < top:
2979                     _, y = self.transAxes.inverted().transform(
2980                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2981                     title.set_position((x, y))
2982 
2983         ymax = max(title.get_position()[1] for title in titles)
2984         for title in titles:
2985             # now line up all the titles at the highest baseline.
2986             x, _ = title.get_position()
2987             title.set_position((x, ymax))
2988 
2989     # Drawing
2990     @martist.allow_rasterization
2991     def draw(self, renderer):
2992         # docstring inherited
2993         if renderer is None:
2994             raise RuntimeError('No renderer defined')
2995         if not self.get_visible():
2996             return
2997         self._unstale_viewLim()
2998 
2999         renderer.open_group('axes', gid=self.get_gid())
3000 
3001         # prevent triggering call backs during the draw process
3002         self._stale = True
3003 
3004         # loop over self and child Axes...
3005         locator = self.get_axes_locator()
3006         self.apply_aspect(locator(self, renderer) if locator else None)
3007 
3008         artists = self.get_children()
3009         artists.remove(self.patch)
3010 
3011         # the frame draws the edges around the Axes patch -- we
3012         # decouple these so the patch can be in the background and the
3013         # frame in the foreground. Do this before drawing the axis
3014         # objects so that the spine has the opportunity to update them.
3015         if not (self.axison and self._frameon):
3016             for spine in self.spines.values():
3017                 artists.remove(spine)
3018 
3019         self._update_title_position(renderer)
3020 
3021         if not self.axison:
3022             for _axis in self._axis_map.values():
3023                 artists.remove(_axis)
3024 
3025         if not self.figure.canvas.is_saving():
3026             artists = [
3027                 a for a in artists
3028                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3029         artists = sorted(artists, key=attrgetter('zorder'))
3030 
3031         # rasterize artists with negative zorder
3032         # if the minimum zorder is negative, start rasterization
3033         rasterization_zorder = self._rasterization_zorder
3034 
3035         if (rasterization_zorder is not None and
3036                 artists and artists[0].zorder < rasterization_zorder):
3037             split_index = np.searchsorted(
3038                 [art.zorder for art in artists],
3039                 rasterization_zorder, side='right'
3040             )
3041             artists_rasterized = artists[:split_index]
3042             artists = artists[split_index:]
3043         else:
3044             artists_rasterized = []
3045 
3046         if self.axison and self._frameon:
3047             if artists_rasterized:
3048                 artists_rasterized = [self.patch] + artists_rasterized
3049             else:
3050                 artists = [self.patch] + artists
3051 
3052         if artists_rasterized:
3053             _draw_rasterized(self.figure, artists_rasterized, renderer)
3054 
3055         mimage._draw_list_compositing_images(
3056             renderer, self, artists, self.figure.suppressComposite)
3057 
3058         renderer.close_group('axes')
3059         self.stale = False
3060 
3061     def draw_artist(self, a):
3062         """
3063         Efficiently redraw a single artist.
3064         """
3065         a.draw(self.figure.canvas.get_renderer())
3066 
3067     def redraw_in_frame(self):
3068         """
3069         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3070         """
3071         with ExitStack() as stack:
3072             for artist in [*self._axis_map.values(),
3073                            self.title, self._left_title, self._right_title]:
3074                 stack.enter_context(artist._cm_set(visible=False))
3075             self.draw(self.figure.canvas.get_renderer())
3076 
3077     # Axes rectangle characteristics
3078 
3079     def get_frame_on(self):
3080         """Get whether the Axes rectangle patch is drawn."""
3081         return self._frameon
3082 
3083     def set_frame_on(self, b):
3084         """
3085         Set whether the Axes rectangle patch is drawn.
3086 
3087         Parameters
3088         ----------
3089         b : bool
3090         """
3091         self._frameon = b
3092         self.stale = True
3093 
3094     def get_axisbelow(self):
3095         """
3096         Get whether axis ticks and gridlines are above or below most artists.
3097 
3098         Returns
3099         -------
3100         bool or 'line'
3101 
3102         See Also
3103         --------
3104         set_axisbelow
3105         """
3106         return self._axisbelow
3107 
3108     def set_axisbelow(self, b):
3109         """
3110         Set whether axis ticks and gridlines are above or below most artists.
3111 
3112         This controls the zorder of the ticks and gridlines. For more
3113         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3114 
3115         Parameters
3116         ----------
3117         b : bool or 'line'
3118             Possible values:
3119 
3120             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3121             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3122               (e.g. rectangles, with default zorder = 1) but still below lines
3123               and markers (with their default zorder = 2).
3124             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3125               and lines / markers.
3126 
3127         See Also
3128         --------
3129         get_axisbelow
3130         """
3131         # Check that b is True, False or 'line'
3132         self._axisbelow = axisbelow = validate_axisbelow(b)
3133         zorder = {
3134             True: 0.5,
3135             'line': 1.5,
3136             False: 2.5,
3137         }[axisbelow]
3138         for axis in self._axis_map.values():
3139             axis.set_zorder(zorder)
3140         self.stale = True
3141 
3142     @_docstring.dedent_interpd
3143     def grid(self, visible=None, which='major', axis='both', **kwargs):
3144         """
3145         Configure the grid lines.
3146 
3147         Parameters
3148         ----------
3149         visible : bool or None, optional
3150             Whether to show the grid lines.  If any *kwargs* are supplied, it
3151             is assumed you want the grid on and *visible* will be set to True.
3152 
3153             If *visible* is *None* and there are no *kwargs*, this toggles the
3154             visibility of the lines.
3155 
3156         which : {'major', 'minor', 'both'}, optional
3157             The grid lines to apply the changes on.
3158 
3159         axis : {'both', 'x', 'y'}, optional
3160             The axis to apply the changes on.
3161 
3162         **kwargs : `~matplotlib.lines.Line2D` properties
3163             Define the line properties of the grid, e.g.::
3164 
3165                 grid(color='r', linestyle='-', linewidth=2)
3166 
3167             Valid keyword arguments are:
3168 
3169             %(Line2D:kwdoc)s
3170 
3171         Notes
3172         -----
3173         The axis is drawn as a unit, so the effective zorder for drawing the
3174         grid is determined by the zorder of each axis, not by the zorder of the
3175         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3176         use `.set_axisbelow` or, for more control, call the
3177         `~.Artist.set_zorder` method of each axis.
3178         """
3179         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3180         if axis in ['x', 'both']:
3181             self.xaxis.grid(visible, which=which, **kwargs)
3182         if axis in ['y', 'both']:
3183             self.yaxis.grid(visible, which=which, **kwargs)
3184 
3185     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3186                          useOffset=None, useLocale=None, useMathText=None):
3187         r"""
3188         Configure the `.ScalarFormatter` used by default for linear Axes.
3189 
3190         If a parameter is not set, the corresponding property of the formatter
3191         is left unchanged.
3192 
3193         Parameters
3194         ----------
3195         axis : {'x', 'y', 'both'}, default: 'both'
3196             The axis to configure.  Only major ticks are affected.
3197 
3198         style : {'sci', 'scientific', 'plain'}
3199             Whether to use scientific notation.
3200             The formatter default is to use scientific notation.
3201 
3202         scilimits : pair of ints (m, n)
3203             Scientific notation is used only for numbers outside the range
3204             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3205             configured to use scientific notation at all).  Use (0, 0) to
3206             include all numbers.  Use (m, m) where m != 0 to fix the order of
3207             magnitude to 10\ :sup:`m`.
3208             The formatter default is :rc:`axes.formatter.limits`.
3209 
3210         useOffset : bool or float
3211             If True, the offset is calculated as needed.
3212             If False, no offset is used.
3213             If a numeric value, it sets the offset.
3214             The formatter default is :rc:`axes.formatter.useoffset`.
3215 
3216         useLocale : bool
3217             Whether to format the number using the current locale or using the
3218             C (English) locale.  This affects e.g. the decimal separator.  The
3219             formatter default is :rc:`axes.formatter.use_locale`.
3220 
3221         useMathText : bool
3222             Render the offset and scientific notation in mathtext.
3223             The formatter default is :rc:`axes.formatter.use_mathtext`.
3224 
3225         Raises
3226         ------
3227         AttributeError
3228             If the current formatter is not a `.ScalarFormatter`.
3229         """
3230         style = style.lower()
3231         axis = axis.lower()
3232         if scilimits is not None:
3233             try:
3234                 m, n = scilimits
3235                 m + n + 1  # check that both are numbers
3236             except (ValueError, TypeError) as err:
3237                 raise ValueError("scilimits must be a sequence of 2 integers"
3238                                  ) from err
3239         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3240         is_sci_style = _api.check_getitem(STYLES, style=style)
3241         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3242                     'both': list(self._axis_map.values())}
3243         axises = _api.check_getitem(axis_map, axis=axis)
3244         try:
3245             for axis in axises:
3246                 if is_sci_style is not None:
3247                     axis.major.formatter.set_scientific(is_sci_style)
3248                 if scilimits is not None:
3249                     axis.major.formatter.set_powerlimits(scilimits)
3250                 if useOffset is not None:
3251                     axis.major.formatter.set_useOffset(useOffset)
3252                 if useLocale is not None:
3253                     axis.major.formatter.set_useLocale(useLocale)
3254                 if useMathText is not None:
3255                     axis.major.formatter.set_useMathText(useMathText)
3256         except AttributeError as err:
3257             raise AttributeError(
3258                 "This method only works with the ScalarFormatter") from err
3259 
3260     def locator_params(self, axis='both', tight=None, **kwargs):
3261         """
3262         Control behavior of major tick locators.
3263 
3264         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3265         is called automatically after the parameters are changed.
3266 
3267         Parameters
3268         ----------
3269         axis : {'both', 'x', 'y'}, default: 'both'
3270             The axis on which to operate.  (For 3D Axes, *axis* can also be
3271             set to 'z', and 'both' refers to all three axes.)
3272         tight : bool or None, optional
3273             Parameter passed to `~.Axes.autoscale_view`.
3274             Default is None, for no change.
3275 
3276         Other Parameters
3277         ----------------
3278         **kwargs
3279             Remaining keyword arguments are passed to directly to the
3280             ``set_params()`` method of the locator. Supported keywords depend
3281             on the type of the locator. See for example
3282             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3283             used by default for linear.
3284 
3285         Examples
3286         --------
3287         When plotting small subplots, one might want to reduce the maximum
3288         number of ticks and use tight bounds, for example::
3289 
3290             ax.locator_params(tight=True, nbins=4)
3291 
3292         """
3293         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3294         for name in self._axis_names:
3295             if axis in [name, "both"]:
3296                 loc = self._axis_map[name].get_major_locator()
3297                 loc.set_params(**kwargs)
3298                 self._request_autoscale_view(name, tight=tight)
3299         self.stale = True
3300 
3301     def tick_params(self, axis='both', **kwargs):
3302         """
3303         Change the appearance of ticks, tick labels, and gridlines.
3304 
3305         Tick properties that are not explicitly set using the keyword
3306         arguments remain unchanged unless *reset* is True. For the current
3307         style settings, see `.Axis.get_tick_params`.
3308 
3309         Parameters
3310         ----------
3311         axis : {'x', 'y', 'both'}, default: 'both'
3312             The axis to which the parameters are applied.
3313         which : {'major', 'minor', 'both'}, default: 'major'
3314             The group of ticks to which the parameters are applied.
3315         reset : bool, default: False
3316             Whether to reset the ticks to defaults before updating them.
3317 
3318         Other Parameters
3319         ----------------
3320         direction : {'in', 'out', 'inout'}
3321             Puts ticks inside the Axes, outside the Axes, or both.
3322         length : float
3323             Tick length in points.
3324         width : float
3325             Tick width in points.
3326         color : color
3327             Tick color.
3328         pad : float
3329             Distance in points between tick and label.
3330         labelsize : float or str
3331             Tick label font size in points or as a string (e.g., 'large').
3332         labelcolor : color
3333             Tick label color.
3334         labelfontfamily : str
3335             Tick label font.
3336         colors : color
3337             Tick color and label color.
3338         zorder : float
3339             Tick and label zorder.
3340         bottom, top, left, right : bool
3341             Whether to draw the respective ticks.
3342         labelbottom, labeltop, labelleft, labelright : bool
3343             Whether to draw the respective tick labels.
3344         labelrotation : float
3345             Tick label rotation
3346         grid_color : color
3347             Gridline color.
3348         grid_alpha : float
3349             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3350         grid_linewidth : float
3351             Width of gridlines in points.
3352         grid_linestyle : str
3353             Any valid `.Line2D` line style spec.
3354 
3355         Examples
3356         --------
3357         ::
3358 
3359             ax.tick_params(direction='out', length=6, width=2, colors='r',
3360                            grid_color='r', grid_alpha=0.5)
3361 
3362         This will make all major ticks be red, pointing out of the box,
3363         and with dimensions 6 points by 2 points.  Tick labels will
3364         also be red.  Gridlines will be red and translucent.
3365 
3366         """
3367         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3368         if axis in ['x', 'both']:
3369             xkw = dict(kwargs)
3370             xkw.pop('left', None)
3371             xkw.pop('right', None)
3372             xkw.pop('labelleft', None)
3373             xkw.pop('labelright', None)
3374             self.xaxis.set_tick_params(**xkw)
3375         if axis in ['y', 'both']:
3376             ykw = dict(kwargs)
3377             ykw.pop('top', None)
3378             ykw.pop('bottom', None)
3379             ykw.pop('labeltop', None)
3380             ykw.pop('labelbottom', None)
3381             self.yaxis.set_tick_params(**ykw)
3382 
3383     def set_axis_off(self):
3384         """
3385         Turn the x- and y-axis off.
3386 
3387         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3388         """
3389         self.axison = False
3390         self.stale = True
3391 
3392     def set_axis_on(self):
3393         """
3394         Turn the x- and y-axis on.
3395 
3396         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3397         """
3398         self.axison = True
3399         self.stale = True
3400 
3401     # data limits, ticks, tick labels, and formatting
3402 
3403     def get_xlabel(self):
3404         """
3405         Get the xlabel text string.
3406         """
3407         label = self.xaxis.get_label()
3408         return label.get_text()
3409 
3410     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3411                    loc=None, **kwargs):
3412         """
3413         Set the label for the x-axis.
3414 
3415         Parameters
3416         ----------
3417         xlabel : str
3418             The label text.
3419 
3420         labelpad : float, default: :rc:`axes.labelpad`
3421             Spacing in points from the Axes bounding box including ticks
3422             and tick labels.  If None, the previous value is left as is.
3423 
3424         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3425             The label position. This is a high-level alternative for passing
3426             parameters *x* and *horizontalalignment*.
3427 
3428         Other Parameters
3429         ----------------
3430         **kwargs : `~matplotlib.text.Text` properties
3431             `.Text` properties control the appearance of the label.
3432 
3433         See Also
3434         --------
3435         text : Documents the properties supported by `.Text`.
3436         """
3437         if labelpad is not None:
3438             self.xaxis.labelpad = labelpad
3439         protected_kw = ['x', 'horizontalalignment', 'ha']
3440         if {*kwargs} & {*protected_kw}:
3441             if loc is not None:
3442                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3443                                 f"its corresponding low level keyword "
3444                                 f"arguments ({protected_kw}) are also "
3445                                 f"supplied")
3446 
3447         else:
3448             loc = (loc if loc is not None
3449                    else mpl.rcParams['xaxis.labellocation'])
3450             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3451 
3452             x = {
3453                 'left': 0,
3454                 'center': 0.5,
3455                 'right': 1,
3456             }[loc]
3457             kwargs.update(x=x, horizontalalignment=loc)
3458 
3459         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3460 
3461     def invert_xaxis(self):
3462         """
3463         Invert the x-axis.
3464 
3465         See Also
3466         --------
3467         xaxis_inverted
3468         get_xlim, set_xlim
3469         get_xbound, set_xbound
3470         """
3471         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3472 
3473     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3474 
3475     def get_xbound(self):
3476         """
3477         Return the lower and upper x-axis bounds, in increasing order.
3478 
3479         See Also
3480         --------
3481         set_xbound
3482         get_xlim, set_xlim
3483         invert_xaxis, xaxis_inverted
3484         """
3485         left, right = self.get_xlim()
3486         if left < right:
3487             return left, right
3488         else:
3489             return right, left
3490 
3491     def set_xbound(self, lower=None, upper=None):
3492         """
3493         Set the lower and upper numerical bounds of the x-axis.
3494 
3495         This method will honor axis inversion regardless of parameter order.
3496         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3497 
3498         Parameters
3499         ----------
3500         lower, upper : float or None
3501             The lower and upper bounds. If *None*, the respective axis bound
3502             is not modified.
3503 
3504         See Also
3505         --------
3506         get_xbound
3507         get_xlim, set_xlim
3508         invert_xaxis, xaxis_inverted
3509         """
3510         if upper is None and np.iterable(lower):
3511             lower, upper = lower
3512 
3513         old_lower, old_upper = self.get_xbound()
3514         if lower is None:
3515             lower = old_lower
3516         if upper is None:
3517             upper = old_upper
3518 
3519         self.set_xlim(sorted((lower, upper),
3520                              reverse=bool(self.xaxis_inverted())),
3521                       auto=None)
3522 
3523     def get_xlim(self):
3524         """
3525         Return the x-axis view limits.
3526 
3527         Returns
3528         -------
3529         left, right : (float, float)
3530             The current x-axis limits in data coordinates.
3531 
3532         See Also
3533         --------
3534         .Axes.set_xlim
3535         set_xbound, get_xbound
3536         invert_xaxis, xaxis_inverted
3537 
3538         Notes
3539         -----
3540         The x-axis may be inverted, in which case the *left* value will
3541         be greater than the *right* value.
3542         """
3543         return tuple(self.viewLim.intervalx)
3544 
3545     def _validate_converted_limits(self, limit, convert):
3546         """
3547         Raise ValueError if converted limits are non-finite.
3548 
3549         Note that this function also accepts None as a limit argument.
3550 
3551         Returns
3552         -------
3553         The limit value after call to convert(), or None if limit is None.
3554         """
3555         if limit is not None:
3556             converted_limit = convert(limit)
3557             if (isinstance(converted_limit, Real)
3558                     and not np.isfinite(converted_limit)):
3559                 raise ValueError("Axis limits cannot be NaN or Inf")
3560             return converted_limit
3561 
3562     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3563                  xmin=None, xmax=None):
3564         """
3565         Set the x-axis view limits.
3566 
3567         Parameters
3568         ----------
3569         left : float, optional
3570             The left xlim in data coordinates. Passing *None* leaves the
3571             limit unchanged.
3572 
3573             The left and right xlims may also be passed as the tuple
3574             (*left*, *right*) as the first positional argument (or as
3575             the *left* keyword argument).
3576 
3577             .. ACCEPTS: (bottom: float, top: float)
3578 
3579         right : float, optional
3580             The right xlim in data coordinates. Passing *None* leaves the
3581             limit unchanged.
3582 
3583         emit : bool, default: True
3584             Whether to notify observers of limit change.
3585 
3586         auto : bool or None, default: False
3587             Whether to turn on autoscaling of the x-axis. True turns on,
3588             False turns off, None leaves unchanged.
3589 
3590         xmin, xmax : float, optional
3591             They are equivalent to left and right respectively, and it is an
3592             error to pass both *xmin* and *left* or *xmax* and *right*.
3593 
3594         Returns
3595         -------
3596         left, right : (float, float)
3597             The new x-axis limits in data coordinates.
3598 
3599         See Also
3600         --------
3601         get_xlim
3602         set_xbound, get_xbound
3603         invert_xaxis, xaxis_inverted
3604 
3605         Notes
3606         -----
3607         The *left* value may be greater than the *right* value, in which
3608         case the x-axis values will decrease from left to right.
3609 
3610         Examples
3611         --------
3612         >>> set_xlim(left, right)
3613         >>> set_xlim((left, right))
3614         >>> left, right = set_xlim(left, right)
3615 
3616         One limit may be left unchanged.
3617 
3618         >>> set_xlim(right=right_lim)
3619 
3620         Limits may be passed in reverse order to flip the direction of
3621         the x-axis. For example, suppose *x* represents the number of
3622         years before present. The x-axis limits might be set like the
3623         following so 5000 years ago is on the left of the plot and the
3624         present is on the right.
3625 
3626         >>> set_xlim(5000, 0)
3627         """
3628         if right is None and np.iterable(left):
3629             left, right = left
3630         if xmin is not None:
3631             if left is not None:
3632                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3633             left = xmin
3634         if xmax is not None:
3635             if right is not None:
3636                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3637             right = xmax
3638         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3639 
3640     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3641     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3642     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3643     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3644     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3645     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3646     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3647     set_xticklabels = _axis_method_wrapper(
3648         "xaxis", "set_ticklabels",
3649         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3650 
3651     def get_ylabel(self):
3652         """
3653         Get the ylabel text string.
3654         """
3655         label = self.yaxis.get_label()
3656         return label.get_text()
3657 
3658     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3659                    loc=None, **kwargs):
3660         """
3661         Set the label for the y-axis.
3662 
3663         Parameters
3664         ----------
3665         ylabel : str
3666             The label text.
3667 
3668         labelpad : float, default: :rc:`axes.labelpad`
3669             Spacing in points from the Axes bounding box including ticks
3670             and tick labels.  If None, the previous value is left as is.
3671 
3672         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3673             The label position. This is a high-level alternative for passing
3674             parameters *y* and *horizontalalignment*.
3675 
3676         Other Parameters
3677         ----------------
3678         **kwargs : `~matplotlib.text.Text` properties
3679             `.Text` properties control the appearance of the label.
3680 
3681         See Also
3682         --------
3683         text : Documents the properties supported by `.Text`.
3684         """
3685         if labelpad is not None:
3686             self.yaxis.labelpad = labelpad
3687         protected_kw = ['y', 'horizontalalignment', 'ha']
3688         if {*kwargs} & {*protected_kw}:
3689             if loc is not None:
3690                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3691                                 f"its corresponding low level keyword "
3692                                 f"arguments ({protected_kw}) are also "
3693                                 f"supplied")
3694 
3695         else:
3696             loc = (loc if loc is not None
3697                    else mpl.rcParams['yaxis.labellocation'])
3698             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3699 
3700             y, ha = {
3701                 'bottom': (0, 'left'),
3702                 'center': (0.5, 'center'),
3703                 'top': (1, 'right')
3704             }[loc]
3705             kwargs.update(y=y, horizontalalignment=ha)
3706 
3707         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3708 
3709     def invert_yaxis(self):
3710         """
3711         Invert the y-axis.
3712 
3713         See Also
3714         --------
3715         yaxis_inverted
3716         get_ylim, set_ylim
3717         get_ybound, set_ybound
3718         """
3719         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3720 
3721     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3722 
3723     def get_ybound(self):
3724         """
3725         Return the lower and upper y-axis bounds, in increasing order.
3726 
3727         See Also
3728         --------
3729         set_ybound
3730         get_ylim, set_ylim
3731         invert_yaxis, yaxis_inverted
3732         """
3733         bottom, top = self.get_ylim()
3734         if bottom < top:
3735             return bottom, top
3736         else:
3737             return top, bottom
3738 
3739     def set_ybound(self, lower=None, upper=None):
3740         """
3741         Set the lower and upper numerical bounds of the y-axis.
3742 
3743         This method will honor axis inversion regardless of parameter order.
3744         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3745 
3746         Parameters
3747         ----------
3748         lower, upper : float or None
3749             The lower and upper bounds. If *None*, the respective axis bound
3750             is not modified.
3751 
3752         See Also
3753         --------
3754         get_ybound
3755         get_ylim, set_ylim
3756         invert_yaxis, yaxis_inverted
3757         """
3758         if upper is None and np.iterable(lower):
3759             lower, upper = lower
3760 
3761         old_lower, old_upper = self.get_ybound()
3762         if lower is None:
3763             lower = old_lower
3764         if upper is None:
3765             upper = old_upper
3766 
3767         self.set_ylim(sorted((lower, upper),
3768                              reverse=bool(self.yaxis_inverted())),
3769                       auto=None)
3770 
3771     def get_ylim(self):
3772         """
3773         Return the y-axis view limits.
3774 
3775         Returns
3776         -------
3777         bottom, top : (float, float)
3778             The current y-axis limits in data coordinates.
3779 
3780         See Also
3781         --------
3782         .Axes.set_ylim
3783         set_ybound, get_ybound
3784         invert_yaxis, yaxis_inverted
3785 
3786         Notes
3787         -----
3788         The y-axis may be inverted, in which case the *bottom* value
3789         will be greater than the *top* value.
3790         """
3791         return tuple(self.viewLim.intervaly)
3792 
3793     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3794                  ymin=None, ymax=None):
3795         """
3796         Set the y-axis view limits.
3797 
3798         Parameters
3799         ----------
3800         bottom : float, optional
3801             The bottom ylim in data coordinates. Passing *None* leaves the
3802             limit unchanged.
3803 
3804             The bottom and top ylims may also be passed as the tuple
3805             (*bottom*, *top*) as the first positional argument (or as
3806             the *bottom* keyword argument).
3807 
3808             .. ACCEPTS: (bottom: float, top: float)
3809 
3810         top : float, optional
3811             The top ylim in data coordinates. Passing *None* leaves the
3812             limit unchanged.
3813 
3814         emit : bool, default: True
3815             Whether to notify observers of limit change.
3816 
3817         auto : bool or None, default: False
3818             Whether to turn on autoscaling of the y-axis. *True* turns on,
3819             *False* turns off, *None* leaves unchanged.
3820 
3821         ymin, ymax : float, optional
3822             They are equivalent to bottom and top respectively, and it is an
3823             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3824 
3825         Returns
3826         -------
3827         bottom, top : (float, float)
3828             The new y-axis limits in data coordinates.
3829 
3830         See Also
3831         --------
3832         get_ylim
3833         set_ybound, get_ybound
3834         invert_yaxis, yaxis_inverted
3835 
3836         Notes
3837         -----
3838         The *bottom* value may be greater than the *top* value, in which
3839         case the y-axis values will decrease from *bottom* to *top*.
3840 
3841         Examples
3842         --------
3843         >>> set_ylim(bottom, top)
3844         >>> set_ylim((bottom, top))
3845         >>> bottom, top = set_ylim(bottom, top)
3846 
3847         One limit may be left unchanged.
3848 
3849         >>> set_ylim(top=top_lim)
3850 
3851         Limits may be passed in reverse order to flip the direction of
3852         the y-axis. For example, suppose ``y`` represents depth of the
3853         ocean in m. The y-axis limits might be set like the following
3854         so 5000 m depth is at the bottom of the plot and the surface,
3855         0 m, is at the top.
3856 
3857         >>> set_ylim(5000, 0)
3858         """
3859         if top is None and np.iterable(bottom):
3860             bottom, top = bottom
3861         if ymin is not None:
3862             if bottom is not None:
3863                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3864             bottom = ymin
3865         if ymax is not None:
3866             if top is not None:
3867                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3868             top = ymax
3869         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3870 
3871     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3872     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3873     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3874     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3875     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3876     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3877     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3878     set_yticklabels = _axis_method_wrapper(
3879         "yaxis", "set_ticklabels",
3880         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3881 
3882     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3883     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3884 
3885     def format_xdata(self, x):
3886         """
3887         Return *x* formatted as an x-value.
3888 
3889         This function will use the `.fmt_xdata` attribute if it is not None,
3890         else will fall back on the xaxis major formatter.
3891         """
3892         return (self.fmt_xdata if self.fmt_xdata is not None
3893                 else self.xaxis.get_major_formatter().format_data_short)(x)
3894 
3895     def format_ydata(self, y):
3896         """
3897         Return *y* formatted as a y-value.
3898 
3899         This function will use the `.fmt_ydata` attribute if it is not None,
3900         else will fall back on the yaxis major formatter.
3901         """
3902         return (self.fmt_ydata if self.fmt_ydata is not None
3903                 else self.yaxis.get_major_formatter().format_data_short)(y)
3904 
3905     def format_coord(self, x, y):
3906         """Return a format string formatting the *x*, *y* coordinates."""
3907         return "x={} y={}".format(
3908             "???" if x is None else self.format_xdata(x),
3909             "???" if y is None else self.format_ydata(y),
3910         )
3911 
3912     def minorticks_on(self):
3913         """
3914         Display minor ticks on the Axes.
3915 
3916         Displaying minor ticks may reduce performance; you may turn them off
3917         using `minorticks_off()` if drawing speed is a problem.
3918         """
3919         for ax in (self.xaxis, self.yaxis):
3920             scale = ax.get_scale()
3921             if scale == 'log':
3922                 s = ax._scale
3923                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3924             elif scale == 'symlog':
3925                 s = ax._scale
3926                 ax.set_minor_locator(
3927                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3928             else:
3929                 ax.set_minor_locator(mticker.AutoMinorLocator())
3930 
3931     def minorticks_off(self):
3932         """Remove minor ticks from the Axes."""
3933         self.xaxis.set_minor_locator(mticker.NullLocator())
3934         self.yaxis.set_minor_locator(mticker.NullLocator())
3935 
3936     # Interactive manipulation
3937 
3938     def can_zoom(self):
3939         """
3940         Return whether this Axes supports the zoom box button functionality.
3941         """
3942         return True
3943 
3944     def can_pan(self):
3945         """
3946         Return whether this Axes supports any pan/zoom button functionality.
3947         """
3948         return True
3949 
3950     def get_navigate(self):
3951         """
3952         Get whether the Axes responds to navigation commands.
3953         """
3954         return self._navigate
3955 
3956     def set_navigate(self, b):
3957         """
3958         Set whether the Axes responds to navigation toolbar commands.
3959 
3960         Parameters
3961         ----------
3962         b : bool
3963         """
3964         self._navigate = b
3965 
3966     def get_navigate_mode(self):
3967         """
3968         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3969         """
3970         return self._navigate_mode
3971 
3972     def set_navigate_mode(self, b):
3973         """
3974         Set the navigation toolbar button status.
3975 
3976         .. warning::
3977             This is not a user-API function.
3978 
3979         """
3980         self._navigate_mode = b
3981 
3982     def _get_view(self):
3983         """
3984         Save information required to reproduce the current view.
3985 
3986         This method is called before a view is changed, such as during a pan or zoom
3987         initiated by the user.  It returns an opaque object that describes the current
3988         view, in a format compatible with :meth:`_set_view`.
3989 
3990         The default implementation saves the view limits and autoscaling state.
3991         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3992         adjusted accordingly.
3993         """
3994         return {
3995             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
3996             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
3997         }
3998 
3999     def _set_view(self, view):
4000         """
4001         Apply a previously saved view.
4002 
4003         This method is called when restoring a view (with the return value of
4004         :meth:`_get_view` as argument), such as with the navigation buttons.
4005 
4006         Subclasses that override :meth:`_get_view` also need to override this method
4007         accordingly.
4008         """
4009         self.set(**view)
4010 
4011     def _prepare_view_from_bbox(self, bbox, direction='in',
4012                                 mode=None, twinx=False, twiny=False):
4013         """
4014         Helper function to prepare the new bounds from a bbox.
4015 
4016         This helper function returns the new x and y bounds from the zoom
4017         bbox. This a convenience method to abstract the bbox logic
4018         out of the base setter.
4019         """
4020         if len(bbox) == 3:
4021             xp, yp, scl = bbox  # Zooming code
4022             if scl == 0:  # Should not happen
4023                 scl = 1.
4024             if scl > 1:
4025                 direction = 'in'
4026             else:
4027                 direction = 'out'
4028                 scl = 1/scl
4029             # get the limits of the axes
4030             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4031                 np.transpose([self.get_xlim(), self.get_ylim()]))
4032             # set the range
4033             xwidth = xmax - xmin
4034             ywidth = ymax - ymin
4035             xcen = (xmax + xmin)*.5
4036             ycen = (ymax + ymin)*.5
4037             xzc = (xp*(scl - 1) + xcen)/scl
4038             yzc = (yp*(scl - 1) + ycen)/scl
4039             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4040                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4041         elif len(bbox) != 4:
4042             # should be len 3 or 4 but nothing else
4043             _api.warn_external(
4044                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4045                 "of length 3 or 4. Ignoring the view change.")
4046             return
4047 
4048         # Original limits.
4049         xmin0, xmax0 = self.get_xbound()
4050         ymin0, ymax0 = self.get_ybound()
4051         # The zoom box in screen coords.
4052         startx, starty, stopx, stopy = bbox
4053         # Convert to data coords.
4054         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4055             [(startx, starty), (stopx, stopy)])
4056         # Clip to axes limits.
4057         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4058         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4059         # Don't double-zoom twinned axes or if zooming only the other axis.
4060         if twinx or mode == "y":
4061             xmin, xmax = xmin0, xmax0
4062         if twiny or mode == "x":
4063             ymin, ymax = ymin0, ymax0
4064 
4065         if direction == "in":
4066             new_xbound = xmin, xmax
4067             new_ybound = ymin, ymax
4068 
4069         elif direction == "out":
4070             x_trf = self.xaxis.get_transform()
4071             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4072                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4073             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4074             # Move original bounds away by
4075             # (factor) x (distance between unzoom box and Axes bbox).
4076             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4077             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4078             # And back to data space.
4079             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4080 
4081             y_trf = self.yaxis.get_transform()
4082             symin0, symax0, symin, symax = y_trf.transform(
4083                 [ymin0, ymax0, ymin, ymax])
4084             factor = (symax0 - symin0) / (symax - symin)
4085             symin1 = symin0 - factor * (symin - symin0)
4086             symax1 = symax0 + factor * (symax0 - symax)
4087             new_ybound = y_trf.inverted().transform([symin1, symax1])
4088 
4089         return new_xbound, new_ybound
4090 
4091     def _set_view_from_bbox(self, bbox, direction='in',
4092                             mode=None, twinx=False, twiny=False):
4093         """
4094         Update view from a selection bbox.
4095 
4096         .. note::
4097 
4098             Intended to be overridden by new projection types, but if not, the
4099             default implementation sets the view limits to the bbox directly.
4100 
4101         Parameters
4102         ----------
4103         bbox : 4-tuple or 3 tuple
4104             * If bbox is a 4 tuple, it is the selected bounding box limits,
4105               in *display* coordinates.
4106             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4107               (xp, yp) is the center of zooming and scl the scale factor to
4108               zoom by.
4109 
4110         direction : str
4111             The direction to apply the bounding box.
4112                 * `'in'` - The bounding box describes the view directly, i.e.,
4113                            it zooms in.
4114                 * `'out'` - The bounding box describes the size to make the
4115                             existing view, i.e., it zooms out.
4116 
4117         mode : str or None
4118             The selection mode, whether to apply the bounding box in only the
4119             `'x'` direction, `'y'` direction or both (`None`).
4120 
4121         twinx : bool
4122             Whether this axis is twinned in the *x*-direction.
4123 
4124         twiny : bool
4125             Whether this axis is twinned in the *y*-direction.
4126         """
4127         new_xbound, new_ybound = self._prepare_view_from_bbox(
4128             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4129         if not twinx and mode != "y":
4130             self.set_xbound(new_xbound)
4131             self.set_autoscalex_on(False)
4132         if not twiny and mode != "x":
4133             self.set_ybound(new_ybound)
4134             self.set_autoscaley_on(False)
4135 
4136     def start_pan(self, x, y, button):
4137         """
4138         Called when a pan operation has started.
4139 
4140         Parameters
4141         ----------
4142         x, y : float
4143             The mouse coordinates in display coords.
4144         button : `.MouseButton`
4145             The pressed mouse button.
4146 
4147         Notes
4148         -----
4149         This is intended to be overridden by new projection types.
4150         """
4151         self._pan_start = types.SimpleNamespace(
4152             lim=self.viewLim.frozen(),
4153             trans=self.transData.frozen(),
4154             trans_inverse=self.transData.inverted().frozen(),
4155             bbox=self.bbox.frozen(),
4156             x=x,
4157             y=y)
4158 
4159     def end_pan(self):
4160         """
4161         Called when a pan operation completes (when the mouse button is up.)
4162 
4163         Notes
4164         -----
4165         This is intended to be overridden by new projection types.
4166         """
4167         del self._pan_start
4168 
4169     def _get_pan_points(self, button, key, x, y):
4170         """
4171         Helper function to return the new points after a pan.
4172 
4173         This helper function returns the points on the axis after a pan has
4174         occurred. This is a convenience method to abstract the pan logic
4175         out of the base setter.
4176         """
4177         def format_deltas(key, dx, dy):
4178             if key == 'control':
4179                 if abs(dx) > abs(dy):
4180                     dy = dx
4181                 else:
4182                     dx = dy
4183             elif key == 'x':
4184                 dy = 0
4185             elif key == 'y':
4186                 dx = 0
4187             elif key == 'shift':
4188                 if 2 * abs(dx) < abs(dy):
4189                     dx = 0
4190                 elif 2 * abs(dy) < abs(dx):
4191                     dy = 0
4192                 elif abs(dx) > abs(dy):
4193                     dy = dy / abs(dy) * abs(dx)
4194                 else:
4195                     dx = dx / abs(dx) * abs(dy)
4196             return dx, dy
4197 
4198         p = self._pan_start
4199         dx = x - p.x
4200         dy = y - p.y
4201         if dx == dy == 0:
4202             return
4203         if button == 1:
4204             dx, dy = format_deltas(key, dx, dy)
4205             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4206         elif button == 3:
4207             try:
4208                 dx = -dx / self.bbox.width
4209                 dy = -dy / self.bbox.height
4210                 dx, dy = format_deltas(key, dx, dy)
4211                 if self.get_aspect() != 'auto':
4212                     dx = dy = 0.5 * (dx + dy)
4213                 alpha = np.power(10.0, (dx, dy))
4214                 start = np.array([p.x, p.y])
4215                 oldpoints = p.lim.transformed(p.trans)
4216                 newpoints = start + alpha * (oldpoints - start)
4217                 result = (mtransforms.Bbox(newpoints)
4218                           .transformed(p.trans_inverse))
4219             except OverflowError:
4220                 _api.warn_external('Overflow while panning')
4221                 return
4222         else:
4223             return
4224 
4225         valid = np.isfinite(result.transformed(p.trans))
4226         points = result.get_points().astype(object)
4227         # Just ignore invalid limits (typically, underflow in log-scale).
4228         points[~valid] = None
4229         return points
4230 
4231     def drag_pan(self, button, key, x, y):
4232         """
4233         Called when the mouse moves during a pan operation.
4234 
4235         Parameters
4236         ----------
4237         button : `.MouseButton`
4238             The pressed mouse button.
4239         key : str or None
4240             The pressed key, if any.
4241         x, y : float
4242             The mouse coordinates in display coords.
4243 
4244         Notes
4245         -----
4246         This is intended to be overridden by new projection types.
4247         """
4248         points = self._get_pan_points(button, key, x, y)
4249         if points is not None:
4250             self.set_xlim(points[:, 0])
4251             self.set_ylim(points[:, 1])
4252 
4253     def get_children(self):
4254         # docstring inherited.
4255         return [
4256             *self._children,
4257             *self.spines.values(),
4258             *self._axis_map.values(),
4259             self.title, self._left_title, self._right_title,
4260             *self.child_axes,
4261             *([self.legend_] if self.legend_ is not None else []),
4262             self.patch,
4263         ]
4264 
4265     def contains(self, mouseevent):
4266         # docstring inherited.
4267         return self.patch.contains(mouseevent)
4268 
4269     def contains_point(self, point):
4270         """
4271         Return whether *point* (pair of pixel coordinates) is inside the Axes
4272         patch.
4273         """
4274         return self.patch.contains_point(point, radius=1.0)
4275 
4276     def get_default_bbox_extra_artists(self):
4277         """
4278         Return a default list of artists that are used for the bounding box
4279         calculation.
4280 
4281         Artists are excluded either by not being visible or
4282         ``artist.set_in_layout(False)``.
4283         """
4284 
4285         artists = self.get_children()
4286 
4287         for axis in self._axis_map.values():
4288             # axis tight bboxes are calculated separately inside
4289             # Axes.get_tightbbox() using for_layout_only=True
4290             artists.remove(axis)
4291         if not (self.axison and self._frameon):
4292             # don't do bbox on spines if frame not on.
4293             for spine in self.spines.values():
4294                 artists.remove(spine)
4295 
4296         artists.remove(self.title)
4297         artists.remove(self._left_title)
4298         artists.remove(self._right_title)
4299 
4300         # always include types that do not internally implement clipping
4301         # to Axes. may have clip_on set to True and clip_box equivalent
4302         # to ax.bbox but then ignore these properties during draws.
4303         noclip = (_AxesBase, maxis.Axis,
4304                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4305         return [a for a in artists if a.get_visible() and a.get_in_layout()
4306                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4307 
4308     @_api.make_keyword_only("3.8", "call_axes_locator")
4309     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4310                       bbox_extra_artists=None, *, for_layout_only=False):
4311         """
4312         Return the tight bounding box of the Axes, including axis and their
4313         decorators (xlabel, title, etc).
4314 
4315         Artists that have ``artist.set_in_layout(False)`` are not included
4316         in the bbox.
4317 
4318         Parameters
4319         ----------
4320         renderer : `.RendererBase` subclass
4321             renderer that will be used to draw the figures (i.e.
4322             ``fig.canvas.get_renderer()``)
4323 
4324         bbox_extra_artists : list of `.Artist` or ``None``
4325             List of artists to include in the tight bounding box.  If
4326             ``None`` (default), then all artist children of the Axes are
4327             included in the tight bounding box.
4328 
4329         call_axes_locator : bool, default: True
4330             If *call_axes_locator* is ``False``, it does not call the
4331             ``_axes_locator`` attribute, which is necessary to get the correct
4332             bounding box. ``call_axes_locator=False`` can be used if the
4333             caller is only interested in the relative size of the tightbbox
4334             compared to the Axes bbox.
4335 
4336         for_layout_only : default: False
4337             The bounding box will *not* include the x-extent of the title and
4338             the xlabel, or the y-extent of the ylabel.
4339 
4340         Returns
4341         -------
4342         `.BboxBase`
4343             Bounding box in figure pixel coordinates.
4344 
4345         See Also
4346         --------
4347         matplotlib.axes.Axes.get_window_extent
4348         matplotlib.axis.Axis.get_tightbbox
4349         matplotlib.spines.Spine.get_window_extent
4350         """
4351 
4352         bb = []
4353         if renderer is None:
4354             renderer = self.figure._get_renderer()
4355 
4356         if not self.get_visible():
4357             return None
4358 
4359         locator = self.get_axes_locator()
4360         self.apply_aspect(
4361             locator(self, renderer) if locator and call_axes_locator else None)
4362 
4363         for axis in self._axis_map.values():
4364             if self.axison and axis.get_visible():
4365                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4366                 if ba:
4367                     bb.append(ba)
4368         self._update_title_position(renderer)
4369         axbbox = self.get_window_extent(renderer)
4370         bb.append(axbbox)
4371 
4372         for title in [self.title, self._left_title, self._right_title]:
4373             if title.get_visible():
4374                 bt = title.get_window_extent(renderer)
4375                 if for_layout_only and bt.width > 0:
4376                     # make the title bbox 1 pixel wide so its width
4377                     # is not accounted for in bbox calculations in
4378                     # tight/constrained_layout
4379                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4380                     bt.x1 = bt.x0 + 1.0
4381                 bb.append(bt)
4382 
4383         bbox_artists = bbox_extra_artists
4384         if bbox_artists is None:
4385             bbox_artists = self.get_default_bbox_extra_artists()
4386 
4387         for a in bbox_artists:
4388             bbox = a.get_tightbbox(renderer)
4389             if (bbox is not None
4390                     and 0 < bbox.width < np.inf
4391                     and 0 < bbox.height < np.inf):
4392                 bb.append(bbox)
4393         return mtransforms.Bbox.union(
4394             [b for b in bb if b.width != 0 or b.height != 0])
4395 
4396     def _make_twin_axes(self, *args, **kwargs):
4397         """Make a twinx Axes of self. This is used for twinx and twiny."""
4398         if 'sharex' in kwargs and 'sharey' in kwargs:
4399             # The following line is added in v2.2 to avoid breaking Seaborn,
4400             # which currently uses this internal API.
4401             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4402                 raise ValueError("Twinned Axes may share only one axis")
4403         ss = self.get_subplotspec()
4404         if ss:
4405             twin = self.figure.add_subplot(ss, *args, **kwargs)
4406         else:
4407             twin = self.figure.add_axes(
4408                 self.get_position(True), *args, **kwargs,
4409                 axes_locator=_TransformedBoundsLocator(
4410                     [0, 0, 1, 1], self.transAxes))
4411         self.set_adjustable('datalim')
4412         twin.set_adjustable('datalim')
4413         self._twinned_axes.join(self, twin)
4414         return twin
4415 
4416     def twinx(self):
4417         """
4418         Create a twin Axes sharing the xaxis.
4419 
4420         Create a new Axes with an invisible x-axis and an independent
4421         y-axis positioned opposite to the original one (i.e. at right). The
4422         x-axis autoscale setting will be inherited from the original
4423         Axes.  To ensure that the tick marks of both y-axes align, see
4424         `~matplotlib.ticker.LinearLocator`.
4425 
4426         Returns
4427         -------
4428         Axes
4429             The newly created Axes instance
4430 
4431         Notes
4432         -----
4433         For those who are 'picking' artists while using twinx, pick
4434         events are only called for the artists in the top-most Axes.
4435         """
4436         ax2 = self._make_twin_axes(sharex=self)
4437         ax2.yaxis.tick_right()
4438         ax2.yaxis.set_label_position('right')
4439         ax2.yaxis.set_offset_position('right')
4440         ax2.set_autoscalex_on(self.get_autoscalex_on())
4441         self.yaxis.tick_left()
4442         ax2.xaxis.set_visible(False)
4443         ax2.patch.set_visible(False)
4444         ax2.xaxis.units = self.xaxis.units
4445         return ax2
4446 
4447     def twiny(self):
4448         """
4449         Create a twin Axes sharing the yaxis.
4450 
4451         Create a new Axes with an invisible y-axis and an independent
4452         x-axis positioned opposite to the original one (i.e. at top). The
4453         y-axis autoscale setting will be inherited from the original Axes.
4454         To ensure that the tick marks of both x-axes align, see
4455         `~matplotlib.ticker.LinearLocator`.
4456 
4457         Returns
4458         -------
4459         Axes
4460             The newly created Axes instance
4461 
4462         Notes
4463         -----
4464         For those who are 'picking' artists while using twiny, pick
4465         events are only called for the artists in the top-most Axes.
4466         """
4467         ax2 = self._make_twin_axes(sharey=self)
4468         ax2.xaxis.tick_top()
4469         ax2.xaxis.set_label_position('top')
4470         ax2.set_autoscaley_on(self.get_autoscaley_on())
4471         self.xaxis.tick_bottom()
4472         ax2.yaxis.set_visible(False)
4473         ax2.patch.set_visible(False)
4474         ax2.yaxis.units = self.yaxis.units
4475         return ax2
4476 
4477     def get_shared_x_axes(self):
4478         """Return an immutable view on the shared x-axes Grouper."""
4479         return cbook.GrouperView(self._shared_axes["x"])
4480 
4481     def get_shared_y_axes(self):
4482         """Return an immutable view on the shared y-axes Grouper."""
4483         return cbook.GrouperView(self._shared_axes["y"])
4484 
4485     def label_outer(self):
4486         """
4487         Only show "outer" labels and tick labels.
4488 
4489         x-labels are only kept for subplots on the last row (or first row, if
4490         labels are on the top side); y-labels only for subplots on the first
4491         column (or last column, if labels are on the right side).
4492         """
4493         self._label_outer_xaxis(check_patch=False)
4494         self._label_outer_yaxis(check_patch=False)
4495 
4496     def _label_outer_xaxis(self, *, check_patch):
4497         # see documentation in label_outer.
4498         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4499             return
4500         ss = self.get_subplotspec()
4501         if not ss:
4502             return
4503         label_position = self.xaxis.get_label_position()
4504         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4505             if label_position == "top":
4506                 self.set_xlabel("")
4507             self.xaxis.set_tick_params(which="both", labeltop=False)
4508             if self.xaxis.offsetText.get_position()[1] == 1:
4509                 self.xaxis.offsetText.set_visible(False)
4510         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4511             if label_position == "bottom":
4512                 self.set_xlabel("")
4513             self.xaxis.set_tick_params(which="both", labelbottom=False)
4514             if self.xaxis.offsetText.get_position()[1] == 0:
4515                 self.xaxis.offsetText.set_visible(False)
4516 
4517     def _label_outer_yaxis(self, *, check_patch):
4518         # see documentation in label_outer.
4519         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4520             return
4521         ss = self.get_subplotspec()
4522         if not ss:
4523             return
4524         label_position = self.yaxis.get_label_position()
4525         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4526             if label_position == "left":
4527                 self.set_ylabel("")
4528             self.yaxis.set_tick_params(which="both", labelleft=False)
4529             if self.yaxis.offsetText.get_position()[0] == 0:
4530                 self.yaxis.offsetText.set_visible(False)
4531         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4532             if label_position == "right":
4533                 self.set_ylabel("")
4534             self.yaxis.set_tick_params(which="both", labelright=False)
4535             if self.yaxis.offsetText.get_position()[0] == 1:
4536                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:51:45.201 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>imshow</method>
<code>
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im

</code><intended_behavior>The `imshow` method should include logic to assess if a custom `transform` is provided that is different from the default `ax.transData`. If such a custom `transform` is detected, the method of setting the aspect ratio (either through direct calls to `set_aspect` or through the logic that leads to its invocation) should be modulated to ensure that it does not enforce an aspect control that assumes square pixels by default. This means the aspect ratio should only be adjusted if explicitly requested by the user in the context of a custom transform. The method should preserve its current functionality for cases where the `transform` is set to `ax.transData` or not provided by the user, thus maintaining backward compatibility and expected behavior in standard usage scenarios.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `~matplotlib.text.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, kwargs = mlegend._parse_legend_args([self], *args, **kwargs)
320         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
321         self.legend_._remove_method = self._remove_legend
322         return self.legend_
323 
324     def _remove_legend(self, legend):
325         self.legend_ = None
326 
327     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
328         """
329         Add a child inset Axes to this existing Axes.
330 
331         Warnings
332         --------
333         This method is experimental as of 3.0, and the API may change.
334 
335         Parameters
336         ----------
337         bounds : [x0, y0, width, height]
338             Lower-left corner of inset Axes, and its width and height.
339 
340         transform : `.Transform`
341             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
342             Axes-relative coordinates.
343 
344         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
345 'polar', 'rectilinear', str}, optional
346             The projection type of the inset `~.axes.Axes`. *str* is the name
347             of a custom projection, see `~matplotlib.projections`. The default
348             None results in a 'rectilinear' projection.
349 
350         polar : bool, default: False
351             If True, equivalent to projection='polar'.
352 
353         axes_class : subclass type of `~.axes.Axes`, optional
354             The `.axes.Axes` subclass that is instantiated.  This parameter
355             is incompatible with *projection* and *polar*.  See
356             :ref:`axisartist_users-guide-index` for examples.
357 
358         zorder : number
359             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
360             to change whether it is above or below data plotted on the
361             parent Axes.
362 
363         **kwargs
364             Other keyword arguments are passed on to the inset Axes class.
365 
366         Returns
367         -------
368         ax
369             The created `~.axes.Axes` instance.
370 
371         Examples
372         --------
373         This example makes two inset Axes, the first is in Axes-relative
374         coordinates, and the second in data-coordinates::
375 
376             fig, ax = plt.subplots()
377             ax.plot(range(10))
378             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
379             axin2 = ax.inset_axes(
380                     [5, 7, 2.3, 2.3], transform=ax.transData)
381 
382         """
383         if transform is None:
384             transform = self.transAxes
385         kwargs.setdefault('label', 'inset_axes')
386 
387         # This puts the rectangle into figure-relative coordinates.
388         inset_locator = _TransformedBoundsLocator(bounds, transform)
389         bounds = inset_locator(self, None).bounds
390         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
391         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
392 
393         # this locator lets the axes move if in data coordinates.
394         # it gets called in `ax.apply_aspect() (of all places)
395         inset_ax.set_axes_locator(inset_locator)
396 
397         self.add_child_axes(inset_ax)
398 
399         return inset_ax
400 
401     @_docstring.dedent_interpd
402     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
403                        facecolor='none', edgecolor='0.5', alpha=0.5,
404                        zorder=4.99, **kwargs):
405         """
406         Add an inset indicator to the Axes.  This is a rectangle on the plot
407         at the position indicated by *bounds* that optionally has lines that
408         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
409 
410         Warnings
411         --------
412         This method is experimental as of 3.0, and the API may change.
413 
414         Parameters
415         ----------
416         bounds : [x0, y0, width, height]
417             Lower-left corner of rectangle to be marked, and its width
418             and height.
419 
420         inset_ax : `.Axes`
421             An optional inset Axes to draw connecting lines to.  Two lines are
422             drawn connecting the indicator box to the inset Axes on corners
423             chosen so as to not overlap with the indicator box.
424 
425         transform : `.Transform`
426             Transform for the rectangle coordinates. Defaults to
427             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
428             coordinates.
429 
430         facecolor : color, default: 'none'
431             Facecolor of the rectangle.
432 
433         edgecolor : color, default: '0.5'
434             Color of the rectangle and color of the connecting lines.
435 
436         alpha : float, default: 0.5
437             Transparency of the rectangle and connector lines.
438 
439         zorder : float, default: 4.99
440             Drawing order of the rectangle and connector lines.  The default,
441             4.99, is just below the default level of inset Axes.
442 
443         **kwargs
444             Other keyword arguments are passed on to the `.Rectangle` patch:
445 
446             %(Rectangle:kwdoc)s
447 
448         Returns
449         -------
450         rectangle_patch : `.patches.Rectangle`
451              The indicator frame.
452 
453         connector_lines : 4-tuple of `.patches.ConnectionPatch`
454             The four connector lines connecting to (lower_left, upper_left,
455             lower_right upper_right) corners of *inset_ax*. Two lines are
456             set with visibility to *False*,  but the user can set the
457             visibility to True if the automatic choice is not deemed correct.
458 
459         """
460         # to make the axes connectors work, we need to apply the aspect to
461         # the parent axes.
462         self.apply_aspect()
463 
464         if transform is None:
465             transform = self.transData
466         kwargs.setdefault('label', '_indicate_inset')
467 
468         x, y, width, height = bounds
469         rectangle_patch = mpatches.Rectangle(
470             (x, y), width, height,
471             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
472             zorder=zorder, transform=transform, **kwargs)
473         self.add_patch(rectangle_patch)
474 
475         connects = []
476 
477         if inset_ax is not None:
478             # connect the inset_axes to the rectangle
479             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
480                 # inset_ax positions are in axes coordinates
481                 # The 0, 1 values define the four edges if the inset_ax
482                 # lower_left, upper_left, lower_right upper_right.
483                 ex, ey = xy_inset_ax
484                 if self.xaxis.get_inverted():
485                     ex = 1 - ex
486                 if self.yaxis.get_inverted():
487                     ey = 1 - ey
488                 xy_data = x + ex * width, y + ey * height
489                 p = mpatches.ConnectionPatch(
490                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
491                     xyB=xy_data, coordsB=self.transData,
492                     arrowstyle="-", zorder=zorder,
493                     edgecolor=edgecolor, alpha=alpha)
494                 connects.append(p)
495                 self.add_patch(p)
496 
497             # decide which two of the lines to keep visible....
498             pos = inset_ax.get_position()
499             bboxins = pos.transformed(self.figure.transSubfigure)
500             rectbbox = mtransforms.Bbox.from_bounds(
501                 *bounds
502             ).transformed(transform)
503             x0 = rectbbox.x0 < bboxins.x0
504             x1 = rectbbox.x1 < bboxins.x1
505             y0 = rectbbox.y0 < bboxins.y0
506             y1 = rectbbox.y1 < bboxins.y1
507             connects[0].set_visible(x0 ^ y0)
508             connects[1].set_visible(x0 == y1)
509             connects[2].set_visible(x1 == y0)
510             connects[3].set_visible(x1 ^ y1)
511 
512         return rectangle_patch, tuple(connects) if connects else None
513 
514     def indicate_inset_zoom(self, inset_ax, **kwargs):
515         """
516         Add an inset indicator rectangle to the Axes based on the axis
517         limits for an *inset_ax* and draw connectors between *inset_ax*
518         and the rectangle.
519 
520         Warnings
521         --------
522         This method is experimental as of 3.0, and the API may change.
523 
524         Parameters
525         ----------
526         inset_ax : `.Axes`
527             Inset Axes to draw connecting lines to.  Two lines are
528             drawn connecting the indicator box to the inset Axes on corners
529             chosen so as to not overlap with the indicator box.
530 
531         **kwargs
532             Other keyword arguments are passed on to `.Axes.indicate_inset`
533 
534         Returns
535         -------
536         rectangle_patch : `.patches.Rectangle`
537              Rectangle artist.
538 
539         connector_lines : 4-tuple of `.patches.ConnectionPatch`
540             Each of four connector lines coming from the rectangle drawn on
541             this axis, in the order lower left, upper left, lower right,
542             upper right.
543             Two are set with visibility to *False*,  but the user can
544             set the visibility to *True* if the automatic choice is not deemed
545             correct.
546         """
547 
548         xlim = inset_ax.get_xlim()
549         ylim = inset_ax.get_ylim()
550         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
551         return self.indicate_inset(rect, inset_ax, **kwargs)
552 
553     @_docstring.dedent_interpd
554     def secondary_xaxis(self, location, *, functions=None, **kwargs):
555         """
556         Add a second x-axis to this `~.axes.Axes`.
557 
558         For example if we want to have a second scale for the data plotted on
559         the xaxis.
560 
561         %(_secax_docstring)s
562 
563         Examples
564         --------
565         The main axis shows frequency, and the secondary axis shows period.
566 
567         .. plot::
568 
569             fig, ax = plt.subplots()
570             ax.loglog(range(1, 360, 5), range(1, 360, 5))
571             ax.set_xlabel('frequency [Hz]')
572 
573             def invert(x):
574                 # 1/x with special treatment of x == 0
575                 x = np.array(x).astype(float)
576                 near_zero = np.isclose(x, 0)
577                 x[near_zero] = np.inf
578                 x[~near_zero] = 1 / x[~near_zero]
579                 return x
580 
581             # the inverse of 1/x is itself
582             secax = ax.secondary_xaxis('top', functions=(invert, invert))
583             secax.set_xlabel('Period [s]')
584             plt.show()
585         """
586         if location in ['top', 'bottom'] or isinstance(location, Real):
587             secondary_ax = SecondaryAxis(self, 'x', location, functions,
588                                          **kwargs)
589             self.add_child_axes(secondary_ax)
590             return secondary_ax
591         else:
592             raise ValueError('secondary_xaxis location must be either '
593                              'a float or "top"/"bottom"')
594 
595     @_docstring.dedent_interpd
596     def secondary_yaxis(self, location, *, functions=None, **kwargs):
597         """
598         Add a second y-axis to this `~.axes.Axes`.
599 
600         For example if we want to have a second scale for the data plotted on
601         the yaxis.
602 
603         %(_secax_docstring)s
604 
605         Examples
606         --------
607         Add a secondary Axes that converts from radians to degrees
608 
609         .. plot::
610 
611             fig, ax = plt.subplots()
612             ax.plot(range(1, 360, 5), range(1, 360, 5))
613             ax.set_ylabel('degrees')
614             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
615                                                            np.rad2deg))
616             secax.set_ylabel('radians')
617         """
618         if location in ['left', 'right'] or isinstance(location, Real):
619             secondary_ax = SecondaryAxis(self, 'y', location,
620                                          functions, **kwargs)
621             self.add_child_axes(secondary_ax)
622             return secondary_ax
623         else:
624             raise ValueError('secondary_yaxis location must be either '
625                              'a float or "left"/"right"')
626 
627     @_docstring.dedent_interpd
628     def text(self, x, y, s, fontdict=None, **kwargs):
629         """
630         Add text to the Axes.
631 
632         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
633 
634         Parameters
635         ----------
636         x, y : float
637             The position to place the text. By default, this is in data
638             coordinates. The coordinate system can be changed using the
639             *transform* parameter.
640 
641         s : str
642             The text.
643 
644         fontdict : dict, default: None
645 
646             .. admonition:: Discouraged
647 
648                The use of *fontdict* is discouraged. Parameters should be passed as
649                individual keyword arguments or using dictionary-unpacking
650                ``text(..., **fontdict)``.
651 
652             A dictionary to override the default text properties. If fontdict
653             is None, the defaults are determined by `.rcParams`.
654 
655         Returns
656         -------
657         `.Text`
658             The created `.Text` instance.
659 
660         Other Parameters
661         ----------------
662         **kwargs : `~matplotlib.text.Text` properties.
663             Other miscellaneous text parameters.
664 
665             %(Text:kwdoc)s
666 
667         Examples
668         --------
669         Individual keyword arguments can be used to override any given
670         parameter::
671 
672             >>> text(x, y, s, fontsize=12)
673 
674         The default transform specifies that text is in data coords,
675         alternatively, you can specify text in axis coords ((0, 0) is
676         lower-left and (1, 1) is upper-right).  The example below places
677         text in the center of the Axes::
678 
679             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
680             ...      verticalalignment='center', transform=ax.transAxes)
681 
682         You can put a rectangular box around the text instance (e.g., to
683         set a background color) by using the keyword *bbox*.  *bbox* is
684         a dictionary of `~matplotlib.patches.Rectangle`
685         properties.  For example::
686 
687             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
688         """
689         effective_kwargs = {
690             'verticalalignment': 'baseline',
691             'horizontalalignment': 'left',
692             'transform': self.transData,
693             'clip_on': False,
694             **(fontdict if fontdict is not None else {}),
695             **kwargs,
696         }
697         t = mtext.Text(x, y, text=s, **effective_kwargs)
698         if t.get_clip_path() is None:
699             t.set_clip_path(self.patch)
700         self._add_text(t)
701         return t
702 
703     @_docstring.dedent_interpd
704     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
705                  arrowprops=None, annotation_clip=None, **kwargs):
706         # Signature must match Annotation. This is verified in
707         # test_annotate_signature().
708         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
709                              textcoords=textcoords, arrowprops=arrowprops,
710                              annotation_clip=annotation_clip, **kwargs)
711         a.set_transform(mtransforms.IdentityTransform())
712         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
713             a.set_clip_path(self.patch)
714         self._add_text(a)
715         return a
716     annotate.__doc__ = mtext.Annotation.__init__.__doc__
717     #### Lines and spans
718 
719     @_docstring.dedent_interpd
720     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
721         """
722         Add a horizontal line across the Axes.
723 
724         Parameters
725         ----------
726         y : float, default: 0
727             y position in data coordinates of the horizontal line.
728 
729         xmin : float, default: 0
730             Should be between 0 and 1, 0 being the far left of the plot, 1 the
731             far right of the plot.
732 
733         xmax : float, default: 1
734             Should be between 0 and 1, 0 being the far left of the plot, 1 the
735             far right of the plot.
736 
737         Returns
738         -------
739         `~matplotlib.lines.Line2D`
740 
741         Other Parameters
742         ----------------
743         **kwargs
744             Valid keyword arguments are `.Line2D` properties, except for
745             'transform':
746 
747             %(Line2D:kwdoc)s
748 
749         See Also
750         --------
751         hlines : Add horizontal lines in data coordinates.
752         axhspan : Add a horizontal span (rectangle) across the axis.
753         axline : Add a line with an arbitrary slope.
754 
755         Examples
756         --------
757         * draw a thick red hline at 'y' = 0 that spans the xrange::
758 
759             >>> axhline(linewidth=4, color='r')
760 
761         * draw a default hline at 'y' = 1 that spans the xrange::
762 
763             >>> axhline(y=1)
764 
765         * draw a default hline at 'y' = .5 that spans the middle half of
766           the xrange::
767 
768             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
769         """
770         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
771         if "transform" in kwargs:
772             raise ValueError("'transform' is not allowed as a keyword "
773                              "argument; axhline generates its own transform.")
774         ymin, ymax = self.get_ybound()
775 
776         # Strip away the units for comparison with non-unitized bounds.
777         yy, = self._process_unit_info([("y", y)], kwargs)
778         scaley = (yy < ymin) or (yy > ymax)
779 
780         trans = self.get_yaxis_transform(which='grid')
781         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
782         self.add_line(l)
783         if scaley:
784             self._request_autoscale_view("y")
785         return l
786 
787     @_docstring.dedent_interpd
788     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
789         """
790         Add a vertical line across the Axes.
791 
792         Parameters
793         ----------
794         x : float, default: 0
795             x position in data coordinates of the vertical line.
796 
797         ymin : float, default: 0
798             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
799             top of the plot.
800 
801         ymax : float, default: 1
802             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
803             top of the plot.
804 
805         Returns
806         -------
807         `~matplotlib.lines.Line2D`
808 
809         Other Parameters
810         ----------------
811         **kwargs
812             Valid keyword arguments are `.Line2D` properties, except for
813             'transform':
814 
815             %(Line2D:kwdoc)s
816 
817         See Also
818         --------
819         vlines : Add vertical lines in data coordinates.
820         axvspan : Add a vertical span (rectangle) across the axis.
821         axline : Add a line with an arbitrary slope.
822 
823         Examples
824         --------
825         * draw a thick red vline at *x* = 0 that spans the yrange::
826 
827             >>> axvline(linewidth=4, color='r')
828 
829         * draw a default vline at *x* = 1 that spans the yrange::
830 
831             >>> axvline(x=1)
832 
833         * draw a default vline at *x* = .5 that spans the middle half of
834           the yrange::
835 
836             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
837         """
838         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
839         if "transform" in kwargs:
840             raise ValueError("'transform' is not allowed as a keyword "
841                              "argument; axvline generates its own transform.")
842         xmin, xmax = self.get_xbound()
843 
844         # Strip away the units for comparison with non-unitized bounds.
845         xx, = self._process_unit_info([("x", x)], kwargs)
846         scalex = (xx < xmin) or (xx > xmax)
847 
848         trans = self.get_xaxis_transform(which='grid')
849         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
850         self.add_line(l)
851         if scalex:
852             self._request_autoscale_view("x")
853         return l
854 
855     @staticmethod
856     def _check_no_units(vals, names):
857         # Helper method to check that vals are not unitized
858         for val, name in zip(vals, names):
859             if not munits._is_natively_supported(val):
860                 raise ValueError(f"{name} must be a single scalar value, "
861                                  f"but got {val}")
862 
863     @_docstring.dedent_interpd
864     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
865         """
866         Add an infinitely long straight line.
867 
868         The line can be defined either by two points *xy1* and *xy2*, or
869         by one point *xy1* and a *slope*.
870 
871         This draws a straight line "on the screen", regardless of the x and y
872         scales, and is thus also suitable for drawing exponential decays in
873         semilog plots, power laws in loglog plots, etc. However, *slope*
874         should only be used with linear scales; It has no clear meaning for
875         all other scales, and thus the behavior is undefined. Please specify
876         the line using the points *xy1*, *xy2* for non-linear scales.
877 
878         The *transform* keyword argument only applies to the points *xy1*,
879         *xy2*. The *slope* (if given) is always in data coordinates. This can
880         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
881         slope.
882 
883         Parameters
884         ----------
885         xy1, xy2 : (float, float)
886             Points for the line to pass through.
887             Either *xy2* or *slope* has to be given.
888         slope : float, optional
889             The slope of the line. Either *xy2* or *slope* has to be given.
890 
891         Returns
892         -------
893         `.Line2D`
894 
895         Other Parameters
896         ----------------
897         **kwargs
898             Valid kwargs are `.Line2D` properties
899 
900             %(Line2D:kwdoc)s
901 
902         See Also
903         --------
904         axhline : for horizontal lines
905         axvline : for vertical lines
906 
907         Examples
908         --------
909         Draw a thick red line passing through (0, 0) and (1, 1)::
910 
911             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
912         """
913         if slope is not None and (self.get_xscale() != 'linear' or
914                                   self.get_yscale() != 'linear'):
915             raise TypeError("'slope' cannot be used with non-linear scales")
916 
917         datalim = [xy1] if xy2 is None else [xy1, xy2]
918         if "transform" in kwargs:
919             # if a transform is passed (i.e. line points not in data space),
920             # data limits should not be adjusted.
921             datalim = []
922 
923         line = mlines.AxLine(xy1, xy2, slope, **kwargs)
924         # Like add_line, but correctly handling data limits.
925         self._set_artist_props(line)
926         if line.get_clip_path() is None:
927             line.set_clip_path(self.patch)
928         if not line.get_label():
929             line.set_label(f"_child{len(self._children)}")
930         self._children.append(line)
931         line._remove_method = self._children.remove
932         self.update_datalim(datalim)
933 
934         self._request_autoscale_view()
935         return line
936 
937     @_docstring.dedent_interpd
938     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
939         """
940         Add a horizontal span (rectangle) across the Axes.
941 
942         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
943         the whole x-axis horizontally.  The x-span can be set using *xmin*
944         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
945         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
946         the limits set by `~.Axes.set_xlim`.
947 
948         Parameters
949         ----------
950         ymin : float
951             Lower y-coordinate of the span, in data units.
952         ymax : float
953             Upper y-coordinate of the span, in data units.
954         xmin : float, default: 0
955             Lower x-coordinate of the span, in x-axis (0-1) units.
956         xmax : float, default: 1
957             Upper x-coordinate of the span, in x-axis (0-1) units.
958 
959         Returns
960         -------
961         `~matplotlib.patches.Polygon`
962             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
963 
964         Other Parameters
965         ----------------
966         **kwargs : `~matplotlib.patches.Polygon` properties
967 
968         %(Polygon:kwdoc)s
969 
970         See Also
971         --------
972         axvspan : Add a vertical span across the Axes.
973         """
974         # Strip units away.
975         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
976         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
977 
978         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
979         p = mpatches.Polygon(verts, **kwargs)
980         p.set_transform(self.get_yaxis_transform(which="grid"))
981         self.add_patch(p)
982         self._request_autoscale_view("y")
983         return p
984 
985     @_docstring.dedent_interpd
986     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
987         """
988         Add a vertical span (rectangle) across the Axes.
989 
990         The rectangle spans from *xmin* to *xmax* horizontally, and, by
991         default, the whole y-axis vertically.  The y-span can be set using
992         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
993         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
994         regardless of the limits set by `~.Axes.set_ylim`.
995 
996         Parameters
997         ----------
998         xmin : float
999             Lower x-coordinate of the span, in data units.
1000         xmax : float
1001             Upper x-coordinate of the span, in data units.
1002         ymin : float, default: 0
1003             Lower y-coordinate of the span, in y-axis units (0-1).
1004         ymax : float, default: 1
1005             Upper y-coordinate of the span, in y-axis units (0-1).
1006 
1007         Returns
1008         -------
1009         `~matplotlib.patches.Polygon`
1010             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1011 
1012         Other Parameters
1013         ----------------
1014         **kwargs : `~matplotlib.patches.Polygon` properties
1015 
1016         %(Polygon:kwdoc)s
1017 
1018         See Also
1019         --------
1020         axhspan : Add a horizontal span across the Axes.
1021 
1022         Examples
1023         --------
1024         Draw a vertical, green, translucent rectangle from x = 1.25 to
1025         x = 1.55 that spans the yrange of the Axes.
1026 
1027         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1028 
1029         """
1030         # Strip units away.
1031         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1032         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1033 
1034         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1035         p = mpatches.Polygon(verts, **kwargs)
1036         p.set_transform(self.get_xaxis_transform(which="grid"))
1037         p.get_path()._interpolation_steps = 100
1038         self.add_patch(p)
1039         self._request_autoscale_view("x")
1040         return p
1041 
1042     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1043                       label_namer="y")
1044     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1045                label='', **kwargs):
1046         """
1047         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1048 
1049         Parameters
1050         ----------
1051         y : float or array-like
1052             y-indexes where to plot the lines.
1053 
1054         xmin, xmax : float or array-like
1055             Respective beginning and end of each line. If scalars are
1056             provided, all lines will have the same length.
1057 
1058         colors : color or list of colors, default: :rc:`lines.color`
1059 
1060         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1061 
1062         label : str, default: ''
1063 
1064         Returns
1065         -------
1066         `~matplotlib.collections.LineCollection`
1067 
1068         Other Parameters
1069         ----------------
1070         data : indexable object, optional
1071             DATA_PARAMETER_PLACEHOLDER
1072         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1073 
1074         See Also
1075         --------
1076         vlines : vertical lines
1077         axhline : horizontal line across the Axes
1078         """
1079 
1080         # We do the conversion first since not all unitized data is uniform
1081         xmin, xmax, y = self._process_unit_info(
1082             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1083 
1084         if not np.iterable(y):
1085             y = [y]
1086         if not np.iterable(xmin):
1087             xmin = [xmin]
1088         if not np.iterable(xmax):
1089             xmax = [xmax]
1090 
1091         # Create and combine masked_arrays from input
1092         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1093         y = np.ravel(y)
1094         xmin = np.ravel(xmin)
1095         xmax = np.ravel(xmax)
1096 
1097         masked_verts = np.ma.empty((len(y), 2, 2))
1098         masked_verts[:, 0, 0] = xmin
1099         masked_verts[:, 0, 1] = y
1100         masked_verts[:, 1, 0] = xmax
1101         masked_verts[:, 1, 1] = y
1102 
1103         lines = mcoll.LineCollection(masked_verts, colors=colors,
1104                                      linestyles=linestyles, label=label)
1105         self.add_collection(lines, autolim=False)
1106         lines._internal_update(kwargs)
1107 
1108         if len(y) > 0:
1109             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1110             # the case of y being a masked *object* array (as can be generated
1111             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1112             updatex = True
1113             updatey = True
1114             if self.name == "rectilinear":
1115                 datalim = lines.get_datalim(self.transData)
1116                 t = lines.get_transform()
1117                 updatex, updatey = t.contains_branch_seperately(self.transData)
1118                 minx = np.nanmin(datalim.xmin)
1119                 maxx = np.nanmax(datalim.xmax)
1120                 miny = np.nanmin(datalim.ymin)
1121                 maxy = np.nanmax(datalim.ymax)
1122             else:
1123                 minx = np.nanmin(masked_verts[..., 0])
1124                 maxx = np.nanmax(masked_verts[..., 0])
1125                 miny = np.nanmin(masked_verts[..., 1])
1126                 maxy = np.nanmax(masked_verts[..., 1])
1127 
1128             corners = (minx, miny), (maxx, maxy)
1129             self.update_datalim(corners, updatex, updatey)
1130             self._request_autoscale_view()
1131         return lines
1132 
1133     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1134                       label_namer="x")
1135     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1136                label='', **kwargs):
1137         """
1138         Plot vertical lines at each *x* from *ymin* to *ymax*.
1139 
1140         Parameters
1141         ----------
1142         x : float or array-like
1143             x-indexes where to plot the lines.
1144 
1145         ymin, ymax : float or array-like
1146             Respective beginning and end of each line. If scalars are
1147             provided, all lines will have the same length.
1148 
1149         colors : color or list of colors, default: :rc:`lines.color`
1150 
1151         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1152 
1153         label : str, default: ''
1154 
1155         Returns
1156         -------
1157         `~matplotlib.collections.LineCollection`
1158 
1159         Other Parameters
1160         ----------------
1161         data : indexable object, optional
1162             DATA_PARAMETER_PLACEHOLDER
1163         **kwargs : `~matplotlib.collections.LineCollection` properties.
1164 
1165         See Also
1166         --------
1167         hlines : horizontal lines
1168         axvline : vertical line across the Axes
1169         """
1170 
1171         # We do the conversion first since not all unitized data is uniform
1172         x, ymin, ymax = self._process_unit_info(
1173             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1174 
1175         if not np.iterable(x):
1176             x = [x]
1177         if not np.iterable(ymin):
1178             ymin = [ymin]
1179         if not np.iterable(ymax):
1180             ymax = [ymax]
1181 
1182         # Create and combine masked_arrays from input
1183         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1184         x = np.ravel(x)
1185         ymin = np.ravel(ymin)
1186         ymax = np.ravel(ymax)
1187 
1188         masked_verts = np.ma.empty((len(x), 2, 2))
1189         masked_verts[:, 0, 0] = x
1190         masked_verts[:, 0, 1] = ymin
1191         masked_verts[:, 1, 0] = x
1192         masked_verts[:, 1, 1] = ymax
1193 
1194         lines = mcoll.LineCollection(masked_verts, colors=colors,
1195                                      linestyles=linestyles, label=label)
1196         self.add_collection(lines, autolim=False)
1197         lines._internal_update(kwargs)
1198 
1199         if len(x) > 0:
1200             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1201             # the case of x being a masked *object* array (as can be generated
1202             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1203             updatex = True
1204             updatey = True
1205             if self.name == "rectilinear":
1206                 datalim = lines.get_datalim(self.transData)
1207                 t = lines.get_transform()
1208                 updatex, updatey = t.contains_branch_seperately(self.transData)
1209                 minx = np.nanmin(datalim.xmin)
1210                 maxx = np.nanmax(datalim.xmax)
1211                 miny = np.nanmin(datalim.ymin)
1212                 maxy = np.nanmax(datalim.ymax)
1213             else:
1214                 minx = np.nanmin(masked_verts[..., 0])
1215                 maxx = np.nanmax(masked_verts[..., 0])
1216                 miny = np.nanmin(masked_verts[..., 1])
1217                 maxy = np.nanmax(masked_verts[..., 1])
1218 
1219             corners = (minx, miny), (maxx, maxy)
1220             self.update_datalim(corners, updatex, updatey)
1221             self._request_autoscale_view()
1222         return lines
1223 
1224     @_preprocess_data(replace_names=["positions", "lineoffsets",
1225                                      "linelengths", "linewidths",
1226                                      "colors", "linestyles"])
1227     @_docstring.dedent_interpd
1228     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1229                   linelengths=1, linewidths=None, colors=None, alpha=None,
1230                   linestyles='solid', **kwargs):
1231         """
1232         Plot identical parallel lines at the given positions.
1233 
1234         This type of plot is commonly used in neuroscience for representing
1235         neural events, where it is usually called a spike raster, dot raster,
1236         or raster plot.
1237 
1238         However, it is useful in any situation where you wish to show the
1239         timing or position of multiple sets of discrete events, such as the
1240         arrival times of people to a business on each day of the month or the
1241         date of hurricanes each year of the last century.
1242 
1243         Parameters
1244         ----------
1245         positions : array-like or list of array-like
1246             A 1D array-like defines the positions of one sequence of events.
1247 
1248             Multiple groups of events may be passed as a list of array-likes.
1249             Each group can be styled independently by passing lists of values
1250             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1251             *linestyles*.
1252 
1253             Note that *positions* can be a 2D array, but in practice different
1254             event groups usually have different counts so that one will use a
1255             list of different-length arrays rather than a 2D array.
1256 
1257         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1258             The direction of the event sequence:
1259 
1260             - 'horizontal': the events are arranged horizontally.
1261               The indicator lines are vertical.
1262             - 'vertical': the events are arranged vertically.
1263               The indicator lines are horizontal.
1264 
1265         lineoffsets : float or array-like, default: 1
1266             The offset of the center of the lines from the origin, in the
1267             direction orthogonal to *orientation*.
1268 
1269             If *positions* is 2D, this can be a sequence with length matching
1270             the length of *positions*.
1271 
1272         linelengths : float or array-like, default: 1
1273             The total height of the lines (i.e. the lines stretches from
1274             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1275 
1276             If *positions* is 2D, this can be a sequence with length matching
1277             the length of *positions*.
1278 
1279         linewidths : float or array-like, default: :rc:`lines.linewidth`
1280             The line width(s) of the event lines, in points.
1281 
1282             If *positions* is 2D, this can be a sequence with length matching
1283             the length of *positions*.
1284 
1285         colors : color or list of colors, default: :rc:`lines.color`
1286             The color(s) of the event lines.
1287 
1288             If *positions* is 2D, this can be a sequence with length matching
1289             the length of *positions*.
1290 
1291         alpha : float or array-like, default: 1
1292             The alpha blending value(s), between 0 (transparent) and 1
1293             (opaque).
1294 
1295             If *positions* is 2D, this can be a sequence with length matching
1296             the length of *positions*.
1297 
1298         linestyles : str or tuple or list of such values, default: 'solid'
1299             Default is 'solid'. Valid strings are ['solid', 'dashed',
1300             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1301             should be of the form::
1302 
1303                 (offset, onoffseq),
1304 
1305             where *onoffseq* is an even length tuple of on and off ink
1306             in points.
1307 
1308             If *positions* is 2D, this can be a sequence with length matching
1309             the length of *positions*.
1310 
1311         data : indexable object, optional
1312             DATA_PARAMETER_PLACEHOLDER
1313 
1314         **kwargs
1315             Other keyword arguments are line collection properties.  See
1316             `.LineCollection` for a list of the valid properties.
1317 
1318         Returns
1319         -------
1320         list of `.EventCollection`
1321             The `.EventCollection` that were added.
1322 
1323         Notes
1324         -----
1325         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1326         only a single value is given, that value is applied to all lines. If an
1327         array-like is given, it must have the same length as *positions*, and
1328         each value will be applied to the corresponding row of the array.
1329 
1330         Examples
1331         --------
1332         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1333         """
1334 
1335         lineoffsets, linelengths = self._process_unit_info(
1336                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1337 
1338         # fix positions, noting that it can be a list of lists:
1339         if not np.iterable(positions):
1340             positions = [positions]
1341         elif any(np.iterable(position) for position in positions):
1342             positions = [np.asanyarray(position) for position in positions]
1343         else:
1344             positions = [np.asanyarray(positions)]
1345 
1346         poss = []
1347         for position in positions:
1348             poss += self._process_unit_info([("x", position)], kwargs)
1349         positions = poss
1350 
1351         # prevent 'singular' keys from **kwargs dict from overriding the effect
1352         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1353         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1354         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1355         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1356 
1357         if not np.iterable(lineoffsets):
1358             lineoffsets = [lineoffsets]
1359         if not np.iterable(linelengths):
1360             linelengths = [linelengths]
1361         if not np.iterable(linewidths):
1362             linewidths = [linewidths]
1363         if not np.iterable(colors):
1364             colors = [colors]
1365         if not np.iterable(alpha):
1366             alpha = [alpha]
1367         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1368             linestyles = [linestyles]
1369 
1370         lineoffsets = np.asarray(lineoffsets)
1371         linelengths = np.asarray(linelengths)
1372         linewidths = np.asarray(linewidths)
1373 
1374         if len(lineoffsets) == 0:
1375             raise ValueError('lineoffsets cannot be empty')
1376         if len(linelengths) == 0:
1377             raise ValueError('linelengths cannot be empty')
1378         if len(linestyles) == 0:
1379             raise ValueError('linestyles cannot be empty')
1380         if len(linewidths) == 0:
1381             raise ValueError('linewidths cannot be empty')
1382         if len(alpha) == 0:
1383             raise ValueError('alpha cannot be empty')
1384         if len(colors) == 0:
1385             colors = [None]
1386         try:
1387             # Early conversion of the colors into RGBA values to take care
1388             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1389             colors = mcolors.to_rgba_array(colors)
1390         except ValueError:
1391             # Will fail if any element of *colors* is None. But as long
1392             # as len(colors) == 1 or len(positions), the rest of the
1393             # code should process *colors* properly.
1394             pass
1395 
1396         if len(lineoffsets) == 1 and len(positions) != 1:
1397             lineoffsets = np.tile(lineoffsets, len(positions))
1398             lineoffsets[0] = 0
1399             lineoffsets = np.cumsum(lineoffsets)
1400         if len(linelengths) == 1:
1401             linelengths = np.tile(linelengths, len(positions))
1402         if len(linewidths) == 1:
1403             linewidths = np.tile(linewidths, len(positions))
1404         if len(colors) == 1:
1405             colors = list(colors) * len(positions)
1406         if len(alpha) == 1:
1407             alpha = list(alpha) * len(positions)
1408         if len(linestyles) == 1:
1409             linestyles = [linestyles] * len(positions)
1410 
1411         if len(lineoffsets) != len(positions):
1412             raise ValueError('lineoffsets and positions are unequal sized '
1413                              'sequences')
1414         if len(linelengths) != len(positions):
1415             raise ValueError('linelengths and positions are unequal sized '
1416                              'sequences')
1417         if len(linewidths) != len(positions):
1418             raise ValueError('linewidths and positions are unequal sized '
1419                              'sequences')
1420         if len(colors) != len(positions):
1421             raise ValueError('colors and positions are unequal sized '
1422                              'sequences')
1423         if len(alpha) != len(positions):
1424             raise ValueError('alpha and positions are unequal sized '
1425                              'sequences')
1426         if len(linestyles) != len(positions):
1427             raise ValueError('linestyles and positions are unequal sized '
1428                              'sequences')
1429 
1430         colls = []
1431         for position, lineoffset, linelength, linewidth, color, alpha_, \
1432             linestyle in \
1433                 zip(positions, lineoffsets, linelengths, linewidths,
1434                     colors, alpha, linestyles):
1435             coll = mcoll.EventCollection(position,
1436                                          orientation=orientation,
1437                                          lineoffset=lineoffset,
1438                                          linelength=linelength,
1439                                          linewidth=linewidth,
1440                                          color=color,
1441                                          alpha=alpha_,
1442                                          linestyle=linestyle)
1443             self.add_collection(coll, autolim=False)
1444             coll._internal_update(kwargs)
1445             colls.append(coll)
1446 
1447         if len(positions) > 0:
1448             # try to get min/max
1449             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1450                        if len(_p) > 0]
1451             # if we have any non-empty positions, try to autoscale
1452             if len(min_max) > 0:
1453                 mins, maxes = zip(*min_max)
1454                 minpos = np.min(mins)
1455                 maxpos = np.max(maxes)
1456 
1457                 minline = (lineoffsets - linelengths).min()
1458                 maxline = (lineoffsets + linelengths).max()
1459 
1460                 if orientation == "vertical":
1461                     corners = (minline, minpos), (maxline, maxpos)
1462                 else:  # "horizontal"
1463                     corners = (minpos, minline), (maxpos, maxline)
1464                 self.update_datalim(corners)
1465                 self._request_autoscale_view()
1466 
1467         return colls
1468 
1469     #### Basic plotting
1470 
1471     # Uses a custom implementation of data-kwarg handling in
1472     # _process_plot_var_args.
1473     @_docstring.dedent_interpd
1474     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1475         """
1476         Plot y versus x as lines and/or markers.
1477 
1478         Call signatures::
1479 
1480             plot([x], y, [fmt], *, data=None, **kwargs)
1481             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1482 
1483         The coordinates of the points or line nodes are given by *x*, *y*.
1484 
1485         The optional parameter *fmt* is a convenient way for defining basic
1486         formatting like color, marker and linestyle. It's a shortcut string
1487         notation described in the *Notes* section below.
1488 
1489         >>> plot(x, y)        # plot x and y using default line style and color
1490         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1491         >>> plot(y)           # plot y using x as index array 0..N-1
1492         >>> plot(y, 'r+')     # ditto, but with red plusses
1493 
1494         You can use `.Line2D` properties as keyword arguments for more
1495         control on the appearance. Line properties and *fmt* can be mixed.
1496         The following two calls yield identical results:
1497 
1498         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1499         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1500         ...      linewidth=2, markersize=12)
1501 
1502         When conflicting with *fmt*, keyword arguments take precedence.
1503 
1504 
1505         **Plotting labelled data**
1506 
1507         There's a convenient way for plotting objects with labelled data (i.e.
1508         data that can be accessed by index ``obj['y']``). Instead of giving
1509         the data in *x* and *y*, you can provide the object in the *data*
1510         parameter and just give the labels for *x* and *y*::
1511 
1512         >>> plot('xlabel', 'ylabel', data=obj)
1513 
1514         All indexable objects are supported. This could e.g. be a `dict`, a
1515         `pandas.DataFrame` or a structured numpy array.
1516 
1517 
1518         **Plotting multiple sets of data**
1519 
1520         There are various ways to plot multiple sets of data.
1521 
1522         - The most straight forward way is just to call `plot` multiple times.
1523           Example:
1524 
1525           >>> plot(x1, y1, 'bo')
1526           >>> plot(x2, y2, 'go')
1527 
1528         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1529           for every column. If both *x* and *y* are 2D, they must have the
1530           same shape. If only one of them is 2D with shape (N, m) the other
1531           must have length N and will be used for every data set m.
1532 
1533           Example:
1534 
1535           >>> x = [1, 2, 3]
1536           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1537           >>> plot(x, y)
1538 
1539           is equivalent to:
1540 
1541           >>> for col in range(y.shape[1]):
1542           ...     plot(x, y[:, col])
1543 
1544         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1545           groups::
1546 
1547           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1548 
1549           In this case, any additional keyword argument applies to all
1550           datasets. Also, this syntax cannot be combined with the *data*
1551           parameter.
1552 
1553         By default, each line is assigned a different style specified by a
1554         'style cycle'. The *fmt* and line property parameters are only
1555         necessary if you want explicit deviations from these defaults.
1556         Alternatively, you can also change the style cycle using
1557         :rc:`axes.prop_cycle`.
1558 
1559 
1560         Parameters
1561         ----------
1562         x, y : array-like or scalar
1563             The horizontal / vertical coordinates of the data points.
1564             *x* values are optional and default to ``range(len(y))``.
1565 
1566             Commonly, these parameters are 1D arrays.
1567 
1568             They can also be scalars, or two-dimensional (in that case, the
1569             columns represent separate data sets).
1570 
1571             These arguments cannot be passed as keywords.
1572 
1573         fmt : str, optional
1574             A format string, e.g. 'ro' for red circles. See the *Notes*
1575             section for a full description of the format strings.
1576 
1577             Format strings are just an abbreviation for quickly setting
1578             basic line properties. All of these and more can also be
1579             controlled by keyword arguments.
1580 
1581             This argument cannot be passed as keyword.
1582 
1583         data : indexable object, optional
1584             An object with labelled data. If given, provide the label names to
1585             plot in *x* and *y*.
1586 
1587             .. note::
1588                 Technically there's a slight ambiguity in calls where the
1589                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1590                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1591                 the former interpretation is chosen, but a warning is issued.
1592                 You may suppress the warning by adding an empty format string
1593                 ``plot('n', 'o', '', data=obj)``.
1594 
1595         Returns
1596         -------
1597         list of `.Line2D`
1598             A list of lines representing the plotted data.
1599 
1600         Other Parameters
1601         ----------------
1602         scalex, scaley : bool, default: True
1603             These parameters determine if the view limits are adapted to the
1604             data limits. The values are passed on to
1605             `~.axes.Axes.autoscale_view`.
1606 
1607         **kwargs : `~matplotlib.lines.Line2D` properties, optional
1608             *kwargs* are used to specify properties like a line label (for
1609             auto legends), linewidth, antialiasing, marker face color.
1610             Example::
1611 
1612             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1613             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1614 
1615             If you specify multiple lines with one plot call, the kwargs apply
1616             to all those lines. In case the label object is iterable, each
1617             element is used as labels for each set of data.
1618 
1619             Here is a list of available `.Line2D` properties:
1620 
1621             %(Line2D:kwdoc)s
1622 
1623         See Also
1624         --------
1625         scatter : XY scatter plot with markers of varying size and/or color (
1626             sometimes also called bubble chart).
1627 
1628         Notes
1629         -----
1630         **Format Strings**
1631 
1632         A format string consists of a part for color, marker and line::
1633 
1634             fmt = '[marker][line][color]'
1635 
1636         Each of them is optional. If not provided, the value from the style
1637         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1638         the data will be a line without markers.
1639 
1640         Other combinations such as ``[color][marker][line]`` are also
1641         supported, but note that their parsing may be ambiguous.
1642 
1643         **Markers**
1644 
1645         =============   ===============================
1646         character       description
1647         =============   ===============================
1648         ``'.'``         point marker
1649         ``','``         pixel marker
1650         ``'o'``         circle marker
1651         ``'v'``         triangle_down marker
1652         ``'^'``         triangle_up marker
1653         ``'<'``         triangle_left marker
1654         ``'>'``         triangle_right marker
1655         ``'1'``         tri_down marker
1656         ``'2'``         tri_up marker
1657         ``'3'``         tri_left marker
1658         ``'4'``         tri_right marker
1659         ``'8'``         octagon marker
1660         ``'s'``         square marker
1661         ``'p'``         pentagon marker
1662         ``'P'``         plus (filled) marker
1663         ``'*'``         star marker
1664         ``'h'``         hexagon1 marker
1665         ``'H'``         hexagon2 marker
1666         ``'+'``         plus marker
1667         ``'x'``         x marker
1668         ``'X'``         x (filled) marker
1669         ``'D'``         diamond marker
1670         ``'d'``         thin_diamond marker
1671         ``'|'``         vline marker
1672         ``'_'``         hline marker
1673         =============   ===============================
1674 
1675         **Line Styles**
1676 
1677         =============    ===============================
1678         character        description
1679         =============    ===============================
1680         ``'-'``          solid line style
1681         ``'--'``         dashed line style
1682         ``'-.'``         dash-dot line style
1683         ``':'``          dotted line style
1684         =============    ===============================
1685 
1686         Example format strings::
1687 
1688             'b'    # blue markers with default shape
1689             'or'   # red circles
1690             '-g'   # green solid line
1691             '--'   # dashed line with default color
1692             '^k:'  # black triangle_up markers connected by a dotted line
1693 
1694         **Colors**
1695 
1696         The supported color abbreviations are the single letter codes
1697 
1698         =============    ===============================
1699         character        color
1700         =============    ===============================
1701         ``'b'``          blue
1702         ``'g'``          green
1703         ``'r'``          red
1704         ``'c'``          cyan
1705         ``'m'``          magenta
1706         ``'y'``          yellow
1707         ``'k'``          black
1708         ``'w'``          white
1709         =============    ===============================
1710 
1711         and the ``'CN'`` colors that index into the default property cycle.
1712 
1713         If the color is the only part of the format string, you can
1714         additionally use any  `matplotlib.colors` spec, e.g. full names
1715         (``'green'``) or hex strings (``'#008000'``).
1716         """
1717         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1718         lines = [*self._get_lines(*args, data=data, **kwargs)]
1719         for line in lines:
1720             self.add_line(line)
1721         if scalex:
1722             self._request_autoscale_view("x")
1723         if scaley:
1724             self._request_autoscale_view("y")
1725         return lines
1726 
1727     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1728     @_docstring.dedent_interpd
1729     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1730                   **kwargs):
1731         """
1732         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1733 
1734         .. admonition:: Discouraged
1735 
1736             This method exists for historic reasons and will be deprecated in
1737             the future.
1738 
1739             - ``datetime``-like data should directly be plotted using
1740               `~.Axes.plot`.
1741             -  If you need to plot plain numeric data as :ref:`date-format` or
1742                need to set a timezone, call ``ax.xaxis.axis_date`` /
1743                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1744                `.Axis.axis_date`.
1745 
1746         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1747         However, the axis labels are formatted as dates depending on *xdate*
1748         and *ydate*.  Note that `.plot` will work with `datetime` and
1749         `numpy.datetime64` objects without resorting to this method.
1750 
1751         Parameters
1752         ----------
1753         x, y : array-like
1754             The coordinates of the data points. If *xdate* or *ydate* is
1755             *True*, the respective values *x* or *y* are interpreted as
1756             :ref:`Matplotlib dates <date-format>`.
1757 
1758         fmt : str, optional
1759             The plot format string. For details, see the corresponding
1760             parameter in `.plot`.
1761 
1762         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1763             The time zone to use in labeling dates.
1764 
1765         xdate : bool, default: True
1766             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1767 
1768         ydate : bool, default: False
1769             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1770 
1771         Returns
1772         -------
1773         list of `.Line2D`
1774             Objects representing the plotted data.
1775 
1776         Other Parameters
1777         ----------------
1778         data : indexable object, optional
1779             DATA_PARAMETER_PLACEHOLDER
1780         **kwargs
1781             Keyword arguments control the `.Line2D` properties:
1782 
1783             %(Line2D:kwdoc)s
1784 
1785         See Also
1786         --------
1787         matplotlib.dates : Helper functions on dates.
1788         matplotlib.dates.date2num : Convert dates to num.
1789         matplotlib.dates.num2date : Convert num to dates.
1790         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1791 
1792         Notes
1793         -----
1794         If you are using custom date tickers and formatters, it may be
1795         necessary to set the formatters/locators after the call to
1796         `.plot_date`. `.plot_date` will set the default tick locator to
1797         `.AutoDateLocator` (if the tick locator is not already set to a
1798         `.DateLocator` instance) and the default tick formatter to
1799         `.AutoDateFormatter` (if the tick formatter is not already set to a
1800         `.DateFormatter` instance).
1801         """
1802         if xdate:
1803             self.xaxis_date(tz)
1804         if ydate:
1805             self.yaxis_date(tz)
1806         return self.plot(x, y, fmt, **kwargs)
1807 
1808     # @_preprocess_data() # let 'plot' do the unpacking..
1809     @_docstring.dedent_interpd
1810     def loglog(self, *args, **kwargs):
1811         """
1812         Make a plot with log scaling on both the x- and y-axis.
1813 
1814         Call signatures::
1815 
1816             loglog([x], y, [fmt], data=None, **kwargs)
1817             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1818 
1819         This is just a thin wrapper around `.plot` which additionally changes
1820         both the x-axis and the y-axis to log scaling. All the concepts and
1821         parameters of plot can be used here as well.
1822 
1823         The additional parameters *base*, *subs* and *nonpositive* control the
1824         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1825         `.Axes.set_yscale`. To use different properties on the x-axis and the
1826         y-axis, use e.g.
1827         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1828 
1829         Parameters
1830         ----------
1831         base : float, default: 10
1832             Base of the logarithm.
1833 
1834         subs : sequence, optional
1835             The location of the minor ticks. If *None*, reasonable locations
1836             are automatically chosen depending on the number of decades in the
1837             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1838 
1839         nonpositive : {'mask', 'clip'}, default: 'clip'
1840             Non-positive values can be masked as invalid, or clipped to a very
1841             small positive number.
1842 
1843         **kwargs
1844             All parameters supported by `.plot`.
1845 
1846         Returns
1847         -------
1848         list of `.Line2D`
1849             Objects representing the plotted data.
1850         """
1851         dx = {k: v for k, v in kwargs.items()
1852               if k in ['base', 'subs', 'nonpositive',
1853                        'basex', 'subsx', 'nonposx']}
1854         self.set_xscale('log', **dx)
1855         dy = {k: v for k, v in kwargs.items()
1856               if k in ['base', 'subs', 'nonpositive',
1857                        'basey', 'subsy', 'nonposy']}
1858         self.set_yscale('log', **dy)
1859         return self.plot(
1860             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1861 
1862     # @_preprocess_data() # let 'plot' do the unpacking..
1863     @_docstring.dedent_interpd
1864     def semilogx(self, *args, **kwargs):
1865         """
1866         Make a plot with log scaling on the x-axis.
1867 
1868         Call signatures::
1869 
1870             semilogx([x], y, [fmt], data=None, **kwargs)
1871             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1872 
1873         This is just a thin wrapper around `.plot` which additionally changes
1874         the x-axis to log scaling. All the concepts and parameters of plot can
1875         be used here as well.
1876 
1877         The additional parameters *base*, *subs*, and *nonpositive* control the
1878         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1879 
1880         Parameters
1881         ----------
1882         base : float, default: 10
1883             Base of the x logarithm.
1884 
1885         subs : array-like, optional
1886             The location of the minor xticks. If *None*, reasonable locations
1887             are automatically chosen depending on the number of decades in the
1888             plot. See `.Axes.set_xscale` for details.
1889 
1890         nonpositive : {'mask', 'clip'}, default: 'clip'
1891             Non-positive values in x can be masked as invalid, or clipped to a
1892             very small positive number.
1893 
1894         **kwargs
1895             All parameters supported by `.plot`.
1896 
1897         Returns
1898         -------
1899         list of `.Line2D`
1900             Objects representing the plotted data.
1901         """
1902         d = {k: v for k, v in kwargs.items()
1903              if k in ['base', 'subs', 'nonpositive',
1904                       'basex', 'subsx', 'nonposx']}
1905         self.set_xscale('log', **d)
1906         return self.plot(
1907             *args, **{k: v for k, v in kwargs.items() if k not in d})
1908 
1909     # @_preprocess_data() # let 'plot' do the unpacking..
1910     @_docstring.dedent_interpd
1911     def semilogy(self, *args, **kwargs):
1912         """
1913         Make a plot with log scaling on the y-axis.
1914 
1915         Call signatures::
1916 
1917             semilogy([x], y, [fmt], data=None, **kwargs)
1918             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1919 
1920         This is just a thin wrapper around `.plot` which additionally changes
1921         the y-axis to log scaling. All the concepts and parameters of plot can
1922         be used here as well.
1923 
1924         The additional parameters *base*, *subs*, and *nonpositive* control the
1925         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1926 
1927         Parameters
1928         ----------
1929         base : float, default: 10
1930             Base of the y logarithm.
1931 
1932         subs : array-like, optional
1933             The location of the minor yticks. If *None*, reasonable locations
1934             are automatically chosen depending on the number of decades in the
1935             plot. See `.Axes.set_yscale` for details.
1936 
1937         nonpositive : {'mask', 'clip'}, default: 'clip'
1938             Non-positive values in y can be masked as invalid, or clipped to a
1939             very small positive number.
1940 
1941         **kwargs
1942             All parameters supported by `.plot`.
1943 
1944         Returns
1945         -------
1946         list of `.Line2D`
1947             Objects representing the plotted data.
1948         """
1949         d = {k: v for k, v in kwargs.items()
1950              if k in ['base', 'subs', 'nonpositive',
1951                       'basey', 'subsy', 'nonposy']}
1952         self.set_yscale('log', **d)
1953         return self.plot(
1954             *args, **{k: v for k, v in kwargs.items() if k not in d})
1955 
1956     @_preprocess_data(replace_names=["x"], label_namer="x")
1957     def acorr(self, x, **kwargs):
1958         """
1959         Plot the autocorrelation of *x*.
1960 
1961         Parameters
1962         ----------
1963         x : array-like
1964 
1965         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1966             A detrending function applied to *x*.  It must have the
1967             signature ::
1968 
1969                 detrend(x: np.ndarray) -> np.ndarray
1970 
1971         normed : bool, default: True
1972             If ``True``, input vectors are normalised to unit length.
1973 
1974         usevlines : bool, default: True
1975             Determines the plot style.
1976 
1977             If ``True``, vertical lines are plotted from 0 to the acorr value
1978             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1979             at y=0 using `.Axes.axhline`.
1980 
1981             If ``False``, markers are plotted at the acorr values using
1982             `.Axes.plot`.
1983 
1984         maxlags : int, default: 10
1985             Number of lags to show. If ``None``, will return all
1986             ``2 * len(x) - 1`` lags.
1987 
1988         Returns
1989         -------
1990         lags : array (length ``2*maxlags+1``)
1991             The lag vector.
1992         c : array  (length ``2*maxlags+1``)
1993             The auto correlation vector.
1994         line : `.LineCollection` or `.Line2D`
1995             `.Artist` added to the Axes of the correlation:
1996 
1997             - `.LineCollection` if *usevlines* is True.
1998             - `.Line2D` if *usevlines* is False.
1999         b : `~matplotlib.lines.Line2D` or None
2000             Horizontal line at 0 if *usevlines* is True
2001             None *usevlines* is False.
2002 
2003         Other Parameters
2004         ----------------
2005         linestyle : `~matplotlib.lines.Line2D` property, optional
2006             The linestyle for plotting the data points.
2007             Only used if *usevlines* is ``False``.
2008 
2009         marker : str, default: 'o'
2010             The marker for plotting the data points.
2011             Only used if *usevlines* is ``False``.
2012 
2013         data : indexable object, optional
2014             DATA_PARAMETER_PLACEHOLDER
2015 
2016         **kwargs
2017             Additional parameters are passed to `.Axes.vlines` and
2018             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2019             passed to `.Axes.plot`.
2020 
2021         Notes
2022         -----
2023         The cross correlation is performed with `numpy.correlate` with
2024         ``mode = "full"``.
2025         """
2026         return self.xcorr(x, x, **kwargs)
2027 
2028     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2029     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2030               usevlines=True, maxlags=10, **kwargs):
2031         r"""
2032         Plot the cross correlation between *x* and *y*.
2033 
2034         The correlation with lag k is defined as
2035         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2036         conjugate of :math:`y`.
2037 
2038         Parameters
2039         ----------
2040         x, y : array-like of length n
2041 
2042         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2043             A detrending function applied to *x* and *y*.  It must have the
2044             signature ::
2045 
2046                 detrend(x: np.ndarray) -> np.ndarray
2047 
2048         normed : bool, default: True
2049             If ``True``, input vectors are normalised to unit length.
2050 
2051         usevlines : bool, default: True
2052             Determines the plot style.
2053 
2054             If ``True``, vertical lines are plotted from 0 to the xcorr value
2055             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2056             at y=0 using `.Axes.axhline`.
2057 
2058             If ``False``, markers are plotted at the xcorr values using
2059             `.Axes.plot`.
2060 
2061         maxlags : int, default: 10
2062             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2063             lags.
2064 
2065         Returns
2066         -------
2067         lags : array (length ``2*maxlags+1``)
2068             The lag vector.
2069         c : array  (length ``2*maxlags+1``)
2070             The auto correlation vector.
2071         line : `.LineCollection` or `.Line2D`
2072             `.Artist` added to the Axes of the correlation:
2073 
2074             - `.LineCollection` if *usevlines* is True.
2075             - `.Line2D` if *usevlines* is False.
2076         b : `~matplotlib.lines.Line2D` or None
2077             Horizontal line at 0 if *usevlines* is True
2078             None *usevlines* is False.
2079 
2080         Other Parameters
2081         ----------------
2082         linestyle : `~matplotlib.lines.Line2D` property, optional
2083             The linestyle for plotting the data points.
2084             Only used if *usevlines* is ``False``.
2085 
2086         marker : str, default: 'o'
2087             The marker for plotting the data points.
2088             Only used if *usevlines* is ``False``.
2089 
2090         data : indexable object, optional
2091             DATA_PARAMETER_PLACEHOLDER
2092 
2093         **kwargs
2094             Additional parameters are passed to `.Axes.vlines` and
2095             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2096             passed to `.Axes.plot`.
2097 
2098         Notes
2099         -----
2100         The cross correlation is performed with `numpy.correlate` with
2101         ``mode = "full"``.
2102         """
2103         Nx = len(x)
2104         if Nx != len(y):
2105             raise ValueError('x and y must be equal length')
2106 
2107         x = detrend(np.asarray(x))
2108         y = detrend(np.asarray(y))
2109 
2110         correls = np.correlate(x, y, mode="full")
2111 
2112         if normed:
2113             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2114 
2115         if maxlags is None:
2116             maxlags = Nx - 1
2117 
2118         if maxlags >= Nx or maxlags < 1:
2119             raise ValueError('maxlags must be None or strictly '
2120                              'positive < %d' % Nx)
2121 
2122         lags = np.arange(-maxlags, maxlags + 1)
2123         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2124 
2125         if usevlines:
2126             a = self.vlines(lags, [0], correls, **kwargs)
2127             # Make label empty so only vertical lines get a legend entry
2128             kwargs.pop('label', '')
2129             b = self.axhline(**kwargs)
2130         else:
2131             kwargs.setdefault('marker', 'o')
2132             kwargs.setdefault('linestyle', 'None')
2133             a, = self.plot(lags, correls, **kwargs)
2134             b = None
2135         return lags, correls, a, b
2136 
2137     #### Specialized plotting
2138 
2139     # @_preprocess_data() # let 'plot' do the unpacking..
2140     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2141         """
2142         Make a step plot.
2143 
2144         Call signatures::
2145 
2146             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2147             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2148 
2149         This is just a thin wrapper around `.plot` which changes some
2150         formatting options. Most of the concepts and parameters of plot can be
2151         used here as well.
2152 
2153         .. note::
2154 
2155             This method uses a standard plot with a step drawstyle: The *x*
2156             values are the reference positions and steps extend left/right/both
2157             directions depending on *where*.
2158 
2159             For the common case where you know the values and edges of the
2160             steps, use `~.Axes.stairs` instead.
2161 
2162         Parameters
2163         ----------
2164         x : array-like
2165             1D sequence of x positions. It is assumed, but not checked, that
2166             it is uniformly increasing.
2167 
2168         y : array-like
2169             1D sequence of y levels.
2170 
2171         fmt : str, optional
2172             A format string, e.g. 'g' for a green line. See `.plot` for a more
2173             detailed description.
2174 
2175             Note: While full format strings are accepted, it is recommended to
2176             only specify the color. Line styles are currently ignored (use
2177             the keyword argument *linestyle* instead). Markers are accepted
2178             and plotted on the given positions, however, this is a rarely
2179             needed feature for step plots.
2180 
2181         where : {'pre', 'post', 'mid'}, default: 'pre'
2182             Define where the steps should be placed:
2183 
2184             - 'pre': The y value is continued constantly to the left from
2185               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2186               value ``y[i]``.
2187             - 'post': The y value is continued constantly to the right from
2188               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2189               value ``y[i]``.
2190             - 'mid': Steps occur half-way between the *x* positions.
2191 
2192         data : indexable object, optional
2193             An object with labelled data. If given, provide the label names to
2194             plot in *x* and *y*.
2195 
2196         **kwargs
2197             Additional parameters are the same as those for `.plot`.
2198 
2199         Returns
2200         -------
2201         list of `.Line2D`
2202             Objects representing the plotted data.
2203         """
2204         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2205         kwargs['drawstyle'] = 'steps-' + where
2206         return self.plot(x, y, *args, data=data, **kwargs)
2207 
2208     @staticmethod
2209     def _convert_dx(dx, x0, xconv, convert):
2210         """
2211         Small helper to do logic of width conversion flexibly.
2212 
2213         *dx* and *x0* have units, but *xconv* has already been converted
2214         to unitless (and is an ndarray).  This allows the *dx* to have units
2215         that are different from *x0*, but are still accepted by the
2216         ``__add__`` operator of *x0*.
2217         """
2218 
2219         # x should be an array...
2220         assert type(xconv) is np.ndarray
2221 
2222         if xconv.size == 0:
2223             # xconv has already been converted, but maybe empty...
2224             return convert(dx)
2225 
2226         try:
2227             # attempt to add the width to x0; this works for
2228             # datetime+timedelta, for instance
2229 
2230             # only use the first element of x and x0.  This saves
2231             # having to be sure addition works across the whole
2232             # vector.  This is particularly an issue if
2233             # x0 and dx are lists so x0 + dx just concatenates the lists.
2234             # We can't just cast x0 and dx to numpy arrays because that
2235             # removes the units from unit packages like `pint` that
2236             # wrap numpy arrays.
2237             try:
2238                 x0 = cbook._safe_first_finite(x0)
2239             except (TypeError, IndexError, KeyError):
2240                 pass
2241 
2242             try:
2243                 x = cbook._safe_first_finite(xconv)
2244             except (TypeError, IndexError, KeyError):
2245                 x = xconv
2246 
2247             delist = False
2248             if not np.iterable(dx):
2249                 dx = [dx]
2250                 delist = True
2251             dx = [convert(x0 + ddx) - x for ddx in dx]
2252             if delist:
2253                 dx = dx[0]
2254         except (ValueError, TypeError, AttributeError):
2255             # if the above fails (for any reason) just fallback to what
2256             # we do by default and convert dx by itself.
2257             dx = convert(dx)
2258         return dx
2259 
2260     @_preprocess_data()
2261     @_docstring.dedent_interpd
2262     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2263             **kwargs):
2264         r"""
2265         Make a bar plot.
2266 
2267         The bars are positioned at *x* with the given *align*\ment. Their
2268         dimensions are given by *height* and *width*. The vertical baseline
2269         is *bottom* (default 0).
2270 
2271         Many parameters can take either a single value applying to all bars
2272         or a sequence of values, one for each bar.
2273 
2274         Parameters
2275         ----------
2276         x : float or array-like
2277             The x coordinates of the bars. See also *align* for the
2278             alignment of the bars to the coordinates.
2279 
2280         height : float or array-like
2281             The height(s) of the bars.
2282 
2283             Note that if *bottom* has units (e.g. datetime), *height* should be in
2284             units that are a difference from the value of *bottom* (e.g. timedelta).
2285 
2286         width : float or array-like, default: 0.8
2287             The width(s) of the bars.
2288 
2289             Note that if *x* has units (e.g. datetime), then *width* should be in
2290             units that are a difference (e.g. timedelta) around the *x* values.
2291 
2292         bottom : float or array-like, default: 0
2293             The y coordinate(s) of the bottom side(s) of the bars.
2294 
2295             Note that if *bottom* has units, then the y-axis will get a Locator and
2296             Formatter appropriate for the units (e.g. dates, or categorical).
2297 
2298         align : {'center', 'edge'}, default: 'center'
2299             Alignment of the bars to the *x* coordinates:
2300 
2301             - 'center': Center the base on the *x* positions.
2302             - 'edge': Align the left edges of the bars with the *x* positions.
2303 
2304             To align the bars on the right edge pass a negative *width* and
2305             ``align='edge'``.
2306 
2307         Returns
2308         -------
2309         `.BarContainer`
2310             Container with all the bars and optionally errorbars.
2311 
2312         Other Parameters
2313         ----------------
2314         color : color or list of color, optional
2315             The colors of the bar faces.
2316 
2317         edgecolor : color or list of color, optional
2318             The colors of the bar edges.
2319 
2320         linewidth : float or array-like, optional
2321             Width of the bar edge(s). If 0, don't draw edges.
2322 
2323         tick_label : str or list of str, optional
2324             The tick labels of the bars.
2325             Default: None (Use default numeric labels.)
2326 
2327         label : str or list of str, optional
2328             A single label is attached to the resulting `.BarContainer` as a
2329             label for the whole dataset.
2330             If a list is provided, it must be the same length as *x* and
2331             labels the individual bars. Repeated labels are not de-duplicated
2332             and will cause repeated label entries, so this is best used when
2333             bars also differ in style (e.g., by passing a list to *color*.)
2334 
2335         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2336             If not *None*, add horizontal / vertical errorbars to the bar tips.
2337             The values are +/- sizes relative to the data:
2338 
2339             - scalar: symmetric +/- values for all bars
2340             - shape(N,): symmetric +/- values for each bar
2341             - shape(2, N): Separate - and + values for each bar. First row
2342               contains the lower errors, the second row contains the upper
2343               errors.
2344             - *None*: No errorbar. (Default)
2345 
2346             See :doc:`/gallery/statistics/errorbar_features` for an example on
2347             the usage of *xerr* and *yerr*.
2348 
2349         ecolor : color or list of color, default: 'black'
2350             The line color of the errorbars.
2351 
2352         capsize : float, default: :rc:`errorbar.capsize`
2353            The length of the error bar caps in points.
2354 
2355         error_kw : dict, optional
2356             Dictionary of keyword arguments to be passed to the
2357             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2358             here take precedence over the independent keyword arguments.
2359 
2360         log : bool, default: False
2361             If *True*, set the y-axis to be log scale.
2362 
2363         data : indexable object, optional
2364             DATA_PARAMETER_PLACEHOLDER
2365 
2366         **kwargs : `.Rectangle` properties
2367 
2368         %(Rectangle:kwdoc)s
2369 
2370         See Also
2371         --------
2372         barh : Plot a horizontal bar plot.
2373 
2374         Notes
2375         -----
2376         Stacked bars can be achieved by passing individual *bottom* values per
2377         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2378         """
2379         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2380         color = kwargs.pop('color', None)
2381         if color is None:
2382             color = self._get_patches_for_fill.get_next_color()
2383         edgecolor = kwargs.pop('edgecolor', None)
2384         linewidth = kwargs.pop('linewidth', None)
2385         hatch = kwargs.pop('hatch', None)
2386 
2387         # Because xerr and yerr will be passed to errorbar, most dimension
2388         # checking and processing will be left to the errorbar method.
2389         xerr = kwargs.pop('xerr', None)
2390         yerr = kwargs.pop('yerr', None)
2391         error_kw = kwargs.pop('error_kw', {})
2392         ezorder = error_kw.pop('zorder', None)
2393         if ezorder is None:
2394             ezorder = kwargs.get('zorder', None)
2395             if ezorder is not None:
2396                 # If using the bar zorder, increment slightly to make sure
2397                 # errorbars are drawn on top of bars
2398                 ezorder += 0.01
2399         error_kw.setdefault('zorder', ezorder)
2400         ecolor = kwargs.pop('ecolor', 'k')
2401         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2402         error_kw.setdefault('ecolor', ecolor)
2403         error_kw.setdefault('capsize', capsize)
2404 
2405         # The keyword argument *orientation* is used by barh() to defer all
2406         # logic and drawing to bar(). It is considered internal and is
2407         # intentionally not mentioned in the docstring.
2408         orientation = kwargs.pop('orientation', 'vertical')
2409         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2410         log = kwargs.pop('log', False)
2411         label = kwargs.pop('label', '')
2412         tick_labels = kwargs.pop('tick_label', None)
2413 
2414         y = bottom  # Matches barh call signature.
2415         if orientation == 'vertical':
2416             if y is None:
2417                 y = 0
2418         else:  # horizontal
2419             if x is None:
2420                 x = 0
2421 
2422         if orientation == 'vertical':
2423             # It is possible for y (bottom) to contain unit information.
2424             # However, it is also possible for y=0 for the default and height
2425             # to contain unit information.  This will prioritize the units of y.
2426             self._process_unit_info(
2427                 [("x", x), ("y", y), ("y", height)], kwargs, convert=False)
2428             if log:
2429                 self.set_yscale('log', nonpositive='clip')
2430         else:  # horizontal
2431             # It is possible for x (left) to contain unit information.
2432             # However, it is also possible for x=0 for the default and width
2433             # to contain unit information.  This will prioritize the units of x.
2434             self._process_unit_info(
2435                 [("x", x), ("x", width), ("y", y)], kwargs, convert=False)
2436             if log:
2437                 self.set_xscale('log', nonpositive='clip')
2438 
2439         # lets do some conversions now since some types cannot be
2440         # subtracted uniformly
2441         if self.xaxis is not None:
2442             x0 = x
2443             x = np.asarray(self.convert_xunits(x))
2444             width = self._convert_dx(width, x0, x, self.convert_xunits)
2445             if xerr is not None:
2446                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2447         if self.yaxis is not None:
2448             y0 = y
2449             y = np.asarray(self.convert_yunits(y))
2450             height = self._convert_dx(height, y0, y, self.convert_yunits)
2451             if yerr is not None:
2452                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2453 
2454         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2455             # Make args iterable too.
2456             np.atleast_1d(x), height, width, y, linewidth, hatch)
2457 
2458         # Now that units have been converted, set the tick locations.
2459         if orientation == 'vertical':
2460             tick_label_axis = self.xaxis
2461             tick_label_position = x
2462         else:  # horizontal
2463             tick_label_axis = self.yaxis
2464             tick_label_position = y
2465 
2466         if not isinstance(label, str) and np.iterable(label):
2467             bar_container_label = '_nolegend_'
2468             patch_labels = label
2469         else:
2470             bar_container_label = label
2471             patch_labels = ['_nolegend_'] * len(x)
2472         if len(patch_labels) != len(x):
2473             raise ValueError(f'number of labels ({len(patch_labels)}) '
2474                              f'does not match number of bars ({len(x)}).')
2475 
2476         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2477         hatch = itertools.cycle(np.atleast_1d(hatch))
2478         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2479                                 # Fallback if color == "none".
2480                                 itertools.repeat('none'))
2481         if edgecolor is None:
2482             edgecolor = itertools.repeat(None)
2483         else:
2484             edgecolor = itertools.chain(
2485                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2486                 # Fallback if edgecolor == "none".
2487                 itertools.repeat('none'))
2488 
2489         # We will now resolve the alignment and really have
2490         # left, bottom, width, height vectors
2491         _api.check_in_list(['center', 'edge'], align=align)
2492         if align == 'center':
2493             if orientation == 'vertical':
2494                 try:
2495                     left = x - width / 2
2496                 except TypeError as e:
2497                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2498                                     f'and width ({width.dtype}) '
2499                                     f'are incompatible') from e
2500                 bottom = y
2501             else:  # horizontal
2502                 try:
2503                     bottom = y - height / 2
2504                 except TypeError as e:
2505                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2506                                     f'and height ({height.dtype}) '
2507                                     f'are incompatible') from e
2508                 left = x
2509         else:  # edge
2510             left = x
2511             bottom = y
2512 
2513         patches = []
2514         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2515                    hatch, patch_labels)
2516         for l, b, w, h, c, e, lw, htch, lbl in args:
2517             r = mpatches.Rectangle(
2518                 xy=(l, b), width=w, height=h,
2519                 facecolor=c,
2520                 edgecolor=e,
2521                 linewidth=lw,
2522                 label=lbl,
2523                 hatch=htch,
2524                 )
2525             r._internal_update(kwargs)
2526             r.get_path()._interpolation_steps = 100
2527             if orientation == 'vertical':
2528                 r.sticky_edges.y.append(b)
2529             else:  # horizontal
2530                 r.sticky_edges.x.append(l)
2531             self.add_patch(r)
2532             patches.append(r)
2533 
2534         if xerr is not None or yerr is not None:
2535             if orientation == 'vertical':
2536                 # using list comps rather than arrays to preserve unit info
2537                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2538                 ey = [b + h for b, h in zip(bottom, height)]
2539 
2540             else:  # horizontal
2541                 # using list comps rather than arrays to preserve unit info
2542                 ex = [l + w for l, w in zip(left, width)]
2543                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2544 
2545             error_kw.setdefault("label", '_nolegend_')
2546 
2547             errorbar = self.errorbar(ex, ey,
2548                                      yerr=yerr, xerr=xerr,
2549                                      fmt='none', **error_kw)
2550         else:
2551             errorbar = None
2552 
2553         self._request_autoscale_view()
2554 
2555         if orientation == 'vertical':
2556             datavalues = height
2557         else:  # horizontal
2558             datavalues = width
2559 
2560         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2561                                      orientation=orientation,
2562                                      label=bar_container_label)
2563         self.add_container(bar_container)
2564 
2565         if tick_labels is not None:
2566             tick_labels = np.broadcast_to(tick_labels, len(patches))
2567             tick_label_axis.set_ticks(tick_label_position)
2568             tick_label_axis.set_ticklabels(tick_labels)
2569 
2570         return bar_container
2571 
2572     # @_preprocess_data() # let 'bar' do the unpacking..
2573     @_docstring.dedent_interpd
2574     def barh(self, y, width, height=0.8, left=None, *, align="center",
2575              data=None, **kwargs):
2576         r"""
2577         Make a horizontal bar plot.
2578 
2579         The bars are positioned at *y* with the given *align*\ment. Their
2580         dimensions are given by *width* and *height*. The horizontal baseline
2581         is *left* (default 0).
2582 
2583         Many parameters can take either a single value applying to all bars
2584         or a sequence of values, one for each bar.
2585 
2586         Parameters
2587         ----------
2588         y : float or array-like
2589             The y coordinates of the bars. See also *align* for the
2590             alignment of the bars to the coordinates.
2591 
2592         width : float or array-like
2593             The width(s) of the bars.
2594 
2595             Note that if *left* has units (e.g. datetime), *width* should be in
2596             units that are a difference from the value of *left* (e.g. timedelta).
2597 
2598         height : float or array-like, default: 0.8
2599             The heights of the bars.
2600 
2601             Note that if *y* has units (e.g. datetime), then *height* should be in
2602             units that are a difference (e.g. timedelta) around the *y* values.
2603 
2604         left : float or array-like, default: 0
2605             The x coordinates of the left side(s) of the bars.
2606 
2607             Note that if *left* has units, then the x-axis will get a Locator and
2608             Formatter appropriate for the units (e.g. dates, or categorical).
2609 
2610         align : {'center', 'edge'}, default: 'center'
2611             Alignment of the base to the *y* coordinates*:
2612 
2613             - 'center': Center the bars on the *y* positions.
2614             - 'edge': Align the bottom edges of the bars with the *y*
2615               positions.
2616 
2617             To align the bars on the top edge pass a negative *height* and
2618             ``align='edge'``.
2619 
2620         Returns
2621         -------
2622         `.BarContainer`
2623             Container with all the bars and optionally errorbars.
2624 
2625         Other Parameters
2626         ----------------
2627         color : color or list of color, optional
2628             The colors of the bar faces.
2629 
2630         edgecolor : color or list of color, optional
2631             The colors of the bar edges.
2632 
2633         linewidth : float or array-like, optional
2634             Width of the bar edge(s). If 0, don't draw edges.
2635 
2636         tick_label : str or list of str, optional
2637             The tick labels of the bars.
2638             Default: None (Use default numeric labels.)
2639 
2640         label : str or list of str, optional
2641             A single label is attached to the resulting `.BarContainer` as a
2642             label for the whole dataset.
2643             If a list is provided, it must be the same length as *y* and
2644             labels the individual bars. Repeated labels are not de-duplicated
2645             and will cause repeated label entries, so this is best used when
2646             bars also differ in style (e.g., by passing a list to *color*.)
2647 
2648         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2649             If not *None*, add horizontal / vertical errorbars to the bar tips.
2650             The values are +/- sizes relative to the data:
2651 
2652             - scalar: symmetric +/- values for all bars
2653             - shape(N,): symmetric +/- values for each bar
2654             - shape(2, N): Separate - and + values for each bar. First row
2655               contains the lower errors, the second row contains the upper
2656               errors.
2657             - *None*: No errorbar. (default)
2658 
2659             See :doc:`/gallery/statistics/errorbar_features` for an example on
2660             the usage of *xerr* and *yerr*.
2661 
2662         ecolor : color or list of color, default: 'black'
2663             The line color of the errorbars.
2664 
2665         capsize : float, default: :rc:`errorbar.capsize`
2666            The length of the error bar caps in points.
2667 
2668         error_kw : dict, optional
2669             Dictionary of keyword arguments to be passed to the
2670             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2671             here take precedence over the independent keyword arguments.
2672 
2673         log : bool, default: False
2674             If ``True``, set the x-axis to be log scale.
2675 
2676         data : indexable object, optional
2677             If given, all parameters also accept a string ``s``, which is
2678             interpreted as ``data[s]`` (unless this raises an exception).
2679 
2680         **kwargs : `.Rectangle` properties
2681 
2682         %(Rectangle:kwdoc)s
2683 
2684         See Also
2685         --------
2686         bar : Plot a vertical bar plot.
2687 
2688         Notes
2689         -----
2690         Stacked bars can be achieved by passing individual *left* values per
2691         bar. See
2692         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2693         """
2694         kwargs.setdefault('orientation', 'horizontal')
2695         patches = self.bar(x=left, height=height, width=width, bottom=y,
2696                            align=align, data=data, **kwargs)
2697         return patches
2698 
2699     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2700                   padding=0, **kwargs):
2701         """
2702         Label a bar plot.
2703 
2704         Adds labels to bars in the given `.BarContainer`.
2705         You may need to adjust the axis limits to fit the labels.
2706 
2707         Parameters
2708         ----------
2709         container : `.BarContainer`
2710             Container with all the bars and optionally errorbars, likely
2711             returned from `.bar` or `.barh`.
2712 
2713         labels : array-like, optional
2714             A list of label texts, that should be displayed. If not given, the
2715             label texts will be the data values formatted with *fmt*.
2716 
2717         fmt : str or callable, default: '%g'
2718             An unnamed %-style or {}-style format string for the label or a
2719             function to call with the value as the first argument.
2720             When *fmt* is a string and can be interpreted in both formats,
2721             %-style takes precedence over {}-style.
2722 
2723             .. versionadded:: 3.7
2724                Support for {}-style format string and callables.
2725 
2726         label_type : {'edge', 'center'}, default: 'edge'
2727             The label type. Possible values:
2728 
2729             - 'edge': label placed at the end-point of the bar segment, and the
2730               value displayed will be the position of that end-point.
2731             - 'center': label placed in the center of the bar segment, and the
2732               value displayed will be the length of that segment.
2733               (useful for stacked bars, i.e.,
2734               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2735 
2736         padding : float, default: 0
2737             Distance of label from the end of the bar, in points.
2738 
2739         **kwargs
2740             Any remaining keyword arguments are passed through to
2741             `.Axes.annotate`. The alignment parameters (
2742             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2743             not supported because the labels are automatically aligned to
2744             the bars.
2745 
2746         Returns
2747         -------
2748         list of `.Text`
2749             A list of `.Text` instances for the labels.
2750         """
2751         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2752             if key in kwargs:
2753                 raise ValueError(
2754                     f"Passing {key!r} to bar_label() is not supported.")
2755 
2756         a, b = self.yaxis.get_view_interval()
2757         y_inverted = a > b
2758         c, d = self.xaxis.get_view_interval()
2759         x_inverted = c > d
2760 
2761         # want to know whether to put label on positive or negative direction
2762         # cannot use np.sign here because it will return 0 if x == 0
2763         def sign(x):
2764             return 1 if x >= 0 else -1
2765 
2766         _api.check_in_list(['edge', 'center'], label_type=label_type)
2767 
2768         bars = container.patches
2769         errorbar = container.errorbar
2770         datavalues = container.datavalues
2771         orientation = container.orientation
2772 
2773         if errorbar:
2774             # check "ErrorbarContainer" for the definition of these elements
2775             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2776             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2777             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2778             errs = barlinecol.get_segments()
2779         else:
2780             errs = []
2781 
2782         if labels is None:
2783             labels = []
2784 
2785         annotations = []
2786 
2787         for bar, err, dat, lbl in itertools.zip_longest(
2788                 bars, errs, datavalues, labels
2789         ):
2790             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2791             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2792 
2793             if orientation == "vertical":
2794                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2795                 length = abs(y0 - y1)
2796             else:  # horizontal
2797                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2798                 length = abs(x0 - x1)
2799 
2800             if err is None or np.size(err) == 0:
2801                 endpt = extrema
2802             elif orientation == "vertical":
2803                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2804             else:  # horizontal
2805                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2806 
2807             if label_type == "center":
2808                 value = sign(dat) * length
2809             else:  # edge
2810                 value = extrema
2811 
2812             if label_type == "center":
2813                 xy = (0.5, 0.5)
2814                 kwargs["xycoords"] = (
2815                     lambda r, b=bar:
2816                         mtransforms.Bbox.intersection(
2817                             b.get_window_extent(r), b.get_clip_box()
2818                         ) or mtransforms.Bbox.null()
2819                 )
2820             else:  # edge
2821                 if orientation == "vertical":
2822                     xy = xc, endpt
2823                 else:  # horizontal
2824                     xy = endpt, yc
2825 
2826             if orientation == "vertical":
2827                 y_direction = -1 if y_inverted else 1
2828                 xytext = 0, y_direction * sign(dat) * padding
2829             else:  # horizontal
2830                 x_direction = -1 if x_inverted else 1
2831                 xytext = x_direction * sign(dat) * padding, 0
2832 
2833             if label_type == "center":
2834                 ha, va = "center", "center"
2835             else:  # edge
2836                 if orientation == "vertical":
2837                     ha = 'center'
2838                     if y_inverted:
2839                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2840                     else:
2841                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2842                 else:  # horizontal
2843                     if x_inverted:
2844                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2845                     else:
2846                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2847                     va = 'center'
2848 
2849             if np.isnan(dat):
2850                 lbl = ''
2851 
2852             if lbl is None:
2853                 if isinstance(fmt, str):
2854                     lbl = cbook._auto_format_str(fmt, value)
2855                 elif callable(fmt):
2856                     lbl = fmt(value)
2857                 else:
2858                     raise TypeError("fmt must be a str or callable")
2859             annotation = self.annotate(lbl,
2860                                        xy, xytext, textcoords="offset points",
2861                                        ha=ha, va=va, **kwargs)
2862             annotations.append(annotation)
2863 
2864         return annotations
2865 
2866     @_preprocess_data()
2867     @_docstring.dedent_interpd
2868     def broken_barh(self, xranges, yrange, **kwargs):
2869         """
2870         Plot a horizontal sequence of rectangles.
2871 
2872         A rectangle is drawn for each element of *xranges*. All rectangles
2873         have the same vertical position and size defined by *yrange*.
2874 
2875         Parameters
2876         ----------
2877         xranges : sequence of tuples (*xmin*, *xwidth*)
2878             The x-positions and extents of the rectangles. For each tuple
2879             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2880             *xwidth*.
2881         yrange : (*ymin*, *yheight*)
2882             The y-position and extent for all the rectangles.
2883 
2884         Returns
2885         -------
2886         `~.collections.PolyCollection`
2887 
2888         Other Parameters
2889         ----------------
2890         data : indexable object, optional
2891             DATA_PARAMETER_PLACEHOLDER
2892         **kwargs : `.PolyCollection` properties
2893 
2894             Each *kwarg* can be either a single argument applying to all
2895             rectangles, e.g.::
2896 
2897                 facecolors='black'
2898 
2899             or a sequence of arguments over which is cycled, e.g.::
2900 
2901                 facecolors=('black', 'blue')
2902 
2903             would create interleaving black and blue rectangles.
2904 
2905             Supported keywords:
2906 
2907             %(PolyCollection:kwdoc)s
2908         """
2909         # process the unit information
2910         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2911         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2912         self._process_unit_info(
2913             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2914 
2915         vertices = []
2916         y0, dy = yrange
2917         y0, y1 = self.convert_yunits((y0, y0 + dy))
2918         for xr in xranges:  # convert the absolute values, not the x and dx
2919             try:
2920                 x0, dx = xr
2921             except Exception:
2922                 raise ValueError(
2923                     "each range in xrange must be a sequence with two "
2924                     "elements (i.e. xrange must be an (N, 2) array)") from None
2925             x0, x1 = self.convert_xunits((x0, x0 + dx))
2926             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2927 
2928         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2929         self.add_collection(col, autolim=True)
2930         self._request_autoscale_view()
2931 
2932         return col
2933 
2934     @_preprocess_data()
2935     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2936              label=None, orientation='vertical'):
2937         """
2938         Create a stem plot.
2939 
2940         A stem plot draws lines perpendicular to a baseline at each location
2941         *locs* from the baseline to *heads*, and places a marker there. For
2942         vertical stem plots (the default), the *locs* are *x* positions, and
2943         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2944         *y* positions, and the *heads* are *x* values.
2945 
2946         Call signature::
2947 
2948           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2949 
2950         The *locs*-positions are optional. *linefmt* may be provided as
2951         positional, but all other formats must be provided as keyword
2952         arguments.
2953 
2954         Parameters
2955         ----------
2956         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2957             For vertical stem plots, the x-positions of the stems.
2958             For horizontal stem plots, the y-positions of the stems.
2959 
2960         heads : array-like
2961             For vertical stem plots, the y-values of the stem heads.
2962             For horizontal stem plots, the x-values of the stem heads.
2963 
2964         linefmt : str, optional
2965             A string defining the color and/or linestyle of the vertical lines:
2966 
2967             =========  =============
2968             Character  Line Style
2969             =========  =============
2970             ``'-'``    solid line
2971             ``'--'``   dashed line
2972             ``'-.'``   dash-dot line
2973             ``':'``    dotted line
2974             =========  =============
2975 
2976             Default: 'C0-', i.e. solid line with the first color of the color
2977             cycle.
2978 
2979             Note: Markers specified through this parameter (e.g. 'x') will be
2980             silently ignored. Instead, markers should be specified using
2981             *markerfmt*.
2982 
2983         markerfmt : str, optional
2984             A string defining the color and/or shape of the markers at the stem
2985             heads. If the marker is not given, use the marker 'o', i.e. filled
2986             circles. If the color is not given, use the color from *linefmt*.
2987 
2988         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2989             A format string defining the properties of the baseline.
2990 
2991         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2992             If 'vertical', will produce a plot with stems oriented vertically,
2993             If 'horizontal', the stems will be oriented horizontally.
2994 
2995         bottom : float, default: 0
2996             The y/x-position of the baseline (depending on orientation).
2997 
2998         label : str, default: None
2999             The label to use for the stems in legends.
3000 
3001         data : indexable object, optional
3002             DATA_PARAMETER_PLACEHOLDER
3003 
3004         Returns
3005         -------
3006         `.StemContainer`
3007             The container may be treated like a tuple
3008             (*markerline*, *stemlines*, *baseline*)
3009 
3010         Notes
3011         -----
3012         .. seealso::
3013             The MATLAB function
3014             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
3015             which inspired this method.
3016         """
3017         if not 1 <= len(args) <= 3:
3018             raise _api.nargs_error('stem', '1-3', len(args))
3019         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3020 
3021         if len(args) == 1:
3022             heads, = args
3023             locs = np.arange(len(heads))
3024             args = ()
3025         elif isinstance(args[1], str):
3026             heads, *args = args
3027             locs = np.arange(len(heads))
3028         else:
3029             locs, heads, *args = args
3030 
3031         if orientation == 'vertical':
3032             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3033         else:  # horizontal
3034             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3035 
3036         # resolve line format
3037         if linefmt is None:
3038             linefmt = args[0] if len(args) > 0 else "C0-"
3039         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3040 
3041         # resolve marker format
3042         if markerfmt is None:
3043             # if not given as kwarg, fall back to 'o'
3044             markerfmt = "o"
3045         if markerfmt == '':
3046             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3047         markerstyle, markermarker, markercolor = \
3048             _process_plot_format(markerfmt)
3049         if markermarker is None:
3050             markermarker = 'o'
3051         if markerstyle is None:
3052             markerstyle = 'None'
3053         if markercolor is None:
3054             markercolor = linecolor
3055 
3056         # resolve baseline format
3057         if basefmt is None:
3058             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3059                        "C3-")
3060         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3061 
3062         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3063         if linestyle is None:
3064             linestyle = mpl.rcParams['lines.linestyle']
3065         xlines = self.vlines if orientation == "vertical" else self.hlines
3066         stemlines = xlines(
3067             locs, bottom, heads,
3068             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3069 
3070         if orientation == 'horizontal':
3071             marker_x = heads
3072             marker_y = locs
3073             baseline_x = [bottom, bottom]
3074             baseline_y = [np.min(locs), np.max(locs)]
3075         else:
3076             marker_x = locs
3077             marker_y = heads
3078             baseline_x = [np.min(locs), np.max(locs)]
3079             baseline_y = [bottom, bottom]
3080 
3081         markerline, = self.plot(marker_x, marker_y,
3082                                 color=markercolor, linestyle=markerstyle,
3083                                 marker=markermarker, label="_nolegend_")
3084 
3085         baseline, = self.plot(baseline_x, baseline_y,
3086                               color=basecolor, linestyle=basestyle,
3087                               marker=basemarker, label="_nolegend_")
3088 
3089         stem_container = StemContainer((markerline, stemlines, baseline),
3090                                        label=label)
3091         self.add_container(stem_container)
3092         return stem_container
3093 
3094     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3095     def pie(self, x, explode=None, labels=None, colors=None,
3096             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3097             startangle=0, radius=1, counterclock=True,
3098             wedgeprops=None, textprops=None, center=(0, 0),
3099             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3100         """
3101         Plot a pie chart.
3102 
3103         Make a pie chart of array *x*.  The fractional area of each wedge is
3104         given by ``x/sum(x)``.
3105 
3106         The wedges are plotted counterclockwise, by default starting from the
3107         x-axis.
3108 
3109         Parameters
3110         ----------
3111         x : 1D array-like
3112             The wedge sizes.
3113 
3114         explode : array-like, default: None
3115             If not *None*, is a ``len(x)`` array which specifies the fraction
3116             of the radius with which to offset each wedge.
3117 
3118         labels : list, default: None
3119             A sequence of strings providing the labels for each wedge
3120 
3121         colors : color or array-like of color, default: None
3122             A sequence of colors through which the pie chart will cycle.  If
3123             *None*, will use the colors in the currently active cycle.
3124 
3125         hatch : str or list, default: None
3126             Hatching pattern applied to all pie wedges or sequence of patterns
3127             through which the chart will cycle. For a list of valid patterns,
3128             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3129 
3130             .. versionadded:: 3.7
3131 
3132         autopct : None or str or callable, default: None
3133             If not *None*, *autopct* is a string or function used to label the
3134             wedges with their numeric value. The label will be placed inside
3135             the wedge. If *autopct* is a format string, the label will be
3136             ``fmt % pct``. If *autopct* is a function, then it will be called.
3137 
3138         pctdistance : float, default: 0.6
3139             The relative distance along the radius at which the text
3140             generated by *autopct* is drawn. To draw the text outside the pie,
3141             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3142             ``None``.
3143 
3144         labeldistance : float or None, default: 1.1
3145             The relative distance along the radius at which the labels are
3146             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3147             If set to ``None``, labels are not drawn but are still stored for
3148             use in `.legend`.
3149 
3150         shadow : bool or dict, default: False
3151             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3152             passing the properties in the dict to `.Shadow`.
3153 
3154             .. versionadded:: 3.8
3155                 *shadow* can be a dict.
3156 
3157         startangle : float, default: 0 degrees
3158             The angle by which the start of the pie is rotated,
3159             counterclockwise from the x-axis.
3160 
3161         radius : float, default: 1
3162             The radius of the pie.
3163 
3164         counterclock : bool, default: True
3165             Specify fractions direction, clockwise or counterclockwise.
3166 
3167         wedgeprops : dict, default: None
3168             Dict of arguments passed to each `.patches.Wedge` of the pie.
3169             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3170             the wedge border lines equal to 3. By default, ``clip_on=False``.
3171             When there is a conflict between these properties and other
3172             keywords, properties passed to *wedgeprops* take precedence.
3173 
3174         textprops : dict, default: None
3175             Dict of arguments to pass to the text objects.
3176 
3177         center : (float, float), default: (0, 0)
3178             The coordinates of the center of the chart.
3179 
3180         frame : bool, default: False
3181             Plot Axes frame with the chart if true.
3182 
3183         rotatelabels : bool, default: False
3184             Rotate each label to the angle of the corresponding slice if true.
3185 
3186         normalize : bool, default: True
3187             When *True*, always make a full pie by normalizing x so that
3188             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3189             and raises a `ValueError` for ``sum(x) > 1``.
3190 
3191         data : indexable object, optional
3192             DATA_PARAMETER_PLACEHOLDER
3193 
3194         Returns
3195         -------
3196         patches : list
3197             A sequence of `matplotlib.patches.Wedge` instances
3198 
3199         texts : list
3200             A list of the label `.Text` instances.
3201 
3202         autotexts : list
3203             A list of `.Text` instances for the numeric labels. This will only
3204             be returned if the parameter *autopct* is not *None*.
3205 
3206         Notes
3207         -----
3208         The pie chart will probably look best if the figure and Axes are
3209         square, or the Axes aspect is equal.
3210         This method sets the aspect ratio of the axis to "equal".
3211         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3212         """
3213         self.set_aspect('equal')
3214         # The use of float32 is "historical", but can't be changed without
3215         # regenerating the test baselines.
3216         x = np.asarray(x, np.float32)
3217         if x.ndim > 1:
3218             raise ValueError("x must be 1D")
3219 
3220         if np.any(x < 0):
3221             raise ValueError("Wedge sizes 'x' must be non negative values")
3222 
3223         sx = x.sum()
3224 
3225         if normalize:
3226             x = x / sx
3227         elif sx > 1:
3228             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3229         if labels is None:
3230             labels = [''] * len(x)
3231         if explode is None:
3232             explode = [0] * len(x)
3233         if len(x) != len(labels):
3234             raise ValueError("'label' must be of length 'x'")
3235         if len(x) != len(explode):
3236             raise ValueError("'explode' must be of length 'x'")
3237         if colors is None:
3238             get_next_color = self._get_patches_for_fill.get_next_color
3239         else:
3240             color_cycle = itertools.cycle(colors)
3241 
3242             def get_next_color():
3243                 return next(color_cycle)
3244 
3245         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3246 
3247         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3248         if radius <= 0:
3249             raise ValueError(f'radius must be a positive number, not {radius}')
3250 
3251         # Starting theta1 is the start fraction of the circle
3252         theta1 = startangle / 360
3253 
3254         if wedgeprops is None:
3255             wedgeprops = {}
3256         if textprops is None:
3257             textprops = {}
3258 
3259         texts = []
3260         slices = []
3261         autotexts = []
3262 
3263         for frac, label, expl in zip(x, labels, explode):
3264             x, y = center
3265             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3266             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3267             x += expl * math.cos(thetam)
3268             y += expl * math.sin(thetam)
3269 
3270             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3271                                360. * max(theta1, theta2),
3272                                facecolor=get_next_color(),
3273                                hatch=next(hatch_cycle),
3274                                clip_on=False,
3275                                label=label)
3276             w.set(**wedgeprops)
3277             slices.append(w)
3278             self.add_patch(w)
3279 
3280             if shadow:
3281                 # Make sure to add a shadow after the call to add_patch so the
3282                 # figure and transform props will be set.
3283                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3284                 if isinstance(shadow, dict):
3285                     shadow_dict.update(shadow)
3286                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3287 
3288             if labeldistance is not None:
3289                 xt = x + labeldistance * radius * math.cos(thetam)
3290                 yt = y + labeldistance * radius * math.sin(thetam)
3291                 label_alignment_h = 'left' if xt > 0 else 'right'
3292                 label_alignment_v = 'center'
3293                 label_rotation = 'horizontal'
3294                 if rotatelabels:
3295                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3296                     label_rotation = (np.rad2deg(thetam)
3297                                       + (0 if xt > 0 else 180))
3298                 t = self.text(xt, yt, label,
3299                               clip_on=False,
3300                               horizontalalignment=label_alignment_h,
3301                               verticalalignment=label_alignment_v,
3302                               rotation=label_rotation,
3303                               size=mpl.rcParams['xtick.labelsize'])
3304                 t.set(**textprops)
3305                 texts.append(t)
3306 
3307             if autopct is not None:
3308                 xt = x + pctdistance * radius * math.cos(thetam)
3309                 yt = y + pctdistance * radius * math.sin(thetam)
3310                 if isinstance(autopct, str):
3311                     s = autopct % (100. * frac)
3312                 elif callable(autopct):
3313                     s = autopct(100. * frac)
3314                 else:
3315                     raise TypeError(
3316                         'autopct must be callable or a format string')
3317                 t = self.text(xt, yt, s,
3318                               clip_on=False,
3319                               horizontalalignment='center',
3320                               verticalalignment='center')
3321                 t.set(**textprops)
3322                 autotexts.append(t)
3323 
3324             theta1 = theta2
3325 
3326         if frame:
3327             self._request_autoscale_view()
3328         else:
3329             self.set(frame_on=False, xticks=[], yticks=[],
3330                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3331                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3332 
3333         if autopct is None:
3334             return slices, texts
3335         else:
3336             return slices, texts, autotexts
3337 
3338     @staticmethod
3339     def _errorevery_to_mask(x, errorevery):
3340         """
3341         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3342 
3343         This function is split out to be usable both by 2D and 3D errorbars.
3344         """
3345         if isinstance(errorevery, Integral):
3346             errorevery = (0, errorevery)
3347         if isinstance(errorevery, tuple):
3348             if (len(errorevery) == 2 and
3349                     isinstance(errorevery[0], Integral) and
3350                     isinstance(errorevery[1], Integral)):
3351                 errorevery = slice(errorevery[0], None, errorevery[1])
3352             else:
3353                 raise ValueError(
3354                     f'{errorevery=!r} is a not a tuple of two integers')
3355         elif isinstance(errorevery, slice):
3356             pass
3357         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3358             try:
3359                 x[errorevery]  # fancy indexing
3360             except (ValueError, IndexError) as err:
3361                 raise ValueError(
3362                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3363                     "index to match 'xerr'/'yerr'") from err
3364         else:
3365             raise ValueError(f"{errorevery=!r} is not a recognized value")
3366         everymask = np.zeros(len(x), bool)
3367         everymask[errorevery] = True
3368         return everymask
3369 
3370     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3371                       label_namer="y")
3372     @_docstring.dedent_interpd
3373     def errorbar(self, x, y, yerr=None, xerr=None,
3374                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3375                  barsabove=False, lolims=False, uplims=False,
3376                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3377                  **kwargs):
3378         """
3379         Plot y versus x as lines and/or markers with attached errorbars.
3380 
3381         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3382         sizes. By default, this draws the data markers/lines as well the
3383         errorbars. Use fmt='none' to draw errorbars without any data markers.
3384 
3385         .. versionadded:: 3.7
3386            Caps and error lines are drawn in polar coordinates on polar plots.
3387 
3388 
3389         Parameters
3390         ----------
3391         x, y : float or array-like
3392             The data positions.
3393 
3394         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3395             The errorbar sizes:
3396 
3397             - scalar: Symmetric +/- values for all data points.
3398             - shape(N,): Symmetric +/-values for each data point.
3399             - shape(2, N): Separate - and + values for each bar. First row
3400               contains the lower errors, the second row contains the upper
3401               errors.
3402             - *None*: No errorbar.
3403 
3404             All values must be >= 0.
3405 
3406             See :doc:`/gallery/statistics/errorbar_features`
3407             for an example on the usage of ``xerr`` and ``yerr``.
3408 
3409         fmt : str, default: ''
3410             The format for the data points / data lines. See `.plot` for
3411             details.
3412 
3413             Use 'none' (case-insensitive) to plot errorbars without any data
3414             markers.
3415 
3416         ecolor : color, default: None
3417             The color of the errorbar lines.  If None, use the color of the
3418             line connecting the markers.
3419 
3420         elinewidth : float, default: None
3421             The linewidth of the errorbar lines. If None, the linewidth of
3422             the current style is used.
3423 
3424         capsize : float, default: :rc:`errorbar.capsize`
3425             The length of the error bar caps in points.
3426 
3427         capthick : float, default: None
3428             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3429             This setting is a more sensible name for the property that
3430             controls the thickness of the error bar cap in points. For
3431             backwards compatibility, if *mew* or *markeredgewidth* are given,
3432             then they will over-ride *capthick*. This may change in future
3433             releases.
3434 
3435         barsabove : bool, default: False
3436             If True, will plot the errorbars above the plot
3437             symbols. Default is below.
3438 
3439         lolims, uplims, xlolims, xuplims : bool, default: False
3440             These arguments can be used to indicate that a value gives only
3441             upper/lower limits.  In that case a caret symbol is used to
3442             indicate this. *lims*-arguments may be scalars, or array-likes of
3443             the same length as *xerr* and *yerr*.  To use limits with inverted
3444             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3445             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3446             *lolims* to True means that the y-value is a *lower* limit of the
3447             True value, so, only an *upward*-pointing arrow will be drawn!
3448 
3449         errorevery : int or (int, int), default: 1
3450             draws error bars on a subset of the data. *errorevery* =N draws
3451             error bars on the points (x[::N], y[::N]).
3452             *errorevery* =(start, N) draws error bars on the points
3453             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3454             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3455             Used to avoid overlapping error bars when two series share x-axis
3456             values.
3457 
3458         Returns
3459         -------
3460         `.ErrorbarContainer`
3461             The container contains:
3462 
3463             - plotline: `~matplotlib.lines.Line2D` instance of x, y plot markers
3464               and/or line.
3465             - caplines: A tuple of `~matplotlib.lines.Line2D` instances of the error
3466               bar caps.
3467             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3468               vertical error ranges.
3469 
3470         Other Parameters
3471         ----------------
3472         data : indexable object, optional
3473             DATA_PARAMETER_PLACEHOLDER
3474 
3475         **kwargs
3476             All other keyword arguments are passed on to the `~.Axes.plot` call
3477             drawing the markers. For example, this code makes big red squares
3478             with thick green edges::
3479 
3480                 x, y, yerr = rand(3, 10)
3481                 errorbar(x, y, yerr, marker='s', mfc='red',
3482                          mec='green', ms=20, mew=4)
3483 
3484             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3485             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3486             and *markeredgewidth*.
3487 
3488             Valid kwargs for the marker properties are:
3489 
3490             - *dashes*
3491             - *dash_capstyle*
3492             - *dash_joinstyle*
3493             - *drawstyle*
3494             - *fillstyle*
3495             - *linestyle*
3496             - *marker*
3497             - *markeredgecolor*
3498             - *markeredgewidth*
3499             - *markerfacecolor*
3500             - *markerfacecoloralt*
3501             - *markersize*
3502             - *markevery*
3503             - *solid_capstyle*
3504             - *solid_joinstyle*
3505 
3506             Refer to the corresponding `.Line2D` property for more details:
3507 
3508             %(Line2D:kwdoc)s
3509         """
3510         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3511         # Drop anything that comes in as None to use the default instead.
3512         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3513         kwargs.setdefault('zorder', 2)
3514 
3515         # Casting to object arrays preserves units.
3516         if not isinstance(x, np.ndarray):
3517             x = np.asarray(x, dtype=object)
3518         if not isinstance(y, np.ndarray):
3519             y = np.asarray(y, dtype=object)
3520 
3521         def _upcast_err(err):
3522             """
3523             Safely handle tuple of containers that carry units.
3524 
3525             This function covers the case where the input to the xerr/yerr is a
3526             length 2 tuple of equal length ndarray-subclasses that carry the
3527             unit information in the container.
3528 
3529             If we have a tuple of nested numpy array (subclasses), we defer
3530             coercing the units to be consistent to the underlying unit
3531             library (and implicitly the broadcasting).
3532 
3533             Otherwise, fallback to casting to an object array.
3534             """
3535 
3536             if (
3537                     # make sure it is not a scalar
3538                     np.iterable(err) and
3539                     # and it is not empty
3540                     len(err) > 0 and
3541                     # and the first element is an array sub-class use
3542                     # safe_first_element because getitem is index-first not
3543                     # location first on pandas objects so err[0] almost always
3544                     # fails.
3545                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3546             ):
3547                 # Get the type of the first element
3548                 atype = type(cbook._safe_first_finite(err))
3549                 # Promote the outer container to match the inner container
3550                 if atype is np.ndarray:
3551                     # Converts using np.asarray, because data cannot
3552                     # be directly passed to init of np.ndarray
3553                     return np.asarray(err, dtype=object)
3554                 # If atype is not np.ndarray, directly pass data to init.
3555                 # This works for types such as unyts and astropy units
3556                 return atype(err)
3557             # Otherwise wrap it in an object array
3558             return np.asarray(err, dtype=object)
3559 
3560         if xerr is not None and not isinstance(xerr, np.ndarray):
3561             xerr = _upcast_err(xerr)
3562         if yerr is not None and not isinstance(yerr, np.ndarray):
3563             yerr = _upcast_err(yerr)
3564         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3565         if len(x) != len(y):
3566             raise ValueError("'x' and 'y' must have the same size")
3567 
3568         everymask = self._errorevery_to_mask(x, errorevery)
3569 
3570         label = kwargs.pop("label", None)
3571         kwargs['label'] = '_nolegend_'
3572 
3573         # Create the main line and determine overall kwargs for child artists.
3574         # We avoid calling self.plot() directly, or self._get_lines(), because
3575         # that would call self._process_unit_info again, and do other indirect
3576         # data processing.
3577         (data_line, base_style), = self._get_lines._plot_args(
3578             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3579 
3580         # Do this after creating `data_line` to avoid modifying `base_style`.
3581         if barsabove:
3582             data_line.set_zorder(kwargs['zorder'] - .1)
3583         else:
3584             data_line.set_zorder(kwargs['zorder'] + .1)
3585 
3586         # Add line to plot, or throw it away and use it to determine kwargs.
3587         if fmt.lower() != 'none':
3588             self.add_line(data_line)
3589         else:
3590             data_line = None
3591             # Remove alpha=0 color that _get_lines._plot_args returns for
3592             # 'none' format, and replace it with user-specified color, if
3593             # supplied.
3594             base_style.pop('color')
3595             if 'color' in kwargs:
3596                 base_style['color'] = kwargs.pop('color')
3597 
3598         if 'color' not in base_style:
3599             base_style['color'] = 'C0'
3600         if ecolor is None:
3601             ecolor = base_style['color']
3602 
3603         # Eject any line-specific information from format string, as it's not
3604         # needed for bars or caps.
3605         for key in ['marker', 'markersize', 'markerfacecolor',
3606                     'markerfacecoloralt',
3607                     'markeredgewidth', 'markeredgecolor', 'markevery',
3608                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3609                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3610                     'dashes']:
3611             base_style.pop(key, None)
3612 
3613         # Make the style dict for the line collections (the bars).
3614         eb_lines_style = {**base_style, 'color': ecolor}
3615 
3616         if elinewidth is not None:
3617             eb_lines_style['linewidth'] = elinewidth
3618         elif 'linewidth' in kwargs:
3619             eb_lines_style['linewidth'] = kwargs['linewidth']
3620 
3621         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3622             if key in kwargs:
3623                 eb_lines_style[key] = kwargs[key]
3624 
3625         # Make the style dict for caps (the "hats").
3626         eb_cap_style = {**base_style, 'linestyle': 'none'}
3627         if capsize is None:
3628             capsize = mpl.rcParams["errorbar.capsize"]
3629         if capsize > 0:
3630             eb_cap_style['markersize'] = 2. * capsize
3631         if capthick is not None:
3632             eb_cap_style['markeredgewidth'] = capthick
3633 
3634         # For backwards-compat, allow explicit setting of
3635         # 'markeredgewidth' to over-ride capthick.
3636         for key in ('markeredgewidth', 'transform', 'alpha',
3637                     'zorder', 'rasterized'):
3638             if key in kwargs:
3639                 eb_cap_style[key] = kwargs[key]
3640         eb_cap_style['color'] = ecolor
3641 
3642         barcols = []
3643         caplines = {'x': [], 'y': []}
3644 
3645         # Vectorized fancy-indexer.
3646         def apply_mask(arrays, mask):
3647             return [array[mask] for array in arrays]
3648 
3649         # dep: dependent dataset, indep: independent dataset
3650         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3651              marker, lomarker, himarker) in [
3652                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3653                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3654                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3655                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3656         ]:
3657             if err is None:
3658                 continue
3659             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3660             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3661             try:
3662                 np.broadcast_to(err, (2, len(dep)))
3663             except ValueError:
3664                 raise ValueError(
3665                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3666                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3667                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3668             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3669             if np.any(np.less(err, -err, out=res, where=(err == err))):
3670                 # like err<0, but also works for timedelta and nan.
3671                 raise ValueError(
3672                     f"'{dep_axis}err' must not contain negative values")
3673             # This is like
3674             #     elow, ehigh = np.broadcast_to(...)
3675             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3676             # except that broadcast_to would strip units.
3677             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3678             barcols.append(lines_func(
3679                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3680             if self.name == "polar" and dep_axis == "x":
3681                 for b in barcols:
3682                     for p in b.get_paths():
3683                         p._interpolation_steps = 2
3684             # Normal errorbars for points without upper/lower limits.
3685             nolims = ~(lolims | uplims)
3686             if nolims.any() and capsize > 0:
3687                 indep_masked, lo_masked, hi_masked = apply_mask(
3688                     [indep, low, high], nolims & everymask)
3689                 for lh_masked in [lo_masked, hi_masked]:
3690                     # Since this has to work for x and y as dependent data, we
3691                     # first set both x and y to the independent variable and
3692                     # overwrite the respective dependent data in a second step.
3693                     line = mlines.Line2D(indep_masked, indep_masked,
3694                                          marker=marker, **eb_cap_style)
3695                     line.set(**{f"{dep_axis}data": lh_masked})
3696                     caplines[dep_axis].append(line)
3697             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3698                 if not lims.any():
3699                     continue
3700                 hlmarker = (
3701                     himarker
3702                     if self._axis_map[dep_axis].get_inverted() ^ idx
3703                     else lomarker)
3704                 x_masked, y_masked, hl_masked = apply_mask(
3705                     [x, y, hl], lims & everymask)
3706                 # As above, we set the dependent data in a second step.
3707                 line = mlines.Line2D(x_masked, y_masked,
3708                                      marker=hlmarker, **eb_cap_style)
3709                 line.set(**{f"{dep_axis}data": hl_masked})
3710                 caplines[dep_axis].append(line)
3711                 if capsize > 0:
3712                     caplines[dep_axis].append(mlines.Line2D(
3713                         x_masked, y_masked, marker=marker, **eb_cap_style))
3714         if self.name == 'polar':
3715             for axis in caplines:
3716                 for l in caplines[axis]:
3717                     # Rotate caps to be perpendicular to the error bars
3718                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3719                         rotation = mtransforms.Affine2D().rotate(theta)
3720                         if axis == 'y':
3721                             rotation.rotate(-np.pi / 2)
3722                         ms = mmarkers.MarkerStyle(marker=marker,
3723                                                   transform=rotation)
3724                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3725                                                     **eb_cap_style))
3726         else:
3727             for axis in caplines:
3728                 for l in caplines[axis]:
3729                     self.add_line(l)
3730 
3731         self._request_autoscale_view()
3732         caplines = caplines['x'] + caplines['y']
3733         errorbar_container = ErrorbarContainer(
3734             (data_line, tuple(caplines), tuple(barcols)),
3735             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3736             label=label)
3737         self.containers.append(errorbar_container)
3738 
3739         return errorbar_container  # (l0, caplines, barcols)
3740 
3741     @_preprocess_data()
3742     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3743                 positions=None, widths=None, patch_artist=None,
3744                 bootstrap=None, usermedians=None, conf_intervals=None,
3745                 meanline=None, showmeans=None, showcaps=None,
3746                 showbox=None, showfliers=None, boxprops=None,
3747                 labels=None, flierprops=None, medianprops=None,
3748                 meanprops=None, capprops=None, whiskerprops=None,
3749                 manage_ticks=True, autorange=False, zorder=None,
3750                 capwidths=None):
3751         """
3752         Draw a box and whisker plot.
3753 
3754         The box extends from the first quartile (Q1) to the third
3755         quartile (Q3) of the data, with a line at the median.
3756         The whiskers extend from the box to the farthest data point
3757         lying within 1.5x the inter-quartile range (IQR) from the box.
3758         Flier points are those past the end of the whiskers.
3759         See https://en.wikipedia.org/wiki/Box_plot for reference.
3760 
3761         .. code-block:: none
3762 
3763                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3764                                |-----:-----|
3765                o      |--------|     :     |--------|    o  o
3766                                |-----:-----|
3767              flier             <----------->            fliers
3768                                     IQR
3769 
3770 
3771         Parameters
3772         ----------
3773         x : Array or a sequence of vectors.
3774             The input data.  If a 2D array, a boxplot is drawn for each column
3775             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3776             array in *x*.
3777 
3778         notch : bool, default: False
3779             Whether to draw a notched boxplot (`True`), or a rectangular
3780             boxplot (`False`).  The notches represent the confidence interval
3781             (CI) around the median.  The documentation for *bootstrap*
3782             describes how the locations of the notches are computed by
3783             default, but their locations may also be overridden by setting the
3784             *conf_intervals* parameter.
3785 
3786             .. note::
3787 
3788                 In cases where the values of the CI are less than the
3789                 lower quartile or greater than the upper quartile, the
3790                 notches will extend beyond the box, giving it a
3791                 distinctive "flipped" appearance. This is expected
3792                 behavior and consistent with other statistical
3793                 visualization packages.
3794 
3795         sym : str, optional
3796             The default symbol for flier points.  An empty string ('') hides
3797             the fliers.  If `None`, then the fliers default to 'b+'.  More
3798             control is provided by the *flierprops* parameter.
3799 
3800         vert : bool, default: True
3801             If `True`, draws vertical boxes.
3802             If `False`, draw horizontal boxes.
3803 
3804         whis : float or (float, float), default: 1.5
3805             The position of the whiskers.
3806 
3807             If a float, the lower whisker is at the lowest datum above
3808             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3809             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3810             third quartiles.  The default value of ``whis = 1.5`` corresponds
3811             to Tukey's original definition of boxplots.
3812 
3813             If a pair of floats, they indicate the percentiles at which to
3814             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3815             (0, 100) results in whiskers covering the whole range of the data.
3816 
3817             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3818             to (0, 100) (cover the whole range of the data) if *autorange* is
3819             True.
3820 
3821             Beyond the whiskers, data are considered outliers and are plotted
3822             as individual points.
3823 
3824         bootstrap : int, optional
3825             Specifies whether to bootstrap the confidence intervals
3826             around the median for notched boxplots. If *bootstrap* is
3827             None, no bootstrapping is performed, and notches are
3828             calculated using a Gaussian-based asymptotic approximation
3829             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3830             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3831             the number of times to bootstrap the median to determine its
3832             95% confidence intervals. Values between 1000 and 10000 are
3833             recommended.
3834 
3835         usermedians : 1D array-like, optional
3836             A 1D array-like of length ``len(x)``.  Each entry that is not
3837             `None` forces the value of the median for the corresponding
3838             dataset.  For entries that are `None`, the medians are computed
3839             by Matplotlib as normal.
3840 
3841         conf_intervals : array-like, optional
3842             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3843             None forces the location of the corresponding notch (which is
3844             only drawn if *notch* is `True`).  For entries that are `None`,
3845             the notches are computed by the method specified by the other
3846             parameters (e.g., *bootstrap*).
3847 
3848         positions : array-like, optional
3849             The positions of the boxes. The ticks and limits are
3850             automatically set to match the positions. Defaults to
3851             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3852 
3853         widths : float or array-like
3854             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3855             between extreme positions)``, if that is smaller.
3856 
3857         patch_artist : bool, default: False
3858             If `False` produces boxes with the Line2D artist. Otherwise,
3859             boxes are drawn with Patch artists.
3860 
3861         labels : sequence, optional
3862             Labels for each dataset (one per dataset).
3863 
3864         manage_ticks : bool, default: True
3865             If True, the tick locations and labels will be adjusted to match
3866             the boxplot positions.
3867 
3868         autorange : bool, default: False
3869             When `True` and the data are distributed such that the 25th and
3870             75th percentiles are equal, *whis* is set to (0, 100) such
3871             that the whisker ends are at the minimum and maximum of the data.
3872 
3873         meanline : bool, default: False
3874             If `True` (and *showmeans* is `True`), will try to render the
3875             mean as a line spanning the full width of the box according to
3876             *meanprops* (see below).  Not recommended if *shownotches* is also
3877             True.  Otherwise, means will be shown as points.
3878 
3879         zorder : float, default: ``Line2D.zorder = 2``
3880             The zorder of the boxplot.
3881 
3882         Returns
3883         -------
3884         dict
3885           A dictionary mapping each component of the boxplot to a list
3886           of the `.Line2D` instances created. That dictionary has the
3887           following keys (assuming vertical boxplots):
3888 
3889           - ``boxes``: the main body of the boxplot showing the
3890             quartiles and the median's confidence intervals if
3891             enabled.
3892 
3893           - ``medians``: horizontal lines at the median of each box.
3894 
3895           - ``whiskers``: the vertical lines extending to the most
3896             extreme, non-outlier data points.
3897 
3898           - ``caps``: the horizontal lines at the ends of the
3899             whiskers.
3900 
3901           - ``fliers``: points representing data that extend beyond
3902             the whiskers (fliers).
3903 
3904           - ``means``: points or lines representing the means.
3905 
3906         Other Parameters
3907         ----------------
3908         showcaps : bool, default: True
3909             Show the caps on the ends of whiskers.
3910         showbox : bool, default: True
3911             Show the central box.
3912         showfliers : bool, default: True
3913             Show the outliers beyond the caps.
3914         showmeans : bool, default: False
3915             Show the arithmetic means.
3916         capprops : dict, default: None
3917             The style of the caps.
3918         capwidths : float or array, default: None
3919             The widths of the caps.
3920         boxprops : dict, default: None
3921             The style of the box.
3922         whiskerprops : dict, default: None
3923             The style of the whiskers.
3924         flierprops : dict, default: None
3925             The style of the fliers.
3926         medianprops : dict, default: None
3927             The style of the median.
3928         meanprops : dict, default: None
3929             The style of the mean.
3930         data : indexable object, optional
3931             DATA_PARAMETER_PLACEHOLDER
3932 
3933         See Also
3934         --------
3935         violinplot : Draw an estimate of the probability density function.
3936         """
3937 
3938         # Missing arguments default to rcParams.
3939         if whis is None:
3940             whis = mpl.rcParams['boxplot.whiskers']
3941         if bootstrap is None:
3942             bootstrap = mpl.rcParams['boxplot.bootstrap']
3943 
3944         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3945                                        labels=labels, autorange=autorange)
3946         if notch is None:
3947             notch = mpl.rcParams['boxplot.notch']
3948         if vert is None:
3949             vert = mpl.rcParams['boxplot.vertical']
3950         if patch_artist is None:
3951             patch_artist = mpl.rcParams['boxplot.patchartist']
3952         if meanline is None:
3953             meanline = mpl.rcParams['boxplot.meanline']
3954         if showmeans is None:
3955             showmeans = mpl.rcParams['boxplot.showmeans']
3956         if showcaps is None:
3957             showcaps = mpl.rcParams['boxplot.showcaps']
3958         if showbox is None:
3959             showbox = mpl.rcParams['boxplot.showbox']
3960         if showfliers is None:
3961             showfliers = mpl.rcParams['boxplot.showfliers']
3962 
3963         if boxprops is None:
3964             boxprops = {}
3965         if whiskerprops is None:
3966             whiskerprops = {}
3967         if capprops is None:
3968             capprops = {}
3969         if medianprops is None:
3970             medianprops = {}
3971         if meanprops is None:
3972             meanprops = {}
3973         if flierprops is None:
3974             flierprops = {}
3975 
3976         if patch_artist:
3977             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3978             if 'color' in boxprops:
3979                 boxprops['edgecolor'] = boxprops.pop('color')
3980 
3981         # if non-default sym value, put it into the flier dictionary
3982         # the logic for providing the default symbol ('b+') now lives
3983         # in bxp in the initial value of flierkw
3984         # handle all of the *sym* related logic here so we only have to pass
3985         # on the flierprops dict.
3986         if sym is not None:
3987             # no-flier case, which should really be done with
3988             # 'showfliers=False' but none-the-less deal with it to keep back
3989             # compatibility
3990             if sym == '':
3991                 # blow away existing dict and make one for invisible markers
3992                 flierprops = dict(linestyle='none', marker='', color='none')
3993                 # turn the fliers off just to be safe
3994                 showfliers = False
3995             # now process the symbol string
3996             else:
3997                 # process the symbol string
3998                 # discarded linestyle
3999                 _, marker, color = _process_plot_format(sym)
4000                 # if we have a marker, use it
4001                 if marker is not None:
4002                     flierprops['marker'] = marker
4003                 # if we have a color, use it
4004                 if color is not None:
4005                     # assume that if color is passed in the user want
4006                     # filled symbol, if the users want more control use
4007                     # flierprops
4008                     flierprops['color'] = color
4009                     flierprops['markerfacecolor'] = color
4010                     flierprops['markeredgecolor'] = color
4011 
4012         # replace medians if necessary:
4013         if usermedians is not None:
4014             if (len(np.ravel(usermedians)) != len(bxpstats) or
4015                     np.shape(usermedians)[0] != len(bxpstats)):
4016                 raise ValueError(
4017                     "'usermedians' and 'x' have different lengths")
4018             else:
4019                 # reassign medians as necessary
4020                 for stats, med in zip(bxpstats, usermedians):
4021                     if med is not None:
4022                         stats['med'] = med
4023 
4024         if conf_intervals is not None:
4025             if len(conf_intervals) != len(bxpstats):
4026                 raise ValueError(
4027                     "'conf_intervals' and 'x' have different lengths")
4028             else:
4029                 for stats, ci in zip(bxpstats, conf_intervals):
4030                     if ci is not None:
4031                         if len(ci) != 2:
4032                             raise ValueError('each confidence interval must '
4033                                              'have two values')
4034                         else:
4035                             if ci[0] is not None:
4036                                 stats['cilo'] = ci[0]
4037                             if ci[1] is not None:
4038                                 stats['cihi'] = ci[1]
4039 
4040         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4041                            vert=vert, patch_artist=patch_artist,
4042                            shownotches=notch, showmeans=showmeans,
4043                            showcaps=showcaps, showbox=showbox,
4044                            boxprops=boxprops, flierprops=flierprops,
4045                            medianprops=medianprops, meanprops=meanprops,
4046                            meanline=meanline, showfliers=showfliers,
4047                            capprops=capprops, whiskerprops=whiskerprops,
4048                            manage_ticks=manage_ticks, zorder=zorder,
4049                            capwidths=capwidths)
4050         return artists
4051 
4052     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4053             patch_artist=False, shownotches=False, showmeans=False,
4054             showcaps=True, showbox=True, showfliers=True,
4055             boxprops=None, whiskerprops=None, flierprops=None,
4056             medianprops=None, capprops=None, meanprops=None,
4057             meanline=False, manage_ticks=True, zorder=None,
4058             capwidths=None):
4059         """
4060         Drawing function for box and whisker plots.
4061 
4062         Make a box and whisker plot for each column of *x* or each
4063         vector in sequence *x*.  The box extends from the lower to
4064         upper quartile values of the data, with a line at the median.
4065         The whiskers extend from the box to show the range of the
4066         data.  Flier points are those past the end of the whiskers.
4067 
4068         Parameters
4069         ----------
4070         bxpstats : list of dicts
4071           A list of dictionaries containing stats for each boxplot.
4072           Required keys are:
4073 
4074           - ``med``: Median (scalar).
4075           - ``q1``, ``q3``: First & third quartiles (scalars).
4076           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4077 
4078           Optional keys are:
4079 
4080           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4081           - ``fliers``: Data beyond the whiskers (array-like).
4082             Needed if ``showfliers=True``.
4083           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4084             about the median. Needed if ``shownotches=True``.
4085           - ``label``: Name of the dataset (str).  If available,
4086             this will be used a tick label for the boxplot
4087 
4088         positions : array-like, default: [1, 2, ..., n]
4089           The positions of the boxes. The ticks and limits
4090           are automatically set to match the positions.
4091 
4092         widths : float or array-like, default: None
4093           The widths of the boxes.  The default is
4094           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4095 
4096         capwidths : float or array-like, default: None
4097           Either a scalar or a vector and sets the width of each cap.
4098           The default is ``0.5*(with of the box)``, see *widths*.
4099 
4100         vert : bool, default: True
4101           If `True` (default), makes the boxes vertical.
4102           If `False`, makes horizontal boxes.
4103 
4104         patch_artist : bool, default: False
4105           If `False` produces boxes with the `.Line2D` artist.
4106           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4107 
4108         shownotches, showmeans, showcaps, showbox, showfliers : bool
4109           Whether to draw the CI notches, the mean value (both default to
4110           False), the caps, the box, and the fliers (all three default to
4111           True).
4112 
4113         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4114  dict, optional
4115           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4116           means.
4117 
4118         meanline : bool, default: False
4119           If `True` (and *showmeans* is `True`), will try to render the mean
4120           as a line spanning the full width of the box according to
4121           *meanprops*. Not recommended if *shownotches* is also True.
4122           Otherwise, means will be shown as points.
4123 
4124         manage_ticks : bool, default: True
4125           If True, the tick locations and labels will be adjusted to match the
4126           boxplot positions.
4127 
4128         zorder : float, default: ``Line2D.zorder = 2``
4129           The zorder of the resulting boxplot.
4130 
4131         Returns
4132         -------
4133         dict
4134           A dictionary mapping each component of the boxplot to a list
4135           of the `.Line2D` instances created. That dictionary has the
4136           following keys (assuming vertical boxplots):
4137 
4138           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4139             the median's confidence intervals if enabled.
4140           - ``medians``: horizontal lines at the median of each box.
4141           - ``whiskers``: vertical lines up to the last non-outlier data.
4142           - ``caps``: horizontal lines at the ends of the whiskers.
4143           - ``fliers``: points representing data beyond the whiskers (fliers).
4144           - ``means``: points or lines representing the means.
4145 
4146         Examples
4147         --------
4148         .. plot:: gallery/statistics/bxp.py
4149         """
4150 
4151         # lists of artists to be output
4152         whiskers = []
4153         caps = []
4154         boxes = []
4155         medians = []
4156         means = []
4157         fliers = []
4158 
4159         # empty list of xticklabels
4160         datalabels = []
4161 
4162         # Use default zorder if none specified
4163         if zorder is None:
4164             zorder = mlines.Line2D.zorder
4165 
4166         zdelta = 0.1
4167 
4168         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4169             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4170                  if k.startswith(f'boxplot.{subkey}props')}
4171             d['zorder'] = zorder + zdelta
4172             if not usemarker:
4173                 d['marker'] = ''
4174             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4175             return d
4176 
4177         box_kw = {
4178             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4179             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4180             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4181             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4182                           else mpl.rcParams['patch.facecolor']),
4183             'zorder': zorder,
4184             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4185         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4186         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4187         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4188         flier_kw = merge_kw_rc('flier', flierprops)
4189         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4190         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4191         removed_prop = 'marker' if meanline else 'linestyle'
4192         # Only remove the property if it's not set explicitly as a parameter.
4193         if meanprops is None or removed_prop not in meanprops:
4194             mean_kw[removed_prop] = ''
4195 
4196         # vertical or horizontal plot?
4197         maybe_swap = slice(None) if vert else slice(None, None, -1)
4198 
4199         def do_plot(xs, ys, **kwargs):
4200             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4201 
4202         def do_patch(xs, ys, **kwargs):
4203             path = mpath.Path._create_closed(
4204                 np.column_stack([xs, ys][maybe_swap]))
4205             patch = mpatches.PathPatch(path, **kwargs)
4206             self.add_artist(patch)
4207             return patch
4208 
4209         # input validation
4210         N = len(bxpstats)
4211         datashape_message = ("List of boxplot statistics and `{0}` "
4212                              "values must have same the length")
4213         # check position
4214         if positions is None:
4215             positions = list(range(1, N + 1))
4216         elif len(positions) != N:
4217             raise ValueError(datashape_message.format("positions"))
4218 
4219         positions = np.array(positions)
4220         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4221             raise TypeError("positions should be an iterable of numbers")
4222 
4223         # width
4224         if widths is None:
4225             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4226         elif np.isscalar(widths):
4227             widths = [widths] * N
4228         elif len(widths) != N:
4229             raise ValueError(datashape_message.format("widths"))
4230 
4231         # capwidth
4232         if capwidths is None:
4233             capwidths = 0.5 * np.array(widths)
4234         elif np.isscalar(capwidths):
4235             capwidths = [capwidths] * N
4236         elif len(capwidths) != N:
4237             raise ValueError(datashape_message.format("capwidths"))
4238 
4239         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4240                                                capwidths):
4241             # try to find a new label
4242             datalabels.append(stats.get('label', pos))
4243 
4244             # whisker coords
4245             whis_x = [pos, pos]
4246             whislo_y = [stats['q1'], stats['whislo']]
4247             whishi_y = [stats['q3'], stats['whishi']]
4248             # cap coords
4249             cap_left = pos - capwidth * 0.5
4250             cap_right = pos + capwidth * 0.5
4251             cap_x = [cap_left, cap_right]
4252             cap_lo = np.full(2, stats['whislo'])
4253             cap_hi = np.full(2, stats['whishi'])
4254             # box and median coords
4255             box_left = pos - width * 0.5
4256             box_right = pos + width * 0.5
4257             med_y = [stats['med'], stats['med']]
4258             # notched boxes
4259             if shownotches:
4260                 notch_left = pos - width * 0.25
4261                 notch_right = pos + width * 0.25
4262                 box_x = [box_left, box_right, box_right, notch_right,
4263                          box_right, box_right, box_left, box_left, notch_left,
4264                          box_left, box_left]
4265                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4266                          stats['med'], stats['cihi'], stats['q3'],
4267                          stats['q3'], stats['cihi'], stats['med'],
4268                          stats['cilo'], stats['q1']]
4269                 med_x = [notch_left, notch_right]
4270             # plain boxes
4271             else:
4272                 box_x = [box_left, box_right, box_right, box_left, box_left]
4273                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4274                          stats['q1']]
4275                 med_x = [box_left, box_right]
4276 
4277             # maybe draw the box
4278             if showbox:
4279                 do_box = do_patch if patch_artist else do_plot
4280                 boxes.append(do_box(box_x, box_y, **box_kw))
4281             # draw the whiskers
4282             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4283             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4284             # maybe draw the caps
4285             if showcaps:
4286                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4287                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4288             # draw the medians
4289             medians.append(do_plot(med_x, med_y, **median_kw))
4290             # maybe draw the means
4291             if showmeans:
4292                 if meanline:
4293                     means.append(do_plot(
4294                         [box_left, box_right], [stats['mean'], stats['mean']],
4295                         **mean_kw
4296                     ))
4297                 else:
4298                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4299             # maybe draw the fliers
4300             if showfliers:
4301                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4302                 flier_y = stats['fliers']
4303                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4304 
4305         if manage_ticks:
4306             axis_name = "x" if vert else "y"
4307             interval = getattr(self.dataLim, f"interval{axis_name}")
4308             axis = self._axis_map[axis_name]
4309             positions = axis.convert_units(positions)
4310             # The 0.5 additional padding ensures reasonable-looking boxes
4311             # even when drawing a single box.  We set the sticky edge to
4312             # prevent margins expansion, in order to match old behavior (back
4313             # when separate calls to boxplot() would completely reset the axis
4314             # limits regardless of what was drawn before).  The sticky edges
4315             # are attached to the median lines, as they are always present.
4316             interval[:] = (min(interval[0], min(positions) - .5),
4317                            max(interval[1], max(positions) + .5))
4318             for median, position in zip(medians, positions):
4319                 getattr(median.sticky_edges, axis_name).extend(
4320                     [position - .5, position + .5])
4321             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4322             locator = axis.get_major_locator()
4323             if not isinstance(axis.get_major_locator(),
4324                               mticker.FixedLocator):
4325                 locator = mticker.FixedLocator([])
4326                 axis.set_major_locator(locator)
4327             locator.locs = np.array([*locator.locs, *positions])
4328             formatter = axis.get_major_formatter()
4329             if not isinstance(axis.get_major_formatter(),
4330                               mticker.FixedFormatter):
4331                 formatter = mticker.FixedFormatter([])
4332                 axis.set_major_formatter(formatter)
4333             formatter.seq = [*formatter.seq, *datalabels]
4334 
4335             self._request_autoscale_view()
4336 
4337         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4338                     medians=medians, fliers=fliers, means=means)
4339 
4340     @staticmethod
4341     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4342                                   get_next_color_func):
4343         """
4344         Helper function to process color related arguments of `.Axes.scatter`.
4345 
4346         Argument precedence for facecolors:
4347 
4348         - c (if not None)
4349         - kwargs['facecolor']
4350         - kwargs['facecolors']
4351         - kwargs['color'] (==kwcolor)
4352         - 'b' if in classic mode else the result of ``get_next_color_func()``
4353 
4354         Argument precedence for edgecolors:
4355 
4356         - kwargs['edgecolor']
4357         - edgecolors (is an explicit kw argument in scatter())
4358         - kwargs['color'] (==kwcolor)
4359         - 'face' if not in classic mode else None
4360 
4361         Parameters
4362         ----------
4363         c : color or sequence or sequence of color or None
4364             See argument description of `.Axes.scatter`.
4365         edgecolors : color or sequence of color or {'face', 'none'} or None
4366             See argument description of `.Axes.scatter`.
4367         kwargs : dict
4368             Additional kwargs. If these keys exist, we pop and process them:
4369             'facecolors', 'facecolor', 'edgecolor', 'color'
4370             Note: The dict is modified by this function.
4371         xsize : int
4372             The size of the x and y arrays passed to `.Axes.scatter`.
4373         get_next_color_func : callable
4374             A callable that returns a color. This color is used as facecolor
4375             if no other color is provided.
4376 
4377             Note, that this is a function rather than a fixed color value to
4378             support conditional evaluation of the next color.  As of the
4379             current implementation obtaining the next color from the
4380             property cycle advances the cycle. This must only happen if we
4381             actually use the color, which will only be decided within this
4382             method.
4383 
4384         Returns
4385         -------
4386         c
4387             The input *c* if it was not *None*, else a color derived from the
4388             other inputs or defaults.
4389         colors : array(N, 4) or None
4390             The facecolors as RGBA values, or *None* if a colormap is used.
4391         edgecolors
4392             The edgecolor.
4393 
4394         """
4395         facecolors = kwargs.pop('facecolors', None)
4396         facecolors = kwargs.pop('facecolor', facecolors)
4397         edgecolors = kwargs.pop('edgecolor', edgecolors)
4398 
4399         kwcolor = kwargs.pop('color', None)
4400 
4401         if kwcolor is not None and c is not None:
4402             raise ValueError("Supply a 'c' argument or a 'color'"
4403                              " kwarg but not both; they differ but"
4404                              " their functionalities overlap.")
4405 
4406         if kwcolor is not None:
4407             try:
4408                 mcolors.to_rgba_array(kwcolor)
4409             except ValueError as err:
4410                 raise ValueError(
4411                     "'color' kwarg must be a color or sequence of color "
4412                     "specs.  For a sequence of values to be color-mapped, use "
4413                     "the 'c' argument instead.") from err
4414             if edgecolors is None:
4415                 edgecolors = kwcolor
4416             if facecolors is None:
4417                 facecolors = kwcolor
4418 
4419         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4420             edgecolors = mpl.rcParams['scatter.edgecolors']
4421 
4422         c_was_none = c is None
4423         if c is None:
4424             c = (facecolors if facecolors is not None
4425                  else "b" if mpl.rcParams['_internal.classic_mode']
4426                  else get_next_color_func())
4427         c_is_string_or_strings = (
4428             isinstance(c, str)
4429             or (np.iterable(c) and len(c) > 0
4430                 and isinstance(cbook._safe_first_finite(c), str)))
4431 
4432         def invalid_shape_exception(csize, xsize):
4433             return ValueError(
4434                 f"'c' argument has {csize} elements, which is inconsistent "
4435                 f"with 'x' and 'y' with size {xsize}.")
4436 
4437         c_is_mapped = False  # Unless proven otherwise below.
4438         valid_shape = True  # Unless proven otherwise below.
4439         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4440             try:  # First, does 'c' look suitable for value-mapping?
4441                 c = np.asanyarray(c, dtype=float)
4442             except ValueError:
4443                 pass  # Failed to convert to float array; must be color specs.
4444             else:
4445                 # handle the documented special case of a 2D array with 1
4446                 # row which as RGB(A) to broadcast.
4447                 if c.shape == (1, 4) or c.shape == (1, 3):
4448                     c_is_mapped = False
4449                     if c.size != xsize:
4450                         valid_shape = False
4451                 # If c can be either mapped values or an RGB(A) color, prefer
4452                 # the former if shapes match, the latter otherwise.
4453                 elif c.size == xsize:
4454                     c = c.ravel()
4455                     c_is_mapped = True
4456                 else:  # Wrong size; it must not be intended for mapping.
4457                     if c.shape in ((3,), (4,)):
4458                         _api.warn_external(
4459                             "*c* argument looks like a single numeric RGB or "
4460                             "RGBA sequence, which should be avoided as value-"
4461                             "mapping will have precedence in case its length "
4462                             "matches with *x* & *y*.  Please use the *color* "
4463                             "keyword-argument or provide a 2D array "
4464                             "with a single row if you intend to specify "
4465                             "the same RGB or RGBA value for all points.")
4466                     valid_shape = False
4467         if not c_is_mapped:
4468             try:  # Is 'c' acceptable as PathCollection facecolors?
4469                 colors = mcolors.to_rgba_array(c)
4470             except (TypeError, ValueError) as err:
4471                 if "RGBA values should be within 0-1 range" in str(err):
4472                     raise
4473                 else:
4474                     if not valid_shape:
4475                         raise invalid_shape_exception(c.size, xsize) from err
4476                     # Both the mapping *and* the RGBA conversion failed: pretty
4477                     # severe failure => one may appreciate a verbose feedback.
4478                     raise ValueError(
4479                         f"'c' argument must be a color, a sequence of colors, "
4480                         f"or a sequence of numbers, not {c!r}") from err
4481             else:
4482                 if len(colors) not in (0, 1, xsize):
4483                     # NB: remember that a single color is also acceptable.
4484                     # Besides *colors* will be an empty array if c == 'none'.
4485                     raise invalid_shape_exception(len(colors), xsize)
4486         else:
4487             colors = None  # use cmap, norm after collection is created
4488         return c, colors, edgecolors
4489 
4490     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4491                                      "edgecolors", "c", "facecolor",
4492                                      "facecolors", "color"],
4493                       label_namer="y")
4494     @_docstring.interpd
4495     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4496                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4497                 edgecolors=None, plotnonfinite=False, **kwargs):
4498         """
4499         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4500 
4501         Parameters
4502         ----------
4503         x, y : float or array-like, shape (n, )
4504             The data positions.
4505 
4506         s : float or array-like, shape (n, ), optional
4507             The marker size in points**2 (typographic points are 1/72 in.).
4508             Default is ``rcParams['lines.markersize'] ** 2``.
4509 
4510             The linewidth and edgecolor can visually interact with the marker
4511             size, and can lead to artifacts if the marker size is smaller than
4512             the linewidth.
4513 
4514             If the linewidth is greater than 0 and the edgecolor is anything
4515             but *'none'*, then the effective size of the marker will be
4516             increased by half the linewidth because the stroke will be centered
4517             on the edge of the shape.
4518 
4519             To eliminate the marker edge either set *linewidth=0* or
4520             *edgecolor='none'*.
4521 
4522         c : array-like or list of colors or color, optional
4523             The marker colors. Possible values:
4524 
4525             - A scalar or sequence of n numbers to be mapped to colors using
4526               *cmap* and *norm*.
4527             - A 2D array in which the rows are RGB or RGBA.
4528             - A sequence of colors of length n.
4529             - A single color format string.
4530 
4531             Note that *c* should not be a single numeric RGB or RGBA sequence
4532             because that is indistinguishable from an array of values to be
4533             colormapped. If you want to specify the same RGB or RGBA value for
4534             all points, use a 2D array with a single row.  Otherwise,
4535             value-matching will have precedence in case of a size matching with
4536             *x* and *y*.
4537 
4538             If you wish to specify a single color for all points
4539             prefer the *color* keyword argument.
4540 
4541             Defaults to `None`. In that case the marker color is determined
4542             by the value of *color*, *facecolor* or *facecolors*. In case
4543             those are not specified or `None`, the marker color is determined
4544             by the next color of the ``Axes``' current "shape and fill" color
4545             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4546 
4547         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4548             The marker style. *marker* can be either an instance of the class
4549             or the text shorthand for a particular marker.
4550             See :mod:`matplotlib.markers` for more information about marker
4551             styles.
4552 
4553         %(cmap_doc)s
4554 
4555             This parameter is ignored if *c* is RGB(A).
4556 
4557         %(norm_doc)s
4558 
4559             This parameter is ignored if *c* is RGB(A).
4560 
4561         %(vmin_vmax_doc)s
4562 
4563             This parameter is ignored if *c* is RGB(A).
4564 
4565         alpha : float, default: None
4566             The alpha blending value, between 0 (transparent) and 1 (opaque).
4567 
4568         linewidths : float or array-like, default: :rc:`lines.linewidth`
4569             The linewidth of the marker edges. Note: The default *edgecolors*
4570             is 'face'. You may want to change this as well.
4571 
4572         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4573 default: :rc:`scatter.edgecolors`
4574             The edge color of the marker. Possible values:
4575 
4576             - 'face': The edge color will always be the same as the face color.
4577             - 'none': No patch boundary will be drawn.
4578             - A color or sequence of colors.
4579 
4580             For non-filled markers, *edgecolors* is ignored. Instead, the color
4581             is determined like with 'face', i.e. from *c*, *colors*, or
4582             *facecolors*.
4583 
4584         plotnonfinite : bool, default: False
4585             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4586             or ``nan``). If ``True`` the points are drawn with the *bad*
4587             colormap color (see `.Colormap.set_bad`).
4588 
4589         Returns
4590         -------
4591         `~matplotlib.collections.PathCollection`
4592 
4593         Other Parameters
4594         ----------------
4595         data : indexable object, optional
4596             DATA_PARAMETER_PLACEHOLDER
4597         **kwargs : `~matplotlib.collections.Collection` properties
4598 
4599         See Also
4600         --------
4601         plot : To plot scatter plots when markers are identical in size and
4602             color.
4603 
4604         Notes
4605         -----
4606         * The `.plot` function will be faster for scatterplots where markers
4607           don't vary in size or color.
4608 
4609         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4610           case all masks will be combined and only unmasked points will be
4611           plotted.
4612 
4613         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4614           may be input as N-D arrays, but within scatter they will be
4615           flattened. The exception is *c*, which will be flattened only if its
4616           size matches the size of *x* and *y*.
4617 
4618         """
4619         # add edgecolors and linewidths to kwargs so they
4620         # can be processed by normailze_kwargs
4621         if edgecolors is not None:
4622             kwargs.update({'edgecolors': edgecolors})
4623         if linewidths is not None:
4624             kwargs.update({'linewidths': linewidths})
4625 
4626         kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
4627         # re direct linewidth and edgecolor so it can be
4628         # further processed by the rest of the function
4629         linewidths = kwargs.pop('linewidth', None)
4630         edgecolors = kwargs.pop('edgecolor', None)
4631         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4632         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4633         # np.ma.ravel yields an ndarray, not a masked array,
4634         # unless its argument is a masked array.
4635         x = np.ma.ravel(x)
4636         y = np.ma.ravel(y)
4637         if x.size != y.size:
4638             raise ValueError("x and y must be the same size")
4639 
4640         if s is None:
4641             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4642                  mpl.rcParams['lines.markersize'] ** 2.0)
4643         s = np.ma.ravel(s)
4644         if (len(s) not in (1, x.size) or
4645                 (not np.issubdtype(s.dtype, np.floating) and
4646                  not np.issubdtype(s.dtype, np.integer))):
4647             raise ValueError(
4648                 "s must be a scalar, "
4649                 "or float array-like with the same size as x and y")
4650 
4651         # get the original edgecolor the user passed before we normalize
4652         orig_edgecolor = edgecolors
4653         if edgecolors is None:
4654             orig_edgecolor = kwargs.get('edgecolor', None)
4655         c, colors, edgecolors = \
4656             self._parse_scatter_color_args(
4657                 c, edgecolors, kwargs, x.size,
4658                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4659 
4660         if plotnonfinite and colors is None:
4661             c = np.ma.masked_invalid(c)
4662             x, y, s, edgecolors, linewidths = \
4663                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4664         else:
4665             x, y, s, c, colors, edgecolors, linewidths = \
4666                 cbook._combine_masks(
4667                     x, y, s, c, colors, edgecolors, linewidths)
4668         # Unmask edgecolors if it was actually a single RGB or RGBA.
4669         if (x.size in (3, 4)
4670                 and np.ma.is_masked(edgecolors)
4671                 and not np.ma.is_masked(orig_edgecolor)):
4672             edgecolors = edgecolors.data
4673 
4674         scales = s   # Renamed for readability below.
4675 
4676         # load default marker from rcParams
4677         if marker is None:
4678             marker = mpl.rcParams['scatter.marker']
4679 
4680         if isinstance(marker, mmarkers.MarkerStyle):
4681             marker_obj = marker
4682         else:
4683             marker_obj = mmarkers.MarkerStyle(marker)
4684 
4685         path = marker_obj.get_path().transformed(
4686             marker_obj.get_transform())
4687         if not marker_obj.is_filled():
4688             if orig_edgecolor is not None:
4689                 _api.warn_external(
4690                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4691                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4692                     "ignoring the edgecolor in favor of the facecolor.  This "
4693                     "behavior may change in the future."
4694                 )
4695             # We need to handle markers that cannot be filled (like
4696             # '+' and 'x') differently than markers that can be
4697             # filled, but have their fillstyle set to 'none'.  This is
4698             # to get:
4699             #
4700             #  - respecting the fillestyle if set
4701             #  - maintaining back-compatibility for querying the facecolor of
4702             #    the un-fillable markers.
4703             #
4704             # While not an ideal situation, but is better than the
4705             # alternatives.
4706             if marker_obj.get_fillstyle() == 'none':
4707                 # promote the facecolor to be the edgecolor
4708                 edgecolors = colors
4709                 # set the facecolor to 'none' (at the last chance) because
4710                 # we cannot fill a path if the facecolor is non-null
4711                 # (which is defendable at the renderer level).
4712                 colors = 'none'
4713             else:
4714                 # if we are not nulling the face color we can do this
4715                 # simpler
4716                 edgecolors = 'face'
4717 
4718             if linewidths is None:
4719                 linewidths = mpl.rcParams['lines.linewidth']
4720             elif np.iterable(linewidths):
4721                 linewidths = [
4722                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4723                     for lw in linewidths]
4724 
4725         offsets = np.ma.column_stack([x, y])
4726 
4727         collection = mcoll.PathCollection(
4728             (path,), scales,
4729             facecolors=colors,
4730             edgecolors=edgecolors,
4731             linewidths=linewidths,
4732             offsets=offsets,
4733             offset_transform=kwargs.pop('transform', self.transData),
4734             alpha=alpha,
4735         )
4736         collection.set_transform(mtransforms.IdentityTransform())
4737         if colors is None:
4738             collection.set_array(c)
4739             collection.set_cmap(cmap)
4740             collection.set_norm(norm)
4741             collection._scale_norm(norm, vmin, vmax)
4742         else:
4743             extra_kwargs = {
4744                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4745                     }
4746             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4747             if any(extra_keys):
4748                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4749                 _api.warn_external(
4750                     "No data for colormapping provided via 'c'. "
4751                     f"Parameters {keys_str} will be ignored")
4752         collection._internal_update(kwargs)
4753 
4754         # Classic mode only:
4755         # ensure there are margins to allow for the
4756         # finite size of the symbols.  In v2.x, margins
4757         # are present by default, so we disable this
4758         # scatter-specific override.
4759         if mpl.rcParams['_internal.classic_mode']:
4760             if self._xmargin < 0.05 and x.size > 0:
4761                 self.set_xmargin(0.05)
4762             if self._ymargin < 0.05 and x.size > 0:
4763                 self.set_ymargin(0.05)
4764 
4765         self.add_collection(collection)
4766         self._request_autoscale_view()
4767 
4768         return collection
4769 
4770     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4771     @_docstring.dedent_interpd
4772     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4773                xscale='linear', yscale='linear', extent=None,
4774                cmap=None, norm=None, vmin=None, vmax=None,
4775                alpha=None, linewidths=None, edgecolors='face',
4776                reduce_C_function=np.mean, mincnt=None, marginals=False,
4777                **kwargs):
4778         """
4779         Make a 2D hexagonal binning plot of points *x*, *y*.
4780 
4781         If *C* is *None*, the value of the hexagon is determined by the number
4782         of points in the hexagon. Otherwise, *C* specifies values at the
4783         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4784         using *reduce_C_function*.
4785 
4786         Parameters
4787         ----------
4788         x, y : array-like
4789             The data positions. *x* and *y* must be of the same length.
4790 
4791         C : array-like, optional
4792             If given, these values are accumulated in the bins. Otherwise,
4793             every point has a value of 1. Must be of the same length as *x*
4794             and *y*.
4795 
4796         gridsize : int or (int, int), default: 100
4797             If a single int, the number of hexagons in the *x*-direction.
4798             The number of hexagons in the *y*-direction is chosen such that
4799             the hexagons are approximately regular.
4800 
4801             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4802             in the *x*-direction and the *y*-direction. In the
4803             *y*-direction, counting is done along vertically aligned
4804             hexagons, not along the zig-zag chains of hexagons; see the
4805             following illustration.
4806 
4807             .. plot::
4808 
4809                import numpy
4810                import matplotlib.pyplot as plt
4811 
4812                np.random.seed(19680801)
4813                n= 300
4814                x = np.random.standard_normal(n)
4815                y = np.random.standard_normal(n)
4816 
4817                fig, ax = plt.subplots(figsize=(4, 4))
4818                h = ax.hexbin(x, y, gridsize=(5, 3))
4819                hx, hy = h.get_offsets().T
4820                ax.plot(hx[24::3], hy[24::3], 'ro-')
4821                ax.plot(hx[-3:], hy[-3:], 'ro-')
4822                ax.set_title('gridsize=(5, 3)')
4823                ax.axis('off')
4824 
4825             To get approximately regular hexagons, choose
4826             :math:`n_x = \\sqrt{3}\\,n_y`.
4827 
4828         bins : 'log' or int or sequence, default: None
4829             Discretization of the hexagon values.
4830 
4831             - If *None*, no binning is applied; the color of each hexagon
4832               directly corresponds to its count value.
4833             - If 'log', use a logarithmic scale for the colormap.
4834               Internally, :math:`log_{10}(i+1)` is used to determine the
4835               hexagon color. This is equivalent to ``norm=LogNorm()``.
4836             - If an integer, divide the counts in the specified number
4837               of bins, and color the hexagons accordingly.
4838             - If a sequence of values, the values of the lower bound of
4839               the bins to be used.
4840 
4841         xscale : {'linear', 'log'}, default: 'linear'
4842             Use a linear or log10 scale on the horizontal axis.
4843 
4844         yscale : {'linear', 'log'}, default: 'linear'
4845             Use a linear or log10 scale on the vertical axis.
4846 
4847         mincnt : int > 0, default: *None*
4848             If not *None*, only display cells with more than *mincnt*
4849             number of points in the cell.
4850 
4851         marginals : bool, default: *False*
4852             If marginals is *True*, plot the marginal density as
4853             colormapped rectangles along the bottom of the x-axis and
4854             left of the y-axis.
4855 
4856         extent : 4-tuple of float, default: *None*
4857             The limits of the bins (xmin, xmax, ymin, ymax).
4858             The default assigns the limits based on
4859             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4860 
4861             If *xscale* or *yscale* is set to 'log', the limits are
4862             expected to be the exponent for a power of 10. E.g. for
4863             x-limits of 1 and 50 in 'linear' scale and y-limits
4864             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4865 
4866         Returns
4867         -------
4868         `~matplotlib.collections.PolyCollection`
4869             A `.PolyCollection` defining the hexagonal bins.
4870 
4871             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4872               the x, y positions of the M hexagon centers.
4873             - `.PolyCollection.get_array` contains the values of the M
4874               hexagons.
4875 
4876             If *marginals* is *True*, horizontal
4877             bar and vertical bar (both PolyCollections) will be attached
4878             to the return collection as attributes *hbar* and *vbar*.
4879 
4880         Other Parameters
4881         ----------------
4882         %(cmap_doc)s
4883 
4884         %(norm_doc)s
4885 
4886         %(vmin_vmax_doc)s
4887 
4888         alpha : float between 0 and 1, optional
4889             The alpha blending value, between 0 (transparent) and 1 (opaque).
4890 
4891         linewidths : float, default: *None*
4892             If *None*, defaults to :rc:`patch.linewidth`.
4893 
4894         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4895             The color of the hexagon edges. Possible values are:
4896 
4897             - 'face': Draw the edges in the same color as the fill color.
4898             - 'none': No edges are drawn. This can sometimes lead to unsightly
4899               unpainted pixels between the hexagons.
4900             - *None*: Draw outlines in the default color.
4901             - An explicit color.
4902 
4903         reduce_C_function : callable, default: `numpy.mean`
4904             The function to aggregate *C* within the bins. It is ignored if
4905             *C* is not given. This must have the signature::
4906 
4907                 def reduce_C_function(C: array) -> float
4908 
4909             Commonly used functions are:
4910 
4911             - `numpy.mean`: average of the points
4912             - `numpy.sum`: integral of the point values
4913             - `numpy.amax`: value taken from the largest point
4914 
4915         data : indexable object, optional
4916             DATA_PARAMETER_PLACEHOLDER
4917 
4918         **kwargs : `~matplotlib.collections.PolyCollection` properties
4919             All other keyword arguments are passed on to `.PolyCollection`:
4920 
4921             %(PolyCollection:kwdoc)s
4922 
4923         See Also
4924         --------
4925         hist2d : 2D histogram rectangular bins
4926         """
4927         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4928 
4929         x, y, C = cbook.delete_masked_points(x, y, C)
4930 
4931         # Set the size of the hexagon grid
4932         if np.iterable(gridsize):
4933             nx, ny = gridsize
4934         else:
4935             nx = gridsize
4936             ny = int(nx / math.sqrt(3))
4937         # Count the number of data in each hexagon
4938         x = np.asarray(x, float)
4939         y = np.asarray(y, float)
4940 
4941         # Will be log()'d if necessary, and then rescaled.
4942         tx = x
4943         ty = y
4944 
4945         if xscale == 'log':
4946             if np.any(x <= 0.0):
4947                 raise ValueError(
4948                     "x contains non-positive values, so cannot be log-scaled")
4949             tx = np.log10(tx)
4950         if yscale == 'log':
4951             if np.any(y <= 0.0):
4952                 raise ValueError(
4953                     "y contains non-positive values, so cannot be log-scaled")
4954             ty = np.log10(ty)
4955         if extent is not None:
4956             xmin, xmax, ymin, ymax = extent
4957         else:
4958             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4959             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4960 
4961             # to avoid issues with singular data, expand the min/max pairs
4962             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4963             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4964 
4965         nx1 = nx + 1
4966         ny1 = ny + 1
4967         nx2 = nx
4968         ny2 = ny
4969         n = nx1 * ny1 + nx2 * ny2
4970 
4971         # In the x-direction, the hexagons exactly cover the region from
4972         # xmin to xmax. Need some padding to avoid roundoff errors.
4973         padding = 1.e-9 * (xmax - xmin)
4974         xmin -= padding
4975         xmax += padding
4976         sx = (xmax - xmin) / nx
4977         sy = (ymax - ymin) / ny
4978         # Positions in hexagon index coordinates.
4979         ix = (tx - xmin) / sx
4980         iy = (ty - ymin) / sy
4981         ix1 = np.round(ix).astype(int)
4982         iy1 = np.round(iy).astype(int)
4983         ix2 = np.floor(ix).astype(int)
4984         iy2 = np.floor(iy).astype(int)
4985         # flat indices, plus one so that out-of-range points go to position 0.
4986         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4987                       ix1 * ny1 + iy1 + 1, 0)
4988         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4989                       ix2 * ny2 + iy2 + 1, 0)
4990 
4991         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4992         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4993         bdist = (d1 < d2)
4994 
4995         if C is None:  # [1:] drops out-of-range points.
4996             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4997             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4998             accum = np.concatenate([counts1, counts2]).astype(float)
4999             if mincnt is not None:
5000                 accum[accum < mincnt] = np.nan
5001             C = np.ones(len(x))
5002         else:
5003             # store the C values in a list per hexagon index
5004             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
5005             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
5006             for i in range(len(x)):
5007                 if bdist[i]:
5008                     Cs_at_i1[i1[i]].append(C[i])
5009                 else:
5010                     Cs_at_i2[i2[i]].append(C[i])
5011             if mincnt is None:
5012                 mincnt = 0
5013             accum = np.array(
5014                 [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
5015                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
5016                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
5017                 float)
5018 
5019         good_idxs = ~np.isnan(accum)
5020 
5021         offsets = np.zeros((n, 2), float)
5022         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
5023         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
5024         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
5025         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
5026         offsets[:, 0] *= sx
5027         offsets[:, 1] *= sy
5028         offsets[:, 0] += xmin
5029         offsets[:, 1] += ymin
5030         # remove accumulation bins with no data
5031         offsets = offsets[good_idxs, :]
5032         accum = accum[good_idxs]
5033 
5034         polygon = [sx, sy / 3] * np.array(
5035             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5036 
5037         if linewidths is None:
5038             linewidths = [mpl.rcParams['patch.linewidth']]
5039 
5040         if xscale == 'log' or yscale == 'log':
5041             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5042             if xscale == 'log':
5043                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5044                 xmin = 10.0 ** xmin
5045                 xmax = 10.0 ** xmax
5046                 self.set_xscale(xscale)
5047             if yscale == 'log':
5048                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5049                 ymin = 10.0 ** ymin
5050                 ymax = 10.0 ** ymax
5051                 self.set_yscale(yscale)
5052             collection = mcoll.PolyCollection(
5053                 polygons,
5054                 edgecolors=edgecolors,
5055                 linewidths=linewidths,
5056                 )
5057         else:
5058             collection = mcoll.PolyCollection(
5059                 [polygon],
5060                 edgecolors=edgecolors,
5061                 linewidths=linewidths,
5062                 offsets=offsets,
5063                 offset_transform=mtransforms.AffineDeltaTransform(
5064                     self.transData),
5065             )
5066 
5067         # Set normalizer if bins is 'log'
5068         if bins == 'log':
5069             if norm is not None:
5070                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5071                                    f"can be supplied, ignoring bins={bins}")
5072             else:
5073                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5074                 vmin = vmax = None
5075             bins = None
5076 
5077         # autoscale the norm with current accum values if it hasn't been set
5078         if norm is not None:
5079             if norm.vmin is None and norm.vmax is None:
5080                 norm.autoscale(accum)
5081 
5082         if bins is not None:
5083             if not np.iterable(bins):
5084                 minimum, maximum = min(accum), max(accum)
5085                 bins -= 1  # one less edge than bins
5086                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5087             bins = np.sort(bins)
5088             accum = bins.searchsorted(accum)
5089 
5090         collection.set_array(accum)
5091         collection.set_cmap(cmap)
5092         collection.set_norm(norm)
5093         collection.set_alpha(alpha)
5094         collection._internal_update(kwargs)
5095         collection._scale_norm(norm, vmin, vmax)
5096 
5097         corners = ((xmin, ymin), (xmax, ymax))
5098         self.update_datalim(corners)
5099         self._request_autoscale_view(tight=True)
5100 
5101         # add the collection last
5102         self.add_collection(collection, autolim=False)
5103         if not marginals:
5104             return collection
5105 
5106         # Process marginals
5107         bars = []
5108         for zname, z, zmin, zmax, zscale, nbins in [
5109                 ("x", x, xmin, xmax, xscale, nx),
5110                 ("y", y, ymin, ymax, yscale, 2 * ny),
5111         ]:
5112 
5113             if zscale == "log":
5114                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5115             else:
5116                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5117 
5118             verts = np.empty((nbins, 4, 2))
5119             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5120             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5121             verts[:, 0, 1] = verts[:, 3, 1] = .00
5122             verts[:, 1, 1] = verts[:, 2, 1] = .05
5123             if zname == "y":
5124                 verts = verts[:, :, ::-1]  # Swap x and y.
5125 
5126             # Sort z-values into bins defined by bin_edges.
5127             bin_idxs = np.searchsorted(bin_edges, z) - 1
5128             values = np.empty(nbins)
5129             for i in range(nbins):
5130                 # Get C-values for each bin, and compute bin value with
5131                 # reduce_C_function.
5132                 ci = C[bin_idxs == i]
5133                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5134 
5135             mask = ~np.isnan(values)
5136             verts = verts[mask]
5137             values = values[mask]
5138 
5139             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5140             bar = mcoll.PolyCollection(
5141                 verts, transform=trans, edgecolors="face")
5142             bar.set_array(values)
5143             bar.set_cmap(cmap)
5144             bar.set_norm(norm)
5145             bar.set_alpha(alpha)
5146             bar._internal_update(kwargs)
5147             bars.append(self.add_collection(bar, autolim=False))
5148 
5149         collection.hbar, collection.vbar = bars
5150 
5151         def on_changed(collection):
5152             collection.hbar.set_cmap(collection.get_cmap())
5153             collection.hbar.set_cmap(collection.get_cmap())
5154             collection.vbar.set_clim(collection.get_clim())
5155             collection.vbar.set_clim(collection.get_clim())
5156 
5157         collection.callbacks.connect('changed', on_changed)
5158 
5159         return collection
5160 
5161     @_docstring.dedent_interpd
5162     def arrow(self, x, y, dx, dy, **kwargs):
5163         """
5164         Add an arrow to the Axes.
5165 
5166         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5167 
5168         Parameters
5169         ----------
5170         %(FancyArrow)s
5171 
5172         Returns
5173         -------
5174         `.FancyArrow`
5175             The created `.FancyArrow` object.
5176 
5177         Notes
5178         -----
5179         The resulting arrow is affected by the Axes aspect ratio and limits.
5180         This may produce an arrow whose head is not square with its stem. To
5181         create an arrow whose head is square with its stem,
5182         use :meth:`annotate` for example:
5183 
5184         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5185         ...             arrowprops=dict(arrowstyle="->"))
5186 
5187         """
5188         # Strip away units for the underlying patch since units
5189         # do not make sense to most patch-like code
5190         x = self.convert_xunits(x)
5191         y = self.convert_yunits(y)
5192         dx = self.convert_xunits(dx)
5193         dy = self.convert_yunits(dy)
5194 
5195         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5196         self.add_patch(a)
5197         self._request_autoscale_view()
5198         return a
5199 
5200     @_docstring.copy(mquiver.QuiverKey.__init__)
5201     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5202         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5203         self.add_artist(qk)
5204         return qk
5205 
5206     # Handle units for x and y, if they've been passed
5207     def _quiver_units(self, args, kwargs):
5208         if len(args) > 3:
5209             x, y = args[0:2]
5210             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5211             return (x, y) + args[2:]
5212         return args
5213 
5214     # args can be a combination of X, Y, U, V, C and all should be replaced
5215     @_preprocess_data()
5216     @_docstring.dedent_interpd
5217     def quiver(self, *args, **kwargs):
5218         """%(quiver_doc)s"""
5219         # Make sure units are handled for x and y values
5220         args = self._quiver_units(args, kwargs)
5221         q = mquiver.Quiver(self, *args, **kwargs)
5222         self.add_collection(q, autolim=True)
5223         self._request_autoscale_view()
5224         return q
5225 
5226     # args can be some combination of X, Y, U, V, C and all should be replaced
5227     @_preprocess_data()
5228     @_docstring.dedent_interpd
5229     def barbs(self, *args, **kwargs):
5230         """%(barbs_doc)s"""
5231         # Make sure units are handled for x and y values
5232         args = self._quiver_units(args, kwargs)
5233         b = mquiver.Barbs(self, *args, **kwargs)
5234         self.add_collection(b, autolim=True)
5235         self._request_autoscale_view()
5236         return b
5237 
5238     # Uses a custom implementation of data-kwarg handling in
5239     # _process_plot_var_args.
5240     def fill(self, *args, data=None, **kwargs):
5241         """
5242         Plot filled polygons.
5243 
5244         Parameters
5245         ----------
5246         *args : sequence of x, y, [color]
5247             Each polygon is defined by the lists of *x* and *y* positions of
5248             its nodes, optionally followed by a *color* specifier. See
5249             :mod:`matplotlib.colors` for supported color specifiers. The
5250             standard color cycle is used for polygons without a color
5251             specifier.
5252 
5253             You can plot multiple polygons by providing multiple *x*, *y*,
5254             *[color]* groups.
5255 
5256             For example, each of the following is legal::
5257 
5258                 ax.fill(x, y)                    # a polygon with default color
5259                 ax.fill(x, y, "b")               # a blue polygon
5260                 ax.fill(x, y, x2, y2)            # two polygons
5261                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5262 
5263         data : indexable object, optional
5264             An object with labelled data. If given, provide the label names to
5265             plot in *x* and *y*, e.g.::
5266 
5267                 ax.fill("time", "signal",
5268                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5269 
5270         Returns
5271         -------
5272         list of `~matplotlib.patches.Polygon`
5273 
5274         Other Parameters
5275         ----------------
5276         **kwargs : `~matplotlib.patches.Polygon` properties
5277 
5278         Notes
5279         -----
5280         Use :meth:`fill_between` if you would like to fill the region between
5281         two curves.
5282         """
5283         # For compatibility(!), get aliases from Line2D rather than Patch.
5284         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5285         # _get_patches_for_fill returns a generator, convert it to a list.
5286         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5287         for poly in patches:
5288             self.add_patch(poly)
5289         self._request_autoscale_view()
5290         return patches
5291 
5292     def _fill_between_x_or_y(
5293             self, ind_dir, ind, dep1, dep2=0, *,
5294             where=None, interpolate=False, step=None, **kwargs):
5295         # Common implementation between fill_between (*ind_dir*="x") and
5296         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5297         # *dep* the dependent variable.  The docstring below is interpolated
5298         # to generate both methods' docstrings.
5299         """
5300         Fill the area between two {dir} curves.
5301 
5302         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5303         *{dep}2*).  This creates one or multiple polygons describing the filled
5304         area.
5305 
5306         You may exclude some {dir} sections from filling using *where*.
5307 
5308         By default, the edges connect the given points directly.  Use *step*
5309         if the filling should be a step function, i.e. constant in between
5310         *{ind}*.
5311 
5312         Parameters
5313         ----------
5314         {ind} : array (length N)
5315             The {ind} coordinates of the nodes defining the curves.
5316 
5317         {dep}1 : array (length N) or scalar
5318             The {dep} coordinates of the nodes defining the first curve.
5319 
5320         {dep}2 : array (length N) or scalar, default: 0
5321             The {dep} coordinates of the nodes defining the second curve.
5322 
5323         where : array of bool (length N), optional
5324             Define *where* to exclude some {dir} regions from being filled.
5325             The filled regions are defined by the coordinates ``{ind}[where]``.
5326             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5327             ``where[i] and where[i+1]``.  Note that this definition implies
5328             that an isolated *True* value between two *False* values in *where*
5329             will not result in filling.  Both sides of the *True* position
5330             remain unfilled due to the adjacent *False* values.
5331 
5332         interpolate : bool, default: False
5333             This option is only relevant if *where* is used and the two curves
5334             are crossing each other.
5335 
5336             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5337             similar.  By default, the nodes of the polygon defining the filled
5338             region will only be placed at the positions in the *{ind}* array.
5339             Such a polygon cannot describe the above semantics close to the
5340             intersection.  The {ind}-sections containing the intersection are
5341             simply clipped.
5342 
5343             Setting *interpolate* to *True* will calculate the actual
5344             intersection point and extend the filled region up to this point.
5345 
5346         step : {{'pre', 'post', 'mid'}}, optional
5347             Define *step* if the filling should be a step function,
5348             i.e. constant in between *{ind}*.  The value determines where the
5349             step will occur:
5350 
5351             - 'pre': The y value is continued constantly to the left from
5352               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5353               value ``y[i]``.
5354             - 'post': The y value is continued constantly to the right from
5355               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5356               value ``y[i]``.
5357             - 'mid': Steps occur half-way between the *x* positions.
5358 
5359         Returns
5360         -------
5361         `.PolyCollection`
5362             A `.PolyCollection` containing the plotted polygons.
5363 
5364         Other Parameters
5365         ----------------
5366         data : indexable object, optional
5367             DATA_PARAMETER_PLACEHOLDER
5368 
5369         **kwargs
5370             All other keyword arguments are passed on to `.PolyCollection`.
5371             They control the `.Polygon` properties:
5372 
5373             %(PolyCollection:kwdoc)s
5374 
5375         See Also
5376         --------
5377         fill_between : Fill between two sets of y-values.
5378         fill_betweenx : Fill between two sets of x-values.
5379         """
5380 
5381         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5382 
5383         if not mpl.rcParams["_internal.classic_mode"]:
5384             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5385             if not any(c in kwargs for c in ("color", "facecolor")):
5386                 kwargs["facecolor"] = \
5387                     self._get_patches_for_fill.get_next_color()
5388 
5389         # Handle united data, such as dates
5390         ind, dep1, dep2 = map(
5391             ma.masked_invalid, self._process_unit_info(
5392                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5393 
5394         for name, array in [
5395                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5396             if array.ndim > 1:
5397                 raise ValueError(f"{name!r} is not 1-dimensional")
5398 
5399         if where is None:
5400             where = True
5401         else:
5402             where = np.asarray(where, dtype=bool)
5403             if where.size != ind.size:
5404                 raise ValueError(f"where size ({where.size}) does not match "
5405                                  f"{ind_dir} size ({ind.size})")
5406         where = where & ~functools.reduce(
5407             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5408 
5409         ind, dep1, dep2 = np.broadcast_arrays(
5410             np.atleast_1d(ind), dep1, dep2, subok=True)
5411 
5412         polys = []
5413         for idx0, idx1 in cbook.contiguous_regions(where):
5414             indslice = ind[idx0:idx1]
5415             dep1slice = dep1[idx0:idx1]
5416             dep2slice = dep2[idx0:idx1]
5417             if step is not None:
5418                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5419                 indslice, dep1slice, dep2slice = \
5420                     step_func(indslice, dep1slice, dep2slice)
5421 
5422             if not len(indslice):
5423                 continue
5424 
5425             N = len(indslice)
5426             pts = np.zeros((2 * N + 2, 2))
5427 
5428             if interpolate:
5429                 def get_interp_point(idx):
5430                     im1 = max(idx - 1, 0)
5431                     ind_values = ind[im1:idx+1]
5432                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5433                     dep1_values = dep1[im1:idx+1]
5434 
5435                     if len(diff_values) == 2:
5436                         if np.ma.is_masked(diff_values[1]):
5437                             return ind[im1], dep1[im1]
5438                         elif np.ma.is_masked(diff_values[0]):
5439                             return ind[idx], dep1[idx]
5440 
5441                     diff_order = diff_values.argsort()
5442                     diff_root_ind = np.interp(
5443                         0, diff_values[diff_order], ind_values[diff_order])
5444                     ind_order = ind_values.argsort()
5445                     diff_root_dep = np.interp(
5446                         diff_root_ind,
5447                         ind_values[ind_order], dep1_values[ind_order])
5448                     return diff_root_ind, diff_root_dep
5449 
5450                 start = get_interp_point(idx0)
5451                 end = get_interp_point(idx1)
5452             else:
5453                 # Handle scalar dep2 (e.g. 0): the fill should go all
5454                 # the way down to 0 even if none of the dep1 sample points do.
5455                 start = indslice[0], dep2slice[0]
5456                 end = indslice[-1], dep2slice[-1]
5457 
5458             pts[0] = start
5459             pts[N + 1] = end
5460 
5461             pts[1:N+1, 0] = indslice
5462             pts[1:N+1, 1] = dep1slice
5463             pts[N+2:, 0] = indslice[::-1]
5464             pts[N+2:, 1] = dep2slice[::-1]
5465 
5466             if ind_dir == "y":
5467                 pts = pts[:, ::-1]
5468 
5469             polys.append(pts)
5470 
5471         collection = mcoll.PolyCollection(polys, **kwargs)
5472 
5473         # now update the datalim and autoscale
5474         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5475                             np.column_stack([ind[where], dep2[where]])])
5476         if ind_dir == "y":
5477             pts = pts[:, ::-1]
5478 
5479         up_x = up_y = True
5480         if "transform" in kwargs:
5481             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5482         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5483 
5484         self.add_collection(collection, autolim=False)
5485         self._request_autoscale_view()
5486         return collection
5487 
5488     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5489                      step=None, **kwargs):
5490         return self._fill_between_x_or_y(
5491             "x", x, y1, y2,
5492             where=where, interpolate=interpolate, step=step, **kwargs)
5493 
5494     if _fill_between_x_or_y.__doc__:
5495         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5496             dir="horizontal", ind="x", dep="y"
5497         )
5498     fill_between = _preprocess_data(
5499         _docstring.dedent_interpd(fill_between),
5500         replace_names=["x", "y1", "y2", "where"])
5501 
5502     def fill_betweenx(self, y, x1, x2=0, where=None,
5503                       step=None, interpolate=False, **kwargs):
5504         return self._fill_between_x_or_y(
5505             "y", y, x1, x2,
5506             where=where, interpolate=interpolate, step=step, **kwargs)
5507 
5508     if _fill_between_x_or_y.__doc__:
5509         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5510             dir="vertical", ind="y", dep="x"
5511         )
5512     fill_betweenx = _preprocess_data(
5513         _docstring.dedent_interpd(fill_betweenx),
5514         replace_names=["y", "x1", "x2", "where"])
5515 
5516     #### plotting z(x, y): imshow, pcolor and relatives, contour
5517 
5518     @_preprocess_data()
5519     @_docstring.interpd
5520     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5521                interpolation=None, alpha=None,
5522                vmin=None, vmax=None, origin=None, extent=None,
5523                interpolation_stage=None, filternorm=True, filterrad=4.0,
5524                resample=None, url=None, **kwargs):
5525         """
5526         Display data as an image, i.e., on a 2D regular raster.
5527 
5528         The input may either be actual RGB(A) data, or 2D scalar data, which
5529         will be rendered as a pseudocolor image. For displaying a grayscale
5530         image set up the colormapping using the parameters
5531         ``cmap='gray', vmin=0, vmax=255``.
5532 
5533         The number of pixels used to render an image is set by the Axes size
5534         and the *dpi* of the figure. This can lead to aliasing artifacts when
5535         the image is resampled because the displayed image size will usually
5536         not match the size of *X* (see
5537         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5538         The resampling can be controlled via the *interpolation* parameter
5539         and/or :rc:`image.interpolation`.
5540 
5541         Parameters
5542         ----------
5543         X : array-like or PIL image
5544             The image data. Supported array shapes are:
5545 
5546             - (M, N): an image with scalar data. The values are mapped to
5547               colors using normalization and a colormap. See parameters *norm*,
5548               *cmap*, *vmin*, *vmax*.
5549             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5550             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5551               i.e. including transparency.
5552 
5553             The first two dimensions (M, N) define the rows and columns of
5554             the image.
5555 
5556             Out-of-range RGB(A) values are clipped.
5557 
5558         %(cmap_doc)s
5559 
5560             This parameter is ignored if *X* is RGB(A).
5561 
5562         %(norm_doc)s
5563 
5564             This parameter is ignored if *X* is RGB(A).
5565 
5566         %(vmin_vmax_doc)s
5567 
5568             This parameter is ignored if *X* is RGB(A).
5569 
5570         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5571             The aspect ratio of the Axes.  This parameter is particularly
5572             relevant for images since it determines whether data pixels are
5573             square.
5574 
5575             This parameter is a shortcut for explicitly calling
5576             `.Axes.set_aspect`. See there for further details.
5577 
5578             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5579               (unless pixel sizes are explicitly made non-square in data
5580               coordinates using *extent*).
5581             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5582               that the data fit in the Axes. In general, this will result in
5583               non-square pixels.
5584 
5585         interpolation : str, default: :rc:`image.interpolation`
5586             The interpolation method used.
5587 
5588             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5589             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5590             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5591             'sinc', 'lanczos', 'blackman'.
5592 
5593             The data *X* is resampled to the pixel size of the image on the
5594             figure canvas, using the interpolation method to either up- or
5595             downsample the data.
5596 
5597             If *interpolation* is 'none', then for the ps, pdf, and svg
5598             backends no down- or upsampling occurs, and the image data is
5599             passed to the backend as a native image.  Note that different ps,
5600             pdf, and svg viewers may display these raw pixels differently. On
5601             other backends, 'none' is the same as 'nearest'.
5602 
5603             If *interpolation* is the default 'antialiased', then 'nearest'
5604             interpolation is used if the image is upsampled by more than a
5605             factor of three (i.e. the number of display pixels is at least
5606             three times the size of the data array).  If the upsampling rate is
5607             smaller than 3, or the image is downsampled, then 'hanning'
5608             interpolation is used to act as an anti-aliasing filter, unless the
5609             image happens to be upsampled by exactly a factor of two or one.
5610 
5611             See
5612             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5613             for an overview of the supported interpolation methods, and
5614             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5615             a discussion of image antialiasing.
5616 
5617             Some interpolation methods require an additional radius parameter,
5618             which can be set by *filterrad*. Additionally, the antigrain image
5619             resize filter is controlled by the parameter *filternorm*.
5620 
5621         interpolation_stage : {'data', 'rgba'}, default: 'data'
5622             If 'data', interpolation
5623             is carried out on the data provided by the user.  If 'rgba', the
5624             interpolation is carried out after the colormapping has been
5625             applied (visual interpolation).
5626 
5627         alpha : float or array-like, optional
5628             The alpha blending value, between 0 (transparent) and 1 (opaque).
5629             If *alpha* is an array, the alpha blending values are applied pixel
5630             by pixel, and *alpha* must have the same shape as *X*.
5631 
5632         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5633             Place the [0, 0] index of the array in the upper left or lower
5634             left corner of the Axes. The convention (the default) 'upper' is
5635             typically used for matrices and images.
5636 
5637             Note that the vertical axis points upward for 'lower'
5638             but downward for 'upper'.
5639 
5640             See the :ref:`imshow_extent` tutorial for
5641             examples and a more detailed description.
5642 
5643         extent : floats (left, right, bottom, top), optional
5644             The bounding box in data coordinates that the image will fill.
5645             These values may be unitful and match the units of the Axes.
5646             The image is stretched individually along x and y to fill the box.
5647 
5648             The default extent is determined by the following conditions.
5649             Pixels have unit size in data coordinates. Their centers are on
5650             integer coordinates, and their center coordinates range from 0 to
5651             columns-1 horizontally and from 0 to rows-1 vertically.
5652 
5653             Note that the direction of the vertical axis and thus the default
5654             values for top and bottom depend on *origin*:
5655 
5656             - For ``origin == 'upper'`` the default is
5657               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5658             - For ``origin == 'lower'`` the default is
5659               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5660 
5661             See the :ref:`imshow_extent` tutorial for
5662             examples and a more detailed description.
5663 
5664         filternorm : bool, default: True
5665             A parameter for the antigrain image resize filter (see the
5666             antigrain documentation).  If *filternorm* is set, the filter
5667             normalizes integer values and corrects the rounding errors. It
5668             doesn't do anything with the source floating point values, it
5669             corrects only integers according to the rule of 1.0 which means
5670             that any sum of pixel weights must be equal to 1.0.  So, the
5671             filter function must produce a graph of the proper shape.
5672 
5673         filterrad : float > 0, default: 4.0
5674             The filter radius for filters that have a radius parameter, i.e.
5675             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5676 
5677         resample : bool, default: :rc:`image.resample`
5678             When *True*, use a full resampling method.  When *False*, only
5679             resample when the output image is larger than the input image.
5680 
5681         url : str, optional
5682             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5683 
5684         Returns
5685         -------
5686         `~matplotlib.image.AxesImage`
5687 
5688         Other Parameters
5689         ----------------
5690         data : indexable object, optional
5691             DATA_PARAMETER_PLACEHOLDER
5692 
5693         **kwargs : `~matplotlib.artist.Artist` properties
5694             These parameters are passed on to the constructor of the
5695             `.AxesImage` artist.
5696 
5697         See Also
5698         --------
5699         matshow : Plot a matrix or an array as an image.
5700 
5701         Notes
5702         -----
5703         Unless *extent* is used, pixel centers will be located at integer
5704         coordinates. In other words: the origin will coincide with the center
5705         of pixel (0, 0).
5706 
5707         There are two common representations for RGB images with an alpha
5708         channel:
5709 
5710         -   Straight (unassociated) alpha: R, G, and B channels represent the
5711             color of the pixel, disregarding its opacity.
5712         -   Premultiplied (associated) alpha: R, G, and B channels represent
5713             the color of the pixel, adjusted for its opacity by multiplication.
5714 
5715         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5716         (unassociated) alpha representation.
5717         """
5718         if aspect is None:
5719             aspect = mpl.rcParams['image.aspect']
5720         self.set_aspect(aspect)
5721         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5722                               interpolation=interpolation, origin=origin,
5723                               extent=extent, filternorm=filternorm,
5724                               filterrad=filterrad, resample=resample,
5725                               interpolation_stage=interpolation_stage,
5726                               **kwargs)
5727 
5728         im.set_data(X)
5729         im.set_alpha(alpha)
5730         if im.get_clip_path() is None:
5731             # image does not already have clipping set, clip to axes patch
5732             im.set_clip_path(self.patch)
5733         im._scale_norm(norm, vmin, vmax)
5734         im.set_url(url)
5735 
5736         # update ax.dataLim, and, if autoscaling, set viewLim
5737         # to tightly fit the image, regardless of dataLim.
5738         im.set_extent(im.get_extent())
5739 
5740         self.add_image(im)
5741         return im
5742 
5743     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5744         # - create X and Y if not present;
5745         # - reshape X and Y as needed if they are 1-D;
5746         # - check for proper sizes based on `shading` kwarg;
5747         # - reset shading if shading='auto' to flat or nearest
5748         #   depending on size;
5749 
5750         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5751         try:
5752             _api.check_in_list(_valid_shading, shading=shading)
5753         except ValueError:
5754             _api.warn_external(f"shading value '{shading}' not in list of "
5755                                f"valid values {_valid_shading}. Setting "
5756                                "shading='auto'.")
5757             shading = 'auto'
5758 
5759         if len(args) == 1:
5760             C = np.asanyarray(args[0])
5761             nrows, ncols = C.shape[:2]
5762             if shading in ['gouraud', 'nearest']:
5763                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5764             else:
5765                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5766                 shading = 'flat'
5767             C = cbook.safe_masked_invalid(C, copy=True)
5768             return X, Y, C, shading
5769 
5770         if len(args) == 3:
5771             # Check x and y for bad data...
5772             C = np.asanyarray(args[2])
5773             # unit conversion allows e.g. datetime objects as axis values
5774             X, Y = args[:2]
5775             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5776             X, Y = [cbook.safe_masked_invalid(a, copy=True) for a in [X, Y]]
5777 
5778             if funcname == 'pcolormesh':
5779                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5780                     raise ValueError(
5781                         'x and y arguments to pcolormesh cannot have '
5782                         'non-finite values or be of type '
5783                         'numpy.ma.MaskedArray with masked values')
5784             nrows, ncols = C.shape[:2]
5785         else:
5786             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5787 
5788         Nx = X.shape[-1]
5789         Ny = Y.shape[0]
5790         if X.ndim != 2 or X.shape[0] == 1:
5791             x = X.reshape(1, Nx)
5792             X = x.repeat(Ny, axis=0)
5793         if Y.ndim != 2 or Y.shape[1] == 1:
5794             y = Y.reshape(Ny, 1)
5795             Y = y.repeat(Nx, axis=1)
5796         if X.shape != Y.shape:
5797             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5798                             f'see help({funcname})')
5799 
5800         if shading == 'auto':
5801             if ncols == Nx and nrows == Ny:
5802                 shading = 'nearest'
5803             else:
5804                 shading = 'flat'
5805 
5806         if shading == 'flat':
5807             if (Nx, Ny) != (ncols + 1, nrows + 1):
5808                 raise TypeError(f"Dimensions of C {C.shape} should"
5809                                 f" be one smaller than X({Nx}) and Y({Ny})"
5810                                 f" while using shading='flat'"
5811                                 f" see help({funcname})")
5812         else:    # ['nearest', 'gouraud']:
5813             if (Nx, Ny) != (ncols, nrows):
5814                 raise TypeError('Dimensions of C %s are incompatible with'
5815                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5816                                     C.shape, Nx, Ny, funcname))
5817             if shading == 'nearest':
5818                 # grid is specified at the center, so define corners
5819                 # at the midpoints between the grid centers and then use the
5820                 # flat algorithm.
5821                 def _interp_grid(X):
5822                     # helper for below
5823                     if np.shape(X)[1] > 1:
5824                         dX = np.diff(X, axis=1)/2.
5825                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5826                             _api.warn_external(
5827                                 f"The input coordinates to {funcname} are "
5828                                 "interpreted as cell centers, but are not "
5829                                 "monotonically increasing or decreasing. "
5830                                 "This may lead to incorrectly calculated cell "
5831                                 "edges, in which case, please supply "
5832                                 f"explicit cell edges to {funcname}.")
5833 
5834                         hstack = np.ma.hstack if np.ma.isMA(X) else np.hstack
5835                         X = hstack((X[:, [0]] - dX[:, [0]],
5836                                     X[:, :-1] + dX,
5837                                     X[:, [-1]] + dX[:, [-1]]))
5838                     else:
5839                         # This is just degenerate, but we can't reliably guess
5840                         # a dX if there is just one value.
5841                         X = np.hstack((X, X))
5842                     return X
5843 
5844                 if ncols == Nx:
5845                     X = _interp_grid(X)
5846                     Y = _interp_grid(Y)
5847                 if nrows == Ny:
5848                     X = _interp_grid(X.T).T
5849                     Y = _interp_grid(Y.T).T
5850                 shading = 'flat'
5851 
5852         C = cbook.safe_masked_invalid(C, copy=True)
5853         return X, Y, C, shading
5854 
5855     @_preprocess_data()
5856     @_docstring.dedent_interpd
5857     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5858                vmin=None, vmax=None, **kwargs):
5859         r"""
5860         Create a pseudocolor plot with a non-regular rectangular grid.
5861 
5862         Call signature::
5863 
5864             pcolor([X, Y,] C, **kwargs)
5865 
5866         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5867 
5868         .. hint::
5869 
5870             ``pcolor()`` can be very slow for large arrays. In most
5871             cases you should use the similar but much faster
5872             `~.Axes.pcolormesh` instead. See
5873             :ref:`Differences between pcolor() and pcolormesh()
5874             <differences-pcolor-pcolormesh>` for a discussion of the
5875             differences.
5876 
5877         Parameters
5878         ----------
5879         C : 2D array-like
5880             The color-mapped values.  Color-mapping is controlled by *cmap*,
5881             *norm*, *vmin*, and *vmax*.
5882 
5883         X, Y : array-like, optional
5884             The coordinates of the corners of quadrilaterals of a pcolormesh::
5885 
5886                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5887                                       ●╶───╴●
5888                                       │     │
5889                                       ●╶───╴●
5890                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5891 
5892             Note that the column index corresponds to the x-coordinate, and
5893             the row index corresponds to y. For details, see the
5894             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5895 
5896             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5897             greater than those of *C*, and the quadrilateral is colored due
5898             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5899             dimensions, a warning will be raised and the last row and column
5900             of *C* will be ignored.
5901 
5902             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5903             the same as those of *C* (if not, a ValueError will be raised). The
5904             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5905 
5906             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5907             expanded as needed into the appropriate 2D arrays, making a
5908             rectangular grid.
5909 
5910         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5911             The fill style for the quadrilateral. Possible values:
5912 
5913             - 'flat': A solid color is used for each quad. The color of the
5914               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5915               ``C[i, j]``. The dimensions of *X* and *Y* should be
5916               one greater than those of *C*; if they are the same as *C*,
5917               then a deprecation warning is raised, and the last row
5918               and column of *C* are dropped.
5919             - 'nearest': Each grid point will have a color centered on it,
5920               extending halfway between the adjacent grid centers.  The
5921               dimensions of *X* and *Y* must be the same as *C*.
5922             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5923               larger than *C*.  Choose 'nearest' if dimensions are the same.
5924 
5925             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5926             for more description.
5927 
5928         %(cmap_doc)s
5929 
5930         %(norm_doc)s
5931 
5932         %(vmin_vmax_doc)s
5933 
5934         edgecolors : {'none', None, 'face', color, color sequence}, optional
5935             The color of the edges. Defaults to 'none'. Possible values:
5936 
5937             - 'none' or '': No edge.
5938             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5939               :rc:`patch.force_edgecolor` has to be True for this to work.
5940             - 'face': Use the adjacent face color.
5941             - A color or sequence of colors will set the edge color.
5942 
5943             The singular form *edgecolor* works as an alias.
5944 
5945         alpha : float, default: None
5946             The alpha blending value of the face color, between 0 (transparent)
5947             and 1 (opaque). Note: The edgecolor is currently not affected by
5948             this.
5949 
5950         snap : bool, default: False
5951             Whether to snap the mesh to pixel boundaries.
5952 
5953         Returns
5954         -------
5955         `matplotlib.collections.PolyQuadMesh`
5956 
5957         Other Parameters
5958         ----------------
5959         antialiaseds : bool, default: False
5960             The default *antialiaseds* is False if the default
5961             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5962             at patch boundaries, and works regardless of the value of alpha.
5963             If *edgecolors* is not "none", then the default *antialiaseds*
5964             is taken from :rc:`patch.antialiased`.
5965             Stroking the edges may be preferred if *alpha* is 1, but will
5966             cause artifacts otherwise.
5967 
5968         data : indexable object, optional
5969             DATA_PARAMETER_PLACEHOLDER
5970 
5971         **kwargs
5972             Additionally, the following arguments are allowed. They are passed
5973             along to the `~matplotlib.collections.PolyQuadMesh` constructor:
5974 
5975         %(PolyCollection:kwdoc)s
5976 
5977         See Also
5978         --------
5979         pcolormesh : for an explanation of the differences between
5980             pcolor and pcolormesh.
5981         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5982             faster alternative.
5983 
5984         Notes
5985         -----
5986         **Masked arrays**
5987 
5988         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5989         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5990         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5991         plotted.
5992 
5993         .. _axes-pcolor-grid-orientation:
5994 
5995         **Grid orientation**
5996 
5997         The grid orientation follows the standard matrix convention: An array
5998         *C* with shape (nrows, ncolumns) is plotted with the column number as
5999         *X* and the row number as *Y*.
6000         """
6001 
6002         if shading is None:
6003             shading = mpl.rcParams['pcolor.shading']
6004         shading = shading.lower()
6005         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
6006                                             kwargs=kwargs)
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiaseds' in kwargs:
6021             kwargs['antialiased'] = kwargs.pop('antialiaseds')
6022         if 'antialiased' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiased'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         if np.ma.isMaskedArray(X) or np.ma.isMaskedArray(Y):
6028             stack = np.ma.stack
6029             X = np.ma.asarray(X)
6030             Y = np.ma.asarray(Y)
6031             # For bounds collections later
6032             x = X.compressed()
6033             y = Y.compressed()
6034         else:
6035             stack = np.stack
6036             x = X
6037             y = Y
6038         coords = stack([X, Y], axis=-1)
6039 
6040         collection = mcoll.PolyQuadMesh(
6041             coords, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6042         collection._scale_norm(norm, vmin, vmax)
6043 
6044         # Transform from native to data coordinates?
6045         t = collection._transform
6046         if (not isinstance(t, mtransforms.Transform) and
6047                 hasattr(t, '_as_mpl_transform')):
6048             t = t._as_mpl_transform(self.axes)
6049 
6050         if t and any(t.contains_branch_seperately(self.transData)):
6051             trans_to_data = t - self.transData
6052             pts = np.vstack([x, y]).T.astype(float)
6053             transformed_pts = trans_to_data.transform(pts)
6054             x = transformed_pts[..., 0]
6055             y = transformed_pts[..., 1]
6056 
6057         self.add_collection(collection, autolim=False)
6058 
6059         minx = np.min(x)
6060         maxx = np.max(x)
6061         miny = np.min(y)
6062         maxy = np.max(y)
6063         collection.sticky_edges.x[:] = [minx, maxx]
6064         collection.sticky_edges.y[:] = [miny, maxy]
6065         corners = (minx, miny), (maxx, maxy)
6066         self.update_datalim(corners)
6067         self._request_autoscale_view()
6068         return collection
6069 
6070     @_preprocess_data()
6071     @_docstring.dedent_interpd
6072     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6073                    vmax=None, shading=None, antialiased=False, **kwargs):
6074         """
6075         Create a pseudocolor plot with a non-regular rectangular grid.
6076 
6077         Call signature::
6078 
6079             pcolormesh([X, Y,] C, **kwargs)
6080 
6081         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6082 
6083         .. hint::
6084 
6085            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6086            and preferred in most cases. For a detailed discussion on the
6087            differences see :ref:`Differences between pcolor() and pcolormesh()
6088            <differences-pcolor-pcolormesh>`.
6089 
6090         Parameters
6091         ----------
6092         C : array-like
6093             The mesh data. Supported array shapes are:
6094 
6095             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6096               colors using normalization and a colormap. See parameters *norm*,
6097               *cmap*, *vmin*, *vmax*.
6098             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6099             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6100               i.e. including transparency.
6101 
6102             The first two dimensions (M, N) define the rows and columns of
6103             the mesh data.
6104 
6105         X, Y : array-like, optional
6106             The coordinates of the corners of quadrilaterals of a pcolormesh::
6107 
6108                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6109                                       ●╶───╴●
6110                                       │     │
6111                                       ●╶───╴●
6112                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6113 
6114             Note that the column index corresponds to the x-coordinate, and
6115             the row index corresponds to y. For details, see the
6116             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6117 
6118             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6119             greater than those of *C*, and the quadrilateral is colored due
6120             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6121             dimensions, a warning will be raised and the last row and column
6122             of *C* will be ignored.
6123 
6124             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6125             and *Y* should be the same as those of *C* (if not, a ValueError
6126             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6127             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6128             interpolation is caried out between the quadrilateral corners.
6129 
6130             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6131             expanded as needed into the appropriate 2D arrays, making a
6132             rectangular grid.
6133 
6134         %(cmap_doc)s
6135 
6136         %(norm_doc)s
6137 
6138         %(vmin_vmax_doc)s
6139 
6140         edgecolors : {'none', None, 'face', color, color sequence}, optional
6141             The color of the edges. Defaults to 'none'. Possible values:
6142 
6143             - 'none' or '': No edge.
6144             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6145               :rc:`patch.force_edgecolor` has to be True for this to work.
6146             - 'face': Use the adjacent face color.
6147             - A color or sequence of colors will set the edge color.
6148 
6149             The singular form *edgecolor* works as an alias.
6150 
6151         alpha : float, default: None
6152             The alpha blending value, between 0 (transparent) and 1 (opaque).
6153 
6154         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6155             The fill style for the quadrilateral; defaults to
6156             :rc:`pcolor.shading`. Possible values:
6157 
6158             - 'flat': A solid color is used for each quad. The color of the
6159               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6160               ``C[i, j]``. The dimensions of *X* and *Y* should be
6161               one greater than those of *C*; if they are the same as *C*,
6162               then a deprecation warning is raised, and the last row
6163               and column of *C* are dropped.
6164             - 'nearest': Each grid point will have a color centered on it,
6165               extending halfway between the adjacent grid centers.  The
6166               dimensions of *X* and *Y* must be the same as *C*.
6167             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6168               corners (i', j') are given by ``C[i', j']``. The color values of
6169               the area in between is interpolated from the corner values.
6170               The dimensions of *X* and *Y* must be the same as *C*. When
6171               Gouraud shading is used, *edgecolors* is ignored.
6172             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6173               larger than *C*.  Choose 'nearest' if dimensions are the same.
6174 
6175             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6176             for more description.
6177 
6178         snap : bool, default: False
6179             Whether to snap the mesh to pixel boundaries.
6180 
6181         rasterized : bool, optional
6182             Rasterize the pcolormesh when drawing vector graphics.  This can
6183             speed up rendering and produce smaller files for large data sets.
6184             See also :doc:`/gallery/misc/rasterization_demo`.
6185 
6186         Returns
6187         -------
6188         `matplotlib.collections.QuadMesh`
6189 
6190         Other Parameters
6191         ----------------
6192         data : indexable object, optional
6193             DATA_PARAMETER_PLACEHOLDER
6194 
6195         **kwargs
6196             Additionally, the following arguments are allowed. They are passed
6197             along to the `~matplotlib.collections.QuadMesh` constructor:
6198 
6199         %(QuadMesh:kwdoc)s
6200 
6201         See Also
6202         --------
6203         pcolor : An alternative implementation with slightly different
6204             features. For a detailed discussion on the differences see
6205             :ref:`Differences between pcolor() and pcolormesh()
6206             <differences-pcolor-pcolormesh>`.
6207         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6208             faster alternative.
6209 
6210         Notes
6211         -----
6212         **Masked arrays**
6213 
6214         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6215         quadrilateral will be transparent. Masking of *X* and *Y* is not
6216         supported. Use `~.Axes.pcolor` if you need this functionality.
6217 
6218         .. _axes-pcolormesh-grid-orientation:
6219 
6220         **Grid orientation**
6221 
6222         The grid orientation follows the standard matrix convention: An array
6223         *C* with shape (nrows, ncolumns) is plotted with the column number as
6224         *X* and the row number as *Y*.
6225 
6226         .. _differences-pcolor-pcolormesh:
6227 
6228         **Differences between pcolor() and pcolormesh()**
6229 
6230         Both methods are used to create a pseudocolor plot of a 2D array
6231         using quadrilaterals.
6232 
6233         The main difference lies in the created object and internal data
6234         handling:
6235         While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`
6236         returns a `.QuadMesh`. The latter is more specialized for the given
6237         purpose and thus is faster. It should almost always be preferred.
6238 
6239         There is also a slight difference in the handling of masked arrays.
6240         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6241         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6242         and *Y*. The reason lies in the internal handling of the masked values.
6243         `~.Axes.pcolor` leaves out the respective polygons from the
6244         PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked
6245         elements to transparent. You can see the difference when using
6246         edgecolors. While all edges are drawn irrespective of masking in a
6247         QuadMesh, the edge between two adjacent masked quadrilaterals in
6248         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6249         exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual
6250         polygon, it also supports applying hatches and linestyles to the collection.
6251 
6252         Another difference is the support of Gouraud shading in
6253         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6254 
6255         """
6256         if shading is None:
6257             shading = mpl.rcParams['pcolor.shading']
6258         shading = shading.lower()
6259         kwargs.setdefault('edgecolors', 'none')
6260 
6261         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6262                                             shading=shading, kwargs=kwargs)
6263         coords = np.stack([X, Y], axis=-1)
6264 
6265         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6266 
6267         collection = mcoll.QuadMesh(
6268             coords, antialiased=antialiased, shading=shading,
6269             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6270         collection._scale_norm(norm, vmin, vmax)
6271 
6272         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6273 
6274         # Transform from native to data coordinates?
6275         t = collection._transform
6276         if (not isinstance(t, mtransforms.Transform) and
6277                 hasattr(t, '_as_mpl_transform')):
6278             t = t._as_mpl_transform(self.axes)
6279 
6280         if t and any(t.contains_branch_seperately(self.transData)):
6281             trans_to_data = t - self.transData
6282             coords = trans_to_data.transform(coords)
6283 
6284         self.add_collection(collection, autolim=False)
6285 
6286         minx, miny = np.min(coords, axis=0)
6287         maxx, maxy = np.max(coords, axis=0)
6288         collection.sticky_edges.x[:] = [minx, maxx]
6289         collection.sticky_edges.y[:] = [miny, maxy]
6290         corners = (minx, miny), (maxx, maxy)
6291         self.update_datalim(corners)
6292         self._request_autoscale_view()
6293         return collection
6294 
6295     @_preprocess_data()
6296     @_docstring.dedent_interpd
6297     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6298                    vmax=None, **kwargs):
6299         """
6300         Create a pseudocolor plot with a non-regular rectangular grid.
6301 
6302         Call signature::
6303 
6304           ax.pcolorfast([X, Y], C, /, **kwargs)
6305 
6306         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6307         It's designed to provide the fastest pcolor-type plotting with the
6308         Agg backend. To achieve this, it uses different algorithms internally
6309         depending on the complexity of the input grid (regular rectangular,
6310         non-regular rectangular or arbitrary quadrilateral).
6311 
6312         .. warning::
6313 
6314            This method is experimental. Compared to `~.Axes.pcolor` or
6315            `~.Axes.pcolormesh` it has some limitations:
6316 
6317            - It supports only flat shading (no outlines)
6318            - It lacks support for log scaling of the axes.
6319            - It does not have a pyplot wrapper.
6320 
6321         Parameters
6322         ----------
6323         C : array-like
6324             The image data. Supported array shapes are:
6325 
6326             - (M, N): an image with scalar data.  Color-mapping is controlled
6327               by *cmap*, *norm*, *vmin*, and *vmax*.
6328             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6329             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6330               i.e. including transparency.
6331 
6332             The first two dimensions (M, N) define the rows and columns of
6333             the image.
6334 
6335             This parameter can only be passed positionally.
6336 
6337         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6338             *X* and *Y* are used to specify the coordinates of the
6339             quadrilaterals. There are different ways to do this:
6340 
6341             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6342               a *uniform rectangular grid*.
6343 
6344               The tuples define the outer edges of the grid. All individual
6345               quadrilaterals will be of the same size. This is the fastest
6346               version.
6347 
6348             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6349               grid*.
6350 
6351               In this case *X* and *Y* have to be monotonic 1D arrays of length
6352               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6353 
6354               The speed is intermediate. Note: The grid is checked, and if
6355               found to be uniform the fast version is used.
6356 
6357             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6358               grid* (i.e. if the quadrilaterals are not rectangular).
6359 
6360               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6361               specifying the x and y coordinates of the corners of the colored
6362               quadrilaterals.
6363 
6364               This is the most general, but the slowest to render.  It may
6365               produce faster and more compact output using ps, pdf, and
6366               svg backends, however.
6367 
6368             These arguments can only be passed positionally.
6369 
6370         %(cmap_doc)s
6371 
6372             This parameter is ignored if *C* is RGB(A).
6373 
6374         %(norm_doc)s
6375 
6376             This parameter is ignored if *C* is RGB(A).
6377 
6378         %(vmin_vmax_doc)s
6379 
6380             This parameter is ignored if *C* is RGB(A).
6381 
6382         alpha : float, default: None
6383             The alpha blending value, between 0 (transparent) and 1 (opaque).
6384 
6385         snap : bool, default: False
6386             Whether to snap the mesh to pixel boundaries.
6387 
6388         Returns
6389         -------
6390         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6391             The return type depends on the type of grid:
6392 
6393             - `.AxesImage` for a regular rectangular grid.
6394             - `.PcolorImage` for a non-regular rectangular grid.
6395             - `.QuadMesh` for a non-rectangular grid.
6396 
6397         Other Parameters
6398         ----------------
6399         data : indexable object, optional
6400             DATA_PARAMETER_PLACEHOLDER
6401 
6402         **kwargs
6403             Supported additional parameters depend on the type of grid.
6404             See return types of *image* for further description.
6405         """
6406 
6407         C = args[-1]
6408         nr, nc = np.shape(C)[:2]
6409         if len(args) == 1:
6410             style = "image"
6411             x = [0, nc]
6412             y = [0, nr]
6413         elif len(args) == 3:
6414             x, y = args[:2]
6415             x = np.asarray(x)
6416             y = np.asarray(y)
6417             if x.ndim == 1 and y.ndim == 1:
6418                 if x.size == 2 and y.size == 2:
6419                     style = "image"
6420                 else:
6421                     dx = np.diff(x)
6422                     dy = np.diff(y)
6423                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6424                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6425                         style = "image"
6426                     else:
6427                         style = "pcolorimage"
6428             elif x.ndim == 2 and y.ndim == 2:
6429                 style = "quadmesh"
6430             else:
6431                 raise TypeError("arguments do not match valid signatures")
6432         else:
6433             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6434 
6435         if style == "quadmesh":
6436             # data point in each cell is value at lower left corner
6437             coords = np.stack([x, y], axis=-1)
6438             if np.ndim(C) not in {2, 3}:
6439                 raise ValueError("C must be 2D or 3D")
6440             collection = mcoll.QuadMesh(
6441                 coords, array=C,
6442                 alpha=alpha, cmap=cmap, norm=norm,
6443                 antialiased=False, edgecolors="none")
6444             self.add_collection(collection, autolim=False)
6445             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6446             ret = collection
6447 
6448         else:  # It's one of the two image styles.
6449             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6450             if style == "image":
6451                 im = mimage.AxesImage(
6452                     self, cmap=cmap, norm=norm,
6453                     data=C, alpha=alpha, extent=extent,
6454                     interpolation='nearest', origin='lower',
6455                     **kwargs)
6456             elif style == "pcolorimage":
6457                 im = mimage.PcolorImage(
6458                     self, x, y, C,
6459                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6460                     **kwargs)
6461             self.add_image(im)
6462             ret = im
6463 
6464         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6465             ret._scale_norm(norm, vmin, vmax)
6466 
6467         if ret.get_clip_path() is None:
6468             # image does not already have clipping set, clip to axes patch
6469             ret.set_clip_path(self.patch)
6470 
6471         ret.sticky_edges.x[:] = [xl, xr]
6472         ret.sticky_edges.y[:] = [yb, yt]
6473         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6474         self._request_autoscale_view(tight=True)
6475         return ret
6476 
6477     @_preprocess_data()
6478     @_docstring.dedent_interpd
6479     def contour(self, *args, **kwargs):
6480         """
6481         Plot contour lines.
6482 
6483         Call signature::
6484 
6485             contour([X, Y,] Z, [levels], **kwargs)
6486         %(contour_doc)s
6487         """
6488         kwargs['filled'] = False
6489         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6490         self._request_autoscale_view()
6491         return contours
6492 
6493     @_preprocess_data()
6494     @_docstring.dedent_interpd
6495     def contourf(self, *args, **kwargs):
6496         """
6497         Plot filled contours.
6498 
6499         Call signature::
6500 
6501             contourf([X, Y,] Z, [levels], **kwargs)
6502         %(contour_doc)s
6503         """
6504         kwargs['filled'] = True
6505         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6506         self._request_autoscale_view()
6507         return contours
6508 
6509     def clabel(self, CS, levels=None, **kwargs):
6510         """
6511         Label a contour plot.
6512 
6513         Adds labels to line contours in given `.ContourSet`.
6514 
6515         Parameters
6516         ----------
6517         CS : `.ContourSet` instance
6518             Line contours to label.
6519 
6520         levels : array-like, optional
6521             A list of level values, that should be labeled. The list must be
6522             a subset of ``CS.levels``. If not given, all levels are labeled.
6523 
6524         **kwargs
6525             All other parameters are documented in `~.ContourLabeler.clabel`.
6526         """
6527         return CS.clabel(levels, **kwargs)
6528 
6529     #### Data analysis
6530 
6531     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6532     def hist(self, x, bins=None, range=None, density=False, weights=None,
6533              cumulative=False, bottom=None, histtype='bar', align='mid',
6534              orientation='vertical', rwidth=None, log=False,
6535              color=None, label=None, stacked=False, **kwargs):
6536         """
6537         Compute and plot a histogram.
6538 
6539         This method uses `numpy.histogram` to bin the data in *x* and count the
6540         number of values in each bin, then draws the distribution either as a
6541         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6542         *weights* parameters are forwarded to `numpy.histogram`.
6543 
6544         If the data has already been binned and counted, use `~.bar` or
6545         `~.stairs` to plot the distribution::
6546 
6547             counts, bins = np.histogram(x)
6548             plt.stairs(counts, bins)
6549 
6550         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6551         treating each bin as a single point with a weight equal to its count::
6552 
6553             plt.hist(bins[:-1], bins, weights=counts)
6554 
6555         The data input *x* can be a singular array, a list of datasets of
6556         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6557         which each column is a dataset. Note that the ndarray form is
6558         transposed relative to the list form. If the input is an array, then
6559         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6560         sequence of arrays, then the return value is a tuple
6561         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6562 
6563         Masked arrays are not supported.
6564 
6565         Parameters
6566         ----------
6567         x : (n,) array or sequence of (n,) arrays
6568             Input values, this takes either a single array or a sequence of
6569             arrays which are not required to be of the same length.
6570 
6571         bins : int or sequence or str, default: :rc:`hist.bins`
6572             If *bins* is an integer, it defines the number of equal-width bins
6573             in the range.
6574 
6575             If *bins* is a sequence, it defines the bin edges, including the
6576             left edge of the first bin and the right edge of the last bin;
6577             in this case, bins may be unequally spaced.  All but the last
6578             (righthand-most) bin is half-open.  In other words, if *bins* is::
6579 
6580                 [1, 2, 3, 4]
6581 
6582             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6583             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6584             *includes* 4.
6585 
6586             If *bins* is a string, it is one of the binning strategies
6587             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6588             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6589 
6590         range : tuple or None, default: None
6591             The lower and upper range of the bins. Lower and upper outliers
6592             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6593             Range has no effect if *bins* is a sequence.
6594 
6595             If *bins* is a sequence or *range* is specified, autoscaling
6596             is based on the specified bin range instead of the
6597             range of x.
6598 
6599         density : bool, default: False
6600             If ``True``, draw and return a probability density: each bin
6601             will display the bin's raw count divided by the total number of
6602             counts *and the bin width*
6603             (``density = counts / (sum(counts) * np.diff(bins))``),
6604             so that the area under the histogram integrates to 1
6605             (``np.sum(density * np.diff(bins)) == 1``).
6606 
6607             If *stacked* is also ``True``, the sum of the histograms is
6608             normalized to 1.
6609 
6610         weights : (n,) array-like or None, default: None
6611             An array of weights, of the same shape as *x*.  Each value in
6612             *x* only contributes its associated weight towards the bin count
6613             (instead of 1).  If *density* is ``True``, the weights are
6614             normalized, so that the integral of the density over the range
6615             remains 1.
6616 
6617         cumulative : bool or -1, default: False
6618             If ``True``, then a histogram is computed where each bin gives the
6619             counts in that bin plus all bins for smaller values. The last bin
6620             gives the total number of datapoints.
6621 
6622             If *density* is also ``True`` then the histogram is normalized such
6623             that the last bin equals 1.
6624 
6625             If *cumulative* is a number less than 0 (e.g., -1), the direction
6626             of accumulation is reversed.  In this case, if *density* is also
6627             ``True``, then the histogram is normalized such that the first bin
6628             equals 1.
6629 
6630         bottom : array-like, scalar, or None, default: None
6631             Location of the bottom of each bin, i.e. bins are drawn from
6632             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6633             of each bin is shifted by the same amount. If an array, each bin
6634             is shifted independently and the length of bottom must match the
6635             number of bins. If None, defaults to 0.
6636 
6637         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6638             The type of histogram to draw.
6639 
6640             - 'bar' is a traditional bar-type histogram.  If multiple data
6641               are given the bars are arranged side by side.
6642             - 'barstacked' is a bar-type histogram where multiple
6643               data are stacked on top of each other.
6644             - 'step' generates a lineplot that is by default unfilled.
6645             - 'stepfilled' generates a lineplot that is by default filled.
6646 
6647         align : {'left', 'mid', 'right'}, default: 'mid'
6648             The horizontal alignment of the histogram bars.
6649 
6650             - 'left': bars are centered on the left bin edges.
6651             - 'mid': bars are centered between the bin edges.
6652             - 'right': bars are centered on the right bin edges.
6653 
6654         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6655             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6656             and the *bottom* kwarg will be the left edges.
6657 
6658         rwidth : float or None, default: None
6659             The relative width of the bars as a fraction of the bin width.  If
6660             ``None``, automatically compute the width.
6661 
6662             Ignored if *histtype* is 'step' or 'stepfilled'.
6663 
6664         log : bool, default: False
6665             If ``True``, the histogram axis will be set to a log scale.
6666 
6667         color : color or array-like of colors or None, default: None
6668             Color or sequence of colors, one per dataset.  Default (``None``)
6669             uses the standard line color sequence.
6670 
6671         label : str or None, default: None
6672             String, or sequence of strings to match multiple datasets.  Bar
6673             charts yield multiple patches per dataset, but only the first gets
6674             the label, so that `~.Axes.legend` will work as expected.
6675 
6676         stacked : bool, default: False
6677             If ``True``, multiple data are stacked on top of each other If
6678             ``False`` multiple data are arranged side by side if histtype is
6679             'bar' or on top of each other if histtype is 'step'
6680 
6681         Returns
6682         -------
6683         n : array or list of arrays
6684             The values of the histogram bins. See *density* and *weights* for a
6685             description of the possible semantics.  If input *x* is an array,
6686             then this is an array of length *nbins*. If input is a sequence of
6687             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6688             the values of the histograms for each of the arrays in the same
6689             order.  The dtype of the array *n* (or of its element arrays) will
6690             always be float even if no weighting or normalization is used.
6691 
6692         bins : array
6693             The edges of the bins. Length nbins + 1 (nbins left edges and right
6694             edge of last bin).  Always a single array even when multiple data
6695             sets are passed in.
6696 
6697         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6698 such objects
6699             Container of individual artists used to create the histogram
6700             or list of such containers if there are multiple input datasets.
6701 
6702         Other Parameters
6703         ----------------
6704         data : indexable object, optional
6705             DATA_PARAMETER_PLACEHOLDER
6706 
6707         **kwargs
6708             `~matplotlib.patches.Patch` properties
6709 
6710         See Also
6711         --------
6712         hist2d : 2D histogram with rectangular bins
6713         hexbin : 2D histogram with hexagonal bins
6714         stairs : Plot a pre-computed histogram
6715         bar : Plot a pre-computed histogram
6716 
6717         Notes
6718         -----
6719         For large numbers of bins (>1000), plotting can be significantly
6720         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6721         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6722         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6723         """
6724         # Avoid shadowing the builtin.
6725         bin_range = range
6726         from builtins import range
6727 
6728         if np.isscalar(x):
6729             x = [x]
6730 
6731         if bins is None:
6732             bins = mpl.rcParams['hist.bins']
6733 
6734         # Validate string inputs here to avoid cluttering subsequent code.
6735         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6736                            histtype=histtype)
6737         _api.check_in_list(['left', 'mid', 'right'], align=align)
6738         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6739 
6740         if histtype == 'barstacked' and not stacked:
6741             stacked = True
6742 
6743         # Massage 'x' for processing.
6744         x = cbook._reshape_2D(x, 'x')
6745         nx = len(x)  # number of datasets
6746 
6747         # Process unit information.  _process_unit_info sets the unit and
6748         # converts the first dataset; then we convert each following dataset
6749         # one at a time.
6750         if orientation == "vertical":
6751             convert_units = self.convert_xunits
6752             x = [*self._process_unit_info([("x", x[0])], kwargs),
6753                  *map(convert_units, x[1:])]
6754         else:  # horizontal
6755             convert_units = self.convert_yunits
6756             x = [*self._process_unit_info([("y", x[0])], kwargs),
6757                  *map(convert_units, x[1:])]
6758 
6759         if bin_range is not None:
6760             bin_range = convert_units(bin_range)
6761 
6762         if not cbook.is_scalar_or_string(bins):
6763             bins = convert_units(bins)
6764 
6765         # We need to do to 'weights' what was done to 'x'
6766         if weights is not None:
6767             w = cbook._reshape_2D(weights, 'weights')
6768         else:
6769             w = [None] * nx
6770 
6771         if len(w) != nx:
6772             raise ValueError('weights should have the same shape as x')
6773 
6774         input_empty = True
6775         for xi, wi in zip(x, w):
6776             len_xi = len(xi)
6777             if wi is not None and len(wi) != len_xi:
6778                 raise ValueError('weights should have the same shape as x')
6779             if len_xi:
6780                 input_empty = False
6781 
6782         if color is None:
6783             colors = [self._get_lines.get_next_color() for i in range(nx)]
6784         else:
6785             colors = mcolors.to_rgba_array(color)
6786             if len(colors) != nx:
6787                 raise ValueError(f"The 'color' keyword argument must have one "
6788                                  f"color per dataset, but {nx} datasets and "
6789                                  f"{len(colors)} colors were provided")
6790 
6791         hist_kwargs = dict()
6792 
6793         # if the bin_range is not given, compute without nan numpy
6794         # does not do this for us when guessing the range (but will
6795         # happily ignore nans when computing the histogram).
6796         if bin_range is None:
6797             xmin = np.inf
6798             xmax = -np.inf
6799             for xi in x:
6800                 if len(xi):
6801                     # python's min/max ignore nan,
6802                     # np.minnan returns nan for all nan input
6803                     xmin = min(xmin, np.nanmin(xi))
6804                     xmax = max(xmax, np.nanmax(xi))
6805             if xmin <= xmax:  # Only happens if we have seen a finite value.
6806                 bin_range = (xmin, xmax)
6807 
6808         # If bins are not specified either explicitly or via range,
6809         # we need to figure out the range required for all datasets,
6810         # and supply that to np.histogram.
6811         if not input_empty and len(x) > 1:
6812             if weights is not None:
6813                 _w = np.concatenate(w)
6814             else:
6815                 _w = None
6816             bins = np.histogram_bin_edges(
6817                 np.concatenate(x), bins, bin_range, _w)
6818         else:
6819             hist_kwargs['range'] = bin_range
6820 
6821         density = bool(density)
6822         if density and not stacked:
6823             hist_kwargs['density'] = density
6824 
6825         # List to store all the top coordinates of the histograms
6826         tops = []  # Will have shape (n_datasets, n_bins).
6827         # Loop through datasets
6828         for i in range(nx):
6829             # this will automatically overwrite bins,
6830             # so that each histogram uses the same bins
6831             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6832             tops.append(m)
6833         tops = np.array(tops, float)  # causes problems later if it's an int
6834         bins = np.array(bins, float)  # causes problems if float16
6835         if stacked:
6836             tops = tops.cumsum(axis=0)
6837             # If a stacked density plot, normalize so the area of all the
6838             # stacked histograms together is 1
6839             if density:
6840                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6841         if cumulative:
6842             slc = slice(None)
6843             if isinstance(cumulative, Number) and cumulative < 0:
6844                 slc = slice(None, None, -1)
6845             if density:
6846                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6847             else:
6848                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6849 
6850         patches = []
6851 
6852         if histtype.startswith('bar'):
6853 
6854             totwidth = np.diff(bins)
6855 
6856             if rwidth is not None:
6857                 dr = np.clip(rwidth, 0, 1)
6858             elif (len(tops) > 1 and
6859                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6860                 dr = 0.8
6861             else:
6862                 dr = 1.0
6863 
6864             if histtype == 'bar' and not stacked:
6865                 width = dr * totwidth / nx
6866                 dw = width
6867                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6868             elif histtype == 'barstacked' or stacked:
6869                 width = dr * totwidth
6870                 boffset, dw = 0.0, 0.0
6871 
6872             if align == 'mid':
6873                 boffset += 0.5 * totwidth
6874             elif align == 'right':
6875                 boffset += totwidth
6876 
6877             if orientation == 'horizontal':
6878                 _barfunc = self.barh
6879                 bottom_kwarg = 'left'
6880             else:  # orientation == 'vertical'
6881                 _barfunc = self.bar
6882                 bottom_kwarg = 'bottom'
6883 
6884             for top, color in zip(tops, colors):
6885                 if bottom is None:
6886                     bottom = np.zeros(len(top))
6887                 if stacked:
6888                     height = top - bottom
6889                 else:
6890                     height = top
6891                 bars = _barfunc(bins[:-1]+boffset, height, width,
6892                                 align='center', log=log,
6893                                 color=color, **{bottom_kwarg: bottom})
6894                 patches.append(bars)
6895                 if stacked:
6896                     bottom = top
6897                 boffset += dw
6898             # Remove stickies from all bars but the lowest ones, as otherwise
6899             # margin expansion would be unable to cross the stickies in the
6900             # middle of the bars.
6901             for bars in patches[1:]:
6902                 for patch in bars:
6903                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6904 
6905         elif histtype.startswith('step'):
6906             # these define the perimeter of the polygon
6907             x = np.zeros(4 * len(bins) - 3)
6908             y = np.zeros(4 * len(bins) - 3)
6909 
6910             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6911             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6912 
6913             if bottom is None:
6914                 bottom = 0
6915 
6916             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6917             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6918 
6919             if log:
6920                 if orientation == 'horizontal':
6921                     self.set_xscale('log', nonpositive='clip')
6922                 else:  # orientation == 'vertical'
6923                     self.set_yscale('log', nonpositive='clip')
6924 
6925             if align == 'left':
6926                 x -= 0.5*(bins[1]-bins[0])
6927             elif align == 'right':
6928                 x += 0.5*(bins[1]-bins[0])
6929 
6930             # If fill kwarg is set, it will be passed to the patch collection,
6931             # overriding this
6932             fill = (histtype == 'stepfilled')
6933 
6934             xvals, yvals = [], []
6935             for top in tops:
6936                 if stacked:
6937                     # top of the previous polygon becomes the bottom
6938                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6939                 # set the top of this polygon
6940                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6941 
6942                 # The starting point of the polygon has not yet been
6943                 # updated. So far only the endpoint was adjusted. This
6944                 # assignment closes the polygon. The redundant endpoint is
6945                 # later discarded (for step and stepfilled).
6946                 y[0] = y[-1]
6947 
6948                 if orientation == 'horizontal':
6949                     xvals.append(y.copy())
6950                     yvals.append(x.copy())
6951                 else:
6952                     xvals.append(x.copy())
6953                     yvals.append(y.copy())
6954 
6955             # stepfill is closed, step is not
6956             split = -1 if fill else 2 * len(bins)
6957             # add patches in reverse order so that when stacking,
6958             # items lower in the stack are plotted on top of
6959             # items higher in the stack
6960             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6961                 patches.append(self.fill(
6962                     x[:split], y[:split],
6963                     closed=True if fill else None,
6964                     facecolor=color,
6965                     edgecolor=None if fill else color,
6966                     fill=fill if fill else None,
6967                     zorder=None if fill else mlines.Line2D.zorder))
6968             for patch_list in patches:
6969                 for patch in patch_list:
6970                     if orientation == 'vertical':
6971                         patch.sticky_edges.y.append(0)
6972                     elif orientation == 'horizontal':
6973                         patch.sticky_edges.x.append(0)
6974 
6975             # we return patches, so put it back in the expected order
6976             patches.reverse()
6977 
6978         # If None, make all labels None (via zip_longest below); otherwise,
6979         # cast each element to str, but keep a single str as it.
6980         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6981         for patch, lbl in itertools.zip_longest(patches, labels):
6982             if patch:
6983                 p = patch[0]
6984                 p._internal_update(kwargs)
6985                 if lbl is not None:
6986                     p.set_label(lbl)
6987                 for p in patch[1:]:
6988                     p._internal_update(kwargs)
6989                     p.set_label('_nolegend_')
6990 
6991         if nx == 1:
6992             return tops[0], bins, patches[0]
6993         else:
6994             patch_type = ("BarContainer" if histtype.startswith("bar")
6995                           else "list[Polygon]")
6996             return tops, bins, cbook.silent_list(patch_type, patches)
6997 
6998     @_preprocess_data()
6999     def stairs(self, values, edges=None, *,
7000                orientation='vertical', baseline=0, fill=False, **kwargs):
7001         """
7002         A stepwise constant function as a line with bounding edges
7003         or a filled plot.
7004 
7005         Parameters
7006         ----------
7007         values : array-like
7008             The step heights.
7009 
7010         edges : array-like
7011             The edge positions, with ``len(edges) == len(vals) + 1``,
7012             between which the curve takes on vals values.
7013 
7014         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7015             The direction of the steps. Vertical means that *values* are along
7016             the y-axis, and edges are along the x-axis.
7017 
7018         baseline : float, array-like or None, default: 0
7019             The bottom value of the bounding edges or when
7020             ``fill=True``, position of lower edge. If *fill* is
7021             True or an array is passed to *baseline*, a closed
7022             path is drawn.
7023 
7024         fill : bool, default: False
7025             Whether the area under the step curve should be filled.
7026 
7027         Returns
7028         -------
7029         StepPatch : `~matplotlib.patches.StepPatch`
7030 
7031         Other Parameters
7032         ----------------
7033         data : indexable object, optional
7034             DATA_PARAMETER_PLACEHOLDER
7035 
7036         **kwargs
7037             `~matplotlib.patches.StepPatch` properties
7038 
7039         """
7040 
7041         if 'color' in kwargs:
7042             _color = kwargs.pop('color')
7043         else:
7044             _color = self._get_lines.get_next_color()
7045         if fill:
7046             kwargs.setdefault('linewidth', 0)
7047             kwargs.setdefault('facecolor', _color)
7048         else:
7049             kwargs.setdefault('edgecolor', _color)
7050 
7051         if edges is None:
7052             edges = np.arange(len(values) + 1)
7053 
7054         edges, values, baseline = self._process_unit_info(
7055             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7056 
7057         patch = mpatches.StepPatch(values,
7058                                    edges,
7059                                    baseline=baseline,
7060                                    orientation=orientation,
7061                                    fill=fill,
7062                                    **kwargs)
7063         self.add_patch(patch)
7064         if baseline is None:
7065             baseline = 0
7066         if orientation == 'vertical':
7067             patch.sticky_edges.y.append(np.min(baseline))
7068             self.update_datalim([(edges[0], np.min(baseline))])
7069         else:
7070             patch.sticky_edges.x.append(np.min(baseline))
7071             self.update_datalim([(np.min(baseline), edges[0])])
7072         self._request_autoscale_view()
7073         return patch
7074 
7075     @_preprocess_data(replace_names=["x", "y", "weights"])
7076     @_docstring.dedent_interpd
7077     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7078                cmin=None, cmax=None, **kwargs):
7079         """
7080         Make a 2D histogram plot.
7081 
7082         Parameters
7083         ----------
7084         x, y : array-like, shape (n, )
7085             Input values
7086 
7087         bins : None or int or [int, int] or array-like or [array, array]
7088 
7089             The bin specification:
7090 
7091             - If int, the number of bins for the two dimensions
7092               (nx=ny=bins).
7093             - If ``[int, int]``, the number of bins in each dimension
7094               (nx, ny = bins).
7095             - If array-like, the bin edges for the two dimensions
7096               (x_edges=y_edges=bins).
7097             - If ``[array, array]``, the bin edges in each dimension
7098               (x_edges, y_edges = bins).
7099 
7100             The default value is 10.
7101 
7102         range : array-like shape(2, 2), optional
7103             The leftmost and rightmost edges of the bins along each dimension
7104             (if not specified explicitly in the bins parameters): ``[[xmin,
7105             xmax], [ymin, ymax]]``. All values outside of this range will be
7106             considered outliers and not tallied in the histogram.
7107 
7108         density : bool, default: False
7109             Normalize histogram.  See the documentation for the *density*
7110             parameter of `~.Axes.hist` for more details.
7111 
7112         weights : array-like, shape (n, ), optional
7113             An array of values w_i weighing each sample (x_i, y_i).
7114 
7115         cmin, cmax : float, default: None
7116             All bins that has count less than *cmin* or more than *cmax* will
7117             not be displayed (set to NaN before passing to imshow) and these
7118             count values in the return value count histogram will also be set
7119             to nan upon return.
7120 
7121         Returns
7122         -------
7123         h : 2D array
7124             The bi-dimensional histogram of samples x and y. Values in x are
7125             histogrammed along the first dimension and values in y are
7126             histogrammed along the second dimension.
7127         xedges : 1D array
7128             The bin edges along the x-axis.
7129         yedges : 1D array
7130             The bin edges along the y-axis.
7131         image : `~.matplotlib.collections.QuadMesh`
7132 
7133         Other Parameters
7134         ----------------
7135         %(cmap_doc)s
7136 
7137         %(norm_doc)s
7138 
7139         %(vmin_vmax_doc)s
7140 
7141         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7142             The alpha blending value.
7143 
7144         data : indexable object, optional
7145             DATA_PARAMETER_PLACEHOLDER
7146 
7147         **kwargs
7148             Additional parameters are passed along to the
7149             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7150             constructor.
7151 
7152         See Also
7153         --------
7154         hist : 1D histogram plotting
7155         hexbin : 2D histogram with hexagonal bins
7156 
7157         Notes
7158         -----
7159         - Currently ``hist2d`` calculates its own axis limits, and any limits
7160           previously set are ignored.
7161         - Rendering the histogram with a logarithmic color scale is
7162           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7163           keyword argument. Likewise, power-law normalization (similar
7164           in effect to gamma correction) can be accomplished with
7165           `.colors.PowerNorm`.
7166         """
7167 
7168         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7169                                            density=density, weights=weights)
7170 
7171         if cmin is not None:
7172             h[h < cmin] = None
7173         if cmax is not None:
7174             h[h > cmax] = None
7175 
7176         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7177         self.set_xlim(xedges[0], xedges[-1])
7178         self.set_ylim(yedges[0], yedges[-1])
7179 
7180         return h, xedges, yedges, pc
7181 
7182     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7183     @_docstring.dedent_interpd
7184     def ecdf(self, x, weights=None, *, complementary=False,
7185              orientation="vertical", compress=False, **kwargs):
7186         """
7187         Compute and plot the empirical cumulative distribution function of *x*.
7188 
7189         .. versionadded:: 3.8
7190 
7191         Parameters
7192         ----------
7193         x : 1d array-like
7194             The input data.  Infinite entries are kept (and move the relevant
7195             end of the ecdf from 0/1), but NaNs and masked values are errors.
7196 
7197         weights : 1d array-like or None, default: None
7198             The weights of the entries; must have the same shape as *x*.
7199             Weights corresponding to NaN data points are dropped, and then the
7200             remaining weights are normalized to sum to 1.  If unset, all
7201             entries have the same weight.
7202 
7203         complementary : bool, default: False
7204             Whether to plot a cumulative distribution function, which increases
7205             from 0 to 1 (the default), or a complementary cumulative
7206             distribution function, which decreases from 1 to 0.
7207 
7208         orientation : {"vertical", "horizontal"}, default: "vertical"
7209             Whether the entries are plotted along the x-axis ("vertical", the
7210             default) or the y-axis ("horizontal").  This parameter takes the
7211             same values as in `~.Axes.hist`.
7212 
7213         compress : bool, default: False
7214             Whether multiple entries with the same values are grouped together
7215             (with a summed weight) before plotting.  This is mainly useful if
7216             *x* contains many identical data points, to decrease the rendering
7217             complexity of the plot. If *x* contains no duplicate points, this
7218             has no effect and just uses some time and memory.
7219 
7220         Other Parameters
7221         ----------------
7222         data : indexable object, optional
7223             DATA_PARAMETER_PLACEHOLDER
7224 
7225         **kwargs
7226             Keyword arguments control the `.Line2D` properties:
7227 
7228             %(Line2D:kwdoc)s
7229 
7230         Returns
7231         -------
7232         `.Line2D`
7233 
7234         Notes
7235         -----
7236         The ecdf plot can be thought of as a cumulative histogram with one bin
7237         per data entry; i.e. it reports on the entire dataset without any
7238         arbitrary binning.
7239 
7240         If *x* contains NaNs or masked entries, either remove them first from
7241         the array (if they should not taken into account), or replace them by
7242         -inf or +inf (if they should be sorted at the beginning or the end of
7243         the array).
7244         """
7245         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7246         if "drawstyle" in kwargs or "ds" in kwargs:
7247             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7248         if np.ma.getmask(x).any():
7249             raise ValueError("ecdf() does not support masked entries")
7250         x = np.asarray(x)
7251         if np.isnan(x).any():
7252             raise ValueError("ecdf() does not support NaNs")
7253         argsort = np.argsort(x)
7254         x = x[argsort]
7255         if weights is None:
7256             # Ensure that we end at exactly 1, avoiding floating point errors.
7257             cum_weights = (1 + np.arange(len(x))) / len(x)
7258         else:
7259             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7260             cum_weights = np.cumsum(weights / np.sum(weights))
7261         if compress:
7262             # Get indices of unique x values.
7263             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7264             x = x[compress_idxs]
7265             cum_weights = cum_weights[compress_idxs]
7266         if orientation == "vertical":
7267             if not complementary:
7268                 line, = self.plot([x[0], *x], [0, *cum_weights],
7269                                   drawstyle="steps-post", **kwargs)
7270             else:
7271                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7272                                   drawstyle="steps-pre", **kwargs)
7273             line.sticky_edges.y[:] = [0, 1]
7274         else:  # orientation == "horizontal":
7275             if not complementary:
7276                 line, = self.plot([0, *cum_weights], [x[0], *x],
7277                                   drawstyle="steps-pre", **kwargs)
7278             else:
7279                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7280                                   drawstyle="steps-post", **kwargs)
7281             line.sticky_edges.x[:] = [0, 1]
7282         return line
7283 
7284     @_preprocess_data(replace_names=["x"])
7285     @_docstring.dedent_interpd
7286     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7287             window=None, noverlap=None, pad_to=None,
7288             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7289         r"""
7290         Plot the power spectral density.
7291 
7292         The power spectral density :math:`P_{xx}` by Welch's average
7293         periodogram method.  The vector *x* is divided into *NFFT* length
7294         segments.  Each segment is detrended by function *detrend* and
7295         windowed by function *window*.  *noverlap* gives the length of
7296         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7297         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7298         with a scaling to correct for power loss due to windowing.
7299 
7300         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7301 
7302         Parameters
7303         ----------
7304         x : 1-D array or sequence
7305             Array or sequence containing the data
7306 
7307         %(Spectral)s
7308 
7309         %(PSD)s
7310 
7311         noverlap : int, default: 0 (no overlap)
7312             The number of points of overlap between segments.
7313 
7314         Fc : int, default: 0
7315             The center frequency of *x*, which offsets the x extents of the
7316             plot to reflect the frequency range used when a signal is acquired
7317             and then filtered and downsampled to baseband.
7318 
7319         return_line : bool, default: False
7320             Whether to include the line object plotted in the returned values.
7321 
7322         Returns
7323         -------
7324         Pxx : 1-D array
7325             The values for the power spectrum :math:`P_{xx}` before scaling
7326             (real valued).
7327 
7328         freqs : 1-D array
7329             The frequencies corresponding to the elements in *Pxx*.
7330 
7331         line : `~matplotlib.lines.Line2D`
7332             The line created by this function.
7333             Only returned if *return_line* is True.
7334 
7335         Other Parameters
7336         ----------------
7337         data : indexable object, optional
7338             DATA_PARAMETER_PLACEHOLDER
7339 
7340         **kwargs
7341             Keyword arguments control the `.Line2D` properties:
7342 
7343             %(Line2D:kwdoc)s
7344 
7345         See Also
7346         --------
7347         specgram
7348             Differs in the default overlap; in not returning the mean of the
7349             segment periodograms; in returning the times of the segments; and
7350             in plotting a colormap instead of a line.
7351         magnitude_spectrum
7352             Plots the magnitude spectrum.
7353         csd
7354             Plots the spectral density between two signals.
7355 
7356         Notes
7357         -----
7358         For plotting, the power is plotted as
7359         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7360         is returned.
7361 
7362         References
7363         ----------
7364         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7365         John Wiley & Sons (1986)
7366         """
7367         if Fc is None:
7368             Fc = 0
7369 
7370         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7371                               window=window, noverlap=noverlap, pad_to=pad_to,
7372                               sides=sides, scale_by_freq=scale_by_freq)
7373         freqs += Fc
7374 
7375         if scale_by_freq in (None, True):
7376             psd_units = 'dB/Hz'
7377         else:
7378             psd_units = 'dB'
7379 
7380         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7381         self.set_xlabel('Frequency')
7382         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7383         self.grid(True)
7384 
7385         vmin, vmax = self.get_ybound()
7386         step = max(10 * int(np.log10(vmax - vmin)), 1)
7387         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7388         self.set_yticks(ticks)
7389 
7390         if return_line is None or not return_line:
7391             return pxx, freqs
7392         else:
7393             return pxx, freqs, line
7394 
7395     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7396     @_docstring.dedent_interpd
7397     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7398             window=None, noverlap=None, pad_to=None,
7399             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7400         r"""
7401         Plot the cross-spectral density.
7402 
7403         The cross spectral density :math:`P_{xy}` by Welch's average
7404         periodogram method.  The vectors *x* and *y* are divided into
7405         *NFFT* length segments.  Each segment is detrended by function
7406         *detrend* and windowed by function *window*.  *noverlap* gives
7407         the length of the overlap between segments.  The product of
7408         the direct FFTs of *x* and *y* are averaged over each segment
7409         to compute :math:`P_{xy}`, with a scaling to correct for power
7410         loss due to windowing.
7411 
7412         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7413         padded to *NFFT*.
7414 
7415         Parameters
7416         ----------
7417         x, y : 1-D arrays or sequences
7418             Arrays or sequences containing the data.
7419 
7420         %(Spectral)s
7421 
7422         %(PSD)s
7423 
7424         noverlap : int, default: 0 (no overlap)
7425             The number of points of overlap between segments.
7426 
7427         Fc : int, default: 0
7428             The center frequency of *x*, which offsets the x extents of the
7429             plot to reflect the frequency range used when a signal is acquired
7430             and then filtered and downsampled to baseband.
7431 
7432         return_line : bool, default: False
7433             Whether to include the line object plotted in the returned values.
7434 
7435         Returns
7436         -------
7437         Pxy : 1-D array
7438             The values for the cross spectrum :math:`P_{xy}` before scaling
7439             (complex valued).
7440 
7441         freqs : 1-D array
7442             The frequencies corresponding to the elements in *Pxy*.
7443 
7444         line : `~matplotlib.lines.Line2D`
7445             The line created by this function.
7446             Only returned if *return_line* is True.
7447 
7448         Other Parameters
7449         ----------------
7450         data : indexable object, optional
7451             DATA_PARAMETER_PLACEHOLDER
7452 
7453         **kwargs
7454             Keyword arguments control the `.Line2D` properties:
7455 
7456             %(Line2D:kwdoc)s
7457 
7458         See Also
7459         --------
7460         psd : is equivalent to setting ``y = x``.
7461 
7462         Notes
7463         -----
7464         For plotting, the power is plotted as
7465         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7466         is returned.
7467 
7468         References
7469         ----------
7470         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7471         John Wiley & Sons (1986)
7472         """
7473         if Fc is None:
7474             Fc = 0
7475 
7476         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7477                               window=window, noverlap=noverlap, pad_to=pad_to,
7478                               sides=sides, scale_by_freq=scale_by_freq)
7479         # pxy is complex
7480         freqs += Fc
7481 
7482         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7483         self.set_xlabel('Frequency')
7484         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7485         self.grid(True)
7486 
7487         vmin, vmax = self.get_ybound()
7488         step = max(10 * int(np.log10(vmax - vmin)), 1)
7489         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7490         self.set_yticks(ticks)
7491 
7492         if return_line is None or not return_line:
7493             return pxy, freqs
7494         else:
7495             return pxy, freqs, line
7496 
7497     @_preprocess_data(replace_names=["x"])
7498     @_docstring.dedent_interpd
7499     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7500                            pad_to=None, sides=None, scale=None,
7501                            **kwargs):
7502         """
7503         Plot the magnitude spectrum.
7504 
7505         Compute the magnitude spectrum of *x*.  Data is padded to a
7506         length of *pad_to* and the windowing function *window* is applied to
7507         the signal.
7508 
7509         Parameters
7510         ----------
7511         x : 1-D array or sequence
7512             Array or sequence containing the data.
7513 
7514         %(Spectral)s
7515 
7516         %(Single_Spectrum)s
7517 
7518         scale : {'default', 'linear', 'dB'}
7519             The scaling of the values in the *spec*.  'linear' is no scaling.
7520             'dB' returns the values in dB scale, i.e., the dB amplitude
7521             (20 * log10). 'default' is 'linear'.
7522 
7523         Fc : int, default: 0
7524             The center frequency of *x*, which offsets the x extents of the
7525             plot to reflect the frequency range used when a signal is acquired
7526             and then filtered and downsampled to baseband.
7527 
7528         Returns
7529         -------
7530         spectrum : 1-D array
7531             The values for the magnitude spectrum before scaling (real valued).
7532 
7533         freqs : 1-D array
7534             The frequencies corresponding to the elements in *spectrum*.
7535 
7536         line : `~matplotlib.lines.Line2D`
7537             The line created by this function.
7538 
7539         Other Parameters
7540         ----------------
7541         data : indexable object, optional
7542             DATA_PARAMETER_PLACEHOLDER
7543 
7544         **kwargs
7545             Keyword arguments control the `.Line2D` properties:
7546 
7547             %(Line2D:kwdoc)s
7548 
7549         See Also
7550         --------
7551         psd
7552             Plots the power spectral density.
7553         angle_spectrum
7554             Plots the angles of the corresponding frequencies.
7555         phase_spectrum
7556             Plots the phase (unwrapped angle) of the corresponding frequencies.
7557         specgram
7558             Can plot the magnitude spectrum of segments within the signal in a
7559             colormap.
7560         """
7561         if Fc is None:
7562             Fc = 0
7563 
7564         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7565                                               pad_to=pad_to, sides=sides)
7566         freqs += Fc
7567 
7568         yunits = _api.check_getitem(
7569             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7570              'dB': 'dB'},
7571             scale=scale)
7572         if yunits == 'energy':
7573             Z = spec
7574         else:  # yunits == 'dB'
7575             Z = 20. * np.log10(spec)
7576 
7577         line, = self.plot(freqs, Z, **kwargs)
7578         self.set_xlabel('Frequency')
7579         self.set_ylabel('Magnitude (%s)' % yunits)
7580 
7581         return spec, freqs, line
7582 
7583     @_preprocess_data(replace_names=["x"])
7584     @_docstring.dedent_interpd
7585     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7586                        pad_to=None, sides=None, **kwargs):
7587         """
7588         Plot the angle spectrum.
7589 
7590         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7591         Data is padded to a length of *pad_to* and the windowing function
7592         *window* is applied to the signal.
7593 
7594         Parameters
7595         ----------
7596         x : 1-D array or sequence
7597             Array or sequence containing the data.
7598 
7599         %(Spectral)s
7600 
7601         %(Single_Spectrum)s
7602 
7603         Fc : int, default: 0
7604             The center frequency of *x*, which offsets the x extents of the
7605             plot to reflect the frequency range used when a signal is acquired
7606             and then filtered and downsampled to baseband.
7607 
7608         Returns
7609         -------
7610         spectrum : 1-D array
7611             The values for the angle spectrum in radians (real valued).
7612 
7613         freqs : 1-D array
7614             The frequencies corresponding to the elements in *spectrum*.
7615 
7616         line : `~matplotlib.lines.Line2D`
7617             The line created by this function.
7618 
7619         Other Parameters
7620         ----------------
7621         data : indexable object, optional
7622             DATA_PARAMETER_PLACEHOLDER
7623 
7624         **kwargs
7625             Keyword arguments control the `.Line2D` properties:
7626 
7627             %(Line2D:kwdoc)s
7628 
7629         See Also
7630         --------
7631         magnitude_spectrum
7632             Plots the magnitudes of the corresponding frequencies.
7633         phase_spectrum
7634             Plots the unwrapped version of this function.
7635         specgram
7636             Can plot the angle spectrum of segments within the signal in a
7637             colormap.
7638         """
7639         if Fc is None:
7640             Fc = 0
7641 
7642         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7643                                           pad_to=pad_to, sides=sides)
7644         freqs += Fc
7645 
7646         lines = self.plot(freqs, spec, **kwargs)
7647         self.set_xlabel('Frequency')
7648         self.set_ylabel('Angle (radians)')
7649 
7650         return spec, freqs, lines[0]
7651 
7652     @_preprocess_data(replace_names=["x"])
7653     @_docstring.dedent_interpd
7654     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7655                        pad_to=None, sides=None, **kwargs):
7656         """
7657         Plot the phase spectrum.
7658 
7659         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7660         Data is padded to a length of *pad_to* and the windowing function
7661         *window* is applied to the signal.
7662 
7663         Parameters
7664         ----------
7665         x : 1-D array or sequence
7666             Array or sequence containing the data
7667 
7668         %(Spectral)s
7669 
7670         %(Single_Spectrum)s
7671 
7672         Fc : int, default: 0
7673             The center frequency of *x*, which offsets the x extents of the
7674             plot to reflect the frequency range used when a signal is acquired
7675             and then filtered and downsampled to baseband.
7676 
7677         Returns
7678         -------
7679         spectrum : 1-D array
7680             The values for the phase spectrum in radians (real valued).
7681 
7682         freqs : 1-D array
7683             The frequencies corresponding to the elements in *spectrum*.
7684 
7685         line : `~matplotlib.lines.Line2D`
7686             The line created by this function.
7687 
7688         Other Parameters
7689         ----------------
7690         data : indexable object, optional
7691             DATA_PARAMETER_PLACEHOLDER
7692 
7693         **kwargs
7694             Keyword arguments control the `.Line2D` properties:
7695 
7696             %(Line2D:kwdoc)s
7697 
7698         See Also
7699         --------
7700         magnitude_spectrum
7701             Plots the magnitudes of the corresponding frequencies.
7702         angle_spectrum
7703             Plots the wrapped version of this function.
7704         specgram
7705             Can plot the phase spectrum of segments within the signal in a
7706             colormap.
7707         """
7708         if Fc is None:
7709             Fc = 0
7710 
7711         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7712                                           pad_to=pad_to, sides=sides)
7713         freqs += Fc
7714 
7715         lines = self.plot(freqs, spec, **kwargs)
7716         self.set_xlabel('Frequency')
7717         self.set_ylabel('Phase (radians)')
7718 
7719         return spec, freqs, lines[0]
7720 
7721     @_preprocess_data(replace_names=["x", "y"])
7722     @_docstring.dedent_interpd
7723     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7724                window=mlab.window_hanning, noverlap=0, pad_to=None,
7725                sides='default', scale_by_freq=None, **kwargs):
7726         r"""
7727         Plot the coherence between *x* and *y*.
7728 
7729         Coherence is the normalized cross spectral density:
7730 
7731         .. math::
7732 
7733           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7734 
7735         Parameters
7736         ----------
7737         %(Spectral)s
7738 
7739         %(PSD)s
7740 
7741         noverlap : int, default: 0 (no overlap)
7742             The number of points of overlap between blocks.
7743 
7744         Fc : int, default: 0
7745             The center frequency of *x*, which offsets the x extents of the
7746             plot to reflect the frequency range used when a signal is acquired
7747             and then filtered and downsampled to baseband.
7748 
7749         Returns
7750         -------
7751         Cxy : 1-D array
7752             The coherence vector.
7753 
7754         freqs : 1-D array
7755             The frequencies for the elements in *Cxy*.
7756 
7757         Other Parameters
7758         ----------------
7759         data : indexable object, optional
7760             DATA_PARAMETER_PLACEHOLDER
7761 
7762         **kwargs
7763             Keyword arguments control the `.Line2D` properties:
7764 
7765             %(Line2D:kwdoc)s
7766 
7767         References
7768         ----------
7769         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7770         John Wiley & Sons (1986)
7771         """
7772         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7773                                  window=window, noverlap=noverlap,
7774                                  scale_by_freq=scale_by_freq, sides=sides,
7775                                  pad_to=pad_to)
7776         freqs += Fc
7777 
7778         self.plot(freqs, cxy, **kwargs)
7779         self.set_xlabel('Frequency')
7780         self.set_ylabel('Coherence')
7781         self.grid(True)
7782 
7783         return cxy, freqs
7784 
7785     @_preprocess_data(replace_names=["x"])
7786     @_docstring.dedent_interpd
7787     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7788                  window=None, noverlap=None,
7789                  cmap=None, xextent=None, pad_to=None, sides=None,
7790                  scale_by_freq=None, mode=None, scale=None,
7791                  vmin=None, vmax=None, **kwargs):
7792         """
7793         Plot a spectrogram.
7794 
7795         Compute and plot a spectrogram of data in *x*.  Data are split into
7796         *NFFT* length segments and the spectrum of each section is
7797         computed.  The windowing function *window* is applied to each
7798         segment, and the amount of overlap of each segment is
7799         specified with *noverlap*. The spectrogram is plotted as a colormap
7800         (using imshow).
7801 
7802         Parameters
7803         ----------
7804         x : 1-D array or sequence
7805             Array or sequence containing the data.
7806 
7807         %(Spectral)s
7808 
7809         %(PSD)s
7810 
7811         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7812             What sort of spectrum to use.  Default is 'psd', which takes the
7813             power spectral density.  'magnitude' returns the magnitude
7814             spectrum.  'angle' returns the phase spectrum without unwrapping.
7815             'phase' returns the phase spectrum with unwrapping.
7816 
7817         noverlap : int, default: 128
7818             The number of points of overlap between blocks.
7819 
7820         scale : {'default', 'linear', 'dB'}
7821             The scaling of the values in the *spec*.  'linear' is no scaling.
7822             'dB' returns the values in dB scale.  When *mode* is 'psd',
7823             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7824             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7825             'magnitude' and 'linear' otherwise.  This must be 'linear'
7826             if *mode* is 'angle' or 'phase'.
7827 
7828         Fc : int, default: 0
7829             The center frequency of *x*, which offsets the x extents of the
7830             plot to reflect the frequency range used when a signal is acquired
7831             and then filtered and downsampled to baseband.
7832 
7833         cmap : `.Colormap`, default: :rc:`image.cmap`
7834 
7835         xextent : *None* or (xmin, xmax)
7836             The image extent along the x-axis. The default sets *xmin* to the
7837             left border of the first bin (*spectrum* column) and *xmax* to the
7838             right border of the last bin. Note that for *noverlap>0* the width
7839             of the bins is smaller than those of the segments.
7840 
7841         data : indexable object, optional
7842             DATA_PARAMETER_PLACEHOLDER
7843 
7844         **kwargs
7845             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7846             which makes the specgram image. The origin keyword argument
7847             is not supported.
7848 
7849         Returns
7850         -------
7851         spectrum : 2D array
7852             Columns are the periodograms of successive segments.
7853 
7854         freqs : 1-D array
7855             The frequencies corresponding to the rows in *spectrum*.
7856 
7857         t : 1-D array
7858             The times corresponding to midpoints of segments (i.e., the columns
7859             in *spectrum*).
7860 
7861         im : `.AxesImage`
7862             The image created by imshow containing the spectrogram.
7863 
7864         See Also
7865         --------
7866         psd
7867             Differs in the default overlap; in returning the mean of the
7868             segment periodograms; in not returning times; and in generating a
7869             line plot instead of colormap.
7870         magnitude_spectrum
7871             A single spectrum, similar to having a single segment when *mode*
7872             is 'magnitude'. Plots a line instead of a colormap.
7873         angle_spectrum
7874             A single spectrum, similar to having a single segment when *mode*
7875             is 'angle'. Plots a line instead of a colormap.
7876         phase_spectrum
7877             A single spectrum, similar to having a single segment when *mode*
7878             is 'phase'. Plots a line instead of a colormap.
7879 
7880         Notes
7881         -----
7882         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7883         is set to 'psd'.
7884         """
7885         if NFFT is None:
7886             NFFT = 256  # same default as in mlab.specgram()
7887         if Fc is None:
7888             Fc = 0  # same default as in mlab._spectral_helper()
7889         if noverlap is None:
7890             noverlap = 128  # same default as in mlab.specgram()
7891         if Fs is None:
7892             Fs = 2  # same default as in mlab._spectral_helper()
7893 
7894         if mode == 'complex':
7895             raise ValueError('Cannot plot a complex specgram')
7896 
7897         if scale is None or scale == 'default':
7898             if mode in ['angle', 'phase']:
7899                 scale = 'linear'
7900             else:
7901                 scale = 'dB'
7902         elif mode in ['angle', 'phase'] and scale == 'dB':
7903             raise ValueError('Cannot use dB scale with angle or phase mode')
7904 
7905         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7906                                        detrend=detrend, window=window,
7907                                        noverlap=noverlap, pad_to=pad_to,
7908                                        sides=sides,
7909                                        scale_by_freq=scale_by_freq,
7910                                        mode=mode)
7911 
7912         if scale == 'linear':
7913             Z = spec
7914         elif scale == 'dB':
7915             if mode is None or mode == 'default' or mode == 'psd':
7916                 Z = 10. * np.log10(spec)
7917             else:
7918                 Z = 20. * np.log10(spec)
7919         else:
7920             raise ValueError(f'Unknown scale {scale!r}')
7921 
7922         Z = np.flipud(Z)
7923 
7924         if xextent is None:
7925             # padding is needed for first and last segment:
7926             pad_xextent = (NFFT-noverlap) / Fs / 2
7927             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7928         xmin, xmax = xextent
7929         freqs += Fc
7930         extent = xmin, xmax, freqs[0], freqs[-1]
7931 
7932         if 'origin' in kwargs:
7933             raise _api.kwarg_error("specgram", "origin")
7934 
7935         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7936                          origin='upper', **kwargs)
7937         self.axis('auto')
7938 
7939         return spec, freqs, t, im
7940 
7941     @_docstring.dedent_interpd
7942     def spy(self, Z, precision=0, marker=None, markersize=None,
7943             aspect='equal', origin="upper", **kwargs):
7944         """
7945         Plot the sparsity pattern of a 2D array.
7946 
7947         This visualizes the non-zero values of the array.
7948 
7949         Two plotting styles are available: image and marker. Both
7950         are available for full arrays, but only the marker style
7951         works for `scipy.sparse.spmatrix` instances.
7952 
7953         **Image style**
7954 
7955         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7956         extra remaining keyword arguments are passed to this method.
7957 
7958         **Marker style**
7959 
7960         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7961         *None*, a `.Line2D` object will be returned with the value of marker
7962         determining the marker type, and any remaining keyword arguments
7963         passed to `~.Axes.plot`.
7964 
7965         Parameters
7966         ----------
7967         Z : (M, N) array-like
7968             The array to be plotted.
7969 
7970         precision : float or 'present', default: 0
7971             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7972             values of :math:`|Z| > precision` will be plotted.
7973 
7974             For `scipy.sparse.spmatrix` instances, you can also
7975             pass 'present'. In this case any value present in the array
7976             will be plotted, even if it is identically zero.
7977 
7978         aspect : {'equal', 'auto', None} or float, default: 'equal'
7979             The aspect ratio of the Axes.  This parameter is particularly
7980             relevant for images since it determines whether data pixels are
7981             square.
7982 
7983             This parameter is a shortcut for explicitly calling
7984             `.Axes.set_aspect`. See there for further details.
7985 
7986             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7987             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7988               that the data fit in the Axes. In general, this will result in
7989               non-square pixels.
7990             - *None*: Use :rc:`image.aspect`.
7991 
7992         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7993             Place the [0, 0] index of the array in the upper left or lower left
7994             corner of the Axes. The convention 'upper' is typically used for
7995             matrices and images.
7996 
7997         Returns
7998         -------
7999         `~matplotlib.image.AxesImage` or `.Line2D`
8000             The return type depends on the plotting style (see above).
8001 
8002         Other Parameters
8003         ----------------
8004         **kwargs
8005             The supported additional parameters depend on the plotting style.
8006 
8007             For the image style, you can pass the following additional
8008             parameters of `~.Axes.imshow`:
8009 
8010             - *cmap*
8011             - *alpha*
8012             - *url*
8013             - any `.Artist` properties (passed on to the `.AxesImage`)
8014 
8015             For the marker style, you can pass any `.Line2D` property except
8016             for *linestyle*:
8017 
8018             %(Line2D:kwdoc)s
8019         """
8020         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8021             marker = 's'
8022         _api.check_in_list(["upper", "lower"], origin=origin)
8023         if marker is None and markersize is None:
8024             Z = np.asarray(Z)
8025             mask = np.abs(Z) > precision
8026 
8027             if 'cmap' not in kwargs:
8028                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8029                                                         name='binary')
8030             if 'interpolation' in kwargs:
8031                 raise _api.kwarg_error("spy", "interpolation")
8032             if 'norm' not in kwargs:
8033                 kwargs['norm'] = mcolors.NoNorm()
8034             ret = self.imshow(mask, interpolation='nearest',
8035                               aspect=aspect, origin=origin,
8036                               **kwargs)
8037         else:
8038             if hasattr(Z, 'tocoo'):
8039                 c = Z.tocoo()
8040                 if precision == 'present':
8041                     y = c.row
8042                     x = c.col
8043                 else:
8044                     nonzero = np.abs(c.data) > precision
8045                     y = c.row[nonzero]
8046                     x = c.col[nonzero]
8047             else:
8048                 Z = np.asarray(Z)
8049                 nonzero = np.abs(Z) > precision
8050                 y, x = np.nonzero(nonzero)
8051             if marker is None:
8052                 marker = 's'
8053             if markersize is None:
8054                 markersize = 10
8055             if 'linestyle' in kwargs:
8056                 raise _api.kwarg_error("spy", "linestyle")
8057             ret = mlines.Line2D(
8058                 x, y, linestyle='None', marker=marker, markersize=markersize,
8059                 **kwargs)
8060             self.add_line(ret)
8061             nr, nc = Z.shape
8062             self.set_xlim(-0.5, nc - 0.5)
8063             if origin == "upper":
8064                 self.set_ylim(nr - 0.5, -0.5)
8065             else:
8066                 self.set_ylim(-0.5, nr - 0.5)
8067             self.set_aspect(aspect)
8068         self.title.set_y(1.05)
8069         if origin == "upper":
8070             self.xaxis.tick_top()
8071         else:  # lower
8072             self.xaxis.tick_bottom()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return ret
8079 
8080     def matshow(self, Z, **kwargs):
8081         """
8082         Plot the values of a 2D matrix or array as color-coded image.
8083 
8084         The matrix will be shown the way it would be printed, with the first
8085         row at the top.  Row and column numbering is zero-based.
8086 
8087         Parameters
8088         ----------
8089         Z : (M, N) array-like
8090             The matrix to be displayed.
8091 
8092         Returns
8093         -------
8094         `~matplotlib.image.AxesImage`
8095 
8096         Other Parameters
8097         ----------------
8098         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8099 
8100         See Also
8101         --------
8102         imshow : More general function to plot data on a 2D regular raster.
8103 
8104         Notes
8105         -----
8106         This is just a convenience function wrapping `.imshow` to set useful
8107         defaults for displaying a matrix. In particular:
8108 
8109         - Set ``origin='upper'``.
8110         - Set ``interpolation='nearest'``.
8111         - Set ``aspect='equal'``.
8112         - Ticks are placed to the left and above.
8113         - Ticks are formatted to show integer indices.
8114 
8115         """
8116         Z = np.asanyarray(Z)
8117         kw = {'origin': 'upper',
8118               'interpolation': 'nearest',
8119               'aspect': 'equal',          # (already the imshow default)
8120               **kwargs}
8121         im = self.imshow(Z, **kw)
8122         self.title.set_y(1.05)
8123         self.xaxis.tick_top()
8124         self.xaxis.set_ticks_position('both')
8125         self.xaxis.set_major_locator(
8126             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8127         self.yaxis.set_major_locator(
8128             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8129         return im
8130 
8131     @_preprocess_data(replace_names=["dataset"])
8132     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8133                    showmeans=False, showextrema=True, showmedians=False,
8134                    quantiles=None, points=100, bw_method=None):
8135         """
8136         Make a violin plot.
8137 
8138         Make a violin plot for each column of *dataset* or each vector in
8139         sequence *dataset*.  Each filled area extends to represent the
8140         entire data range, with optional lines at the mean, the median,
8141         the minimum, the maximum, and user-specified quantiles.
8142 
8143         Parameters
8144         ----------
8145         dataset : Array or a sequence of vectors.
8146           The input data.
8147 
8148         positions : array-like, default: [1, 2, ..., n]
8149           The positions of the violins. The ticks and limits are
8150           automatically set to match the positions.
8151 
8152         vert : bool, default: True.
8153           If true, creates a vertical violin plot.
8154           Otherwise, creates a horizontal violin plot.
8155 
8156         widths : array-like, default: 0.5
8157           Either a scalar or a vector that sets the maximal width of
8158           each violin. The default is 0.5, which uses about half of the
8159           available horizontal space.
8160 
8161         showmeans : bool, default: False
8162           If `True`, will toggle rendering of the means.
8163 
8164         showextrema : bool, default: True
8165           If `True`, will toggle rendering of the extrema.
8166 
8167         showmedians : bool, default: False
8168           If `True`, will toggle rendering of the medians.
8169 
8170         quantiles : array-like, default: None
8171           If not None, set a list of floats in interval [0, 1] for each violin,
8172           which stands for the quantiles that will be rendered for that
8173           violin.
8174 
8175         points : int, default: 100
8176           Defines the number of points to evaluate each of the
8177           gaussian kernel density estimations at.
8178 
8179         bw_method : str, scalar or callable, optional
8180           The method used to calculate the estimator bandwidth.  This can be
8181           'scott', 'silverman', a scalar constant or a callable.  If a
8182           scalar, this will be used directly as `kde.factor`.  If a
8183           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8184           its only parameter and return a scalar. If None (default), 'scott'
8185           is used.
8186 
8187         data : indexable object, optional
8188             DATA_PARAMETER_PLACEHOLDER
8189 
8190         Returns
8191         -------
8192         dict
8193           A dictionary mapping each component of the violinplot to a
8194           list of the corresponding collection instances created. The
8195           dictionary has the following keys:
8196 
8197           - ``bodies``: A list of the `~.collections.PolyCollection`
8198             instances containing the filled area of each violin.
8199 
8200           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8201             the mean values of each of the violin's distribution.
8202 
8203           - ``cmins``: A `~.collections.LineCollection` instance that marks
8204             the bottom of each violin's distribution.
8205 
8206           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8207             the top of each violin's distribution.
8208 
8209           - ``cbars``: A `~.collections.LineCollection` instance that marks
8210             the centers of each violin's distribution.
8211 
8212           - ``cmedians``: A `~.collections.LineCollection` instance that
8213             marks the median values of each of the violin's distribution.
8214 
8215           - ``cquantiles``: A `~.collections.LineCollection` instance created
8216             to identify the quantile values of each of the violin's
8217             distribution.
8218 
8219         """
8220 
8221         def _kde_method(X, coords):
8222             # Unpack in case of e.g. Pandas or xarray object
8223             X = cbook._unpack_to_numpy(X)
8224             # fallback gracefully if the vector contains only one value
8225             if np.all(X[0] == X):
8226                 return (X[0] == coords).astype(float)
8227             kde = mlab.GaussianKDE(X, bw_method)
8228             return kde.evaluate(coords)
8229 
8230         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8231                                      quantiles=quantiles)
8232         return self.violin(vpstats, positions=positions, vert=vert,
8233                            widths=widths, showmeans=showmeans,
8234                            showextrema=showextrema, showmedians=showmedians)
8235 
8236     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8237                showmeans=False, showextrema=True, showmedians=False):
8238         """
8239         Drawing function for violin plots.
8240 
8241         Draw a violin plot for each column of *vpstats*. Each filled area
8242         extends to represent the entire data range, with optional lines at the
8243         mean, the median, the minimum, the maximum, and the quantiles values.
8244 
8245         Parameters
8246         ----------
8247         vpstats : list of dicts
8248           A list of dictionaries containing stats for each violin plot.
8249           Required keys are:
8250 
8251           - ``coords``: A list of scalars containing the coordinates that
8252             the violin's kernel density estimate were evaluated at.
8253 
8254           - ``vals``: A list of scalars containing the values of the
8255             kernel density estimate at each of the coordinates given
8256             in *coords*.
8257 
8258           - ``mean``: The mean value for this violin's dataset.
8259 
8260           - ``median``: The median value for this violin's dataset.
8261 
8262           - ``min``: The minimum value for this violin's dataset.
8263 
8264           - ``max``: The maximum value for this violin's dataset.
8265 
8266           Optional keys are:
8267 
8268           - ``quantiles``: A list of scalars containing the quantile values
8269             for this violin's dataset.
8270 
8271         positions : array-like, default: [1, 2, ..., n]
8272           The positions of the violins. The ticks and limits are
8273           automatically set to match the positions.
8274 
8275         vert : bool, default: True.
8276           If true, plots the violins vertically.
8277           Otherwise, plots the violins horizontally.
8278 
8279         widths : array-like, default: 0.5
8280           Either a scalar or a vector that sets the maximal width of
8281           each violin. The default is 0.5, which uses about half of the
8282           available horizontal space.
8283 
8284         showmeans : bool, default: False
8285           If true, will toggle rendering of the means.
8286 
8287         showextrema : bool, default: True
8288           If true, will toggle rendering of the extrema.
8289 
8290         showmedians : bool, default: False
8291           If true, will toggle rendering of the medians.
8292 
8293         Returns
8294         -------
8295         dict
8296           A dictionary mapping each component of the violinplot to a
8297           list of the corresponding collection instances created. The
8298           dictionary has the following keys:
8299 
8300           - ``bodies``: A list of the `~.collections.PolyCollection`
8301             instances containing the filled area of each violin.
8302 
8303           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8304             the mean values of each of the violin's distribution.
8305 
8306           - ``cmins``: A `~.collections.LineCollection` instance that marks
8307             the bottom of each violin's distribution.
8308 
8309           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8310             the top of each violin's distribution.
8311 
8312           - ``cbars``: A `~.collections.LineCollection` instance that marks
8313             the centers of each violin's distribution.
8314 
8315           - ``cmedians``: A `~.collections.LineCollection` instance that
8316             marks the median values of each of the violin's distribution.
8317 
8318           - ``cquantiles``: A `~.collections.LineCollection` instance created
8319             to identify the quantiles values of each of the violin's
8320             distribution.
8321         """
8322 
8323         # Statistical quantities to be plotted on the violins
8324         means = []
8325         mins = []
8326         maxes = []
8327         medians = []
8328         quantiles = []
8329 
8330         qlens = []  # Number of quantiles in each dataset.
8331 
8332         artists = {}  # Collections to be returned
8333 
8334         N = len(vpstats)
8335         datashape_message = ("List of violinplot statistics and `{0}` "
8336                              "values must have the same length")
8337 
8338         # Validate positions
8339         if positions is None:
8340             positions = range(1, N + 1)
8341         elif len(positions) != N:
8342             raise ValueError(datashape_message.format("positions"))
8343 
8344         # Validate widths
8345         if np.isscalar(widths):
8346             widths = [widths] * N
8347         elif len(widths) != N:
8348             raise ValueError(datashape_message.format("widths"))
8349 
8350         # Calculate ranges for statistics lines (shape (2, N)).
8351         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8352 
8353         # Colors.
8354         if mpl.rcParams['_internal.classic_mode']:
8355             fillcolor = 'y'
8356             linecolor = 'r'
8357         else:
8358             fillcolor = linecolor = self._get_lines.get_next_color()
8359 
8360         # Check whether we are rendering vertically or horizontally
8361         if vert:
8362             fill = self.fill_betweenx
8363             perp_lines = functools.partial(self.hlines, colors=linecolor)
8364             par_lines = functools.partial(self.vlines, colors=linecolor)
8365         else:
8366             fill = self.fill_between
8367             perp_lines = functools.partial(self.vlines, colors=linecolor)
8368             par_lines = functools.partial(self.hlines, colors=linecolor)
8369 
8370         # Render violins
8371         bodies = []
8372         for stats, pos, width in zip(vpstats, positions, widths):
8373             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8374             vals = np.array(stats['vals'])
8375             vals = 0.5 * width * vals / vals.max()
8376             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8377                             facecolor=fillcolor, alpha=0.3)]
8378             means.append(stats['mean'])
8379             mins.append(stats['min'])
8380             maxes.append(stats['max'])
8381             medians.append(stats['median'])
8382             q = stats.get('quantiles')  # a list of floats, or None
8383             if q is None:
8384                 q = []
8385             quantiles.extend(q)
8386             qlens.append(len(q))
8387         artists['bodies'] = bodies
8388 
8389         if showmeans:  # Render means
8390             artists['cmeans'] = perp_lines(means, *line_ends)
8391         if showextrema:  # Render extrema
8392             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8393             artists['cmins'] = perp_lines(mins, *line_ends)
8394             artists['cbars'] = par_lines(positions, mins, maxes)
8395         if showmedians:  # Render medians
8396             artists['cmedians'] = perp_lines(medians, *line_ends)
8397         if quantiles:  # Render quantiles: each width is repeated qlen times.
8398             artists['cquantiles'] = perp_lines(
8399                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8400 
8401         return artists
8402 
8403     # Methods that are entirely implemented in other modules.
8404 
8405     table = mtable.table
8406 
8407     # args can be either Y or y1, y2, ... and all should be replaced
8408     stackplot = _preprocess_data()(mstack.stackplot)
8409 
8410     streamplot = _preprocess_data(
8411         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8412 
8413     tricontour = mtri.tricontour
8414     tricontourf = mtri.tricontourf
8415     tripcolor = mtri.tripcolor
8416     triplot = mtri.triplot
8417 
8418     def _get_aspect_ratio(self):
8419         """
8420         Convenience method to calculate the aspect ratio of the axes in
8421         the display coordinate system.
8422         """
8423         figure_size = self.get_figure().get_size_inches()
8424         ll, ur = self.get_position() * figure_size
8425         width, height = ur - ll
8426         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>set_aspect</method>
<code>
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True

</code><intended_behavior>While the core functionality of `set_aspect` does not inherently contain a bug related to the issue, an enhancement could be considered to support conditional aspect ratio adjustments based on additional context (such as transformation information). This would potentially involve expanding the method signature to accept a new parameter indicating whether the aspect ratio setting should be conditional on the type of transformation applied. However, this approach would require careful consideration to ensure compatibility with the existing codebase and would likely involve adjustments upstream (e.g., in how `imshow` invokes `set_aspect`) to pass down the necessary context. The primary modification remains in how `imshow` interacts with this method rather than changing `set_aspect` itself.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~matplotlib.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self, clear=False)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self, clear=False)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine._clear()  # Use _clear to not clear Axis again
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than ´None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                ┌─────────────────┬─────────────────┬─────────────────┐
1829                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1830                ├─────────────────┼─────────────────┼─────────────────┤
1831                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1832                ├─────────────────┼─────────────────┼─────────────────┤
1833                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1834                └─────────────────┴─────────────────┴─────────────────┘
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance((mcoll.Collection, mimage.AxesImage), im=im)
2175         if im not in self._children:
2176             raise ValueError("Argument must be an image or collection in this Axes")
2177         self._current_image = im
2178 
2179     def _gci(self):
2180         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2181         return self._current_image
2182 
2183     def has_data(self):
2184         """
2185         Return whether any artists have been added to the Axes.
2186 
2187         This should not be used to determine whether the *dataLim*
2188         need to be updated, and may not actually be useful for
2189         anything.
2190         """
2191         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2192                                   mlines.Line2D, mpatches.Patch))
2193                    for a in self._children)
2194 
2195     def add_artist(self, a):
2196         """
2197         Add an `.Artist` to the Axes; return the artist.
2198 
2199         Use `add_artist` only for artists for which there is no dedicated
2200         "add" method; and if necessary, use a method such as `update_datalim`
2201         to manually update the dataLim if the artist is to be included in
2202         autoscaling.
2203 
2204         If no ``transform`` has been specified when creating the artist (e.g.
2205         ``artist.get_transform() == None``) then the transform is set to
2206         ``ax.transData``.
2207         """
2208         a.axes = self
2209         self._children.append(a)
2210         a._remove_method = self._children.remove
2211         self._set_artist_props(a)
2212         if a.get_clip_path() is None:
2213             a.set_clip_path(self.patch)
2214         self.stale = True
2215         return a
2216 
2217     def add_child_axes(self, ax):
2218         """
2219         Add an `.AxesBase` to the Axes' children; return the child Axes.
2220 
2221         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2222         """
2223 
2224         # normally Axes have themselves as the Axes, but these need to have
2225         # their parent...
2226         # Need to bypass the getter...
2227         ax._axes = self
2228         ax.stale_callback = martist._stale_axes_callback
2229 
2230         self.child_axes.append(ax)
2231         ax._remove_method = self.child_axes.remove
2232         self.stale = True
2233         return ax
2234 
2235     def add_collection(self, collection, autolim=True):
2236         """
2237         Add a `.Collection` to the Axes; return the collection.
2238         """
2239         _api.check_isinstance(mcoll.Collection, collection=collection)
2240         label = collection.get_label()
2241         if not label:
2242             collection.set_label(f'_child{len(self._children)}')
2243         self._children.append(collection)
2244         collection._remove_method = self._children.remove
2245         self._set_artist_props(collection)
2246 
2247         if collection.get_clip_path() is None:
2248             collection.set_clip_path(self.patch)
2249 
2250         if autolim:
2251             # Make sure viewLim is not stale (mostly to match
2252             # pre-lazy-autoscale behavior, which is not really better).
2253             self._unstale_viewLim()
2254             datalim = collection.get_datalim(self.transData)
2255             points = datalim.get_points()
2256             if not np.isinf(datalim.minpos).all():
2257                 # By definition, if minpos (minimum positive value) is set
2258                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2259                 # and minpos would be superfluous. However, we add minpos to
2260                 # the call so that self.dataLim will update its own minpos.
2261                 # This ensures that log scales see the correct minimum.
2262                 points = np.concatenate([points, [datalim.minpos]])
2263             self.update_datalim(points)
2264 
2265         self.stale = True
2266         return collection
2267 
2268     def add_image(self, image):
2269         """
2270         Add an `.AxesImage` to the Axes; return the image.
2271         """
2272         _api.check_isinstance(mimage.AxesImage, image=image)
2273         self._set_artist_props(image)
2274         if not image.get_label():
2275             image.set_label(f'_child{len(self._children)}')
2276         self._children.append(image)
2277         image._remove_method = self._children.remove
2278         self.stale = True
2279         return image
2280 
2281     def _update_image_limits(self, image):
2282         xmin, xmax, ymin, ymax = image.get_extent()
2283         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2284 
2285     def add_line(self, line):
2286         """
2287         Add a `.Line2D` to the Axes; return the line.
2288         """
2289         _api.check_isinstance(mlines.Line2D, line=line)
2290         self._set_artist_props(line)
2291         if line.get_clip_path() is None:
2292             line.set_clip_path(self.patch)
2293 
2294         self._update_line_limits(line)
2295         if not line.get_label():
2296             line.set_label(f'_child{len(self._children)}')
2297         self._children.append(line)
2298         line._remove_method = self._children.remove
2299         self.stale = True
2300         return line
2301 
2302     def _add_text(self, txt):
2303         """
2304         Add a `.Text` to the Axes; return the text.
2305         """
2306         _api.check_isinstance(mtext.Text, txt=txt)
2307         self._set_artist_props(txt)
2308         self._children.append(txt)
2309         txt._remove_method = self._children.remove
2310         self.stale = True
2311         return txt
2312 
2313     def _update_line_limits(self, line):
2314         """
2315         Figures out the data limit of the given line, updating self.dataLim.
2316         """
2317         path = line.get_path()
2318         if path.vertices.size == 0:
2319             return
2320 
2321         line_trf = line.get_transform()
2322 
2323         if line_trf == self.transData:
2324             data_path = path
2325         elif any(line_trf.contains_branch_seperately(self.transData)):
2326             # Compute the transform from line coordinates to data coordinates.
2327             trf_to_data = line_trf - self.transData
2328             # If transData is affine we can use the cached non-affine component
2329             # of line's path (since the non-affine part of line_trf is
2330             # entirely encapsulated in trf_to_data).
2331             if self.transData.is_affine:
2332                 line_trans_path = line._get_transformed_path()
2333                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2334                 data_path = trf_to_data.transform_path_affine(na_path)
2335             else:
2336                 data_path = trf_to_data.transform_path(path)
2337         else:
2338             # For backwards compatibility we update the dataLim with the
2339             # coordinate range of the given path, even though the coordinate
2340             # systems are completely different. This may occur in situations
2341             # such as when ax.transAxes is passed through for absolute
2342             # positioning.
2343             data_path = path
2344 
2345         if not data_path.vertices.size:
2346             return
2347 
2348         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2349         if self.name != "rectilinear":
2350             # This block is mostly intended to handle axvline in polar plots,
2351             # for which updatey would otherwise be True.
2352             if updatex and line_trf == self.get_yaxis_transform():
2353                 updatex = False
2354             if updatey and line_trf == self.get_xaxis_transform():
2355                 updatey = False
2356         self.dataLim.update_from_path(data_path,
2357                                       self.ignore_existing_data_limits,
2358                                       updatex=updatex, updatey=updatey)
2359         self.ignore_existing_data_limits = False
2360 
2361     def add_patch(self, p):
2362         """
2363         Add a `.Patch` to the Axes; return the patch.
2364         """
2365         _api.check_isinstance(mpatches.Patch, p=p)
2366         self._set_artist_props(p)
2367         if p.get_clip_path() is None:
2368             p.set_clip_path(self.patch)
2369         self._update_patch_limits(p)
2370         self._children.append(p)
2371         p._remove_method = self._children.remove
2372         return p
2373 
2374     def _update_patch_limits(self, patch):
2375         """Update the data limits for the given patch."""
2376         # hist can add zero height Rectangles, which is useful to keep
2377         # the bins, counts and patches lined up, but it throws off log
2378         # scaling.  We'll ignore rects with zero height or width in
2379         # the auto-scaling
2380 
2381         # cannot check for '==0' since unitized data may not compare to zero
2382         # issue #2150 - we update the limits if patch has non zero width
2383         # or height.
2384         if (isinstance(patch, mpatches.Rectangle) and
2385                 ((not patch.get_width()) and (not patch.get_height()))):
2386             return
2387         p = patch.get_path()
2388         # Get all vertices on the path
2389         # Loop through each segment to get extrema for Bezier curve sections
2390         vertices = []
2391         for curve, code in p.iter_bezier(simplify=False):
2392             # Get distance along the curve of any extrema
2393             _, dzeros = curve.axis_aligned_extrema()
2394             # Calculate vertices of start, end and any extrema in between
2395             vertices.append(curve([0, *dzeros, 1]))
2396 
2397         if len(vertices):
2398             vertices = np.row_stack(vertices)
2399 
2400         patch_trf = patch.get_transform()
2401         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2402         if not (updatex or updatey):
2403             return
2404         if self.name != "rectilinear":
2405             # As in _update_line_limits, but for axvspan.
2406             if updatex and patch_trf == self.get_yaxis_transform():
2407                 updatex = False
2408             if updatey and patch_trf == self.get_xaxis_transform():
2409                 updatey = False
2410         trf_to_data = patch_trf - self.transData
2411         xys = trf_to_data.transform(vertices)
2412         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2413 
2414     def add_table(self, tab):
2415         """
2416         Add a `.Table` to the Axes; return the table.
2417         """
2418         _api.check_isinstance(mtable.Table, tab=tab)
2419         self._set_artist_props(tab)
2420         self._children.append(tab)
2421         if tab.get_clip_path() is None:
2422             tab.set_clip_path(self.patch)
2423         tab._remove_method = self._children.remove
2424         return tab
2425 
2426     def add_container(self, container):
2427         """
2428         Add a `.Container` to the Axes' containers; return the container.
2429         """
2430         label = container.get_label()
2431         if not label:
2432             container.set_label('_container%d' % len(self.containers))
2433         self.containers.append(container)
2434         container._remove_method = self.containers.remove
2435         return container
2436 
2437     def _unit_change_handler(self, axis_name, event=None):
2438         """
2439         Process axis units changes: requests updates to data and view limits.
2440         """
2441         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2442             return functools.partial(
2443                 self._unit_change_handler, axis_name, event=object())
2444         _api.check_in_list(self._axis_map, axis_name=axis_name)
2445         for line in self.lines:
2446             line.recache_always()
2447         self.relim()
2448         self._request_autoscale_view(axis_name)
2449 
2450     def relim(self, visible_only=False):
2451         """
2452         Recompute the data limits based on current artists.
2453 
2454         At present, `.Collection` instances are not supported.
2455 
2456         Parameters
2457         ----------
2458         visible_only : bool, default: False
2459             Whether to exclude invisible artists.
2460         """
2461         # Collections are deliberately not supported (yet); see
2462         # the TODO note in artists.py.
2463         self.dataLim.ignore(True)
2464         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2465         self.ignore_existing_data_limits = True
2466 
2467         for artist in self._children:
2468             if not visible_only or artist.get_visible():
2469                 if isinstance(artist, mlines.Line2D):
2470                     self._update_line_limits(artist)
2471                 elif isinstance(artist, mpatches.Patch):
2472                     self._update_patch_limits(artist)
2473                 elif isinstance(artist, mimage.AxesImage):
2474                     self._update_image_limits(artist)
2475 
2476     def update_datalim(self, xys, updatex=True, updatey=True):
2477         """
2478         Extend the `~.Axes.dataLim` Bbox to include the given points.
2479 
2480         If no data is set currently, the Bbox will ignore its limits and set
2481         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2482         compute the bounds of the union of its current data and the data in
2483         *xys*.
2484 
2485         Parameters
2486         ----------
2487         xys : 2D array-like
2488             The points to include in the data limits Bbox. This can be either
2489             a list of (x, y) tuples or a (N, 2) array.
2490 
2491         updatex, updatey : bool, default: True
2492             Whether to update the x/y limits.
2493         """
2494         xys = np.asarray(xys)
2495         if not np.any(np.isfinite(xys)):
2496             return
2497         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2498                                          updatex=updatex, updatey=updatey)
2499         self.ignore_existing_data_limits = False
2500 
2501     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2502         """
2503         Set axis units based on *datasets* and *kwargs*, and optionally apply
2504         unit conversions to *datasets*.
2505 
2506         Parameters
2507         ----------
2508         datasets : list
2509             List of (axis_name, dataset) pairs (where the axis name is defined
2510             as in `._axis_map`).  Individual datasets can also be None
2511             (which gets passed through).
2512         kwargs : dict
2513             Other parameters from which unit info (i.e., the *xunits*,
2514             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2515             polar) entries) is popped, if present.  Note that this dict is
2516             mutated in-place!
2517         convert : bool, default: True
2518             Whether to return the original datasets or the converted ones.
2519 
2520         Returns
2521         -------
2522         list
2523             Either the original datasets if *convert* is False, or the
2524             converted ones if *convert* is True (the default).
2525         """
2526         # The API makes datasets a list of pairs rather than an axis_name to
2527         # dataset mapping because it is sometimes necessary to process multiple
2528         # datasets for a single axis, and concatenating them may be tricky
2529         # (e.g. if some are scalars, etc.).
2530         datasets = datasets or []
2531         kwargs = kwargs or {}
2532         axis_map = self._axis_map
2533         for axis_name, data in datasets:
2534             try:
2535                 axis = axis_map[axis_name]
2536             except KeyError:
2537                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2538             # Update from data if axis is already set but no unit is set yet.
2539             if axis is not None and data is not None and not axis.have_units():
2540                 axis.update_units(data)
2541         for axis_name, axis in axis_map.items():
2542             # Return if no axis is set.
2543             if axis is None:
2544                 continue
2545             # Check for units in the kwargs, and if present update axis.
2546             units = kwargs.pop(f"{axis_name}units", axis.units)
2547             if self.name == "polar":
2548                 # Special case: polar supports "thetaunits"/"runits".
2549                 polar_units = {"x": "thetaunits", "y": "runits"}
2550                 units = kwargs.pop(polar_units[axis_name], units)
2551             if units != axis.units and units is not None:
2552                 axis.set_units(units)
2553                 # If the units being set imply a different converter,
2554                 # we need to update again.
2555                 for dataset_axis_name, data in datasets:
2556                     if dataset_axis_name == axis_name and data is not None:
2557                         axis.update_units(data)
2558         return [axis_map[axis_name].convert_units(data)
2559                 if convert and data is not None else data
2560                 for axis_name, data in datasets]
2561 
2562     def in_axes(self, mouseevent):
2563         """
2564         Return whether the given event (in display coords) is in the Axes.
2565         """
2566         return self.patch.contains(mouseevent)[0]
2567 
2568     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2569     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2570     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2571     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2572 
2573     def get_autoscale_on(self):
2574         """Return True if each axis is autoscaled, False otherwise."""
2575         return all(axis._get_autoscale_on()
2576                    for axis in self._axis_map.values())
2577 
2578     def set_autoscale_on(self, b):
2579         """
2580         Set whether autoscaling is applied to each axis on the next draw or
2581         call to `.Axes.autoscale_view`.
2582 
2583         Parameters
2584         ----------
2585         b : bool
2586         """
2587         for axis in self._axis_map.values():
2588             axis._set_autoscale_on(b)
2589 
2590     @property
2591     def use_sticky_edges(self):
2592         """
2593         When autoscaling, whether to obey all `Artist.sticky_edges`.
2594 
2595         Default is ``True``.
2596 
2597         Setting this to ``False`` ensures that the specified margins
2598         will be applied, even if the plot includes an image, for
2599         example, which would otherwise force a view limit to coincide
2600         with its data limit.
2601 
2602         The changing this property does not change the plot until
2603         `autoscale` or `autoscale_view` is called.
2604         """
2605         return self._use_sticky_edges
2606 
2607     @use_sticky_edges.setter
2608     def use_sticky_edges(self, b):
2609         self._use_sticky_edges = bool(b)
2610         # No effect until next autoscaling, which will mark the Axes as stale.
2611 
2612     def set_xmargin(self, m):
2613         """
2614         Set padding of X data limits prior to autoscaling.
2615 
2616         *m* times the data interval will be added to each end of that interval
2617         before it is used in autoscaling.  If *m* is negative, this will clip
2618         the data range instead of expanding it.
2619 
2620         For example, if your data is in the range [0, 2], a margin of 0.1 will
2621         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2622         of [0.2, 1.8].
2623 
2624         Parameters
2625         ----------
2626         m : float greater than -0.5
2627         """
2628         if m <= -0.5:
2629             raise ValueError("margin must be greater than -0.5")
2630         self._xmargin = m
2631         self._request_autoscale_view("x")
2632         self.stale = True
2633 
2634     def set_ymargin(self, m):
2635         """
2636         Set padding of Y data limits prior to autoscaling.
2637 
2638         *m* times the data interval will be added to each end of that interval
2639         before it is used in autoscaling.  If *m* is negative, this will clip
2640         the data range instead of expanding it.
2641 
2642         For example, if your data is in the range [0, 2], a margin of 0.1 will
2643         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2644         of [0.2, 1.8].
2645 
2646         Parameters
2647         ----------
2648         m : float greater than -0.5
2649         """
2650         if m <= -0.5:
2651             raise ValueError("margin must be greater than -0.5")
2652         self._ymargin = m
2653         self._request_autoscale_view("y")
2654         self.stale = True
2655 
2656     def margins(self, *margins, x=None, y=None, tight=True):
2657         """
2658         Set or retrieve autoscaling margins.
2659 
2660         The padding added to each limit of the Axes is the *margin*
2661         times the data interval. All input parameters must be floats
2662         greater than -0.5. Passing both positional and keyword
2663         arguments is invalid and will raise a TypeError. If no
2664         arguments (positional or otherwise) are provided, the current
2665         margins will remain unchanged and simply be returned.
2666 
2667         Specifying any margin changes only the autoscaling; for example,
2668         if *xmargin* is not None, then *xmargin* times the X data
2669         interval will be added to each end of that interval before
2670         it is used in autoscaling.
2671 
2672         Parameters
2673         ----------
2674         *margins : float, optional
2675             If a single positional argument is provided, it specifies
2676             both margins of the x-axis and y-axis limits. If two
2677             positional arguments are provided, they will be interpreted
2678             as *xmargin*, *ymargin*. If setting the margin on a single
2679             axis is desired, use the keyword arguments described below.
2680 
2681         x, y : float, optional
2682             Specific margin values for the x-axis and y-axis,
2683             respectively. These cannot be used with positional
2684             arguments, but can be used individually to alter on e.g.,
2685             only the y-axis.
2686 
2687         tight : bool or None, default: True
2688             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2689             which is executed after a margin is changed; the default
2690             here is *True*, on the assumption that when margins are
2691             specified, no additional padding to match tick marks is
2692             usually desired.  Setting *tight* to *None* preserves
2693             the previous setting.
2694 
2695         Returns
2696         -------
2697         xmargin, ymargin : float
2698 
2699         Notes
2700         -----
2701         If a previously used Axes method such as :meth:`pcolor` has set
2702         :attr:`use_sticky_edges` to `True`, only the limits not set by
2703         the "sticky artists" will be modified. To force all of the
2704         margins to be set, set :attr:`use_sticky_edges` to `False`
2705         before calling :meth:`margins`.
2706         """
2707 
2708         if margins and (x is not None or y is not None):
2709             raise TypeError('Cannot pass both positional and keyword '
2710                             'arguments for x and/or y.')
2711         elif len(margins) == 1:
2712             x = y = margins[0]
2713         elif len(margins) == 2:
2714             x, y = margins
2715         elif margins:
2716             raise TypeError('Must pass a single positional argument for all '
2717                             'margins, or one for each margin (x, y).')
2718 
2719         if x is None and y is None:
2720             if tight is not True:
2721                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2722             return self._xmargin, self._ymargin
2723 
2724         if tight is not None:
2725             self._tight = tight
2726         if x is not None:
2727             self.set_xmargin(x)
2728         if y is not None:
2729             self.set_ymargin(y)
2730 
2731     def set_rasterization_zorder(self, z):
2732         """
2733         Set the zorder threshold for rasterization for vector graphics output.
2734 
2735         All artists with a zorder below the given value will be rasterized if
2736         they support rasterization.
2737 
2738         This setting is ignored for pixel-based output.
2739 
2740         See also :doc:`/gallery/misc/rasterization_demo`.
2741 
2742         Parameters
2743         ----------
2744         z : float or None
2745             The zorder below which artists are rasterized.
2746             If ``None`` rasterization based on zorder is deactivated.
2747         """
2748         self._rasterization_zorder = z
2749         self.stale = True
2750 
2751     def get_rasterization_zorder(self):
2752         """Return the zorder value below which artists will be rasterized."""
2753         return self._rasterization_zorder
2754 
2755     def autoscale(self, enable=True, axis='both', tight=None):
2756         """
2757         Autoscale the axis view to the data (toggle).
2758 
2759         Convenience method for simple axis view autoscaling.
2760         It turns autoscaling on or off, and then,
2761         if autoscaling for either axis is on, it performs
2762         the autoscaling on the specified axis or Axes.
2763 
2764         Parameters
2765         ----------
2766         enable : bool or None, default: True
2767             True turns autoscaling on, False turns it off.
2768             None leaves the autoscaling state unchanged.
2769         axis : {'both', 'x', 'y'}, default: 'both'
2770             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2771             to 'z', and 'both' refers to all three axes.)
2772         tight : bool or None, default: None
2773             If True, first set the margins to zero.  Then, this argument is
2774             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2775             its value); see the description of its behavior there.
2776         """
2777         if enable is None:
2778             scalex = True
2779             scaley = True
2780         else:
2781             if axis in ['x', 'both']:
2782                 self.set_autoscalex_on(bool(enable))
2783                 scalex = self.get_autoscalex_on()
2784             else:
2785                 scalex = False
2786             if axis in ['y', 'both']:
2787                 self.set_autoscaley_on(bool(enable))
2788                 scaley = self.get_autoscaley_on()
2789             else:
2790                 scaley = False
2791         if tight and scalex:
2792             self._xmargin = 0
2793         if tight and scaley:
2794             self._ymargin = 0
2795         if scalex:
2796             self._request_autoscale_view("x", tight=tight)
2797         if scaley:
2798             self._request_autoscale_view("y", tight=tight)
2799 
2800     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2801         """
2802         Autoscale the view limits using the data limits.
2803 
2804         Parameters
2805         ----------
2806         tight : bool or None
2807             If *True*, only expand the axis limits using the margins.  Note
2808             that unlike for `autoscale`, ``tight=True`` does *not* set the
2809             margins to zero.
2810 
2811             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2812             after expansion by the margins, further expand the axis limits
2813             using the axis major locator.
2814 
2815             If None (the default), reuse the value set in the previous call to
2816             `autoscale_view` (the initial value is False, but the default style
2817             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2818             behaves like True).
2819 
2820         scalex : bool, default: True
2821             Whether to autoscale the x-axis.
2822 
2823         scaley : bool, default: True
2824             Whether to autoscale the y-axis.
2825 
2826         Notes
2827         -----
2828         The autoscaling preserves any preexisting axis direction reversal.
2829 
2830         The data limits are not updated automatically when artist data are
2831         changed after the artist has been added to an Axes instance.  In that
2832         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2833         autoscale_view.
2834 
2835         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2836         not be changed by autoscale_view().
2837         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2838         """
2839         if tight is not None:
2840             self._tight = bool(tight)
2841 
2842         x_stickies = y_stickies = np.array([])
2843         if self.use_sticky_edges:
2844             if self._xmargin and scalex and self.get_autoscalex_on():
2845                 x_stickies = np.sort(np.concatenate([
2846                     artist.sticky_edges.x
2847                     for ax in self._shared_axes["x"].get_siblings(self)
2848                     for artist in ax.get_children()]))
2849             if self._ymargin and scaley and self.get_autoscaley_on():
2850                 y_stickies = np.sort(np.concatenate([
2851                     artist.sticky_edges.y
2852                     for ax in self._shared_axes["y"].get_siblings(self)
2853                     for artist in ax.get_children()]))
2854         if self.get_xscale() == 'log':
2855             x_stickies = x_stickies[x_stickies > 0]
2856         if self.get_yscale() == 'log':
2857             y_stickies = y_stickies[y_stickies > 0]
2858 
2859         def handle_single_axis(
2860                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2861 
2862             if not (scale and axis._get_autoscale_on()):
2863                 return  # nothing to do...
2864 
2865             shared = shared_axes.get_siblings(self)
2866             # Base autoscaling on finite data limits when there is at least one
2867             # finite data limit among all the shared_axes and intervals.
2868             values = [val for ax in shared
2869                       for val in getattr(ax.dataLim, f"interval{name}")
2870                       if np.isfinite(val)]
2871             if values:
2872                 x0, x1 = (min(values), max(values))
2873             elif getattr(self._viewLim, f"mutated{name}")():
2874                 # No data, but explicit viewLims already set:
2875                 # in mutatedx or mutatedy.
2876                 return
2877             else:
2878                 x0, x1 = (-np.inf, np.inf)
2879             # If x0 and x1 are nonfinite, get default limits from the locator.
2880             locator = axis.get_major_locator()
2881             x0, x1 = locator.nonsingular(x0, x1)
2882             # Find the minimum minpos for use in the margin calculation.
2883             minimum_minpos = min(
2884                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2885 
2886             # Prevent margin addition from crossing a sticky value.  A small
2887             # tolerance must be added due to floating point issues with
2888             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2889             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2890             # datasets where all values are tiny (less than 1e-8).
2891             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2892             # Index of largest element < x0 + tol, if any.
2893             i0 = stickies.searchsorted(x0 + tol) - 1
2894             x0bound = stickies[i0] if i0 != -1 else None
2895             # Index of smallest element > x1 - tol, if any.
2896             i1 = stickies.searchsorted(x1 - tol)
2897             x1bound = stickies[i1] if i1 != len(stickies) else None
2898 
2899             # Add the margin in figure space and then transform back, to handle
2900             # non-linear scales.
2901             transform = axis.get_transform()
2902             inverse_trans = transform.inverted()
2903             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2904             x0t, x1t = transform.transform([x0, x1])
2905             delta = (x1t - x0t) * margin
2906             if not np.isfinite(delta):
2907                 delta = 0  # If a bound isn't finite, set margin to zero.
2908             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2909 
2910             # Apply sticky bounds.
2911             if x0bound is not None:
2912                 x0 = max(x0, x0bound)
2913             if x1bound is not None:
2914                 x1 = min(x1, x1bound)
2915 
2916             if not self._tight:
2917                 x0, x1 = locator.view_limits(x0, x1)
2918             set_bound(x0, x1)
2919             # End of definition of internal function 'handle_single_axis'.
2920 
2921         handle_single_axis(
2922             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2923             x_stickies, self.set_xbound)
2924         handle_single_axis(
2925             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2926             y_stickies, self.set_ybound)
2927 
2928     def _update_title_position(self, renderer):
2929         """
2930         Update the title position based on the bounding box enclosing
2931         all the ticklabels and x-axis spine and xlabel...
2932         """
2933         if self._autotitlepos is not None and not self._autotitlepos:
2934             _log.debug('title position was updated manually, not adjusting')
2935             return
2936 
2937         titles = (self.title, self._left_title, self._right_title)
2938 
2939         # Need to check all our twins too, and all the children as well.
2940         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2941         for ax in self.child_axes:  # Child positions must be updated first.
2942             locator = ax.get_axes_locator()
2943             ax.apply_aspect(locator(self, renderer) if locator else None)
2944 
2945         for title in titles:
2946             x, _ = title.get_position()
2947             # need to start again in case of window resizing
2948             title.set_position((x, 1.0))
2949             top = -np.inf
2950             for ax in axs:
2951                 bb = None
2952                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2953                         or ax.xaxis.get_label_position() == 'top'):
2954                     bb = ax.xaxis.get_tightbbox(renderer)
2955                 if bb is None:
2956                     if 'outline' in ax.spines:
2957                         # Special case for colorbars:
2958                         bb = ax.spines['outline'].get_window_extent()
2959                     else:
2960                         bb = ax.get_window_extent(renderer)
2961                 top = max(top, bb.ymax)
2962                 if title.get_text():
2963                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2964                     if ax.yaxis.offsetText.get_text():
2965                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2966                         if bb.intersection(title.get_tightbbox(renderer), bb):
2967                             top = bb.ymax
2968             if top < 0:
2969                 # the top of Axes is not even on the figure, so don't try and
2970                 # automatically place it.
2971                 _log.debug('top of Axes not in the figure, so title not moved')
2972                 return
2973             if title.get_window_extent(renderer).ymin < top:
2974                 _, y = self.transAxes.inverted().transform((0, top))
2975                 title.set_position((x, y))
2976                 # empirically, this doesn't always get the min to top,
2977                 # so we need to adjust again.
2978                 if title.get_window_extent(renderer).ymin < top:
2979                     _, y = self.transAxes.inverted().transform(
2980                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2981                     title.set_position((x, y))
2982 
2983         ymax = max(title.get_position()[1] for title in titles)
2984         for title in titles:
2985             # now line up all the titles at the highest baseline.
2986             x, _ = title.get_position()
2987             title.set_position((x, ymax))
2988 
2989     # Drawing
2990     @martist.allow_rasterization
2991     def draw(self, renderer):
2992         # docstring inherited
2993         if renderer is None:
2994             raise RuntimeError('No renderer defined')
2995         if not self.get_visible():
2996             return
2997         self._unstale_viewLim()
2998 
2999         renderer.open_group('axes', gid=self.get_gid())
3000 
3001         # prevent triggering call backs during the draw process
3002         self._stale = True
3003 
3004         # loop over self and child Axes...
3005         locator = self.get_axes_locator()
3006         self.apply_aspect(locator(self, renderer) if locator else None)
3007 
3008         artists = self.get_children()
3009         artists.remove(self.patch)
3010 
3011         # the frame draws the edges around the Axes patch -- we
3012         # decouple these so the patch can be in the background and the
3013         # frame in the foreground. Do this before drawing the axis
3014         # objects so that the spine has the opportunity to update them.
3015         if not (self.axison and self._frameon):
3016             for spine in self.spines.values():
3017                 artists.remove(spine)
3018 
3019         self._update_title_position(renderer)
3020 
3021         if not self.axison:
3022             for _axis in self._axis_map.values():
3023                 artists.remove(_axis)
3024 
3025         if not self.figure.canvas.is_saving():
3026             artists = [
3027                 a for a in artists
3028                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3029         artists = sorted(artists, key=attrgetter('zorder'))
3030 
3031         # rasterize artists with negative zorder
3032         # if the minimum zorder is negative, start rasterization
3033         rasterization_zorder = self._rasterization_zorder
3034 
3035         if (rasterization_zorder is not None and
3036                 artists and artists[0].zorder < rasterization_zorder):
3037             split_index = np.searchsorted(
3038                 [art.zorder for art in artists],
3039                 rasterization_zorder, side='right'
3040             )
3041             artists_rasterized = artists[:split_index]
3042             artists = artists[split_index:]
3043         else:
3044             artists_rasterized = []
3045 
3046         if self.axison and self._frameon:
3047             if artists_rasterized:
3048                 artists_rasterized = [self.patch] + artists_rasterized
3049             else:
3050                 artists = [self.patch] + artists
3051 
3052         if artists_rasterized:
3053             _draw_rasterized(self.figure, artists_rasterized, renderer)
3054 
3055         mimage._draw_list_compositing_images(
3056             renderer, self, artists, self.figure.suppressComposite)
3057 
3058         renderer.close_group('axes')
3059         self.stale = False
3060 
3061     def draw_artist(self, a):
3062         """
3063         Efficiently redraw a single artist.
3064         """
3065         a.draw(self.figure.canvas.get_renderer())
3066 
3067     def redraw_in_frame(self):
3068         """
3069         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3070         """
3071         with ExitStack() as stack:
3072             for artist in [*self._axis_map.values(),
3073                            self.title, self._left_title, self._right_title]:
3074                 stack.enter_context(artist._cm_set(visible=False))
3075             self.draw(self.figure.canvas.get_renderer())
3076 
3077     # Axes rectangle characteristics
3078 
3079     def get_frame_on(self):
3080         """Get whether the Axes rectangle patch is drawn."""
3081         return self._frameon
3082 
3083     def set_frame_on(self, b):
3084         """
3085         Set whether the Axes rectangle patch is drawn.
3086 
3087         Parameters
3088         ----------
3089         b : bool
3090         """
3091         self._frameon = b
3092         self.stale = True
3093 
3094     def get_axisbelow(self):
3095         """
3096         Get whether axis ticks and gridlines are above or below most artists.
3097 
3098         Returns
3099         -------
3100         bool or 'line'
3101 
3102         See Also
3103         --------
3104         set_axisbelow
3105         """
3106         return self._axisbelow
3107 
3108     def set_axisbelow(self, b):
3109         """
3110         Set whether axis ticks and gridlines are above or below most artists.
3111 
3112         This controls the zorder of the ticks and gridlines. For more
3113         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3114 
3115         Parameters
3116         ----------
3117         b : bool or 'line'
3118             Possible values:
3119 
3120             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3121             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3122               (e.g. rectangles, with default zorder = 1) but still below lines
3123               and markers (with their default zorder = 2).
3124             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3125               and lines / markers.
3126 
3127         See Also
3128         --------
3129         get_axisbelow
3130         """
3131         # Check that b is True, False or 'line'
3132         self._axisbelow = axisbelow = validate_axisbelow(b)
3133         zorder = {
3134             True: 0.5,
3135             'line': 1.5,
3136             False: 2.5,
3137         }[axisbelow]
3138         for axis in self._axis_map.values():
3139             axis.set_zorder(zorder)
3140         self.stale = True
3141 
3142     @_docstring.dedent_interpd
3143     def grid(self, visible=None, which='major', axis='both', **kwargs):
3144         """
3145         Configure the grid lines.
3146 
3147         Parameters
3148         ----------
3149         visible : bool or None, optional
3150             Whether to show the grid lines.  If any *kwargs* are supplied, it
3151             is assumed you want the grid on and *visible* will be set to True.
3152 
3153             If *visible* is *None* and there are no *kwargs*, this toggles the
3154             visibility of the lines.
3155 
3156         which : {'major', 'minor', 'both'}, optional
3157             The grid lines to apply the changes on.
3158 
3159         axis : {'both', 'x', 'y'}, optional
3160             The axis to apply the changes on.
3161 
3162         **kwargs : `~matplotlib.lines.Line2D` properties
3163             Define the line properties of the grid, e.g.::
3164 
3165                 grid(color='r', linestyle='-', linewidth=2)
3166 
3167             Valid keyword arguments are:
3168 
3169             %(Line2D:kwdoc)s
3170 
3171         Notes
3172         -----
3173         The axis is drawn as a unit, so the effective zorder for drawing the
3174         grid is determined by the zorder of each axis, not by the zorder of the
3175         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3176         use `.set_axisbelow` or, for more control, call the
3177         `~.Artist.set_zorder` method of each axis.
3178         """
3179         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3180         if axis in ['x', 'both']:
3181             self.xaxis.grid(visible, which=which, **kwargs)
3182         if axis in ['y', 'both']:
3183             self.yaxis.grid(visible, which=which, **kwargs)
3184 
3185     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3186                          useOffset=None, useLocale=None, useMathText=None):
3187         r"""
3188         Configure the `.ScalarFormatter` used by default for linear Axes.
3189 
3190         If a parameter is not set, the corresponding property of the formatter
3191         is left unchanged.
3192 
3193         Parameters
3194         ----------
3195         axis : {'x', 'y', 'both'}, default: 'both'
3196             The axis to configure.  Only major ticks are affected.
3197 
3198         style : {'sci', 'scientific', 'plain'}
3199             Whether to use scientific notation.
3200             The formatter default is to use scientific notation.
3201 
3202         scilimits : pair of ints (m, n)
3203             Scientific notation is used only for numbers outside the range
3204             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3205             configured to use scientific notation at all).  Use (0, 0) to
3206             include all numbers.  Use (m, m) where m != 0 to fix the order of
3207             magnitude to 10\ :sup:`m`.
3208             The formatter default is :rc:`axes.formatter.limits`.
3209 
3210         useOffset : bool or float
3211             If True, the offset is calculated as needed.
3212             If False, no offset is used.
3213             If a numeric value, it sets the offset.
3214             The formatter default is :rc:`axes.formatter.useoffset`.
3215 
3216         useLocale : bool
3217             Whether to format the number using the current locale or using the
3218             C (English) locale.  This affects e.g. the decimal separator.  The
3219             formatter default is :rc:`axes.formatter.use_locale`.
3220 
3221         useMathText : bool
3222             Render the offset and scientific notation in mathtext.
3223             The formatter default is :rc:`axes.formatter.use_mathtext`.
3224 
3225         Raises
3226         ------
3227         AttributeError
3228             If the current formatter is not a `.ScalarFormatter`.
3229         """
3230         style = style.lower()
3231         axis = axis.lower()
3232         if scilimits is not None:
3233             try:
3234                 m, n = scilimits
3235                 m + n + 1  # check that both are numbers
3236             except (ValueError, TypeError) as err:
3237                 raise ValueError("scilimits must be a sequence of 2 integers"
3238                                  ) from err
3239         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3240         is_sci_style = _api.check_getitem(STYLES, style=style)
3241         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3242                     'both': list(self._axis_map.values())}
3243         axises = _api.check_getitem(axis_map, axis=axis)
3244         try:
3245             for axis in axises:
3246                 if is_sci_style is not None:
3247                     axis.major.formatter.set_scientific(is_sci_style)
3248                 if scilimits is not None:
3249                     axis.major.formatter.set_powerlimits(scilimits)
3250                 if useOffset is not None:
3251                     axis.major.formatter.set_useOffset(useOffset)
3252                 if useLocale is not None:
3253                     axis.major.formatter.set_useLocale(useLocale)
3254                 if useMathText is not None:
3255                     axis.major.formatter.set_useMathText(useMathText)
3256         except AttributeError as err:
3257             raise AttributeError(
3258                 "This method only works with the ScalarFormatter") from err
3259 
3260     def locator_params(self, axis='both', tight=None, **kwargs):
3261         """
3262         Control behavior of major tick locators.
3263 
3264         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3265         is called automatically after the parameters are changed.
3266 
3267         Parameters
3268         ----------
3269         axis : {'both', 'x', 'y'}, default: 'both'
3270             The axis on which to operate.  (For 3D Axes, *axis* can also be
3271             set to 'z', and 'both' refers to all three axes.)
3272         tight : bool or None, optional
3273             Parameter passed to `~.Axes.autoscale_view`.
3274             Default is None, for no change.
3275 
3276         Other Parameters
3277         ----------------
3278         **kwargs
3279             Remaining keyword arguments are passed to directly to the
3280             ``set_params()`` method of the locator. Supported keywords depend
3281             on the type of the locator. See for example
3282             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3283             used by default for linear.
3284 
3285         Examples
3286         --------
3287         When plotting small subplots, one might want to reduce the maximum
3288         number of ticks and use tight bounds, for example::
3289 
3290             ax.locator_params(tight=True, nbins=4)
3291 
3292         """
3293         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3294         for name in self._axis_names:
3295             if axis in [name, "both"]:
3296                 loc = self._axis_map[name].get_major_locator()
3297                 loc.set_params(**kwargs)
3298                 self._request_autoscale_view(name, tight=tight)
3299         self.stale = True
3300 
3301     def tick_params(self, axis='both', **kwargs):
3302         """
3303         Change the appearance of ticks, tick labels, and gridlines.
3304 
3305         Tick properties that are not explicitly set using the keyword
3306         arguments remain unchanged unless *reset* is True. For the current
3307         style settings, see `.Axis.get_tick_params`.
3308 
3309         Parameters
3310         ----------
3311         axis : {'x', 'y', 'both'}, default: 'both'
3312             The axis to which the parameters are applied.
3313         which : {'major', 'minor', 'both'}, default: 'major'
3314             The group of ticks to which the parameters are applied.
3315         reset : bool, default: False
3316             Whether to reset the ticks to defaults before updating them.
3317 
3318         Other Parameters
3319         ----------------
3320         direction : {'in', 'out', 'inout'}
3321             Puts ticks inside the Axes, outside the Axes, or both.
3322         length : float
3323             Tick length in points.
3324         width : float
3325             Tick width in points.
3326         color : color
3327             Tick color.
3328         pad : float
3329             Distance in points between tick and label.
3330         labelsize : float or str
3331             Tick label font size in points or as a string (e.g., 'large').
3332         labelcolor : color
3333             Tick label color.
3334         labelfontfamily : str
3335             Tick label font.
3336         colors : color
3337             Tick color and label color.
3338         zorder : float
3339             Tick and label zorder.
3340         bottom, top, left, right : bool
3341             Whether to draw the respective ticks.
3342         labelbottom, labeltop, labelleft, labelright : bool
3343             Whether to draw the respective tick labels.
3344         labelrotation : float
3345             Tick label rotation
3346         grid_color : color
3347             Gridline color.
3348         grid_alpha : float
3349             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3350         grid_linewidth : float
3351             Width of gridlines in points.
3352         grid_linestyle : str
3353             Any valid `.Line2D` line style spec.
3354 
3355         Examples
3356         --------
3357         ::
3358 
3359             ax.tick_params(direction='out', length=6, width=2, colors='r',
3360                            grid_color='r', grid_alpha=0.5)
3361 
3362         This will make all major ticks be red, pointing out of the box,
3363         and with dimensions 6 points by 2 points.  Tick labels will
3364         also be red.  Gridlines will be red and translucent.
3365 
3366         """
3367         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3368         if axis in ['x', 'both']:
3369             xkw = dict(kwargs)
3370             xkw.pop('left', None)
3371             xkw.pop('right', None)
3372             xkw.pop('labelleft', None)
3373             xkw.pop('labelright', None)
3374             self.xaxis.set_tick_params(**xkw)
3375         if axis in ['y', 'both']:
3376             ykw = dict(kwargs)
3377             ykw.pop('top', None)
3378             ykw.pop('bottom', None)
3379             ykw.pop('labeltop', None)
3380             ykw.pop('labelbottom', None)
3381             self.yaxis.set_tick_params(**ykw)
3382 
3383     def set_axis_off(self):
3384         """
3385         Turn the x- and y-axis off.
3386 
3387         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3388         """
3389         self.axison = False
3390         self.stale = True
3391 
3392     def set_axis_on(self):
3393         """
3394         Turn the x- and y-axis on.
3395 
3396         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3397         """
3398         self.axison = True
3399         self.stale = True
3400 
3401     # data limits, ticks, tick labels, and formatting
3402 
3403     def get_xlabel(self):
3404         """
3405         Get the xlabel text string.
3406         """
3407         label = self.xaxis.get_label()
3408         return label.get_text()
3409 
3410     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3411                    loc=None, **kwargs):
3412         """
3413         Set the label for the x-axis.
3414 
3415         Parameters
3416         ----------
3417         xlabel : str
3418             The label text.
3419 
3420         labelpad : float, default: :rc:`axes.labelpad`
3421             Spacing in points from the Axes bounding box including ticks
3422             and tick labels.  If None, the previous value is left as is.
3423 
3424         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3425             The label position. This is a high-level alternative for passing
3426             parameters *x* and *horizontalalignment*.
3427 
3428         Other Parameters
3429         ----------------
3430         **kwargs : `~matplotlib.text.Text` properties
3431             `.Text` properties control the appearance of the label.
3432 
3433         See Also
3434         --------
3435         text : Documents the properties supported by `.Text`.
3436         """
3437         if labelpad is not None:
3438             self.xaxis.labelpad = labelpad
3439         protected_kw = ['x', 'horizontalalignment', 'ha']
3440         if {*kwargs} & {*protected_kw}:
3441             if loc is not None:
3442                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3443                                 f"its corresponding low level keyword "
3444                                 f"arguments ({protected_kw}) are also "
3445                                 f"supplied")
3446 
3447         else:
3448             loc = (loc if loc is not None
3449                    else mpl.rcParams['xaxis.labellocation'])
3450             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3451 
3452             x = {
3453                 'left': 0,
3454                 'center': 0.5,
3455                 'right': 1,
3456             }[loc]
3457             kwargs.update(x=x, horizontalalignment=loc)
3458 
3459         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3460 
3461     def invert_xaxis(self):
3462         """
3463         Invert the x-axis.
3464 
3465         See Also
3466         --------
3467         xaxis_inverted
3468         get_xlim, set_xlim
3469         get_xbound, set_xbound
3470         """
3471         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3472 
3473     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3474 
3475     def get_xbound(self):
3476         """
3477         Return the lower and upper x-axis bounds, in increasing order.
3478 
3479         See Also
3480         --------
3481         set_xbound
3482         get_xlim, set_xlim
3483         invert_xaxis, xaxis_inverted
3484         """
3485         left, right = self.get_xlim()
3486         if left < right:
3487             return left, right
3488         else:
3489             return right, left
3490 
3491     def set_xbound(self, lower=None, upper=None):
3492         """
3493         Set the lower and upper numerical bounds of the x-axis.
3494 
3495         This method will honor axis inversion regardless of parameter order.
3496         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3497 
3498         Parameters
3499         ----------
3500         lower, upper : float or None
3501             The lower and upper bounds. If *None*, the respective axis bound
3502             is not modified.
3503 
3504         See Also
3505         --------
3506         get_xbound
3507         get_xlim, set_xlim
3508         invert_xaxis, xaxis_inverted
3509         """
3510         if upper is None and np.iterable(lower):
3511             lower, upper = lower
3512 
3513         old_lower, old_upper = self.get_xbound()
3514         if lower is None:
3515             lower = old_lower
3516         if upper is None:
3517             upper = old_upper
3518 
3519         self.set_xlim(sorted((lower, upper),
3520                              reverse=bool(self.xaxis_inverted())),
3521                       auto=None)
3522 
3523     def get_xlim(self):
3524         """
3525         Return the x-axis view limits.
3526 
3527         Returns
3528         -------
3529         left, right : (float, float)
3530             The current x-axis limits in data coordinates.
3531 
3532         See Also
3533         --------
3534         .Axes.set_xlim
3535         set_xbound, get_xbound
3536         invert_xaxis, xaxis_inverted
3537 
3538         Notes
3539         -----
3540         The x-axis may be inverted, in which case the *left* value will
3541         be greater than the *right* value.
3542         """
3543         return tuple(self.viewLim.intervalx)
3544 
3545     def _validate_converted_limits(self, limit, convert):
3546         """
3547         Raise ValueError if converted limits are non-finite.
3548 
3549         Note that this function also accepts None as a limit argument.
3550 
3551         Returns
3552         -------
3553         The limit value after call to convert(), or None if limit is None.
3554         """
3555         if limit is not None:
3556             converted_limit = convert(limit)
3557             if (isinstance(converted_limit, Real)
3558                     and not np.isfinite(converted_limit)):
3559                 raise ValueError("Axis limits cannot be NaN or Inf")
3560             return converted_limit
3561 
3562     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3563                  xmin=None, xmax=None):
3564         """
3565         Set the x-axis view limits.
3566 
3567         Parameters
3568         ----------
3569         left : float, optional
3570             The left xlim in data coordinates. Passing *None* leaves the
3571             limit unchanged.
3572 
3573             The left and right xlims may also be passed as the tuple
3574             (*left*, *right*) as the first positional argument (or as
3575             the *left* keyword argument).
3576 
3577             .. ACCEPTS: (bottom: float, top: float)
3578 
3579         right : float, optional
3580             The right xlim in data coordinates. Passing *None* leaves the
3581             limit unchanged.
3582 
3583         emit : bool, default: True
3584             Whether to notify observers of limit change.
3585 
3586         auto : bool or None, default: False
3587             Whether to turn on autoscaling of the x-axis. True turns on,
3588             False turns off, None leaves unchanged.
3589 
3590         xmin, xmax : float, optional
3591             They are equivalent to left and right respectively, and it is an
3592             error to pass both *xmin* and *left* or *xmax* and *right*.
3593 
3594         Returns
3595         -------
3596         left, right : (float, float)
3597             The new x-axis limits in data coordinates.
3598 
3599         See Also
3600         --------
3601         get_xlim
3602         set_xbound, get_xbound
3603         invert_xaxis, xaxis_inverted
3604 
3605         Notes
3606         -----
3607         The *left* value may be greater than the *right* value, in which
3608         case the x-axis values will decrease from left to right.
3609 
3610         Examples
3611         --------
3612         >>> set_xlim(left, right)
3613         >>> set_xlim((left, right))
3614         >>> left, right = set_xlim(left, right)
3615 
3616         One limit may be left unchanged.
3617 
3618         >>> set_xlim(right=right_lim)
3619 
3620         Limits may be passed in reverse order to flip the direction of
3621         the x-axis. For example, suppose *x* represents the number of
3622         years before present. The x-axis limits might be set like the
3623         following so 5000 years ago is on the left of the plot and the
3624         present is on the right.
3625 
3626         >>> set_xlim(5000, 0)
3627         """
3628         if right is None and np.iterable(left):
3629             left, right = left
3630         if xmin is not None:
3631             if left is not None:
3632                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3633             left = xmin
3634         if xmax is not None:
3635             if right is not None:
3636                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3637             right = xmax
3638         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3639 
3640     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3641     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3642     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3643     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3644     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3645     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3646     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3647     set_xticklabels = _axis_method_wrapper(
3648         "xaxis", "set_ticklabels",
3649         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3650 
3651     def get_ylabel(self):
3652         """
3653         Get the ylabel text string.
3654         """
3655         label = self.yaxis.get_label()
3656         return label.get_text()
3657 
3658     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3659                    loc=None, **kwargs):
3660         """
3661         Set the label for the y-axis.
3662 
3663         Parameters
3664         ----------
3665         ylabel : str
3666             The label text.
3667 
3668         labelpad : float, default: :rc:`axes.labelpad`
3669             Spacing in points from the Axes bounding box including ticks
3670             and tick labels.  If None, the previous value is left as is.
3671 
3672         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3673             The label position. This is a high-level alternative for passing
3674             parameters *y* and *horizontalalignment*.
3675 
3676         Other Parameters
3677         ----------------
3678         **kwargs : `~matplotlib.text.Text` properties
3679             `.Text` properties control the appearance of the label.
3680 
3681         See Also
3682         --------
3683         text : Documents the properties supported by `.Text`.
3684         """
3685         if labelpad is not None:
3686             self.yaxis.labelpad = labelpad
3687         protected_kw = ['y', 'horizontalalignment', 'ha']
3688         if {*kwargs} & {*protected_kw}:
3689             if loc is not None:
3690                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3691                                 f"its corresponding low level keyword "
3692                                 f"arguments ({protected_kw}) are also "
3693                                 f"supplied")
3694 
3695         else:
3696             loc = (loc if loc is not None
3697                    else mpl.rcParams['yaxis.labellocation'])
3698             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3699 
3700             y, ha = {
3701                 'bottom': (0, 'left'),
3702                 'center': (0.5, 'center'),
3703                 'top': (1, 'right')
3704             }[loc]
3705             kwargs.update(y=y, horizontalalignment=ha)
3706 
3707         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3708 
3709     def invert_yaxis(self):
3710         """
3711         Invert the y-axis.
3712 
3713         See Also
3714         --------
3715         yaxis_inverted
3716         get_ylim, set_ylim
3717         get_ybound, set_ybound
3718         """
3719         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3720 
3721     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3722 
3723     def get_ybound(self):
3724         """
3725         Return the lower and upper y-axis bounds, in increasing order.
3726 
3727         See Also
3728         --------
3729         set_ybound
3730         get_ylim, set_ylim
3731         invert_yaxis, yaxis_inverted
3732         """
3733         bottom, top = self.get_ylim()
3734         if bottom < top:
3735             return bottom, top
3736         else:
3737             return top, bottom
3738 
3739     def set_ybound(self, lower=None, upper=None):
3740         """
3741         Set the lower and upper numerical bounds of the y-axis.
3742 
3743         This method will honor axis inversion regardless of parameter order.
3744         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3745 
3746         Parameters
3747         ----------
3748         lower, upper : float or None
3749             The lower and upper bounds. If *None*, the respective axis bound
3750             is not modified.
3751 
3752         See Also
3753         --------
3754         get_ybound
3755         get_ylim, set_ylim
3756         invert_yaxis, yaxis_inverted
3757         """
3758         if upper is None and np.iterable(lower):
3759             lower, upper = lower
3760 
3761         old_lower, old_upper = self.get_ybound()
3762         if lower is None:
3763             lower = old_lower
3764         if upper is None:
3765             upper = old_upper
3766 
3767         self.set_ylim(sorted((lower, upper),
3768                              reverse=bool(self.yaxis_inverted())),
3769                       auto=None)
3770 
3771     def get_ylim(self):
3772         """
3773         Return the y-axis view limits.
3774 
3775         Returns
3776         -------
3777         bottom, top : (float, float)
3778             The current y-axis limits in data coordinates.
3779 
3780         See Also
3781         --------
3782         .Axes.set_ylim
3783         set_ybound, get_ybound
3784         invert_yaxis, yaxis_inverted
3785 
3786         Notes
3787         -----
3788         The y-axis may be inverted, in which case the *bottom* value
3789         will be greater than the *top* value.
3790         """
3791         return tuple(self.viewLim.intervaly)
3792 
3793     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3794                  ymin=None, ymax=None):
3795         """
3796         Set the y-axis view limits.
3797 
3798         Parameters
3799         ----------
3800         bottom : float, optional
3801             The bottom ylim in data coordinates. Passing *None* leaves the
3802             limit unchanged.
3803 
3804             The bottom and top ylims may also be passed as the tuple
3805             (*bottom*, *top*) as the first positional argument (or as
3806             the *bottom* keyword argument).
3807 
3808             .. ACCEPTS: (bottom: float, top: float)
3809 
3810         top : float, optional
3811             The top ylim in data coordinates. Passing *None* leaves the
3812             limit unchanged.
3813 
3814         emit : bool, default: True
3815             Whether to notify observers of limit change.
3816 
3817         auto : bool or None, default: False
3818             Whether to turn on autoscaling of the y-axis. *True* turns on,
3819             *False* turns off, *None* leaves unchanged.
3820 
3821         ymin, ymax : float, optional
3822             They are equivalent to bottom and top respectively, and it is an
3823             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3824 
3825         Returns
3826         -------
3827         bottom, top : (float, float)
3828             The new y-axis limits in data coordinates.
3829 
3830         See Also
3831         --------
3832         get_ylim
3833         set_ybound, get_ybound
3834         invert_yaxis, yaxis_inverted
3835 
3836         Notes
3837         -----
3838         The *bottom* value may be greater than the *top* value, in which
3839         case the y-axis values will decrease from *bottom* to *top*.
3840 
3841         Examples
3842         --------
3843         >>> set_ylim(bottom, top)
3844         >>> set_ylim((bottom, top))
3845         >>> bottom, top = set_ylim(bottom, top)
3846 
3847         One limit may be left unchanged.
3848 
3849         >>> set_ylim(top=top_lim)
3850 
3851         Limits may be passed in reverse order to flip the direction of
3852         the y-axis. For example, suppose ``y`` represents depth of the
3853         ocean in m. The y-axis limits might be set like the following
3854         so 5000 m depth is at the bottom of the plot and the surface,
3855         0 m, is at the top.
3856 
3857         >>> set_ylim(5000, 0)
3858         """
3859         if top is None and np.iterable(bottom):
3860             bottom, top = bottom
3861         if ymin is not None:
3862             if bottom is not None:
3863                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3864             bottom = ymin
3865         if ymax is not None:
3866             if top is not None:
3867                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3868             top = ymax
3869         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3870 
3871     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3872     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3873     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3874     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3875     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3876     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3877     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3878     set_yticklabels = _axis_method_wrapper(
3879         "yaxis", "set_ticklabels",
3880         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3881 
3882     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3883     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3884 
3885     def format_xdata(self, x):
3886         """
3887         Return *x* formatted as an x-value.
3888 
3889         This function will use the `.fmt_xdata` attribute if it is not None,
3890         else will fall back on the xaxis major formatter.
3891         """
3892         return (self.fmt_xdata if self.fmt_xdata is not None
3893                 else self.xaxis.get_major_formatter().format_data_short)(x)
3894 
3895     def format_ydata(self, y):
3896         """
3897         Return *y* formatted as a y-value.
3898 
3899         This function will use the `.fmt_ydata` attribute if it is not None,
3900         else will fall back on the yaxis major formatter.
3901         """
3902         return (self.fmt_ydata if self.fmt_ydata is not None
3903                 else self.yaxis.get_major_formatter().format_data_short)(y)
3904 
3905     def format_coord(self, x, y):
3906         """Return a format string formatting the *x*, *y* coordinates."""
3907         return "x={} y={}".format(
3908             "???" if x is None else self.format_xdata(x),
3909             "???" if y is None else self.format_ydata(y),
3910         )
3911 
3912     def minorticks_on(self):
3913         """
3914         Display minor ticks on the Axes.
3915 
3916         Displaying minor ticks may reduce performance; you may turn them off
3917         using `minorticks_off()` if drawing speed is a problem.
3918         """
3919         for ax in (self.xaxis, self.yaxis):
3920             scale = ax.get_scale()
3921             if scale == 'log':
3922                 s = ax._scale
3923                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3924             elif scale == 'symlog':
3925                 s = ax._scale
3926                 ax.set_minor_locator(
3927                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3928             else:
3929                 ax.set_minor_locator(mticker.AutoMinorLocator())
3930 
3931     def minorticks_off(self):
3932         """Remove minor ticks from the Axes."""
3933         self.xaxis.set_minor_locator(mticker.NullLocator())
3934         self.yaxis.set_minor_locator(mticker.NullLocator())
3935 
3936     # Interactive manipulation
3937 
3938     def can_zoom(self):
3939         """
3940         Return whether this Axes supports the zoom box button functionality.
3941         """
3942         return True
3943 
3944     def can_pan(self):
3945         """
3946         Return whether this Axes supports any pan/zoom button functionality.
3947         """
3948         return True
3949 
3950     def get_navigate(self):
3951         """
3952         Get whether the Axes responds to navigation commands.
3953         """
3954         return self._navigate
3955 
3956     def set_navigate(self, b):
3957         """
3958         Set whether the Axes responds to navigation toolbar commands.
3959 
3960         Parameters
3961         ----------
3962         b : bool
3963         """
3964         self._navigate = b
3965 
3966     def get_navigate_mode(self):
3967         """
3968         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3969         """
3970         return self._navigate_mode
3971 
3972     def set_navigate_mode(self, b):
3973         """
3974         Set the navigation toolbar button status.
3975 
3976         .. warning::
3977             This is not a user-API function.
3978 
3979         """
3980         self._navigate_mode = b
3981 
3982     def _get_view(self):
3983         """
3984         Save information required to reproduce the current view.
3985 
3986         This method is called before a view is changed, such as during a pan or zoom
3987         initiated by the user.  It returns an opaque object that describes the current
3988         view, in a format compatible with :meth:`_set_view`.
3989 
3990         The default implementation saves the view limits and autoscaling state.
3991         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3992         adjusted accordingly.
3993         """
3994         return {
3995             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
3996             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
3997         }
3998 
3999     def _set_view(self, view):
4000         """
4001         Apply a previously saved view.
4002 
4003         This method is called when restoring a view (with the return value of
4004         :meth:`_get_view` as argument), such as with the navigation buttons.
4005 
4006         Subclasses that override :meth:`_get_view` also need to override this method
4007         accordingly.
4008         """
4009         self.set(**view)
4010 
4011     def _prepare_view_from_bbox(self, bbox, direction='in',
4012                                 mode=None, twinx=False, twiny=False):
4013         """
4014         Helper function to prepare the new bounds from a bbox.
4015 
4016         This helper function returns the new x and y bounds from the zoom
4017         bbox. This a convenience method to abstract the bbox logic
4018         out of the base setter.
4019         """
4020         if len(bbox) == 3:
4021             xp, yp, scl = bbox  # Zooming code
4022             if scl == 0:  # Should not happen
4023                 scl = 1.
4024             if scl > 1:
4025                 direction = 'in'
4026             else:
4027                 direction = 'out'
4028                 scl = 1/scl
4029             # get the limits of the axes
4030             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4031                 np.transpose([self.get_xlim(), self.get_ylim()]))
4032             # set the range
4033             xwidth = xmax - xmin
4034             ywidth = ymax - ymin
4035             xcen = (xmax + xmin)*.5
4036             ycen = (ymax + ymin)*.5
4037             xzc = (xp*(scl - 1) + xcen)/scl
4038             yzc = (yp*(scl - 1) + ycen)/scl
4039             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4040                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4041         elif len(bbox) != 4:
4042             # should be len 3 or 4 but nothing else
4043             _api.warn_external(
4044                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4045                 "of length 3 or 4. Ignoring the view change.")
4046             return
4047 
4048         # Original limits.
4049         xmin0, xmax0 = self.get_xbound()
4050         ymin0, ymax0 = self.get_ybound()
4051         # The zoom box in screen coords.
4052         startx, starty, stopx, stopy = bbox
4053         # Convert to data coords.
4054         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4055             [(startx, starty), (stopx, stopy)])
4056         # Clip to axes limits.
4057         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4058         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4059         # Don't double-zoom twinned axes or if zooming only the other axis.
4060         if twinx or mode == "y":
4061             xmin, xmax = xmin0, xmax0
4062         if twiny or mode == "x":
4063             ymin, ymax = ymin0, ymax0
4064 
4065         if direction == "in":
4066             new_xbound = xmin, xmax
4067             new_ybound = ymin, ymax
4068 
4069         elif direction == "out":
4070             x_trf = self.xaxis.get_transform()
4071             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4072                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4073             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4074             # Move original bounds away by
4075             # (factor) x (distance between unzoom box and Axes bbox).
4076             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4077             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4078             # And back to data space.
4079             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4080 
4081             y_trf = self.yaxis.get_transform()
4082             symin0, symax0, symin, symax = y_trf.transform(
4083                 [ymin0, ymax0, ymin, ymax])
4084             factor = (symax0 - symin0) / (symax - symin)
4085             symin1 = symin0 - factor * (symin - symin0)
4086             symax1 = symax0 + factor * (symax0 - symax)
4087             new_ybound = y_trf.inverted().transform([symin1, symax1])
4088 
4089         return new_xbound, new_ybound
4090 
4091     def _set_view_from_bbox(self, bbox, direction='in',
4092                             mode=None, twinx=False, twiny=False):
4093         """
4094         Update view from a selection bbox.
4095 
4096         .. note::
4097 
4098             Intended to be overridden by new projection types, but if not, the
4099             default implementation sets the view limits to the bbox directly.
4100 
4101         Parameters
4102         ----------
4103         bbox : 4-tuple or 3 tuple
4104             * If bbox is a 4 tuple, it is the selected bounding box limits,
4105               in *display* coordinates.
4106             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4107               (xp, yp) is the center of zooming and scl the scale factor to
4108               zoom by.
4109 
4110         direction : str
4111             The direction to apply the bounding box.
4112                 * `'in'` - The bounding box describes the view directly, i.e.,
4113                            it zooms in.
4114                 * `'out'` - The bounding box describes the size to make the
4115                             existing view, i.e., it zooms out.
4116 
4117         mode : str or None
4118             The selection mode, whether to apply the bounding box in only the
4119             `'x'` direction, `'y'` direction or both (`None`).
4120 
4121         twinx : bool
4122             Whether this axis is twinned in the *x*-direction.
4123 
4124         twiny : bool
4125             Whether this axis is twinned in the *y*-direction.
4126         """
4127         new_xbound, new_ybound = self._prepare_view_from_bbox(
4128             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4129         if not twinx and mode != "y":
4130             self.set_xbound(new_xbound)
4131             self.set_autoscalex_on(False)
4132         if not twiny and mode != "x":
4133             self.set_ybound(new_ybound)
4134             self.set_autoscaley_on(False)
4135 
4136     def start_pan(self, x, y, button):
4137         """
4138         Called when a pan operation has started.
4139 
4140         Parameters
4141         ----------
4142         x, y : float
4143             The mouse coordinates in display coords.
4144         button : `.MouseButton`
4145             The pressed mouse button.
4146 
4147         Notes
4148         -----
4149         This is intended to be overridden by new projection types.
4150         """
4151         self._pan_start = types.SimpleNamespace(
4152             lim=self.viewLim.frozen(),
4153             trans=self.transData.frozen(),
4154             trans_inverse=self.transData.inverted().frozen(),
4155             bbox=self.bbox.frozen(),
4156             x=x,
4157             y=y)
4158 
4159     def end_pan(self):
4160         """
4161         Called when a pan operation completes (when the mouse button is up.)
4162 
4163         Notes
4164         -----
4165         This is intended to be overridden by new projection types.
4166         """
4167         del self._pan_start
4168 
4169     def _get_pan_points(self, button, key, x, y):
4170         """
4171         Helper function to return the new points after a pan.
4172 
4173         This helper function returns the points on the axis after a pan has
4174         occurred. This is a convenience method to abstract the pan logic
4175         out of the base setter.
4176         """
4177         def format_deltas(key, dx, dy):
4178             if key == 'control':
4179                 if abs(dx) > abs(dy):
4180                     dy = dx
4181                 else:
4182                     dx = dy
4183             elif key == 'x':
4184                 dy = 0
4185             elif key == 'y':
4186                 dx = 0
4187             elif key == 'shift':
4188                 if 2 * abs(dx) < abs(dy):
4189                     dx = 0
4190                 elif 2 * abs(dy) < abs(dx):
4191                     dy = 0
4192                 elif abs(dx) > abs(dy):
4193                     dy = dy / abs(dy) * abs(dx)
4194                 else:
4195                     dx = dx / abs(dx) * abs(dy)
4196             return dx, dy
4197 
4198         p = self._pan_start
4199         dx = x - p.x
4200         dy = y - p.y
4201         if dx == dy == 0:
4202             return
4203         if button == 1:
4204             dx, dy = format_deltas(key, dx, dy)
4205             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4206         elif button == 3:
4207             try:
4208                 dx = -dx / self.bbox.width
4209                 dy = -dy / self.bbox.height
4210                 dx, dy = format_deltas(key, dx, dy)
4211                 if self.get_aspect() != 'auto':
4212                     dx = dy = 0.5 * (dx + dy)
4213                 alpha = np.power(10.0, (dx, dy))
4214                 start = np.array([p.x, p.y])
4215                 oldpoints = p.lim.transformed(p.trans)
4216                 newpoints = start + alpha * (oldpoints - start)
4217                 result = (mtransforms.Bbox(newpoints)
4218                           .transformed(p.trans_inverse))
4219             except OverflowError:
4220                 _api.warn_external('Overflow while panning')
4221                 return
4222         else:
4223             return
4224 
4225         valid = np.isfinite(result.transformed(p.trans))
4226         points = result.get_points().astype(object)
4227         # Just ignore invalid limits (typically, underflow in log-scale).
4228         points[~valid] = None
4229         return points
4230 
4231     def drag_pan(self, button, key, x, y):
4232         """
4233         Called when the mouse moves during a pan operation.
4234 
4235         Parameters
4236         ----------
4237         button : `.MouseButton`
4238             The pressed mouse button.
4239         key : str or None
4240             The pressed key, if any.
4241         x, y : float
4242             The mouse coordinates in display coords.
4243 
4244         Notes
4245         -----
4246         This is intended to be overridden by new projection types.
4247         """
4248         points = self._get_pan_points(button, key, x, y)
4249         if points is not None:
4250             self.set_xlim(points[:, 0])
4251             self.set_ylim(points[:, 1])
4252 
4253     def get_children(self):
4254         # docstring inherited.
4255         return [
4256             *self._children,
4257             *self.spines.values(),
4258             *self._axis_map.values(),
4259             self.title, self._left_title, self._right_title,
4260             *self.child_axes,
4261             *([self.legend_] if self.legend_ is not None else []),
4262             self.patch,
4263         ]
4264 
4265     def contains(self, mouseevent):
4266         # docstring inherited.
4267         return self.patch.contains(mouseevent)
4268 
4269     def contains_point(self, point):
4270         """
4271         Return whether *point* (pair of pixel coordinates) is inside the Axes
4272         patch.
4273         """
4274         return self.patch.contains_point(point, radius=1.0)
4275 
4276     def get_default_bbox_extra_artists(self):
4277         """
4278         Return a default list of artists that are used for the bounding box
4279         calculation.
4280 
4281         Artists are excluded either by not being visible or
4282         ``artist.set_in_layout(False)``.
4283         """
4284 
4285         artists = self.get_children()
4286 
4287         for axis in self._axis_map.values():
4288             # axis tight bboxes are calculated separately inside
4289             # Axes.get_tightbbox() using for_layout_only=True
4290             artists.remove(axis)
4291         if not (self.axison and self._frameon):
4292             # don't do bbox on spines if frame not on.
4293             for spine in self.spines.values():
4294                 artists.remove(spine)
4295 
4296         artists.remove(self.title)
4297         artists.remove(self._left_title)
4298         artists.remove(self._right_title)
4299 
4300         # always include types that do not internally implement clipping
4301         # to Axes. may have clip_on set to True and clip_box equivalent
4302         # to ax.bbox but then ignore these properties during draws.
4303         noclip = (_AxesBase, maxis.Axis,
4304                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4305         return [a for a in artists if a.get_visible() and a.get_in_layout()
4306                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4307 
4308     @_api.make_keyword_only("3.8", "call_axes_locator")
4309     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4310                       bbox_extra_artists=None, *, for_layout_only=False):
4311         """
4312         Return the tight bounding box of the Axes, including axis and their
4313         decorators (xlabel, title, etc).
4314 
4315         Artists that have ``artist.set_in_layout(False)`` are not included
4316         in the bbox.
4317 
4318         Parameters
4319         ----------
4320         renderer : `.RendererBase` subclass
4321             renderer that will be used to draw the figures (i.e.
4322             ``fig.canvas.get_renderer()``)
4323 
4324         bbox_extra_artists : list of `.Artist` or ``None``
4325             List of artists to include in the tight bounding box.  If
4326             ``None`` (default), then all artist children of the Axes are
4327             included in the tight bounding box.
4328 
4329         call_axes_locator : bool, default: True
4330             If *call_axes_locator* is ``False``, it does not call the
4331             ``_axes_locator`` attribute, which is necessary to get the correct
4332             bounding box. ``call_axes_locator=False`` can be used if the
4333             caller is only interested in the relative size of the tightbbox
4334             compared to the Axes bbox.
4335 
4336         for_layout_only : default: False
4337             The bounding box will *not* include the x-extent of the title and
4338             the xlabel, or the y-extent of the ylabel.
4339 
4340         Returns
4341         -------
4342         `.BboxBase`
4343             Bounding box in figure pixel coordinates.
4344 
4345         See Also
4346         --------
4347         matplotlib.axes.Axes.get_window_extent
4348         matplotlib.axis.Axis.get_tightbbox
4349         matplotlib.spines.Spine.get_window_extent
4350         """
4351 
4352         bb = []
4353         if renderer is None:
4354             renderer = self.figure._get_renderer()
4355 
4356         if not self.get_visible():
4357             return None
4358 
4359         locator = self.get_axes_locator()
4360         self.apply_aspect(
4361             locator(self, renderer) if locator and call_axes_locator else None)
4362 
4363         for axis in self._axis_map.values():
4364             if self.axison and axis.get_visible():
4365                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4366                 if ba:
4367                     bb.append(ba)
4368         self._update_title_position(renderer)
4369         axbbox = self.get_window_extent(renderer)
4370         bb.append(axbbox)
4371 
4372         for title in [self.title, self._left_title, self._right_title]:
4373             if title.get_visible():
4374                 bt = title.get_window_extent(renderer)
4375                 if for_layout_only and bt.width > 0:
4376                     # make the title bbox 1 pixel wide so its width
4377                     # is not accounted for in bbox calculations in
4378                     # tight/constrained_layout
4379                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4380                     bt.x1 = bt.x0 + 1.0
4381                 bb.append(bt)
4382 
4383         bbox_artists = bbox_extra_artists
4384         if bbox_artists is None:
4385             bbox_artists = self.get_default_bbox_extra_artists()
4386 
4387         for a in bbox_artists:
4388             bbox = a.get_tightbbox(renderer)
4389             if (bbox is not None
4390                     and 0 < bbox.width < np.inf
4391                     and 0 < bbox.height < np.inf):
4392                 bb.append(bbox)
4393         return mtransforms.Bbox.union(
4394             [b for b in bb if b.width != 0 or b.height != 0])
4395 
4396     def _make_twin_axes(self, *args, **kwargs):
4397         """Make a twinx Axes of self. This is used for twinx and twiny."""
4398         if 'sharex' in kwargs and 'sharey' in kwargs:
4399             # The following line is added in v2.2 to avoid breaking Seaborn,
4400             # which currently uses this internal API.
4401             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4402                 raise ValueError("Twinned Axes may share only one axis")
4403         ss = self.get_subplotspec()
4404         if ss:
4405             twin = self.figure.add_subplot(ss, *args, **kwargs)
4406         else:
4407             twin = self.figure.add_axes(
4408                 self.get_position(True), *args, **kwargs,
4409                 axes_locator=_TransformedBoundsLocator(
4410                     [0, 0, 1, 1], self.transAxes))
4411         self.set_adjustable('datalim')
4412         twin.set_adjustable('datalim')
4413         self._twinned_axes.join(self, twin)
4414         return twin
4415 
4416     def twinx(self):
4417         """
4418         Create a twin Axes sharing the xaxis.
4419 
4420         Create a new Axes with an invisible x-axis and an independent
4421         y-axis positioned opposite to the original one (i.e. at right). The
4422         x-axis autoscale setting will be inherited from the original
4423         Axes.  To ensure that the tick marks of both y-axes align, see
4424         `~matplotlib.ticker.LinearLocator`.
4425 
4426         Returns
4427         -------
4428         Axes
4429             The newly created Axes instance
4430 
4431         Notes
4432         -----
4433         For those who are 'picking' artists while using twinx, pick
4434         events are only called for the artists in the top-most Axes.
4435         """
4436         ax2 = self._make_twin_axes(sharex=self)
4437         ax2.yaxis.tick_right()
4438         ax2.yaxis.set_label_position('right')
4439         ax2.yaxis.set_offset_position('right')
4440         ax2.set_autoscalex_on(self.get_autoscalex_on())
4441         self.yaxis.tick_left()
4442         ax2.xaxis.set_visible(False)
4443         ax2.patch.set_visible(False)
4444         ax2.xaxis.units = self.xaxis.units
4445         return ax2
4446 
4447     def twiny(self):
4448         """
4449         Create a twin Axes sharing the yaxis.
4450 
4451         Create a new Axes with an invisible y-axis and an independent
4452         x-axis positioned opposite to the original one (i.e. at top). The
4453         y-axis autoscale setting will be inherited from the original Axes.
4454         To ensure that the tick marks of both x-axes align, see
4455         `~matplotlib.ticker.LinearLocator`.
4456 
4457         Returns
4458         -------
4459         Axes
4460             The newly created Axes instance
4461 
4462         Notes
4463         -----
4464         For those who are 'picking' artists while using twiny, pick
4465         events are only called for the artists in the top-most Axes.
4466         """
4467         ax2 = self._make_twin_axes(sharey=self)
4468         ax2.xaxis.tick_top()
4469         ax2.xaxis.set_label_position('top')
4470         ax2.set_autoscaley_on(self.get_autoscaley_on())
4471         self.xaxis.tick_bottom()
4472         ax2.yaxis.set_visible(False)
4473         ax2.patch.set_visible(False)
4474         ax2.yaxis.units = self.yaxis.units
4475         return ax2
4476 
4477     def get_shared_x_axes(self):
4478         """Return an immutable view on the shared x-axes Grouper."""
4479         return cbook.GrouperView(self._shared_axes["x"])
4480 
4481     def get_shared_y_axes(self):
4482         """Return an immutable view on the shared y-axes Grouper."""
4483         return cbook.GrouperView(self._shared_axes["y"])
4484 
4485     def label_outer(self):
4486         """
4487         Only show "outer" labels and tick labels.
4488 
4489         x-labels are only kept for subplots on the last row (or first row, if
4490         labels are on the top side); y-labels only for subplots on the first
4491         column (or last column, if labels are on the right side).
4492         """
4493         self._label_outer_xaxis(check_patch=False)
4494         self._label_outer_yaxis(check_patch=False)
4495 
4496     def _label_outer_xaxis(self, *, check_patch):
4497         # see documentation in label_outer.
4498         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4499             return
4500         ss = self.get_subplotspec()
4501         if not ss:
4502             return
4503         label_position = self.xaxis.get_label_position()
4504         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4505             if label_position == "top":
4506                 self.set_xlabel("")
4507             self.xaxis.set_tick_params(which="both", labeltop=False)
4508             if self.xaxis.offsetText.get_position()[1] == 1:
4509                 self.xaxis.offsetText.set_visible(False)
4510         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4511             if label_position == "bottom":
4512                 self.set_xlabel("")
4513             self.xaxis.set_tick_params(which="both", labelbottom=False)
4514             if self.xaxis.offsetText.get_position()[1] == 0:
4515                 self.xaxis.offsetText.set_visible(False)
4516 
4517     def _label_outer_yaxis(self, *, check_patch):
4518         # see documentation in label_outer.
4519         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4520             return
4521         ss = self.get_subplotspec()
4522         if not ss:
4523             return
4524         label_position = self.yaxis.get_label_position()
4525         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4526             if label_position == "left":
4527                 self.set_ylabel("")
4528             self.yaxis.set_tick_params(which="both", labelleft=False)
4529             if self.yaxis.offsetText.get_position()[0] == 0:
4530                 self.yaxis.offsetText.set_visible(False)
4531         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4532             if label_position == "right":
4533                 self.set_ylabel("")
4534             self.yaxis.set_tick_params(which="both", labelright=False)
4535             if self.yaxis.offsetText.get_position()[0] == 1:
4536                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:51:45.202 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:51:45.203 | INFO     | Search-only: skipping patch selection
2025-10-15 07:51:45.374 | INFO     | Task matplotlib__matplotlib-26122 completed successfully.
2025-10-15 07:51:45.375 | INFO     | No patch generated. You can try running ACR again.
