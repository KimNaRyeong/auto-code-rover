[
    {
        "rel_file_path": "seaborn/axisgrid.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/axisgrid.py",
        "start": 1320,
        "end": 1335,
        "class_name": "PairGrid",
        "method_name": "map",
        "code": "1320     def map(self, func, **kwargs):\n1321         \"\"\"Plot with the same function in every subplot.\n1322 \n1323         Parameters\n1324         ----------\n1325         func : callable plotting function\n1326             Must take x, y arrays as positional arguments and draw onto the\n1327             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1328             called ``color`` and  ``label``.\n1329 \n1330         \"\"\"\n1331         row_indices, col_indices = np.indices(self.axes.shape)\n1332         indices = zip(row_indices.flat, col_indices.flat)\n1333         self._map_bivariate(func, indices, **kwargs)\n1334 \n1335         return self\n",
        "intended_behavior": "The `map` method should correctly handle the `hue` parameter regardless if it is numeric, categorical, or a DataFrame column. The method should ensure that the `hue` parameter passed to the plotting functions (like `scatterplot` or `regplot`) is processed in such a manner that it does not raise KeyError or TypeError when categorical data is used. This might involve validating or transforming the `hue` data before it is utilized by the plotting functions or ensuring that seaborn's internal mechanisms for handling hues (e.g., normalization, lookup) are compatible with how `map` is invoking those functions."
    },
    {
        "rel_file_path": "seaborn/axisgrid.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/axisgrid.py",
        "start": 1124,
        "end": 1635,
        "class_name": "PairGrid",
        "method_name": null,
        "code": "1124 class PairGrid(Grid):\n1125     \"\"\"Subplot grid for plotting pairwise relationships in a dataset.\n1126 \n1127     This object maps each variable in a dataset onto a column and row in a\n1128     grid of multiple axes. Different axes-level plotting functions can be\n1129     used to draw bivariate plots in the upper and lower triangles, and the\n1130     the marginal distribution of each variable can be shown on the diagonal.\n1131 \n1132     Several different common plots can be generated in a single line using\n1133     :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.\n1134 \n1135     See the :ref:`tutorial <grid_tutorial>` for more information.\n1136 \n1137     \"\"\"\n1138     def __init__(\n1139         self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,\n1140         hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,\n1141         height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False, size=None\n1142     ):\n1143         \"\"\"Initialize the plot figure and PairGrid object.\n1144 \n1145         Parameters\n1146         ----------\n1147         data : DataFrame\n1148             Tidy (long-form) dataframe where each column is a variable and\n1149             each row is an observation.\n1150         hue : string (variable name)\n1151             Variable in ``data`` to map plot aspects to different colors. This\n1152             variable will be excluded from the default x and y variables.\n1153         vars : list of variable names\n1154             Variables within ``data`` to use, otherwise use every column with\n1155             a numeric datatype.\n1156         {x, y}_vars : lists of variable names\n1157             Variables within ``data`` to use separately for the rows and\n1158             columns of the figure; i.e. to make a non-square plot.\n1159         hue_order : list of strings\n1160             Order for the levels of the hue variable in the palette\n1161         palette : dict or seaborn color palette\n1162             Set of colors for mapping the ``hue`` variable. If a dict, keys\n1163             should be values  in the ``hue`` variable.\n1164         hue_kws : dictionary of param -> list of values mapping\n1165             Other keyword arguments to insert into the plotting call to let\n1166             other plot attributes vary across levels of the hue variable (e.g.\n1167             the markers in a scatterplot).\n1168         corner : bool\n1169             If True, don't add axes to the upper (off-diagonal) triangle of the\n1170             grid, making this a \"corner\" plot.\n1171         height : scalar\n1172             Height (in inches) of each facet.\n1173         aspect : scalar\n1174             Aspect * height gives the width (in inches) of each facet.\n1175         layout_pad : scalar\n1176             Padding between axes; passed to ``fig.tight_layout``.\n1177         despine : boolean\n1178             Remove the top and right spines from the plots.\n1179         dropna : boolean\n1180             Drop missing values from the data before plotting.\n1181 \n1182         See Also\n1183         --------\n1184         pairplot : Easily drawing common uses of :class:`PairGrid`.\n1185         FacetGrid : Subplot grid for plotting conditional relationships.\n1186 \n1187         Examples\n1188         --------\n1189 \n1190         .. include:: ../docstrings/PairGrid.rst\n1191 \n1192         \"\"\"\n1193 \n1194         super().__init__()\n1195 \n1196         # Handle deprecations\n1197         if size is not None:\n1198             height = size\n1199             msg = (\"The `size` parameter has been renamed to `height`; \"\n1200                    \"please update your code.\")\n1201             warnings.warn(UserWarning(msg))\n1202 \n1203         # Sort out the variables that define the grid\n1204         numeric_cols = self._find_numeric_cols(data)\n1205         if hue in numeric_cols:\n1206             numeric_cols.remove(hue)\n1207         if vars is not None:\n1208             x_vars = list(vars)\n1209             y_vars = list(vars)\n1210         if x_vars is None:\n1211             x_vars = numeric_cols\n1212         if y_vars is None:\n1213             y_vars = numeric_cols\n1214 \n1215         if np.isscalar(x_vars):\n1216             x_vars = [x_vars]\n1217         if np.isscalar(y_vars):\n1218             y_vars = [y_vars]\n1219 \n1220         self.x_vars = x_vars = list(x_vars)\n1221         self.y_vars = y_vars = list(y_vars)\n1222         self.square_grid = self.x_vars == self.y_vars\n1223 \n1224         if not x_vars:\n1225             raise ValueError(\"No variables found for grid columns.\")\n1226         if not y_vars:\n1227             raise ValueError(\"No variables found for grid rows.\")\n1228 \n1229         # Create the figure and the array of subplots\n1230         figsize = len(x_vars) * height * aspect, len(y_vars) * height\n1231 \n1232         # Disable autolayout so legend_out works\n1233         with mpl.rc_context({\"figure.autolayout\": False}):\n1234             fig = plt.figure(figsize=figsize)\n1235 \n1236         axes = fig.subplots(len(y_vars), len(x_vars),\n1237                             sharex=\"col\", sharey=\"row\",\n1238                             squeeze=False)\n1239 \n1240         # Possibly remove upper axes to make a corner grid\n1241         # Note: setting up the axes is usually the most time-intensive part\n1242         # of using the PairGrid. We are foregoing the speed improvement that\n1243         # we would get by just not setting up the hidden axes so that we can\n1244         # avoid implementing fig.subplots ourselves. But worth thinking about.\n1245         self._corner = corner\n1246         if corner:\n1247             hide_indices = np.triu_indices_from(axes, 1)\n1248             for i, j in zip(*hide_indices):\n1249                 axes[i, j].remove()\n1250                 axes[i, j] = None\n1251 \n1252         self._figure = fig\n1253         self.axes = axes\n1254         self.data = data\n1255 \n1256         # Save what we are going to do with the diagonal\n1257         self.diag_sharey = diag_sharey\n1258         self.diag_vars = None\n1259         self.diag_axes = None\n1260 \n1261         self._dropna = dropna\n1262 \n1263         # Label the axes\n1264         self._add_axis_labels()\n1265 \n1266         # Sort out the hue variable\n1267         self._hue_var = hue\n1268         if hue is None:\n1269             self.hue_names = hue_order = [\"_nolegend_\"]\n1270             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n1271                                       index=data.index)\n1272         else:\n1273             # We need hue_order and hue_names because the former is used to control\n1274             # the order of drawing and the latter is used to control the order of\n1275             # the legend. hue_names can become string-typed while hue_order must\n1276             # retain the type of the input data. This is messy but results from\n1277             # the fact that PairGrid can implement the hue-mapping logic itself\n1278             # (and was originally written exclusively that way) but now can delegate\n1279             # to the axes-level functions, while always handling legend creation.\n1280             # See GH2307\n1281             hue_names = hue_order = categorical_order(data[hue], hue_order)\n1282             if dropna:\n1283                 # Filter NA from the list of unique hue names\n1284                 hue_names = list(filter(pd.notnull, hue_names))\n1285             self.hue_names = hue_names\n1286             self.hue_vals = data[hue]\n1287 \n1288         # Additional dict of kwarg -> list of values for mapping the hue var\n1289         self.hue_kws = hue_kws if hue_kws is not None else {}\n1290 \n1291         self._orig_palette = palette\n1292         self._hue_order = hue_order\n1293         self.palette = self._get_palette(data, hue, hue_order, palette)\n1294         self._legend_data = {}\n1295 \n1296         # Make the plot look nice\n1297         for ax in axes[:-1, :].flat:\n1298             if ax is None:\n1299                 continue\n1300             for label in ax.get_xticklabels():\n1301                 label.set_visible(False)\n1302             ax.xaxis.offsetText.set_visible(False)\n1303             ax.xaxis.label.set_visible(False)\n1304 \n1305         for ax in axes[:, 1:].flat:\n1306             if ax is None:\n1307                 continue\n1308             for label in ax.get_yticklabels():\n1309                 label.set_visible(False)\n1310             ax.yaxis.offsetText.set_visible(False)\n1311             ax.yaxis.label.set_visible(False)\n1312 \n1313         self._tight_layout_rect = [.01, .01, .99, .99]\n1314         self._tight_layout_pad = layout_pad\n1315         self._despine = despine\n1316         if despine:\n1317             utils.despine(fig=fig)\n1318         self.tight_layout(pad=layout_pad)\n1319 \n1320     def map(self, func, **kwargs):\n1321         \"\"\"Plot with the same function in every subplot.\n1322 \n1323         Parameters\n1324         ----------\n1325         func : callable plotting function\n1326             Must take x, y arrays as positional arguments and draw onto the\n1327             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1328             called ``color`` and  ``label``.\n1329 \n1330         \"\"\"\n1331         row_indices, col_indices = np.indices(self.axes.shape)\n1332         indices = zip(row_indices.flat, col_indices.flat)\n1333         self._map_bivariate(func, indices, **kwargs)\n1334 \n1335         return self\n1336 \n1337     def map_lower(self, func, **kwargs):\n1338         \"\"\"Plot with a bivariate function on the lower diagonal subplots.\n1339 \n1340         Parameters\n1341         ----------\n1342         func : callable plotting function\n1343             Must take x, y arrays as positional arguments and draw onto the\n1344             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1345             called ``color`` and  ``label``.\n1346 \n1347         \"\"\"\n1348         indices = zip(*np.tril_indices_from(self.axes, -1))\n1349         self._map_bivariate(func, indices, **kwargs)\n1350         return self\n1351 \n1352     def map_upper(self, func, **kwargs):\n1353         \"\"\"Plot with a bivariate function on the upper diagonal subplots.\n1354 \n1355         Parameters\n1356         ----------\n1357         func : callable plotting function\n1358             Must take x, y arrays as positional arguments and draw onto the\n1359             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1360             called ``color`` and  ``label``.\n1361 \n1362         \"\"\"\n1363         indices = zip(*np.triu_indices_from(self.axes, 1))\n1364         self._map_bivariate(func, indices, **kwargs)\n1365         return self\n1366 \n1367     def map_offdiag(self, func, **kwargs):\n1368         \"\"\"Plot with a bivariate function on the off-diagonal subplots.\n1369 \n1370         Parameters\n1371         ----------\n1372         func : callable plotting function\n1373             Must take x, y arrays as positional arguments and draw onto the\n1374             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1375             called ``color`` and  ``label``.\n1376 \n1377         \"\"\"\n1378         if self.square_grid:\n1379             self.map_lower(func, **kwargs)\n1380             if not self._corner:\n1381                 self.map_upper(func, **kwargs)\n1382         else:\n1383             indices = []\n1384             for i, (y_var) in enumerate(self.y_vars):\n1385                 for j, (x_var) in enumerate(self.x_vars):\n1386                     if x_var != y_var:\n1387                         indices.append((i, j))\n1388             self._map_bivariate(func, indices, **kwargs)\n1389         return self\n1390 \n1391     def map_diag(self, func, **kwargs):\n1392         \"\"\"Plot with a univariate function on each diagonal subplot.\n1393 \n1394         Parameters\n1395         ----------\n1396         func : callable plotting function\n1397             Must take an x array as a positional argument and draw onto the\n1398             \"currently active\" matplotlib Axes. Also needs to accept kwargs\n1399             called ``color`` and  ``label``.\n1400 \n1401         \"\"\"\n1402         # Add special diagonal axes for the univariate plot\n1403         if self.diag_axes is None:\n1404             diag_vars = []\n1405             diag_axes = []\n1406             for i, y_var in enumerate(self.y_vars):\n1407                 for j, x_var in enumerate(self.x_vars):\n1408                     if x_var == y_var:\n1409 \n1410                         # Make the density axes\n1411                         diag_vars.append(x_var)\n1412                         ax = self.axes[i, j]\n1413                         diag_ax = ax.twinx()\n1414                         diag_ax.set_axis_off()\n1415                         diag_axes.append(diag_ax)\n1416 \n1417                         # Work around matplotlib bug\n1418                         # https://github.com/matplotlib/matplotlib/issues/15188\n1419                         if not plt.rcParams.get(\"ytick.left\", True):\n1420                             for tick in ax.yaxis.majorTicks:\n1421                                 tick.tick1line.set_visible(False)\n1422 \n1423                         # Remove main y axis from density axes in a corner plot\n1424                         if self._corner:\n1425                             ax.yaxis.set_visible(False)\n1426                             if self._despine:\n1427                                 utils.despine(ax=ax, left=True)\n1428                             # TODO add optional density ticks (on the right)\n1429                             # when drawing a corner plot?\n1430 \n1431             if self.diag_sharey and diag_axes:\n1432                 # This may change in future matplotlibs\n1433                 # See https://github.com/matplotlib/matplotlib/pull/9923\n1434                 group = diag_axes[0].get_shared_y_axes()\n1435                 for ax in diag_axes[1:]:\n1436                     group.join(ax, diag_axes[0])\n1437 \n1438             self.diag_vars = np.array(diag_vars, np.object_)\n1439             self.diag_axes = np.array(diag_axes, np.object_)\n1440 \n1441         if \"hue\" not in signature(func).parameters:\n1442             return self._map_diag_iter_hue(func, **kwargs)\n1443 \n1444         # Loop over diagonal variables and axes, making one plot in each\n1445         for var, ax in zip(self.diag_vars, self.diag_axes):\n1446 \n1447             plot_kwargs = kwargs.copy()\n1448             if str(func.__module__).startswith(\"seaborn\"):\n1449                 plot_kwargs[\"ax\"] = ax\n1450             else:\n1451                 plt.sca(ax)\n1452 \n1453             vector = self.data[var]\n1454             if self._hue_var is not None:\n1455                 hue = self.data[self._hue_var]\n1456             else:\n1457                 hue = None\n1458 \n1459             if self._dropna:\n1460                 not_na = vector.notna()\n1461                 if hue is not None:\n1462                     not_na &= hue.notna()\n1463                 vector = vector[not_na]\n1464                 if hue is not None:\n1465                     hue = hue[not_na]\n1466 \n1467             plot_kwargs.setdefault(\"hue\", hue)\n1468             plot_kwargs.setdefault(\"hue_order\", self._hue_order)\n1469             plot_kwargs.setdefault(\"palette\", self._orig_palette)\n1470             func(x=vector, **plot_kwargs)\n1471             ax.legend_ = None\n1472 \n1473         self._add_axis_labels()\n1474         return self\n1475 \n1476     def _map_diag_iter_hue(self, func, **kwargs):\n1477         \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"\n1478         # Plot on each of the diagonal axes\n1479         fixed_color = kwargs.pop(\"color\", None)\n1480 \n1481         for var, ax in zip(self.diag_vars, self.diag_axes):\n1482             hue_grouped = self.data[var].groupby(self.hue_vals)\n1483 \n1484             plot_kwargs = kwargs.copy()\n1485             if str(func.__module__).startswith(\"seaborn\"):\n1486                 plot_kwargs[\"ax\"] = ax\n1487             else:\n1488                 plt.sca(ax)\n1489 \n1490             for k, label_k in enumerate(self._hue_order):\n1491 \n1492                 # Attempt to get data for this level, allowing for empty\n1493                 try:\n1494                     data_k = hue_grouped.get_group(label_k)\n1495                 except KeyError:\n1496                     data_k = pd.Series([], dtype=float)\n1497 \n1498                 if fixed_color is None:\n1499                     color = self.palette[k]\n1500                 else:\n1501                     color = fixed_color\n1502 \n1503                 if self._dropna:\n1504                     data_k = utils.remove_na(data_k)\n1505 \n1506                 if str(func.__module__).startswith(\"seaborn\"):\n1507                     func(x=data_k, label=label_k, color=color, **plot_kwargs)\n1508                 else:\n1509                     func(data_k, label=label_k, color=color, **plot_kwargs)\n1510 \n1511         self._add_axis_labels()\n1512 \n1513         return self\n1514 \n1515     def _map_bivariate(self, func, indices, **kwargs):\n1516         \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"\n1517         # This is a hack to handle the fact that new distribution plots don't add\n1518         # their artists onto the axes. This is probably superior in general, but\n1519         # we'll need a better way to handle it in the axisgrid functions.\n1520         from .distributions import histplot, kdeplot\n1521         if func is histplot or func is kdeplot:\n1522             self._extract_legend_handles = True\n1523 \n1524         kws = kwargs.copy()  # Use copy as we insert other kwargs\n1525         for i, j in indices:\n1526             x_var = self.x_vars[j]\n1527             y_var = self.y_vars[i]\n1528             ax = self.axes[i, j]\n1529             if ax is None:  # i.e. we are in corner mode\n1530                 continue\n1531             self._plot_bivariate(x_var, y_var, ax, func, **kws)\n1532         self._add_axis_labels()\n1533 \n1534         if \"hue\" in signature(func).parameters:\n1535             self.hue_names = list(self._legend_data)\n1536 \n1537     def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):\n1538         \"\"\"Draw a bivariate plot on the specified axes.\"\"\"\n1539         if \"hue\" not in signature(func).parameters:\n1540             self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)\n1541             return\n1542 \n1543         kwargs = kwargs.copy()\n1544         if str(func.__module__).startswith(\"seaborn\"):\n1545             kwargs[\"ax\"] = ax\n1546         else:\n1547             plt.sca(ax)\n1548 \n1549         if x_var == y_var:\n1550             axes_vars = [x_var]\n1551         else:\n1552             axes_vars = [x_var, y_var]\n1553 \n1554         if self._hue_var is not None and self._hue_var not in axes_vars:\n1555             axes_vars.append(self._hue_var)\n1556 \n1557         data = self.data[axes_vars]\n1558         if self._dropna:\n1559             data = data.dropna()\n1560 \n1561         x = data[x_var]\n1562         y = data[y_var]\n1563         if self._hue_var is None:\n1564             hue = None\n1565         else:\n1566             hue = data.get(self._hue_var)\n1567 \n1568         if \"hue\" not in kwargs:\n1569             kwargs.update({\n1570                 \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,\n1571             })\n1572         func(x=x, y=y, **kwargs)\n1573 \n1574         self._update_legend_data(ax)\n1575 \n1576     def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):\n1577         \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"\n1578         kwargs = kwargs.copy()\n1579         if str(func.__module__).startswith(\"seaborn\"):\n1580             kwargs[\"ax\"] = ax\n1581         else:\n1582             plt.sca(ax)\n1583 \n1584         if x_var == y_var:\n1585             axes_vars = [x_var]\n1586         else:\n1587             axes_vars = [x_var, y_var]\n1588 \n1589         hue_grouped = self.data.groupby(self.hue_vals)\n1590         for k, label_k in enumerate(self._hue_order):\n1591 \n1592             kws = kwargs.copy()\n1593 \n1594             # Attempt to get data for this level, allowing for empty\n1595             try:\n1596                 data_k = hue_grouped.get_group(label_k)\n1597             except KeyError:\n1598                 data_k = pd.DataFrame(columns=axes_vars,\n1599                                       dtype=float)\n1600 \n1601             if self._dropna:\n1602                 data_k = data_k[axes_vars].dropna()\n1603 \n1604             x = data_k[x_var]\n1605             y = data_k[y_var]\n1606 \n1607             for kw, val_list in self.hue_kws.items():\n1608                 kws[kw] = val_list[k]\n1609             kws.setdefault(\"color\", self.palette[k])\n1610             if self._hue_var is not None:\n1611                 kws[\"label\"] = label_k\n1612 \n1613             if str(func.__module__).startswith(\"seaborn\"):\n1614                 func(x=x, y=y, **kws)\n1615             else:\n1616                 func(x, y, **kws)\n1617 \n1618         self._update_legend_data(ax)\n1619 \n1620     def _add_axis_labels(self):\n1621         \"\"\"Add labels to the left and bottom Axes.\"\"\"\n1622         for ax, label in zip(self.axes[-1, :], self.x_vars):\n1623             ax.set_xlabel(label)\n1624         for ax, label in zip(self.axes[:, 0], self.y_vars):\n1625             ax.set_ylabel(label)\n1626         if self._corner:\n1627             self.axes[0, 0].set_ylabel(\"\")\n1628 \n1629     def _find_numeric_cols(self, data):\n1630         \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n1631         numeric_cols = []\n1632         for col in data:\n1633             if variable_type(data[col]) == \"numeric\":\n1634                 numeric_cols.append(col)\n1635         return numeric_cols\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "seaborn/relational.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/relational.py",
        "start": 1,
        "end": 1095,
        "class_name": null,
        "method_name": null,
        "code": "1 import warnings\n2 \n3 import numpy as np\n4 import pandas as pd\n5 import matplotlib as mpl\n6 import matplotlib.pyplot as plt\n7 \n8 from ._oldcore import (\n9     VectorPlotter,\n10 )\n11 from .utils import (\n12     locator_to_legend_entries,\n13     adjust_legend_subtitles,\n14     _default_color,\n15     _deprecate_ci,\n16 )\n17 from ._statistics import EstimateAggregator\n18 from .axisgrid import FacetGrid, _facet_docs\n19 from ._docstrings import DocstringComponents, _core_docs\n20 \n21 \n22 __all__ = [\"relplot\", \"scatterplot\", \"lineplot\"]\n23 \n24 \n25 _relational_narrative = DocstringComponents(dict(\n26 \n27     # ---  Introductory prose\n28     main_api=\"\"\"\n29 The relationship between ``x`` and ``y`` can be shown for different subsets\n30 of the data using the ``hue``, ``size``, and ``style`` parameters. These\n31 parameters control what visual semantics are used to identify the different\n32 subsets. It is possible to show up to three dimensions independently by\n33 using all three semantic types, but this style of plot can be hard to\n34 interpret and is often ineffective. Using redundant semantics (i.e. both\n35 ``hue`` and ``style`` for the same variable) can be helpful for making\n36 graphics more accessible.\n37 \n38 See the :ref:`tutorial <relational_tutorial>` for more information.\n39     \"\"\",\n40 \n41     relational_semantic=\"\"\"\n42 The default treatment of the ``hue`` (and to a lesser extent, ``size``)\n43 semantic, if present, depends on whether the variable is inferred to\n44 represent \"numeric\" or \"categorical\" data. In particular, numeric variables\n45 are represented with a sequential colormap by default, and the legend\n46 entries show regular \"ticks\" with values that may or may not exist in the\n47 data. This behavior can be controlled through various parameters, as\n48 described and illustrated below.\n49     \"\"\",\n50 ))\n51 \n52 _relational_docs = dict(\n53 \n54     # --- Shared function parameters\n55     data_vars=\"\"\"\n56 x, y : names of variables in ``data`` or vector data\n57     Input data variables; must be numeric. Can pass data directly or\n58     reference columns in ``data``.\n59     \"\"\",\n60     data=\"\"\"\n61 data : DataFrame, array, or list of arrays\n62     Input data structure. If ``x`` and ``y`` are specified as names, this\n63     should be a \"long-form\" DataFrame containing those columns. Otherwise\n64     it is treated as \"wide-form\" data and grouping variables are ignored.\n65     See the examples for the various ways this parameter can be specified\n66     and the different effects of each.\n67     \"\"\",\n68     palette=\"\"\"\n69 palette : string, list, dict, or matplotlib colormap\n70     An object that determines how colors are chosen when ``hue`` is used.\n71     It can be the name of a seaborn palette or matplotlib colormap, a list\n72     of colors (anything matplotlib understands), a dict mapping levels\n73     of the ``hue`` variable to colors, or a matplotlib colormap object.\n74     \"\"\",\n75     hue_order=\"\"\"\n76 hue_order : list\n77     Specified order for the appearance of the ``hue`` variable levels,\n78     otherwise they are determined from the data. Not relevant when the\n79     ``hue`` variable is numeric.\n80     \"\"\",\n81     hue_norm=\"\"\"\n82 hue_norm : tuple or :class:`matplotlib.colors.Normalize` object\n83     Normalization in data units for colormap applied to the ``hue``\n84     variable when it is numeric. Not relevant if it is categorical.\n85     \"\"\",\n86     sizes=\"\"\"\n87 sizes : list, dict, or tuple\n88     An object that determines how sizes are chosen when ``size`` is used.\n89     It can always be a list of size values or a dict mapping levels of the\n90     ``size`` variable to sizes. When ``size``  is numeric, it can also be\n91     a tuple specifying the minimum and maximum size to use such that other\n92     values are normalized within this range.\n93     \"\"\",\n94     size_order=\"\"\"\n95 size_order : list\n96     Specified order for appearance of the ``size`` variable levels,\n97     otherwise they are determined from the data. Not relevant when the\n98     ``size`` variable is numeric.\n99     \"\"\",\n100     size_norm=\"\"\"\n101 size_norm : tuple or Normalize object\n102     Normalization in data units for scaling plot objects when the\n103     ``size`` variable is numeric.\n104     \"\"\",\n105     dashes=\"\"\"\n106 dashes : boolean, list, or dictionary\n107     Object determining how to draw the lines for different levels of the\n108     ``style`` variable. Setting to ``True`` will use default dash codes, or\n109     you can pass a list of dash codes or a dictionary mapping levels of the\n110     ``style`` variable to dash codes. Setting to ``False`` will use solid\n111     lines for all subsets. Dashes are specified as in matplotlib: a tuple\n112     of ``(segment, gap)`` lengths, or an empty string to draw a solid line.\n113     \"\"\",\n114     markers=\"\"\"\n115 markers : boolean, list, or dictionary\n116     Object determining how to draw the markers for different levels of the\n117     ``style`` variable. Setting to ``True`` will use default markers, or\n118     you can pass a list of markers or a dictionary mapping levels of the\n119     ``style`` variable to markers. Setting to ``False`` will draw\n120     marker-less lines.  Markers are specified as in matplotlib.\n121     \"\"\",\n122     style_order=\"\"\"\n123 style_order : list\n124     Specified order for appearance of the ``style`` variable levels\n125     otherwise they are determined from the data. Not relevant when the\n126     ``style`` variable is numeric.\n127     \"\"\",\n128     units=\"\"\"\n129 units : vector or key in ``data``\n130     Grouping variable identifying sampling units. When used, a separate\n131     line will be drawn for each unit with appropriate semantics, but no\n132     legend entry will be added. Useful for showing distribution of\n133     experimental replicates when exact identities are not needed.\n134     \"\"\",\n135     estimator=\"\"\"\n136 estimator : name of pandas method or callable or None\n137     Method for aggregating across multiple observations of the ``y``\n138     variable at the same ``x`` level. If ``None``, all observations will\n139     be drawn.\n140     \"\"\",\n141     ci=\"\"\"\n142 ci : int or \"sd\" or None\n143     Size of the confidence interval to draw when aggregating.\n144 \n145     .. deprecated:: 0.12.0\n146         Use the new `errorbar` parameter for more flexibility.\n147 \n148     \"\"\",\n149     n_boot=\"\"\"\n150 n_boot : int\n151     Number of bootstraps to use for computing the confidence interval.\n152     \"\"\",\n153     seed=\"\"\"\n154 seed : int, numpy.random.Generator, or numpy.random.RandomState\n155     Seed or random number generator for reproducible bootstrapping.\n156     \"\"\",\n157     legend=\"\"\"\n158 legend : \"auto\", \"brief\", \"full\", or False\n159     How to draw the legend. If \"brief\", numeric ``hue`` and ``size``\n160     variables will be represented with a sample of evenly spaced values.\n161     If \"full\", every group will get an entry in the legend. If \"auto\",\n162     choose between brief or full representation based on number of levels.\n163     If ``False``, no legend data is added and no legend is drawn.\n164     \"\"\",\n165     ax_in=\"\"\"\n166 ax : matplotlib Axes\n167     Axes object to draw the plot onto, otherwise uses the current Axes.\n168     \"\"\",\n169     ax_out=\"\"\"\n170 ax : matplotlib Axes\n171     Returns the Axes object with the plot drawn onto it.\n172     \"\"\",\n173 \n174 )\n175 \n176 \n177 _param_docs = DocstringComponents.from_nested_components(\n178     core=_core_docs[\"params\"],\n179     facets=DocstringComponents(_facet_docs),\n180     rel=DocstringComponents(_relational_docs),\n181     stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),\n182 )\n183 \n184 \n185 class _RelationalPlotter(VectorPlotter):\n186 \n187     wide_structure = {\n188         \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",\n189     }\n190 \n191     # TODO where best to define default parameters?\n192     sort = True\n193 \n194     def add_legend_data(self, ax):\n195         \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"\n196         verbosity = self.legend\n197         if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:\n198             err = \"`legend` must be 'auto', 'brief', 'full', or a boolean.\"\n199             raise ValueError(err)\n200         elif verbosity is True:\n201             verbosity = \"auto\"\n202 \n203         legend_kwargs = {}\n204         keys = []\n205 \n206         # Assign a legend title if there is only going to be one sub-legend,\n207         # otherwise, subtitles will be inserted into the texts list with an\n208         # invisible handle (which is a hack)\n209         titles = {\n210             title for title in\n211             (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])\n212             if title is not None\n213         }\n214         if len(titles) == 1:\n215             legend_title = titles.pop()\n216         else:\n217             legend_title = \"\"\n218 \n219         title_kws = dict(\n220             visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"\n221         )\n222 \n223         def update(var_name, val_name, **kws):\n224 \n225             key = var_name, val_name\n226             if key in legend_kwargs:\n227                 legend_kwargs[key].update(**kws)\n228             else:\n229                 keys.append(key)\n230 \n231                 legend_kwargs[key] = dict(**kws)\n232 \n233         # Define the maximum number of ticks to use for \"brief\" legends\n234         brief_ticks = 6\n235 \n236         # -- Add a legend for hue semantics\n237         brief_hue = self._hue_map.map_type == \"numeric\" and (\n238             verbosity == \"brief\"\n239             or (verbosity == \"auto\" and len(self._hue_map.levels) > brief_ticks)\n240         )\n241         if brief_hue:\n242             if isinstance(self._hue_map.norm, mpl.colors.LogNorm):\n243                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n244             else:\n245                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n246             limits = min(self._hue_map.levels), max(self._hue_map.levels)\n247             hue_levels, hue_formatted_levels = locator_to_legend_entries(\n248                 locator, limits, self.plot_data[\"hue\"].infer_objects().dtype\n249             )\n250         elif self._hue_map.levels is None:\n251             hue_levels = hue_formatted_levels = []\n252         else:\n253             hue_levels = hue_formatted_levels = self._hue_map.levels\n254 \n255         # Add the hue semantic subtitle\n256         if not legend_title and self.variables.get(\"hue\", None) is not None:\n257             update((self.variables[\"hue\"], \"title\"),\n258                    self.variables[\"hue\"], **title_kws)\n259 \n260         # Add the hue semantic labels\n261         for level, formatted_level in zip(hue_levels, hue_formatted_levels):\n262             if level is not None:\n263                 color = self._hue_map(level)\n264                 update(self.variables[\"hue\"], formatted_level, color=color)\n265 \n266         # -- Add a legend for size semantics\n267         brief_size = self._size_map.map_type == \"numeric\" and (\n268             verbosity == \"brief\"\n269             or (verbosity == \"auto\" and len(self._size_map.levels) > brief_ticks)\n270         )\n271         if brief_size:\n272             # Define how ticks will interpolate between the min/max data values\n273             if isinstance(self._size_map.norm, mpl.colors.LogNorm):\n274                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n275             else:\n276                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n277             # Define the min/max data values\n278             limits = min(self._size_map.levels), max(self._size_map.levels)\n279             size_levels, size_formatted_levels = locator_to_legend_entries(\n280                 locator, limits, self.plot_data[\"size\"].infer_objects().dtype\n281             )\n282         elif self._size_map.levels is None:\n283             size_levels = size_formatted_levels = []\n284         else:\n285             size_levels = size_formatted_levels = self._size_map.levels\n286 \n287         # Add the size semantic subtitle\n288         if not legend_title and self.variables.get(\"size\", None) is not None:\n289             update((self.variables[\"size\"], \"title\"),\n290                    self.variables[\"size\"], **title_kws)\n291 \n292         # Add the size semantic labels\n293         for level, formatted_level in zip(size_levels, size_formatted_levels):\n294             if level is not None:\n295                 size = self._size_map(level)\n296                 update(\n297                     self.variables[\"size\"],\n298                     formatted_level,\n299                     linewidth=size,\n300                     s=size,\n301                 )\n302 \n303         # -- Add a legend for style semantics\n304 \n305         # Add the style semantic title\n306         if not legend_title and self.variables.get(\"style\", None) is not None:\n307             update((self.variables[\"style\"], \"title\"),\n308                    self.variables[\"style\"], **title_kws)\n309 \n310         # Add the style semantic labels\n311         if self._style_map.levels is not None:\n312             for level in self._style_map.levels:\n313                 if level is not None:\n314                     attrs = self._style_map(level)\n315                     update(\n316                         self.variables[\"style\"],\n317                         level,\n318                         marker=attrs.get(\"marker\", \"\"),\n319                         dashes=attrs.get(\"dashes\", \"\"),\n320                     )\n321 \n322         func = getattr(ax, self._legend_func)\n323 \n324         legend_data = {}\n325         legend_order = []\n326 \n327         for key in keys:\n328 \n329             _, label = key\n330             kws = legend_kwargs[key]\n331             kws.setdefault(\"color\", \".2\")\n332             use_kws = {}\n333             for attr in self._legend_attributes + [\"visible\"]:\n334                 if attr in kws:\n335                     use_kws[attr] = kws[attr]\n336             artist = func([], [], label=label, **use_kws)\n337             if self._legend_func == \"plot\":\n338                 artist = artist[0]\n339             legend_data[key] = artist\n340             legend_order.append(key)\n341 \n342         self.legend_title = legend_title\n343         self.legend_data = legend_data\n344         self.legend_order = legend_order\n345 \n346 \n347 class _LinePlotter(_RelationalPlotter):\n348 \n349     _legend_attributes = [\"color\", \"linewidth\", \"marker\", \"dashes\"]\n350     _legend_func = \"plot\"\n351 \n352     def __init__(\n353         self, *,\n354         data=None, variables={},\n355         estimator=None, ci=None, n_boot=None, seed=None,\n356         sort=True, err_style=None, err_kws=None, legend=None,\n357         errorbar=None,\n358     ):\n359 \n360         # TODO this is messy, we want the mapping to be agnostic about\n361         # the kind of plot to draw, but for the time being we need to set\n362         # this information so the SizeMapping can use it\n363         self._default_size_range = (\n364             np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]\n365         )\n366 \n367         super().__init__(data=data, variables=variables)\n368 \n369         self.estimator = estimator\n370         self.errorbar = errorbar\n371         self.ci = ci\n372         self.n_boot = n_boot\n373         self.seed = seed\n374         self.sort = sort\n375         self.err_style = err_style\n376         self.err_kws = {} if err_kws is None else err_kws\n377 \n378         self.legend = legend\n379 \n380     def plot(self, ax, kws):\n381         \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"\n382 \n383         # Draw a test plot, using the passed in kwargs. The goal here is to\n384         # honor both (a) the current state of the plot cycler and (b) the\n385         # specified kwargs on all the lines we will draw, overriding when\n386         # relevant with the data semantics. Note that we won't cycle\n387         # internally; in other words, if ``hue`` is not used, all elements will\n388         # have the same color, but they will have the color that you would have\n389         # gotten from the corresponding matplotlib function, and calling the\n390         # function will advance the axes property cycle.\n391 \n392         kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))\n393         kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))\n394 \n395         # Set default error kwargs\n396         err_kws = self.err_kws.copy()\n397         if self.err_style == \"band\":\n398             err_kws.setdefault(\"alpha\", .2)\n399         elif self.err_style == \"bars\":\n400             pass\n401         elif self.err_style is not None:\n402             err = \"`err_style` must be 'band' or 'bars', not {}\"\n403             raise ValueError(err.format(self.err_style))\n404 \n405         # Initialize the aggregation object\n406         agg = EstimateAggregator(\n407             self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n408         )\n409 \n410         # TODO abstract variable to aggregate over here-ish. Better name?\n411         agg_var = \"y\"\n412         grouper = [\"x\"]\n413 \n414         # TODO How to handle NA? We don't want NA to propagate through to the\n415         # estimate/CI when some values are present, but we would also like\n416         # matplotlib to show \"gaps\" in the line when all values are missing.\n417         # This is straightforward absent aggregation, but complicated with it.\n418         # If we want to use nas, we need to conditionalize dropna in iter_data.\n419 \n420         # Loop over the semantic subsets and add to the plot\n421         grouping_vars = \"hue\", \"size\", \"style\"\n422         for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):\n423 \n424             if self.sort:\n425                 sort_vars = [\"units\", \"x\", \"y\"]\n426                 sort_cols = [var for var in sort_vars if var in self.variables]\n427                 sub_data = sub_data.sort_values(sort_cols)\n428 \n429             if self.estimator is not None:\n430                 if \"units\" in self.variables:\n431                     # TODO eventually relax this constraint\n432                     err = \"estimator must be None when specifying units\"\n433                     raise ValueError(err)\n434                 grouped = sub_data.groupby(grouper, sort=self.sort)\n435                 # Could pass as_index=False instead of reset_index,\n436                 # but that fails on a corner case with older pandas.\n437                 sub_data = grouped.apply(agg, agg_var).reset_index()\n438 \n439             # TODO this is pretty ad hoc ; see GH2409\n440             for var in \"xy\":\n441                 if self._log_scaled(var):\n442                     for col in sub_data.filter(regex=f\"^{var}\"):\n443                         sub_data[col] = np.power(10, sub_data[col])\n444 \n445             # --- Draw the main line(s)\n446 \n447             if \"units\" in self.variables:   # XXX why not add to grouping variables?\n448                 lines = []\n449                 for _, unit_data in sub_data.groupby(\"units\"):\n450                     lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))\n451             else:\n452                 lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)\n453 \n454             for line in lines:\n455 \n456                 if \"hue\" in sub_vars:\n457                     line.set_color(self._hue_map(sub_vars[\"hue\"]))\n458 \n459                 if \"size\" in sub_vars:\n460                     line.set_linewidth(self._size_map(sub_vars[\"size\"]))\n461 \n462                 if \"style\" in sub_vars:\n463                     attributes = self._style_map(sub_vars[\"style\"])\n464                     if \"dashes\" in attributes:\n465                         line.set_dashes(attributes[\"dashes\"])\n466                     if \"marker\" in attributes:\n467                         line.set_marker(attributes[\"marker\"])\n468 \n469             line_color = line.get_color()\n470             line_alpha = line.get_alpha()\n471             line_capstyle = line.get_solid_capstyle()\n472 \n473             # --- Draw the confidence intervals\n474 \n475             if self.estimator is not None and self.errorbar is not None:\n476 \n477                 # TODO handling of orientation will need to happen here\n478 \n479                 if self.err_style == \"band\":\n480 \n481                     ax.fill_between(\n482                         sub_data[\"x\"], sub_data[\"ymin\"], sub_data[\"ymax\"],\n483                         color=line_color, **err_kws\n484                     )\n485 \n486                 elif self.err_style == \"bars\":\n487 \n488                     error_deltas = (\n489                         sub_data[\"y\"] - sub_data[\"ymin\"],\n490                         sub_data[\"ymax\"] - sub_data[\"y\"],\n491                     )\n492                     ebars = ax.errorbar(\n493                         sub_data[\"x\"], sub_data[\"y\"], error_deltas,\n494                         linestyle=\"\", color=line_color, alpha=line_alpha,\n495                         **err_kws\n496                     )\n497 \n498                     # Set the capstyle properly on the error bars\n499                     for obj in ebars.get_children():\n500                         if isinstance(obj, mpl.collections.LineCollection):\n501                             obj.set_capstyle(line_capstyle)\n502 \n503         # Finalize the axes details\n504         self._add_axis_labels(ax)\n505         if self.legend:\n506             self.add_legend_data(ax)\n507             handles, _ = ax.get_legend_handles_labels()\n508             if handles:\n509                 legend = ax.legend(title=self.legend_title)\n510                 adjust_legend_subtitles(legend)\n511 \n512 \n513 class _ScatterPlotter(_RelationalPlotter):\n514 \n515     _legend_attributes = [\"color\", \"s\", \"marker\"]\n516     _legend_func = \"scatter\"\n517 \n518     def __init__(\n519         self, *,\n520         data=None, variables={},\n521         x_bins=None, y_bins=None,\n522         estimator=None, ci=None, n_boot=None,\n523         alpha=None, x_jitter=None, y_jitter=None,\n524         legend=None\n525     ):\n526 \n527         # TODO this is messy, we want the mapping to be agnostic about\n528         # the kind of plot to draw, but for the time being we need to set\n529         # this information so the SizeMapping can use it\n530         self._default_size_range = (\n531             np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])\n532         )\n533 \n534         super().__init__(data=data, variables=variables)\n535 \n536         self.alpha = alpha\n537         self.legend = legend\n538 \n539     def plot(self, ax, kws):\n540 \n541         # --- Determine the visual attributes of the plot\n542 \n543         data = self.plot_data.dropna()\n544         if data.empty:\n545             return\n546 \n547         # Define the vectors of x and y positions\n548         empty = np.full(len(data), np.nan)\n549         x = data.get(\"x\", empty)\n550         y = data.get(\"y\", empty)\n551 \n552         if \"style\" in self.variables:\n553             # Use a representative marker so scatter sets the edgecolor\n554             # properly for line art markers. We currently enforce either\n555             # all or none line art so this works.\n556             example_level = self._style_map.levels[0]\n557             example_marker = self._style_map(example_level, \"marker\")\n558             kws.setdefault(\"marker\", example_marker)\n559 \n560         # Conditionally set the marker edgecolor based on whether the marker is \"filled\"\n561         # See https://github.com/matplotlib/matplotlib/issues/17849 for context\n562         m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))\n563         if not isinstance(m, mpl.markers.MarkerStyle):\n564             # TODO in more recent matplotlib (which?) can pass a MarkerStyle here\n565             m = mpl.markers.MarkerStyle(m)\n566         if m.is_filled():\n567             kws.setdefault(\"edgecolor\", \"w\")\n568 \n569         # TODO this makes it impossible to vary alpha with hue which might\n570         # otherwise be useful? Should we just pass None?\n571         kws[\"alpha\"] = 1 if self.alpha == \"auto\" else self.alpha\n572 \n573         # Draw the scatter plot\n574         points = ax.scatter(x=x, y=y, **kws)\n575 \n576         # Apply the mapping from semantic variables to artist attributes\n577 \n578         if \"hue\" in self.variables:\n579             points.set_facecolors(self._hue_map(data[\"hue\"]))\n580 \n581         if \"size\" in self.variables:\n582             points.set_sizes(self._size_map(data[\"size\"]))\n583 \n584         if \"style\" in self.variables:\n585             p = [self._style_map(val, \"path\") for val in data[\"style\"]]\n586             points.set_paths(p)\n587 \n588         # Apply dependent default attributes\n589 \n590         if \"linewidth\" not in kws:\n591             sizes = points.get_sizes()\n592             points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))\n593 \n594         # Finalize the axes details\n595         self._add_axis_labels(ax)\n596         if self.legend:\n597             self.add_legend_data(ax)\n598             handles, _ = ax.get_legend_handles_labels()\n599             if handles:\n600                 legend = ax.legend(title=self.legend_title)\n601                 adjust_legend_subtitles(legend)\n602 \n603 \n604 def lineplot(\n605     data=None, *,\n606     x=None, y=None, hue=None, size=None, style=None, units=None,\n607     palette=None, hue_order=None, hue_norm=None,\n608     sizes=None, size_order=None, size_norm=None,\n609     dashes=True, markers=None, style_order=None,\n610     estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n611     sort=True, err_style=\"band\", err_kws=None, ci=\"deprecated\",\n612     legend=\"auto\", ax=None, **kwargs\n613 ):\n614 \n615     # Handle deprecation of ci parameter\n616     errorbar = _deprecate_ci(errorbar, ci)\n617 \n618     variables = _LinePlotter.get_semantics(locals())\n619     p = _LinePlotter(\n620         data=data, variables=variables,\n621         estimator=estimator, ci=ci, n_boot=n_boot, seed=seed,\n622         sort=sort, err_style=err_style, err_kws=err_kws, legend=legend,\n623         errorbar=errorbar,\n624     )\n625 \n626     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n627     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n628     p.map_style(markers=markers, dashes=dashes, order=style_order)\n629 \n630     if ax is None:\n631         ax = plt.gca()\n632 \n633     if style is None and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n634         kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n635 \n636     if not p.has_xy_data:\n637         return ax\n638 \n639     p._attach(ax)\n640 \n641     # Other functions have color as an explicit param,\n642     # and we should probably do that here too\n643     color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n644     kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n645 \n646     p.plot(ax, kwargs)\n647     return ax\n648 \n649 \n650 lineplot.__doc__ = \"\"\"\\\n651 Draw a line plot with possibility of several semantic groupings.\n652 \n653 {narrative.main_api}\n654 \n655 {narrative.relational_semantic}\n656 \n657 By default, the plot aggregates over multiple ``y`` values at each value of\n658 ``x`` and shows an estimate of the central tendency and a confidence\n659 interval for that estimate.\n660 \n661 Parameters\n662 ----------\n663 {params.core.data}\n664 {params.core.xy}\n665 hue : vector or key in ``data``\n666     Grouping variable that will produce lines with different colors.\n667     Can be either categorical or numeric, although color mapping will\n668     behave differently in latter case.\n669 size : vector or key in ``data``\n670     Grouping variable that will produce lines with different widths.\n671     Can be either categorical or numeric, although size mapping will\n672     behave differently in latter case.\n673 style : vector or key in ``data``\n674     Grouping variable that will produce lines with different dashes\n675     and/or markers. Can have a numeric dtype but will always be treated\n676     as categorical.\n677 {params.rel.units}\n678 {params.core.palette}\n679 {params.core.hue_order}\n680 {params.core.hue_norm}\n681 {params.rel.sizes}\n682 {params.rel.size_order}\n683 {params.rel.size_norm}\n684 {params.rel.dashes}\n685 {params.rel.markers}\n686 {params.rel.style_order}\n687 {params.rel.estimator}\n688 {params.stat.errorbar}\n689 {params.rel.n_boot}\n690 {params.rel.seed}\n691 sort : boolean\n692     If True, the data will be sorted by the x and y variables, otherwise\n693     lines will connect points in the order they appear in the dataset.\n694 err_style : \"band\" or \"bars\"\n695     Whether to draw the confidence intervals with translucent error bands\n696     or discrete error bars.\n697 err_kws : dict of keyword arguments\n698     Additional parameters to control the aesthetics of the error bars. The\n699     kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`\n700     or :meth:`matplotlib.axes.Axes.errorbar`, depending on ``err_style``.\n701 {params.rel.legend}\n702 {params.rel.ci}\n703 {params.core.ax}\n704 kwargs : key, value mappings\n705     Other keyword arguments are passed down to\n706     :meth:`matplotlib.axes.Axes.plot`.\n707 \n708 Returns\n709 -------\n710 {returns.ax}\n711 \n712 See Also\n713 --------\n714 {seealso.scatterplot}\n715 {seealso.pointplot}\n716 \n717 Examples\n718 --------\n719 \n720 .. include:: ../docstrings/lineplot.rst\n721 \n722 \"\"\".format(\n723     narrative=_relational_narrative,\n724     params=_param_docs,\n725     returns=_core_docs[\"returns\"],\n726     seealso=_core_docs[\"seealso\"],\n727 )\n728 \n729 \n730 def scatterplot(\n731     data=None, *,\n732     x=None, y=None, hue=None, size=None, style=None,\n733     palette=None, hue_order=None, hue_norm=None,\n734     sizes=None, size_order=None, size_norm=None,\n735     markers=True, style_order=None,\n736     x_bins=None, y_bins=None,\n737     units=None, estimator=None, ci=95, n_boot=1000,\n738     alpha=None, x_jitter=None, y_jitter=None,\n739     legend=\"auto\", ax=None,\n740     **kwargs\n741 ):\n742 \n743     variables = _ScatterPlotter.get_semantics(locals())\n744     p = _ScatterPlotter(\n745         data=data, variables=variables,\n746         x_bins=x_bins, y_bins=y_bins,\n747         estimator=estimator, ci=ci, n_boot=n_boot,\n748         alpha=alpha, x_jitter=x_jitter, y_jitter=y_jitter, legend=legend,\n749     )\n750 \n751     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n752     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n753     p.map_style(markers=markers, order=style_order)\n754 \n755     if ax is None:\n756         ax = plt.gca()\n757 \n758     if not p.has_xy_data:\n759         return ax\n760 \n761     p._attach(ax)\n762 \n763     # Other functions have color as an explicit param,\n764     # and we should probably do that here too\n765     color = kwargs.pop(\"color\", None)\n766     kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)\n767 \n768     p.plot(ax, kwargs)\n769 \n770     return ax\n771 \n772 \n773 scatterplot.__doc__ = \"\"\"\\\n774 Draw a scatter plot with possibility of several semantic groupings.\n775 \n776 {narrative.main_api}\n777 \n778 {narrative.relational_semantic}\n779 \n780 Parameters\n781 ----------\n782 {params.core.data}\n783 {params.core.xy}\n784 hue : vector or key in ``data``\n785     Grouping variable that will produce points with different colors.\n786     Can be either categorical or numeric, although color mapping will\n787     behave differently in latter case.\n788 size : vector or key in ``data``\n789     Grouping variable that will produce points with different sizes.\n790     Can be either categorical or numeric, although size mapping will\n791     behave differently in latter case.\n792 style : vector or key in ``data``\n793     Grouping variable that will produce points with different markers.\n794     Can have a numeric dtype but will always be treated as categorical.\n795 {params.core.palette}\n796 {params.core.hue_order}\n797 {params.core.hue_norm}\n798 {params.rel.sizes}\n799 {params.rel.size_order}\n800 {params.rel.size_norm}\n801 {params.rel.markers}\n802 {params.rel.style_order}\n803 {{x,y}}_bins : lists or arrays or functions\n804     *Currently non-functional.*\n805 {params.rel.units}\n806     *Currently non-functional.*\n807 {params.rel.estimator}\n808     *Currently non-functional.*\n809 {params.rel.ci}\n810     *Currently non-functional.*\n811 {params.rel.n_boot}\n812     *Currently non-functional.*\n813 alpha : float\n814     Proportional opacity of the points.\n815 {{x,y}}_jitter : booleans or floats\n816     *Currently non-functional.*\n817 {params.rel.legend}\n818 {params.core.ax}\n819 kwargs : key, value mappings\n820     Other keyword arguments are passed down to\n821     :meth:`matplotlib.axes.Axes.scatter`.\n822 \n823 Returns\n824 -------\n825 {returns.ax}\n826 \n827 See Also\n828 --------\n829 {seealso.lineplot}\n830 {seealso.stripplot}\n831 {seealso.swarmplot}\n832 \n833 Examples\n834 --------\n835 \n836 .. include:: ../docstrings/scatterplot.rst\n837 \n838 \"\"\".format(\n839     narrative=_relational_narrative,\n840     params=_param_docs,\n841     returns=_core_docs[\"returns\"],\n842     seealso=_core_docs[\"seealso\"],\n843 )\n844 \n845 \n846 def relplot(\n847     data=None, *,\n848     x=None, y=None, hue=None, size=None, style=None, units=None,\n849     row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n850     palette=None, hue_order=None, hue_norm=None,\n851     sizes=None, size_order=None, size_norm=None,\n852     markers=None, dashes=None, style_order=None,\n853     legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,\n854     **kwargs\n855 ):\n856 \n857     if kind == \"scatter\":\n858 \n859         plotter = _ScatterPlotter\n860         func = scatterplot\n861         markers = True if markers is None else markers\n862 \n863     elif kind == \"line\":\n864 \n865         plotter = _LinePlotter\n866         func = lineplot\n867         dashes = True if dashes is None else dashes\n868 \n869     else:\n870         err = f\"Plot kind {kind} not recognized\"\n871         raise ValueError(err)\n872 \n873     # Check for attempt to plot onto specific axes and warn\n874     if \"ax\" in kwargs:\n875         msg = (\n876             \"relplot is a figure-level function and does not accept \"\n877             \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")\n878         )\n879         warnings.warn(msg, UserWarning)\n880         kwargs.pop(\"ax\")\n881 \n882     # Use the full dataset to map the semantics\n883     p = plotter(\n884         data=data,\n885         variables=plotter.get_semantics(locals()),\n886         legend=legend,\n887     )\n888     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n889     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n890     p.map_style(markers=markers, dashes=dashes, order=style_order)\n891 \n892     # Extract the semantic mappings\n893     if \"hue\" in p.variables:\n894         palette = p._hue_map.lookup_table\n895         hue_order = p._hue_map.levels\n896         hue_norm = p._hue_map.norm\n897     else:\n898         palette = hue_order = hue_norm = None\n899 \n900     if \"size\" in p.variables:\n901         sizes = p._size_map.lookup_table\n902         size_order = p._size_map.levels\n903         size_norm = p._size_map.norm\n904 \n905     if \"style\" in p.variables:\n906         style_order = p._style_map.levels\n907         if markers:\n908             markers = {k: p._style_map(k, \"marker\") for k in style_order}\n909         else:\n910             markers = None\n911         if dashes:\n912             dashes = {k: p._style_map(k, \"dashes\") for k in style_order}\n913         else:\n914             dashes = None\n915     else:\n916         markers = dashes = style_order = None\n917 \n918     # Now extract the data that would be used to draw a single plot\n919     variables = p.variables\n920     plot_data = p.plot_data\n921     plot_semantics = p.semantics\n922 \n923     # Define the common plotting parameters\n924     plot_kws = dict(\n925         palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n926         sizes=sizes, size_order=size_order, size_norm=size_norm,\n927         markers=markers, dashes=dashes, style_order=style_order,\n928         legend=False,\n929     )\n930     plot_kws.update(kwargs)\n931     if kind == \"scatter\":\n932         plot_kws.pop(\"dashes\")\n933 \n934     # Add the grid semantics onto the plotter\n935     grid_semantics = \"row\", \"col\"\n936     p.semantics = plot_semantics + grid_semantics\n937     p.assign_variables(\n938         data=data,\n939         variables=dict(\n940             x=x, y=y,\n941             hue=hue, size=size, style=style, units=units,\n942             row=row, col=col,\n943         ),\n944     )\n945 \n946     # Define the named variables for plotting on each facet\n947     # Rename the variables with a leading underscore to avoid\n948     # collisions with faceting variable names\n949     plot_variables = {v: f\"_{v}\" for v in variables}\n950     plot_kws.update(plot_variables)\n951 \n952     # Pass the row/col variables to FacetGrid with their original\n953     # names so that the axes titles render correctly\n954     for var in [\"row\", \"col\"]:\n955         # Handle faceting variables that lack name information\n956         if var in p.variables and p.variables[var] is None:\n957             p.variables[var] = f\"_{var}_\"\n958     grid_kws = {v: p.variables.get(v) for v in grid_semantics}\n959 \n960     # Rename the columns of the plot_data structure appropriately\n961     new_cols = plot_variables.copy()\n962     new_cols.update(grid_kws)\n963     full_data = p.plot_data.rename(columns=new_cols)\n964 \n965     # Set up the FacetGrid object\n966     facet_kws = {} if facet_kws is None else facet_kws.copy()\n967     g = FacetGrid(\n968         data=full_data.dropna(axis=1, how=\"all\"),\n969         **grid_kws,\n970         col_wrap=col_wrap, row_order=row_order, col_order=col_order,\n971         height=height, aspect=aspect, dropna=False,\n972         **facet_kws\n973     )\n974 \n975     # Draw the plot\n976     g.map_dataframe(func, **plot_kws)\n977 \n978     # Label the axes, using the original variables\n979     g.set(xlabel=variables.get(\"x\"), ylabel=variables.get(\"y\"))\n980 \n981     # Show the legend\n982     if legend:\n983         # Replace the original plot data so the legend uses\n984         # numeric data with the correct type\n985         p.plot_data = plot_data\n986         p.add_legend_data(g.axes.flat[0])\n987         if p.legend_data:\n988             g.add_legend(legend_data=p.legend_data,\n989                          label_order=p.legend_order,\n990                          title=p.legend_title,\n991                          adjust_subtitles=True)\n992 \n993     # Rename the columns of the FacetGrid's `data` attribute\n994     # to match the original column names\n995     orig_cols = {\n996         f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()\n997     }\n998     grid_data = g.data.rename(columns=orig_cols)\n999     if data is not None and (x is not None or y is not None):\n1000         if not isinstance(data, pd.DataFrame):\n1001             data = pd.DataFrame(data)\n1002         g.data = pd.merge(\n1003             data,\n1004             grid_data[grid_data.columns.difference(data.columns)],\n1005             left_index=True,\n1006             right_index=True,\n1007         )\n1008     else:\n1009         g.data = grid_data\n1010 \n1011     return g\n1012 \n1013 \n1014 relplot.__doc__ = \"\"\"\\\n1015 Figure-level interface for drawing relational plots onto a FacetGrid.\n1016 \n1017 This function provides access to several different axes-level functions\n1018 that show the relationship between two variables with semantic mappings\n1019 of subsets. The ``kind`` parameter selects the underlying axes-level\n1020 function to use:\n1021 \n1022 - :func:`scatterplot` (with ``kind=\"scatter\"``; the default)\n1023 - :func:`lineplot` (with ``kind=\"line\"``)\n1024 \n1025 Extra keyword arguments are passed to the underlying function, so you\n1026 should refer to the documentation for each to see kind-specific options.\n1027 \n1028 {narrative.main_api}\n1029 \n1030 {narrative.relational_semantic}\n1031 \n1032 After plotting, the :class:`FacetGrid` with the plot is returned and can\n1033 be used directly to tweak supporting plot details or add other layers.\n1034 \n1035 Note that, unlike when using the underlying plotting functions directly,\n1036 data must be passed in a long-form DataFrame with variables specified by\n1037 passing strings to ``x``, ``y``, and other parameters.\n1038 \n1039 Parameters\n1040 ----------\n1041 {params.core.data}\n1042 {params.core.xy}\n1043 hue : vector or key in ``data``\n1044     Grouping variable that will produce elements with different colors.\n1045     Can be either categorical or numeric, although color mapping will\n1046     behave differently in latter case.\n1047 size : vector or key in ``data``\n1048     Grouping variable that will produce elements with different sizes.\n1049     Can be either categorical or numeric, although size mapping will\n1050     behave differently in latter case.\n1051 style : vector or key in ``data``\n1052     Grouping variable that will produce elements with different styles.\n1053     Can have a numeric dtype but will always be treated as categorical.\n1054 {params.rel.units}\n1055 {params.facets.rowcol}\n1056 {params.facets.col_wrap}\n1057 row_order, col_order : lists of strings\n1058     Order to organize the rows and/or columns of the grid in, otherwise the\n1059     orders are inferred from the data objects.\n1060 {params.core.palette}\n1061 {params.core.hue_order}\n1062 {params.core.hue_norm}\n1063 {params.rel.sizes}\n1064 {params.rel.size_order}\n1065 {params.rel.size_norm}\n1066 {params.rel.style_order}\n1067 {params.rel.dashes}\n1068 {params.rel.markers}\n1069 {params.rel.legend}\n1070 kind : string\n1071     Kind of plot to draw, corresponding to a seaborn relational plot.\n1072     Options are {{``scatter`` and ``line``}}.\n1073 {params.facets.height}\n1074 {params.facets.aspect}\n1075 facet_kws : dict\n1076     Dictionary of other keyword arguments to pass to :class:`FacetGrid`.\n1077 kwargs : key, value pairings\n1078     Other keyword arguments are passed through to the underlying plotting\n1079     function.\n1080 \n1081 Returns\n1082 -------\n1083 {returns.facetgrid}\n1084 \n1085 Examples\n1086 --------\n1087 \n1088 .. include:: ../docstrings/relplot.rst\n1089 \n1090 \"\"\".format(\n1091     narrative=_relational_narrative,\n1092     params=_param_docs,\n1093     returns=_core_docs[\"returns\"],\n1094     seealso=_core_docs[\"seealso\"],\n1095 )\n",
        "intended_behavior": "The methods for plotting that accept a `hue` parameter need to robustly handle different types of inputs for `hue`, including direct lists or Series from a DataFrame, ensuring that categorical data is handled consistently. If the issue is rooted in how these methods interpret or utilize the `hue` parameter when passed from `PairGrid.map`, adjustments should ensure that `hue` data is properly normalized and mapped to the color palette without causing exceptions. This might require additional checks or preprocessing steps for `hue` values within these plotting methods or a more sophisticated method of passing data between `PairGrid.map` and the plotting functions to ensure they receive `hue` in the expected format."
    }
]