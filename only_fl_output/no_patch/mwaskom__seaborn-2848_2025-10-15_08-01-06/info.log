2025-10-15 08:01:06.706 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 08:01:08.367 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1626, output_tokens=12, cost=0.016620
2025-10-15 08:01:18.904 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1806, output_tokens=421, cost=0.030690
2025-10-15 08:01:19.880 | INFO     | registered non reproducing test 0
2025-10-15 08:01:36.268 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2733, output_tokens=589, cost=0.045000
2025-10-15 08:01:56.229 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2733, output_tokens=579, cost=0.044700
2025-10-15 08:01:57.186 | INFO     | registered non reproducing test 2
2025-10-15 08:01:57.187 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 08:01:57.193 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 08:02:07.812 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1845, output_tokens=380, cost=0.029850
2025-10-15 08:02:07.821 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 08:02:11.674 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=734, output_tokens=92, cost=0.010100
2025-10-15 08:02:11.675 | DEBUG    | Extracted a valid json.
2025-10-15 08:02:11.675 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"PairGrid\")",
        "search_method(\"scatterplot\")",
        "search_method(\"regplot\")",
        "search_method_in_file(\"_lookup_single\", \"_core.py\")",
        "search_method_in_file(\"plot\", \"relational.py\")",
        "search_code(\"hue_order\")",
        "search_code(\"palette\")"
    ],
    "bug_locations": []
}
2025-10-15 08:02:11.949 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 08:02:11.950 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 08:02:36.335 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9289, output_tokens=831, cost=0.117820
2025-10-15 08:02:36.351 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 08:02:46.270 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10336, output_tokens=387, cost=0.114970
2025-10-15 08:02:46.278 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 08:02:55.800 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=741, output_tokens=352, cost=0.017970
2025-10-15 08:02:55.801 | DEBUG    | Extracted a valid json.
2025-10-15 08:02:55.801 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "seaborn/axisgrid.py",
            "class": "PairGrid",
            "method": "map",
            "intended_behavior": "The `map` method should correctly handle the `hue` parameter regardless if it is numeric, categorical, or a DataFrame column. The method should ensure that the `hue` parameter passed to the plotting functions (like `scatterplot` or `regplot`) is processed in such a manner that it does not raise KeyError or TypeError when categorical data is used. This might involve validating or transforming the `hue` data before it is utilized by the plotting functions or ensuring that seaborn's internal mechanisms for handling hues (e.g., normalization, lookup) are compatible with how `map` is invoking those functions."
        },
        {
            "file": "seaborn/relational.py",
            "class": "",
            "method": "scatterplot and potentially other plotting functions",
            "intended_behavior": "The methods for plotting that accept a `hue` parameter need to robustly handle different types of inputs for `hue`, including direct lists or Series from a DataFrame, ensuring that categorical data is handled consistently. If the issue is rooted in how these methods interpret or utilize the `hue` parameter when passed from `PairGrid.map`, adjustments should ensure that `hue` data is properly normalized and mapped to the color palette without causing exceptions. This might require additional checks or preprocessing steps for `hue` values within these plotting methods or a more sophisticated method of passing data between `PairGrid.map` and the plotting functions to ensure they receive `hue` in the expected format."
        }
    ]
}
2025-10-15 08:02:55.811 | DEBUG    | Bug location extracted successfully: [<file>seaborn/axisgrid.py</file>
<class>PairGrid</class>
<method>map</method>
<code>
1320     def map(self, func, **kwargs):
1321         """Plot with the same function in every subplot.
1322 
1323         Parameters
1324         ----------
1325         func : callable plotting function
1326             Must take x, y arrays as positional arguments and draw onto the
1327             "currently active" matplotlib Axes. Also needs to accept kwargs
1328             called ``color`` and  ``label``.
1329 
1330         """
1331         row_indices, col_indices = np.indices(self.axes.shape)
1332         indices = zip(row_indices.flat, col_indices.flat)
1333         self._map_bivariate(func, indices, **kwargs)
1334 
1335         return self

</code><intended_behavior>The `map` method should correctly handle the `hue` parameter regardless if it is numeric, categorical, or a DataFrame column. The method should ensure that the `hue` parameter passed to the plotting functions (like `scatterplot` or `regplot`) is processed in such a manner that it does not raise KeyError or TypeError when categorical data is used. This might involve validating or transforming the `hue` data before it is utilized by the plotting functions or ensuring that seaborn's internal mechanisms for handling hues (e.g., normalization, lookup) are compatible with how `map` is invoking those functions.</intended_behavior>, <file>seaborn/axisgrid.py</file>
<class>PairGrid</class>
<method>None</method>
<code>
1124 class PairGrid(Grid):
1125     """Subplot grid for plotting pairwise relationships in a dataset.
1126 
1127     This object maps each variable in a dataset onto a column and row in a
1128     grid of multiple axes. Different axes-level plotting functions can be
1129     used to draw bivariate plots in the upper and lower triangles, and the
1130     the marginal distribution of each variable can be shown on the diagonal.
1131 
1132     Several different common plots can be generated in a single line using
1133     :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.
1134 
1135     See the :ref:`tutorial <grid_tutorial>` for more information.
1136 
1137     """
1138     def __init__(
1139         self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,
1140         hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,
1141         height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False, size=None
1142     ):
1143         """Initialize the plot figure and PairGrid object.
1144 
1145         Parameters
1146         ----------
1147         data : DataFrame
1148             Tidy (long-form) dataframe where each column is a variable and
1149             each row is an observation.
1150         hue : string (variable name)
1151             Variable in ``data`` to map plot aspects to different colors. This
1152             variable will be excluded from the default x and y variables.
1153         vars : list of variable names
1154             Variables within ``data`` to use, otherwise use every column with
1155             a numeric datatype.
1156         {x, y}_vars : lists of variable names
1157             Variables within ``data`` to use separately for the rows and
1158             columns of the figure; i.e. to make a non-square plot.
1159         hue_order : list of strings
1160             Order for the levels of the hue variable in the palette
1161         palette : dict or seaborn color palette
1162             Set of colors for mapping the ``hue`` variable. If a dict, keys
1163             should be values  in the ``hue`` variable.
1164         hue_kws : dictionary of param -> list of values mapping
1165             Other keyword arguments to insert into the plotting call to let
1166             other plot attributes vary across levels of the hue variable (e.g.
1167             the markers in a scatterplot).
1168         corner : bool
1169             If True, don't add axes to the upper (off-diagonal) triangle of the
1170             grid, making this a "corner" plot.
1171         height : scalar
1172             Height (in inches) of each facet.
1173         aspect : scalar
1174             Aspect * height gives the width (in inches) of each facet.
1175         layout_pad : scalar
1176             Padding between axes; passed to ``fig.tight_layout``.
1177         despine : boolean
1178             Remove the top and right spines from the plots.
1179         dropna : boolean
1180             Drop missing values from the data before plotting.
1181 
1182         See Also
1183         --------
1184         pairplot : Easily drawing common uses of :class:`PairGrid`.
1185         FacetGrid : Subplot grid for plotting conditional relationships.
1186 
1187         Examples
1188         --------
1189 
1190         .. include:: ../docstrings/PairGrid.rst
1191 
1192         """
1193 
1194         super().__init__()
1195 
1196         # Handle deprecations
1197         if size is not None:
1198             height = size
1199             msg = ("The `size` parameter has been renamed to `height`; "
1200                    "please update your code.")
1201             warnings.warn(UserWarning(msg))
1202 
1203         # Sort out the variables that define the grid
1204         numeric_cols = self._find_numeric_cols(data)
1205         if hue in numeric_cols:
1206             numeric_cols.remove(hue)
1207         if vars is not None:
1208             x_vars = list(vars)
1209             y_vars = list(vars)
1210         if x_vars is None:
1211             x_vars = numeric_cols
1212         if y_vars is None:
1213             y_vars = numeric_cols
1214 
1215         if np.isscalar(x_vars):
1216             x_vars = [x_vars]
1217         if np.isscalar(y_vars):
1218             y_vars = [y_vars]
1219 
1220         self.x_vars = x_vars = list(x_vars)
1221         self.y_vars = y_vars = list(y_vars)
1222         self.square_grid = self.x_vars == self.y_vars
1223 
1224         if not x_vars:
1225             raise ValueError("No variables found for grid columns.")
1226         if not y_vars:
1227             raise ValueError("No variables found for grid rows.")
1228 
1229         # Create the figure and the array of subplots
1230         figsize = len(x_vars) * height * aspect, len(y_vars) * height
1231 
1232         # Disable autolayout so legend_out works
1233         with mpl.rc_context({"figure.autolayout": False}):
1234             fig = plt.figure(figsize=figsize)
1235 
1236         axes = fig.subplots(len(y_vars), len(x_vars),
1237                             sharex="col", sharey="row",
1238                             squeeze=False)
1239 
1240         # Possibly remove upper axes to make a corner grid
1241         # Note: setting up the axes is usually the most time-intensive part
1242         # of using the PairGrid. We are foregoing the speed improvement that
1243         # we would get by just not setting up the hidden axes so that we can
1244         # avoid implementing fig.subplots ourselves. But worth thinking about.
1245         self._corner = corner
1246         if corner:
1247             hide_indices = np.triu_indices_from(axes, 1)
1248             for i, j in zip(*hide_indices):
1249                 axes[i, j].remove()
1250                 axes[i, j] = None
1251 
1252         self._figure = fig
1253         self.axes = axes
1254         self.data = data
1255 
1256         # Save what we are going to do with the diagonal
1257         self.diag_sharey = diag_sharey
1258         self.diag_vars = None
1259         self.diag_axes = None
1260 
1261         self._dropna = dropna
1262 
1263         # Label the axes
1264         self._add_axis_labels()
1265 
1266         # Sort out the hue variable
1267         self._hue_var = hue
1268         if hue is None:
1269             self.hue_names = hue_order = ["_nolegend_"]
1270             self.hue_vals = pd.Series(["_nolegend_"] * len(data),
1271                                       index=data.index)
1272         else:
1273             # We need hue_order and hue_names because the former is used to control
1274             # the order of drawing and the latter is used to control the order of
1275             # the legend. hue_names can become string-typed while hue_order must
1276             # retain the type of the input data. This is messy but results from
1277             # the fact that PairGrid can implement the hue-mapping logic itself
1278             # (and was originally written exclusively that way) but now can delegate
1279             # to the axes-level functions, while always handling legend creation.
1280             # See GH2307
1281             hue_names = hue_order = categorical_order(data[hue], hue_order)
1282             if dropna:
1283                 # Filter NA from the list of unique hue names
1284                 hue_names = list(filter(pd.notnull, hue_names))
1285             self.hue_names = hue_names
1286             self.hue_vals = data[hue]
1287 
1288         # Additional dict of kwarg -> list of values for mapping the hue var
1289         self.hue_kws = hue_kws if hue_kws is not None else {}
1290 
1291         self._orig_palette = palette
1292         self._hue_order = hue_order
1293         self.palette = self._get_palette(data, hue, hue_order, palette)
1294         self._legend_data = {}
1295 
1296         # Make the plot look nice
1297         for ax in axes[:-1, :].flat:
1298             if ax is None:
1299                 continue
1300             for label in ax.get_xticklabels():
1301                 label.set_visible(False)
1302             ax.xaxis.offsetText.set_visible(False)
1303             ax.xaxis.label.set_visible(False)
1304 
1305         for ax in axes[:, 1:].flat:
1306             if ax is None:
1307                 continue
1308             for label in ax.get_yticklabels():
1309                 label.set_visible(False)
1310             ax.yaxis.offsetText.set_visible(False)
1311             ax.yaxis.label.set_visible(False)
1312 
1313         self._tight_layout_rect = [.01, .01, .99, .99]
1314         self._tight_layout_pad = layout_pad
1315         self._despine = despine
1316         if despine:
1317             utils.despine(fig=fig)
1318         self.tight_layout(pad=layout_pad)
1319 
1320     def map(self, func, **kwargs):
1321         """Plot with the same function in every subplot.
1322 
1323         Parameters
1324         ----------
1325         func : callable plotting function
1326             Must take x, y arrays as positional arguments and draw onto the
1327             "currently active" matplotlib Axes. Also needs to accept kwargs
1328             called ``color`` and  ``label``.
1329 
1330         """
1331         row_indices, col_indices = np.indices(self.axes.shape)
1332         indices = zip(row_indices.flat, col_indices.flat)
1333         self._map_bivariate(func, indices, **kwargs)
1334 
1335         return self
1336 
1337     def map_lower(self, func, **kwargs):
1338         """Plot with a bivariate function on the lower diagonal subplots.
1339 
1340         Parameters
1341         ----------
1342         func : callable plotting function
1343             Must take x, y arrays as positional arguments and draw onto the
1344             "currently active" matplotlib Axes. Also needs to accept kwargs
1345             called ``color`` and  ``label``.
1346 
1347         """
1348         indices = zip(*np.tril_indices_from(self.axes, -1))
1349         self._map_bivariate(func, indices, **kwargs)
1350         return self
1351 
1352     def map_upper(self, func, **kwargs):
1353         """Plot with a bivariate function on the upper diagonal subplots.
1354 
1355         Parameters
1356         ----------
1357         func : callable plotting function
1358             Must take x, y arrays as positional arguments and draw onto the
1359             "currently active" matplotlib Axes. Also needs to accept kwargs
1360             called ``color`` and  ``label``.
1361 
1362         """
1363         indices = zip(*np.triu_indices_from(self.axes, 1))
1364         self._map_bivariate(func, indices, **kwargs)
1365         return self
1366 
1367     def map_offdiag(self, func, **kwargs):
1368         """Plot with a bivariate function on the off-diagonal subplots.
1369 
1370         Parameters
1371         ----------
1372         func : callable plotting function
1373             Must take x, y arrays as positional arguments and draw onto the
1374             "currently active" matplotlib Axes. Also needs to accept kwargs
1375             called ``color`` and  ``label``.
1376 
1377         """
1378         if self.square_grid:
1379             self.map_lower(func, **kwargs)
1380             if not self._corner:
1381                 self.map_upper(func, **kwargs)
1382         else:
1383             indices = []
1384             for i, (y_var) in enumerate(self.y_vars):
1385                 for j, (x_var) in enumerate(self.x_vars):
1386                     if x_var != y_var:
1387                         indices.append((i, j))
1388             self._map_bivariate(func, indices, **kwargs)
1389         return self
1390 
1391     def map_diag(self, func, **kwargs):
1392         """Plot with a univariate function on each diagonal subplot.
1393 
1394         Parameters
1395         ----------
1396         func : callable plotting function
1397             Must take an x array as a positional argument and draw onto the
1398             "currently active" matplotlib Axes. Also needs to accept kwargs
1399             called ``color`` and  ``label``.
1400 
1401         """
1402         # Add special diagonal axes for the univariate plot
1403         if self.diag_axes is None:
1404             diag_vars = []
1405             diag_axes = []
1406             for i, y_var in enumerate(self.y_vars):
1407                 for j, x_var in enumerate(self.x_vars):
1408                     if x_var == y_var:
1409 
1410                         # Make the density axes
1411                         diag_vars.append(x_var)
1412                         ax = self.axes[i, j]
1413                         diag_ax = ax.twinx()
1414                         diag_ax.set_axis_off()
1415                         diag_axes.append(diag_ax)
1416 
1417                         # Work around matplotlib bug
1418                         # https://github.com/matplotlib/matplotlib/issues/15188
1419                         if not plt.rcParams.get("ytick.left", True):
1420                             for tick in ax.yaxis.majorTicks:
1421                                 tick.tick1line.set_visible(False)
1422 
1423                         # Remove main y axis from density axes in a corner plot
1424                         if self._corner:
1425                             ax.yaxis.set_visible(False)
1426                             if self._despine:
1427                                 utils.despine(ax=ax, left=True)
1428                             # TODO add optional density ticks (on the right)
1429                             # when drawing a corner plot?
1430 
1431             if self.diag_sharey and diag_axes:
1432                 # This may change in future matplotlibs
1433                 # See https://github.com/matplotlib/matplotlib/pull/9923
1434                 group = diag_axes[0].get_shared_y_axes()
1435                 for ax in diag_axes[1:]:
1436                     group.join(ax, diag_axes[0])
1437 
1438             self.diag_vars = np.array(diag_vars, np.object_)
1439             self.diag_axes = np.array(diag_axes, np.object_)
1440 
1441         if "hue" not in signature(func).parameters:
1442             return self._map_diag_iter_hue(func, **kwargs)
1443 
1444         # Loop over diagonal variables and axes, making one plot in each
1445         for var, ax in zip(self.diag_vars, self.diag_axes):
1446 
1447             plot_kwargs = kwargs.copy()
1448             if str(func.__module__).startswith("seaborn"):
1449                 plot_kwargs["ax"] = ax
1450             else:
1451                 plt.sca(ax)
1452 
1453             vector = self.data[var]
1454             if self._hue_var is not None:
1455                 hue = self.data[self._hue_var]
1456             else:
1457                 hue = None
1458 
1459             if self._dropna:
1460                 not_na = vector.notna()
1461                 if hue is not None:
1462                     not_na &= hue.notna()
1463                 vector = vector[not_na]
1464                 if hue is not None:
1465                     hue = hue[not_na]
1466 
1467             plot_kwargs.setdefault("hue", hue)
1468             plot_kwargs.setdefault("hue_order", self._hue_order)
1469             plot_kwargs.setdefault("palette", self._orig_palette)
1470             func(x=vector, **plot_kwargs)
1471             ax.legend_ = None
1472 
1473         self._add_axis_labels()
1474         return self
1475 
1476     def _map_diag_iter_hue(self, func, **kwargs):
1477         """Put marginal plot on each diagonal axes, iterating over hue."""
1478         # Plot on each of the diagonal axes
1479         fixed_color = kwargs.pop("color", None)
1480 
1481         for var, ax in zip(self.diag_vars, self.diag_axes):
1482             hue_grouped = self.data[var].groupby(self.hue_vals)
1483 
1484             plot_kwargs = kwargs.copy()
1485             if str(func.__module__).startswith("seaborn"):
1486                 plot_kwargs["ax"] = ax
1487             else:
1488                 plt.sca(ax)
1489 
1490             for k, label_k in enumerate(self._hue_order):
1491 
1492                 # Attempt to get data for this level, allowing for empty
1493                 try:
1494                     data_k = hue_grouped.get_group(label_k)
1495                 except KeyError:
1496                     data_k = pd.Series([], dtype=float)
1497 
1498                 if fixed_color is None:
1499                     color = self.palette[k]
1500                 else:
1501                     color = fixed_color
1502 
1503                 if self._dropna:
1504                     data_k = utils.remove_na(data_k)
1505 
1506                 if str(func.__module__).startswith("seaborn"):
1507                     func(x=data_k, label=label_k, color=color, **plot_kwargs)
1508                 else:
1509                     func(data_k, label=label_k, color=color, **plot_kwargs)
1510 
1511         self._add_axis_labels()
1512 
1513         return self
1514 
1515     def _map_bivariate(self, func, indices, **kwargs):
1516         """Draw a bivariate plot on the indicated axes."""
1517         # This is a hack to handle the fact that new distribution plots don't add
1518         # their artists onto the axes. This is probably superior in general, but
1519         # we'll need a better way to handle it in the axisgrid functions.
1520         from .distributions import histplot, kdeplot
1521         if func is histplot or func is kdeplot:
1522             self._extract_legend_handles = True
1523 
1524         kws = kwargs.copy()  # Use copy as we insert other kwargs
1525         for i, j in indices:
1526             x_var = self.x_vars[j]
1527             y_var = self.y_vars[i]
1528             ax = self.axes[i, j]
1529             if ax is None:  # i.e. we are in corner mode
1530                 continue
1531             self._plot_bivariate(x_var, y_var, ax, func, **kws)
1532         self._add_axis_labels()
1533 
1534         if "hue" in signature(func).parameters:
1535             self.hue_names = list(self._legend_data)
1536 
1537     def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):
1538         """Draw a bivariate plot on the specified axes."""
1539         if "hue" not in signature(func).parameters:
1540             self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)
1541             return
1542 
1543         kwargs = kwargs.copy()
1544         if str(func.__module__).startswith("seaborn"):
1545             kwargs["ax"] = ax
1546         else:
1547             plt.sca(ax)
1548 
1549         if x_var == y_var:
1550             axes_vars = [x_var]
1551         else:
1552             axes_vars = [x_var, y_var]
1553 
1554         if self._hue_var is not None and self._hue_var not in axes_vars:
1555             axes_vars.append(self._hue_var)
1556 
1557         data = self.data[axes_vars]
1558         if self._dropna:
1559             data = data.dropna()
1560 
1561         x = data[x_var]
1562         y = data[y_var]
1563         if self._hue_var is None:
1564             hue = None
1565         else:
1566             hue = data.get(self._hue_var)
1567 
1568         if "hue" not in kwargs:
1569             kwargs.update({
1570                 "hue": hue, "hue_order": self._hue_order, "palette": self._orig_palette,
1571             })
1572         func(x=x, y=y, **kwargs)
1573 
1574         self._update_legend_data(ax)
1575 
1576     def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):
1577         """Draw a bivariate plot while iterating over hue subsets."""
1578         kwargs = kwargs.copy()
1579         if str(func.__module__).startswith("seaborn"):
1580             kwargs["ax"] = ax
1581         else:
1582             plt.sca(ax)
1583 
1584         if x_var == y_var:
1585             axes_vars = [x_var]
1586         else:
1587             axes_vars = [x_var, y_var]
1588 
1589         hue_grouped = self.data.groupby(self.hue_vals)
1590         for k, label_k in enumerate(self._hue_order):
1591 
1592             kws = kwargs.copy()
1593 
1594             # Attempt to get data for this level, allowing for empty
1595             try:
1596                 data_k = hue_grouped.get_group(label_k)
1597             except KeyError:
1598                 data_k = pd.DataFrame(columns=axes_vars,
1599                                       dtype=float)
1600 
1601             if self._dropna:
1602                 data_k = data_k[axes_vars].dropna()
1603 
1604             x = data_k[x_var]
1605             y = data_k[y_var]
1606 
1607             for kw, val_list in self.hue_kws.items():
1608                 kws[kw] = val_list[k]
1609             kws.setdefault("color", self.palette[k])
1610             if self._hue_var is not None:
1611                 kws["label"] = label_k
1612 
1613             if str(func.__module__).startswith("seaborn"):
1614                 func(x=x, y=y, **kws)
1615             else:
1616                 func(x, y, **kws)
1617 
1618         self._update_legend_data(ax)
1619 
1620     def _add_axis_labels(self):
1621         """Add labels to the left and bottom Axes."""
1622         for ax, label in zip(self.axes[-1, :], self.x_vars):
1623             ax.set_xlabel(label)
1624         for ax, label in zip(self.axes[:, 0], self.y_vars):
1625             ax.set_ylabel(label)
1626         if self._corner:
1627             self.axes[0, 0].set_ylabel("")
1628 
1629     def _find_numeric_cols(self, data):
1630         """Find which variables in a DataFrame are numeric."""
1631         numeric_cols = []
1632         for col in data:
1633             if variable_type(data[col]) == "numeric":
1634                 numeric_cols.append(col)
1635         return numeric_cols

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>seaborn/relational.py</file>
<class>None</class>
<method>None</method>
<code>
1 import warnings
2 
3 import numpy as np
4 import pandas as pd
5 import matplotlib as mpl
6 import matplotlib.pyplot as plt
7 
8 from ._oldcore import (
9     VectorPlotter,
10 )
11 from .utils import (
12     locator_to_legend_entries,
13     adjust_legend_subtitles,
14     _default_color,
15     _deprecate_ci,
16 )
17 from ._statistics import EstimateAggregator
18 from .axisgrid import FacetGrid, _facet_docs
19 from ._docstrings import DocstringComponents, _core_docs
20 
21 
22 __all__ = ["relplot", "scatterplot", "lineplot"]
23 
24 
25 _relational_narrative = DocstringComponents(dict(
26 
27     # ---  Introductory prose
28     main_api="""
29 The relationship between ``x`` and ``y`` can be shown for different subsets
30 of the data using the ``hue``, ``size``, and ``style`` parameters. These
31 parameters control what visual semantics are used to identify the different
32 subsets. It is possible to show up to three dimensions independently by
33 using all three semantic types, but this style of plot can be hard to
34 interpret and is often ineffective. Using redundant semantics (i.e. both
35 ``hue`` and ``style`` for the same variable) can be helpful for making
36 graphics more accessible.
37 
38 See the :ref:`tutorial <relational_tutorial>` for more information.
39     """,
40 
41     relational_semantic="""
42 The default treatment of the ``hue`` (and to a lesser extent, ``size``)
43 semantic, if present, depends on whether the variable is inferred to
44 represent "numeric" or "categorical" data. In particular, numeric variables
45 are represented with a sequential colormap by default, and the legend
46 entries show regular "ticks" with values that may or may not exist in the
47 data. This behavior can be controlled through various parameters, as
48 described and illustrated below.
49     """,
50 ))
51 
52 _relational_docs = dict(
53 
54     # --- Shared function parameters
55     data_vars="""
56 x, y : names of variables in ``data`` or vector data
57     Input data variables; must be numeric. Can pass data directly or
58     reference columns in ``data``.
59     """,
60     data="""
61 data : DataFrame, array, or list of arrays
62     Input data structure. If ``x`` and ``y`` are specified as names, this
63     should be a "long-form" DataFrame containing those columns. Otherwise
64     it is treated as "wide-form" data and grouping variables are ignored.
65     See the examples for the various ways this parameter can be specified
66     and the different effects of each.
67     """,
68     palette="""
69 palette : string, list, dict, or matplotlib colormap
70     An object that determines how colors are chosen when ``hue`` is used.
71     It can be the name of a seaborn palette or matplotlib colormap, a list
72     of colors (anything matplotlib understands), a dict mapping levels
73     of the ``hue`` variable to colors, or a matplotlib colormap object.
74     """,
75     hue_order="""
76 hue_order : list
77     Specified order for the appearance of the ``hue`` variable levels,
78     otherwise they are determined from the data. Not relevant when the
79     ``hue`` variable is numeric.
80     """,
81     hue_norm="""
82 hue_norm : tuple or :class:`matplotlib.colors.Normalize` object
83     Normalization in data units for colormap applied to the ``hue``
84     variable when it is numeric. Not relevant if it is categorical.
85     """,
86     sizes="""
87 sizes : list, dict, or tuple
88     An object that determines how sizes are chosen when ``size`` is used.
89     It can always be a list of size values or a dict mapping levels of the
90     ``size`` variable to sizes. When ``size``  is numeric, it can also be
91     a tuple specifying the minimum and maximum size to use such that other
92     values are normalized within this range.
93     """,
94     size_order="""
95 size_order : list
96     Specified order for appearance of the ``size`` variable levels,
97     otherwise they are determined from the data. Not relevant when the
98     ``size`` variable is numeric.
99     """,
100     size_norm="""
101 size_norm : tuple or Normalize object
102     Normalization in data units for scaling plot objects when the
103     ``size`` variable is numeric.
104     """,
105     dashes="""
106 dashes : boolean, list, or dictionary
107     Object determining how to draw the lines for different levels of the
108     ``style`` variable. Setting to ``True`` will use default dash codes, or
109     you can pass a list of dash codes or a dictionary mapping levels of the
110     ``style`` variable to dash codes. Setting to ``False`` will use solid
111     lines for all subsets. Dashes are specified as in matplotlib: a tuple
112     of ``(segment, gap)`` lengths, or an empty string to draw a solid line.
113     """,
114     markers="""
115 markers : boolean, list, or dictionary
116     Object determining how to draw the markers for different levels of the
117     ``style`` variable. Setting to ``True`` will use default markers, or
118     you can pass a list of markers or a dictionary mapping levels of the
119     ``style`` variable to markers. Setting to ``False`` will draw
120     marker-less lines.  Markers are specified as in matplotlib.
121     """,
122     style_order="""
123 style_order : list
124     Specified order for appearance of the ``style`` variable levels
125     otherwise they are determined from the data. Not relevant when the
126     ``style`` variable is numeric.
127     """,
128     units="""
129 units : vector or key in ``data``
130     Grouping variable identifying sampling units. When used, a separate
131     line will be drawn for each unit with appropriate semantics, but no
132     legend entry will be added. Useful for showing distribution of
133     experimental replicates when exact identities are not needed.
134     """,
135     estimator="""
136 estimator : name of pandas method or callable or None
137     Method for aggregating across multiple observations of the ``y``
138     variable at the same ``x`` level. If ``None``, all observations will
139     be drawn.
140     """,
141     ci="""
142 ci : int or "sd" or None
143     Size of the confidence interval to draw when aggregating.
144 
145     .. deprecated:: 0.12.0
146         Use the new `errorbar` parameter for more flexibility.
147 
148     """,
149     n_boot="""
150 n_boot : int
151     Number of bootstraps to use for computing the confidence interval.
152     """,
153     seed="""
154 seed : int, numpy.random.Generator, or numpy.random.RandomState
155     Seed or random number generator for reproducible bootstrapping.
156     """,
157     legend="""
158 legend : "auto", "brief", "full", or False
159     How to draw the legend. If "brief", numeric ``hue`` and ``size``
160     variables will be represented with a sample of evenly spaced values.
161     If "full", every group will get an entry in the legend. If "auto",
162     choose between brief or full representation based on number of levels.
163     If ``False``, no legend data is added and no legend is drawn.
164     """,
165     ax_in="""
166 ax : matplotlib Axes
167     Axes object to draw the plot onto, otherwise uses the current Axes.
168     """,
169     ax_out="""
170 ax : matplotlib Axes
171     Returns the Axes object with the plot drawn onto it.
172     """,
173 
174 )
175 
176 
177 _param_docs = DocstringComponents.from_nested_components(
178     core=_core_docs["params"],
179     facets=DocstringComponents(_facet_docs),
180     rel=DocstringComponents(_relational_docs),
181     stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),
182 )
183 
184 
185 class _RelationalPlotter(VectorPlotter):
186 
187     wide_structure = {
188         "x": "@index", "y": "@values", "hue": "@columns", "style": "@columns",
189     }
190 
191     # TODO where best to define default parameters?
192     sort = True
193 
194     def add_legend_data(self, ax):
195         """Add labeled artists to represent the different plot semantics."""
196         verbosity = self.legend
197         if isinstance(verbosity, str) and verbosity not in ["auto", "brief", "full"]:
198             err = "`legend` must be 'auto', 'brief', 'full', or a boolean."
199             raise ValueError(err)
200         elif verbosity is True:
201             verbosity = "auto"
202 
203         legend_kwargs = {}
204         keys = []
205 
206         # Assign a legend title if there is only going to be one sub-legend,
207         # otherwise, subtitles will be inserted into the texts list with an
208         # invisible handle (which is a hack)
209         titles = {
210             title for title in
211             (self.variables.get(v, None) for v in ["hue", "size", "style"])
212             if title is not None
213         }
214         if len(titles) == 1:
215             legend_title = titles.pop()
216         else:
217             legend_title = ""
218 
219         title_kws = dict(
220             visible=False, color="w", s=0, linewidth=0, marker="", dashes=""
221         )
222 
223         def update(var_name, val_name, **kws):
224 
225             key = var_name, val_name
226             if key in legend_kwargs:
227                 legend_kwargs[key].update(**kws)
228             else:
229                 keys.append(key)
230 
231                 legend_kwargs[key] = dict(**kws)
232 
233         # Define the maximum number of ticks to use for "brief" legends
234         brief_ticks = 6
235 
236         # -- Add a legend for hue semantics
237         brief_hue = self._hue_map.map_type == "numeric" and (
238             verbosity == "brief"
239             or (verbosity == "auto" and len(self._hue_map.levels) > brief_ticks)
240         )
241         if brief_hue:
242             if isinstance(self._hue_map.norm, mpl.colors.LogNorm):
243                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
244             else:
245                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
246             limits = min(self._hue_map.levels), max(self._hue_map.levels)
247             hue_levels, hue_formatted_levels = locator_to_legend_entries(
248                 locator, limits, self.plot_data["hue"].infer_objects().dtype
249             )
250         elif self._hue_map.levels is None:
251             hue_levels = hue_formatted_levels = []
252         else:
253             hue_levels = hue_formatted_levels = self._hue_map.levels
254 
255         # Add the hue semantic subtitle
256         if not legend_title and self.variables.get("hue", None) is not None:
257             update((self.variables["hue"], "title"),
258                    self.variables["hue"], **title_kws)
259 
260         # Add the hue semantic labels
261         for level, formatted_level in zip(hue_levels, hue_formatted_levels):
262             if level is not None:
263                 color = self._hue_map(level)
264                 update(self.variables["hue"], formatted_level, color=color)
265 
266         # -- Add a legend for size semantics
267         brief_size = self._size_map.map_type == "numeric" and (
268             verbosity == "brief"
269             or (verbosity == "auto" and len(self._size_map.levels) > brief_ticks)
270         )
271         if brief_size:
272             # Define how ticks will interpolate between the min/max data values
273             if isinstance(self._size_map.norm, mpl.colors.LogNorm):
274                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
275             else:
276                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
277             # Define the min/max data values
278             limits = min(self._size_map.levels), max(self._size_map.levels)
279             size_levels, size_formatted_levels = locator_to_legend_entries(
280                 locator, limits, self.plot_data["size"].infer_objects().dtype
281             )
282         elif self._size_map.levels is None:
283             size_levels = size_formatted_levels = []
284         else:
285             size_levels = size_formatted_levels = self._size_map.levels
286 
287         # Add the size semantic subtitle
288         if not legend_title and self.variables.get("size", None) is not None:
289             update((self.variables["size"], "title"),
290                    self.variables["size"], **title_kws)
291 
292         # Add the size semantic labels
293         for level, formatted_level in zip(size_levels, size_formatted_levels):
294             if level is not None:
295                 size = self._size_map(level)
296                 update(
297                     self.variables["size"],
298                     formatted_level,
299                     linewidth=size,
300                     s=size,
301                 )
302 
303         # -- Add a legend for style semantics
304 
305         # Add the style semantic title
306         if not legend_title and self.variables.get("style", None) is not None:
307             update((self.variables["style"], "title"),
308                    self.variables["style"], **title_kws)
309 
310         # Add the style semantic labels
311         if self._style_map.levels is not None:
312             for level in self._style_map.levels:
313                 if level is not None:
314                     attrs = self._style_map(level)
315                     update(
316                         self.variables["style"],
317                         level,
318                         marker=attrs.get("marker", ""),
319                         dashes=attrs.get("dashes", ""),
320                     )
321 
322         func = getattr(ax, self._legend_func)
323 
324         legend_data = {}
325         legend_order = []
326 
327         for key in keys:
328 
329             _, label = key
330             kws = legend_kwargs[key]
331             kws.setdefault("color", ".2")
332             use_kws = {}
333             for attr in self._legend_attributes + ["visible"]:
334                 if attr in kws:
335                     use_kws[attr] = kws[attr]
336             artist = func([], [], label=label, **use_kws)
337             if self._legend_func == "plot":
338                 artist = artist[0]
339             legend_data[key] = artist
340             legend_order.append(key)
341 
342         self.legend_title = legend_title
343         self.legend_data = legend_data
344         self.legend_order = legend_order
345 
346 
347 class _LinePlotter(_RelationalPlotter):
348 
349     _legend_attributes = ["color", "linewidth", "marker", "dashes"]
350     _legend_func = "plot"
351 
352     def __init__(
353         self, *,
354         data=None, variables={},
355         estimator=None, ci=None, n_boot=None, seed=None,
356         sort=True, err_style=None, err_kws=None, legend=None,
357         errorbar=None,
358     ):
359 
360         # TODO this is messy, we want the mapping to be agnostic about
361         # the kind of plot to draw, but for the time being we need to set
362         # this information so the SizeMapping can use it
363         self._default_size_range = (
364             np.r_[.5, 2] * mpl.rcParams["lines.linewidth"]
365         )
366 
367         super().__init__(data=data, variables=variables)
368 
369         self.estimator = estimator
370         self.errorbar = errorbar
371         self.ci = ci
372         self.n_boot = n_boot
373         self.seed = seed
374         self.sort = sort
375         self.err_style = err_style
376         self.err_kws = {} if err_kws is None else err_kws
377 
378         self.legend = legend
379 
380     def plot(self, ax, kws):
381         """Draw the plot onto an axes, passing matplotlib kwargs."""
382 
383         # Draw a test plot, using the passed in kwargs. The goal here is to
384         # honor both (a) the current state of the plot cycler and (b) the
385         # specified kwargs on all the lines we will draw, overriding when
386         # relevant with the data semantics. Note that we won't cycle
387         # internally; in other words, if ``hue`` is not used, all elements will
388         # have the same color, but they will have the color that you would have
389         # gotten from the corresponding matplotlib function, and calling the
390         # function will advance the axes property cycle.
391 
392         kws.setdefault("markeredgewidth", kws.pop("mew", .75))
393         kws.setdefault("markeredgecolor", kws.pop("mec", "w"))
394 
395         # Set default error kwargs
396         err_kws = self.err_kws.copy()
397         if self.err_style == "band":
398             err_kws.setdefault("alpha", .2)
399         elif self.err_style == "bars":
400             pass
401         elif self.err_style is not None:
402             err = "`err_style` must be 'band' or 'bars', not {}"
403             raise ValueError(err.format(self.err_style))
404 
405         # Initialize the aggregation object
406         agg = EstimateAggregator(
407             self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,
408         )
409 
410         # TODO abstract variable to aggregate over here-ish. Better name?
411         agg_var = "y"
412         grouper = ["x"]
413 
414         # TODO How to handle NA? We don't want NA to propagate through to the
415         # estimate/CI when some values are present, but we would also like
416         # matplotlib to show "gaps" in the line when all values are missing.
417         # This is straightforward absent aggregation, but complicated with it.
418         # If we want to use nas, we need to conditionalize dropna in iter_data.
419 
420         # Loop over the semantic subsets and add to the plot
421         grouping_vars = "hue", "size", "style"
422         for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):
423 
424             if self.sort:
425                 sort_vars = ["units", "x", "y"]
426                 sort_cols = [var for var in sort_vars if var in self.variables]
427                 sub_data = sub_data.sort_values(sort_cols)
428 
429             if self.estimator is not None:
430                 if "units" in self.variables:
431                     # TODO eventually relax this constraint
432                     err = "estimator must be None when specifying units"
433                     raise ValueError(err)
434                 grouped = sub_data.groupby(grouper, sort=self.sort)
435                 # Could pass as_index=False instead of reset_index,
436                 # but that fails on a corner case with older pandas.
437                 sub_data = grouped.apply(agg, agg_var).reset_index()
438 
439             # TODO this is pretty ad hoc ; see GH2409
440             for var in "xy":
441                 if self._log_scaled(var):
442                     for col in sub_data.filter(regex=f"^{var}"):
443                         sub_data[col] = np.power(10, sub_data[col])
444 
445             # --- Draw the main line(s)
446 
447             if "units" in self.variables:   # XXX why not add to grouping variables?
448                 lines = []
449                 for _, unit_data in sub_data.groupby("units"):
450                     lines.extend(ax.plot(unit_data["x"], unit_data["y"], **kws))
451             else:
452                 lines = ax.plot(sub_data["x"], sub_data["y"], **kws)
453 
454             for line in lines:
455 
456                 if "hue" in sub_vars:
457                     line.set_color(self._hue_map(sub_vars["hue"]))
458 
459                 if "size" in sub_vars:
460                     line.set_linewidth(self._size_map(sub_vars["size"]))
461 
462                 if "style" in sub_vars:
463                     attributes = self._style_map(sub_vars["style"])
464                     if "dashes" in attributes:
465                         line.set_dashes(attributes["dashes"])
466                     if "marker" in attributes:
467                         line.set_marker(attributes["marker"])
468 
469             line_color = line.get_color()
470             line_alpha = line.get_alpha()
471             line_capstyle = line.get_solid_capstyle()
472 
473             # --- Draw the confidence intervals
474 
475             if self.estimator is not None and self.errorbar is not None:
476 
477                 # TODO handling of orientation will need to happen here
478 
479                 if self.err_style == "band":
480 
481                     ax.fill_between(
482                         sub_data["x"], sub_data["ymin"], sub_data["ymax"],
483                         color=line_color, **err_kws
484                     )
485 
486                 elif self.err_style == "bars":
487 
488                     error_deltas = (
489                         sub_data["y"] - sub_data["ymin"],
490                         sub_data["ymax"] - sub_data["y"],
491                     )
492                     ebars = ax.errorbar(
493                         sub_data["x"], sub_data["y"], error_deltas,
494                         linestyle="", color=line_color, alpha=line_alpha,
495                         **err_kws
496                     )
497 
498                     # Set the capstyle properly on the error bars
499                     for obj in ebars.get_children():
500                         if isinstance(obj, mpl.collections.LineCollection):
501                             obj.set_capstyle(line_capstyle)
502 
503         # Finalize the axes details
504         self._add_axis_labels(ax)
505         if self.legend:
506             self.add_legend_data(ax)
507             handles, _ = ax.get_legend_handles_labels()
508             if handles:
509                 legend = ax.legend(title=self.legend_title)
510                 adjust_legend_subtitles(legend)
511 
512 
513 class _ScatterPlotter(_RelationalPlotter):
514 
515     _legend_attributes = ["color", "s", "marker"]
516     _legend_func = "scatter"
517 
518     def __init__(
519         self, *,
520         data=None, variables={},
521         x_bins=None, y_bins=None,
522         estimator=None, ci=None, n_boot=None,
523         alpha=None, x_jitter=None, y_jitter=None,
524         legend=None
525     ):
526 
527         # TODO this is messy, we want the mapping to be agnostic about
528         # the kind of plot to draw, but for the time being we need to set
529         # this information so the SizeMapping can use it
530         self._default_size_range = (
531             np.r_[.5, 2] * np.square(mpl.rcParams["lines.markersize"])
532         )
533 
534         super().__init__(data=data, variables=variables)
535 
536         self.alpha = alpha
537         self.legend = legend
538 
539     def plot(self, ax, kws):
540 
541         # --- Determine the visual attributes of the plot
542 
543         data = self.plot_data.dropna()
544         if data.empty:
545             return
546 
547         # Define the vectors of x and y positions
548         empty = np.full(len(data), np.nan)
549         x = data.get("x", empty)
550         y = data.get("y", empty)
551 
552         if "style" in self.variables:
553             # Use a representative marker so scatter sets the edgecolor
554             # properly for line art markers. We currently enforce either
555             # all or none line art so this works.
556             example_level = self._style_map.levels[0]
557             example_marker = self._style_map(example_level, "marker")
558             kws.setdefault("marker", example_marker)
559 
560         # Conditionally set the marker edgecolor based on whether the marker is "filled"
561         # See https://github.com/matplotlib/matplotlib/issues/17849 for context
562         m = kws.get("marker", mpl.rcParams.get("marker", "o"))
563         if not isinstance(m, mpl.markers.MarkerStyle):
564             # TODO in more recent matplotlib (which?) can pass a MarkerStyle here
565             m = mpl.markers.MarkerStyle(m)
566         if m.is_filled():
567             kws.setdefault("edgecolor", "w")
568 
569         # TODO this makes it impossible to vary alpha with hue which might
570         # otherwise be useful? Should we just pass None?
571         kws["alpha"] = 1 if self.alpha == "auto" else self.alpha
572 
573         # Draw the scatter plot
574         points = ax.scatter(x=x, y=y, **kws)
575 
576         # Apply the mapping from semantic variables to artist attributes
577 
578         if "hue" in self.variables:
579             points.set_facecolors(self._hue_map(data["hue"]))
580 
581         if "size" in self.variables:
582             points.set_sizes(self._size_map(data["size"]))
583 
584         if "style" in self.variables:
585             p = [self._style_map(val, "path") for val in data["style"]]
586             points.set_paths(p)
587 
588         # Apply dependent default attributes
589 
590         if "linewidth" not in kws:
591             sizes = points.get_sizes()
592             points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))
593 
594         # Finalize the axes details
595         self._add_axis_labels(ax)
596         if self.legend:
597             self.add_legend_data(ax)
598             handles, _ = ax.get_legend_handles_labels()
599             if handles:
600                 legend = ax.legend(title=self.legend_title)
601                 adjust_legend_subtitles(legend)
602 
603 
604 def lineplot(
605     data=None, *,
606     x=None, y=None, hue=None, size=None, style=None, units=None,
607     palette=None, hue_order=None, hue_norm=None,
608     sizes=None, size_order=None, size_norm=None,
609     dashes=True, markers=None, style_order=None,
610     estimator="mean", errorbar=("ci", 95), n_boot=1000, seed=None,
611     sort=True, err_style="band", err_kws=None, ci="deprecated",
612     legend="auto", ax=None, **kwargs
613 ):
614 
615     # Handle deprecation of ci parameter
616     errorbar = _deprecate_ci(errorbar, ci)
617 
618     variables = _LinePlotter.get_semantics(locals())
619     p = _LinePlotter(
620         data=data, variables=variables,
621         estimator=estimator, ci=ci, n_boot=n_boot, seed=seed,
622         sort=sort, err_style=err_style, err_kws=err_kws, legend=legend,
623         errorbar=errorbar,
624     )
625 
626     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
627     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
628     p.map_style(markers=markers, dashes=dashes, order=style_order)
629 
630     if ax is None:
631         ax = plt.gca()
632 
633     if style is None and not {"ls", "linestyle"} & set(kwargs):  # XXX
634         kwargs["dashes"] = "" if dashes is None or isinstance(dashes, bool) else dashes
635 
636     if not p.has_xy_data:
637         return ax
638 
639     p._attach(ax)
640 
641     # Other functions have color as an explicit param,
642     # and we should probably do that here too
643     color = kwargs.pop("color", kwargs.pop("c", None))
644     kwargs["color"] = _default_color(ax.plot, hue, color, kwargs)
645 
646     p.plot(ax, kwargs)
647     return ax
648 
649 
650 lineplot.__doc__ = """\
651 Draw a line plot with possibility of several semantic groupings.
652 
653 {narrative.main_api}
654 
655 {narrative.relational_semantic}
656 
657 By default, the plot aggregates over multiple ``y`` values at each value of
658 ``x`` and shows an estimate of the central tendency and a confidence
659 interval for that estimate.
660 
661 Parameters
662 ----------
663 {params.core.data}
664 {params.core.xy}
665 hue : vector or key in ``data``
666     Grouping variable that will produce lines with different colors.
667     Can be either categorical or numeric, although color mapping will
668     behave differently in latter case.
669 size : vector or key in ``data``
670     Grouping variable that will produce lines with different widths.
671     Can be either categorical or numeric, although size mapping will
672     behave differently in latter case.
673 style : vector or key in ``data``
674     Grouping variable that will produce lines with different dashes
675     and/or markers. Can have a numeric dtype but will always be treated
676     as categorical.
677 {params.rel.units}
678 {params.core.palette}
679 {params.core.hue_order}
680 {params.core.hue_norm}
681 {params.rel.sizes}
682 {params.rel.size_order}
683 {params.rel.size_norm}
684 {params.rel.dashes}
685 {params.rel.markers}
686 {params.rel.style_order}
687 {params.rel.estimator}
688 {params.stat.errorbar}
689 {params.rel.n_boot}
690 {params.rel.seed}
691 sort : boolean
692     If True, the data will be sorted by the x and y variables, otherwise
693     lines will connect points in the order they appear in the dataset.
694 err_style : "band" or "bars"
695     Whether to draw the confidence intervals with translucent error bands
696     or discrete error bars.
697 err_kws : dict of keyword arguments
698     Additional parameters to control the aesthetics of the error bars. The
699     kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`
700     or :meth:`matplotlib.axes.Axes.errorbar`, depending on ``err_style``.
701 {params.rel.legend}
702 {params.rel.ci}
703 {params.core.ax}
704 kwargs : key, value mappings
705     Other keyword arguments are passed down to
706     :meth:`matplotlib.axes.Axes.plot`.
707 
708 Returns
709 -------
710 {returns.ax}
711 
712 See Also
713 --------
714 {seealso.scatterplot}
715 {seealso.pointplot}
716 
717 Examples
718 --------
719 
720 .. include:: ../docstrings/lineplot.rst
721 
722 """.format(
723     narrative=_relational_narrative,
724     params=_param_docs,
725     returns=_core_docs["returns"],
726     seealso=_core_docs["seealso"],
727 )
728 
729 
730 def scatterplot(
731     data=None, *,
732     x=None, y=None, hue=None, size=None, style=None,
733     palette=None, hue_order=None, hue_norm=None,
734     sizes=None, size_order=None, size_norm=None,
735     markers=True, style_order=None,
736     x_bins=None, y_bins=None,
737     units=None, estimator=None, ci=95, n_boot=1000,
738     alpha=None, x_jitter=None, y_jitter=None,
739     legend="auto", ax=None,
740     **kwargs
741 ):
742 
743     variables = _ScatterPlotter.get_semantics(locals())
744     p = _ScatterPlotter(
745         data=data, variables=variables,
746         x_bins=x_bins, y_bins=y_bins,
747         estimator=estimator, ci=ci, n_boot=n_boot,
748         alpha=alpha, x_jitter=x_jitter, y_jitter=y_jitter, legend=legend,
749     )
750 
751     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
752     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
753     p.map_style(markers=markers, order=style_order)
754 
755     if ax is None:
756         ax = plt.gca()
757 
758     if not p.has_xy_data:
759         return ax
760 
761     p._attach(ax)
762 
763     # Other functions have color as an explicit param,
764     # and we should probably do that here too
765     color = kwargs.pop("color", None)
766     kwargs["color"] = _default_color(ax.scatter, hue, color, kwargs)
767 
768     p.plot(ax, kwargs)
769 
770     return ax
771 
772 
773 scatterplot.__doc__ = """\
774 Draw a scatter plot with possibility of several semantic groupings.
775 
776 {narrative.main_api}
777 
778 {narrative.relational_semantic}
779 
780 Parameters
781 ----------
782 {params.core.data}
783 {params.core.xy}
784 hue : vector or key in ``data``
785     Grouping variable that will produce points with different colors.
786     Can be either categorical or numeric, although color mapping will
787     behave differently in latter case.
788 size : vector or key in ``data``
789     Grouping variable that will produce points with different sizes.
790     Can be either categorical or numeric, although size mapping will
791     behave differently in latter case.
792 style : vector or key in ``data``
793     Grouping variable that will produce points with different markers.
794     Can have a numeric dtype but will always be treated as categorical.
795 {params.core.palette}
796 {params.core.hue_order}
797 {params.core.hue_norm}
798 {params.rel.sizes}
799 {params.rel.size_order}
800 {params.rel.size_norm}
801 {params.rel.markers}
802 {params.rel.style_order}
803 {{x,y}}_bins : lists or arrays or functions
804     *Currently non-functional.*
805 {params.rel.units}
806     *Currently non-functional.*
807 {params.rel.estimator}
808     *Currently non-functional.*
809 {params.rel.ci}
810     *Currently non-functional.*
811 {params.rel.n_boot}
812     *Currently non-functional.*
813 alpha : float
814     Proportional opacity of the points.
815 {{x,y}}_jitter : booleans or floats
816     *Currently non-functional.*
817 {params.rel.legend}
818 {params.core.ax}
819 kwargs : key, value mappings
820     Other keyword arguments are passed down to
821     :meth:`matplotlib.axes.Axes.scatter`.
822 
823 Returns
824 -------
825 {returns.ax}
826 
827 See Also
828 --------
829 {seealso.lineplot}
830 {seealso.stripplot}
831 {seealso.swarmplot}
832 
833 Examples
834 --------
835 
836 .. include:: ../docstrings/scatterplot.rst
837 
838 """.format(
839     narrative=_relational_narrative,
840     params=_param_docs,
841     returns=_core_docs["returns"],
842     seealso=_core_docs["seealso"],
843 )
844 
845 
846 def relplot(
847     data=None, *,
848     x=None, y=None, hue=None, size=None, style=None, units=None,
849     row=None, col=None, col_wrap=None, row_order=None, col_order=None,
850     palette=None, hue_order=None, hue_norm=None,
851     sizes=None, size_order=None, size_norm=None,
852     markers=None, dashes=None, style_order=None,
853     legend="auto", kind="scatter", height=5, aspect=1, facet_kws=None,
854     **kwargs
855 ):
856 
857     if kind == "scatter":
858 
859         plotter = _ScatterPlotter
860         func = scatterplot
861         markers = True if markers is None else markers
862 
863     elif kind == "line":
864 
865         plotter = _LinePlotter
866         func = lineplot
867         dashes = True if dashes is None else dashes
868 
869     else:
870         err = f"Plot kind {kind} not recognized"
871         raise ValueError(err)
872 
873     # Check for attempt to plot onto specific axes and warn
874     if "ax" in kwargs:
875         msg = (
876             "relplot is a figure-level function and does not accept "
877             "the `ax` parameter. You may wish to try {}".format(kind + "plot")
878         )
879         warnings.warn(msg, UserWarning)
880         kwargs.pop("ax")
881 
882     # Use the full dataset to map the semantics
883     p = plotter(
884         data=data,
885         variables=plotter.get_semantics(locals()),
886         legend=legend,
887     )
888     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
889     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
890     p.map_style(markers=markers, dashes=dashes, order=style_order)
891 
892     # Extract the semantic mappings
893     if "hue" in p.variables:
894         palette = p._hue_map.lookup_table
895         hue_order = p._hue_map.levels
896         hue_norm = p._hue_map.norm
897     else:
898         palette = hue_order = hue_norm = None
899 
900     if "size" in p.variables:
901         sizes = p._size_map.lookup_table
902         size_order = p._size_map.levels
903         size_norm = p._size_map.norm
904 
905     if "style" in p.variables:
906         style_order = p._style_map.levels
907         if markers:
908             markers = {k: p._style_map(k, "marker") for k in style_order}
909         else:
910             markers = None
911         if dashes:
912             dashes = {k: p._style_map(k, "dashes") for k in style_order}
913         else:
914             dashes = None
915     else:
916         markers = dashes = style_order = None
917 
918     # Now extract the data that would be used to draw a single plot
919     variables = p.variables
920     plot_data = p.plot_data
921     plot_semantics = p.semantics
922 
923     # Define the common plotting parameters
924     plot_kws = dict(
925         palette=palette, hue_order=hue_order, hue_norm=hue_norm,
926         sizes=sizes, size_order=size_order, size_norm=size_norm,
927         markers=markers, dashes=dashes, style_order=style_order,
928         legend=False,
929     )
930     plot_kws.update(kwargs)
931     if kind == "scatter":
932         plot_kws.pop("dashes")
933 
934     # Add the grid semantics onto the plotter
935     grid_semantics = "row", "col"
936     p.semantics = plot_semantics + grid_semantics
937     p.assign_variables(
938         data=data,
939         variables=dict(
940             x=x, y=y,
941             hue=hue, size=size, style=style, units=units,
942             row=row, col=col,
943         ),
944     )
945 
946     # Define the named variables for plotting on each facet
947     # Rename the variables with a leading underscore to avoid
948     # collisions with faceting variable names
949     plot_variables = {v: f"_{v}" for v in variables}
950     plot_kws.update(plot_variables)
951 
952     # Pass the row/col variables to FacetGrid with their original
953     # names so that the axes titles render correctly
954     for var in ["row", "col"]:
955         # Handle faceting variables that lack name information
956         if var in p.variables and p.variables[var] is None:
957             p.variables[var] = f"_{var}_"
958     grid_kws = {v: p.variables.get(v) for v in grid_semantics}
959 
960     # Rename the columns of the plot_data structure appropriately
961     new_cols = plot_variables.copy()
962     new_cols.update(grid_kws)
963     full_data = p.plot_data.rename(columns=new_cols)
964 
965     # Set up the FacetGrid object
966     facet_kws = {} if facet_kws is None else facet_kws.copy()
967     g = FacetGrid(
968         data=full_data.dropna(axis=1, how="all"),
969         **grid_kws,
970         col_wrap=col_wrap, row_order=row_order, col_order=col_order,
971         height=height, aspect=aspect, dropna=False,
972         **facet_kws
973     )
974 
975     # Draw the plot
976     g.map_dataframe(func, **plot_kws)
977 
978     # Label the axes, using the original variables
979     g.set(xlabel=variables.get("x"), ylabel=variables.get("y"))
980 
981     # Show the legend
982     if legend:
983         # Replace the original plot data so the legend uses
984         # numeric data with the correct type
985         p.plot_data = plot_data
986         p.add_legend_data(g.axes.flat[0])
987         if p.legend_data:
988             g.add_legend(legend_data=p.legend_data,
989                          label_order=p.legend_order,
990                          title=p.legend_title,
991                          adjust_subtitles=True)
992 
993     # Rename the columns of the FacetGrid's `data` attribute
994     # to match the original column names
995     orig_cols = {
996         f"_{k}": f"_{k}_" if v is None else v for k, v in variables.items()
997     }
998     grid_data = g.data.rename(columns=orig_cols)
999     if data is not None and (x is not None or y is not None):
1000         if not isinstance(data, pd.DataFrame):
1001             data = pd.DataFrame(data)
1002         g.data = pd.merge(
1003             data,
1004             grid_data[grid_data.columns.difference(data.columns)],
1005             left_index=True,
1006             right_index=True,
1007         )
1008     else:
1009         g.data = grid_data
1010 
1011     return g
1012 
1013 
1014 relplot.__doc__ = """\
1015 Figure-level interface for drawing relational plots onto a FacetGrid.
1016 
1017 This function provides access to several different axes-level functions
1018 that show the relationship between two variables with semantic mappings
1019 of subsets. The ``kind`` parameter selects the underlying axes-level
1020 function to use:
1021 
1022 - :func:`scatterplot` (with ``kind="scatter"``; the default)
1023 - :func:`lineplot` (with ``kind="line"``)
1024 
1025 Extra keyword arguments are passed to the underlying function, so you
1026 should refer to the documentation for each to see kind-specific options.
1027 
1028 {narrative.main_api}
1029 
1030 {narrative.relational_semantic}
1031 
1032 After plotting, the :class:`FacetGrid` with the plot is returned and can
1033 be used directly to tweak supporting plot details or add other layers.
1034 
1035 Note that, unlike when using the underlying plotting functions directly,
1036 data must be passed in a long-form DataFrame with variables specified by
1037 passing strings to ``x``, ``y``, and other parameters.
1038 
1039 Parameters
1040 ----------
1041 {params.core.data}
1042 {params.core.xy}
1043 hue : vector or key in ``data``
1044     Grouping variable that will produce elements with different colors.
1045     Can be either categorical or numeric, although color mapping will
1046     behave differently in latter case.
1047 size : vector or key in ``data``
1048     Grouping variable that will produce elements with different sizes.
1049     Can be either categorical or numeric, although size mapping will
1050     behave differently in latter case.
1051 style : vector or key in ``data``
1052     Grouping variable that will produce elements with different styles.
1053     Can have a numeric dtype but will always be treated as categorical.
1054 {params.rel.units}
1055 {params.facets.rowcol}
1056 {params.facets.col_wrap}
1057 row_order, col_order : lists of strings
1058     Order to organize the rows and/or columns of the grid in, otherwise the
1059     orders are inferred from the data objects.
1060 {params.core.palette}
1061 {params.core.hue_order}
1062 {params.core.hue_norm}
1063 {params.rel.sizes}
1064 {params.rel.size_order}
1065 {params.rel.size_norm}
1066 {params.rel.style_order}
1067 {params.rel.dashes}
1068 {params.rel.markers}
1069 {params.rel.legend}
1070 kind : string
1071     Kind of plot to draw, corresponding to a seaborn relational plot.
1072     Options are {{``scatter`` and ``line``}}.
1073 {params.facets.height}
1074 {params.facets.aspect}
1075 facet_kws : dict
1076     Dictionary of other keyword arguments to pass to :class:`FacetGrid`.
1077 kwargs : key, value pairings
1078     Other keyword arguments are passed through to the underlying plotting
1079     function.
1080 
1081 Returns
1082 -------
1083 {returns.facetgrid}
1084 
1085 Examples
1086 --------
1087 
1088 .. include:: ../docstrings/relplot.rst
1089 
1090 """.format(
1091     narrative=_relational_narrative,
1092     params=_param_docs,
1093     returns=_core_docs["returns"],
1094     seealso=_core_docs["seealso"],
1095 )

</code><intended_behavior>The methods for plotting that accept a `hue` parameter need to robustly handle different types of inputs for `hue`, including direct lists or Series from a DataFrame, ensuring that categorical data is handled consistently. If the issue is rooted in how these methods interpret or utilize the `hue` parameter when passed from `PairGrid.map`, adjustments should ensure that `hue` data is properly normalized and mapped to the color palette without causing exceptions. This might require additional checks or preprocessing steps for `hue` values within these plotting methods or a more sophisticated method of passing data between `PairGrid.map` and the plotting functions to ensure they receive `hue` in the expected format.</intended_behavior>]
2025-10-15 08:02:55.811 | INFO     | Search completed. Bug locations: [<file>seaborn/axisgrid.py</file>
<class>PairGrid</class>
<method>map</method>
<code>
1320     def map(self, func, **kwargs):
1321         """Plot with the same function in every subplot.
1322 
1323         Parameters
1324         ----------
1325         func : callable plotting function
1326             Must take x, y arrays as positional arguments and draw onto the
1327             "currently active" matplotlib Axes. Also needs to accept kwargs
1328             called ``color`` and  ``label``.
1329 
1330         """
1331         row_indices, col_indices = np.indices(self.axes.shape)
1332         indices = zip(row_indices.flat, col_indices.flat)
1333         self._map_bivariate(func, indices, **kwargs)
1334 
1335         return self

</code><intended_behavior>The `map` method should correctly handle the `hue` parameter regardless if it is numeric, categorical, or a DataFrame column. The method should ensure that the `hue` parameter passed to the plotting functions (like `scatterplot` or `regplot`) is processed in such a manner that it does not raise KeyError or TypeError when categorical data is used. This might involve validating or transforming the `hue` data before it is utilized by the plotting functions or ensuring that seaborn's internal mechanisms for handling hues (e.g., normalization, lookup) are compatible with how `map` is invoking those functions.</intended_behavior>, <file>seaborn/axisgrid.py</file>
<class>PairGrid</class>
<method>None</method>
<code>
1124 class PairGrid(Grid):
1125     """Subplot grid for plotting pairwise relationships in a dataset.
1126 
1127     This object maps each variable in a dataset onto a column and row in a
1128     grid of multiple axes. Different axes-level plotting functions can be
1129     used to draw bivariate plots in the upper and lower triangles, and the
1130     the marginal distribution of each variable can be shown on the diagonal.
1131 
1132     Several different common plots can be generated in a single line using
1133     :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.
1134 
1135     See the :ref:`tutorial <grid_tutorial>` for more information.
1136 
1137     """
1138     def __init__(
1139         self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,
1140         hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,
1141         height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False, size=None
1142     ):
1143         """Initialize the plot figure and PairGrid object.
1144 
1145         Parameters
1146         ----------
1147         data : DataFrame
1148             Tidy (long-form) dataframe where each column is a variable and
1149             each row is an observation.
1150         hue : string (variable name)
1151             Variable in ``data`` to map plot aspects to different colors. This
1152             variable will be excluded from the default x and y variables.
1153         vars : list of variable names
1154             Variables within ``data`` to use, otherwise use every column with
1155             a numeric datatype.
1156         {x, y}_vars : lists of variable names
1157             Variables within ``data`` to use separately for the rows and
1158             columns of the figure; i.e. to make a non-square plot.
1159         hue_order : list of strings
1160             Order for the levels of the hue variable in the palette
1161         palette : dict or seaborn color palette
1162             Set of colors for mapping the ``hue`` variable. If a dict, keys
1163             should be values  in the ``hue`` variable.
1164         hue_kws : dictionary of param -> list of values mapping
1165             Other keyword arguments to insert into the plotting call to let
1166             other plot attributes vary across levels of the hue variable (e.g.
1167             the markers in a scatterplot).
1168         corner : bool
1169             If True, don't add axes to the upper (off-diagonal) triangle of the
1170             grid, making this a "corner" plot.
1171         height : scalar
1172             Height (in inches) of each facet.
1173         aspect : scalar
1174             Aspect * height gives the width (in inches) of each facet.
1175         layout_pad : scalar
1176             Padding between axes; passed to ``fig.tight_layout``.
1177         despine : boolean
1178             Remove the top and right spines from the plots.
1179         dropna : boolean
1180             Drop missing values from the data before plotting.
1181 
1182         See Also
1183         --------
1184         pairplot : Easily drawing common uses of :class:`PairGrid`.
1185         FacetGrid : Subplot grid for plotting conditional relationships.
1186 
1187         Examples
1188         --------
1189 
1190         .. include:: ../docstrings/PairGrid.rst
1191 
1192         """
1193 
1194         super().__init__()
1195 
1196         # Handle deprecations
1197         if size is not None:
1198             height = size
1199             msg = ("The `size` parameter has been renamed to `height`; "
1200                    "please update your code.")
1201             warnings.warn(UserWarning(msg))
1202 
1203         # Sort out the variables that define the grid
1204         numeric_cols = self._find_numeric_cols(data)
1205         if hue in numeric_cols:
1206             numeric_cols.remove(hue)
1207         if vars is not None:
1208             x_vars = list(vars)
1209             y_vars = list(vars)
1210         if x_vars is None:
1211             x_vars = numeric_cols
1212         if y_vars is None:
1213             y_vars = numeric_cols
1214 
1215         if np.isscalar(x_vars):
1216             x_vars = [x_vars]
1217         if np.isscalar(y_vars):
1218             y_vars = [y_vars]
1219 
1220         self.x_vars = x_vars = list(x_vars)
1221         self.y_vars = y_vars = list(y_vars)
1222         self.square_grid = self.x_vars == self.y_vars
1223 
1224         if not x_vars:
1225             raise ValueError("No variables found for grid columns.")
1226         if not y_vars:
1227             raise ValueError("No variables found for grid rows.")
1228 
1229         # Create the figure and the array of subplots
1230         figsize = len(x_vars) * height * aspect, len(y_vars) * height
1231 
1232         # Disable autolayout so legend_out works
1233         with mpl.rc_context({"figure.autolayout": False}):
1234             fig = plt.figure(figsize=figsize)
1235 
1236         axes = fig.subplots(len(y_vars), len(x_vars),
1237                             sharex="col", sharey="row",
1238                             squeeze=False)
1239 
1240         # Possibly remove upper axes to make a corner grid
1241         # Note: setting up the axes is usually the most time-intensive part
1242         # of using the PairGrid. We are foregoing the speed improvement that
1243         # we would get by just not setting up the hidden axes so that we can
1244         # avoid implementing fig.subplots ourselves. But worth thinking about.
1245         self._corner = corner
1246         if corner:
1247             hide_indices = np.triu_indices_from(axes, 1)
1248             for i, j in zip(*hide_indices):
1249                 axes[i, j].remove()
1250                 axes[i, j] = None
1251 
1252         self._figure = fig
1253         self.axes = axes
1254         self.data = data
1255 
1256         # Save what we are going to do with the diagonal
1257         self.diag_sharey = diag_sharey
1258         self.diag_vars = None
1259         self.diag_axes = None
1260 
1261         self._dropna = dropna
1262 
1263         # Label the axes
1264         self._add_axis_labels()
1265 
1266         # Sort out the hue variable
1267         self._hue_var = hue
1268         if hue is None:
1269             self.hue_names = hue_order = ["_nolegend_"]
1270             self.hue_vals = pd.Series(["_nolegend_"] * len(data),
1271                                       index=data.index)
1272         else:
1273             # We need hue_order and hue_names because the former is used to control
1274             # the order of drawing and the latter is used to control the order of
1275             # the legend. hue_names can become string-typed while hue_order must
1276             # retain the type of the input data. This is messy but results from
1277             # the fact that PairGrid can implement the hue-mapping logic itself
1278             # (and was originally written exclusively that way) but now can delegate
1279             # to the axes-level functions, while always handling legend creation.
1280             # See GH2307
1281             hue_names = hue_order = categorical_order(data[hue], hue_order)
1282             if dropna:
1283                 # Filter NA from the list of unique hue names
1284                 hue_names = list(filter(pd.notnull, hue_names))
1285             self.hue_names = hue_names
1286             self.hue_vals = data[hue]
1287 
1288         # Additional dict of kwarg -> list of values for mapping the hue var
1289         self.hue_kws = hue_kws if hue_kws is not None else {}
1290 
1291         self._orig_palette = palette
1292         self._hue_order = hue_order
1293         self.palette = self._get_palette(data, hue, hue_order, palette)
1294         self._legend_data = {}
1295 
1296         # Make the plot look nice
1297         for ax in axes[:-1, :].flat:
1298             if ax is None:
1299                 continue
1300             for label in ax.get_xticklabels():
1301                 label.set_visible(False)
1302             ax.xaxis.offsetText.set_visible(False)
1303             ax.xaxis.label.set_visible(False)
1304 
1305         for ax in axes[:, 1:].flat:
1306             if ax is None:
1307                 continue
1308             for label in ax.get_yticklabels():
1309                 label.set_visible(False)
1310             ax.yaxis.offsetText.set_visible(False)
1311             ax.yaxis.label.set_visible(False)
1312 
1313         self._tight_layout_rect = [.01, .01, .99, .99]
1314         self._tight_layout_pad = layout_pad
1315         self._despine = despine
1316         if despine:
1317             utils.despine(fig=fig)
1318         self.tight_layout(pad=layout_pad)
1319 
1320     def map(self, func, **kwargs):
1321         """Plot with the same function in every subplot.
1322 
1323         Parameters
1324         ----------
1325         func : callable plotting function
1326             Must take x, y arrays as positional arguments and draw onto the
1327             "currently active" matplotlib Axes. Also needs to accept kwargs
1328             called ``color`` and  ``label``.
1329 
1330         """
1331         row_indices, col_indices = np.indices(self.axes.shape)
1332         indices = zip(row_indices.flat, col_indices.flat)
1333         self._map_bivariate(func, indices, **kwargs)
1334 
1335         return self
1336 
1337     def map_lower(self, func, **kwargs):
1338         """Plot with a bivariate function on the lower diagonal subplots.
1339 
1340         Parameters
1341         ----------
1342         func : callable plotting function
1343             Must take x, y arrays as positional arguments and draw onto the
1344             "currently active" matplotlib Axes. Also needs to accept kwargs
1345             called ``color`` and  ``label``.
1346 
1347         """
1348         indices = zip(*np.tril_indices_from(self.axes, -1))
1349         self._map_bivariate(func, indices, **kwargs)
1350         return self
1351 
1352     def map_upper(self, func, **kwargs):
1353         """Plot with a bivariate function on the upper diagonal subplots.
1354 
1355         Parameters
1356         ----------
1357         func : callable plotting function
1358             Must take x, y arrays as positional arguments and draw onto the
1359             "currently active" matplotlib Axes. Also needs to accept kwargs
1360             called ``color`` and  ``label``.
1361 
1362         """
1363         indices = zip(*np.triu_indices_from(self.axes, 1))
1364         self._map_bivariate(func, indices, **kwargs)
1365         return self
1366 
1367     def map_offdiag(self, func, **kwargs):
1368         """Plot with a bivariate function on the off-diagonal subplots.
1369 
1370         Parameters
1371         ----------
1372         func : callable plotting function
1373             Must take x, y arrays as positional arguments and draw onto the
1374             "currently active" matplotlib Axes. Also needs to accept kwargs
1375             called ``color`` and  ``label``.
1376 
1377         """
1378         if self.square_grid:
1379             self.map_lower(func, **kwargs)
1380             if not self._corner:
1381                 self.map_upper(func, **kwargs)
1382         else:
1383             indices = []
1384             for i, (y_var) in enumerate(self.y_vars):
1385                 for j, (x_var) in enumerate(self.x_vars):
1386                     if x_var != y_var:
1387                         indices.append((i, j))
1388             self._map_bivariate(func, indices, **kwargs)
1389         return self
1390 
1391     def map_diag(self, func, **kwargs):
1392         """Plot with a univariate function on each diagonal subplot.
1393 
1394         Parameters
1395         ----------
1396         func : callable plotting function
1397             Must take an x array as a positional argument and draw onto the
1398             "currently active" matplotlib Axes. Also needs to accept kwargs
1399             called ``color`` and  ``label``.
1400 
1401         """
1402         # Add special diagonal axes for the univariate plot
1403         if self.diag_axes is None:
1404             diag_vars = []
1405             diag_axes = []
1406             for i, y_var in enumerate(self.y_vars):
1407                 for j, x_var in enumerate(self.x_vars):
1408                     if x_var == y_var:
1409 
1410                         # Make the density axes
1411                         diag_vars.append(x_var)
1412                         ax = self.axes[i, j]
1413                         diag_ax = ax.twinx()
1414                         diag_ax.set_axis_off()
1415                         diag_axes.append(diag_ax)
1416 
1417                         # Work around matplotlib bug
1418                         # https://github.com/matplotlib/matplotlib/issues/15188
1419                         if not plt.rcParams.get("ytick.left", True):
1420                             for tick in ax.yaxis.majorTicks:
1421                                 tick.tick1line.set_visible(False)
1422 
1423                         # Remove main y axis from density axes in a corner plot
1424                         if self._corner:
1425                             ax.yaxis.set_visible(False)
1426                             if self._despine:
1427                                 utils.despine(ax=ax, left=True)
1428                             # TODO add optional density ticks (on the right)
1429                             # when drawing a corner plot?
1430 
1431             if self.diag_sharey and diag_axes:
1432                 # This may change in future matplotlibs
1433                 # See https://github.com/matplotlib/matplotlib/pull/9923
1434                 group = diag_axes[0].get_shared_y_axes()
1435                 for ax in diag_axes[1:]:
1436                     group.join(ax, diag_axes[0])
1437 
1438             self.diag_vars = np.array(diag_vars, np.object_)
1439             self.diag_axes = np.array(diag_axes, np.object_)
1440 
1441         if "hue" not in signature(func).parameters:
1442             return self._map_diag_iter_hue(func, **kwargs)
1443 
1444         # Loop over diagonal variables and axes, making one plot in each
1445         for var, ax in zip(self.diag_vars, self.diag_axes):
1446 
1447             plot_kwargs = kwargs.copy()
1448             if str(func.__module__).startswith("seaborn"):
1449                 plot_kwargs["ax"] = ax
1450             else:
1451                 plt.sca(ax)
1452 
1453             vector = self.data[var]
1454             if self._hue_var is not None:
1455                 hue = self.data[self._hue_var]
1456             else:
1457                 hue = None
1458 
1459             if self._dropna:
1460                 not_na = vector.notna()
1461                 if hue is not None:
1462                     not_na &= hue.notna()
1463                 vector = vector[not_na]
1464                 if hue is not None:
1465                     hue = hue[not_na]
1466 
1467             plot_kwargs.setdefault("hue", hue)
1468             plot_kwargs.setdefault("hue_order", self._hue_order)
1469             plot_kwargs.setdefault("palette", self._orig_palette)
1470             func(x=vector, **plot_kwargs)
1471             ax.legend_ = None
1472 
1473         self._add_axis_labels()
1474         return self
1475 
1476     def _map_diag_iter_hue(self, func, **kwargs):
1477         """Put marginal plot on each diagonal axes, iterating over hue."""
1478         # Plot on each of the diagonal axes
1479         fixed_color = kwargs.pop("color", None)
1480 
1481         for var, ax in zip(self.diag_vars, self.diag_axes):
1482             hue_grouped = self.data[var].groupby(self.hue_vals)
1483 
1484             plot_kwargs = kwargs.copy()
1485             if str(func.__module__).startswith("seaborn"):
1486                 plot_kwargs["ax"] = ax
1487             else:
1488                 plt.sca(ax)
1489 
1490             for k, label_k in enumerate(self._hue_order):
1491 
1492                 # Attempt to get data for this level, allowing for empty
1493                 try:
1494                     data_k = hue_grouped.get_group(label_k)
1495                 except KeyError:
1496                     data_k = pd.Series([], dtype=float)
1497 
1498                 if fixed_color is None:
1499                     color = self.palette[k]
1500                 else:
1501                     color = fixed_color
1502 
1503                 if self._dropna:
1504                     data_k = utils.remove_na(data_k)
1505 
1506                 if str(func.__module__).startswith("seaborn"):
1507                     func(x=data_k, label=label_k, color=color, **plot_kwargs)
1508                 else:
1509                     func(data_k, label=label_k, color=color, **plot_kwargs)
1510 
1511         self._add_axis_labels()
1512 
1513         return self
1514 
1515     def _map_bivariate(self, func, indices, **kwargs):
1516         """Draw a bivariate plot on the indicated axes."""
1517         # This is a hack to handle the fact that new distribution plots don't add
1518         # their artists onto the axes. This is probably superior in general, but
1519         # we'll need a better way to handle it in the axisgrid functions.
1520         from .distributions import histplot, kdeplot
1521         if func is histplot or func is kdeplot:
1522             self._extract_legend_handles = True
1523 
1524         kws = kwargs.copy()  # Use copy as we insert other kwargs
1525         for i, j in indices:
1526             x_var = self.x_vars[j]
1527             y_var = self.y_vars[i]
1528             ax = self.axes[i, j]
1529             if ax is None:  # i.e. we are in corner mode
1530                 continue
1531             self._plot_bivariate(x_var, y_var, ax, func, **kws)
1532         self._add_axis_labels()
1533 
1534         if "hue" in signature(func).parameters:
1535             self.hue_names = list(self._legend_data)
1536 
1537     def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):
1538         """Draw a bivariate plot on the specified axes."""
1539         if "hue" not in signature(func).parameters:
1540             self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)
1541             return
1542 
1543         kwargs = kwargs.copy()
1544         if str(func.__module__).startswith("seaborn"):
1545             kwargs["ax"] = ax
1546         else:
1547             plt.sca(ax)
1548 
1549         if x_var == y_var:
1550             axes_vars = [x_var]
1551         else:
1552             axes_vars = [x_var, y_var]
1553 
1554         if self._hue_var is not None and self._hue_var not in axes_vars:
1555             axes_vars.append(self._hue_var)
1556 
1557         data = self.data[axes_vars]
1558         if self._dropna:
1559             data = data.dropna()
1560 
1561         x = data[x_var]
1562         y = data[y_var]
1563         if self._hue_var is None:
1564             hue = None
1565         else:
1566             hue = data.get(self._hue_var)
1567 
1568         if "hue" not in kwargs:
1569             kwargs.update({
1570                 "hue": hue, "hue_order": self._hue_order, "palette": self._orig_palette,
1571             })
1572         func(x=x, y=y, **kwargs)
1573 
1574         self._update_legend_data(ax)
1575 
1576     def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):
1577         """Draw a bivariate plot while iterating over hue subsets."""
1578         kwargs = kwargs.copy()
1579         if str(func.__module__).startswith("seaborn"):
1580             kwargs["ax"] = ax
1581         else:
1582             plt.sca(ax)
1583 
1584         if x_var == y_var:
1585             axes_vars = [x_var]
1586         else:
1587             axes_vars = [x_var, y_var]
1588 
1589         hue_grouped = self.data.groupby(self.hue_vals)
1590         for k, label_k in enumerate(self._hue_order):
1591 
1592             kws = kwargs.copy()
1593 
1594             # Attempt to get data for this level, allowing for empty
1595             try:
1596                 data_k = hue_grouped.get_group(label_k)
1597             except KeyError:
1598                 data_k = pd.DataFrame(columns=axes_vars,
1599                                       dtype=float)
1600 
1601             if self._dropna:
1602                 data_k = data_k[axes_vars].dropna()
1603 
1604             x = data_k[x_var]
1605             y = data_k[y_var]
1606 
1607             for kw, val_list in self.hue_kws.items():
1608                 kws[kw] = val_list[k]
1609             kws.setdefault("color", self.palette[k])
1610             if self._hue_var is not None:
1611                 kws["label"] = label_k
1612 
1613             if str(func.__module__).startswith("seaborn"):
1614                 func(x=x, y=y, **kws)
1615             else:
1616                 func(x, y, **kws)
1617 
1618         self._update_legend_data(ax)
1619 
1620     def _add_axis_labels(self):
1621         """Add labels to the left and bottom Axes."""
1622         for ax, label in zip(self.axes[-1, :], self.x_vars):
1623             ax.set_xlabel(label)
1624         for ax, label in zip(self.axes[:, 0], self.y_vars):
1625             ax.set_ylabel(label)
1626         if self._corner:
1627             self.axes[0, 0].set_ylabel("")
1628 
1629     def _find_numeric_cols(self, data):
1630         """Find which variables in a DataFrame are numeric."""
1631         numeric_cols = []
1632         for col in data:
1633             if variable_type(data[col]) == "numeric":
1634                 numeric_cols.append(col)
1635         return numeric_cols

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>seaborn/relational.py</file>
<class>None</class>
<method>None</method>
<code>
1 import warnings
2 
3 import numpy as np
4 import pandas as pd
5 import matplotlib as mpl
6 import matplotlib.pyplot as plt
7 
8 from ._oldcore import (
9     VectorPlotter,
10 )
11 from .utils import (
12     locator_to_legend_entries,
13     adjust_legend_subtitles,
14     _default_color,
15     _deprecate_ci,
16 )
17 from ._statistics import EstimateAggregator
18 from .axisgrid import FacetGrid, _facet_docs
19 from ._docstrings import DocstringComponents, _core_docs
20 
21 
22 __all__ = ["relplot", "scatterplot", "lineplot"]
23 
24 
25 _relational_narrative = DocstringComponents(dict(
26 
27     # ---  Introductory prose
28     main_api="""
29 The relationship between ``x`` and ``y`` can be shown for different subsets
30 of the data using the ``hue``, ``size``, and ``style`` parameters. These
31 parameters control what visual semantics are used to identify the different
32 subsets. It is possible to show up to three dimensions independently by
33 using all three semantic types, but this style of plot can be hard to
34 interpret and is often ineffective. Using redundant semantics (i.e. both
35 ``hue`` and ``style`` for the same variable) can be helpful for making
36 graphics more accessible.
37 
38 See the :ref:`tutorial <relational_tutorial>` for more information.
39     """,
40 
41     relational_semantic="""
42 The default treatment of the ``hue`` (and to a lesser extent, ``size``)
43 semantic, if present, depends on whether the variable is inferred to
44 represent "numeric" or "categorical" data. In particular, numeric variables
45 are represented with a sequential colormap by default, and the legend
46 entries show regular "ticks" with values that may or may not exist in the
47 data. This behavior can be controlled through various parameters, as
48 described and illustrated below.
49     """,
50 ))
51 
52 _relational_docs = dict(
53 
54     # --- Shared function parameters
55     data_vars="""
56 x, y : names of variables in ``data`` or vector data
57     Input data variables; must be numeric. Can pass data directly or
58     reference columns in ``data``.
59     """,
60     data="""
61 data : DataFrame, array, or list of arrays
62     Input data structure. If ``x`` and ``y`` are specified as names, this
63     should be a "long-form" DataFrame containing those columns. Otherwise
64     it is treated as "wide-form" data and grouping variables are ignored.
65     See the examples for the various ways this parameter can be specified
66     and the different effects of each.
67     """,
68     palette="""
69 palette : string, list, dict, or matplotlib colormap
70     An object that determines how colors are chosen when ``hue`` is used.
71     It can be the name of a seaborn palette or matplotlib colormap, a list
72     of colors (anything matplotlib understands), a dict mapping levels
73     of the ``hue`` variable to colors, or a matplotlib colormap object.
74     """,
75     hue_order="""
76 hue_order : list
77     Specified order for the appearance of the ``hue`` variable levels,
78     otherwise they are determined from the data. Not relevant when the
79     ``hue`` variable is numeric.
80     """,
81     hue_norm="""
82 hue_norm : tuple or :class:`matplotlib.colors.Normalize` object
83     Normalization in data units for colormap applied to the ``hue``
84     variable when it is numeric. Not relevant if it is categorical.
85     """,
86     sizes="""
87 sizes : list, dict, or tuple
88     An object that determines how sizes are chosen when ``size`` is used.
89     It can always be a list of size values or a dict mapping levels of the
90     ``size`` variable to sizes. When ``size``  is numeric, it can also be
91     a tuple specifying the minimum and maximum size to use such that other
92     values are normalized within this range.
93     """,
94     size_order="""
95 size_order : list
96     Specified order for appearance of the ``size`` variable levels,
97     otherwise they are determined from the data. Not relevant when the
98     ``size`` variable is numeric.
99     """,
100     size_norm="""
101 size_norm : tuple or Normalize object
102     Normalization in data units for scaling plot objects when the
103     ``size`` variable is numeric.
104     """,
105     dashes="""
106 dashes : boolean, list, or dictionary
107     Object determining how to draw the lines for different levels of the
108     ``style`` variable. Setting to ``True`` will use default dash codes, or
109     you can pass a list of dash codes or a dictionary mapping levels of the
110     ``style`` variable to dash codes. Setting to ``False`` will use solid
111     lines for all subsets. Dashes are specified as in matplotlib: a tuple
112     of ``(segment, gap)`` lengths, or an empty string to draw a solid line.
113     """,
114     markers="""
115 markers : boolean, list, or dictionary
116     Object determining how to draw the markers for different levels of the
117     ``style`` variable. Setting to ``True`` will use default markers, or
118     you can pass a list of markers or a dictionary mapping levels of the
119     ``style`` variable to markers. Setting to ``False`` will draw
120     marker-less lines.  Markers are specified as in matplotlib.
121     """,
122     style_order="""
123 style_order : list
124     Specified order for appearance of the ``style`` variable levels
125     otherwise they are determined from the data. Not relevant when the
126     ``style`` variable is numeric.
127     """,
128     units="""
129 units : vector or key in ``data``
130     Grouping variable identifying sampling units. When used, a separate
131     line will be drawn for each unit with appropriate semantics, but no
132     legend entry will be added. Useful for showing distribution of
133     experimental replicates when exact identities are not needed.
134     """,
135     estimator="""
136 estimator : name of pandas method or callable or None
137     Method for aggregating across multiple observations of the ``y``
138     variable at the same ``x`` level. If ``None``, all observations will
139     be drawn.
140     """,
141     ci="""
142 ci : int or "sd" or None
143     Size of the confidence interval to draw when aggregating.
144 
145     .. deprecated:: 0.12.0
146         Use the new `errorbar` parameter for more flexibility.
147 
148     """,
149     n_boot="""
150 n_boot : int
151     Number of bootstraps to use for computing the confidence interval.
152     """,
153     seed="""
154 seed : int, numpy.random.Generator, or numpy.random.RandomState
155     Seed or random number generator for reproducible bootstrapping.
156     """,
157     legend="""
158 legend : "auto", "brief", "full", or False
159     How to draw the legend. If "brief", numeric ``hue`` and ``size``
160     variables will be represented with a sample of evenly spaced values.
161     If "full", every group will get an entry in the legend. If "auto",
162     choose between brief or full representation based on number of levels.
163     If ``False``, no legend data is added and no legend is drawn.
164     """,
165     ax_in="""
166 ax : matplotlib Axes
167     Axes object to draw the plot onto, otherwise uses the current Axes.
168     """,
169     ax_out="""
170 ax : matplotlib Axes
171     Returns the Axes object with the plot drawn onto it.
172     """,
173 
174 )
175 
176 
177 _param_docs = DocstringComponents.from_nested_components(
178     core=_core_docs["params"],
179     facets=DocstringComponents(_facet_docs),
180     rel=DocstringComponents(_relational_docs),
181     stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),
182 )
183 
184 
185 class _RelationalPlotter(VectorPlotter):
186 
187     wide_structure = {
188         "x": "@index", "y": "@values", "hue": "@columns", "style": "@columns",
189     }
190 
191     # TODO where best to define default parameters?
192     sort = True
193 
194     def add_legend_data(self, ax):
195         """Add labeled artists to represent the different plot semantics."""
196         verbosity = self.legend
197         if isinstance(verbosity, str) and verbosity not in ["auto", "brief", "full"]:
198             err = "`legend` must be 'auto', 'brief', 'full', or a boolean."
199             raise ValueError(err)
200         elif verbosity is True:
201             verbosity = "auto"
202 
203         legend_kwargs = {}
204         keys = []
205 
206         # Assign a legend title if there is only going to be one sub-legend,
207         # otherwise, subtitles will be inserted into the texts list with an
208         # invisible handle (which is a hack)
209         titles = {
210             title for title in
211             (self.variables.get(v, None) for v in ["hue", "size", "style"])
212             if title is not None
213         }
214         if len(titles) == 1:
215             legend_title = titles.pop()
216         else:
217             legend_title = ""
218 
219         title_kws = dict(
220             visible=False, color="w", s=0, linewidth=0, marker="", dashes=""
221         )
222 
223         def update(var_name, val_name, **kws):
224 
225             key = var_name, val_name
226             if key in legend_kwargs:
227                 legend_kwargs[key].update(**kws)
228             else:
229                 keys.append(key)
230 
231                 legend_kwargs[key] = dict(**kws)
232 
233         # Define the maximum number of ticks to use for "brief" legends
234         brief_ticks = 6
235 
236         # -- Add a legend for hue semantics
237         brief_hue = self._hue_map.map_type == "numeric" and (
238             verbosity == "brief"
239             or (verbosity == "auto" and len(self._hue_map.levels) > brief_ticks)
240         )
241         if brief_hue:
242             if isinstance(self._hue_map.norm, mpl.colors.LogNorm):
243                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
244             else:
245                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
246             limits = min(self._hue_map.levels), max(self._hue_map.levels)
247             hue_levels, hue_formatted_levels = locator_to_legend_entries(
248                 locator, limits, self.plot_data["hue"].infer_objects().dtype
249             )
250         elif self._hue_map.levels is None:
251             hue_levels = hue_formatted_levels = []
252         else:
253             hue_levels = hue_formatted_levels = self._hue_map.levels
254 
255         # Add the hue semantic subtitle
256         if not legend_title and self.variables.get("hue", None) is not None:
257             update((self.variables["hue"], "title"),
258                    self.variables["hue"], **title_kws)
259 
260         # Add the hue semantic labels
261         for level, formatted_level in zip(hue_levels, hue_formatted_levels):
262             if level is not None:
263                 color = self._hue_map(level)
264                 update(self.variables["hue"], formatted_level, color=color)
265 
266         # -- Add a legend for size semantics
267         brief_size = self._size_map.map_type == "numeric" and (
268             verbosity == "brief"
269             or (verbosity == "auto" and len(self._size_map.levels) > brief_ticks)
270         )
271         if brief_size:
272             # Define how ticks will interpolate between the min/max data values
273             if isinstance(self._size_map.norm, mpl.colors.LogNorm):
274                 locator = mpl.ticker.LogLocator(numticks=brief_ticks)
275             else:
276                 locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)
277             # Define the min/max data values
278             limits = min(self._size_map.levels), max(self._size_map.levels)
279             size_levels, size_formatted_levels = locator_to_legend_entries(
280                 locator, limits, self.plot_data["size"].infer_objects().dtype
281             )
282         elif self._size_map.levels is None:
283             size_levels = size_formatted_levels = []
284         else:
285             size_levels = size_formatted_levels = self._size_map.levels
286 
287         # Add the size semantic subtitle
288         if not legend_title and self.variables.get("size", None) is not None:
289             update((self.variables["size"], "title"),
290                    self.variables["size"], **title_kws)
291 
292         # Add the size semantic labels
293         for level, formatted_level in zip(size_levels, size_formatted_levels):
294             if level is not None:
295                 size = self._size_map(level)
296                 update(
297                     self.variables["size"],
298                     formatted_level,
299                     linewidth=size,
300                     s=size,
301                 )
302 
303         # -- Add a legend for style semantics
304 
305         # Add the style semantic title
306         if not legend_title and self.variables.get("style", None) is not None:
307             update((self.variables["style"], "title"),
308                    self.variables["style"], **title_kws)
309 
310         # Add the style semantic labels
311         if self._style_map.levels is not None:
312             for level in self._style_map.levels:
313                 if level is not None:
314                     attrs = self._style_map(level)
315                     update(
316                         self.variables["style"],
317                         level,
318                         marker=attrs.get("marker", ""),
319                         dashes=attrs.get("dashes", ""),
320                     )
321 
322         func = getattr(ax, self._legend_func)
323 
324         legend_data = {}
325         legend_order = []
326 
327         for key in keys:
328 
329             _, label = key
330             kws = legend_kwargs[key]
331             kws.setdefault("color", ".2")
332             use_kws = {}
333             for attr in self._legend_attributes + ["visible"]:
334                 if attr in kws:
335                     use_kws[attr] = kws[attr]
336             artist = func([], [], label=label, **use_kws)
337             if self._legend_func == "plot":
338                 artist = artist[0]
339             legend_data[key] = artist
340             legend_order.append(key)
341 
342         self.legend_title = legend_title
343         self.legend_data = legend_data
344         self.legend_order = legend_order
345 
346 
347 class _LinePlotter(_RelationalPlotter):
348 
349     _legend_attributes = ["color", "linewidth", "marker", "dashes"]
350     _legend_func = "plot"
351 
352     def __init__(
353         self, *,
354         data=None, variables={},
355         estimator=None, ci=None, n_boot=None, seed=None,
356         sort=True, err_style=None, err_kws=None, legend=None,
357         errorbar=None,
358     ):
359 
360         # TODO this is messy, we want the mapping to be agnostic about
361         # the kind of plot to draw, but for the time being we need to set
362         # this information so the SizeMapping can use it
363         self._default_size_range = (
364             np.r_[.5, 2] * mpl.rcParams["lines.linewidth"]
365         )
366 
367         super().__init__(data=data, variables=variables)
368 
369         self.estimator = estimator
370         self.errorbar = errorbar
371         self.ci = ci
372         self.n_boot = n_boot
373         self.seed = seed
374         self.sort = sort
375         self.err_style = err_style
376         self.err_kws = {} if err_kws is None else err_kws
377 
378         self.legend = legend
379 
380     def plot(self, ax, kws):
381         """Draw the plot onto an axes, passing matplotlib kwargs."""
382 
383         # Draw a test plot, using the passed in kwargs. The goal here is to
384         # honor both (a) the current state of the plot cycler and (b) the
385         # specified kwargs on all the lines we will draw, overriding when
386         # relevant with the data semantics. Note that we won't cycle
387         # internally; in other words, if ``hue`` is not used, all elements will
388         # have the same color, but they will have the color that you would have
389         # gotten from the corresponding matplotlib function, and calling the
390         # function will advance the axes property cycle.
391 
392         kws.setdefault("markeredgewidth", kws.pop("mew", .75))
393         kws.setdefault("markeredgecolor", kws.pop("mec", "w"))
394 
395         # Set default error kwargs
396         err_kws = self.err_kws.copy()
397         if self.err_style == "band":
398             err_kws.setdefault("alpha", .2)
399         elif self.err_style == "bars":
400             pass
401         elif self.err_style is not None:
402             err = "`err_style` must be 'band' or 'bars', not {}"
403             raise ValueError(err.format(self.err_style))
404 
405         # Initialize the aggregation object
406         agg = EstimateAggregator(
407             self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,
408         )
409 
410         # TODO abstract variable to aggregate over here-ish. Better name?
411         agg_var = "y"
412         grouper = ["x"]
413 
414         # TODO How to handle NA? We don't want NA to propagate through to the
415         # estimate/CI when some values are present, but we would also like
416         # matplotlib to show "gaps" in the line when all values are missing.
417         # This is straightforward absent aggregation, but complicated with it.
418         # If we want to use nas, we need to conditionalize dropna in iter_data.
419 
420         # Loop over the semantic subsets and add to the plot
421         grouping_vars = "hue", "size", "style"
422         for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):
423 
424             if self.sort:
425                 sort_vars = ["units", "x", "y"]
426                 sort_cols = [var for var in sort_vars if var in self.variables]
427                 sub_data = sub_data.sort_values(sort_cols)
428 
429             if self.estimator is not None:
430                 if "units" in self.variables:
431                     # TODO eventually relax this constraint
432                     err = "estimator must be None when specifying units"
433                     raise ValueError(err)
434                 grouped = sub_data.groupby(grouper, sort=self.sort)
435                 # Could pass as_index=False instead of reset_index,
436                 # but that fails on a corner case with older pandas.
437                 sub_data = grouped.apply(agg, agg_var).reset_index()
438 
439             # TODO this is pretty ad hoc ; see GH2409
440             for var in "xy":
441                 if self._log_scaled(var):
442                     for col in sub_data.filter(regex=f"^{var}"):
443                         sub_data[col] = np.power(10, sub_data[col])
444 
445             # --- Draw the main line(s)
446 
447             if "units" in self.variables:   # XXX why not add to grouping variables?
448                 lines = []
449                 for _, unit_data in sub_data.groupby("units"):
450                     lines.extend(ax.plot(unit_data["x"], unit_data["y"], **kws))
451             else:
452                 lines = ax.plot(sub_data["x"], sub_data["y"], **kws)
453 
454             for line in lines:
455 
456                 if "hue" in sub_vars:
457                     line.set_color(self._hue_map(sub_vars["hue"]))
458 
459                 if "size" in sub_vars:
460                     line.set_linewidth(self._size_map(sub_vars["size"]))
461 
462                 if "style" in sub_vars:
463                     attributes = self._style_map(sub_vars["style"])
464                     if "dashes" in attributes:
465                         line.set_dashes(attributes["dashes"])
466                     if "marker" in attributes:
467                         line.set_marker(attributes["marker"])
468 
469             line_color = line.get_color()
470             line_alpha = line.get_alpha()
471             line_capstyle = line.get_solid_capstyle()
472 
473             # --- Draw the confidence intervals
474 
475             if self.estimator is not None and self.errorbar is not None:
476 
477                 # TODO handling of orientation will need to happen here
478 
479                 if self.err_style == "band":
480 
481                     ax.fill_between(
482                         sub_data["x"], sub_data["ymin"], sub_data["ymax"],
483                         color=line_color, **err_kws
484                     )
485 
486                 elif self.err_style == "bars":
487 
488                     error_deltas = (
489                         sub_data["y"] - sub_data["ymin"],
490                         sub_data["ymax"] - sub_data["y"],
491                     )
492                     ebars = ax.errorbar(
493                         sub_data["x"], sub_data["y"], error_deltas,
494                         linestyle="", color=line_color, alpha=line_alpha,
495                         **err_kws
496                     )
497 
498                     # Set the capstyle properly on the error bars
499                     for obj in ebars.get_children():
500                         if isinstance(obj, mpl.collections.LineCollection):
501                             obj.set_capstyle(line_capstyle)
502 
503         # Finalize the axes details
504         self._add_axis_labels(ax)
505         if self.legend:
506             self.add_legend_data(ax)
507             handles, _ = ax.get_legend_handles_labels()
508             if handles:
509                 legend = ax.legend(title=self.legend_title)
510                 adjust_legend_subtitles(legend)
511 
512 
513 class _ScatterPlotter(_RelationalPlotter):
514 
515     _legend_attributes = ["color", "s", "marker"]
516     _legend_func = "scatter"
517 
518     def __init__(
519         self, *,
520         data=None, variables={},
521         x_bins=None, y_bins=None,
522         estimator=None, ci=None, n_boot=None,
523         alpha=None, x_jitter=None, y_jitter=None,
524         legend=None
525     ):
526 
527         # TODO this is messy, we want the mapping to be agnostic about
528         # the kind of plot to draw, but for the time being we need to set
529         # this information so the SizeMapping can use it
530         self._default_size_range = (
531             np.r_[.5, 2] * np.square(mpl.rcParams["lines.markersize"])
532         )
533 
534         super().__init__(data=data, variables=variables)
535 
536         self.alpha = alpha
537         self.legend = legend
538 
539     def plot(self, ax, kws):
540 
541         # --- Determine the visual attributes of the plot
542 
543         data = self.plot_data.dropna()
544         if data.empty:
545             return
546 
547         # Define the vectors of x and y positions
548         empty = np.full(len(data), np.nan)
549         x = data.get("x", empty)
550         y = data.get("y", empty)
551 
552         if "style" in self.variables:
553             # Use a representative marker so scatter sets the edgecolor
554             # properly for line art markers. We currently enforce either
555             # all or none line art so this works.
556             example_level = self._style_map.levels[0]
557             example_marker = self._style_map(example_level, "marker")
558             kws.setdefault("marker", example_marker)
559 
560         # Conditionally set the marker edgecolor based on whether the marker is "filled"
561         # See https://github.com/matplotlib/matplotlib/issues/17849 for context
562         m = kws.get("marker", mpl.rcParams.get("marker", "o"))
563         if not isinstance(m, mpl.markers.MarkerStyle):
564             # TODO in more recent matplotlib (which?) can pass a MarkerStyle here
565             m = mpl.markers.MarkerStyle(m)
566         if m.is_filled():
567             kws.setdefault("edgecolor", "w")
568 
569         # TODO this makes it impossible to vary alpha with hue which might
570         # otherwise be useful? Should we just pass None?
571         kws["alpha"] = 1 if self.alpha == "auto" else self.alpha
572 
573         # Draw the scatter plot
574         points = ax.scatter(x=x, y=y, **kws)
575 
576         # Apply the mapping from semantic variables to artist attributes
577 
578         if "hue" in self.variables:
579             points.set_facecolors(self._hue_map(data["hue"]))
580 
581         if "size" in self.variables:
582             points.set_sizes(self._size_map(data["size"]))
583 
584         if "style" in self.variables:
585             p = [self._style_map(val, "path") for val in data["style"]]
586             points.set_paths(p)
587 
588         # Apply dependent default attributes
589 
590         if "linewidth" not in kws:
591             sizes = points.get_sizes()
592             points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))
593 
594         # Finalize the axes details
595         self._add_axis_labels(ax)
596         if self.legend:
597             self.add_legend_data(ax)
598             handles, _ = ax.get_legend_handles_labels()
599             if handles:
600                 legend = ax.legend(title=self.legend_title)
601                 adjust_legend_subtitles(legend)
602 
603 
604 def lineplot(
605     data=None, *,
606     x=None, y=None, hue=None, size=None, style=None, units=None,
607     palette=None, hue_order=None, hue_norm=None,
608     sizes=None, size_order=None, size_norm=None,
609     dashes=True, markers=None, style_order=None,
610     estimator="mean", errorbar=("ci", 95), n_boot=1000, seed=None,
611     sort=True, err_style="band", err_kws=None, ci="deprecated",
612     legend="auto", ax=None, **kwargs
613 ):
614 
615     # Handle deprecation of ci parameter
616     errorbar = _deprecate_ci(errorbar, ci)
617 
618     variables = _LinePlotter.get_semantics(locals())
619     p = _LinePlotter(
620         data=data, variables=variables,
621         estimator=estimator, ci=ci, n_boot=n_boot, seed=seed,
622         sort=sort, err_style=err_style, err_kws=err_kws, legend=legend,
623         errorbar=errorbar,
624     )
625 
626     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
627     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
628     p.map_style(markers=markers, dashes=dashes, order=style_order)
629 
630     if ax is None:
631         ax = plt.gca()
632 
633     if style is None and not {"ls", "linestyle"} & set(kwargs):  # XXX
634         kwargs["dashes"] = "" if dashes is None or isinstance(dashes, bool) else dashes
635 
636     if not p.has_xy_data:
637         return ax
638 
639     p._attach(ax)
640 
641     # Other functions have color as an explicit param,
642     # and we should probably do that here too
643     color = kwargs.pop("color", kwargs.pop("c", None))
644     kwargs["color"] = _default_color(ax.plot, hue, color, kwargs)
645 
646     p.plot(ax, kwargs)
647     return ax
648 
649 
650 lineplot.__doc__ = """\
651 Draw a line plot with possibility of several semantic groupings.
652 
653 {narrative.main_api}
654 
655 {narrative.relational_semantic}
656 
657 By default, the plot aggregates over multiple ``y`` values at each value of
658 ``x`` and shows an estimate of the central tendency and a confidence
659 interval for that estimate.
660 
661 Parameters
662 ----------
663 {params.core.data}
664 {params.core.xy}
665 hue : vector or key in ``data``
666     Grouping variable that will produce lines with different colors.
667     Can be either categorical or numeric, although color mapping will
668     behave differently in latter case.
669 size : vector or key in ``data``
670     Grouping variable that will produce lines with different widths.
671     Can be either categorical or numeric, although size mapping will
672     behave differently in latter case.
673 style : vector or key in ``data``
674     Grouping variable that will produce lines with different dashes
675     and/or markers. Can have a numeric dtype but will always be treated
676     as categorical.
677 {params.rel.units}
678 {params.core.palette}
679 {params.core.hue_order}
680 {params.core.hue_norm}
681 {params.rel.sizes}
682 {params.rel.size_order}
683 {params.rel.size_norm}
684 {params.rel.dashes}
685 {params.rel.markers}
686 {params.rel.style_order}
687 {params.rel.estimator}
688 {params.stat.errorbar}
689 {params.rel.n_boot}
690 {params.rel.seed}
691 sort : boolean
692     If True, the data will be sorted by the x and y variables, otherwise
693     lines will connect points in the order they appear in the dataset.
694 err_style : "band" or "bars"
695     Whether to draw the confidence intervals with translucent error bands
696     or discrete error bars.
697 err_kws : dict of keyword arguments
698     Additional parameters to control the aesthetics of the error bars. The
699     kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`
700     or :meth:`matplotlib.axes.Axes.errorbar`, depending on ``err_style``.
701 {params.rel.legend}
702 {params.rel.ci}
703 {params.core.ax}
704 kwargs : key, value mappings
705     Other keyword arguments are passed down to
706     :meth:`matplotlib.axes.Axes.plot`.
707 
708 Returns
709 -------
710 {returns.ax}
711 
712 See Also
713 --------
714 {seealso.scatterplot}
715 {seealso.pointplot}
716 
717 Examples
718 --------
719 
720 .. include:: ../docstrings/lineplot.rst
721 
722 """.format(
723     narrative=_relational_narrative,
724     params=_param_docs,
725     returns=_core_docs["returns"],
726     seealso=_core_docs["seealso"],
727 )
728 
729 
730 def scatterplot(
731     data=None, *,
732     x=None, y=None, hue=None, size=None, style=None,
733     palette=None, hue_order=None, hue_norm=None,
734     sizes=None, size_order=None, size_norm=None,
735     markers=True, style_order=None,
736     x_bins=None, y_bins=None,
737     units=None, estimator=None, ci=95, n_boot=1000,
738     alpha=None, x_jitter=None, y_jitter=None,
739     legend="auto", ax=None,
740     **kwargs
741 ):
742 
743     variables = _ScatterPlotter.get_semantics(locals())
744     p = _ScatterPlotter(
745         data=data, variables=variables,
746         x_bins=x_bins, y_bins=y_bins,
747         estimator=estimator, ci=ci, n_boot=n_boot,
748         alpha=alpha, x_jitter=x_jitter, y_jitter=y_jitter, legend=legend,
749     )
750 
751     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
752     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
753     p.map_style(markers=markers, order=style_order)
754 
755     if ax is None:
756         ax = plt.gca()
757 
758     if not p.has_xy_data:
759         return ax
760 
761     p._attach(ax)
762 
763     # Other functions have color as an explicit param,
764     # and we should probably do that here too
765     color = kwargs.pop("color", None)
766     kwargs["color"] = _default_color(ax.scatter, hue, color, kwargs)
767 
768     p.plot(ax, kwargs)
769 
770     return ax
771 
772 
773 scatterplot.__doc__ = """\
774 Draw a scatter plot with possibility of several semantic groupings.
775 
776 {narrative.main_api}
777 
778 {narrative.relational_semantic}
779 
780 Parameters
781 ----------
782 {params.core.data}
783 {params.core.xy}
784 hue : vector or key in ``data``
785     Grouping variable that will produce points with different colors.
786     Can be either categorical or numeric, although color mapping will
787     behave differently in latter case.
788 size : vector or key in ``data``
789     Grouping variable that will produce points with different sizes.
790     Can be either categorical or numeric, although size mapping will
791     behave differently in latter case.
792 style : vector or key in ``data``
793     Grouping variable that will produce points with different markers.
794     Can have a numeric dtype but will always be treated as categorical.
795 {params.core.palette}
796 {params.core.hue_order}
797 {params.core.hue_norm}
798 {params.rel.sizes}
799 {params.rel.size_order}
800 {params.rel.size_norm}
801 {params.rel.markers}
802 {params.rel.style_order}
803 {{x,y}}_bins : lists or arrays or functions
804     *Currently non-functional.*
805 {params.rel.units}
806     *Currently non-functional.*
807 {params.rel.estimator}
808     *Currently non-functional.*
809 {params.rel.ci}
810     *Currently non-functional.*
811 {params.rel.n_boot}
812     *Currently non-functional.*
813 alpha : float
814     Proportional opacity of the points.
815 {{x,y}}_jitter : booleans or floats
816     *Currently non-functional.*
817 {params.rel.legend}
818 {params.core.ax}
819 kwargs : key, value mappings
820     Other keyword arguments are passed down to
821     :meth:`matplotlib.axes.Axes.scatter`.
822 
823 Returns
824 -------
825 {returns.ax}
826 
827 See Also
828 --------
829 {seealso.lineplot}
830 {seealso.stripplot}
831 {seealso.swarmplot}
832 
833 Examples
834 --------
835 
836 .. include:: ../docstrings/scatterplot.rst
837 
838 """.format(
839     narrative=_relational_narrative,
840     params=_param_docs,
841     returns=_core_docs["returns"],
842     seealso=_core_docs["seealso"],
843 )
844 
845 
846 def relplot(
847     data=None, *,
848     x=None, y=None, hue=None, size=None, style=None, units=None,
849     row=None, col=None, col_wrap=None, row_order=None, col_order=None,
850     palette=None, hue_order=None, hue_norm=None,
851     sizes=None, size_order=None, size_norm=None,
852     markers=None, dashes=None, style_order=None,
853     legend="auto", kind="scatter", height=5, aspect=1, facet_kws=None,
854     **kwargs
855 ):
856 
857     if kind == "scatter":
858 
859         plotter = _ScatterPlotter
860         func = scatterplot
861         markers = True if markers is None else markers
862 
863     elif kind == "line":
864 
865         plotter = _LinePlotter
866         func = lineplot
867         dashes = True if dashes is None else dashes
868 
869     else:
870         err = f"Plot kind {kind} not recognized"
871         raise ValueError(err)
872 
873     # Check for attempt to plot onto specific axes and warn
874     if "ax" in kwargs:
875         msg = (
876             "relplot is a figure-level function and does not accept "
877             "the `ax` parameter. You may wish to try {}".format(kind + "plot")
878         )
879         warnings.warn(msg, UserWarning)
880         kwargs.pop("ax")
881 
882     # Use the full dataset to map the semantics
883     p = plotter(
884         data=data,
885         variables=plotter.get_semantics(locals()),
886         legend=legend,
887     )
888     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)
889     p.map_size(sizes=sizes, order=size_order, norm=size_norm)
890     p.map_style(markers=markers, dashes=dashes, order=style_order)
891 
892     # Extract the semantic mappings
893     if "hue" in p.variables:
894         palette = p._hue_map.lookup_table
895         hue_order = p._hue_map.levels
896         hue_norm = p._hue_map.norm
897     else:
898         palette = hue_order = hue_norm = None
899 
900     if "size" in p.variables:
901         sizes = p._size_map.lookup_table
902         size_order = p._size_map.levels
903         size_norm = p._size_map.norm
904 
905     if "style" in p.variables:
906         style_order = p._style_map.levels
907         if markers:
908             markers = {k: p._style_map(k, "marker") for k in style_order}
909         else:
910             markers = None
911         if dashes:
912             dashes = {k: p._style_map(k, "dashes") for k in style_order}
913         else:
914             dashes = None
915     else:
916         markers = dashes = style_order = None
917 
918     # Now extract the data that would be used to draw a single plot
919     variables = p.variables
920     plot_data = p.plot_data
921     plot_semantics = p.semantics
922 
923     # Define the common plotting parameters
924     plot_kws = dict(
925         palette=palette, hue_order=hue_order, hue_norm=hue_norm,
926         sizes=sizes, size_order=size_order, size_norm=size_norm,
927         markers=markers, dashes=dashes, style_order=style_order,
928         legend=False,
929     )
930     plot_kws.update(kwargs)
931     if kind == "scatter":
932         plot_kws.pop("dashes")
933 
934     # Add the grid semantics onto the plotter
935     grid_semantics = "row", "col"
936     p.semantics = plot_semantics + grid_semantics
937     p.assign_variables(
938         data=data,
939         variables=dict(
940             x=x, y=y,
941             hue=hue, size=size, style=style, units=units,
942             row=row, col=col,
943         ),
944     )
945 
946     # Define the named variables for plotting on each facet
947     # Rename the variables with a leading underscore to avoid
948     # collisions with faceting variable names
949     plot_variables = {v: f"_{v}" for v in variables}
950     plot_kws.update(plot_variables)
951 
952     # Pass the row/col variables to FacetGrid with their original
953     # names so that the axes titles render correctly
954     for var in ["row", "col"]:
955         # Handle faceting variables that lack name information
956         if var in p.variables and p.variables[var] is None:
957             p.variables[var] = f"_{var}_"
958     grid_kws = {v: p.variables.get(v) for v in grid_semantics}
959 
960     # Rename the columns of the plot_data structure appropriately
961     new_cols = plot_variables.copy()
962     new_cols.update(grid_kws)
963     full_data = p.plot_data.rename(columns=new_cols)
964 
965     # Set up the FacetGrid object
966     facet_kws = {} if facet_kws is None else facet_kws.copy()
967     g = FacetGrid(
968         data=full_data.dropna(axis=1, how="all"),
969         **grid_kws,
970         col_wrap=col_wrap, row_order=row_order, col_order=col_order,
971         height=height, aspect=aspect, dropna=False,
972         **facet_kws
973     )
974 
975     # Draw the plot
976     g.map_dataframe(func, **plot_kws)
977 
978     # Label the axes, using the original variables
979     g.set(xlabel=variables.get("x"), ylabel=variables.get("y"))
980 
981     # Show the legend
982     if legend:
983         # Replace the original plot data so the legend uses
984         # numeric data with the correct type
985         p.plot_data = plot_data
986         p.add_legend_data(g.axes.flat[0])
987         if p.legend_data:
988             g.add_legend(legend_data=p.legend_data,
989                          label_order=p.legend_order,
990                          title=p.legend_title,
991                          adjust_subtitles=True)
992 
993     # Rename the columns of the FacetGrid's `data` attribute
994     # to match the original column names
995     orig_cols = {
996         f"_{k}": f"_{k}_" if v is None else v for k, v in variables.items()
997     }
998     grid_data = g.data.rename(columns=orig_cols)
999     if data is not None and (x is not None or y is not None):
1000         if not isinstance(data, pd.DataFrame):
1001             data = pd.DataFrame(data)
1002         g.data = pd.merge(
1003             data,
1004             grid_data[grid_data.columns.difference(data.columns)],
1005             left_index=True,
1006             right_index=True,
1007         )
1008     else:
1009         g.data = grid_data
1010 
1011     return g
1012 
1013 
1014 relplot.__doc__ = """\
1015 Figure-level interface for drawing relational plots onto a FacetGrid.
1016 
1017 This function provides access to several different axes-level functions
1018 that show the relationship between two variables with semantic mappings
1019 of subsets. The ``kind`` parameter selects the underlying axes-level
1020 function to use:
1021 
1022 - :func:`scatterplot` (with ``kind="scatter"``; the default)
1023 - :func:`lineplot` (with ``kind="line"``)
1024 
1025 Extra keyword arguments are passed to the underlying function, so you
1026 should refer to the documentation for each to see kind-specific options.
1027 
1028 {narrative.main_api}
1029 
1030 {narrative.relational_semantic}
1031 
1032 After plotting, the :class:`FacetGrid` with the plot is returned and can
1033 be used directly to tweak supporting plot details or add other layers.
1034 
1035 Note that, unlike when using the underlying plotting functions directly,
1036 data must be passed in a long-form DataFrame with variables specified by
1037 passing strings to ``x``, ``y``, and other parameters.
1038 
1039 Parameters
1040 ----------
1041 {params.core.data}
1042 {params.core.xy}
1043 hue : vector or key in ``data``
1044     Grouping variable that will produce elements with different colors.
1045     Can be either categorical or numeric, although color mapping will
1046     behave differently in latter case.
1047 size : vector or key in ``data``
1048     Grouping variable that will produce elements with different sizes.
1049     Can be either categorical or numeric, although size mapping will
1050     behave differently in latter case.
1051 style : vector or key in ``data``
1052     Grouping variable that will produce elements with different styles.
1053     Can have a numeric dtype but will always be treated as categorical.
1054 {params.rel.units}
1055 {params.facets.rowcol}
1056 {params.facets.col_wrap}
1057 row_order, col_order : lists of strings
1058     Order to organize the rows and/or columns of the grid in, otherwise the
1059     orders are inferred from the data objects.
1060 {params.core.palette}
1061 {params.core.hue_order}
1062 {params.core.hue_norm}
1063 {params.rel.sizes}
1064 {params.rel.size_order}
1065 {params.rel.size_norm}
1066 {params.rel.style_order}
1067 {params.rel.dashes}
1068 {params.rel.markers}
1069 {params.rel.legend}
1070 kind : string
1071     Kind of plot to draw, corresponding to a seaborn relational plot.
1072     Options are {{``scatter`` and ``line``}}.
1073 {params.facets.height}
1074 {params.facets.aspect}
1075 facet_kws : dict
1076     Dictionary of other keyword arguments to pass to :class:`FacetGrid`.
1077 kwargs : key, value pairings
1078     Other keyword arguments are passed through to the underlying plotting
1079     function.
1080 
1081 Returns
1082 -------
1083 {returns.facetgrid}
1084 
1085 Examples
1086 --------
1087 
1088 .. include:: ../docstrings/relplot.rst
1089 
1090 """.format(
1091     narrative=_relational_narrative,
1092     params=_param_docs,
1093     returns=_core_docs["returns"],
1094     seealso=_core_docs["seealso"],
1095 )

</code><intended_behavior>The methods for plotting that accept a `hue` parameter need to robustly handle different types of inputs for `hue`, including direct lists or Series from a DataFrame, ensuring that categorical data is handled consistently. If the issue is rooted in how these methods interpret or utilize the `hue` parameter when passed from `PairGrid.map`, adjustments should ensure that `hue` data is properly normalized and mapped to the color palette without causing exceptions. This might require additional checks or preprocessing steps for `hue` values within these plotting methods or a more sophisticated method of passing data between `PairGrid.map` and the plotting functions to ensure they receive `hue` in the expected format.</intended_behavior>]
2025-10-15 08:02:55.812 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 08:02:55.812 | INFO     | Search-only: skipping patch selection
2025-10-15 08:02:55.891 | INFO     | Task mwaskom__seaborn-2848 completed successfully.
2025-10-15 08:02:55.891 | INFO     | No patch generated. You can try running ACR again.
