[
    {
        "rel_file_path": "seaborn/relational.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/relational.py",
        "start": 825,
        "end": 990,
        "class_name": null,
        "method_name": "relplot",
        "code": "825 def relplot(\n826     data=None, *,\n827     x=None, y=None, hue=None, size=None, style=None, units=None,\n828     row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n829     palette=None, hue_order=None, hue_norm=None,\n830     sizes=None, size_order=None, size_norm=None,\n831     markers=None, dashes=None, style_order=None,\n832     legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,\n833     **kwargs\n834 ):\n835 \n836     if kind == \"scatter\":\n837 \n838         plotter = _ScatterPlotter\n839         func = scatterplot\n840         markers = True if markers is None else markers\n841 \n842     elif kind == \"line\":\n843 \n844         plotter = _LinePlotter\n845         func = lineplot\n846         dashes = True if dashes is None else dashes\n847 \n848     else:\n849         err = f\"Plot kind {kind} not recognized\"\n850         raise ValueError(err)\n851 \n852     # Check for attempt to plot onto specific axes and warn\n853     if \"ax\" in kwargs:\n854         msg = (\n855             \"relplot is a figure-level function and does not accept \"\n856             \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")\n857         )\n858         warnings.warn(msg, UserWarning)\n859         kwargs.pop(\"ax\")\n860 \n861     # Use the full dataset to map the semantics\n862     p = plotter(\n863         data=data,\n864         variables=plotter.get_semantics(locals()),\n865         legend=legend,\n866     )\n867     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n868     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n869     p.map_style(markers=markers, dashes=dashes, order=style_order)\n870 \n871     # Extract the semantic mappings\n872     if \"hue\" in p.variables:\n873         palette = p._hue_map.lookup_table\n874         hue_order = p._hue_map.levels\n875         hue_norm = p._hue_map.norm\n876     else:\n877         palette = hue_order = hue_norm = None\n878 \n879     if \"size\" in p.variables:\n880         sizes = p._size_map.lookup_table\n881         size_order = p._size_map.levels\n882         size_norm = p._size_map.norm\n883 \n884     if \"style\" in p.variables:\n885         style_order = p._style_map.levels\n886         if markers:\n887             markers = {k: p._style_map(k, \"marker\") for k in style_order}\n888         else:\n889             markers = None\n890         if dashes:\n891             dashes = {k: p._style_map(k, \"dashes\") for k in style_order}\n892         else:\n893             dashes = None\n894     else:\n895         markers = dashes = style_order = None\n896 \n897     # Now extract the data that would be used to draw a single plot\n898     variables = p.variables\n899     plot_data = p.plot_data\n900     plot_semantics = p.semantics\n901 \n902     # Define the common plotting parameters\n903     plot_kws = dict(\n904         palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n905         sizes=sizes, size_order=size_order, size_norm=size_norm,\n906         markers=markers, dashes=dashes, style_order=style_order,\n907         legend=False,\n908     )\n909     plot_kws.update(kwargs)\n910     if kind == \"scatter\":\n911         plot_kws.pop(\"dashes\")\n912 \n913     # Add the grid semantics onto the plotter\n914     grid_semantics = \"row\", \"col\"\n915     p.semantics = plot_semantics + grid_semantics\n916     p.assign_variables(\n917         data=data,\n918         variables=dict(\n919             x=x, y=y,\n920             hue=hue, size=size, style=style, units=units,\n921             row=row, col=col,\n922         ),\n923     )\n924 \n925     # Define the named variables for plotting on each facet\n926     # Rename the variables with a leading underscore to avoid\n927     # collisions with faceting variable names\n928     plot_variables = {v: f\"_{v}\" for v in variables}\n929     plot_kws.update(plot_variables)\n930 \n931     # Pass the row/col variables to FacetGrid with their original\n932     # names so that the axes titles render correctly\n933     for var in [\"row\", \"col\"]:\n934         # Handle faceting variables that lack name information\n935         if var in p.variables and p.variables[var] is None:\n936             p.variables[var] = f\"_{var}_\"\n937     grid_kws = {v: p.variables.get(v) for v in grid_semantics}\n938 \n939     # Rename the columns of the plot_data structure appropriately\n940     new_cols = plot_variables.copy()\n941     new_cols.update(grid_kws)\n942     full_data = p.plot_data.rename(columns=new_cols)\n943 \n944     # Set up the FacetGrid object\n945     facet_kws = {} if facet_kws is None else facet_kws.copy()\n946     g = FacetGrid(\n947         data=full_data.dropna(axis=1, how=\"all\"),\n948         **grid_kws,\n949         col_wrap=col_wrap, row_order=row_order, col_order=col_order,\n950         height=height, aspect=aspect, dropna=False,\n951         **facet_kws\n952     )\n953 \n954     # Draw the plot\n955     g.map_dataframe(func, **plot_kws)\n956 \n957     # Label the axes, using the original variables\n958     g.set(xlabel=variables.get(\"x\"), ylabel=variables.get(\"y\"))\n959 \n960     # Show the legend\n961     if legend:\n962         # Replace the original plot data so the legend uses\n963         # numeric data with the correct type\n964         p.plot_data = plot_data\n965         p.add_legend_data(g.axes.flat[0])\n966         if p.legend_data:\n967             g.add_legend(legend_data=p.legend_data,\n968                          label_order=p.legend_order,\n969                          title=p.legend_title,\n970                          adjust_subtitles=True)\n971 \n972     # Rename the columns of the FacetGrid's `data` attribute\n973     # to match the original column names\n974     orig_cols = {\n975         f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()\n976     }\n977     grid_data = g.data.rename(columns=orig_cols)\n978     if data is not None and (x is not None or y is not None):\n979         if not isinstance(data, pd.DataFrame):\n980             data = pd.DataFrame(data)\n981         g.data = pd.merge(\n982             data,\n983             grid_data[grid_data.columns.difference(data.columns)],\n984             left_index=True,\n985             right_index=True,\n986         )\n987     else:\n988         g.data = grid_data\n989 \n990     return g\n",
        "intended_behavior": "The method should ensure that plots generated do not have overlapping labels. This could be achieved by introducing or updating existing logic that automatically adjusts label positioning based on the plot's dimensions and the length of the labels themselves. Preserve the functionality that allows for customizable and clear visualization of data across various plot kinds (`scatter`, `line`). Enhancements might include better default settings for label formatting that considers the plot's scale and density or improved interaction with matplotlib for dynamic label adjustments."
    },
    {
        "rel_file_path": "seaborn/axisgrid.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/axisgrid.py",
        "start": 938,
        "end": 1028,
        "class_name": null,
        "method_name": "set_titles",
        "code": "938     def set_titles(self, template=None, row_template=None, col_template=None,\n939                    **kwargs):\n940         \"\"\"Draw titles either above each facet or on the grid margins.\n941 \n942         Parameters\n943         ----------\n944         template : string\n945             Template for all titles with the formatting keys {col_var} and\n946             {col_name} (if using a `col` faceting variable) and/or {row_var}\n947             and {row_name} (if using a `row` faceting variable).\n948         row_template:\n949             Template for the row variable when titles are drawn on the grid\n950             margins. Must have {row_var} and {row_name} formatting keys.\n951         col_template:\n952             Template for the column variable when titles are drawn on the grid\n953             margins. Must have {col_var} and {col_name} formatting keys.\n954 \n955         Returns\n956         -------\n957         self: object\n958             Returns self.\n959 \n960         \"\"\"\n961         args = dict(row_var=self._row_var, col_var=self._col_var)\n962         kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])\n963 \n964         # Establish default templates\n965         if row_template is None:\n966             row_template = \"{row_var} = {row_name}\"\n967         if col_template is None:\n968             col_template = \"{col_var} = {col_name}\"\n969         if template is None:\n970             if self._row_var is None:\n971                 template = col_template\n972             elif self._col_var is None:\n973                 template = row_template\n974             else:\n975                 template = \" | \".join([row_template, col_template])\n976 \n977         row_template = utils.to_utf8(row_template)\n978         col_template = utils.to_utf8(col_template)\n979         template = utils.to_utf8(template)\n980 \n981         if self._margin_titles:\n982 \n983             # Remove any existing title texts\n984             for text in self._margin_titles_texts:\n985                 text.remove()\n986             self._margin_titles_texts = []\n987 \n988             if self.row_names is not None:\n989                 # Draw the row titles on the right edge of the grid\n990                 for i, row_name in enumerate(self.row_names):\n991                     ax = self.axes[i, -1]\n992                     args.update(dict(row_name=row_name))\n993                     title = row_template.format(**args)\n994                     text = ax.annotate(\n995                         title, xy=(1.02, .5), xycoords=\"axes fraction\",\n996                         rotation=270, ha=\"left\", va=\"center\",\n997                         **kwargs\n998                     )\n999                     self._margin_titles_texts.append(text)\n1000 \n1001             if self.col_names is not None:\n1002                 # Draw the column titles  as normal titles\n1003                 for j, col_name in enumerate(self.col_names):\n1004                     args.update(dict(col_name=col_name))\n1005                     title = col_template.format(**args)\n1006                     self.axes[0, j].set_title(title, **kwargs)\n1007 \n1008             return self\n1009 \n1010         # Otherwise title each facet with all the necessary information\n1011         if (self._row_var is not None) and (self._col_var is not None):\n1012             for i, row_name in enumerate(self.row_names):\n1013                 for j, col_name in enumerate(self.col_names):\n1014                     args.update(dict(row_name=row_name, col_name=col_name))\n1015                     title = template.format(**args)\n1016                     self.axes[i, j].set_title(title, **kwargs)\n1017         elif self.row_names is not None and len(self.row_names):\n1018             for i, row_name in enumerate(self.row_names):\n1019                 args.update(dict(row_name=row_name))\n1020                 title = template.format(**args)\n1021                 self.axes[i, 0].set_title(title, **kwargs)\n1022         elif self.col_names is not None and len(self.col_names):\n1023             for i, col_name in enumerate(self.col_names):\n1024                 args.update(dict(col_name=col_name))\n1025                 title = template.format(**args)\n1026                 # Index the flat array so col_wrap works\n1027                 self.axes.flat[i].set_title(title, **kwargs)\n1028         return self\n",
        "intended_behavior": "This method should guarantee that titles are set in a way that avoids overlapping with axis labels or tick marks, especially in dense plot arrangements or when using longer text labels. Potentially, introducing smarter handling of text size, positioning, and even auto-adjusting text wrapping or rotation based on space availability could be beneficial. All these should be done while maintaining the method's purpose of providing flexible, readable titles to the FacetGrid plots."
    },
    {
        "rel_file_path": "seaborn/axisgrid.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.12/seaborn/axisgrid.py",
        "start": 938,
        "end": 1028,
        "class_name": "FacetGrid",
        "method_name": "set_titles",
        "code": "938     def set_titles(self, template=None, row_template=None, col_template=None,\n939                    **kwargs):\n940         \"\"\"Draw titles either above each facet or on the grid margins.\n941 \n942         Parameters\n943         ----------\n944         template : string\n945             Template for all titles with the formatting keys {col_var} and\n946             {col_name} (if using a `col` faceting variable) and/or {row_var}\n947             and {row_name} (if using a `row` faceting variable).\n948         row_template:\n949             Template for the row variable when titles are drawn on the grid\n950             margins. Must have {row_var} and {row_name} formatting keys.\n951         col_template:\n952             Template for the column variable when titles are drawn on the grid\n953             margins. Must have {col_var} and {col_name} formatting keys.\n954 \n955         Returns\n956         -------\n957         self: object\n958             Returns self.\n959 \n960         \"\"\"\n961         args = dict(row_var=self._row_var, col_var=self._col_var)\n962         kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])\n963 \n964         # Establish default templates\n965         if row_template is None:\n966             row_template = \"{row_var} = {row_name}\"\n967         if col_template is None:\n968             col_template = \"{col_var} = {col_name}\"\n969         if template is None:\n970             if self._row_var is None:\n971                 template = col_template\n972             elif self._col_var is None:\n973                 template = row_template\n974             else:\n975                 template = \" | \".join([row_template, col_template])\n976 \n977         row_template = utils.to_utf8(row_template)\n978         col_template = utils.to_utf8(col_template)\n979         template = utils.to_utf8(template)\n980 \n981         if self._margin_titles:\n982 \n983             # Remove any existing title texts\n984             for text in self._margin_titles_texts:\n985                 text.remove()\n986             self._margin_titles_texts = []\n987 \n988             if self.row_names is not None:\n989                 # Draw the row titles on the right edge of the grid\n990                 for i, row_name in enumerate(self.row_names):\n991                     ax = self.axes[i, -1]\n992                     args.update(dict(row_name=row_name))\n993                     title = row_template.format(**args)\n994                     text = ax.annotate(\n995                         title, xy=(1.02, .5), xycoords=\"axes fraction\",\n996                         rotation=270, ha=\"left\", va=\"center\",\n997                         **kwargs\n998                     )\n999                     self._margin_titles_texts.append(text)\n1000 \n1001             if self.col_names is not None:\n1002                 # Draw the column titles  as normal titles\n1003                 for j, col_name in enumerate(self.col_names):\n1004                     args.update(dict(col_name=col_name))\n1005                     title = col_template.format(**args)\n1006                     self.axes[0, j].set_title(title, **kwargs)\n1007 \n1008             return self\n1009 \n1010         # Otherwise title each facet with all the necessary information\n1011         if (self._row_var is not None) and (self._col_var is not None):\n1012             for i, row_name in enumerate(self.row_names):\n1013                 for j, col_name in enumerate(self.col_names):\n1014                     args.update(dict(row_name=row_name, col_name=col_name))\n1015                     title = template.format(**args)\n1016                     self.axes[i, j].set_title(title, **kwargs)\n1017         elif self.row_names is not None and len(self.row_names):\n1018             for i, row_name in enumerate(self.row_names):\n1019                 args.update(dict(row_name=row_name))\n1020                 title = template.format(**args)\n1021                 self.axes[i, 0].set_title(title, **kwargs)\n1022         elif self.col_names is not None and len(self.col_names):\n1023             for i, col_name in enumerate(self.col_names):\n1024                 args.update(dict(col_name=col_name))\n1025                 title = template.format(**args)\n1026                 # Index the flat array so col_wrap works\n1027                 self.axes.flat[i].set_title(title, **kwargs)\n1028         return self\n",
        "intended_behavior": "This method should guarantee that titles are set in a way that avoids overlapping with axis labels or tick marks, especially in dense plot arrangements or when using longer text labels. Potentially, introducing smarter handling of text size, positioning, and even auto-adjusting text wrapping or rotation based on space availability could be beneficial. All these should be done while maintaining the method's purpose of providing flexible, readable titles to the FacetGrid plots."
    }
]