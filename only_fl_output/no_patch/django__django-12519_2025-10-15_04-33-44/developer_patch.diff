diff --git a/django/db/backends/mysql/base.py b/django/db/backends/mysql/base.py
--- a/django/db/backends/mysql/base.py
+++ b/django/db/backends/mysql/base.py
@@ -364,3 +364,10 @@ def mysql_version(self):
     @cached_property
     def mysql_is_mariadb(self):
         return 'mariadb' in self.mysql_server_info.lower()
+
+    @cached_property
+    def sql_mode(self):
+        with self.cursor() as cursor:
+            cursor.execute('SELECT @@sql_mode')
+            sql_mode = cursor.fetchone()
+        return set(sql_mode[0].split(',') if sql_mode else ())
diff --git a/django/db/backends/mysql/validation.py b/django/db/backends/mysql/validation.py
--- a/django/db/backends/mysql/validation.py
+++ b/django/db/backends/mysql/validation.py
@@ -10,11 +10,7 @@ def check(self, **kwargs):
         return issues
 
     def _check_sql_mode(self, **kwargs):
-        with self.connection.cursor() as cursor:
-            cursor.execute("SELECT @@sql_mode")
-            sql_mode = cursor.fetchone()
-        modes = set(sql_mode[0].split(',') if sql_mode else ())
-        if not (modes & {'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES'}):
+        if not (self.connection.sql_mode & {'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES'}):
             return [checks.Warning(
                 "MySQL Strict Mode is not set for database connection '%s'" % self.connection.alias,
                 hint="MySQL's Strict Mode fixes many data integrity problems in MySQL, "
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -6,6 +6,7 @@
 from django.core.exceptions import EmptyResultSet, FieldError
 from django.db import NotSupportedError, connection
 from django.db.models import fields
+from django.db.models.constants import LOOKUP_SEP
 from django.db.models.query_utils import Q
 from django.utils.deconstruct import deconstructible
 from django.utils.functional import cached_property
@@ -559,6 +560,14 @@ def as_sql(self, *args, **kwargs):
             'only be used in a subquery.'
         )
 
+    def resolve_expression(self, *args, **kwargs):
+        col = super().resolve_expression(*args, **kwargs)
+        # FIXME: Rename possibly_multivalued to multivalued and fix detection
+        # for non-multivalued JOINs (e.g. foreign key fields). This should take
+        # into accountÂ only many-to-many and one-to-many relationships.
+        col.possibly_multivalued = LOOKUP_SEP in self.name
+        return col
+
     def relabeled_clone(self, relabels):
         return self
 
@@ -747,6 +756,7 @@ def as_sql(self, compiler, connection):
 class Col(Expression):
 
     contains_column_references = True
+    possibly_multivalued = False
 
     def __init__(self, alias, target, output_field=None):
         if output_field is None:
@@ -1042,7 +1052,10 @@ def as_sql(self, compiler, connection, template=None, **extra_context):
     def get_group_by_cols(self, alias=None):
         if alias:
             return [Ref(alias, self)]
-        return self.query.get_external_cols()
+        external_cols = self.query.get_external_cols()
+        if any(col.possibly_multivalued for col in external_cols):
+            return [self]
+        return external_cols
 
 
 class Exists(Subquery):
