[
    {
        "rel_file_path": "django/db/models/sql/compiler.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/sql/compiler.py",
        "start": 1,
        "end": 1572,
        "class_name": null,
        "method_name": null,
        "code": "1 import collections\n2 import re\n3 from functools import partial\n4 from itertools import chain\n5 \n6 from django.core.exceptions import EmptyResultSet, FieldError\n7 from django.db.models.constants import LOOKUP_SEP\n8 from django.db.models.expressions import OrderBy, Random, RawSQL, Ref, Value\n9 from django.db.models.functions import Cast\n10 from django.db.models.query_utils import Q, select_related_descend\n11 from django.db.models.sql.constants import (\n12     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,\n13 )\n14 from django.db.models.sql.query import Query, get_order_dir\n15 from django.db.transaction import TransactionManagementError\n16 from django.db.utils import DatabaseError, NotSupportedError\n17 from django.utils.functional import cached_property\n18 from django.utils.hashable import make_hashable\n19 \n20 \n21 class SQLCompiler:\n22     def __init__(self, query, connection, using):\n23         self.query = query\n24         self.connection = connection\n25         self.using = using\n26         self.quote_cache = {'*': '*'}\n27         # The select, klass_info, and annotations are needed by QuerySet.iterator()\n28         # these are set as a side-effect of executing the query. Note that we calculate\n29         # separately a list of extra select columns needed for grammatical correctness\n30         # of the query, but these columns are not included in self.select.\n31         self.select = None\n32         self.annotation_col_map = None\n33         self.klass_info = None\n34         # Multiline ordering SQL clause may appear from RawSQL.\n35         self.ordering_parts = re.compile(r'^(.*)\\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)\n36         self._meta_ordering = None\n37 \n38     def setup_query(self):\n39         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n40             self.query.get_initial_alias()\n41         self.select, self.klass_info, self.annotation_col_map = self.get_select()\n42         self.col_count = len(self.select)\n43 \n44     def pre_sql_setup(self):\n45         \"\"\"\n46         Do any necessary class setup immediately prior to producing SQL. This\n47         is for things that can't necessarily be done in __init__ because we\n48         might not have all the pieces in place at that time.\n49         \"\"\"\n50         self.setup_query()\n51         order_by = self.get_order_by()\n52         self.where, self.having = self.query.where.split_having()\n53         extra_select = self.get_extra_select(order_by, self.select)\n54         self.has_extra_select = bool(extra_select)\n55         group_by = self.get_group_by(self.select + extra_select, order_by)\n56         return extra_select, order_by, group_by\n57 \n58     def get_group_by(self, select, order_by):\n59         \"\"\"\n60         Return a list of 2-tuples of form (sql, params).\n61 \n62         The logic of what exactly the GROUP BY clause contains is hard\n63         to describe in other words than \"if it passes the test suite,\n64         then it is correct\".\n65         \"\"\"\n66         # Some examples:\n67         #     SomeModel.objects.annotate(Count('somecol'))\n68         #     GROUP BY: all fields of the model\n69         #\n70         #    SomeModel.objects.values('name').annotate(Count('somecol'))\n71         #    GROUP BY: name\n72         #\n73         #    SomeModel.objects.annotate(Count('somecol')).values('name')\n74         #    GROUP BY: all cols of the model\n75         #\n76         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n77         #    GROUP BY: name, pk\n78         #\n79         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n80         #    GROUP BY: name, pk\n81         #\n82         # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n83         # can't be ever restricted to a smaller set, but additional columns in\n84         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n85         # the end result is that it is impossible to force the query to have\n86         # a chosen GROUP BY clause - you can almost do this by using the form:\n87         #     .values(*wanted_cols).annotate(AnAggregate())\n88         # but any later annotations, extra selects, values calls that\n89         # refer some column outside of the wanted_cols, order_by, or even\n90         # filter calls can alter the GROUP BY clause.\n91 \n92         # The query.group_by is either None (no GROUP BY at all), True\n93         # (group by select fields), or a list of expressions to be added\n94         # to the group by.\n95         if self.query.group_by is None:\n96             return []\n97         expressions = []\n98         if self.query.group_by is not True:\n99             # If the group by is set to a list (by .values() call most likely),\n100             # then we need to add everything in it to the GROUP BY clause.\n101             # Backwards compatibility hack for setting query.group_by. Remove\n102             # when  we have public API way of forcing the GROUP BY clause.\n103             # Converts string references to expressions.\n104             for expr in self.query.group_by:\n105                 if not hasattr(expr, 'as_sql'):\n106                     expressions.append(self.query.resolve_ref(expr))\n107                 else:\n108                     expressions.append(expr)\n109         # Note that even if the group_by is set, it is only the minimal\n110         # set to group by. So, we need to add cols in select, order_by, and\n111         # having into the select in any case.\n112         for expr, _, _ in select:\n113             cols = expr.get_group_by_cols()\n114             for col in cols:\n115                 expressions.append(col)\n116         for expr, (sql, params, is_ref) in order_by:\n117             # Skip References to the select clause, as all expressions in the\n118             # select clause are already part of the group by.\n119             if not expr.contains_aggregate and not is_ref:\n120                 expressions.extend(expr.get_source_expressions())\n121         having_group_by = self.having.get_group_by_cols() if self.having else ()\n122         for expr in having_group_by:\n123             expressions.append(expr)\n124         result = []\n125         seen = set()\n126         expressions = self.collapse_group_by(expressions, having_group_by)\n127 \n128         for expr in expressions:\n129             sql, params = self.compile(expr)\n130             params_hash = make_hashable(params)\n131             if (sql, params_hash) not in seen:\n132                 result.append((sql, params))\n133                 seen.add((sql, params_hash))\n134         return result\n135 \n136     def collapse_group_by(self, expressions, having):\n137         # If the DB can group by primary key, then group by the primary key of\n138         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n139         # include the primary key of every table, but for MySQL it is enough to\n140         # have the main table's primary key.\n141         if self.connection.features.allows_group_by_pk:\n142             # Determine if the main model's primary key is in the query.\n143             pk = None\n144             for expr in expressions:\n145                 # Is this a reference to query's base table primary key? If the\n146                 # expression isn't a Col-like, then skip the expression.\n147                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and\n148                         getattr(expr, 'alias', None) == self.query.base_table):\n149                     pk = expr\n150                     break\n151             # If the main model's primary key is in the query, group by that\n152             # field, HAVING expressions, and expressions associated with tables\n153             # that don't have a primary key included in the grouped columns.\n154             if pk:\n155                 pk_aliases = {\n156                     expr.alias for expr in expressions\n157                     if hasattr(expr, 'target') and expr.target.primary_key\n158                 }\n159                 expressions = [pk] + [\n160                     expr for expr in expressions\n161                     if expr in having or (\n162                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases\n163                     )\n164                 ]\n165         elif self.connection.features.allows_group_by_selected_pks:\n166             # Filter out all expressions associated with a table's primary key\n167             # present in the grouped columns. This is done by identifying all\n168             # tables that have their primary key included in the grouped\n169             # columns and removing non-primary key columns referring to them.\n170             # Unmanaged models are excluded because they could be representing\n171             # database views on which the optimization might not be allowed.\n172             pks = {\n173                 expr for expr in expressions\n174                 if (\n175                     hasattr(expr, 'target') and\n176                     expr.target.primary_key and\n177                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)\n178                 )\n179             }\n180             aliases = {expr.alias for expr in pks}\n181             expressions = [\n182                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases\n183             ]\n184         return expressions\n185 \n186     def get_select(self):\n187         \"\"\"\n188         Return three values:\n189         - a list of 3-tuples of (expression, (sql, params), alias)\n190         - a klass_info structure,\n191         - a dictionary of annotations\n192 \n193         The (sql, params) is what the expression will produce, and alias is the\n194         \"AS alias\" for the column (possibly None).\n195 \n196         The klass_info structure contains the following information:\n197         - The base model of the query.\n198         - Which columns for that model are present in the query (by\n199           position of the select clause).\n200         - related_klass_infos: [f, klass_info] to descent into\n201 \n202         The annotations is a dictionary of {'attname': column position} values.\n203         \"\"\"\n204         select = []\n205         klass_info = None\n206         annotations = {}\n207         select_idx = 0\n208         for alias, (sql, params) in self.query.extra_select.items():\n209             annotations[alias] = select_idx\n210             select.append((RawSQL(sql, params), alias))\n211             select_idx += 1\n212         assert not (self.query.select and self.query.default_cols)\n213         if self.query.default_cols:\n214             cols = self.get_default_columns()\n215         else:\n216             # self.query.select is a special case. These columns never go to\n217             # any model.\n218             cols = self.query.select\n219         if cols:\n220             select_list = []\n221             for col in cols:\n222                 select_list.append(select_idx)\n223                 select.append((col, None))\n224                 select_idx += 1\n225             klass_info = {\n226                 'model': self.query.model,\n227                 'select_fields': select_list,\n228             }\n229         for alias, annotation in self.query.annotation_select.items():\n230             annotations[alias] = select_idx\n231             select.append((annotation, alias))\n232             select_idx += 1\n233 \n234         if self.query.select_related:\n235             related_klass_infos = self.get_related_selections(select)\n236             klass_info['related_klass_infos'] = related_klass_infos\n237 \n238             def get_select_from_parent(klass_info):\n239                 for ki in klass_info['related_klass_infos']:\n240                     if ki['from_parent']:\n241                         ki['select_fields'] = (klass_info['select_fields'] +\n242                                                ki['select_fields'])\n243                     get_select_from_parent(ki)\n244             get_select_from_parent(klass_info)\n245 \n246         ret = []\n247         for col, alias in select:\n248             try:\n249                 sql, params = self.compile(col)\n250             except EmptyResultSet:\n251                 # Select a predicate that's always False.\n252                 sql, params = '0', ()\n253             else:\n254                 sql, params = col.select_format(self, sql, params)\n255             ret.append((col, (sql, params), alias))\n256         return ret, klass_info, annotations\n257 \n258     def get_order_by(self):\n259         \"\"\"\n260         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n261         ORDER BY clause.\n262 \n263         The order_by clause can alter the select clause (for example it\n264         can add aliases to clauses that do not yet have one, or it can\n265         add totally new select clauses).\n266         \"\"\"\n267         if self.query.extra_order_by:\n268             ordering = self.query.extra_order_by\n269         elif not self.query.default_ordering:\n270             ordering = self.query.order_by\n271         elif self.query.order_by:\n272             ordering = self.query.order_by\n273         elif self.query.get_meta().ordering:\n274             ordering = self.query.get_meta().ordering\n275             self._meta_ordering = ordering\n276         else:\n277             ordering = []\n278         if self.query.standard_ordering:\n279             asc, desc = ORDER_DIR['ASC']\n280         else:\n281             asc, desc = ORDER_DIR['DESC']\n282 \n283         order_by = []\n284         for field in ordering:\n285             if hasattr(field, 'resolve_expression'):\n286                 if isinstance(field, Value):\n287                     # output_field must be resolved for constants.\n288                     field = Cast(field, field.output_field)\n289                 if not isinstance(field, OrderBy):\n290                     field = field.asc()\n291                 if not self.query.standard_ordering:\n292                     field = field.copy()\n293                     field.reverse_ordering()\n294                 order_by.append((field, False))\n295                 continue\n296             if field == '?':  # random\n297                 order_by.append((OrderBy(Random()), False))\n298                 continue\n299 \n300             col, order = get_order_dir(field, asc)\n301             descending = order == 'DESC'\n302 \n303             if col in self.query.annotation_select:\n304                 # Reference to expression in SELECT clause\n305                 order_by.append((\n306                     OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n307                     True))\n308                 continue\n309             if col in self.query.annotations:\n310                 # References to an expression which is masked out of the SELECT\n311                 # clause.\n312                 expr = self.query.annotations[col]\n313                 if isinstance(expr, Value):\n314                     # output_field must be resolved for constants.\n315                     expr = Cast(expr, expr.output_field)\n316                 order_by.append((OrderBy(expr, descending=descending), False))\n317                 continue\n318 \n319             if '.' in field:\n320                 # This came in through an extra(order_by=...) addition. Pass it\n321                 # on verbatim.\n322                 table, col = col.split('.', 1)\n323                 order_by.append((\n324                     OrderBy(\n325                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n326                         descending=descending\n327                     ), False))\n328                 continue\n329 \n330             if not self.query.extra or col not in self.query.extra:\n331                 # 'col' is of the form 'field' or 'field1__field2' or\n332                 # '-field1__field2__field', etc.\n333                 order_by.extend(self.find_ordering_name(\n334                     field, self.query.get_meta(), default_order=asc))\n335             else:\n336                 if col not in self.query.extra_select:\n337                     order_by.append((\n338                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n339                         False))\n340                 else:\n341                     order_by.append((\n342                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n343                         True))\n344         result = []\n345         seen = set()\n346 \n347         for expr, is_ref in order_by:\n348             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n349             if self.query.combinator:\n350                 src = resolved.get_source_expressions()[0]\n351                 # Relabel order by columns to raw numbers if this is a combined\n352                 # query; necessary since the columns can't be referenced by the\n353                 # fully qualified name and the simple column names may collide.\n354                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n355                     if is_ref and col_alias == src.refs:\n356                         src = src.source\n357                     elif col_alias:\n358                         continue\n359                     if src == sel_expr:\n360                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n361                         break\n362                 else:\n363                     if col_alias:\n364                         raise DatabaseError('ORDER BY term does not match any column in the result set.')\n365                     # Add column used in ORDER BY clause without an alias to\n366                     # the selected columns.\n367                     self.query.add_select_col(src)\n368                     resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n369             sql, params = self.compile(resolved)\n370             # Don't add the same column twice, but the order direction is\n371             # not taken into account so we strip it. When this entire method\n372             # is refactored into expressions, then we can check each part as we\n373             # generate it.\n374             without_ordering = self.ordering_parts.search(sql).group(1)\n375             params_hash = make_hashable(params)\n376             if (without_ordering, params_hash) in seen:\n377                 continue\n378             seen.add((without_ordering, params_hash))\n379             result.append((resolved, (sql, params, is_ref)))\n380         return result\n381 \n382     def get_extra_select(self, order_by, select):\n383         extra_select = []\n384         if self.query.distinct and not self.query.distinct_fields:\n385             select_sql = [t[1] for t in select]\n386             for expr, (sql, params, is_ref) in order_by:\n387                 without_ordering = self.ordering_parts.search(sql).group(1)\n388                 if not is_ref and (without_ordering, params) not in select_sql:\n389                     extra_select.append((expr, (without_ordering, params), None))\n390         return extra_select\n391 \n392     def quote_name_unless_alias(self, name):\n393         \"\"\"\n394         A wrapper around connection.ops.quote_name that doesn't quote aliases\n395         for table names. This avoids problems with some SQL dialects that treat\n396         quoted strings specially (e.g. PostgreSQL).\n397         \"\"\"\n398         if name in self.quote_cache:\n399             return self.quote_cache[name]\n400         if ((name in self.query.alias_map and name not in self.query.table_map) or\n401                 name in self.query.extra_select or (\n402                     name in self.query.external_aliases and name not in self.query.table_map)):\n403             self.quote_cache[name] = name\n404             return name\n405         r = self.connection.ops.quote_name(name)\n406         self.quote_cache[name] = r\n407         return r\n408 \n409     def compile(self, node):\n410         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n411         if vendor_impl:\n412             sql, params = vendor_impl(self, self.connection)\n413         else:\n414             sql, params = node.as_sql(self, self.connection)\n415         return sql, params\n416 \n417     def get_combinator_sql(self, combinator, all):\n418         features = self.connection.features\n419         compilers = [\n420             query.get_compiler(self.using, self.connection)\n421             for query in self.query.combined_queries if not query.is_empty()\n422         ]\n423         if not features.supports_slicing_ordering_in_compound:\n424             for query, compiler in zip(self.query.combined_queries, compilers):\n425                 if query.low_mark or query.high_mark:\n426                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n427                 if compiler.get_order_by():\n428                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n429         parts = ()\n430         for compiler in compilers:\n431             try:\n432                 # If the columns list is limited, then all combined queries\n433                 # must have the same columns list. Set the selects defined on\n434                 # the query on all combined queries, if not already set.\n435                 if not compiler.query.values_select and self.query.values_select:\n436                     compiler.query = compiler.query.clone()\n437                     compiler.query.set_values((\n438                         *self.query.extra_select,\n439                         *self.query.values_select,\n440                         *self.query.annotation_select,\n441                     ))\n442                 part_sql, part_args = compiler.as_sql()\n443                 if compiler.query.combinator:\n444                     # Wrap in a subquery if wrapping in parentheses isn't\n445                     # supported.\n446                     if not features.supports_parentheses_in_compound:\n447                         part_sql = 'SELECT * FROM ({})'.format(part_sql)\n448                     # Add parentheses when combining with compound query if not\n449                     # already added for all compound queries.\n450                     elif not features.supports_slicing_ordering_in_compound:\n451                         part_sql = '({})'.format(part_sql)\n452                 parts += ((part_sql, part_args),)\n453             except EmptyResultSet:\n454                 # Omit the empty queryset with UNION and with DIFFERENCE if the\n455                 # first queryset is nonempty.\n456                 if combinator == 'union' or (combinator == 'difference' and parts):\n457                     continue\n458                 raise\n459         if not parts:\n460             raise EmptyResultSet\n461         combinator_sql = self.connection.ops.set_operators[combinator]\n462         if all and combinator == 'union':\n463             combinator_sql += ' ALL'\n464         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n465         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n466         result = [' {} '.format(combinator_sql).join(sql_parts)]\n467         params = []\n468         for part in args_parts:\n469             params.extend(part)\n470         return result, params\n471 \n472     def as_sql(self, with_limits=True, with_col_aliases=False):\n473         \"\"\"\n474         Create the SQL for this query. Return the SQL string and list of\n475         parameters.\n476 \n477         If 'with_limits' is False, any limit/offset information is not included\n478         in the query.\n479         \"\"\"\n480         refcounts_before = self.query.alias_refcount.copy()\n481         try:\n482             extra_select, order_by, group_by = self.pre_sql_setup()\n483             for_update_part = None\n484             # Is a LIMIT/OFFSET clause needed?\n485             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n486             combinator = self.query.combinator\n487             features = self.connection.features\n488             if combinator:\n489                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n490                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n491                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n492             else:\n493                 distinct_fields, distinct_params = self.get_distinct()\n494                 # This must come after 'select', 'ordering', and 'distinct'\n495                 # (see docstring of get_from_clause() for details).\n496                 from_, f_params = self.get_from_clause()\n497                 where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n498                 having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n499                 result = ['SELECT']\n500                 params = []\n501 \n502                 if self.query.distinct:\n503                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n504                         distinct_fields,\n505                         distinct_params,\n506                     )\n507                     result += distinct_result\n508                     params += distinct_params\n509 \n510                 out_cols = []\n511                 col_idx = 1\n512                 for _, (s_sql, s_params), alias in self.select + extra_select:\n513                     if alias:\n514                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n515                     elif with_col_aliases:\n516                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n517                         col_idx += 1\n518                     params.extend(s_params)\n519                     out_cols.append(s_sql)\n520 \n521                 result += [', '.join(out_cols), 'FROM', *from_]\n522                 params.extend(f_params)\n523 \n524                 if self.query.select_for_update and self.connection.features.has_select_for_update:\n525                     if self.connection.get_autocommit():\n526                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n527 \n528                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:\n529                         raise NotSupportedError(\n530                             'LIMIT/OFFSET is not supported with '\n531                             'select_for_update on this database backend.'\n532                         )\n533                     nowait = self.query.select_for_update_nowait\n534                     skip_locked = self.query.select_for_update_skip_locked\n535                     of = self.query.select_for_update_of\n536                     # If it's a NOWAIT/SKIP LOCKED/OF query but the backend\n537                     # doesn't support it, raise NotSupportedError to prevent a\n538                     # possible deadlock.\n539                     if nowait and not self.connection.features.has_select_for_update_nowait:\n540                         raise NotSupportedError('NOWAIT is not supported on this database backend.')\n541                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:\n542                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n543                     elif of and not self.connection.features.has_select_for_update_of:\n544                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n545                     for_update_part = self.connection.ops.for_update_sql(\n546                         nowait=nowait,\n547                         skip_locked=skip_locked,\n548                         of=self.get_select_for_update_of_arguments(),\n549                     )\n550 \n551                 if for_update_part and self.connection.features.for_update_after_from:\n552                     result.append(for_update_part)\n553 \n554                 if where:\n555                     result.append('WHERE %s' % where)\n556                     params.extend(w_params)\n557 \n558                 grouping = []\n559                 for g_sql, g_params in group_by:\n560                     grouping.append(g_sql)\n561                     params.extend(g_params)\n562                 if grouping:\n563                     if distinct_fields:\n564                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n565                     order_by = order_by or self.connection.ops.force_no_ordering()\n566                     result.append('GROUP BY %s' % ', '.join(grouping))\n567                     if self._meta_ordering:\n568                         order_by = None\n569                 if having:\n570                     result.append('HAVING %s' % having)\n571                     params.extend(h_params)\n572 \n573             if self.query.explain_query:\n574                 result.insert(0, self.connection.ops.explain_query_prefix(\n575                     self.query.explain_format,\n576                     **self.query.explain_options\n577                 ))\n578 \n579             if order_by:\n580                 ordering = []\n581                 for _, (o_sql, o_params, _) in order_by:\n582                     ordering.append(o_sql)\n583                     params.extend(o_params)\n584                 result.append('ORDER BY %s' % ', '.join(ordering))\n585 \n586             if with_limit_offset:\n587                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n588 \n589             if for_update_part and not self.connection.features.for_update_after_from:\n590                 result.append(for_update_part)\n591 \n592             if self.query.subquery and extra_select:\n593                 # If the query is used as a subquery, the extra selects would\n594                 # result in more columns than the left-hand side expression is\n595                 # expecting. This can happen when a subquery uses a combination\n596                 # of order_by() and distinct(), forcing the ordering expressions\n597                 # to be selected as well. Wrap the query in another subquery\n598                 # to exclude extraneous selects.\n599                 sub_selects = []\n600                 sub_params = []\n601                 for index, (select, _, alias) in enumerate(self.select, start=1):\n602                     if not alias and with_col_aliases:\n603                         alias = 'col%d' % index\n604                     if alias:\n605                         sub_selects.append(\"%s.%s\" % (\n606                             self.connection.ops.quote_name('subquery'),\n607                             self.connection.ops.quote_name(alias),\n608                         ))\n609                     else:\n610                         select_clone = select.relabeled_clone({select.alias: 'subquery'})\n611                         subselect, subparams = select_clone.as_sql(self, self.connection)\n612                         sub_selects.append(subselect)\n613                         sub_params.extend(subparams)\n614                 return 'SELECT %s FROM (%s) subquery' % (\n615                     ', '.join(sub_selects),\n616                     ' '.join(result),\n617                 ), tuple(sub_params + params)\n618 \n619             return ' '.join(result), tuple(params)\n620         finally:\n621             # Finally do cleanup - get rid of the joins we created above.\n622             self.query.reset_refcounts(refcounts_before)\n623 \n624     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n625         \"\"\"\n626         Compute the default columns for selecting every field in the base\n627         model. Will sometimes be called to pull in related models (e.g. via\n628         select_related), in which case \"opts\" and \"start_alias\" will be given\n629         to provide a starting point for the traversal.\n630 \n631         Return a list of strings, quoted appropriately for use in SQL\n632         directly, as well as a set of aliases used in the select statement (if\n633         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n634         of strings as the first component and None as the second component).\n635         \"\"\"\n636         result = []\n637         if opts is None:\n638             opts = self.query.get_meta()\n639         only_load = self.deferred_to_columns()\n640         start_alias = start_alias or self.query.get_initial_alias()\n641         # The 'seen_models' is used to optimize checking the needed parent\n642         # alias for a given field. This also includes None -> start_alias to\n643         # be used by local fields.\n644         seen_models = {None: start_alias}\n645 \n646         for field in opts.concrete_fields:\n647             model = field.model._meta.concrete_model\n648             # A proxy model will have a different model and concrete_model. We\n649             # will assign None if the field belongs to this model.\n650             if model == opts.model:\n651                 model = None\n652             if from_parent and model is not None and issubclass(\n653                     from_parent._meta.concrete_model, model._meta.concrete_model):\n654                 # Avoid loading data for already loaded parents.\n655                 # We end up here in the case select_related() resolution\n656                 # proceeds from parent model to child model. In that case the\n657                 # parent model data is already present in the SELECT clause,\n658                 # and we want to avoid reloading the same data again.\n659                 continue\n660             if field.model in only_load and field.attname not in only_load[field.model]:\n661                 continue\n662             alias = self.query.join_parent_model(opts, model, start_alias,\n663                                                  seen_models)\n664             column = field.get_col(alias)\n665             result.append(column)\n666         return result\n667 \n668     def get_distinct(self):\n669         \"\"\"\n670         Return a quoted list of fields to use in DISTINCT ON part of the query.\n671 \n672         This method can alter the tables in the query, and thus it must be\n673         called before get_from_clause().\n674         \"\"\"\n675         result = []\n676         params = []\n677         opts = self.query.get_meta()\n678 \n679         for name in self.query.distinct_fields:\n680             parts = name.split(LOOKUP_SEP)\n681             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n682             targets, alias, _ = self.query.trim_joins(targets, joins, path)\n683             for target in targets:\n684                 if name in self.query.annotation_select:\n685                     result.append(name)\n686                 else:\n687                     r, p = self.compile(transform_function(target, alias))\n688                     result.append(r)\n689                     params.append(p)\n690         return result, params\n691 \n692     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n693                            already_seen=None):\n694         \"\"\"\n695         Return the table alias (the name might be ambiguous, the alias will\n696         not be) and column name for ordering by the given 'name' parameter.\n697         The 'name' is of the form 'field1__field2__...__fieldN'.\n698         \"\"\"\n699         name, order = get_order_dir(name, default_order)\n700         descending = order == 'DESC'\n701         pieces = name.split(LOOKUP_SEP)\n702         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n703 \n704         # If we get to this point and the field is a relation to another model,\n705         # append the default ordering for that model unless the attribute name\n706         # of the field is specified.\n707         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n708             # Firstly, avoid infinite loops.\n709             already_seen = already_seen or set()\n710             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n711             if join_tuple in already_seen:\n712                 raise FieldError('Infinite loop caused by ordering.')\n713             already_seen.add(join_tuple)\n714 \n715             results = []\n716             for item in opts.ordering:\n717                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n718                     item = item.desc() if descending else item.asc()\n719                 if isinstance(item, OrderBy):\n720                     results.append((item, False))\n721                     continue\n722                 results.extend(self.find_ordering_name(item, opts, alias,\n723                                                        order, already_seen))\n724             return results\n725         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n726         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n727 \n728     def _setup_joins(self, pieces, opts, alias):\n729         \"\"\"\n730         Helper method for get_order_by() and get_distinct().\n731 \n732         get_ordering() and get_distinct() must produce same target columns on\n733         same input, as the prefixes of get_ordering() and get_distinct() must\n734         match. Executing SQL where this is not true is an error.\n735         \"\"\"\n736         alias = alias or self.query.get_initial_alias()\n737         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)\n738         alias = joins[-1]\n739         return field, targets, alias, joins, path, opts, transform_function\n740 \n741     def get_from_clause(self):\n742         \"\"\"\n743         Return a list of strings that are joined together to go after the\n744         \"FROM\" part of the query, as well as a list any extra parameters that\n745         need to be included. Subclasses, can override this to create a\n746         from-clause via a \"select\".\n747 \n748         This should only be called after any SQL construction methods that\n749         might change the tables that are needed. This means the select columns,\n750         ordering, and distinct must be done first.\n751         \"\"\"\n752         result = []\n753         params = []\n754         for alias in tuple(self.query.alias_map):\n755             if not self.query.alias_refcount[alias]:\n756                 continue\n757             try:\n758                 from_clause = self.query.alias_map[alias]\n759             except KeyError:\n760                 # Extra tables can end up in self.tables, but not in the\n761                 # alias_map if they aren't in a join. That's OK. We skip them.\n762                 continue\n763             clause_sql, clause_params = self.compile(from_clause)\n764             result.append(clause_sql)\n765             params.extend(clause_params)\n766         for t in self.query.extra_tables:\n767             alias, _ = self.query.table_alias(t)\n768             # Only add the alias if it's not already present (the table_alias()\n769             # call increments the refcount, so an alias refcount of one means\n770             # this is the only reference).\n771             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:\n772                 result.append(', %s' % self.quote_name_unless_alias(alias))\n773         return result, params\n774 \n775     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,\n776                                requested=None, restricted=None):\n777         \"\"\"\n778         Fill in the information needed for a select_related query. The current\n779         depth is measured as the number of connections away from the root model\n780         (for example, cur_depth=1 means we are looking at models with direct\n781         connections to the root model).\n782         \"\"\"\n783         def _get_field_choices():\n784             direct_choices = (f.name for f in opts.fields if f.is_relation)\n785             reverse_choices = (\n786                 f.field.related_query_name()\n787                 for f in opts.related_objects if f.field.unique\n788             )\n789             return chain(direct_choices, reverse_choices, self.query._filtered_relations)\n790 \n791         related_klass_infos = []\n792         if not restricted and cur_depth > self.query.max_depth:\n793             # We've recursed far enough; bail out.\n794             return related_klass_infos\n795 \n796         if not opts:\n797             opts = self.query.get_meta()\n798             root_alias = self.query.get_initial_alias()\n799         only_load = self.query.get_loaded_field_names()\n800 \n801         # Setup for the case when only particular related fields should be\n802         # included in the related selection.\n803         fields_found = set()\n804         if requested is None:\n805             restricted = isinstance(self.query.select_related, dict)\n806             if restricted:\n807                 requested = self.query.select_related\n808 \n809         def get_related_klass_infos(klass_info, related_klass_infos):\n810             klass_info['related_klass_infos'] = related_klass_infos\n811 \n812         for f in opts.fields:\n813             field_model = f.model._meta.concrete_model\n814             fields_found.add(f.name)\n815 \n816             if restricted:\n817                 next = requested.get(f.name, {})\n818                 if not f.is_relation:\n819                     # If a non-related field is used like a relation,\n820                     # or if a single non-relational field is given.\n821                     if next or f.name in requested:\n822                         raise FieldError(\n823                             \"Non-relational field given in select_related: '%s'. \"\n824                             \"Choices are: %s\" % (\n825                                 f.name,\n826                                 \", \".join(_get_field_choices()) or '(none)',\n827                             )\n828                         )\n829             else:\n830                 next = False\n831 \n832             if not select_related_descend(f, restricted, requested,\n833                                           only_load.get(field_model)):\n834                 continue\n835             klass_info = {\n836                 'model': f.remote_field.model,\n837                 'field': f,\n838                 'reverse': False,\n839                 'local_setter': f.set_cached_value,\n840                 'remote_setter': f.remote_field.set_cached_value if f.unique else lambda x, y: None,\n841                 'from_parent': False,\n842             }\n843             related_klass_infos.append(klass_info)\n844             select_fields = []\n845             _, _, _, joins, _, _ = self.query.setup_joins(\n846                 [f.name], opts, root_alias)\n847             alias = joins[-1]\n848             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)\n849             for col in columns:\n850                 select_fields.append(len(select))\n851                 select.append((col, None))\n852             klass_info['select_fields'] = select_fields\n853             next_klass_infos = self.get_related_selections(\n854                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)\n855             get_related_klass_infos(klass_info, next_klass_infos)\n856 \n857         if restricted:\n858             related_fields = [\n859                 (o.field, o.related_model)\n860                 for o in opts.related_objects\n861                 if o.field.unique and not o.many_to_many\n862             ]\n863             for f, model in related_fields:\n864                 if not select_related_descend(f, restricted, requested,\n865                                               only_load.get(model), reverse=True):\n866                     continue\n867 \n868                 related_field_name = f.related_query_name()\n869                 fields_found.add(related_field_name)\n870 \n871                 join_info = self.query.setup_joins([related_field_name], opts, root_alias)\n872                 alias = join_info.joins[-1]\n873                 from_parent = issubclass(model, opts.model) and model is not opts.model\n874                 klass_info = {\n875                     'model': model,\n876                     'field': f,\n877                     'reverse': True,\n878                     'local_setter': f.remote_field.set_cached_value,\n879                     'remote_setter': f.set_cached_value,\n880                     'from_parent': from_parent,\n881                 }\n882                 related_klass_infos.append(klass_info)\n883                 select_fields = []\n884                 columns = self.get_default_columns(\n885                     start_alias=alias, opts=model._meta, from_parent=opts.model)\n886                 for col in columns:\n887                     select_fields.append(len(select))\n888                     select.append((col, None))\n889                 klass_info['select_fields'] = select_fields\n890                 next = requested.get(f.related_query_name(), {})\n891                 next_klass_infos = self.get_related_selections(\n892                     select, model._meta, alias, cur_depth + 1,\n893                     next, restricted)\n894                 get_related_klass_infos(klass_info, next_klass_infos)\n895 \n896             def local_setter(obj, from_obj):\n897                 # Set a reverse fk object when relation is non-empty.\n898                 if from_obj:\n899                     f.remote_field.set_cached_value(from_obj, obj)\n900 \n901             def remote_setter(name, obj, from_obj):\n902                 setattr(from_obj, name, obj)\n903 \n904             for name in list(requested):\n905                 # Filtered relations work only on the topmost level.\n906                 if cur_depth > 1:\n907                     break\n908                 if name in self.query._filtered_relations:\n909                     fields_found.add(name)\n910                     f, _, join_opts, joins, _, _ = self.query.setup_joins([name], opts, root_alias)\n911                     model = join_opts.model\n912                     alias = joins[-1]\n913                     from_parent = issubclass(model, opts.model) and model is not opts.model\n914                     klass_info = {\n915                         'model': model,\n916                         'field': f,\n917                         'reverse': True,\n918                         'local_setter': local_setter,\n919                         'remote_setter': partial(remote_setter, name),\n920                         'from_parent': from_parent,\n921                     }\n922                     related_klass_infos.append(klass_info)\n923                     select_fields = []\n924                     columns = self.get_default_columns(\n925                         start_alias=alias, opts=model._meta,\n926                         from_parent=opts.model,\n927                     )\n928                     for col in columns:\n929                         select_fields.append(len(select))\n930                         select.append((col, None))\n931                     klass_info['select_fields'] = select_fields\n932                     next_requested = requested.get(name, {})\n933                     next_klass_infos = self.get_related_selections(\n934                         select, opts=model._meta, root_alias=alias,\n935                         cur_depth=cur_depth + 1, requested=next_requested,\n936                         restricted=restricted,\n937                     )\n938                     get_related_klass_infos(klass_info, next_klass_infos)\n939             fields_not_found = set(requested).difference(fields_found)\n940             if fields_not_found:\n941                 invalid_fields = (\"'%s'\" % s for s in fields_not_found)\n942                 raise FieldError(\n943                     'Invalid field name(s) given in select_related: %s. '\n944                     'Choices are: %s' % (\n945                         ', '.join(invalid_fields),\n946                         ', '.join(_get_field_choices()) or '(none)',\n947                     )\n948                 )\n949         return related_klass_infos\n950 \n951     def get_select_for_update_of_arguments(self):\n952         \"\"\"\n953         Return a quoted list of arguments for the SELECT FOR UPDATE OF part of\n954         the query.\n955         \"\"\"\n956         def _get_parent_klass_info(klass_info):\n957             return (\n958                 {\n959                     'model': parent_model,\n960                     'field': parent_link,\n961                     'reverse': False,\n962                     'select_fields': [\n963                         select_index\n964                         for select_index in klass_info['select_fields']\n965                         if self.select[select_index][0].target.model == parent_model\n966                     ],\n967                 }\n968                 for parent_model, parent_link in klass_info['model']._meta.parents.items()\n969             )\n970 \n971         def _get_field_choices():\n972             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n973             queue = collections.deque([(None, self.klass_info)])\n974             while queue:\n975                 parent_path, klass_info = queue.popleft()\n976                 if parent_path is None:\n977                     path = []\n978                     yield 'self'\n979                 else:\n980                     field = klass_info['field']\n981                     if klass_info['reverse']:\n982                         field = field.remote_field\n983                     path = parent_path + [field.name]\n984                     yield LOOKUP_SEP.join(path)\n985                 queue.extend(\n986                     (path, klass_info)\n987                     for klass_info in _get_parent_klass_info(klass_info)\n988                 )\n989                 queue.extend(\n990                     (path, klass_info)\n991                     for klass_info in klass_info.get('related_klass_infos', [])\n992                 )\n993         result = []\n994         invalid_names = []\n995         for name in self.query.select_for_update_of:\n996             klass_info = self.klass_info\n997             if name == 'self':\n998                 # Find the first selected column from a base model. If it\n999                 # doesn't exist, don't lock a base model.\n1000                 for select_index in klass_info['select_fields']:\n1001                     if self.select[select_index][0].target.model == klass_info['model']:\n1002                         col = self.select[select_index][0]\n1003                         break\n1004                 else:\n1005                     col = None\n1006             else:\n1007                 for part in name.split(LOOKUP_SEP):\n1008                     klass_infos = (\n1009                         *klass_info.get('related_klass_infos', []),\n1010                         *_get_parent_klass_info(klass_info),\n1011                     )\n1012                     for related_klass_info in klass_infos:\n1013                         field = related_klass_info['field']\n1014                         if related_klass_info['reverse']:\n1015                             field = field.remote_field\n1016                         if field.name == part:\n1017                             klass_info = related_klass_info\n1018                             break\n1019                     else:\n1020                         klass_info = None\n1021                         break\n1022                 if klass_info is None:\n1023                     invalid_names.append(name)\n1024                     continue\n1025                 select_index = klass_info['select_fields'][0]\n1026                 col = self.select[select_index][0]\n1027             if col is not None:\n1028                 if self.connection.features.select_for_update_of_column:\n1029                     result.append(self.compile(col)[0])\n1030                 else:\n1031                     result.append(self.quote_name_unless_alias(col.alias))\n1032         if invalid_names:\n1033             raise FieldError(\n1034                 'Invalid field name(s) given in select_for_update(of=(...)): %s. '\n1035                 'Only relational fields followed in the query are allowed. '\n1036                 'Choices are: %s.' % (\n1037                     ', '.join(invalid_names),\n1038                     ', '.join(_get_field_choices()),\n1039                 )\n1040             )\n1041         return result\n1042 \n1043     def deferred_to_columns(self):\n1044         \"\"\"\n1045         Convert the self.deferred_loading data structure to mapping of table\n1046         names to sets of column names which are to be loaded. Return the\n1047         dictionary.\n1048         \"\"\"\n1049         columns = {}\n1050         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)\n1051         return columns\n1052 \n1053     def get_converters(self, expressions):\n1054         converters = {}\n1055         for i, expression in enumerate(expressions):\n1056             if expression:\n1057                 backend_converters = self.connection.ops.get_db_converters(expression)\n1058                 field_converters = expression.get_db_converters(self.connection)\n1059                 if backend_converters or field_converters:\n1060                     converters[i] = (backend_converters + field_converters, expression)\n1061         return converters\n1062 \n1063     def apply_converters(self, rows, converters):\n1064         connection = self.connection\n1065         converters = list(converters.items())\n1066         for row in map(list, rows):\n1067             for pos, (convs, expression) in converters:\n1068                 value = row[pos]\n1069                 for converter in convs:\n1070                     value = converter(value, expression, connection)\n1071                 row[pos] = value\n1072             yield row\n1073 \n1074     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,\n1075                      chunk_size=GET_ITERATOR_CHUNK_SIZE):\n1076         \"\"\"Return an iterator over the results from executing this query.\"\"\"\n1077         if results is None:\n1078             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)\n1079         fields = [s[0] for s in self.select[0:self.col_count]]\n1080         converters = self.get_converters(fields)\n1081         rows = chain.from_iterable(results)\n1082         if converters:\n1083             rows = self.apply_converters(rows, converters)\n1084             if tuple_expected:\n1085                 rows = map(tuple, rows)\n1086         return rows\n1087 \n1088     def has_results(self):\n1089         \"\"\"\n1090         Backends (e.g. NoSQL) can override this in order to use optimized\n1091         versions of \"query has any results.\"\n1092         \"\"\"\n1093         # This is always executed on a query clone, so we can modify self.query\n1094         self.query.add_extra({'a': 1}, None, None, None, None, None)\n1095         self.query.set_extra_mask(['a'])\n1096         return bool(self.execute_sql(SINGLE))\n1097 \n1098     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n1099         \"\"\"\n1100         Run the query against the database and return the result(s). The\n1101         return value is a single data item if result_type is SINGLE, or an\n1102         iterator over the results if the result_type is MULTI.\n1103 \n1104         result_type is either MULTI (use fetchmany() to retrieve all rows),\n1105         SINGLE (only retrieve a single row), or None. In this last case, the\n1106         cursor is returned if any query is executed, since it's used by\n1107         subclasses such as InsertQuery). It's possible, however, that no query\n1108         is needed, as the filters describe an empty set. In that case, None is\n1109         returned, to avoid any unnecessary database interaction.\n1110         \"\"\"\n1111         result_type = result_type or NO_RESULTS\n1112         try:\n1113             sql, params = self.as_sql()\n1114             if not sql:\n1115                 raise EmptyResultSet\n1116         except EmptyResultSet:\n1117             if result_type == MULTI:\n1118                 return iter([])\n1119             else:\n1120                 return\n1121         if chunked_fetch:\n1122             cursor = self.connection.chunked_cursor()\n1123         else:\n1124             cursor = self.connection.cursor()\n1125         try:\n1126             cursor.execute(sql, params)\n1127         except Exception:\n1128             # Might fail for server-side cursors (e.g. connection closed)\n1129             cursor.close()\n1130             raise\n1131 \n1132         if result_type == CURSOR:\n1133             # Give the caller the cursor to process and close.\n1134             return cursor\n1135         if result_type == SINGLE:\n1136             try:\n1137                 val = cursor.fetchone()\n1138                 if val:\n1139                     return val[0:self.col_count]\n1140                 return val\n1141             finally:\n1142                 # done with the cursor\n1143                 cursor.close()\n1144         if result_type == NO_RESULTS:\n1145             cursor.close()\n1146             return\n1147 \n1148         result = cursor_iter(\n1149             cursor, self.connection.features.empty_fetchmany_value,\n1150             self.col_count if self.has_extra_select else None,\n1151             chunk_size,\n1152         )\n1153         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n1154             try:\n1155                 # If we are using non-chunked reads, we return the same data\n1156                 # structure as normally, but ensure it is all read into memory\n1157                 # before going any further. Use chunked_fetch if requested,\n1158                 # unless the database doesn't support it.\n1159                 return list(result)\n1160             finally:\n1161                 # done with the cursor\n1162                 cursor.close()\n1163         return result\n1164 \n1165     def as_subquery_condition(self, alias, columns, compiler):\n1166         qn = compiler.quote_name_unless_alias\n1167         qn2 = self.connection.ops.quote_name\n1168 \n1169         for index, select_col in enumerate(self.query.select):\n1170             lhs_sql, lhs_params = self.compile(select_col)\n1171             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))\n1172             self.query.where.add(\n1173                 RawSQL('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')\n1174 \n1175         sql, params = self.as_sql()\n1176         return 'EXISTS (%s)' % sql, params\n1177 \n1178     def explain_query(self):\n1179         result = list(self.execute_sql())\n1180         # Some backends return 1 item tuples with strings, and others return\n1181         # tuples with integers and strings. Flatten them out into strings.\n1182         for row in result[0]:\n1183             if not isinstance(row, str):\n1184                 yield ' '.join(str(c) for c in row)\n1185             else:\n1186                 yield row\n1187 \n1188 \n1189 class SQLInsertCompiler(SQLCompiler):\n1190     returning_fields = None\n1191     returning_params = tuple()\n1192 \n1193     def field_as_sql(self, field, val):\n1194         \"\"\"\n1195         Take a field and a value intended to be saved on that field, and\n1196         return placeholder SQL and accompanying params. Check for raw values,\n1197         expressions, and fields with get_placeholder() defined in that order.\n1198 \n1199         When field is None, consider the value raw and use it as the\n1200         placeholder, with no corresponding parameters returned.\n1201         \"\"\"\n1202         if field is None:\n1203             # A field value of None means the value is raw.\n1204             sql, params = val, []\n1205         elif hasattr(val, 'as_sql'):\n1206             # This is an expression, let's compile it.\n1207             sql, params = self.compile(val)\n1208         elif hasattr(field, 'get_placeholder'):\n1209             # Some fields (e.g. geo fields) need special munging before\n1210             # they can be inserted.\n1211             sql, params = field.get_placeholder(val, self, self.connection), [val]\n1212         else:\n1213             # Return the common case for the placeholder\n1214             sql, params = '%s', [val]\n1215 \n1216         # The following hook is only used by Oracle Spatial, which sometimes\n1217         # needs to yield 'NULL' and [] as its placeholder and params instead\n1218         # of '%s' and [None]. The 'NULL' placeholder is produced earlier by\n1219         # OracleOperations.get_geom_placeholder(). The following line removes\n1220         # the corresponding None parameter. See ticket #10888.\n1221         params = self.connection.ops.modify_insert_params(sql, params)\n1222 \n1223         return sql, params\n1224 \n1225     def prepare_value(self, field, value):\n1226         \"\"\"\n1227         Prepare a value to be used in a query by resolving it if it is an\n1228         expression and otherwise calling the field's get_db_prep_save().\n1229         \"\"\"\n1230         if hasattr(value, 'resolve_expression'):\n1231             value = value.resolve_expression(self.query, allow_joins=False, for_save=True)\n1232             # Don't allow values containing Col expressions. They refer to\n1233             # existing columns on a row, but in the case of insert the row\n1234             # doesn't exist yet.\n1235             if value.contains_column_references:\n1236                 raise ValueError(\n1237                     'Failed to insert expression \"%s\" on %s. F() expressions '\n1238                     'can only be used to update, not to insert.' % (value, field)\n1239                 )\n1240             if value.contains_aggregate:\n1241                 raise FieldError(\n1242                     'Aggregate functions are not allowed in this query '\n1243                     '(%s=%r).' % (field.name, value)\n1244                 )\n1245             if value.contains_over_clause:\n1246                 raise FieldError(\n1247                     'Window expressions are not allowed in this query (%s=%r).'\n1248                     % (field.name, value)\n1249                 )\n1250         else:\n1251             value = field.get_db_prep_save(value, connection=self.connection)\n1252         return value\n1253 \n1254     def pre_save_val(self, field, obj):\n1255         \"\"\"\n1256         Get the given field's value off the given obj. pre_save() is used for\n1257         things like auto_now on DateTimeField. Skip it if this is a raw query.\n1258         \"\"\"\n1259         if self.query.raw:\n1260             return getattr(obj, field.attname)\n1261         return field.pre_save(obj, add=True)\n1262 \n1263     def assemble_as_sql(self, fields, value_rows):\n1264         \"\"\"\n1265         Take a sequence of N fields and a sequence of M rows of values, and\n1266         generate placeholder SQL and parameters for each field and value.\n1267         Return a pair containing:\n1268          * a sequence of M rows of N SQL placeholder strings, and\n1269          * a sequence of M rows of corresponding parameter values.\n1270 \n1271         Each placeholder string may contain any number of '%s' interpolation\n1272         strings, and each parameter row will contain exactly as many params\n1273         as the total number of '%s's in the corresponding placeholder row.\n1274         \"\"\"\n1275         if not value_rows:\n1276             return [], []\n1277 \n1278         # list of (sql, [params]) tuples for each object to be saved\n1279         # Shape: [n_objs][n_fields][2]\n1280         rows_of_fields_as_sql = (\n1281             (self.field_as_sql(field, v) for field, v in zip(fields, row))\n1282             for row in value_rows\n1283         )\n1284 \n1285         # tuple like ([sqls], [[params]s]) for each object to be saved\n1286         # Shape: [n_objs][2][n_fields]\n1287         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)\n1288 \n1289         # Extract separate lists for placeholders and params.\n1290         # Each of these has shape [n_objs][n_fields]\n1291         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)\n1292 \n1293         # Params for each field are still lists, and need to be flattened.\n1294         param_rows = [[p for ps in row for p in ps] for row in param_rows]\n1295 \n1296         return placeholder_rows, param_rows\n1297 \n1298     def as_sql(self):\n1299         # We don't need quote_name_unless_alias() here, since these are all\n1300         # going to be column names (so we can avoid the extra overhead).\n1301         qn = self.connection.ops.quote_name\n1302         opts = self.query.get_meta()\n1303         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)\n1304         result = ['%s %s' % (insert_statement, qn(opts.db_table))]\n1305         fields = self.query.fields or [opts.pk]\n1306         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))\n1307 \n1308         if self.query.fields:\n1309             value_rows = [\n1310                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]\n1311                 for obj in self.query.objs\n1312             ]\n1313         else:\n1314             # An empty object.\n1315             value_rows = [[self.connection.ops.pk_default_value()] for _ in self.query.objs]\n1316             fields = [None]\n1317 \n1318         # Currently the backends just accept values when generating bulk\n1319         # queries and generate their own placeholders. Doing that isn't\n1320         # necessary and it should be possible to use placeholders and\n1321         # expressions in bulk inserts too.\n1322         can_bulk = (not self.returning_fields and self.connection.features.has_bulk_insert)\n1323 \n1324         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)\n1325 \n1326         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(\n1327             ignore_conflicts=self.query.ignore_conflicts\n1328         )\n1329         if self.returning_fields and self.connection.features.can_return_columns_from_insert:\n1330             if self.connection.features.can_return_rows_from_bulk_insert:\n1331                 result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))\n1332                 params = param_rows\n1333             else:\n1334                 result.append(\"VALUES (%s)\" % \", \".join(placeholder_rows[0]))\n1335                 params = [param_rows[0]]\n1336             if ignore_conflicts_suffix_sql:\n1337                 result.append(ignore_conflicts_suffix_sql)\n1338             # Skip empty r_sql to allow subclasses to customize behavior for\n1339             # 3rd party backends. Refs #19096.\n1340             r_sql, self.returning_params = self.connection.ops.return_insert_columns(self.returning_fields)\n1341             if r_sql:\n1342                 result.append(r_sql)\n1343                 params += [self.returning_params]\n1344             return [(\" \".join(result), tuple(chain.from_iterable(params)))]\n1345 \n1346         if can_bulk:\n1347             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))\n1348             if ignore_conflicts_suffix_sql:\n1349                 result.append(ignore_conflicts_suffix_sql)\n1350             return [(\" \".join(result), tuple(p for ps in param_rows for p in ps))]\n1351         else:\n1352             if ignore_conflicts_suffix_sql:\n1353                 result.append(ignore_conflicts_suffix_sql)\n1354             return [\n1355                 (\" \".join(result + [\"VALUES (%s)\" % \", \".join(p)]), vals)\n1356                 for p, vals in zip(placeholder_rows, param_rows)\n1357             ]\n1358 \n1359     def execute_sql(self, returning_fields=None):\n1360         assert not (\n1361             returning_fields and len(self.query.objs) != 1 and\n1362             not self.connection.features.can_return_rows_from_bulk_insert\n1363         )\n1364         self.returning_fields = returning_fields\n1365         with self.connection.cursor() as cursor:\n1366             for sql, params in self.as_sql():\n1367                 cursor.execute(sql, params)\n1368             if not self.returning_fields:\n1369                 return []\n1370             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:\n1371                 return self.connection.ops.fetch_returned_insert_rows(cursor)\n1372             if self.connection.features.can_return_columns_from_insert:\n1373                 assert len(self.query.objs) == 1\n1374                 return self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)\n1375             return [self.connection.ops.last_insert_id(\n1376                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column\n1377             )]\n1378 \n1379 \n1380 class SQLDeleteCompiler(SQLCompiler):\n1381     @cached_property\n1382     def single_alias(self):\n1383         return sum(self.query.alias_refcount[t] > 0 for t in self.query.alias_map) == 1\n1384 \n1385     def _as_sql(self, query):\n1386         result = [\n1387             'DELETE FROM %s' % self.quote_name_unless_alias(query.base_table)\n1388         ]\n1389         where, params = self.compile(query.where)\n1390         if where:\n1391             result.append('WHERE %s' % where)\n1392         return ' '.join(result), tuple(params)\n1393 \n1394     def as_sql(self):\n1395         \"\"\"\n1396         Create the SQL for this query. Return the SQL string and list of\n1397         parameters.\n1398         \"\"\"\n1399         if self.single_alias:\n1400             return self._as_sql(self.query)\n1401         innerq = self.query.clone()\n1402         innerq.__class__ = Query\n1403         innerq.clear_select_clause()\n1404         pk = self.query.model._meta.pk\n1405         innerq.select = [\n1406             pk.get_col(self.query.get_initial_alias())\n1407         ]\n1408         outerq = Query(self.query.model)\n1409         outerq.where = self.query.where_class()\n1410         outerq.add_q(Q(pk__in=innerq))\n1411         return self._as_sql(outerq)\n1412 \n1413 \n1414 class SQLUpdateCompiler(SQLCompiler):\n1415     def as_sql(self):\n1416         \"\"\"\n1417         Create the SQL for this query. Return the SQL string and list of\n1418         parameters.\n1419         \"\"\"\n1420         self.pre_sql_setup()\n1421         if not self.query.values:\n1422             return '', ()\n1423         qn = self.quote_name_unless_alias\n1424         values, update_params = [], []\n1425         for field, model, val in self.query.values:\n1426             if hasattr(val, 'resolve_expression'):\n1427                 val = val.resolve_expression(self.query, allow_joins=False, for_save=True)\n1428                 if val.contains_aggregate:\n1429                     raise FieldError(\n1430                         'Aggregate functions are not allowed in this query '\n1431                         '(%s=%r).' % (field.name, val)\n1432                     )\n1433                 if val.contains_over_clause:\n1434                     raise FieldError(\n1435                         'Window expressions are not allowed in this query '\n1436                         '(%s=%r).' % (field.name, val)\n1437                     )\n1438             elif hasattr(val, 'prepare_database_save'):\n1439                 if field.remote_field:\n1440                     val = field.get_db_prep_save(\n1441                         val.prepare_database_save(field),\n1442                         connection=self.connection,\n1443                     )\n1444                 else:\n1445                     raise TypeError(\n1446                         \"Tried to update field %s with a model instance, %r. \"\n1447                         \"Use a value compatible with %s.\"\n1448                         % (field, val, field.__class__.__name__)\n1449                     )\n1450             else:\n1451                 val = field.get_db_prep_save(val, connection=self.connection)\n1452 \n1453             # Getting the placeholder for the field.\n1454             if hasattr(field, 'get_placeholder'):\n1455                 placeholder = field.get_placeholder(val, self, self.connection)\n1456             else:\n1457                 placeholder = '%s'\n1458             name = field.column\n1459             if hasattr(val, 'as_sql'):\n1460                 sql, params = self.compile(val)\n1461                 values.append('%s = %s' % (qn(name), placeholder % sql))\n1462                 update_params.extend(params)\n1463             elif val is not None:\n1464                 values.append('%s = %s' % (qn(name), placeholder))\n1465                 update_params.append(val)\n1466             else:\n1467                 values.append('%s = NULL' % qn(name))\n1468         table = self.query.base_table\n1469         result = [\n1470             'UPDATE %s SET' % qn(table),\n1471             ', '.join(values),\n1472         ]\n1473         where, params = self.compile(self.query.where)\n1474         if where:\n1475             result.append('WHERE %s' % where)\n1476         return ' '.join(result), tuple(update_params + params)\n1477 \n1478     def execute_sql(self, result_type):\n1479         \"\"\"\n1480         Execute the specified update. Return the number of rows affected by\n1481         the primary update query. The \"primary update query\" is the first\n1482         non-empty query that is executed. Row counts for any subsequent,\n1483         related queries are not available.\n1484         \"\"\"\n1485         cursor = super().execute_sql(result_type)\n1486         try:\n1487             rows = cursor.rowcount if cursor else 0\n1488             is_empty = cursor is None\n1489         finally:\n1490             if cursor:\n1491                 cursor.close()\n1492         for query in self.query.get_related_updates():\n1493             aux_rows = query.get_compiler(self.using).execute_sql(result_type)\n1494             if is_empty and aux_rows:\n1495                 rows = aux_rows\n1496                 is_empty = False\n1497         return rows\n1498 \n1499     def pre_sql_setup(self):\n1500         \"\"\"\n1501         If the update depends on results from other tables, munge the \"where\"\n1502         conditions to match the format required for (portable) SQL updates.\n1503 \n1504         If multiple updates are required, pull out the id values to update at\n1505         this point so that they don't change as a result of the progressive\n1506         updates.\n1507         \"\"\"\n1508         refcounts_before = self.query.alias_refcount.copy()\n1509         # Ensure base table is in the query\n1510         self.query.get_initial_alias()\n1511         count = self.query.count_active_tables()\n1512         if not self.query.related_updates and count == 1:\n1513             return\n1514         query = self.query.chain(klass=Query)\n1515         query.select_related = False\n1516         query.clear_ordering(True)\n1517         query.extra = {}\n1518         query.select = []\n1519         query.add_fields([query.get_meta().pk.name])\n1520         super().pre_sql_setup()\n1521 \n1522         must_pre_select = count > 1 and not self.connection.features.update_can_self_select\n1523 \n1524         # Now we adjust the current query: reset the where clause and get rid\n1525         # of all the tables we don't need (since they're in the sub-select).\n1526         self.query.where = self.query.where_class()\n1527         if self.query.related_updates or must_pre_select:\n1528             # Either we're using the idents in multiple update queries (so\n1529             # don't want them to change), or the db backend doesn't support\n1530             # selecting from the updating table (e.g. MySQL).\n1531             idents = []\n1532             for rows in query.get_compiler(self.using).execute_sql(MULTI):\n1533                 idents.extend(r[0] for r in rows)\n1534             self.query.add_filter(('pk__in', idents))\n1535             self.query.related_ids = idents\n1536         else:\n1537             # The fast path. Filters and updates in one query.\n1538             self.query.add_filter(('pk__in', query))\n1539         self.query.reset_refcounts(refcounts_before)\n1540 \n1541 \n1542 class SQLAggregateCompiler(SQLCompiler):\n1543     def as_sql(self):\n1544         \"\"\"\n1545         Create the SQL for this query. Return the SQL string and list of\n1546         parameters.\n1547         \"\"\"\n1548         sql, params = [], []\n1549         for annotation in self.query.annotation_select.values():\n1550             ann_sql, ann_params = self.compile(annotation)\n1551             ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n1552             sql.append(ann_sql)\n1553             params.extend(ann_params)\n1554         self.col_count = len(self.query.annotation_select)\n1555         sql = ', '.join(sql)\n1556         params = tuple(params)\n1557 \n1558         sql = 'SELECT %s FROM (%s) subquery' % (sql, self.query.subquery)\n1559         params = params + self.query.sub_params\n1560         return sql, params\n1561 \n1562 \n1563 def cursor_iter(cursor, sentinel, col_count, itersize):\n1564     \"\"\"\n1565     Yield blocks of rows from a cursor and ensure the cursor is closed when\n1566     done.\n1567     \"\"\"\n1568     try:\n1569         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):\n1570             yield rows if col_count is None else [r[:col_count] for r in rows]\n1571     finally:\n1572         cursor.close()\n",
        "intended_behavior": "The code here should properly distinguish contexts where window functions are used, especially in 'SELECT' clauses. The fix should ensure that window expressions within annotations are compiled into SQL without incorrectly raising a 'NotSupportedError'. This adjustment must keep the validation against the use of window functions in prohibited clauses (like 'WHERE'), while allowing them in 'SELECT' clauses as per SQL standards."
    },
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/expressions.py",
        "start": 1156,
        "end": 1247,
        "class_name": "Window",
        "method_name": null,
        "code": "1156 class Window(Expression):\n1157     template = '%(expression)s OVER (%(window)s)'\n1158     # Although the main expression may either be an aggregate or an\n1159     # expression with an aggregate function, the GROUP BY that will\n1160     # be introduced in the query as a result is not desired.\n1161     contains_aggregate = False\n1162     contains_over_clause = True\n1163     filterable = False\n1164 \n1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1166         self.partition_by = partition_by\n1167         self.order_by = order_by\n1168         self.frame = frame\n1169 \n1170         if not getattr(expression, 'window_compatible', False):\n1171             raise ValueError(\n1172                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1173                 expression.__class__.__name__\n1174             )\n1175 \n1176         if self.partition_by is not None:\n1177             if not isinstance(self.partition_by, (tuple, list)):\n1178                 self.partition_by = (self.partition_by,)\n1179             self.partition_by = ExpressionList(*self.partition_by)\n1180 \n1181         if self.order_by is not None:\n1182             if isinstance(self.order_by, (list, tuple)):\n1183                 self.order_by = ExpressionList(*self.order_by)\n1184             elif not isinstance(self.order_by, BaseExpression):\n1185                 raise ValueError(\n1186                     'order_by must be either an Expression or a sequence of '\n1187                     'expressions.'\n1188                 )\n1189         super().__init__(output_field=output_field)\n1190         self.source_expression = self._parse_expressions(expression)[0]\n1191 \n1192     def _resolve_output_field(self):\n1193         return self.source_expression.output_field\n1194 \n1195     def get_source_expressions(self):\n1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1197 \n1198     def set_source_expressions(self, exprs):\n1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1200 \n1201     def as_sql(self, compiler, connection, template=None):\n1202         connection.ops.check_expression_support(self)\n1203         if not connection.features.supports_over_clause:\n1204             raise NotSupportedError('This backend does not support window expressions.')\n1205         expr_sql, params = compiler.compile(self.source_expression)\n1206         window_sql, window_params = [], []\n1207 \n1208         if self.partition_by is not None:\n1209             sql_expr, sql_params = self.partition_by.as_sql(\n1210                 compiler=compiler, connection=connection,\n1211                 template='PARTITION BY %(expressions)s',\n1212             )\n1213             window_sql.extend(sql_expr)\n1214             window_params.extend(sql_params)\n1215 \n1216         if self.order_by is not None:\n1217             window_sql.append(' ORDER BY ')\n1218             order_sql, order_params = compiler.compile(self.order_by)\n1219             window_sql.extend(order_sql)\n1220             window_params.extend(order_params)\n1221 \n1222         if self.frame:\n1223             frame_sql, frame_params = compiler.compile(self.frame)\n1224             window_sql.append(' ' + frame_sql)\n1225             window_params.extend(frame_params)\n1226 \n1227         params.extend(window_params)\n1228         template = template or self.template\n1229 \n1230         return template % {\n1231             'expression': expr_sql,\n1232             'window': ''.join(window_sql).strip()\n1233         }, params\n1234 \n1235     def __str__(self):\n1236         return '{} OVER ({}{}{})'.format(\n1237             str(self.source_expression),\n1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',\n1240             str(self.frame or ''),\n1241         )\n1242 \n1243     def __repr__(self):\n1244         return '<%s: %s>' % (self.__class__.__name__, self)\n1245 \n1246     def get_group_by_cols(self, alias=None):\n1247         return []\n",
        "intended_behavior": "Ensure that when a 'Window' expression is used within an 'annotate' call, it is flagged in a way that prevents 'NotSupportedError' from being incorrectly raised. This may involve adding additional checks or flags to indicate that the window expression is used in a supported context (i.e., within the 'SELECT' clause) and should not be treated as an error."
    }
]