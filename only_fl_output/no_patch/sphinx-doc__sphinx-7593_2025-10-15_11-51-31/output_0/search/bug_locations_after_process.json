[
    {
        "rel_file_path": "sphinx/roles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/roles.py",
        "start": 1,
        "end": 630,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.roles\n3     ~~~~~~~~~~~~\n4 \n5     Handlers for additional ReST roles.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import warnings\n13 from typing import Any, Dict, List, Tuple\n14 \n15 from docutils import nodes, utils\n16 from docutils.nodes import Element, Node, TextElement, system_message\n17 from docutils.parsers.rst.states import Inliner\n18 \n19 from sphinx import addnodes\n20 from sphinx.deprecation import RemovedInSphinx40Warning\n21 from sphinx.locale import _\n22 from sphinx.util import ws_re\n23 from sphinx.util.docutils import ReferenceRole, SphinxRole\n24 from sphinx.util.nodes import (\n25     split_explicit_title, process_index_entry, set_role_source_info\n26 )\n27 from sphinx.util.typing import RoleFunction\n28 \n29 if False:\n30     # For type annotation\n31     from typing import Type  # for python3.5.1\n32     from sphinx.application import Sphinx\n33     from sphinx.environment import BuildEnvironment\n34 \n35 \n36 generic_docroles = {\n37     'command': addnodes.literal_strong,\n38     'dfn': nodes.emphasis,\n39     'kbd': nodes.literal,\n40     'mailheader': addnodes.literal_emphasis,\n41     'makevar': addnodes.literal_strong,\n42     'manpage': addnodes.manpage,\n43     'mimetype': addnodes.literal_emphasis,\n44     'newsgroup': addnodes.literal_emphasis,\n45     'program': addnodes.literal_strong,  # XXX should be an x-ref\n46     'regexp': nodes.literal,\n47 }\n48 \n49 \n50 # -- generic cross-reference role ----------------------------------------------\n51 \n52 class XRefRole(ReferenceRole):\n53     \"\"\"\n54     A generic cross-referencing role.  To create a callable that can be used as\n55     a role function, create an instance of this class.\n56 \n57     The general features of this role are:\n58 \n59     * Automatic creation of a reference and a content node.\n60     * Optional separation of title and target with `title <target>`.\n61     * The implementation is a class rather than a function to make\n62       customization easier.\n63 \n64     Customization can be done in two ways:\n65 \n66     * Supplying constructor parameters:\n67       * `fix_parens` to normalize parentheses (strip from target, and add to\n68         title if configured)\n69       * `lowercase` to lowercase the target\n70       * `nodeclass` and `innernodeclass` select the node classes for\n71         the reference and the content node\n72 \n73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.\n74     \"\"\"\n75 \n76     nodeclass = addnodes.pending_xref   # type: Type[Element]\n77     innernodeclass = nodes.literal      # type: Type[TextElement]\n78 \n79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,\n80                  nodeclass: \"Type[Element]\" = None, innernodeclass: \"Type[TextElement]\" = None,\n81                  warn_dangling: bool = False) -> None:\n82         self.fix_parens = fix_parens\n83         self.lowercase = lowercase\n84         self.warn_dangling = warn_dangling\n85         if nodeclass is not None:\n86             self.nodeclass = nodeclass\n87         if innernodeclass is not None:\n88             self.innernodeclass = innernodeclass\n89 \n90         super().__init__()\n91 \n92     def _fix_parens(self, env: \"BuildEnvironment\", has_explicit_title: bool, title: str,\n93                     target: str) -> Tuple[str, str]:\n94         warnings.warn('XRefRole._fix_parens() is deprecated.',\n95                       RemovedInSphinx40Warning, stacklevel=2)\n96         if not has_explicit_title:\n97             if title.endswith('()'):\n98                 # remove parentheses\n99                 title = title[:-2]\n100             if env.config.add_function_parentheses:\n101                 # add them back to all occurrences if configured\n102                 title += '()'\n103         # remove parentheses from the target too\n104         if target.endswith('()'):\n105             target = target[:-2]\n106         return title, target\n107 \n108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:\n109         if not self.has_explicit_title:\n110             if title.endswith('()'):\n111                 # remove parentheses\n112                 title = title[:-2]\n113             if self.config.add_function_parentheses:\n114                 # add them back to all occurrences if configured\n115                 title += '()'\n116         # remove parentheses from the target too\n117         if target.endswith('()'):\n118             target = target[:-2]\n119         return title, target\n120 \n121     def run(self) -> Tuple[List[Node], List[system_message]]:\n122         if ':' not in self.name:\n123             self.refdomain, self.reftype = '', self.name\n124             self.classes = ['xref', self.reftype]\n125         else:\n126             self.refdomain, self.reftype = self.name.split(':', 1)\n127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]\n128 \n129         if self.disabled:\n130             return self.create_non_xref_node()\n131         else:\n132             return self.create_xref_node()\n133 \n134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n135         text = utils.unescape(self.text[1:])\n136         if self.fix_parens:\n137             self.has_explicit_title = False  # treat as implicit\n138             text, target = self.update_title_and_target(text, \"\")\n139 \n140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)\n141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)\n142 \n143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n144         target = self.target\n145         title = self.title\n146         if self.lowercase:\n147             target = target.lower()\n148         if self.fix_parens:\n149             title, target = self.update_title_and_target(title, target)\n150 \n151         # create the reference node\n152         options = {'refdoc': self.env.docname,\n153                    'refdomain': self.refdomain,\n154                    'reftype': self.reftype,\n155                    'refexplicit': self.has_explicit_title,\n156                    'refwarn': self.warn_dangling}\n157         refnode = self.nodeclass(self.rawtext, **options)\n158         self.set_source_info(refnode)\n159 \n160         # determine the target and title for the class\n161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,\n162                                           title, target)\n163         refnode['reftarget'] = target\n164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)\n165 \n166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)\n167 \n168     # methods that can be overwritten\n169 \n170     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n171                      title: str, target: str) -> Tuple[str, str]:\n172         \"\"\"Called after parsing title and target text, and creating the\n173         reference node (given in *refnode*).  This method can alter the\n174         reference node and must return a new (or the same) ``(title, target)``\n175         tuple.\n176         \"\"\"\n177         return title, ws_re.sub(' ', target)\n178 \n179     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n181         \"\"\"Called before returning the finished nodes.  *node* is the reference\n182         node if one was created (*is_ref* is then true), else the content node.\n183         This method can add other nodes and must return a ``(nodes, messages)``\n184         tuple (the usual return value of a role function).\n185         \"\"\"\n186         return [node], []\n187 \n188 \n189 class AnyXRefRole(XRefRole):\n190     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n191                      title: str, target: str) -> Tuple[str, str]:\n192         result = super().process_link(env, refnode, has_explicit_title, title, target)\n193         # add all possible context info (i.e. std:program, py:module etc.)\n194         refnode.attributes.update(env.ref_context)\n195         return result\n196 \n197 \n198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n199                      options: Dict = {}, content: List[str] = []\n200                      ) -> Tuple[List[Node], List[system_message]]:\n201     \"\"\"Role for PEP/RFC references that generate an index entry.\"\"\"\n202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',\n203                   RemovedInSphinx40Warning, stacklevel=2)\n204     env = inliner.document.settings.env\n205     if not typ:\n206         assert env.temp_data['default_role']\n207         typ = env.temp_data['default_role'].lower()\n208     else:\n209         typ = typ.lower()\n210 \n211     has_explicit_title, title, target = split_explicit_title(text)\n212     title = utils.unescape(title)\n213     target = utils.unescape(target)\n214     targetid = 'index-%s' % env.new_serialno('index')\n215     indexnode = addnodes.index()\n216     targetnode = nodes.target('', '', ids=[targetid])\n217     inliner.document.note_explicit_target(targetnode)\n218     if typ == 'pep':\n219         indexnode['entries'] = [\n220             ('single', _('Python Enhancement Proposals; PEP %s') % target,\n221              targetid, '', None)]\n222         anchor = ''\n223         anchorindex = target.find('#')\n224         if anchorindex > 0:\n225             target, anchor = target[:anchorindex], target[anchorindex:]\n226         if not has_explicit_title:\n227             title = \"PEP \" + utils.unescape(title)\n228         try:\n229             pepnum = int(target)\n230         except ValueError:\n231             msg = inliner.reporter.error('invalid PEP number %s' % target,\n232                                          line=lineno)\n233             prb = inliner.problematic(rawtext, rawtext, msg)\n234             return [prb], [msg]\n235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum\n236         sn = nodes.strong(title, title)\n237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n238                              classes=[typ])\n239         rn += sn\n240         return [indexnode, targetnode, rn], []\n241     elif typ == 'rfc':\n242         indexnode['entries'] = [\n243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]\n244         anchor = ''\n245         anchorindex = target.find('#')\n246         if anchorindex > 0:\n247             target, anchor = target[:anchorindex], target[anchorindex:]\n248         if not has_explicit_title:\n249             title = \"RFC \" + utils.unescape(title)\n250         try:\n251             rfcnum = int(target)\n252         except ValueError:\n253             msg = inliner.reporter.error('invalid RFC number %s' % target,\n254                                          line=lineno)\n255             prb = inliner.problematic(rawtext, rawtext, msg)\n256             return [prb], [msg]\n257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum\n258         sn = nodes.strong(title, title)\n259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n260                              classes=[typ])\n261         rn += sn\n262         return [indexnode, targetnode, rn], []\n263     else:\n264         raise ValueError('unknown role type: %s' % typ)\n265 \n266 \n267 class PEP(ReferenceRole):\n268     def run(self) -> Tuple[List[Node], List[system_message]]:\n269         target_id = 'index-%s' % self.env.new_serialno('index')\n270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,\n271                     target_id, '', None)]\n272 \n273         index = addnodes.index(entries=entries)\n274         target = nodes.target('', '', ids=[target_id])\n275         self.inliner.document.note_explicit_target(target)\n276 \n277         try:\n278             refuri = self.build_uri()\n279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])\n280             if self.has_explicit_title:\n281                 reference += nodes.strong(self.title, self.title)\n282             else:\n283                 title = \"PEP \" + self.title\n284                 reference += nodes.strong(title, title)\n285         except ValueError:\n286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,\n287                                               line=self.lineno)\n288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n289             return [prb], [msg]\n290 \n291         return [index, target, reference], []\n292 \n293     def build_uri(self) -> str:\n294         base_url = self.inliner.document.settings.pep_base_url\n295         ret = self.target.split('#', 1)\n296         if len(ret) == 2:\n297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])\n298         else:\n299             return base_url + 'pep-%04d' % int(ret[0])\n300 \n301 \n302 class RFC(ReferenceRole):\n303     def run(self) -> Tuple[List[Node], List[system_message]]:\n304         target_id = 'index-%s' % self.env.new_serialno('index')\n305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]\n306 \n307         index = addnodes.index(entries=entries)\n308         target = nodes.target('', '', ids=[target_id])\n309         self.inliner.document.note_explicit_target(target)\n310 \n311         try:\n312             refuri = self.build_uri()\n313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])\n314             if self.has_explicit_title:\n315                 reference += nodes.strong(self.title, self.title)\n316             else:\n317                 title = \"RFC \" + self.title\n318                 reference += nodes.strong(title, title)\n319         except ValueError:\n320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,\n321                                               line=self.lineno)\n322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n323             return [prb], [msg]\n324 \n325         return [index, target, reference], []\n326 \n327     def build_uri(self) -> str:\n328         base_url = self.inliner.document.settings.rfc_base_url\n329         ret = self.target.split('#', 1)\n330         if len(ret) == 2:\n331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]\n332         else:\n333             return base_url + self.inliner.rfc_url % int(ret[0])\n334 \n335 \n336 _amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n337 \n338 \n339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n340                  options: Dict = {}, content: List[str] = []\n341                  ) -> Tuple[List[Node], List[system_message]]:\n342     warnings.warn('menusel_role() is deprecated. '\n343                   'Please use MenuSelection or GUILabel class instead.',\n344                   RemovedInSphinx40Warning, stacklevel=2)\n345     env = inliner.document.settings.env\n346     if not typ:\n347         assert env.temp_data['default_role']\n348         typ = env.temp_data['default_role'].lower()\n349     else:\n350         typ = typ.lower()\n351 \n352     text = utils.unescape(text)\n353     if typ == 'menuselection':\n354         text = text.replace('-->', '\\N{TRIANGULAR BULLET}')\n355     spans = _amp_re.split(text)\n356 \n357     node = nodes.inline(rawtext=rawtext)\n358     for i, span in enumerate(spans):\n359         span = span.replace('&&', '&')\n360         if i == 0:\n361             if len(span) > 0:\n362                 textnode = nodes.Text(span)\n363                 node += textnode\n364             continue\n365         accel_node = nodes.inline()\n366         letter_node = nodes.Text(span[0])\n367         accel_node += letter_node\n368         accel_node['classes'].append('accelerator')\n369         node += accel_node\n370         textnode = nodes.Text(span[1:])\n371         node += textnode\n372 \n373     node['classes'].append(typ)\n374     return [node], []\n375 \n376 \n377 class GUILabel(SphinxRole):\n378     amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n379 \n380     def run(self) -> Tuple[List[Node], List[system_message]]:\n381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])\n382         spans = self.amp_re.split(self.text)\n383         node += nodes.Text(spans.pop(0))\n384         for span in spans:\n385             span = span.replace('&&', '&')\n386 \n387             letter = nodes.Text(span[0])\n388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])\n389             node += accelerator\n390             node += nodes.Text(span[1:])\n391 \n392         return [node], []\n393 \n394 \n395 class MenuSelection(GUILabel):\n396     BULLET_CHARACTER = '\\N{TRIANGULAR BULLET}'\n397 \n398     def run(self) -> Tuple[List[Node], List[system_message]]:\n399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)\n400         return super().run()\n401 \n402 \n403 _litvar_re = re.compile('{([^}]+)}')\n404 parens_re = re.compile(r'(\\\\*{|\\\\*})')\n405 \n406 \n407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n408                       options: Dict = {}, content: List[str] = []\n409                       ) -> Tuple[List[Node], List[system_message]]:\n410     warnings.warn('emph_literal_role() is deprecated. '\n411                   'Please use EmphasizedLiteral class instead.',\n412                   RemovedInSphinx40Warning, stacklevel=2)\n413     env = inliner.document.settings.env\n414     if not typ:\n415         assert env.temp_data['default_role']\n416         typ = env.temp_data['default_role'].lower()\n417     else:\n418         typ = typ.lower()\n419 \n420     retnode = nodes.literal(role=typ.lower(), classes=[typ])\n421     parts = list(parens_re.split(utils.unescape(text)))\n422     stack = ['']\n423     for part in parts:\n424         matched = parens_re.match(part)\n425         if matched:\n426             backslashes = len(part) - 1\n427             if backslashes % 2 == 1:    # escaped\n428                 stack[-1] += \"\\\\\" * int((backslashes - 1) / 2) + part[-1]\n429             elif part[-1] == '{':       # rparen\n430                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n431                 if len(stack) >= 2 and stack[-2] == \"{\":\n432                     # nested\n433                     stack[-1] += \"{\"\n434                 else:\n435                     # start emphasis\n436                     stack.append('{')\n437                     stack.append('')\n438             else:                       # lparen\n439                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n440                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n441                     # emphasized word found\n442                     if stack[0]:\n443                         retnode += nodes.Text(stack[0], stack[0])\n444                     retnode += nodes.emphasis(stack[2], stack[2])\n445                     stack = ['']\n446                 else:\n447                     # emphasized word not found; the rparen is not a special symbol\n448                     stack.append('}')\n449                     stack = [''.join(stack)]\n450         else:\n451             stack[-1] += part\n452     if ''.join(stack):\n453         # remaining is treated as Text\n454         text = ''.join(stack)\n455         retnode += nodes.Text(text, text)\n456 \n457     return [retnode], []\n458 \n459 \n460 class EmphasizedLiteral(SphinxRole):\n461     parens_re = re.compile(r'(\\\\\\\\|\\\\{|\\\\}|{|})')\n462 \n463     def run(self) -> Tuple[List[Node], List[system_message]]:\n464         children = self.parse(self.text)\n465         node = nodes.literal(self.rawtext, '', *children,\n466                              role=self.name.lower(), classes=[self.name])\n467 \n468         return [node], []\n469 \n470     def parse(self, text: str) -> List[Node]:\n471         result = []  # type: List[Node]\n472 \n473         stack = ['']\n474         for part in self.parens_re.split(text):\n475             if part == '\\\\\\\\':  # escaped backslash\n476                 stack[-1] += '\\\\'\n477             elif part == '{':\n478                 if len(stack) >= 2 and stack[-2] == \"{\":  # nested\n479                     stack[-1] += \"{\"\n480                 else:\n481                     # start emphasis\n482                     stack.append('{')\n483                     stack.append('')\n484             elif part == '}':\n485                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n486                     # emphasized word found\n487                     if stack[0]:\n488                         result.append(nodes.Text(stack[0], stack[0]))\n489                     result.append(nodes.emphasis(stack[2], stack[2]))\n490                     stack = ['']\n491                 else:\n492                     # emphasized word not found; the rparen is not a special symbol\n493                     stack.append('}')\n494                     stack = [''.join(stack)]\n495             elif part == '\\\\{':  # escaped left-brace\n496                 stack[-1] += '{'\n497             elif part == '\\\\}':  # escaped right-brace\n498                 stack[-1] += '}'\n499             else:  # others (containing escaped braces)\n500                 stack[-1] += part\n501 \n502         if ''.join(stack):\n503             # remaining is treated as Text\n504             text = ''.join(stack)\n505             result.append(nodes.Text(text, text))\n506 \n507         return result\n508 \n509 \n510 _abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n511 \n512 \n513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n514               options: Dict = {}, content: List[str] = []\n515               ) -> Tuple[List[Node], List[system_message]]:\n516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',\n517                   RemovedInSphinx40Warning, stacklevel=2)\n518     text = utils.unescape(text)\n519     m = _abbr_re.search(text)\n520     if m is None:\n521         return [nodes.abbreviation(text, text, **options)], []\n522     abbr = text[:m.start()].strip()\n523     expl = m.group(1)\n524     options = options.copy()\n525     options['explanation'] = expl\n526     return [nodes.abbreviation(abbr, abbr, **options)], []\n527 \n528 \n529 class Abbreviation(SphinxRole):\n530     abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n531 \n532     def run(self) -> Tuple[List[Node], List[system_message]]:\n533         matched = self.abbr_re.search(self.text)\n534         if matched:\n535             text = self.text[:matched.start()].strip()\n536             self.options['explanation'] = matched.group(1)\n537         else:\n538             text = self.text\n539 \n540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []\n541 \n542 \n543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n544                options: Dict = {}, content: List[str] = []\n545                ) -> Tuple[List[Node], List[system_message]]:\n546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',\n547                   RemovedInSphinx40Warning, stacklevel=2)\n548     # create new reference target\n549     env = inliner.document.settings.env\n550     targetid = 'index-%s' % env.new_serialno('index')\n551     targetnode = nodes.target('', '', ids=[targetid])\n552     # split text and target in role content\n553     has_explicit_title, title, target = split_explicit_title(text)\n554     title = utils.unescape(title)\n555     target = utils.unescape(target)\n556     # if an explicit target is given, we can process it as a full entry\n557     if has_explicit_title:\n558         entries = process_index_entry(target, targetid)\n559     # otherwise we just create a \"single\" entry\n560     else:\n561         # but allow giving main entry\n562         main = ''\n563         if target.startswith('!'):\n564             target = target[1:]\n565             title = title[1:]\n566             main = 'main'\n567         entries = [('single', target, targetid, main, None)]\n568     indexnode = addnodes.index()\n569     indexnode['entries'] = entries\n570     set_role_source_info(inliner, lineno, indexnode)\n571     textnode = nodes.Text(title, title)\n572     return [indexnode, targetnode, textnode], []\n573 \n574 \n575 class Index(ReferenceRole):\n576     def run(self) -> Tuple[List[Node], List[system_message]]:\n577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)\n578         target_id = 'index-%s' % self.env.new_serialno('index')\n579         if self.has_explicit_title:\n580             # if an explicit target is given, process it as a full entry\n581             title = self.title\n582             entries = process_index_entry(self.target, target_id)\n583         else:\n584             # otherwise we just create a single entry\n585             if self.target.startswith('!'):\n586                 title = self.title[1:]\n587                 entries = [('single', self.target[1:], target_id, 'main', None)]\n588             else:\n589                 title = self.title\n590                 entries = [('single', self.target, target_id, '', None)]\n591 \n592         index = addnodes.index(entries=entries)\n593         target = nodes.target('', '', ids=[target_id])\n594         text = nodes.Text(title, title)\n595         self.set_source_info(index)\n596         return [index, target, text], []\n597 \n598 \n599 specific_docroles = {\n600     # links to download references\n601     'download': XRefRole(nodeclass=addnodes.download_reference),\n602     # links to anything\n603     'any': AnyXRefRole(warn_dangling=True),\n604 \n605     'pep': PEP(),\n606     'rfc': RFC(),\n607     'guilabel': GUILabel(),\n608     'menuselection': MenuSelection(),\n609     'file': EmphasizedLiteral(),\n610     'samp': EmphasizedLiteral(),\n611     'abbr': Abbreviation(),\n612 }  # type: Dict[str, RoleFunction]\n613 \n614 \n615 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n616     from docutils.parsers.rst import roles\n617 \n618     for rolename, nodeclass in generic_docroles.items():\n619         generic = roles.GenericRole(rolename, nodeclass)\n620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})\n621         roles.register_local_role(rolename, role)\n622 \n623     for rolename, func in specific_docroles.items():\n624         roles.register_local_role(rolename, func)\n625 \n626     return {\n627         'version': 'builtin',\n628         'parallel_read_safe': True,\n629         'parallel_write_safe': True,\n630     }\n",
        "intended_behavior": "Modify or extend the method responsible for `:kbd:` role processing to parse the role's value and generate separate `<kbd>` elements for each key and/or combination described within the value. This parsing should account for different separators (like spaces or plus signs) and properly nest or sequentially place `<kbd>` elements as needed. The existing functionality for roles should be preserved, meaning this enhancement should only affect how `:kbd:` values are interpreted and converted into HTML."
    },
    {
        "rel_file_path": "sphinx/domains/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/domains/__init__.py",
        "start": 1,
        "end": 402,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.domains\n3     ~~~~~~~~~~~~~~\n4 \n5     Support for domains, which are groupings of description directives\n6     and roles describing e.g. constructs of one programming language.\n7 \n8     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n9     :license: BSD, see LICENSE for details.\n10 \"\"\"\n11 \n12 import copy\n13 from typing import Any, Callable, Dict, Iterable, List, NamedTuple, Tuple, Union\n14 from typing import cast\n15 \n16 from docutils import nodes\n17 from docutils.nodes import Element, Node, system_message\n18 from docutils.parsers.rst.states import Inliner\n19 \n20 from sphinx.addnodes import pending_xref\n21 from sphinx.errors import SphinxError\n22 from sphinx.locale import _\n23 from sphinx.roles import XRefRole\n24 from sphinx.util.typing import RoleFunction\n25 \n26 if False:\n27     # For type annotation\n28     from typing import Type  # for python3.5.1\n29     from sphinx.builders import Builder\n30     from sphinx.environment import BuildEnvironment\n31 \n32 \n33 class ObjType:\n34     \"\"\"\n35     An ObjType is the description for a type of object that a domain can\n36     document.  In the object_types attribute of Domain subclasses, object type\n37     names are mapped to instances of this class.\n38 \n39     Constructor arguments:\n40 \n41     - *lname*: localized name of the type (do not include domain name)\n42     - *roles*: all the roles that can refer to an object of this type\n43     - *attrs*: object attributes -- currently only \"searchprio\" is known,\n44       which defines the object's priority in the full-text search index,\n45       see :meth:`Domain.get_objects()`.\n46     \"\"\"\n47 \n48     known_attrs = {\n49         'searchprio': 1,\n50     }\n51 \n52     def __init__(self, lname: str, *roles: Any, **attrs: Any) -> None:\n53         self.lname = lname\n54         self.roles = roles                      # type: Tuple\n55         self.attrs = self.known_attrs.copy()    # type: Dict\n56         self.attrs.update(attrs)\n57 \n58 \n59 IndexEntry = NamedTuple('IndexEntry', [('name', str),\n60                                        ('subtype', int),\n61                                        ('docname', str),\n62                                        ('anchor', str),\n63                                        ('extra', str),\n64                                        ('qualifier', str),\n65                                        ('descr', str)])\n66 \n67 \n68 class Index:\n69     \"\"\"\n70     An Index is the description for a domain-specific index.  To add an index to\n71     a domain, subclass Index, overriding the three name attributes:\n72 \n73     * `name` is an identifier used for generating file names.\n74       It is also used for a hyperlink target for the index. Therefore, users can\n75       refer the index page using ``ref`` role and a string which is combined\n76       domain name and ``name`` attribute (ex. ``:ref:`py-modindex```).\n77     * `localname` is the section title for the index.\n78     * `shortname` is a short name for the index, for use in the relation bar in\n79       HTML output.  Can be empty to disable entries in the relation bar.\n80 \n81     and providing a :meth:`generate()` method.  Then, add the index class to\n82     your domain's `indices` list.  Extensions can add indices to existing\n83     domains using :meth:`~sphinx.application.Sphinx.add_index_to_domain()`.\n84 \n85     .. versionchanged:: 3.0\n86 \n87        Index pages can be referred by domain name and index name via\n88        :rst:role:`ref` role.\n89     \"\"\"\n90 \n91     name = None  # type: str\n92     localname = None  # type: str\n93     shortname = None  # type: str\n94 \n95     def __init__(self, domain: \"Domain\") -> None:\n96         if self.name is None or self.localname is None:\n97             raise SphinxError('Index subclass %s has no valid name or localname'\n98                               % self.__class__.__name__)\n99         self.domain = domain\n100 \n101     def generate(self, docnames: Iterable[str] = None\n102                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:\n103         \"\"\"Get entries for the index.\n104 \n105         If ``docnames`` is given, restrict to entries referring to these\n106         docnames.\n107 \n108         The return value is a tuple of ``(content, collapse)``:\n109 \n110         ``collapse``\n111           A boolean that determines if sub-entries should start collapsed (for\n112           output formats that support collapsing sub-entries).\n113 \n114         ``content``:\n115           A sequence of ``(letter, entries)`` tuples, where ``letter`` is the\n116           \"heading\" for the given ``entries``, usually the starting letter, and\n117           ``entries`` is a sequence of single entries. Each entry is a sequence\n118           ``[name, subtype, docname, anchor, extra, qualifier, descr]``. The\n119           items in this sequence have the following meaning:\n120 \n121           ``name``\n122             The name of the index entry to be displayed.\n123 \n124           ``subtype``\n125             The sub-entry related type. One of:\n126 \n127             ``0``\n128               A normal entry.\n129             ``1``\n130               An entry with sub-entries.\n131             ``2``\n132               A sub-entry.\n133 \n134           ``docname``\n135             *docname* where the entry is located.\n136 \n137           ``anchor``\n138             Anchor for the entry within ``docname``\n139 \n140           ``extra``\n141             Extra info for the entry.\n142 \n143           ``qualifier``\n144             Qualifier for the description.\n145 \n146           ``descr``\n147             Description for the entry.\n148 \n149         Qualifier and description are not rendered for some output formats such\n150         as LaTeX.\n151         \"\"\"\n152         raise NotImplementedError\n153 \n154 \n155 class Domain:\n156     \"\"\"\n157     A Domain is meant to be a group of \"object\" description directives for\n158     objects of a similar nature, and corresponding roles to create references to\n159     them.  Examples would be Python modules, classes, functions etc., elements\n160     of a templating language, Sphinx roles and directives, etc.\n161 \n162     Each domain has a separate storage for information about existing objects\n163     and how to reference them in `self.data`, which must be a dictionary.  It\n164     also must implement several functions that expose the object information in\n165     a uniform way to parts of Sphinx that allow the user to reference or search\n166     for objects in a domain-agnostic way.\n167 \n168     About `self.data`: since all object and cross-referencing information is\n169     stored on a BuildEnvironment instance, the `domain.data` object is also\n170     stored in the `env.domaindata` dict under the key `domain.name`.  Before the\n171     build process starts, every active domain is instantiated and given the\n172     environment object; the `domaindata` dict must then either be nonexistent or\n173     a dictionary whose 'version' key is equal to the domain class'\n174     :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the\n175     pickled environment is discarded.\n176     \"\"\"\n177 \n178     #: domain name: should be short, but unique\n179     name = ''\n180     #: domain label: longer, more descriptive (used in messages)\n181     label = ''\n182     #: type (usually directive) name -> ObjType instance\n183     object_types = {}       # type: Dict[str, ObjType]\n184     #: directive name -> directive class\n185     directives = {}         # type: Dict[str, Any]\n186     #: role name -> role callable\n187     roles = {}              # type: Dict[str, Union[RoleFunction, XRefRole]]\n188     #: a list of Index subclasses\n189     indices = []            # type: List[Type[Index]]\n190     #: role name -> a warning message if reference is missing\n191     dangling_warnings = {}  # type: Dict[str, str]\n192     #: node_class -> (enum_node_type, title_getter)\n193     enumerable_nodes = {}   # type: Dict[Type[Node], Tuple[str, Callable]]\n194 \n195     #: data value for a fresh environment\n196     initial_data = {}       # type: Dict\n197     #: data value\n198     data = None             # type: Dict\n199     #: data version, bump this when the format of `self.data` changes\n200     data_version = 0\n201 \n202     def __init__(self, env: \"BuildEnvironment\") -> None:\n203         self.env = env              # type: BuildEnvironment\n204         self._role_cache = {}       # type: Dict[str, Callable]\n205         self._directive_cache = {}  # type: Dict[str, Callable]\n206         self._role2type = {}        # type: Dict[str, List[str]]\n207         self._type2role = {}        # type: Dict[str, str]\n208 \n209         # convert class variables to instance one (to enhance through API)\n210         self.object_types = dict(self.object_types)\n211         self.directives = dict(self.directives)\n212         self.roles = dict(self.roles)\n213         self.indices = list(self.indices)\n214 \n215         if self.name not in env.domaindata:\n216             assert isinstance(self.initial_data, dict)\n217             new_data = copy.deepcopy(self.initial_data)\n218             new_data['version'] = self.data_version\n219             self.data = env.domaindata[self.name] = new_data\n220         else:\n221             self.data = env.domaindata[self.name]\n222             if self.data['version'] != self.data_version:\n223                 raise OSError('data of %r domain out of date' % self.label)\n224         for name, obj in self.object_types.items():\n225             for rolename in obj.roles:\n226                 self._role2type.setdefault(rolename, []).append(name)\n227             self._type2role[name] = obj.roles[0] if obj.roles else ''\n228         self.objtypes_for_role = self._role2type.get    # type: Callable[[str], List[str]]\n229         self.role_for_objtype = self._type2role.get     # type: Callable[[str], str]\n230 \n231     def setup(self) -> None:\n232         \"\"\"Set up domain object.\"\"\"\n233         from sphinx.domains.std import StandardDomain\n234 \n235         # Add special hyperlink target for index pages (ex. py-modindex)\n236         std = cast(StandardDomain, self.env.get_domain('std'))\n237         for index in self.indices:\n238             if index.name and index.localname:\n239                 docname = \"%s-%s\" % (self.name, index.name)\n240                 std.note_hyperlink_target(docname, docname, '', index.localname)\n241 \n242     def add_object_type(self, name: str, objtype: ObjType) -> None:\n243         \"\"\"Add an object type.\"\"\"\n244         self.object_types[name] = objtype\n245         if objtype.roles:\n246             self._type2role[name] = objtype.roles[0]\n247         else:\n248             self._type2role[name] = ''\n249 \n250         for role in objtype.roles:\n251             self._role2type.setdefault(role, []).append(name)\n252 \n253     def role(self, name: str) -> RoleFunction:\n254         \"\"\"Return a role adapter function that always gives the registered\n255         role its full name ('domain:name') as the first argument.\n256         \"\"\"\n257         if name in self._role_cache:\n258             return self._role_cache[name]\n259         if name not in self.roles:\n260             return None\n261         fullname = '%s:%s' % (self.name, name)\n262 \n263         def role_adapter(typ: str, rawtext: str, text: str, lineno: int,\n264                          inliner: Inliner, options: Dict = {}, content: List[str] = []\n265                          ) -> Tuple[List[Node], List[system_message]]:\n266             return self.roles[name](fullname, rawtext, text, lineno,\n267                                     inliner, options, content)\n268         self._role_cache[name] = role_adapter\n269         return role_adapter\n270 \n271     def directive(self, name: str) -> Callable:\n272         \"\"\"Return a directive adapter class that always gives the registered\n273         directive its full name ('domain:name') as ``self.name``.\n274         \"\"\"\n275         if name in self._directive_cache:\n276             return self._directive_cache[name]\n277         if name not in self.directives:\n278             return None\n279         fullname = '%s:%s' % (self.name, name)\n280         BaseDirective = self.directives[name]\n281 \n282         class DirectiveAdapter(BaseDirective):  # type: ignore\n283             def run(self) -> List[Node]:\n284                 self.name = fullname\n285                 return super().run()\n286         self._directive_cache[name] = DirectiveAdapter\n287         return DirectiveAdapter\n288 \n289     # methods that should be overwritten\n290 \n291     def clear_doc(self, docname: str) -> None:\n292         \"\"\"Remove traces of a document in the domain-specific inventories.\"\"\"\n293         pass\n294 \n295     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n296         \"\"\"Merge in data regarding *docnames* from a different domaindata\n297         inventory (coming from a subprocess in parallel builds).\n298         \"\"\"\n299         raise NotImplementedError('merge_domaindata must be implemented in %s '\n300                                   'to be able to do parallel builds!' %\n301                                   self.__class__)\n302 \n303     def process_doc(self, env: \"BuildEnvironment\", docname: str,\n304                     document: nodes.document) -> None:\n305         \"\"\"Process a document after it is read by the environment.\"\"\"\n306         pass\n307 \n308     def check_consistency(self) -> None:\n309         \"\"\"Do consistency checks (**experimental**).\"\"\"\n310         pass\n311 \n312     def process_field_xref(self, pnode: pending_xref) -> None:\n313         \"\"\"Process a pending xref created in a doc field.\n314         For example, attach information about the current scope.\n315         \"\"\"\n316         pass\n317 \n318     def resolve_xref(self, env: \"BuildEnvironment\", fromdocname: str, builder: \"Builder\",\n319                      typ: str, target: str, node: pending_xref, contnode: Element\n320                      ) -> Element:\n321         \"\"\"Resolve the pending_xref *node* with the given *typ* and *target*.\n322 \n323         This method should return a new node, to replace the xref node,\n324         containing the *contnode* which is the markup content of the\n325         cross-reference.\n326 \n327         If no resolution can be found, None can be returned; the xref node will\n328         then given to the :event:`missing-reference` event, and if that yields no\n329         resolution, replaced by *contnode*.\n330 \n331         The method can also raise :exc:`sphinx.environment.NoUri` to suppress\n332         the :event:`missing-reference` event being emitted.\n333         \"\"\"\n334         pass\n335 \n336     def resolve_any_xref(self, env: \"BuildEnvironment\", fromdocname: str, builder: \"Builder\",\n337                          target: str, node: pending_xref, contnode: Element\n338                          ) -> List[Tuple[str, Element]]:\n339         \"\"\"Resolve the pending_xref *node* with the given *target*.\n340 \n341         The reference comes from an \"any\" or similar role, which means that we\n342         don't know the type.  Otherwise, the arguments are the same as for\n343         :meth:`resolve_xref`.\n344 \n345         The method must return a list (potentially empty) of tuples\n346         ``('domain:role', newnode)``, where ``'domain:role'`` is the name of a\n347         role that could have created the same reference, e.g. ``'py:func'``.\n348         ``newnode`` is what :meth:`resolve_xref` would return.\n349 \n350         .. versionadded:: 1.3\n351         \"\"\"\n352         raise NotImplementedError\n353 \n354     def get_objects(self) -> Iterable[Tuple[str, str, str, str, str, int]]:\n355         \"\"\"Return an iterable of \"object descriptions\".\n356 \n357         Object descriptions are tuples with six items:\n358 \n359         ``name``\n360           Fully qualified name.\n361 \n362         ``dispname``\n363           Name to display when searching/linking.\n364 \n365         ``type``\n366           Object type, a key in ``self.object_types``.\n367 \n368         ``docname``\n369           The document where it is to be found.\n370 \n371         ``anchor``\n372           The anchor name for the object.\n373 \n374         ``priority``\n375           How \"important\" the object is (determines placement in search\n376           results). One of:\n377 \n378           ``1``\n379             Default priority (placed before full-text matches).\n380           ``0``\n381             Object is important (placed before default-priority objects).\n382           ``2``\n383             Object is unimportant (placed after full-text matches).\n384           ``-1``\n385             Object should not show up in search at all.\n386         \"\"\"\n387         return []\n388 \n389     def get_type_name(self, type: ObjType, primary: bool = False) -> str:\n390         \"\"\"Return full name for given ObjType.\"\"\"\n391         if primary:\n392             return type.lname\n393         return _('%s %s') % (self.label, type.lname)\n394 \n395     def get_enumerable_node_type(self, node: Node) -> str:\n396         \"\"\"Get type of enumerable nodes (experimental).\"\"\"\n397         enum_node_type, _ = self.enumerable_nodes.get(node.__class__, (None, None))\n398         return enum_node_type\n399 \n400     def get_full_qualified_name(self, node: Element) -> str:\n401         \"\"\"Return full qualified name for given node.\"\"\"\n402         return None\n",
        "intended_behavior": "If any specific handling or customization for `:kbd:` or similar roles exists within domain-specific logic, ensure that these are compatible with or extended to support the new, more granular approach to generating `<kbd>` elements. Any domain-specific overrides or extensions that handle these roles should be reviewed to ensure they remain functional or are enhanced to support the intended nested or sequential `<kbd>` behavior."
    }
]