2025-10-15 11:51:31.947 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 11:51:34.263 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=438, output_tokens=12, cost=0.004740
2025-10-15 11:51:34.264 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 11:51:34.268 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:51:40.850 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=742, output_tokens=247, cost=0.014830
2025-10-15 11:51:40.855 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:51:43.068 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=601, output_tokens=47, cost=0.007420
2025-10-15 11:51:43.070 | DEBUG    | Extracted a valid json.
2025-10-15 11:51:43.070 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"parse_restructuredtext\")",
        "search_method(\"convert_to_html\")",
        "search_code(\":kbd:\")"
    ],
    "bug_locations": []
}
2025-10-15 11:51:43.085 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 11:51:43.086 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 11:51:50.828 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1166, output_tokens=381, cost=0.023090
2025-10-15 11:51:50.840 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:51:53.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1763, output_tokens=29, cost=0.018500
2025-10-15 11:51:53.076 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:51:56.423 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=383, output_tokens=42, cost=0.005090
2025-10-15 11:51:56.425 | DEBUG    | Extracted a valid json.
2025-10-15 11:51:56.425 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"Role\")", "search_class(\"Directive\")", "search_code(\"roles\")", "search_code(\"directives\")"],
    "bug_locations": []
}
2025-10-15 11:51:56.697 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 11:51:56.698 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 11:52:08.777 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2943, output_tokens=562, cost=0.046290
2025-10-15 11:52:08.783 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 11:52:16.226 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3721, output_tokens=250, cost=0.044710
2025-10-15 11:52:16.232 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 11:52:23.968 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=604, output_tokens=252, cost=0.013600
2025-10-15 11:52:23.969 | DEBUG    | Extracted a valid json.
2025-10-15 11:52:23.969 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/roles.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify or extend the method responsible for `:kbd:` role processing to parse the role's value and generate separate `<kbd>` elements for each key and/or combination described within the value. This parsing should account for different separators (like spaces or plus signs) and properly nest or sequentially place `<kbd>` elements as needed. The existing functionality for roles should be preserved, meaning this enhancement should only affect how `:kbd:` values are interpreted and converted into HTML."
        },
        {
            "file": "sphinx/domains/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "If any specific handling or customization for `:kbd:` or similar roles exists within domain-specific logic, ensure that these are compatible with or extended to support the new, more granular approach to generating `<kbd>` elements. Any domain-specific overrides or extensions that handle these roles should be reviewed to ensure they remain functional or are enhanced to support the intended nested or sequential `<kbd>` behavior."
        }
    ]
}
2025-10-15 11:52:23.976 | DEBUG    | Bug location extracted successfully: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import (
25     split_explicit_title, process_index_entry, set_role_source_info
26 )
27 from sphinx.util.typing import RoleFunction
28 
29 if False:
30     # For type annotation
31     from typing import Type  # for python3.5.1
32     from sphinx.application import Sphinx
33     from sphinx.environment import BuildEnvironment
34 
35 
36 generic_docroles = {
37     'command': addnodes.literal_strong,
38     'dfn': nodes.emphasis,
39     'kbd': nodes.literal,
40     'mailheader': addnodes.literal_emphasis,
41     'makevar': addnodes.literal_strong,
42     'manpage': addnodes.manpage,
43     'mimetype': addnodes.literal_emphasis,
44     'newsgroup': addnodes.literal_emphasis,
45     'program': addnodes.literal_strong,  # XXX should be an x-ref
46     'regexp': nodes.literal,
47 }
48 
49 
50 # -- generic cross-reference role ----------------------------------------------
51 
52 class XRefRole(ReferenceRole):
53     """
54     A generic cross-referencing role.  To create a callable that can be used as
55     a role function, create an instance of this class.
56 
57     The general features of this role are:
58 
59     * Automatic creation of a reference and a content node.
60     * Optional separation of title and target with `title <target>`.
61     * The implementation is a class rather than a function to make
62       customization easier.
63 
64     Customization can be done in two ways:
65 
66     * Supplying constructor parameters:
67       * `fix_parens` to normalize parentheses (strip from target, and add to
68         title if configured)
69       * `lowercase` to lowercase the target
70       * `nodeclass` and `innernodeclass` select the node classes for
71         the reference and the content node
72 
73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
74     """
75 
76     nodeclass = addnodes.pending_xref   # type: Type[Element]
77     innernodeclass = nodes.literal      # type: Type[TextElement]
78 
79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
80                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
81                  warn_dangling: bool = False) -> None:
82         self.fix_parens = fix_parens
83         self.lowercase = lowercase
84         self.warn_dangling = warn_dangling
85         if nodeclass is not None:
86             self.nodeclass = nodeclass
87         if innernodeclass is not None:
88             self.innernodeclass = innernodeclass
89 
90         super().__init__()
91 
92     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
93                     target: str) -> Tuple[str, str]:
94         warnings.warn('XRefRole._fix_parens() is deprecated.',
95                       RemovedInSphinx40Warning, stacklevel=2)
96         if not has_explicit_title:
97             if title.endswith('()'):
98                 # remove parentheses
99                 title = title[:-2]
100             if env.config.add_function_parentheses:
101                 # add them back to all occurrences if configured
102                 title += '()'
103         # remove parentheses from the target too
104         if target.endswith('()'):
105             target = target[:-2]
106         return title, target
107 
108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
109         if not self.has_explicit_title:
110             if title.endswith('()'):
111                 # remove parentheses
112                 title = title[:-2]
113             if self.config.add_function_parentheses:
114                 # add them back to all occurrences if configured
115                 title += '()'
116         # remove parentheses from the target too
117         if target.endswith('()'):
118             target = target[:-2]
119         return title, target
120 
121     def run(self) -> Tuple[List[Node], List[system_message]]:
122         if ':' not in self.name:
123             self.refdomain, self.reftype = '', self.name
124             self.classes = ['xref', self.reftype]
125         else:
126             self.refdomain, self.reftype = self.name.split(':', 1)
127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
128 
129         if self.disabled:
130             return self.create_non_xref_node()
131         else:
132             return self.create_xref_node()
133 
134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
135         text = utils.unescape(self.text[1:])
136         if self.fix_parens:
137             self.has_explicit_title = False  # treat as implicit
138             text, target = self.update_title_and_target(text, "")
139 
140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
142 
143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
144         target = self.target
145         title = self.title
146         if self.lowercase:
147             target = target.lower()
148         if self.fix_parens:
149             title, target = self.update_title_and_target(title, target)
150 
151         # create the reference node
152         options = {'refdoc': self.env.docname,
153                    'refdomain': self.refdomain,
154                    'reftype': self.reftype,
155                    'refexplicit': self.has_explicit_title,
156                    'refwarn': self.warn_dangling}
157         refnode = self.nodeclass(self.rawtext, **options)
158         self.set_source_info(refnode)
159 
160         # determine the target and title for the class
161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
162                                           title, target)
163         refnode['reftarget'] = target
164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
165 
166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
167 
168     # methods that can be overwritten
169 
170     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
171                      title: str, target: str) -> Tuple[str, str]:
172         """Called after parsing title and target text, and creating the
173         reference node (given in *refnode*).  This method can alter the
174         reference node and must return a new (or the same) ``(title, target)``
175         tuple.
176         """
177         return title, ws_re.sub(' ', target)
178 
179     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
181         """Called before returning the finished nodes.  *node* is the reference
182         node if one was created (*is_ref* is then true), else the content node.
183         This method can add other nodes and must return a ``(nodes, messages)``
184         tuple (the usual return value of a role function).
185         """
186         return [node], []
187 
188 
189 class AnyXRefRole(XRefRole):
190     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
191                      title: str, target: str) -> Tuple[str, str]:
192         result = super().process_link(env, refnode, has_explicit_title, title, target)
193         # add all possible context info (i.e. std:program, py:module etc.)
194         refnode.attributes.update(env.ref_context)
195         return result
196 
197 
198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
199                      options: Dict = {}, content: List[str] = []
200                      ) -> Tuple[List[Node], List[system_message]]:
201     """Role for PEP/RFC references that generate an index entry."""
202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
203                   RemovedInSphinx40Warning, stacklevel=2)
204     env = inliner.document.settings.env
205     if not typ:
206         assert env.temp_data['default_role']
207         typ = env.temp_data['default_role'].lower()
208     else:
209         typ = typ.lower()
210 
211     has_explicit_title, title, target = split_explicit_title(text)
212     title = utils.unescape(title)
213     target = utils.unescape(target)
214     targetid = 'index-%s' % env.new_serialno('index')
215     indexnode = addnodes.index()
216     targetnode = nodes.target('', '', ids=[targetid])
217     inliner.document.note_explicit_target(targetnode)
218     if typ == 'pep':
219         indexnode['entries'] = [
220             ('single', _('Python Enhancement Proposals; PEP %s') % target,
221              targetid, '', None)]
222         anchor = ''
223         anchorindex = target.find('#')
224         if anchorindex > 0:
225             target, anchor = target[:anchorindex], target[anchorindex:]
226         if not has_explicit_title:
227             title = "PEP " + utils.unescape(title)
228         try:
229             pepnum = int(target)
230         except ValueError:
231             msg = inliner.reporter.error('invalid PEP number %s' % target,
232                                          line=lineno)
233             prb = inliner.problematic(rawtext, rawtext, msg)
234             return [prb], [msg]
235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
236         sn = nodes.strong(title, title)
237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
238                              classes=[typ])
239         rn += sn
240         return [indexnode, targetnode, rn], []
241     elif typ == 'rfc':
242         indexnode['entries'] = [
243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
244         anchor = ''
245         anchorindex = target.find('#')
246         if anchorindex > 0:
247             target, anchor = target[:anchorindex], target[anchorindex:]
248         if not has_explicit_title:
249             title = "RFC " + utils.unescape(title)
250         try:
251             rfcnum = int(target)
252         except ValueError:
253             msg = inliner.reporter.error('invalid RFC number %s' % target,
254                                          line=lineno)
255             prb = inliner.problematic(rawtext, rawtext, msg)
256             return [prb], [msg]
257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
258         sn = nodes.strong(title, title)
259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
260                              classes=[typ])
261         rn += sn
262         return [indexnode, targetnode, rn], []
263     else:
264         raise ValueError('unknown role type: %s' % typ)
265 
266 
267 class PEP(ReferenceRole):
268     def run(self) -> Tuple[List[Node], List[system_message]]:
269         target_id = 'index-%s' % self.env.new_serialno('index')
270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
271                     target_id, '', None)]
272 
273         index = addnodes.index(entries=entries)
274         target = nodes.target('', '', ids=[target_id])
275         self.inliner.document.note_explicit_target(target)
276 
277         try:
278             refuri = self.build_uri()
279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
280             if self.has_explicit_title:
281                 reference += nodes.strong(self.title, self.title)
282             else:
283                 title = "PEP " + self.title
284                 reference += nodes.strong(title, title)
285         except ValueError:
286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
287                                               line=self.lineno)
288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
289             return [prb], [msg]
290 
291         return [index, target, reference], []
292 
293     def build_uri(self) -> str:
294         base_url = self.inliner.document.settings.pep_base_url
295         ret = self.target.split('#', 1)
296         if len(ret) == 2:
297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
298         else:
299             return base_url + 'pep-%04d' % int(ret[0])
300 
301 
302 class RFC(ReferenceRole):
303     def run(self) -> Tuple[List[Node], List[system_message]]:
304         target_id = 'index-%s' % self.env.new_serialno('index')
305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
306 
307         index = addnodes.index(entries=entries)
308         target = nodes.target('', '', ids=[target_id])
309         self.inliner.document.note_explicit_target(target)
310 
311         try:
312             refuri = self.build_uri()
313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
314             if self.has_explicit_title:
315                 reference += nodes.strong(self.title, self.title)
316             else:
317                 title = "RFC " + self.title
318                 reference += nodes.strong(title, title)
319         except ValueError:
320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
321                                               line=self.lineno)
322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
323             return [prb], [msg]
324 
325         return [index, target, reference], []
326 
327     def build_uri(self) -> str:
328         base_url = self.inliner.document.settings.rfc_base_url
329         ret = self.target.split('#', 1)
330         if len(ret) == 2:
331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
332         else:
333             return base_url + self.inliner.rfc_url % int(ret[0])
334 
335 
336 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
337 
338 
339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
340                  options: Dict = {}, content: List[str] = []
341                  ) -> Tuple[List[Node], List[system_message]]:
342     warnings.warn('menusel_role() is deprecated. '
343                   'Please use MenuSelection or GUILabel class instead.',
344                   RemovedInSphinx40Warning, stacklevel=2)
345     env = inliner.document.settings.env
346     if not typ:
347         assert env.temp_data['default_role']
348         typ = env.temp_data['default_role'].lower()
349     else:
350         typ = typ.lower()
351 
352     text = utils.unescape(text)
353     if typ == 'menuselection':
354         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
355     spans = _amp_re.split(text)
356 
357     node = nodes.inline(rawtext=rawtext)
358     for i, span in enumerate(spans):
359         span = span.replace('&&', '&')
360         if i == 0:
361             if len(span) > 0:
362                 textnode = nodes.Text(span)
363                 node += textnode
364             continue
365         accel_node = nodes.inline()
366         letter_node = nodes.Text(span[0])
367         accel_node += letter_node
368         accel_node['classes'].append('accelerator')
369         node += accel_node
370         textnode = nodes.Text(span[1:])
371         node += textnode
372 
373     node['classes'].append(typ)
374     return [node], []
375 
376 
377 class GUILabel(SphinxRole):
378     amp_re = re.compile(r'(?<!&)&(?![&\s])')
379 
380     def run(self) -> Tuple[List[Node], List[system_message]]:
381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
382         spans = self.amp_re.split(self.text)
383         node += nodes.Text(spans.pop(0))
384         for span in spans:
385             span = span.replace('&&', '&')
386 
387             letter = nodes.Text(span[0])
388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
389             node += accelerator
390             node += nodes.Text(span[1:])
391 
392         return [node], []
393 
394 
395 class MenuSelection(GUILabel):
396     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
397 
398     def run(self) -> Tuple[List[Node], List[system_message]]:
399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
400         return super().run()
401 
402 
403 _litvar_re = re.compile('{([^}]+)}')
404 parens_re = re.compile(r'(\\*{|\\*})')
405 
406 
407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
408                       options: Dict = {}, content: List[str] = []
409                       ) -> Tuple[List[Node], List[system_message]]:
410     warnings.warn('emph_literal_role() is deprecated. '
411                   'Please use EmphasizedLiteral class instead.',
412                   RemovedInSphinx40Warning, stacklevel=2)
413     env = inliner.document.settings.env
414     if not typ:
415         assert env.temp_data['default_role']
416         typ = env.temp_data['default_role'].lower()
417     else:
418         typ = typ.lower()
419 
420     retnode = nodes.literal(role=typ.lower(), classes=[typ])
421     parts = list(parens_re.split(utils.unescape(text)))
422     stack = ['']
423     for part in parts:
424         matched = parens_re.match(part)
425         if matched:
426             backslashes = len(part) - 1
427             if backslashes % 2 == 1:    # escaped
428                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
429             elif part[-1] == '{':       # rparen
430                 stack[-1] += "\\" * int(backslashes / 2)
431                 if len(stack) >= 2 and stack[-2] == "{":
432                     # nested
433                     stack[-1] += "{"
434                 else:
435                     # start emphasis
436                     stack.append('{')
437                     stack.append('')
438             else:                       # lparen
439                 stack[-1] += "\\" * int(backslashes / 2)
440                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
441                     # emphasized word found
442                     if stack[0]:
443                         retnode += nodes.Text(stack[0], stack[0])
444                     retnode += nodes.emphasis(stack[2], stack[2])
445                     stack = ['']
446                 else:
447                     # emphasized word not found; the rparen is not a special symbol
448                     stack.append('}')
449                     stack = [''.join(stack)]
450         else:
451             stack[-1] += part
452     if ''.join(stack):
453         # remaining is treated as Text
454         text = ''.join(stack)
455         retnode += nodes.Text(text, text)
456 
457     return [retnode], []
458 
459 
460 class EmphasizedLiteral(SphinxRole):
461     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
462 
463     def run(self) -> Tuple[List[Node], List[system_message]]:
464         children = self.parse(self.text)
465         node = nodes.literal(self.rawtext, '', *children,
466                              role=self.name.lower(), classes=[self.name])
467 
468         return [node], []
469 
470     def parse(self, text: str) -> List[Node]:
471         result = []  # type: List[Node]
472 
473         stack = ['']
474         for part in self.parens_re.split(text):
475             if part == '\\\\':  # escaped backslash
476                 stack[-1] += '\\'
477             elif part == '{':
478                 if len(stack) >= 2 and stack[-2] == "{":  # nested
479                     stack[-1] += "{"
480                 else:
481                     # start emphasis
482                     stack.append('{')
483                     stack.append('')
484             elif part == '}':
485                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
486                     # emphasized word found
487                     if stack[0]:
488                         result.append(nodes.Text(stack[0], stack[0]))
489                     result.append(nodes.emphasis(stack[2], stack[2]))
490                     stack = ['']
491                 else:
492                     # emphasized word not found; the rparen is not a special symbol
493                     stack.append('}')
494                     stack = [''.join(stack)]
495             elif part == '\\{':  # escaped left-brace
496                 stack[-1] += '{'
497             elif part == '\\}':  # escaped right-brace
498                 stack[-1] += '}'
499             else:  # others (containing escaped braces)
500                 stack[-1] += part
501 
502         if ''.join(stack):
503             # remaining is treated as Text
504             text = ''.join(stack)
505             result.append(nodes.Text(text, text))
506 
507         return result
508 
509 
510 _abbr_re = re.compile(r'\((.*)\)$', re.S)
511 
512 
513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
514               options: Dict = {}, content: List[str] = []
515               ) -> Tuple[List[Node], List[system_message]]:
516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
517                   RemovedInSphinx40Warning, stacklevel=2)
518     text = utils.unescape(text)
519     m = _abbr_re.search(text)
520     if m is None:
521         return [nodes.abbreviation(text, text, **options)], []
522     abbr = text[:m.start()].strip()
523     expl = m.group(1)
524     options = options.copy()
525     options['explanation'] = expl
526     return [nodes.abbreviation(abbr, abbr, **options)], []
527 
528 
529 class Abbreviation(SphinxRole):
530     abbr_re = re.compile(r'\((.*)\)$', re.S)
531 
532     def run(self) -> Tuple[List[Node], List[system_message]]:
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             self.options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>Modify or extend the method responsible for `:kbd:` role processing to parse the role's value and generate separate `<kbd>` elements for each key and/or combination described within the value. This parsing should account for different separators (like spaces or plus signs) and properly nest or sequentially place `<kbd>` elements as needed. The existing functionality for roles should be preserved, meaning this enhancement should only affect how `:kbd:` values are interpreted and converted into HTML.</intended_behavior>, <file>sphinx/domains/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains
3     ~~~~~~~~~~~~~~
4 
5     Support for domains, which are groupings of description directives
6     and roles describing e.g. constructs of one programming language.
7 
8     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
9     :license: BSD, see LICENSE for details.
10 """
11 
12 import copy
13 from typing import Any, Callable, Dict, Iterable, List, NamedTuple, Tuple, Union
14 from typing import cast
15 
16 from docutils import nodes
17 from docutils.nodes import Element, Node, system_message
18 from docutils.parsers.rst.states import Inliner
19 
20 from sphinx.addnodes import pending_xref
21 from sphinx.errors import SphinxError
22 from sphinx.locale import _
23 from sphinx.roles import XRefRole
24 from sphinx.util.typing import RoleFunction
25 
26 if False:
27     # For type annotation
28     from typing import Type  # for python3.5.1
29     from sphinx.builders import Builder
30     from sphinx.environment import BuildEnvironment
31 
32 
33 class ObjType:
34     """
35     An ObjType is the description for a type of object that a domain can
36     document.  In the object_types attribute of Domain subclasses, object type
37     names are mapped to instances of this class.
38 
39     Constructor arguments:
40 
41     - *lname*: localized name of the type (do not include domain name)
42     - *roles*: all the roles that can refer to an object of this type
43     - *attrs*: object attributes -- currently only "searchprio" is known,
44       which defines the object's priority in the full-text search index,
45       see :meth:`Domain.get_objects()`.
46     """
47 
48     known_attrs = {
49         'searchprio': 1,
50     }
51 
52     def __init__(self, lname: str, *roles: Any, **attrs: Any) -> None:
53         self.lname = lname
54         self.roles = roles                      # type: Tuple
55         self.attrs = self.known_attrs.copy()    # type: Dict
56         self.attrs.update(attrs)
57 
58 
59 IndexEntry = NamedTuple('IndexEntry', [('name', str),
60                                        ('subtype', int),
61                                        ('docname', str),
62                                        ('anchor', str),
63                                        ('extra', str),
64                                        ('qualifier', str),
65                                        ('descr', str)])
66 
67 
68 class Index:
69     """
70     An Index is the description for a domain-specific index.  To add an index to
71     a domain, subclass Index, overriding the three name attributes:
72 
73     * `name` is an identifier used for generating file names.
74       It is also used for a hyperlink target for the index. Therefore, users can
75       refer the index page using ``ref`` role and a string which is combined
76       domain name and ``name`` attribute (ex. ``:ref:`py-modindex```).
77     * `localname` is the section title for the index.
78     * `shortname` is a short name for the index, for use in the relation bar in
79       HTML output.  Can be empty to disable entries in the relation bar.
80 
81     and providing a :meth:`generate()` method.  Then, add the index class to
82     your domain's `indices` list.  Extensions can add indices to existing
83     domains using :meth:`~sphinx.application.Sphinx.add_index_to_domain()`.
84 
85     .. versionchanged:: 3.0
86 
87        Index pages can be referred by domain name and index name via
88        :rst:role:`ref` role.
89     """
90 
91     name = None  # type: str
92     localname = None  # type: str
93     shortname = None  # type: str
94 
95     def __init__(self, domain: "Domain") -> None:
96         if self.name is None or self.localname is None:
97             raise SphinxError('Index subclass %s has no valid name or localname'
98                               % self.__class__.__name__)
99         self.domain = domain
100 
101     def generate(self, docnames: Iterable[str] = None
102                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:
103         """Get entries for the index.
104 
105         If ``docnames`` is given, restrict to entries referring to these
106         docnames.
107 
108         The return value is a tuple of ``(content, collapse)``:
109 
110         ``collapse``
111           A boolean that determines if sub-entries should start collapsed (for
112           output formats that support collapsing sub-entries).
113 
114         ``content``:
115           A sequence of ``(letter, entries)`` tuples, where ``letter`` is the
116           "heading" for the given ``entries``, usually the starting letter, and
117           ``entries`` is a sequence of single entries. Each entry is a sequence
118           ``[name, subtype, docname, anchor, extra, qualifier, descr]``. The
119           items in this sequence have the following meaning:
120 
121           ``name``
122             The name of the index entry to be displayed.
123 
124           ``subtype``
125             The sub-entry related type. One of:
126 
127             ``0``
128               A normal entry.
129             ``1``
130               An entry with sub-entries.
131             ``2``
132               A sub-entry.
133 
134           ``docname``
135             *docname* where the entry is located.
136 
137           ``anchor``
138             Anchor for the entry within ``docname``
139 
140           ``extra``
141             Extra info for the entry.
142 
143           ``qualifier``
144             Qualifier for the description.
145 
146           ``descr``
147             Description for the entry.
148 
149         Qualifier and description are not rendered for some output formats such
150         as LaTeX.
151         """
152         raise NotImplementedError
153 
154 
155 class Domain:
156     """
157     A Domain is meant to be a group of "object" description directives for
158     objects of a similar nature, and corresponding roles to create references to
159     them.  Examples would be Python modules, classes, functions etc., elements
160     of a templating language, Sphinx roles and directives, etc.
161 
162     Each domain has a separate storage for information about existing objects
163     and how to reference them in `self.data`, which must be a dictionary.  It
164     also must implement several functions that expose the object information in
165     a uniform way to parts of Sphinx that allow the user to reference or search
166     for objects in a domain-agnostic way.
167 
168     About `self.data`: since all object and cross-referencing information is
169     stored on a BuildEnvironment instance, the `domain.data` object is also
170     stored in the `env.domaindata` dict under the key `domain.name`.  Before the
171     build process starts, every active domain is instantiated and given the
172     environment object; the `domaindata` dict must then either be nonexistent or
173     a dictionary whose 'version' key is equal to the domain class'
174     :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the
175     pickled environment is discarded.
176     """
177 
178     #: domain name: should be short, but unique
179     name = ''
180     #: domain label: longer, more descriptive (used in messages)
181     label = ''
182     #: type (usually directive) name -> ObjType instance
183     object_types = {}       # type: Dict[str, ObjType]
184     #: directive name -> directive class
185     directives = {}         # type: Dict[str, Any]
186     #: role name -> role callable
187     roles = {}              # type: Dict[str, Union[RoleFunction, XRefRole]]
188     #: a list of Index subclasses
189     indices = []            # type: List[Type[Index]]
190     #: role name -> a warning message if reference is missing
191     dangling_warnings = {}  # type: Dict[str, str]
192     #: node_class -> (enum_node_type, title_getter)
193     enumerable_nodes = {}   # type: Dict[Type[Node], Tuple[str, Callable]]
194 
195     #: data value for a fresh environment
196     initial_data = {}       # type: Dict
197     #: data value
198     data = None             # type: Dict
199     #: data version, bump this when the format of `self.data` changes
200     data_version = 0
201 
202     def __init__(self, env: "BuildEnvironment") -> None:
203         self.env = env              # type: BuildEnvironment
204         self._role_cache = {}       # type: Dict[str, Callable]
205         self._directive_cache = {}  # type: Dict[str, Callable]
206         self._role2type = {}        # type: Dict[str, List[str]]
207         self._type2role = {}        # type: Dict[str, str]
208 
209         # convert class variables to instance one (to enhance through API)
210         self.object_types = dict(self.object_types)
211         self.directives = dict(self.directives)
212         self.roles = dict(self.roles)
213         self.indices = list(self.indices)
214 
215         if self.name not in env.domaindata:
216             assert isinstance(self.initial_data, dict)
217             new_data = copy.deepcopy(self.initial_data)
218             new_data['version'] = self.data_version
219             self.data = env.domaindata[self.name] = new_data
220         else:
221             self.data = env.domaindata[self.name]
222             if self.data['version'] != self.data_version:
223                 raise OSError('data of %r domain out of date' % self.label)
224         for name, obj in self.object_types.items():
225             for rolename in obj.roles:
226                 self._role2type.setdefault(rolename, []).append(name)
227             self._type2role[name] = obj.roles[0] if obj.roles else ''
228         self.objtypes_for_role = self._role2type.get    # type: Callable[[str], List[str]]
229         self.role_for_objtype = self._type2role.get     # type: Callable[[str], str]
230 
231     def setup(self) -> None:
232         """Set up domain object."""
233         from sphinx.domains.std import StandardDomain
234 
235         # Add special hyperlink target for index pages (ex. py-modindex)
236         std = cast(StandardDomain, self.env.get_domain('std'))
237         for index in self.indices:
238             if index.name and index.localname:
239                 docname = "%s-%s" % (self.name, index.name)
240                 std.note_hyperlink_target(docname, docname, '', index.localname)
241 
242     def add_object_type(self, name: str, objtype: ObjType) -> None:
243         """Add an object type."""
244         self.object_types[name] = objtype
245         if objtype.roles:
246             self._type2role[name] = objtype.roles[0]
247         else:
248             self._type2role[name] = ''
249 
250         for role in objtype.roles:
251             self._role2type.setdefault(role, []).append(name)
252 
253     def role(self, name: str) -> RoleFunction:
254         """Return a role adapter function that always gives the registered
255         role its full name ('domain:name') as the first argument.
256         """
257         if name in self._role_cache:
258             return self._role_cache[name]
259         if name not in self.roles:
260             return None
261         fullname = '%s:%s' % (self.name, name)
262 
263         def role_adapter(typ: str, rawtext: str, text: str, lineno: int,
264                          inliner: Inliner, options: Dict = {}, content: List[str] = []
265                          ) -> Tuple[List[Node], List[system_message]]:
266             return self.roles[name](fullname, rawtext, text, lineno,
267                                     inliner, options, content)
268         self._role_cache[name] = role_adapter
269         return role_adapter
270 
271     def directive(self, name: str) -> Callable:
272         """Return a directive adapter class that always gives the registered
273         directive its full name ('domain:name') as ``self.name``.
274         """
275         if name in self._directive_cache:
276             return self._directive_cache[name]
277         if name not in self.directives:
278             return None
279         fullname = '%s:%s' % (self.name, name)
280         BaseDirective = self.directives[name]
281 
282         class DirectiveAdapter(BaseDirective):  # type: ignore
283             def run(self) -> List[Node]:
284                 self.name = fullname
285                 return super().run()
286         self._directive_cache[name] = DirectiveAdapter
287         return DirectiveAdapter
288 
289     # methods that should be overwritten
290 
291     def clear_doc(self, docname: str) -> None:
292         """Remove traces of a document in the domain-specific inventories."""
293         pass
294 
295     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
296         """Merge in data regarding *docnames* from a different domaindata
297         inventory (coming from a subprocess in parallel builds).
298         """
299         raise NotImplementedError('merge_domaindata must be implemented in %s '
300                                   'to be able to do parallel builds!' %
301                                   self.__class__)
302 
303     def process_doc(self, env: "BuildEnvironment", docname: str,
304                     document: nodes.document) -> None:
305         """Process a document after it is read by the environment."""
306         pass
307 
308     def check_consistency(self) -> None:
309         """Do consistency checks (**experimental**)."""
310         pass
311 
312     def process_field_xref(self, pnode: pending_xref) -> None:
313         """Process a pending xref created in a doc field.
314         For example, attach information about the current scope.
315         """
316         pass
317 
318     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
319                      typ: str, target: str, node: pending_xref, contnode: Element
320                      ) -> Element:
321         """Resolve the pending_xref *node* with the given *typ* and *target*.
322 
323         This method should return a new node, to replace the xref node,
324         containing the *contnode* which is the markup content of the
325         cross-reference.
326 
327         If no resolution can be found, None can be returned; the xref node will
328         then given to the :event:`missing-reference` event, and if that yields no
329         resolution, replaced by *contnode*.
330 
331         The method can also raise :exc:`sphinx.environment.NoUri` to suppress
332         the :event:`missing-reference` event being emitted.
333         """
334         pass
335 
336     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
337                          target: str, node: pending_xref, contnode: Element
338                          ) -> List[Tuple[str, Element]]:
339         """Resolve the pending_xref *node* with the given *target*.
340 
341         The reference comes from an "any" or similar role, which means that we
342         don't know the type.  Otherwise, the arguments are the same as for
343         :meth:`resolve_xref`.
344 
345         The method must return a list (potentially empty) of tuples
346         ``('domain:role', newnode)``, where ``'domain:role'`` is the name of a
347         role that could have created the same reference, e.g. ``'py:func'``.
348         ``newnode`` is what :meth:`resolve_xref` would return.
349 
350         .. versionadded:: 1.3
351         """
352         raise NotImplementedError
353 
354     def get_objects(self) -> Iterable[Tuple[str, str, str, str, str, int]]:
355         """Return an iterable of "object descriptions".
356 
357         Object descriptions are tuples with six items:
358 
359         ``name``
360           Fully qualified name.
361 
362         ``dispname``
363           Name to display when searching/linking.
364 
365         ``type``
366           Object type, a key in ``self.object_types``.
367 
368         ``docname``
369           The document where it is to be found.
370 
371         ``anchor``
372           The anchor name for the object.
373 
374         ``priority``
375           How "important" the object is (determines placement in search
376           results). One of:
377 
378           ``1``
379             Default priority (placed before full-text matches).
380           ``0``
381             Object is important (placed before default-priority objects).
382           ``2``
383             Object is unimportant (placed after full-text matches).
384           ``-1``
385             Object should not show up in search at all.
386         """
387         return []
388 
389     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
390         """Return full name for given ObjType."""
391         if primary:
392             return type.lname
393         return _('%s %s') % (self.label, type.lname)
394 
395     def get_enumerable_node_type(self, node: Node) -> str:
396         """Get type of enumerable nodes (experimental)."""
397         enum_node_type, _ = self.enumerable_nodes.get(node.__class__, (None, None))
398         return enum_node_type
399 
400     def get_full_qualified_name(self, node: Element) -> str:
401         """Return full qualified name for given node."""
402         return None

</code><intended_behavior>If any specific handling or customization for `:kbd:` or similar roles exists within domain-specific logic, ensure that these are compatible with or extended to support the new, more granular approach to generating `<kbd>` elements. Any domain-specific overrides or extensions that handle these roles should be reviewed to ensure they remain functional or are enhanced to support the intended nested or sequential `<kbd>` behavior.</intended_behavior>]
2025-10-15 11:52:23.976 | INFO     | Search completed. Bug locations: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import (
25     split_explicit_title, process_index_entry, set_role_source_info
26 )
27 from sphinx.util.typing import RoleFunction
28 
29 if False:
30     # For type annotation
31     from typing import Type  # for python3.5.1
32     from sphinx.application import Sphinx
33     from sphinx.environment import BuildEnvironment
34 
35 
36 generic_docroles = {
37     'command': addnodes.literal_strong,
38     'dfn': nodes.emphasis,
39     'kbd': nodes.literal,
40     'mailheader': addnodes.literal_emphasis,
41     'makevar': addnodes.literal_strong,
42     'manpage': addnodes.manpage,
43     'mimetype': addnodes.literal_emphasis,
44     'newsgroup': addnodes.literal_emphasis,
45     'program': addnodes.literal_strong,  # XXX should be an x-ref
46     'regexp': nodes.literal,
47 }
48 
49 
50 # -- generic cross-reference role ----------------------------------------------
51 
52 class XRefRole(ReferenceRole):
53     """
54     A generic cross-referencing role.  To create a callable that can be used as
55     a role function, create an instance of this class.
56 
57     The general features of this role are:
58 
59     * Automatic creation of a reference and a content node.
60     * Optional separation of title and target with `title <target>`.
61     * The implementation is a class rather than a function to make
62       customization easier.
63 
64     Customization can be done in two ways:
65 
66     * Supplying constructor parameters:
67       * `fix_parens` to normalize parentheses (strip from target, and add to
68         title if configured)
69       * `lowercase` to lowercase the target
70       * `nodeclass` and `innernodeclass` select the node classes for
71         the reference and the content node
72 
73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
74     """
75 
76     nodeclass = addnodes.pending_xref   # type: Type[Element]
77     innernodeclass = nodes.literal      # type: Type[TextElement]
78 
79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
80                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
81                  warn_dangling: bool = False) -> None:
82         self.fix_parens = fix_parens
83         self.lowercase = lowercase
84         self.warn_dangling = warn_dangling
85         if nodeclass is not None:
86             self.nodeclass = nodeclass
87         if innernodeclass is not None:
88             self.innernodeclass = innernodeclass
89 
90         super().__init__()
91 
92     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
93                     target: str) -> Tuple[str, str]:
94         warnings.warn('XRefRole._fix_parens() is deprecated.',
95                       RemovedInSphinx40Warning, stacklevel=2)
96         if not has_explicit_title:
97             if title.endswith('()'):
98                 # remove parentheses
99                 title = title[:-2]
100             if env.config.add_function_parentheses:
101                 # add them back to all occurrences if configured
102                 title += '()'
103         # remove parentheses from the target too
104         if target.endswith('()'):
105             target = target[:-2]
106         return title, target
107 
108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
109         if not self.has_explicit_title:
110             if title.endswith('()'):
111                 # remove parentheses
112                 title = title[:-2]
113             if self.config.add_function_parentheses:
114                 # add them back to all occurrences if configured
115                 title += '()'
116         # remove parentheses from the target too
117         if target.endswith('()'):
118             target = target[:-2]
119         return title, target
120 
121     def run(self) -> Tuple[List[Node], List[system_message]]:
122         if ':' not in self.name:
123             self.refdomain, self.reftype = '', self.name
124             self.classes = ['xref', self.reftype]
125         else:
126             self.refdomain, self.reftype = self.name.split(':', 1)
127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
128 
129         if self.disabled:
130             return self.create_non_xref_node()
131         else:
132             return self.create_xref_node()
133 
134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
135         text = utils.unescape(self.text[1:])
136         if self.fix_parens:
137             self.has_explicit_title = False  # treat as implicit
138             text, target = self.update_title_and_target(text, "")
139 
140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
142 
143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
144         target = self.target
145         title = self.title
146         if self.lowercase:
147             target = target.lower()
148         if self.fix_parens:
149             title, target = self.update_title_and_target(title, target)
150 
151         # create the reference node
152         options = {'refdoc': self.env.docname,
153                    'refdomain': self.refdomain,
154                    'reftype': self.reftype,
155                    'refexplicit': self.has_explicit_title,
156                    'refwarn': self.warn_dangling}
157         refnode = self.nodeclass(self.rawtext, **options)
158         self.set_source_info(refnode)
159 
160         # determine the target and title for the class
161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
162                                           title, target)
163         refnode['reftarget'] = target
164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
165 
166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
167 
168     # methods that can be overwritten
169 
170     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
171                      title: str, target: str) -> Tuple[str, str]:
172         """Called after parsing title and target text, and creating the
173         reference node (given in *refnode*).  This method can alter the
174         reference node and must return a new (or the same) ``(title, target)``
175         tuple.
176         """
177         return title, ws_re.sub(' ', target)
178 
179     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
181         """Called before returning the finished nodes.  *node* is the reference
182         node if one was created (*is_ref* is then true), else the content node.
183         This method can add other nodes and must return a ``(nodes, messages)``
184         tuple (the usual return value of a role function).
185         """
186         return [node], []
187 
188 
189 class AnyXRefRole(XRefRole):
190     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
191                      title: str, target: str) -> Tuple[str, str]:
192         result = super().process_link(env, refnode, has_explicit_title, title, target)
193         # add all possible context info (i.e. std:program, py:module etc.)
194         refnode.attributes.update(env.ref_context)
195         return result
196 
197 
198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
199                      options: Dict = {}, content: List[str] = []
200                      ) -> Tuple[List[Node], List[system_message]]:
201     """Role for PEP/RFC references that generate an index entry."""
202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
203                   RemovedInSphinx40Warning, stacklevel=2)
204     env = inliner.document.settings.env
205     if not typ:
206         assert env.temp_data['default_role']
207         typ = env.temp_data['default_role'].lower()
208     else:
209         typ = typ.lower()
210 
211     has_explicit_title, title, target = split_explicit_title(text)
212     title = utils.unescape(title)
213     target = utils.unescape(target)
214     targetid = 'index-%s' % env.new_serialno('index')
215     indexnode = addnodes.index()
216     targetnode = nodes.target('', '', ids=[targetid])
217     inliner.document.note_explicit_target(targetnode)
218     if typ == 'pep':
219         indexnode['entries'] = [
220             ('single', _('Python Enhancement Proposals; PEP %s') % target,
221              targetid, '', None)]
222         anchor = ''
223         anchorindex = target.find('#')
224         if anchorindex > 0:
225             target, anchor = target[:anchorindex], target[anchorindex:]
226         if not has_explicit_title:
227             title = "PEP " + utils.unescape(title)
228         try:
229             pepnum = int(target)
230         except ValueError:
231             msg = inliner.reporter.error('invalid PEP number %s' % target,
232                                          line=lineno)
233             prb = inliner.problematic(rawtext, rawtext, msg)
234             return [prb], [msg]
235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
236         sn = nodes.strong(title, title)
237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
238                              classes=[typ])
239         rn += sn
240         return [indexnode, targetnode, rn], []
241     elif typ == 'rfc':
242         indexnode['entries'] = [
243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
244         anchor = ''
245         anchorindex = target.find('#')
246         if anchorindex > 0:
247             target, anchor = target[:anchorindex], target[anchorindex:]
248         if not has_explicit_title:
249             title = "RFC " + utils.unescape(title)
250         try:
251             rfcnum = int(target)
252         except ValueError:
253             msg = inliner.reporter.error('invalid RFC number %s' % target,
254                                          line=lineno)
255             prb = inliner.problematic(rawtext, rawtext, msg)
256             return [prb], [msg]
257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
258         sn = nodes.strong(title, title)
259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
260                              classes=[typ])
261         rn += sn
262         return [indexnode, targetnode, rn], []
263     else:
264         raise ValueError('unknown role type: %s' % typ)
265 
266 
267 class PEP(ReferenceRole):
268     def run(self) -> Tuple[List[Node], List[system_message]]:
269         target_id = 'index-%s' % self.env.new_serialno('index')
270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
271                     target_id, '', None)]
272 
273         index = addnodes.index(entries=entries)
274         target = nodes.target('', '', ids=[target_id])
275         self.inliner.document.note_explicit_target(target)
276 
277         try:
278             refuri = self.build_uri()
279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
280             if self.has_explicit_title:
281                 reference += nodes.strong(self.title, self.title)
282             else:
283                 title = "PEP " + self.title
284                 reference += nodes.strong(title, title)
285         except ValueError:
286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
287                                               line=self.lineno)
288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
289             return [prb], [msg]
290 
291         return [index, target, reference], []
292 
293     def build_uri(self) -> str:
294         base_url = self.inliner.document.settings.pep_base_url
295         ret = self.target.split('#', 1)
296         if len(ret) == 2:
297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
298         else:
299             return base_url + 'pep-%04d' % int(ret[0])
300 
301 
302 class RFC(ReferenceRole):
303     def run(self) -> Tuple[List[Node], List[system_message]]:
304         target_id = 'index-%s' % self.env.new_serialno('index')
305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
306 
307         index = addnodes.index(entries=entries)
308         target = nodes.target('', '', ids=[target_id])
309         self.inliner.document.note_explicit_target(target)
310 
311         try:
312             refuri = self.build_uri()
313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
314             if self.has_explicit_title:
315                 reference += nodes.strong(self.title, self.title)
316             else:
317                 title = "RFC " + self.title
318                 reference += nodes.strong(title, title)
319         except ValueError:
320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
321                                               line=self.lineno)
322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
323             return [prb], [msg]
324 
325         return [index, target, reference], []
326 
327     def build_uri(self) -> str:
328         base_url = self.inliner.document.settings.rfc_base_url
329         ret = self.target.split('#', 1)
330         if len(ret) == 2:
331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
332         else:
333             return base_url + self.inliner.rfc_url % int(ret[0])
334 
335 
336 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
337 
338 
339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
340                  options: Dict = {}, content: List[str] = []
341                  ) -> Tuple[List[Node], List[system_message]]:
342     warnings.warn('menusel_role() is deprecated. '
343                   'Please use MenuSelection or GUILabel class instead.',
344                   RemovedInSphinx40Warning, stacklevel=2)
345     env = inliner.document.settings.env
346     if not typ:
347         assert env.temp_data['default_role']
348         typ = env.temp_data['default_role'].lower()
349     else:
350         typ = typ.lower()
351 
352     text = utils.unescape(text)
353     if typ == 'menuselection':
354         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
355     spans = _amp_re.split(text)
356 
357     node = nodes.inline(rawtext=rawtext)
358     for i, span in enumerate(spans):
359         span = span.replace('&&', '&')
360         if i == 0:
361             if len(span) > 0:
362                 textnode = nodes.Text(span)
363                 node += textnode
364             continue
365         accel_node = nodes.inline()
366         letter_node = nodes.Text(span[0])
367         accel_node += letter_node
368         accel_node['classes'].append('accelerator')
369         node += accel_node
370         textnode = nodes.Text(span[1:])
371         node += textnode
372 
373     node['classes'].append(typ)
374     return [node], []
375 
376 
377 class GUILabel(SphinxRole):
378     amp_re = re.compile(r'(?<!&)&(?![&\s])')
379 
380     def run(self) -> Tuple[List[Node], List[system_message]]:
381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
382         spans = self.amp_re.split(self.text)
383         node += nodes.Text(spans.pop(0))
384         for span in spans:
385             span = span.replace('&&', '&')
386 
387             letter = nodes.Text(span[0])
388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
389             node += accelerator
390             node += nodes.Text(span[1:])
391 
392         return [node], []
393 
394 
395 class MenuSelection(GUILabel):
396     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
397 
398     def run(self) -> Tuple[List[Node], List[system_message]]:
399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
400         return super().run()
401 
402 
403 _litvar_re = re.compile('{([^}]+)}')
404 parens_re = re.compile(r'(\\*{|\\*})')
405 
406 
407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
408                       options: Dict = {}, content: List[str] = []
409                       ) -> Tuple[List[Node], List[system_message]]:
410     warnings.warn('emph_literal_role() is deprecated. '
411                   'Please use EmphasizedLiteral class instead.',
412                   RemovedInSphinx40Warning, stacklevel=2)
413     env = inliner.document.settings.env
414     if not typ:
415         assert env.temp_data['default_role']
416         typ = env.temp_data['default_role'].lower()
417     else:
418         typ = typ.lower()
419 
420     retnode = nodes.literal(role=typ.lower(), classes=[typ])
421     parts = list(parens_re.split(utils.unescape(text)))
422     stack = ['']
423     for part in parts:
424         matched = parens_re.match(part)
425         if matched:
426             backslashes = len(part) - 1
427             if backslashes % 2 == 1:    # escaped
428                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
429             elif part[-1] == '{':       # rparen
430                 stack[-1] += "\\" * int(backslashes / 2)
431                 if len(stack) >= 2 and stack[-2] == "{":
432                     # nested
433                     stack[-1] += "{"
434                 else:
435                     # start emphasis
436                     stack.append('{')
437                     stack.append('')
438             else:                       # lparen
439                 stack[-1] += "\\" * int(backslashes / 2)
440                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
441                     # emphasized word found
442                     if stack[0]:
443                         retnode += nodes.Text(stack[0], stack[0])
444                     retnode += nodes.emphasis(stack[2], stack[2])
445                     stack = ['']
446                 else:
447                     # emphasized word not found; the rparen is not a special symbol
448                     stack.append('}')
449                     stack = [''.join(stack)]
450         else:
451             stack[-1] += part
452     if ''.join(stack):
453         # remaining is treated as Text
454         text = ''.join(stack)
455         retnode += nodes.Text(text, text)
456 
457     return [retnode], []
458 
459 
460 class EmphasizedLiteral(SphinxRole):
461     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
462 
463     def run(self) -> Tuple[List[Node], List[system_message]]:
464         children = self.parse(self.text)
465         node = nodes.literal(self.rawtext, '', *children,
466                              role=self.name.lower(), classes=[self.name])
467 
468         return [node], []
469 
470     def parse(self, text: str) -> List[Node]:
471         result = []  # type: List[Node]
472 
473         stack = ['']
474         for part in self.parens_re.split(text):
475             if part == '\\\\':  # escaped backslash
476                 stack[-1] += '\\'
477             elif part == '{':
478                 if len(stack) >= 2 and stack[-2] == "{":  # nested
479                     stack[-1] += "{"
480                 else:
481                     # start emphasis
482                     stack.append('{')
483                     stack.append('')
484             elif part == '}':
485                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
486                     # emphasized word found
487                     if stack[0]:
488                         result.append(nodes.Text(stack[0], stack[0]))
489                     result.append(nodes.emphasis(stack[2], stack[2]))
490                     stack = ['']
491                 else:
492                     # emphasized word not found; the rparen is not a special symbol
493                     stack.append('}')
494                     stack = [''.join(stack)]
495             elif part == '\\{':  # escaped left-brace
496                 stack[-1] += '{'
497             elif part == '\\}':  # escaped right-brace
498                 stack[-1] += '}'
499             else:  # others (containing escaped braces)
500                 stack[-1] += part
501 
502         if ''.join(stack):
503             # remaining is treated as Text
504             text = ''.join(stack)
505             result.append(nodes.Text(text, text))
506 
507         return result
508 
509 
510 _abbr_re = re.compile(r'\((.*)\)$', re.S)
511 
512 
513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
514               options: Dict = {}, content: List[str] = []
515               ) -> Tuple[List[Node], List[system_message]]:
516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
517                   RemovedInSphinx40Warning, stacklevel=2)
518     text = utils.unescape(text)
519     m = _abbr_re.search(text)
520     if m is None:
521         return [nodes.abbreviation(text, text, **options)], []
522     abbr = text[:m.start()].strip()
523     expl = m.group(1)
524     options = options.copy()
525     options['explanation'] = expl
526     return [nodes.abbreviation(abbr, abbr, **options)], []
527 
528 
529 class Abbreviation(SphinxRole):
530     abbr_re = re.compile(r'\((.*)\)$', re.S)
531 
532     def run(self) -> Tuple[List[Node], List[system_message]]:
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             self.options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>Modify or extend the method responsible for `:kbd:` role processing to parse the role's value and generate separate `<kbd>` elements for each key and/or combination described within the value. This parsing should account for different separators (like spaces or plus signs) and properly nest or sequentially place `<kbd>` elements as needed. The existing functionality for roles should be preserved, meaning this enhancement should only affect how `:kbd:` values are interpreted and converted into HTML.</intended_behavior>, <file>sphinx/domains/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains
3     ~~~~~~~~~~~~~~
4 
5     Support for domains, which are groupings of description directives
6     and roles describing e.g. constructs of one programming language.
7 
8     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
9     :license: BSD, see LICENSE for details.
10 """
11 
12 import copy
13 from typing import Any, Callable, Dict, Iterable, List, NamedTuple, Tuple, Union
14 from typing import cast
15 
16 from docutils import nodes
17 from docutils.nodes import Element, Node, system_message
18 from docutils.parsers.rst.states import Inliner
19 
20 from sphinx.addnodes import pending_xref
21 from sphinx.errors import SphinxError
22 from sphinx.locale import _
23 from sphinx.roles import XRefRole
24 from sphinx.util.typing import RoleFunction
25 
26 if False:
27     # For type annotation
28     from typing import Type  # for python3.5.1
29     from sphinx.builders import Builder
30     from sphinx.environment import BuildEnvironment
31 
32 
33 class ObjType:
34     """
35     An ObjType is the description for a type of object that a domain can
36     document.  In the object_types attribute of Domain subclasses, object type
37     names are mapped to instances of this class.
38 
39     Constructor arguments:
40 
41     - *lname*: localized name of the type (do not include domain name)
42     - *roles*: all the roles that can refer to an object of this type
43     - *attrs*: object attributes -- currently only "searchprio" is known,
44       which defines the object's priority in the full-text search index,
45       see :meth:`Domain.get_objects()`.
46     """
47 
48     known_attrs = {
49         'searchprio': 1,
50     }
51 
52     def __init__(self, lname: str, *roles: Any, **attrs: Any) -> None:
53         self.lname = lname
54         self.roles = roles                      # type: Tuple
55         self.attrs = self.known_attrs.copy()    # type: Dict
56         self.attrs.update(attrs)
57 
58 
59 IndexEntry = NamedTuple('IndexEntry', [('name', str),
60                                        ('subtype', int),
61                                        ('docname', str),
62                                        ('anchor', str),
63                                        ('extra', str),
64                                        ('qualifier', str),
65                                        ('descr', str)])
66 
67 
68 class Index:
69     """
70     An Index is the description for a domain-specific index.  To add an index to
71     a domain, subclass Index, overriding the three name attributes:
72 
73     * `name` is an identifier used for generating file names.
74       It is also used for a hyperlink target for the index. Therefore, users can
75       refer the index page using ``ref`` role and a string which is combined
76       domain name and ``name`` attribute (ex. ``:ref:`py-modindex```).
77     * `localname` is the section title for the index.
78     * `shortname` is a short name for the index, for use in the relation bar in
79       HTML output.  Can be empty to disable entries in the relation bar.
80 
81     and providing a :meth:`generate()` method.  Then, add the index class to
82     your domain's `indices` list.  Extensions can add indices to existing
83     domains using :meth:`~sphinx.application.Sphinx.add_index_to_domain()`.
84 
85     .. versionchanged:: 3.0
86 
87        Index pages can be referred by domain name and index name via
88        :rst:role:`ref` role.
89     """
90 
91     name = None  # type: str
92     localname = None  # type: str
93     shortname = None  # type: str
94 
95     def __init__(self, domain: "Domain") -> None:
96         if self.name is None or self.localname is None:
97             raise SphinxError('Index subclass %s has no valid name or localname'
98                               % self.__class__.__name__)
99         self.domain = domain
100 
101     def generate(self, docnames: Iterable[str] = None
102                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:
103         """Get entries for the index.
104 
105         If ``docnames`` is given, restrict to entries referring to these
106         docnames.
107 
108         The return value is a tuple of ``(content, collapse)``:
109 
110         ``collapse``
111           A boolean that determines if sub-entries should start collapsed (for
112           output formats that support collapsing sub-entries).
113 
114         ``content``:
115           A sequence of ``(letter, entries)`` tuples, where ``letter`` is the
116           "heading" for the given ``entries``, usually the starting letter, and
117           ``entries`` is a sequence of single entries. Each entry is a sequence
118           ``[name, subtype, docname, anchor, extra, qualifier, descr]``. The
119           items in this sequence have the following meaning:
120 
121           ``name``
122             The name of the index entry to be displayed.
123 
124           ``subtype``
125             The sub-entry related type. One of:
126 
127             ``0``
128               A normal entry.
129             ``1``
130               An entry with sub-entries.
131             ``2``
132               A sub-entry.
133 
134           ``docname``
135             *docname* where the entry is located.
136 
137           ``anchor``
138             Anchor for the entry within ``docname``
139 
140           ``extra``
141             Extra info for the entry.
142 
143           ``qualifier``
144             Qualifier for the description.
145 
146           ``descr``
147             Description for the entry.
148 
149         Qualifier and description are not rendered for some output formats such
150         as LaTeX.
151         """
152         raise NotImplementedError
153 
154 
155 class Domain:
156     """
157     A Domain is meant to be a group of "object" description directives for
158     objects of a similar nature, and corresponding roles to create references to
159     them.  Examples would be Python modules, classes, functions etc., elements
160     of a templating language, Sphinx roles and directives, etc.
161 
162     Each domain has a separate storage for information about existing objects
163     and how to reference them in `self.data`, which must be a dictionary.  It
164     also must implement several functions that expose the object information in
165     a uniform way to parts of Sphinx that allow the user to reference or search
166     for objects in a domain-agnostic way.
167 
168     About `self.data`: since all object and cross-referencing information is
169     stored on a BuildEnvironment instance, the `domain.data` object is also
170     stored in the `env.domaindata` dict under the key `domain.name`.  Before the
171     build process starts, every active domain is instantiated and given the
172     environment object; the `domaindata` dict must then either be nonexistent or
173     a dictionary whose 'version' key is equal to the domain class'
174     :attr:`data_version` attribute.  Otherwise, `OSError` is raised and the
175     pickled environment is discarded.
176     """
177 
178     #: domain name: should be short, but unique
179     name = ''
180     #: domain label: longer, more descriptive (used in messages)
181     label = ''
182     #: type (usually directive) name -> ObjType instance
183     object_types = {}       # type: Dict[str, ObjType]
184     #: directive name -> directive class
185     directives = {}         # type: Dict[str, Any]
186     #: role name -> role callable
187     roles = {}              # type: Dict[str, Union[RoleFunction, XRefRole]]
188     #: a list of Index subclasses
189     indices = []            # type: List[Type[Index]]
190     #: role name -> a warning message if reference is missing
191     dangling_warnings = {}  # type: Dict[str, str]
192     #: node_class -> (enum_node_type, title_getter)
193     enumerable_nodes = {}   # type: Dict[Type[Node], Tuple[str, Callable]]
194 
195     #: data value for a fresh environment
196     initial_data = {}       # type: Dict
197     #: data value
198     data = None             # type: Dict
199     #: data version, bump this when the format of `self.data` changes
200     data_version = 0
201 
202     def __init__(self, env: "BuildEnvironment") -> None:
203         self.env = env              # type: BuildEnvironment
204         self._role_cache = {}       # type: Dict[str, Callable]
205         self._directive_cache = {}  # type: Dict[str, Callable]
206         self._role2type = {}        # type: Dict[str, List[str]]
207         self._type2role = {}        # type: Dict[str, str]
208 
209         # convert class variables to instance one (to enhance through API)
210         self.object_types = dict(self.object_types)
211         self.directives = dict(self.directives)
212         self.roles = dict(self.roles)
213         self.indices = list(self.indices)
214 
215         if self.name not in env.domaindata:
216             assert isinstance(self.initial_data, dict)
217             new_data = copy.deepcopy(self.initial_data)
218             new_data['version'] = self.data_version
219             self.data = env.domaindata[self.name] = new_data
220         else:
221             self.data = env.domaindata[self.name]
222             if self.data['version'] != self.data_version:
223                 raise OSError('data of %r domain out of date' % self.label)
224         for name, obj in self.object_types.items():
225             for rolename in obj.roles:
226                 self._role2type.setdefault(rolename, []).append(name)
227             self._type2role[name] = obj.roles[0] if obj.roles else ''
228         self.objtypes_for_role = self._role2type.get    # type: Callable[[str], List[str]]
229         self.role_for_objtype = self._type2role.get     # type: Callable[[str], str]
230 
231     def setup(self) -> None:
232         """Set up domain object."""
233         from sphinx.domains.std import StandardDomain
234 
235         # Add special hyperlink target for index pages (ex. py-modindex)
236         std = cast(StandardDomain, self.env.get_domain('std'))
237         for index in self.indices:
238             if index.name and index.localname:
239                 docname = "%s-%s" % (self.name, index.name)
240                 std.note_hyperlink_target(docname, docname, '', index.localname)
241 
242     def add_object_type(self, name: str, objtype: ObjType) -> None:
243         """Add an object type."""
244         self.object_types[name] = objtype
245         if objtype.roles:
246             self._type2role[name] = objtype.roles[0]
247         else:
248             self._type2role[name] = ''
249 
250         for role in objtype.roles:
251             self._role2type.setdefault(role, []).append(name)
252 
253     def role(self, name: str) -> RoleFunction:
254         """Return a role adapter function that always gives the registered
255         role its full name ('domain:name') as the first argument.
256         """
257         if name in self._role_cache:
258             return self._role_cache[name]
259         if name not in self.roles:
260             return None
261         fullname = '%s:%s' % (self.name, name)
262 
263         def role_adapter(typ: str, rawtext: str, text: str, lineno: int,
264                          inliner: Inliner, options: Dict = {}, content: List[str] = []
265                          ) -> Tuple[List[Node], List[system_message]]:
266             return self.roles[name](fullname, rawtext, text, lineno,
267                                     inliner, options, content)
268         self._role_cache[name] = role_adapter
269         return role_adapter
270 
271     def directive(self, name: str) -> Callable:
272         """Return a directive adapter class that always gives the registered
273         directive its full name ('domain:name') as ``self.name``.
274         """
275         if name in self._directive_cache:
276             return self._directive_cache[name]
277         if name not in self.directives:
278             return None
279         fullname = '%s:%s' % (self.name, name)
280         BaseDirective = self.directives[name]
281 
282         class DirectiveAdapter(BaseDirective):  # type: ignore
283             def run(self) -> List[Node]:
284                 self.name = fullname
285                 return super().run()
286         self._directive_cache[name] = DirectiveAdapter
287         return DirectiveAdapter
288 
289     # methods that should be overwritten
290 
291     def clear_doc(self, docname: str) -> None:
292         """Remove traces of a document in the domain-specific inventories."""
293         pass
294 
295     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
296         """Merge in data regarding *docnames* from a different domaindata
297         inventory (coming from a subprocess in parallel builds).
298         """
299         raise NotImplementedError('merge_domaindata must be implemented in %s '
300                                   'to be able to do parallel builds!' %
301                                   self.__class__)
302 
303     def process_doc(self, env: "BuildEnvironment", docname: str,
304                     document: nodes.document) -> None:
305         """Process a document after it is read by the environment."""
306         pass
307 
308     def check_consistency(self) -> None:
309         """Do consistency checks (**experimental**)."""
310         pass
311 
312     def process_field_xref(self, pnode: pending_xref) -> None:
313         """Process a pending xref created in a doc field.
314         For example, attach information about the current scope.
315         """
316         pass
317 
318     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
319                      typ: str, target: str, node: pending_xref, contnode: Element
320                      ) -> Element:
321         """Resolve the pending_xref *node* with the given *typ* and *target*.
322 
323         This method should return a new node, to replace the xref node,
324         containing the *contnode* which is the markup content of the
325         cross-reference.
326 
327         If no resolution can be found, None can be returned; the xref node will
328         then given to the :event:`missing-reference` event, and if that yields no
329         resolution, replaced by *contnode*.
330 
331         The method can also raise :exc:`sphinx.environment.NoUri` to suppress
332         the :event:`missing-reference` event being emitted.
333         """
334         pass
335 
336     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
337                          target: str, node: pending_xref, contnode: Element
338                          ) -> List[Tuple[str, Element]]:
339         """Resolve the pending_xref *node* with the given *target*.
340 
341         The reference comes from an "any" or similar role, which means that we
342         don't know the type.  Otherwise, the arguments are the same as for
343         :meth:`resolve_xref`.
344 
345         The method must return a list (potentially empty) of tuples
346         ``('domain:role', newnode)``, where ``'domain:role'`` is the name of a
347         role that could have created the same reference, e.g. ``'py:func'``.
348         ``newnode`` is what :meth:`resolve_xref` would return.
349 
350         .. versionadded:: 1.3
351         """
352         raise NotImplementedError
353 
354     def get_objects(self) -> Iterable[Tuple[str, str, str, str, str, int]]:
355         """Return an iterable of "object descriptions".
356 
357         Object descriptions are tuples with six items:
358 
359         ``name``
360           Fully qualified name.
361 
362         ``dispname``
363           Name to display when searching/linking.
364 
365         ``type``
366           Object type, a key in ``self.object_types``.
367 
368         ``docname``
369           The document where it is to be found.
370 
371         ``anchor``
372           The anchor name for the object.
373 
374         ``priority``
375           How "important" the object is (determines placement in search
376           results). One of:
377 
378           ``1``
379             Default priority (placed before full-text matches).
380           ``0``
381             Object is important (placed before default-priority objects).
382           ``2``
383             Object is unimportant (placed after full-text matches).
384           ``-1``
385             Object should not show up in search at all.
386         """
387         return []
388 
389     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
390         """Return full name for given ObjType."""
391         if primary:
392             return type.lname
393         return _('%s %s') % (self.label, type.lname)
394 
395     def get_enumerable_node_type(self, node: Node) -> str:
396         """Get type of enumerable nodes (experimental)."""
397         enum_node_type, _ = self.enumerable_nodes.get(node.__class__, (None, None))
398         return enum_node_type
399 
400     def get_full_qualified_name(self, node: Element) -> str:
401         """Return full qualified name for given node."""
402         return None

</code><intended_behavior>If any specific handling or customization for `:kbd:` or similar roles exists within domain-specific logic, ensure that these are compatible with or extended to support the new, more granular approach to generating `<kbd>` elements. Any domain-specific overrides or extensions that handle these roles should be reviewed to ensure they remain functional or are enhanced to support the intended nested or sequential `<kbd>` behavior.</intended_behavior>]
2025-10-15 11:52:23.976 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 11:52:23.977 | INFO     | Search-only: skipping patch selection
2025-10-15 11:52:24.062 | INFO     | Task sphinx-doc__sphinx-7593 completed successfully.
2025-10-15 11:52:24.063 | INFO     | No patch generated. You can try running ACR again.
