[
    {
        "rel_file_path": "astropy/io/ascii/html.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/io/ascii/html.py",
        "start": 1,
        "end": 477,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \"\"\"An extensible HTML table reader and writer.\n3 \n4 html.py:\n5   Classes to read and write HTML tables\n6 \n7 `BeautifulSoup <http://www.crummy.com/software/BeautifulSoup/>`_\n8 must be installed to read HTML tables.\n9 \"\"\"\n10 \n11 import warnings\n12 \n13 from . import core\n14 from astropy.table import Column\n15 from astropy.utils.xml import writer\n16 \n17 from copy import deepcopy\n18 \n19 \n20 class SoupString(str):\n21     \"\"\"\n22     Allows for strings to hold BeautifulSoup data.\n23     \"\"\"\n24 \n25     def __new__(cls, *args, **kwargs):\n26         return str.__new__(cls, *args, **kwargs)\n27 \n28     def __init__(self, val):\n29         self.soup = val\n30 \n31 \n32 class ListWriter:\n33     \"\"\"\n34     Allows for XMLWriter to write to a list instead of a file.\n35     \"\"\"\n36 \n37     def __init__(self, out):\n38         self.out = out\n39 \n40     def write(self, data):\n41         self.out.append(data)\n42 \n43 \n44 def identify_table(soup, htmldict, numtable):\n45     \"\"\"\n46     Checks whether the given BeautifulSoup tag is the table\n47     the user intends to process.\n48     \"\"\"\n49 \n50     if soup is None or soup.name != 'table':\n51         return False  # Tag is not a <table>\n52 \n53     elif 'table_id' not in htmldict:\n54         return numtable == 1\n55     table_id = htmldict['table_id']\n56 \n57     if isinstance(table_id, str):\n58         return 'id' in soup.attrs and soup['id'] == table_id\n59     elif isinstance(table_id, int):\n60         return table_id == numtable\n61 \n62     # Return False if an invalid parameter is given\n63     return False\n64 \n65 \n66 class HTMLInputter(core.BaseInputter):\n67     \"\"\"\n68     Input lines of HTML in a valid form.\n69 \n70     This requires `BeautifulSoup\n71     <http://www.crummy.com/software/BeautifulSoup/>`_ to be installed.\n72     \"\"\"\n73 \n74     def process_lines(self, lines):\n75         \"\"\"\n76         Convert the given input into a list of SoupString rows\n77         for further processing.\n78         \"\"\"\n79 \n80         try:\n81             from bs4 import BeautifulSoup\n82         except ImportError:\n83             raise core.OptionalTableImportError('BeautifulSoup must be '\n84                                                 'installed to read HTML tables')\n85 \n86         if 'parser' not in self.html:\n87             with warnings.catch_warnings():\n88                 # Ignore bs4 parser warning #4550.\n89                 warnings.filterwarnings('ignore', '.*no parser was explicitly specified.*')\n90                 soup = BeautifulSoup('\\n'.join(lines))\n91         else:  # use a custom backend parser\n92             soup = BeautifulSoup('\\n'.join(lines), self.html['parser'])\n93         tables = soup.find_all('table')\n94         for i, possible_table in enumerate(tables):\n95             if identify_table(possible_table, self.html, i + 1):\n96                 table = possible_table  # Find the correct table\n97                 break\n98         else:\n99             if isinstance(self.html['table_id'], int):\n100                 err_descr = f\"number {self.html['table_id']}\"\n101             else:\n102                 err_descr = f\"id '{self.html['table_id']}'\"\n103             raise core.InconsistentTableError(\n104                 f'ERROR: HTML table {err_descr} not found')\n105 \n106         # Get all table rows\n107         soup_list = [SoupString(x) for x in table.find_all('tr')]\n108 \n109         return soup_list\n110 \n111 \n112 class HTMLSplitter(core.BaseSplitter):\n113     \"\"\"\n114     Split HTML table data.\n115     \"\"\"\n116 \n117     def __call__(self, lines):\n118         \"\"\"\n119         Return HTML data from lines as a generator.\n120         \"\"\"\n121         for line in lines:\n122             if not isinstance(line, SoupString):\n123                 raise TypeError('HTML lines should be of type SoupString')\n124             soup = line.soup\n125             header_elements = soup.find_all('th')\n126             if header_elements:\n127                 # Return multicolumns as tuples for HTMLHeader handling\n128                 yield [(el.text.strip(), el['colspan']) if el.has_attr('colspan')\n129                        else el.text.strip() for el in header_elements]\n130             data_elements = soup.find_all('td')\n131             if data_elements:\n132                 yield [el.text.strip() for el in data_elements]\n133         if len(lines) == 0:\n134             raise core.InconsistentTableError('HTML tables must contain data '\n135                                               'in a <table> tag')\n136 \n137 \n138 class HTMLOutputter(core.TableOutputter):\n139     \"\"\"\n140     Output the HTML data as an ``astropy.table.Table`` object.\n141 \n142     This subclass allows for the final table to contain\n143     multidimensional columns (defined using the colspan attribute\n144     of <th>).\n145     \"\"\"\n146 \n147     default_converters = [core.convert_numpy(int),\n148                           core.convert_numpy(float),\n149                           core.convert_numpy(str)]\n150 \n151     def __call__(self, cols, meta):\n152         \"\"\"\n153         Process the data in multidimensional columns.\n154         \"\"\"\n155         new_cols = []\n156         col_num = 0\n157 \n158         while col_num < len(cols):\n159             col = cols[col_num]\n160             if hasattr(col, 'colspan'):\n161                 # Join elements of spanned columns together into list of tuples\n162                 span_cols = cols[col_num:col_num + col.colspan]\n163                 new_col = core.Column(col.name)\n164                 new_col.str_vals = list(zip(*[x.str_vals for x in span_cols]))\n165                 new_cols.append(new_col)\n166                 col_num += col.colspan\n167             else:\n168                 new_cols.append(col)\n169                 col_num += 1\n170 \n171         return super().__call__(new_cols, meta)\n172 \n173 \n174 class HTMLHeader(core.BaseHeader):\n175     splitter_class = HTMLSplitter\n176 \n177     def start_line(self, lines):\n178         \"\"\"\n179         Return the line number at which header data begins.\n180         \"\"\"\n181 \n182         for i, line in enumerate(lines):\n183             if not isinstance(line, SoupString):\n184                 raise TypeError('HTML lines should be of type SoupString')\n185             soup = line.soup\n186             if soup.th is not None:\n187                 return i\n188 \n189         return None\n190 \n191     def _set_cols_from_names(self):\n192         \"\"\"\n193         Set columns from header names, handling multicolumns appropriately.\n194         \"\"\"\n195         self.cols = []\n196         new_names = []\n197 \n198         for name in self.names:\n199             if isinstance(name, tuple):\n200                 col = core.Column(name=name[0])\n201                 col.colspan = int(name[1])\n202                 self.cols.append(col)\n203                 new_names.append(name[0])\n204                 for i in range(1, int(name[1])):\n205                     # Add dummy columns\n206                     self.cols.append(core.Column(''))\n207                     new_names.append('')\n208             else:\n209                 self.cols.append(core.Column(name=name))\n210                 new_names.append(name)\n211 \n212         self.names = new_names\n213 \n214 \n215 class HTMLData(core.BaseData):\n216     splitter_class = HTMLSplitter\n217 \n218     def start_line(self, lines):\n219         \"\"\"\n220         Return the line number at which table data begins.\n221         \"\"\"\n222 \n223         for i, line in enumerate(lines):\n224             if not isinstance(line, SoupString):\n225                 raise TypeError('HTML lines should be of type SoupString')\n226             soup = line.soup\n227 \n228             if soup.td is not None:\n229                 if soup.th is not None:\n230                     raise core.InconsistentTableError('HTML tables cannot '\n231                                                       'have headings and data in the same row')\n232                 return i\n233 \n234         raise core.InconsistentTableError('No start line found for HTML data')\n235 \n236     def end_line(self, lines):\n237         \"\"\"\n238         Return the line number at which table data ends.\n239         \"\"\"\n240         last_index = -1\n241 \n242         for i, line in enumerate(lines):\n243             if not isinstance(line, SoupString):\n244                 raise TypeError('HTML lines should be of type SoupString')\n245             soup = line.soup\n246             if soup.td is not None:\n247                 last_index = i\n248 \n249         if last_index == -1:\n250             return None\n251         return last_index + 1\n252 \n253 \n254 class HTML(core.BaseReader):\n255     \"\"\"HTML format table.\n256 \n257     In order to customize input and output, a dict of parameters may\n258     be passed to this class holding specific customizations.\n259 \n260     **htmldict** : Dictionary of parameters for HTML input/output.\n261 \n262         * css : Customized styling\n263             If present, this parameter will be included in a <style>\n264             tag and will define stylistic attributes of the output.\n265 \n266         * table_id : ID for the input table\n267             If a string, this defines the HTML id of the table to be processed.\n268             If an integer, this specifies the index of the input table in the\n269             available tables. Unless this parameter is given, the reader will\n270             use the first table found in the input file.\n271 \n272         * multicol : Use multi-dimensional columns for output\n273             The writer will output tuples as elements of multi-dimensional\n274             columns if this parameter is true, and if not then it will\n275             use the syntax 1.36583e-13 .. 1.36583e-13 for output. If not\n276             present, this parameter will be true by default.\n277 \n278         * raw_html_cols : column name or list of names with raw HTML content\n279             This allows one to include raw HTML content in the column output,\n280             for instance to include link references in a table.  This option\n281             requires that the bleach package be installed.  Only whitelisted\n282             tags are allowed through for security reasons (see the\n283             raw_html_clean_kwargs arg).\n284 \n285         * raw_html_clean_kwargs : dict of keyword args controlling HTML cleaning\n286             Raw HTML will be cleaned to prevent unsafe HTML from ending up in\n287             the table output.  This is done by calling ``bleach.clean(data,\n288             **raw_html_clean_kwargs)``.  For details on the available options\n289             (e.g. tag whitelist) see:\n290             https://bleach.readthedocs.io/en/latest/clean.html\n291 \n292         * parser : Specific HTML parsing library to use\n293             If specified, this specifies which HTML parsing library\n294             BeautifulSoup should use as a backend. The options to choose\n295             from are 'html.parser' (the standard library parser), 'lxml'\n296             (the recommended parser), 'xml' (lxml's XML parser), and\n297             'html5lib'. html5lib is a highly lenient parser and therefore\n298             might work correctly for unusual input if a different parser\n299             fails.\n300 \n301         * jsfiles : list of js files to include when writing table.\n302 \n303         * cssfiles : list of css files to include when writing table.\n304 \n305         * js : js script to include in the body when writing table.\n306 \n307         * table_class : css class for the table\n308 \n309     \"\"\"\n310 \n311     _format_name = 'html'\n312     _io_registry_format_aliases = ['html']\n313     _io_registry_suffix = '.html'\n314     _description = 'HTML table'\n315 \n316     header_class = HTMLHeader\n317     data_class = HTMLData\n318     inputter_class = HTMLInputter\n319 \n320     max_ndim = 2  # HTML supports writing 2-d columns with shape (n, m)\n321 \n322     def __init__(self, htmldict={}):\n323         \"\"\"\n324         Initialize classes for HTML reading and writing.\n325         \"\"\"\n326         super().__init__()\n327         self.html = deepcopy(htmldict)\n328         if 'multicol' not in htmldict:\n329             self.html['multicol'] = True\n330         if 'table_id' not in htmldict:\n331             self.html['table_id'] = 1\n332         self.inputter.html = self.html\n333 \n334     def read(self, table):\n335         \"\"\"\n336         Read the ``table`` in HTML format and return a resulting ``Table``.\n337         \"\"\"\n338 \n339         self.outputter = HTMLOutputter()\n340         return super().read(table)\n341 \n342     def write(self, table):\n343         \"\"\"\n344         Return data in ``table`` converted to HTML as a list of strings.\n345         \"\"\"\n346         # Check that table has only 1-d or 2-d columns. Above that fails.\n347         self._check_multidim_table(table)\n348 \n349         cols = list(table.columns.values())\n350 \n351         self.data.header.cols = cols\n352 \n353         if isinstance(self.data.fill_values, tuple):\n354             self.data.fill_values = [self.data.fill_values]\n355 \n356         self.data._set_fill_values(cols)\n357 \n358         lines = []\n359 \n360         # Set HTML escaping to False for any column in the raw_html_cols input\n361         raw_html_cols = self.html.get('raw_html_cols', [])\n362         if isinstance(raw_html_cols, str):\n363             raw_html_cols = [raw_html_cols]  # Allow for a single string as input\n364         cols_escaped = [col.info.name not in raw_html_cols for col in cols]\n365 \n366         # Kwargs that get passed on to bleach.clean() if that is available.\n367         raw_html_clean_kwargs = self.html.get('raw_html_clean_kwargs', {})\n368 \n369         # Use XMLWriter to output HTML to lines\n370         w = writer.XMLWriter(ListWriter(lines))\n371 \n372         with w.tag('html'):\n373             with w.tag('head'):\n374                 # Declare encoding and set CSS style for table\n375                 with w.tag('meta', attrib={'charset': 'utf-8'}):\n376                     pass\n377                 with w.tag('meta', attrib={'http-equiv': 'Content-type',\n378                                            'content': 'text/html;charset=UTF-8'}):\n379                     pass\n380                 if 'css' in self.html:\n381                     with w.tag('style'):\n382                         w.data(self.html['css'])\n383                 if 'cssfiles' in self.html:\n384                     for filename in self.html['cssfiles']:\n385                         with w.tag('link', rel=\"stylesheet\", href=filename, type='text/css'):\n386                             pass\n387                 if 'jsfiles' in self.html:\n388                     for filename in self.html['jsfiles']:\n389                         with w.tag('script', src=filename):\n390                             w.data('')  # need this instead of pass to get <script></script>\n391             with w.tag('body'):\n392                 if 'js' in self.html:\n393                     with w.xml_cleaning_method('none'):\n394                         with w.tag('script'):\n395                             w.data(self.html['js'])\n396                 if isinstance(self.html['table_id'], str):\n397                     html_table_id = self.html['table_id']\n398                 else:\n399                     html_table_id = None\n400                 if 'table_class' in self.html:\n401                     html_table_class = self.html['table_class']\n402                     attrib = {\"class\": html_table_class}\n403                 else:\n404                     attrib = {}\n405                 with w.tag('table', id=html_table_id, attrib=attrib):\n406                     with w.tag('thead'):\n407                         with w.tag('tr'):\n408                             for col in cols:\n409                                 if len(col.shape) > 1 and self.html['multicol']:\n410                                     # Set colspan attribute for multicolumns\n411                                     w.start('th', colspan=col.shape[1])\n412                                 else:\n413                                     w.start('th')\n414                                 w.data(col.info.name.strip())\n415                                 w.end(indent=False)\n416                         col_str_iters = []\n417                         new_cols_escaped = []\n418 \n419                         # Make a container to hold any new_col objects created\n420                         # below for multicolumn elements.  This is purely to\n421                         # maintain a reference for these objects during\n422                         # subsequent iteration to format column values.  This\n423                         # requires that the weakref info._parent be maintained.\n424                         new_cols = []\n425 \n426                         for col, col_escaped in zip(cols, cols_escaped):\n427                             if len(col.shape) > 1 and self.html['multicol']:\n428                                 span = col.shape[1]\n429                                 for i in range(span):\n430                                     # Split up multicolumns into separate columns\n431                                     new_col = Column([el[i] for el in col])\n432 \n433                                     new_col_iter_str_vals = self.fill_values(\n434                                         col, new_col.info.iter_str_vals())\n435                                     col_str_iters.append(new_col_iter_str_vals)\n436                                     new_cols_escaped.append(col_escaped)\n437                                     new_cols.append(new_col)\n438                             else:\n439 \n440                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n441                                 col_str_iters.append(col_iter_str_vals)\n442 \n443                                 new_cols_escaped.append(col_escaped)\n444 \n445                     for row in zip(*col_str_iters):\n446                         with w.tag('tr'):\n447                             for el, col_escaped in zip(row, new_cols_escaped):\n448                                 # Potentially disable HTML escaping for column\n449                                 method = ('escape_xml' if col_escaped else 'bleach_clean')\n450                                 with w.xml_cleaning_method(method, **raw_html_clean_kwargs):\n451                                     w.start('td')\n452                                     w.data(el.strip())\n453                                     w.end(indent=False)\n454 \n455         # Fixes XMLWriter's insertion of unwanted line breaks\n456         return [''.join(lines)]\n457 \n458     def fill_values(self, col, col_str_iters):\n459         \"\"\"\n460         Return an iterator of the values with replacements based on fill_values\n461         \"\"\"\n462         # check if the col is a masked column and has fill values\n463         is_masked_column = hasattr(col, 'mask')\n464         has_fill_values = hasattr(col, 'fill_values')\n465 \n466         for idx, col_str in enumerate(col_str_iters):\n467             if is_masked_column and has_fill_values:\n468                 if col.mask[idx]:\n469                     yield col.fill_values[core.masked]\n470                     continue\n471 \n472             if has_fill_values:\n473                 if col_str in col.fill_values:\n474                     yield col.fill_values[col_str]\n475                     continue\n476 \n477             yield col_str\n",
        "intended_behavior": "The method(s) within this file responsible for handling HTML output should be updated or fixed to ensure that the `formats` argument is correctly processed and applied when generating HTML tables. This involves: - Parsing the `formats` dictionary argument to apply specified formatting to each column. - Ensuring that these formatting instructions are applied as the HTML table is generated, similar to how formatting is applied in CSV or rst outputs. - The implementation must maintain compatibility with other column specifications and settings, not overriding other functionalities. - This adjustment should occur without affecting the general structure or functionality of the output methods, preserving existing capabilities beyond formatting handling."
    }
]