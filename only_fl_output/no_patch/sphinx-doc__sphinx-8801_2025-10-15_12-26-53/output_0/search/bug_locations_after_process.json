[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2659,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import re\n14 import warnings\n15 from inspect import Parameter, Signature\n16 from types import ModuleType\n17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,\n18                     TypeVar, Union)\n19 \n20 from docutils.statemachine import StringList\n21 \n22 import sphinx\n23 from sphinx.application import Sphinx\n24 from sphinx.config import ENUM, Config\n25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n26                                 RemovedInSphinx60Warning)\n27 from sphinx.environment import BuildEnvironment\n28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,\n29                                          import_object)\n30 from sphinx.ext.autodoc.mock import ismock, mock, undecorate\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect, logging\n34 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n36                                  stringify_signature)\n37 from sphinx.util.typing import get_type_hints, restify\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43 \n44     from sphinx.ext.autodoc.directive import DocumenterBridge\n45 \n46 \n47 logger = logging.getLogger(__name__)\n48 \n49 \n50 # This type isn't exposed directly in any modules, but can be found\n51 # here in most Python versions\n52 MethodDescriptorType = type(type.__subclasses__)\n53 \n54 \n55 #: extended signature RE: with explicit module name separated by ::\n56 py_ext_sig_re = re.compile(\n57     r'''^ ([\\w.]+::)?            # explicit module name\n58           ([\\w.]+\\.)?            # module and/or class name(s)\n59           (\\w+)  \\s*             # thing name\n60           (?: \\((.*)\\)           # optional: arguments\n61            (?:\\s* -> \\s* (.*))?  #           return annotation\n62           )? $                   # and nothing more\n63           ''', re.VERBOSE)\n64 special_member_re = re.compile(r'^__\\S+__$')\n65 \n66 \n67 def identity(x: Any) -> Any:\n68     return x\n69 \n70 \n71 class _All:\n72     \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n73 \n74     def __contains__(self, item: Any) -> bool:\n75         return True\n76 \n77 \n78 class _Empty:\n79     \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n80 \n81     def __contains__(self, item: Any) -> bool:\n82         return False\n83 \n84 \n85 ALL = _All()\n86 EMPTY = _Empty()\n87 UNINITIALIZED_ATTR = object()\n88 INSTANCEATTR = object()\n89 SLOTSATTR = object()\n90 \n91 \n92 def members_option(arg: Any) -> Union[object, List[str]]:\n93     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n94     if arg in (None, True):\n95         return ALL\n96     elif arg is False:\n97         return None\n98     else:\n99         return [x.strip() for x in arg.split(',') if x.strip()]\n100 \n101 \n102 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n103     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n104     warnings.warn(\"members_set_option() is deprecated.\",\n105                   RemovedInSphinx50Warning, stacklevel=2)\n106     if arg is None:\n107         return ALL\n108     return {x.strip() for x in arg.split(',') if x.strip()}\n109 \n110 \n111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n112     \"\"\"Used to convert the :exclude-members: option.\"\"\"\n113     if arg in (None, True):\n114         return EMPTY\n115     return {x.strip() for x in arg.split(',') if x.strip()}\n116 \n117 \n118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n119     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n120     if arg in (None, True):\n121         return 'object'\n122     else:\n123         return arg\n124 \n125 \n126 def member_order_option(arg: Any) -> Optional[str]:\n127     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n128     if arg in (None, True):\n129         return None\n130     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n131         return arg\n132     else:\n133         raise ValueError(__('invalid value for member-order option: %s') % arg)\n134 \n135 \n136 SUPPRESS = object()\n137 \n138 \n139 def annotation_option(arg: Any) -> Any:\n140     if arg in (None, True):\n141         # suppress showing the representation of the object\n142         return SUPPRESS\n143     else:\n144         return arg\n145 \n146 \n147 def bool_option(arg: Any) -> bool:\n148     \"\"\"Used to convert flag options to auto directives.  (Instead of\n149     directives.flag(), which returns None).\n150     \"\"\"\n151     return True\n152 \n153 \n154 def merge_special_members_option(options: Dict) -> None:\n155     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n156     warnings.warn(\"merge_special_members_option() is deprecated.\",\n157                   RemovedInSphinx50Warning, stacklevel=2)\n158     if 'special-members' in options and options['special-members'] is not ALL:\n159         if options.get('members') is ALL:\n160             pass\n161         elif options.get('members'):\n162             for member in options['special-members']:\n163                 if member not in options['members']:\n164                     options['members'].append(member)\n165         else:\n166             options['members'] = options['special-members']\n167 \n168 \n169 def merge_members_option(options: Dict) -> None:\n170     \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n171     if options.get('members') is ALL:\n172         # merging is not needed when members: ALL\n173         return\n174 \n175     members = options.setdefault('members', [])\n176     for key in {'private-members', 'special-members'}:\n177         if key in options and options[key] not in (ALL, None):\n178             for member in options[key]:\n179                 if member not in members:\n180                     members.append(member)\n181 \n182 \n183 # Some useful event listener factories for autodoc-process-docstring.\n184 \n185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n186     \"\"\"Return a listener that removes the first *pre* and last *post*\n187     lines of every docstring.  If *what* is a sequence of strings,\n188     only docstrings of a type in *what* will be processed.\n189 \n190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n191 \n192        from sphinx.ext.autodoc import cut_lines\n193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n194 \n195     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n196     \"\"\"\n197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n198                 ) -> None:\n199         if what and what_ not in what:\n200             return\n201         del lines[:pre]\n202         if post:\n203             # remove one trailing blank line.\n204             if lines and not lines[-1]:\n205                 lines.pop(-1)\n206             del lines[-post:]\n207         # make sure there is a blank line at the end\n208         if lines and lines[-1]:\n209             lines.append('')\n210     return process\n211 \n212 \n213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n214             exclude: bool = False) -> Callable:\n215     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n216     lines between lines that match the *marker* regular expression.  If no line\n217     matches, the resulting docstring would be empty, so no change will be made\n218     unless *keepempty* is true.\n219 \n220     If *what* is a sequence of strings, only docstrings of a type in *what* will\n221     be processed.\n222     \"\"\"\n223     marker_re = re.compile(marker)\n224 \n225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n226                 ) -> None:\n227         if what and what_ not in what:\n228             return\n229         deleted = 0\n230         delete = not exclude\n231         orig_lines = lines[:]\n232         for i, line in enumerate(orig_lines):\n233             if delete:\n234                 lines.pop(i - deleted)\n235                 deleted += 1\n236             if marker_re.match(line):\n237                 delete = not delete\n238                 if delete:\n239                     lines.pop(i - deleted)\n240                     deleted += 1\n241         if not lines and not keepempty:\n242             lines[:] = orig_lines\n243         # make sure there is a blank line at the end\n244         if lines and lines[-1]:\n245             lines.append('')\n246     return process\n247 \n248 \n249 # This class is used only in ``sphinx.ext.autodoc.directive``,\n250 # But we define this class here to keep compatibility (see #4538)\n251 class Options(dict):\n252     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n253     def __getattr__(self, name: str) -> Any:\n254         try:\n255             return self[name.replace('_', '-')]\n256         except KeyError:\n257             return None\n258 \n259 \n260 class ObjectMember(tuple):\n261     \"\"\"A member of object.\n262 \n263     This is used for the result of `Documenter.get_object_members()` to\n264     represent each member of the object.\n265 \n266     .. Note::\n267 \n268        An instance of this class behaves as a tuple of (name, object)\n269        for compatibility to old Sphinx.  The behavior will be dropped\n270        in the future.  Therefore extensions should not use the tuple\n271        interface.\n272     \"\"\"\n273 \n274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n275         return super().__new__(cls, (name, obj))  # type: ignore\n276 \n277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,\n278                  class_: Any = None, skipped: bool = False) -> None:\n279         self.__name__ = name\n280         self.object = obj\n281         self.docstring = docstring\n282         self.skipped = skipped\n283         self.class_ = class_\n284 \n285 \n286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n287 \n288 \n289 class Documenter:\n290     \"\"\"\n291     A Documenter knows how to autodocument a single object type.  When\n292     registered with the AutoDirective, it will be used to document objects\n293     of that type when needed by autodoc.\n294 \n295     Its *objtype* attribute selects what auto directive it is assigned to\n296     (the directive name is 'auto' + objtype), and what directive it generates\n297     by default, though that can be overridden by an attribute called\n298     *directivetype*.\n299 \n300     A Documenter has an *option_spec* that works like a docutils directive's;\n301     in fact, it will be used to parse an auto directive's options that matches\n302     the documenter.\n303     \"\"\"\n304     #: name by which the directive is called (auto...) and the default\n305     #: generated directive name\n306     objtype = 'object'\n307     #: indentation by which to indent the directive content\n308     content_indent = '   '\n309     #: priority if multiple documenters return True from can_document_member\n310     priority = 0\n311     #: order if autodoc_member_order is set to 'groupwise'\n312     member_order = 0\n313     #: true if the generated content may contain titles\n314     titles_allowed = False\n315 \n316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n317 \n318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n319         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n321 \n322     @classmethod\n323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n324                             ) -> bool:\n325         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n326         raise NotImplementedError('must be implemented in subclasses')\n327 \n328     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n329         self.directive = directive\n330         self.config = directive.env.config\n331         self.env = directive.env    # type: BuildEnvironment\n332         self.options = directive.genopt\n333         self.name = name\n334         self.indent = indent\n335         # the module and object path within the module, and the fully\n336         # qualified name (all set after resolve_name succeeds)\n337         self.modname = None         # type: str\n338         self.module = None          # type: ModuleType\n339         self.objpath = None         # type: List[str]\n340         self.fullname = None        # type: str\n341         # extra signature items (arguments and return annotation,\n342         # also set after resolve_name succeeds)\n343         self.args = None            # type: str\n344         self.retann = None          # type: str\n345         # the object to document (set after import_object succeeds)\n346         self.object = None          # type: Any\n347         self.object_name = None     # type: str\n348         # the parent/owner of the object to document\n349         self.parent = None          # type: Any\n350         # the module analyzer to get at attribute docs, or None\n351         self.analyzer = None        # type: ModuleAnalyzer\n352 \n353     @property\n354     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n355         \"\"\"Returns registered Documenter classes\"\"\"\n356         return self.env.app.registry.documenters\n357 \n358     def add_line(self, line: str, source: str, *lineno: int) -> None:\n359         \"\"\"Append one line of generated reST to the output.\"\"\"\n360         if line.strip():  # not a blank line\n361             self.directive.result.append(self.indent + line, source, *lineno)\n362         else:\n363             self.directive.result.append('', source, *lineno)\n364 \n365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n366                      ) -> Tuple[str, List[str]]:\n367         \"\"\"Resolve the module and name of the object to document given by the\n368         arguments and the current module/class.\n369 \n370         Must return a pair of the module name and a chain of attributes; for\n371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n372         ``zipfile.ZipFile.open`` method.\n373         \"\"\"\n374         raise NotImplementedError('must be implemented in subclasses')\n375 \n376     def parse_name(self) -> bool:\n377         \"\"\"Determine what module to import and what attribute to document.\n378 \n379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n380         *self.args* and *self.retann* if parsing and resolving was successful.\n381         \"\"\"\n382         # first, parse the definition -- auto directives for classes and\n383         # functions can contain a signature which is then used instead of\n384         # an autogenerated one\n385         try:\n386             explicit_modname, path, base, args, retann = \\\n387                 py_ext_sig_re.match(self.name).groups()\n388         except AttributeError:\n389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n390                            type='autodoc')\n391             return False\n392 \n393         # support explicit module and class name separation via ::\n394         if explicit_modname is not None:\n395             modname = explicit_modname[:-2]\n396             parents = path.rstrip('.').split('.') if path else []\n397         else:\n398             modname = None\n399             parents = []\n400 \n401         with mock(self.config.autodoc_mock_imports):\n402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n403 \n404         if not self.modname:\n405             return False\n406 \n407         self.args = args\n408         self.retann = retann\n409         self.fullname = (self.modname or '') + \\\n410                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n411         return True\n412 \n413     def import_object(self, raiseerror: bool = False) -> bool:\n414         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n415         it as *self.object*.\n416 \n417         Returns True if successful, False if an error occurred.\n418         \"\"\"\n419         with mock(self.config.autodoc_mock_imports):\n420             try:\n421                 ret = import_object(self.modname, self.objpath, self.objtype,\n422                                     attrgetter=self.get_attr,\n423                                     warningiserror=self.config.autodoc_warningiserror)\n424                 self.module, self.parent, self.object_name, self.object = ret\n425                 if ismock(self.object):\n426                     self.object = undecorate(self.object)\n427                 return True\n428             except ImportError as exc:\n429                 if raiseerror:\n430                     raise\n431                 else:\n432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n433                     self.env.note_reread()\n434                     return False\n435 \n436     def get_real_modname(self) -> str:\n437         \"\"\"Get the real module name of an object to document.\n438 \n439         It can differ from the name of the module through which the object was\n440         imported.\n441         \"\"\"\n442         return self.get_attr(self.object, '__module__', None) or self.modname\n443 \n444     def check_module(self) -> bool:\n445         \"\"\"Check if *self.object* is really defined in the module given by\n446         *self.modname*.\n447         \"\"\"\n448         if self.options.imported_members:\n449             return True\n450 \n451         subject = inspect.unpartial(self.object)\n452         modname = self.get_attr(subject, '__module__', None)\n453         if modname and modname != self.modname:\n454             return False\n455         return True\n456 \n457     def format_args(self, **kwargs: Any) -> str:\n458         \"\"\"Format the argument signature of *self.object*.\n459 \n460         Should return None if the object does not have a signature.\n461         \"\"\"\n462         return None\n463 \n464     def format_name(self) -> str:\n465         \"\"\"Format the name of *self.object*.\n466 \n467         This normally should be something that can be parsed by the generated\n468         directive, but doesn't need to be (Sphinx will display it unparsed\n469         then).\n470         \"\"\"\n471         # normally the name doesn't contain the module (except for module\n472         # directives of course)\n473         return '.'.join(self.objpath) or self.modname\n474 \n475     def _call_format_args(self, **kwargs: Any) -> str:\n476         if kwargs:\n477             try:\n478                 return self.format_args(**kwargs)\n479             except TypeError:\n480                 # avoid chaining exceptions, by putting nothing here\n481                 pass\n482 \n483         # retry without arguments for old documenters\n484         return self.format_args()\n485 \n486     def format_signature(self, **kwargs: Any) -> str:\n487         \"\"\"Format the signature (arguments and return annotation) of the object.\n488 \n489         Let the user process it via the ``autodoc-process-signature`` event.\n490         \"\"\"\n491         if self.args is not None:\n492             # signature given explicitly\n493             args = \"(%s)\" % self.args\n494             retann = self.retann\n495         else:\n496             # try to introspect the signature\n497             try:\n498                 retann = None\n499                 args = self._call_format_args(**kwargs)\n500                 if args:\n501                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n502                     if matched:\n503                         args = matched.group(1)\n504                         retann = matched.group(2)\n505             except Exception as exc:\n506                 logger.warning(__('error while formatting arguments for %s: %s'),\n507                                self.fullname, exc, type='autodoc')\n508                 args = None\n509 \n510         result = self.env.events.emit_firstresult('autodoc-process-signature',\n511                                                   self.objtype, self.fullname,\n512                                                   self.object, self.options, args, retann)\n513         if result:\n514             args, retann = result\n515 \n516         if args is not None:\n517             return args + ((' -> %s' % retann) if retann else '')\n518         else:\n519             return ''\n520 \n521     def add_directive_header(self, sig: str) -> None:\n522         \"\"\"Add the directive header and options to the generated content.\"\"\"\n523         domain = getattr(self, 'domain', 'py')\n524         directive = getattr(self, 'directivetype', self.objtype)\n525         name = self.format_name()\n526         sourcename = self.get_sourcename()\n527 \n528         # one signature per line, indented by column\n529         prefix = '.. %s:%s:: ' % (domain, directive)\n530         for i, sig_line in enumerate(sig.split(\"\\n\")):\n531             self.add_line('%s%s%s' % (prefix, name, sig_line),\n532                           sourcename)\n533             if i == 0:\n534                 prefix = \" \" * len(prefix)\n535 \n536         if self.options.noindex:\n537             self.add_line('   :noindex:', sourcename)\n538         if self.objpath:\n539             # Be explicit about the module, this is necessary since .. class::\n540             # etc. don't support a prepended module name\n541             self.add_line('   :module: %s' % self.modname, sourcename)\n542 \n543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n544         \"\"\"Decode and return lines of the docstring(s) for the object.\n545 \n546         When it returns None value, autodoc-process-docstring will not be called for this\n547         object.\n548         \"\"\"\n549         if encoding is not None:\n550             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n551                           % self.__class__.__name__,\n552                           RemovedInSphinx40Warning, stacklevel=2)\n553         if ignore is not None:\n554             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n555                           % self.__class__.__name__,\n556                           RemovedInSphinx50Warning, stacklevel=2)\n557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n558                            self.parent, self.object_name)\n559         if docstring:\n560             tab_width = self.directive.state.document.settings.tab_width\n561             return [prepare_docstring(docstring, ignore, tab_width)]\n562         return []\n563 \n564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n565         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n566         for docstringlines in docstrings:\n567             if self.env.app:\n568                 # let extensions preprocess docstrings\n569                 self.env.app.emit('autodoc-process-docstring',\n570                                   self.objtype, self.fullname, self.object,\n571                                   self.options, docstringlines)\n572 \n573                 if docstringlines and docstringlines[-1] != '':\n574                     # append a blank line to the end of the docstring\n575                     docstringlines.append('')\n576 \n577             yield from docstringlines\n578 \n579     def get_sourcename(self) -> str:\n580         if (getattr(self.object, '__module__', None) and\n581                 getattr(self.object, '__qualname__', None)):\n582             # Get the correct location of docstring from self.object\n583             # to support inherited methods\n584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n585         else:\n586             fullname = self.fullname\n587 \n588         if self.analyzer:\n589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n590         else:\n591             return 'docstring of %s' % fullname\n592 \n593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n594                     ) -> None:\n595         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n596         if no_docstring:\n597             warnings.warn(\"The 'no_docstring' argument to %s.add_content() is deprecated.\"\n598                           % self.__class__.__name__,\n599                           RemovedInSphinx50Warning, stacklevel=2)\n600 \n601         # set sourcename and add content from attribute documentation\n602         sourcename = self.get_sourcename()\n603         if self.analyzer:\n604             attr_docs = self.analyzer.find_attr_docs()\n605             if self.objpath:\n606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n607                 if key in attr_docs:\n608                     no_docstring = True\n609                     # make a copy of docstring for attributes to avoid cache\n610                     # the change of autodoc-process-docstring event.\n611                     docstrings = [list(attr_docs[key])]\n612 \n613                     for i, line in enumerate(self.process_doc(docstrings)):\n614                         self.add_line(line, sourcename, i)\n615 \n616         # add content from docstrings\n617         if not no_docstring:\n618             docstrings = self.get_doc()\n619             if docstrings is None:\n620                 # Do not call autodoc-process-docstring on get_doc() returns None.\n621                 pass\n622             else:\n623                 if not docstrings:\n624                     # append at least a dummy docstring, so that the event\n625                     # autodoc-process-docstring is fired and can add some\n626                     # content if desired\n627                     docstrings.append([])\n628                 for i, line in enumerate(self.process_doc(docstrings)):\n629                     self.add_line(line, sourcename, i)\n630 \n631         # add additional content (e.g. from document), if present\n632         if more_content:\n633             for line, src in zip(more_content.data, more_content.items):\n634                 self.add_line(line, src[0], src[1])\n635 \n636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n637         \"\"\"Return `(members_check_module, members)` where `members` is a\n638         list of `(membername, member)` pairs of the members of *self.object*.\n639 \n640         If *want_all* is True, return all members.  Else, only return those\n641         members given by *self.options.members* (which may also be none).\n642         \"\"\"\n643         warnings.warn('The implementation of Documenter.get_object_members() will be '\n644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)\n645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n646         if not want_all:\n647             if not self.options.members:\n648                 return False, []  # type: ignore\n649             # specific members given\n650             selected = []\n651             for name in self.options.members:  # type: str\n652                 if name in members:\n653                     selected.append((name, members[name].value))\n654                 else:\n655                     logger.warning(__('missing attribute %s in object %s') %\n656                                    (name, self.fullname), type='autodoc')\n657             return False, selected\n658         elif self.options.inherited_members:\n659             return False, [(m.name, m.value) for m in members.values()]\n660         else:\n661             return False, [(m.name, m.value) for m in members.values()\n662                            if m.directly_defined]\n663 \n664     def filter_members(self, members: ObjectMembers, want_all: bool\n665                        ) -> List[Tuple[str, Any, bool]]:\n666         \"\"\"Filter the given member list.\n667 \n668         Members are skipped if\n669 \n670         - they are private (except if given explicitly or the private-members\n671           option is set)\n672         - they are special methods (except if given explicitly or the\n673           special-members option is set)\n674         - they are undocumented (except if the undoc-members option is set)\n675 \n676         The user can override the skipping decision by connecting to the\n677         ``autodoc-skip-member`` event.\n678         \"\"\"\n679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n680             if inspect.isclass(self.object):\n681                 for cls in self.object.__mro__:\n682                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n683                         # given member is a member of specified *super class*\n684                         return True\n685                     elif name in cls.__dict__:\n686                         return False\n687                     elif name in self.get_attr(cls, '__annotations__', {}):\n688                         return False\n689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n690                         return False\n691 \n692             return False\n693 \n694         ret = []\n695 \n696         # search for members in source code too\n697         namespace = '.'.join(self.objpath)  # will be empty for modules\n698 \n699         if self.analyzer:\n700             attr_docs = self.analyzer.find_attr_docs()\n701         else:\n702             attr_docs = {}\n703 \n704         # process members and determine which to skip\n705         for obj in members:\n706             membername, member = obj\n707             # if isattr is True, the member is documented as an attribute\n708             if member is INSTANCEATTR:\n709                 isattr = True\n710             else:\n711                 isattr = False\n712 \n713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n714                          self.parent, self.object_name)\n715             if not isinstance(doc, str):\n716                 # Ignore non-string __doc__\n717                 doc = None\n718 \n719             # if the member __doc__ is the same as self's __doc__, it's just\n720             # inherited and therefore not the member's doc\n721             cls = self.get_attr(member, '__class__', None)\n722             if cls:\n723                 cls_doc = self.get_attr(cls, '__doc__', None)\n724                 if cls_doc == doc:\n725                     doc = None\n726 \n727             if isinstance(obj, ObjectMember) and obj.docstring:\n728                 # hack for ClassDocumenter to inject docstring via ObjectMember\n729                 doc = obj.docstring\n730 \n731             has_doc = bool(doc)\n732 \n733             metadata = extract_metadata(doc)\n734             if 'private' in metadata:\n735                 # consider a member private if docstring has \"private\" metadata\n736                 isprivate = True\n737             elif 'public' in metadata:\n738                 # consider a member public if docstring has \"public\" metadata\n739                 isprivate = False\n740             else:\n741                 isprivate = membername.startswith('_')\n742 \n743             keep = False\n744             if ismock(member):\n745                 # mocked module or object\n746                 pass\n747             elif self.options.exclude_members and membername in self.options.exclude_members:\n748                 # remove members given by exclude-members\n749                 keep = False\n750             elif want_all and special_member_re.match(membername):\n751                 # special __methods__\n752                 if self.options.special_members and membername in self.options.special_members:\n753                     if membername == '__doc__':\n754                         keep = False\n755                     elif is_filtered_inherited_member(membername, obj):\n756                         keep = False\n757                     else:\n758                         keep = has_doc or self.options.undoc_members\n759                 else:\n760                     keep = False\n761             elif (namespace, membername) in attr_docs:\n762                 if want_all and isprivate:\n763                     if self.options.private_members is None:\n764                         keep = False\n765                     else:\n766                         keep = membername in self.options.private_members\n767                 else:\n768                     # keep documented attributes\n769                     keep = True\n770                 isattr = True\n771             elif want_all and isprivate:\n772                 if has_doc or self.options.undoc_members:\n773                     if self.options.private_members is None:\n774                         keep = False\n775                     elif is_filtered_inherited_member(membername, obj):\n776                         keep = False\n777                     else:\n778                         keep = membername in self.options.private_members\n779                 else:\n780                     keep = False\n781             else:\n782                 if (self.options.members is ALL and\n783                         is_filtered_inherited_member(membername, obj)):\n784                     keep = False\n785                 else:\n786                     # ignore undocumented members if :undoc-members: is not given\n787                     keep = has_doc or self.options.undoc_members\n788 \n789             if isinstance(obj, ObjectMember) and obj.skipped:\n790                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n791                 keep = False\n792 \n793             # give the user a chance to decide whether this member\n794             # should be skipped\n795             if self.env.app:\n796                 # let extensions preprocess docstrings\n797                 try:\n798                     skip_user = self.env.app.emit_firstresult(\n799                         'autodoc-skip-member', self.objtype, membername, member,\n800                         not keep, self.options)\n801                     if skip_user is not None:\n802                         keep = not skip_user\n803                 except Exception as exc:\n804                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n805                                       'the following exception was raised:\\n%s'),\n806                                    member, exc, type='autodoc')\n807                     keep = False\n808 \n809             if keep:\n810                 ret.append((membername, member, isattr))\n811 \n812         return ret\n813 \n814     def document_members(self, all_members: bool = False) -> None:\n815         \"\"\"Generate reST for member documentation.\n816 \n817         If *all_members* is True, do all members, else those given by\n818         *self.options.members*.\n819         \"\"\"\n820         # set current namespace for finding members\n821         self.env.temp_data['autodoc:module'] = self.modname\n822         if self.objpath:\n823             self.env.temp_data['autodoc:class'] = self.objpath[0]\n824 \n825         want_all = all_members or self.options.inherited_members or \\\n826             self.options.members is ALL\n827         # find out which members are documentable\n828         members_check_module, members = self.get_object_members(want_all)\n829 \n830         # document non-skipped members\n831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n832         for (mname, member, isattr) in self.filter_members(members, want_all):\n833             classes = [cls for cls in self.documenters.values()\n834                        if cls.can_document_member(member, mname, isattr, self)]\n835             if not classes:\n836                 # don't know how to document this member\n837                 continue\n838             # prefer the documenter with the highest priority\n839             classes.sort(key=lambda cls: cls.priority)\n840             # give explicitly separated module name, so that members\n841             # of inner classes can be documented\n842             full_mname = self.modname + '::' + \\\n843                 '.'.join(self.objpath + [mname])\n844             documenter = classes[-1](self.directive, full_mname, self.indent)\n845             memberdocumenters.append((documenter, isattr))\n846 \n847         member_order = self.options.member_order or self.config.autodoc_member_order\n848         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n849 \n850         for documenter, isattr in memberdocumenters:\n851             documenter.generate(\n852                 all_members=True, real_modname=self.real_modname,\n853                 check_module=members_check_module and not isattr)\n854 \n855         # reset current objects\n856         self.env.temp_data['autodoc:module'] = None\n857         self.env.temp_data['autodoc:class'] = None\n858 \n859     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n860                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n861         \"\"\"Sort the given member list.\"\"\"\n862         if order == 'groupwise':\n863             # sort by group; alphabetically within groups\n864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n865         elif order == 'bysource':\n866             if self.analyzer:\n867                 # sort by source order, by virtue of the module analyzer\n868                 tagorder = self.analyzer.tagorder\n869 \n870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n871                     fullname = entry[0].name.split('::')[1]\n872                     return tagorder.get(fullname, len(tagorder))\n873                 documenters.sort(key=keyfunc)\n874             else:\n875                 # Assume that member discovery order matches source order.\n876                 # This is a reasonable assumption in Python 3.6 and up, where\n877                 # module.__dict__ is insertion-ordered.\n878                 pass\n879         else:  # alphabetical\n880             documenters.sort(key=lambda e: e[0].name)\n881 \n882         return documenters\n883 \n884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n885                  check_module: bool = False, all_members: bool = False) -> None:\n886         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n887         its members.\n888 \n889         If *more_content* is given, include that content. If *real_modname* is\n890         given, use that module name to find attribute docs. If *check_module* is\n891         True, only generate if the object is defined in the module name it is\n892         imported from. If *all_members* is True, document all members.\n893         \"\"\"\n894         if not self.parse_name():\n895             # need a module to import\n896             logger.warning(\n897                 __('don\\'t know which module to import for autodocumenting '\n898                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n899                    'in the document, or giving an explicit module name)') %\n900                 self.name, type='autodoc')\n901             return\n902 \n903         # now, import the module and get object to document\n904         if not self.import_object():\n905             return\n906 \n907         # If there is no real module defined, figure out which to use.\n908         # The real module is used in the module analyzer to look up the module\n909         # where the attribute documentation would actually be found in.\n910         # This is used for situations where you have a module that collects the\n911         # functions and classes of internal submodules.\n912         guess_modname = self.get_real_modname()\n913         self.real_modname = real_modname or guess_modname\n914 \n915         # try to also get a source code analyzer for attribute docs\n916         try:\n917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n918             # parse right now, to get PycodeErrors on parsing (results will\n919             # be cached anyway)\n920             self.analyzer.find_attr_docs()\n921         except PycodeError as exc:\n922             logger.debug('[autodoc] module analyzer failed: %s', exc)\n923             # no source file -- e.g. for builtin and C modules\n924             self.analyzer = None\n925             # at least add the module.__file__ as a dependency\n926             if hasattr(self.module, '__file__') and self.module.__file__:\n927                 self.directive.filename_set.add(self.module.__file__)\n928         else:\n929             self.directive.filename_set.add(self.analyzer.srcname)\n930 \n931         if self.real_modname != guess_modname:\n932             # Add module to dependency list if target object is defined in other module.\n933             try:\n934                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n935                 self.directive.filename_set.add(analyzer.srcname)\n936             except PycodeError:\n937                 pass\n938 \n939         # check __module__ of object (for members not given explicitly)\n940         if check_module:\n941             if not self.check_module():\n942                 return\n943 \n944         sourcename = self.get_sourcename()\n945 \n946         # make sure that the result starts with an empty line.  This is\n947         # necessary for some situations where another directive preprocesses\n948         # reST and no starting newline is present\n949         self.add_line('', sourcename)\n950 \n951         # format the object's signature, if any\n952         try:\n953             sig = self.format_signature()\n954         except Exception as exc:\n955             logger.warning(__('error while formatting signature for %s: %s'),\n956                            self.fullname, exc, type='autodoc')\n957             return\n958 \n959         # generate the directive header and options, if applicable\n960         self.add_directive_header(sig)\n961         self.add_line('', sourcename)\n962 \n963         # e.g. the module directive doesn't have content\n964         self.indent += self.content_indent\n965 \n966         # add all content (from docstrings, attribute docs etc.)\n967         self.add_content(more_content)\n968 \n969         # document members, if possible\n970         self.document_members(all_members)\n971 \n972 \n973 class ModuleDocumenter(Documenter):\n974     \"\"\"\n975     Specialized Documenter subclass for modules.\n976     \"\"\"\n977     objtype = 'module'\n978     content_indent = ''\n979     titles_allowed = True\n980 \n981     option_spec = {\n982         'members': members_option, 'undoc-members': bool_option,\n983         'noindex': bool_option, 'inherited-members': inherited_members_option,\n984         'show-inheritance': bool_option, 'synopsis': identity,\n985         'platform': identity, 'deprecated': bool_option,\n986         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n987         'private-members': members_option, 'special-members': members_option,\n988         'imported-members': bool_option, 'ignore-module-all': bool_option\n989     }  # type: Dict[str, Callable]\n990 \n991     def __init__(self, *args: Any) -> None:\n992         super().__init__(*args)\n993         merge_members_option(self.options)\n994         self.__all__ = None  # type: Optional[Sequence[str]]\n995 \n996     @classmethod\n997     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n998                             ) -> bool:\n999         # don't document submodules automatically\n1000         return False\n1001 \n1002     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1003                      ) -> Tuple[str, List[str]]:\n1004         if modname is not None:\n1005             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1006                            type='autodoc')\n1007         return (path or '') + base, []\n1008 \n1009     def parse_name(self) -> bool:\n1010         ret = super().parse_name()\n1011         if self.args or self.retann:\n1012             logger.warning(__('signature arguments or return annotation '\n1013                               'given for automodule %s') % self.fullname,\n1014                            type='autodoc')\n1015         return ret\n1016 \n1017     def import_object(self, raiseerror: bool = False) -> bool:\n1018         ret = super().import_object(raiseerror)\n1019 \n1020         try:\n1021             if not self.options.ignore_module_all:\n1022                 self.__all__ = inspect.getall(self.object)\n1023         except ValueError as exc:\n1024             # invalid __all__ found.\n1025             logger.warning(__('__all__ should be a list of strings, not %r '\n1026                               '(in module %s) -- ignoring __all__') %\n1027                            (exc.args[0], self.fullname), type='autodoc')\n1028 \n1029         return ret\n1030 \n1031     def add_directive_header(self, sig: str) -> None:\n1032         Documenter.add_directive_header(self, sig)\n1033 \n1034         sourcename = self.get_sourcename()\n1035 \n1036         # add some module-specific options\n1037         if self.options.synopsis:\n1038             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1039         if self.options.platform:\n1040             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1041         if self.options.deprecated:\n1042             self.add_line('   :deprecated:', sourcename)\n1043 \n1044     def get_module_members(self) -> Dict[str, ObjectMember]:\n1045         \"\"\"Get members of target module.\"\"\"\n1046         if self.analyzer:\n1047             attr_docs = self.analyzer.attr_docs\n1048         else:\n1049             attr_docs = {}\n1050 \n1051         members = {}  # type: Dict[str, ObjectMember]\n1052         for name in dir(self.object):\n1053             try:\n1054                 value = safe_getattr(self.object, name, None)\n1055                 if ismock(value):\n1056                     value = undecorate(value)\n1057                 docstring = attr_docs.get(('', name), [])\n1058                 members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n1059             except AttributeError:\n1060                 continue\n1061 \n1062         # annotation only member (ex. attr: int)\n1063         for name in inspect.getannotations(self.object):\n1064             if name not in members:\n1065                 docstring = attr_docs.get(('', name), [])\n1066                 members[name] = ObjectMember(name, INSTANCEATTR,\n1067                                              docstring=\"\\n\".join(docstring))\n1068 \n1069         return members\n1070 \n1071     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1072         members = self.get_module_members()\n1073         if want_all:\n1074             if self.__all__ is None:\n1075                 # for implicit module members, check __module__ to avoid\n1076                 # documenting imported objects\n1077                 return True, list(members.values())\n1078             else:\n1079                 for member in members.values():\n1080                     if member.__name__ not in self.__all__:\n1081                         member.skipped = True\n1082 \n1083                 return False, list(members.values())\n1084         else:\n1085             memberlist = self.options.members or []\n1086             ret = []\n1087             for name in memberlist:\n1088                 if name in members:\n1089                     ret.append(members[name])\n1090                 else:\n1091                     logger.warning(__('missing attribute mentioned in :members: option: '\n1092                                       'module %s, attribute %s') %\n1093                                    (safe_getattr(self.object, '__name__', '???'), name),\n1094                                    type='autodoc')\n1095             return False, ret\n1096 \n1097     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1098                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1099         if order == 'bysource' and self.__all__:\n1100             # Sort alphabetically first (for members not listed on the __all__)\n1101             documenters.sort(key=lambda e: e[0].name)\n1102 \n1103             # Sort by __all__\n1104             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1105                 name = entry[0].name.split('::')[1]\n1106                 if name in self.__all__:\n1107                     return self.__all__.index(name)\n1108                 else:\n1109                     return len(self.__all__)\n1110             documenters.sort(key=keyfunc)\n1111 \n1112             return documenters\n1113         else:\n1114             return super().sort_members(documenters, order)\n1115 \n1116 \n1117 class ModuleLevelDocumenter(Documenter):\n1118     \"\"\"\n1119     Specialized Documenter subclass for objects on module level (functions,\n1120     classes, data/constants).\n1121     \"\"\"\n1122     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1123                      ) -> Tuple[str, List[str]]:\n1124         if modname is None:\n1125             if path:\n1126                 modname = path.rstrip('.')\n1127             else:\n1128                 # if documenting a toplevel object without explicit module,\n1129                 # it can be contained in another auto directive ...\n1130                 modname = self.env.temp_data.get('autodoc:module')\n1131                 # ... or in the scope of a module directive\n1132                 if not modname:\n1133                     modname = self.env.ref_context.get('py:module')\n1134                 # ... else, it stays None, which means invalid\n1135         return modname, parents + [base]\n1136 \n1137 \n1138 class ClassLevelDocumenter(Documenter):\n1139     \"\"\"\n1140     Specialized Documenter subclass for objects on class level (methods,\n1141     attributes).\n1142     \"\"\"\n1143     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1144                      ) -> Tuple[str, List[str]]:\n1145         if modname is None:\n1146             if path:\n1147                 mod_cls = path.rstrip('.')\n1148             else:\n1149                 mod_cls = None\n1150                 # if documenting a class-level object without path,\n1151                 # there must be a current class, either from a parent\n1152                 # auto directive ...\n1153                 mod_cls = self.env.temp_data.get('autodoc:class')\n1154                 # ... or from a class directive\n1155                 if mod_cls is None:\n1156                     mod_cls = self.env.ref_context.get('py:class')\n1157                 # ... if still None, there's no way to know\n1158                 if mod_cls is None:\n1159                     return None, []\n1160             modname, sep, cls = mod_cls.rpartition('.')\n1161             parents = [cls]\n1162             # if the module name is still missing, get it like above\n1163             if not modname:\n1164                 modname = self.env.temp_data.get('autodoc:module')\n1165             if not modname:\n1166                 modname = self.env.ref_context.get('py:module')\n1167             # ... else, it stays None, which means invalid\n1168         return modname, parents + [base]\n1169 \n1170 \n1171 class DocstringSignatureMixin:\n1172     \"\"\"\n1173     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1174     feature of reading the signature from the docstring.\n1175     \"\"\"\n1176     _new_docstrings = None  # type: List[List[str]]\n1177     _signatures = None      # type: List[str]\n1178 \n1179     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1180         if encoding is not None:\n1181             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1182                           \"deprecated.\" % self.__class__.__name__,\n1183                           RemovedInSphinx40Warning, stacklevel=2)\n1184 \n1185         # candidates of the object name\n1186         valid_names = [self.objpath[-1]]  # type: ignore\n1187         if isinstance(self, ClassDocumenter):\n1188             valid_names.append('__init__')\n1189             if hasattr(self.object, '__mro__'):\n1190                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1191 \n1192         docstrings = self.get_doc()\n1193         if docstrings is None:\n1194             return None, None\n1195         self._new_docstrings = docstrings[:]\n1196         self._signatures = []\n1197         result = None\n1198         for i, doclines in enumerate(docstrings):\n1199             for j, line in enumerate(doclines):\n1200                 if not line:\n1201                     # no lines in docstring, no match\n1202                     break\n1203 \n1204                 if line.endswith('\\\\'):\n1205                     multiline = True\n1206                     line = line.rstrip('\\\\').rstrip()\n1207                 else:\n1208                     multiline = False\n1209 \n1210                 # match first line of docstring against signature RE\n1211                 match = py_ext_sig_re.match(line)\n1212                 if not match:\n1213                     continue\n1214                 exmod, path, base, args, retann = match.groups()\n1215 \n1216                 # the base name must match ours\n1217                 if base not in valid_names:\n1218                     continue\n1219 \n1220                 # re-prepare docstring to ignore more leading indentation\n1221                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1222                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1223                                                             tabsize=tab_width)\n1224 \n1225                 if result is None:\n1226                     # first signature\n1227                     result = args, retann\n1228                 else:\n1229                     # subsequent signatures\n1230                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1231 \n1232                 if multiline:\n1233                     # the signature have multiple signatures on docstring\n1234                     continue\n1235                 else:\n1236                     # don't look any further\n1237                     break\n1238 \n1239             if result:\n1240                 # finish the loop when signature found\n1241                 break\n1242 \n1243         return result\n1244 \n1245     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1246         if encoding is not None:\n1247             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1248                           % self.__class__.__name__,\n1249                           RemovedInSphinx40Warning, stacklevel=2)\n1250         if self._new_docstrings is not None:\n1251             return self._new_docstrings\n1252         return super().get_doc(None, ignore)  # type: ignore\n1253 \n1254     def format_signature(self, **kwargs: Any) -> str:\n1255         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1256             # only act if a signature is not explicitly given already, and if\n1257             # the feature is enabled\n1258             result = self._find_signature()\n1259             if result is not None:\n1260                 self.args, self.retann = result\n1261         sig = super().format_signature(**kwargs)  # type: ignore\n1262         if self._signatures:\n1263             return \"\\n\".join([sig] + self._signatures)\n1264         else:\n1265             return sig\n1266 \n1267 \n1268 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1269     \"\"\"\n1270     Mixin for AttributeDocumenter to provide the\n1271     feature of stripping any function signature from the docstring.\n1272     \"\"\"\n1273     def format_signature(self, **kwargs: Any) -> str:\n1274         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1275             # only act if a signature is not explicitly given already, and if\n1276             # the feature is enabled\n1277             result = self._find_signature()\n1278             if result is not None:\n1279                 # Discarding _args is a only difference with\n1280                 # DocstringSignatureMixin.format_signature.\n1281                 # Documenter.format_signature use self.args value to format.\n1282                 _args, self.retann = result\n1283         return super().format_signature(**kwargs)\n1284 \n1285 \n1286 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1287     \"\"\"\n1288     Specialized Documenter subclass for functions.\n1289     \"\"\"\n1290     objtype = 'function'\n1291     member_order = 30\n1292 \n1293     @classmethod\n1294     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1295                             ) -> bool:\n1296         # supports functions, builtins and bound methods exported at the module level\n1297         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1298                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1299 \n1300     def format_args(self, **kwargs: Any) -> str:\n1301         if self.config.autodoc_typehints in ('none', 'description'):\n1302             kwargs.setdefault('show_annotation', False)\n1303 \n1304         try:\n1305             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1306             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n1307             args = stringify_signature(sig, **kwargs)\n1308         except TypeError as exc:\n1309             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1310                            self.fullname, exc)\n1311             return None\n1312         except ValueError:\n1313             args = ''\n1314 \n1315         if self.config.strip_signature_backslash:\n1316             # escape backslashes for reST\n1317             args = args.replace('\\\\', '\\\\\\\\')\n1318         return args\n1319 \n1320     def document_members(self, all_members: bool = False) -> None:\n1321         pass\n1322 \n1323     def add_directive_header(self, sig: str) -> None:\n1324         sourcename = self.get_sourcename()\n1325         super().add_directive_header(sig)\n1326 \n1327         if inspect.iscoroutinefunction(self.object):\n1328             self.add_line('   :async:', sourcename)\n1329 \n1330     def format_signature(self, **kwargs: Any) -> str:\n1331         sigs = []\n1332         if (self.analyzer and\n1333                 '.'.join(self.objpath) in self.analyzer.overloads and\n1334                 self.config.autodoc_typehints == 'signature'):\n1335             # Use signatures for overloaded functions instead of the implementation function.\n1336             overloaded = True\n1337         else:\n1338             overloaded = False\n1339             sig = super().format_signature(**kwargs)\n1340             sigs.append(sig)\n1341 \n1342         if inspect.is_singledispatch_function(self.object):\n1343             # append signature of singledispatch'ed functions\n1344             for typ, func in self.object.registry.items():\n1345                 if typ is object:\n1346                     pass  # default implementation. skipped.\n1347                 else:\n1348                     self.annotate_to_first_argument(func, typ)\n1349 \n1350                     documenter = FunctionDocumenter(self.directive, '')\n1351                     documenter.object = func\n1352                     documenter.objpath = [None]\n1353                     sigs.append(documenter.format_signature())\n1354         if overloaded:\n1355             actual = inspect.signature(self.object,\n1356                                        type_aliases=self.config.autodoc_type_aliases)\n1357             __globals__ = safe_getattr(self.object, '__globals__', {})\n1358             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1359                 overload = self.merge_default_value(actual, overload)\n1360                 overload = evaluate_signature(overload, __globals__,\n1361                                               self.config.autodoc_type_aliases)\n1362 \n1363                 sig = stringify_signature(overload, **kwargs)\n1364                 sigs.append(sig)\n1365 \n1366         return \"\\n\".join(sigs)\n1367 \n1368     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n1369         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n1370         parameters = list(overload.parameters.values())\n1371         for i, param in enumerate(parameters):\n1372             actual_param = actual.parameters.get(param.name)\n1373             if actual_param and param.default == '...':\n1374                 parameters[i] = param.replace(default=actual_param.default)\n1375 \n1376         return overload.replace(parameters=parameters)\n1377 \n1378     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1379         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1380         try:\n1381             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n1382         except TypeError as exc:\n1383             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1384                            self.fullname, exc)\n1385             return\n1386         except ValueError:\n1387             return\n1388 \n1389         if len(sig.parameters) == 0:\n1390             return\n1391 \n1392         params = list(sig.parameters.values())\n1393         if params[0].annotation is Parameter.empty:\n1394             params[0] = params[0].replace(annotation=typ)\n1395             try:\n1396                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1397             except TypeError:\n1398                 # failed to update signature (ex. built-in or extension types)\n1399                 return\n1400 \n1401 \n1402 class DecoratorDocumenter(FunctionDocumenter):\n1403     \"\"\"\n1404     Specialized Documenter subclass for decorator functions.\n1405     \"\"\"\n1406     objtype = 'decorator'\n1407 \n1408     # must be lower than FunctionDocumenter\n1409     priority = -1\n1410 \n1411     def format_args(self, **kwargs: Any) -> Any:\n1412         args = super().format_args(**kwargs)\n1413         if ',' in args:\n1414             return args\n1415         else:\n1416             return None\n1417 \n1418 \n1419 # Types which have confusing metaclass signatures it would be best not to show.\n1420 # These are listed by name, rather than storing the objects themselves, to avoid\n1421 # needing to import the modules.\n1422 _METACLASS_CALL_BLACKLIST = [\n1423     'enum.EnumMeta.__call__',\n1424 ]\n1425 \n1426 \n1427 # Types whose __new__ signature is a pass-thru.\n1428 _CLASS_NEW_BLACKLIST = [\n1429     'typing.Generic.__new__',\n1430 ]\n1431 \n1432 \n1433 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1434     \"\"\"\n1435     Specialized Documenter subclass for classes.\n1436     \"\"\"\n1437     objtype = 'class'\n1438     member_order = 20\n1439     option_spec = {\n1440         'members': members_option, 'undoc-members': bool_option,\n1441         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1442         'show-inheritance': bool_option, 'member-order': member_order_option,\n1443         'exclude-members': exclude_members_option,\n1444         'private-members': members_option, 'special-members': members_option,\n1445     }  # type: Dict[str, Callable]\n1446 \n1447     _signature_class = None  # type: Any\n1448     _signature_method_name = None  # type: str\n1449 \n1450     def __init__(self, *args: Any) -> None:\n1451         super().__init__(*args)\n1452         merge_members_option(self.options)\n1453 \n1454     @classmethod\n1455     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1456                             ) -> bool:\n1457         return isinstance(member, type)\n1458 \n1459     def import_object(self, raiseerror: bool = False) -> bool:\n1460         ret = super().import_object(raiseerror)\n1461         # if the class is documented under another name, document it\n1462         # as data/attribute\n1463         if ret:\n1464             if hasattr(self.object, '__name__'):\n1465                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1466             else:\n1467                 self.doc_as_attr = True\n1468         return ret\n1469 \n1470     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1471         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1472             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1473             if inspect.is_builtin_class_method(obj, attr):\n1474                 return None\n1475             attr = self.get_attr(obj, attr, None)\n1476             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1477                 return None\n1478             return attr\n1479 \n1480         # This sequence is copied from inspect._signature_from_callable.\n1481         # ValueError means that no signature could be found, so we keep going.\n1482 \n1483         # First, we check the obj has a __signature__ attribute\n1484         if (hasattr(self.object, '__signature__') and\n1485                 isinstance(self.object.__signature__, Signature)):\n1486             return None, None, self.object.__signature__\n1487 \n1488         # Next, let's see if it has an overloaded __call__ defined\n1489         # in its metaclass\n1490         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1491 \n1492         if call is not None:\n1493             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1494                 call = None\n1495 \n1496         if call is not None:\n1497             self.env.app.emit('autodoc-before-process-signature', call, True)\n1498             try:\n1499                 sig = inspect.signature(call, bound_method=True,\n1500                                         type_aliases=self.config.autodoc_type_aliases)\n1501                 return type(self.object), '__call__', sig\n1502             except ValueError:\n1503                 pass\n1504 \n1505         # Now we check if the 'obj' class has a '__new__' method\n1506         new = get_user_defined_function_or_method(self.object, '__new__')\n1507 \n1508         if new is not None:\n1509             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1510                 new = None\n1511 \n1512         if new is not None:\n1513             self.env.app.emit('autodoc-before-process-signature', new, True)\n1514             try:\n1515                 sig = inspect.signature(new, bound_method=True,\n1516                                         type_aliases=self.config.autodoc_type_aliases)\n1517                 return self.object, '__new__', sig\n1518             except ValueError:\n1519                 pass\n1520 \n1521         # Finally, we should have at least __init__ implemented\n1522         init = get_user_defined_function_or_method(self.object, '__init__')\n1523         if init is not None:\n1524             self.env.app.emit('autodoc-before-process-signature', init, True)\n1525             try:\n1526                 sig = inspect.signature(init, bound_method=True,\n1527                                         type_aliases=self.config.autodoc_type_aliases)\n1528                 return self.object, '__init__', sig\n1529             except ValueError:\n1530                 pass\n1531 \n1532         # None of the attributes are user-defined, so fall back to let inspect\n1533         # handle it.\n1534         # We don't know the exact method that inspect.signature will read\n1535         # the signature from, so just pass the object itself to our hook.\n1536         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1537         try:\n1538             sig = inspect.signature(self.object, bound_method=False,\n1539                                     type_aliases=self.config.autodoc_type_aliases)\n1540             return None, None, sig\n1541         except ValueError:\n1542             pass\n1543 \n1544         # Still no signature: happens e.g. for old-style classes\n1545         # with __init__ in C and no `__text_signature__`.\n1546         return None, None, None\n1547 \n1548     def format_args(self, **kwargs: Any) -> str:\n1549         if self.config.autodoc_typehints in ('none', 'description'):\n1550             kwargs.setdefault('show_annotation', False)\n1551 \n1552         try:\n1553             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1554         except TypeError as exc:\n1555             # __signature__ attribute contained junk\n1556             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1557                            self.fullname, exc)\n1558             return None\n1559 \n1560         if sig is None:\n1561             return None\n1562 \n1563         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1564 \n1565     def format_signature(self, **kwargs: Any) -> str:\n1566         if self.doc_as_attr:\n1567             return ''\n1568 \n1569         sig = super().format_signature()\n1570         sigs = []\n1571 \n1572         overloads = self.get_overloaded_signatures()\n1573         if overloads and self.config.autodoc_typehints == 'signature':\n1574             # Use signatures for overloaded methods instead of the implementation method.\n1575             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1576             __globals__ = safe_getattr(method, '__globals__', {})\n1577             for overload in overloads:\n1578                 overload = evaluate_signature(overload, __globals__,\n1579                                               self.config.autodoc_type_aliases)\n1580 \n1581                 parameters = list(overload.parameters.values())\n1582                 overload = overload.replace(parameters=parameters[1:],\n1583                                             return_annotation=Parameter.empty)\n1584                 sig = stringify_signature(overload, **kwargs)\n1585                 sigs.append(sig)\n1586         else:\n1587             sigs.append(sig)\n1588 \n1589         return \"\\n\".join(sigs)\n1590 \n1591     def get_overloaded_signatures(self) -> List[Signature]:\n1592         if self._signature_class and self._signature_method_name:\n1593             for cls in self._signature_class.__mro__:\n1594                 try:\n1595                     analyzer = ModuleAnalyzer.for_module(cls.__module__)\n1596                     analyzer.analyze()\n1597                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n1598                     if qualname in analyzer.overloads:\n1599                         return analyzer.overloads.get(qualname)\n1600                     elif qualname in analyzer.tagorder:\n1601                         # the constructor is defined in the class, but not overrided.\n1602                         return []\n1603                 except PycodeError:\n1604                     pass\n1605 \n1606         return []\n1607 \n1608     def add_directive_header(self, sig: str) -> None:\n1609         sourcename = self.get_sourcename()\n1610 \n1611         if self.doc_as_attr:\n1612             self.directivetype = 'attribute'\n1613         super().add_directive_header(sig)\n1614 \n1615         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1616             self.add_line('   :final:', sourcename)\n1617 \n1618         # add inheritance info, if wanted\n1619         if not self.doc_as_attr and self.options.show_inheritance:\n1620             sourcename = self.get_sourcename()\n1621             self.add_line('', sourcename)\n1622 \n1623             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n1624                 # A subclass of generic types\n1625                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n1626                 bases = [restify(cls) for cls in self.object.__orig_bases__]\n1627                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1628             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1629                 # A normal class\n1630                 bases = [restify(cls) for cls in self.object.__bases__]\n1631                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1632 \n1633     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1634         members = get_class_members(self.object, self.objpath, self.get_attr)\n1635         if not want_all:\n1636             if not self.options.members:\n1637                 return False, []  # type: ignore\n1638             # specific members given\n1639             selected = []\n1640             for name in self.options.members:  # type: str\n1641                 if name in members:\n1642                     selected.append(members[name])\n1643                 else:\n1644                     logger.warning(__('missing attribute %s in object %s') %\n1645                                    (name, self.fullname), type='autodoc')\n1646             return False, selected\n1647         elif self.options.inherited_members:\n1648             return False, list(members.values())\n1649         else:\n1650             return False, [m for m in members.values() if m.class_ == self.object]\n1651 \n1652     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1653         if encoding is not None:\n1654             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1655                           % self.__class__.__name__,\n1656                           RemovedInSphinx40Warning, stacklevel=2)\n1657         if self.doc_as_attr:\n1658             # Don't show the docstring of the class when it is an alias.\n1659             return None\n1660 \n1661         lines = getattr(self, '_new_docstrings', None)\n1662         if lines is not None:\n1663             return lines\n1664 \n1665         content = self.config.autoclass_content\n1666 \n1667         docstrings = []\n1668         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1669         if attrdocstring:\n1670             docstrings.append(attrdocstring)\n1671 \n1672         # for classes, what the \"docstring\" is can be controlled via a\n1673         # config value; the default is only the class docstring\n1674         if content in ('both', 'init'):\n1675             __init__ = self.get_attr(self.object, '__init__', None)\n1676             initdocstring = getdoc(__init__, self.get_attr,\n1677                                    self.config.autodoc_inherit_docstrings,\n1678                                    self.parent, self.object_name)\n1679             # for new-style classes, no __init__ means default __init__\n1680             if (initdocstring is not None and\n1681                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1682                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1683                 initdocstring = None\n1684             if not initdocstring:\n1685                 # try __new__\n1686                 __new__ = self.get_attr(self.object, '__new__', None)\n1687                 initdocstring = getdoc(__new__, self.get_attr,\n1688                                        self.config.autodoc_inherit_docstrings,\n1689                                        self.parent, self.object_name)\n1690                 # for new-style classes, no __new__ means default __new__\n1691                 if (initdocstring is not None and\n1692                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1693                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1694                     initdocstring = None\n1695             if initdocstring:\n1696                 if content == 'init':\n1697                     docstrings = [initdocstring]\n1698                 else:\n1699                     docstrings.append(initdocstring)\n1700 \n1701         tab_width = self.directive.state.document.settings.tab_width\n1702         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1703 \n1704     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1705                     ) -> None:\n1706         if self.doc_as_attr:\n1707             try:\n1708                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n1709             except AttributeError:\n1710                 pass  # Invalid class object is passed.\n1711 \n1712         super().add_content(more_content)\n1713 \n1714     def document_members(self, all_members: bool = False) -> None:\n1715         if self.doc_as_attr:\n1716             return\n1717         super().document_members(all_members)\n1718 \n1719     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n1720                  check_module: bool = False, all_members: bool = False) -> None:\n1721         # Do not pass real_modname and use the name from the __module__\n1722         # attribute of the class.\n1723         # If a class gets imported into the module real_modname\n1724         # the analyzer won't find the source of the class, if\n1725         # it looks in real_modname.\n1726         return super().generate(more_content=more_content,\n1727                                 check_module=check_module,\n1728                                 all_members=all_members)\n1729 \n1730 \n1731 class ExceptionDocumenter(ClassDocumenter):\n1732     \"\"\"\n1733     Specialized ClassDocumenter subclass for exceptions.\n1734     \"\"\"\n1735     objtype = 'exception'\n1736     member_order = 10\n1737 \n1738     # needs a higher priority than ClassDocumenter\n1739     priority = 10\n1740 \n1741     @classmethod\n1742     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1743                             ) -> bool:\n1744         return isinstance(member, type) and issubclass(member, BaseException)\n1745 \n1746 \n1747 class DataDocumenterMixinBase:\n1748     # define types of instance variables\n1749     config = None  # type: Config\n1750     env = None  # type: BuildEnvironment\n1751     modname = None  # type: str\n1752     parent = None  # type: Any\n1753     object = None  # type: Any\n1754     objpath = None  # type: List[str]\n1755 \n1756     def should_suppress_directive_header(self) -> bool:\n1757         \"\"\"Check directive header should be suppressed.\"\"\"\n1758         return False\n1759 \n1760     def should_suppress_value_header(self) -> bool:\n1761         \"\"\"Check :value: header should be suppressed.\"\"\"\n1762         return False\n1763 \n1764     def update_content(self, more_content: StringList) -> None:\n1765         \"\"\"Update docstring for the NewType object.\"\"\"\n1766         pass\n1767 \n1768 \n1769 class GenericAliasMixin(DataDocumenterMixinBase):\n1770     \"\"\"\n1771     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1772     supporting GenericAliases.\n1773     \"\"\"\n1774 \n1775     def should_suppress_directive_header(self) -> bool:\n1776         return (inspect.isgenericalias(self.object) or\n1777                 super().should_suppress_directive_header())\n1778 \n1779     def update_content(self, more_content: StringList) -> None:\n1780         if inspect.isgenericalias(self.object):\n1781             alias = stringify_typehint(self.object)\n1782             more_content.append(_('alias of %s') % alias, '')\n1783             more_content.append('', '')\n1784 \n1785         super().update_content(more_content)\n1786 \n1787 \n1788 class NewTypeMixin(DataDocumenterMixinBase):\n1789     \"\"\"\n1790     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1791     supporting NewTypes.\n1792     \"\"\"\n1793 \n1794     def should_suppress_directive_header(self) -> bool:\n1795         return (inspect.isNewType(self.object) or\n1796                 super().should_suppress_directive_header())\n1797 \n1798     def update_content(self, more_content: StringList) -> None:\n1799         if inspect.isNewType(self.object):\n1800             supertype = restify(self.object.__supertype__)\n1801             more_content.append(_('alias of %s') % supertype, '')\n1802             more_content.append('', '')\n1803 \n1804         super().update_content(more_content)\n1805 \n1806 \n1807 class TypeVarMixin(DataDocumenterMixinBase):\n1808     \"\"\"\n1809     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1810     supporting TypeVars.\n1811     \"\"\"\n1812 \n1813     def should_suppress_directive_header(self) -> bool:\n1814         return (isinstance(self.object, TypeVar) or\n1815                 super().should_suppress_directive_header())\n1816 \n1817     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1818         if ignore is not None:\n1819             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1820                           % self.__class__.__name__,\n1821                           RemovedInSphinx50Warning, stacklevel=2)\n1822 \n1823         if isinstance(self.object, TypeVar):\n1824             if self.object.__doc__ != TypeVar.__doc__:\n1825                 return super().get_doc()  # type: ignore\n1826             else:\n1827                 return []\n1828         else:\n1829             return super().get_doc()  # type: ignore\n1830 \n1831     def update_content(self, more_content: StringList) -> None:\n1832         if isinstance(self.object, TypeVar):\n1833             attrs = [repr(self.object.__name__)]\n1834             for constraint in self.object.__constraints__:\n1835                 attrs.append(stringify_typehint(constraint))\n1836             if self.object.__covariant__:\n1837                 attrs.append(\"covariant=True\")\n1838             if self.object.__contravariant__:\n1839                 attrs.append(\"contravariant=True\")\n1840 \n1841             more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n1842             more_content.append('', '')\n1843 \n1844         super().update_content(more_content)\n1845 \n1846 \n1847 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\n1848     \"\"\"\n1849     Mixin for DataDocumenter to provide the feature for supporting uninitialized\n1850     (type annotation only) global variables.\n1851     \"\"\"\n1852 \n1853     def import_object(self, raiseerror: bool = False) -> bool:\n1854         try:\n1855             return super().import_object(raiseerror=True)  # type: ignore\n1856         except ImportError as exc:\n1857             # annotation only instance variable (PEP-526)\n1858             try:\n1859                 with mock(self.config.autodoc_mock_imports):\n1860                     parent = import_module(self.modname, self.config.autodoc_warningiserror)\n1861                     annotations = get_type_hints(parent, None,\n1862                                                  self.config.autodoc_type_aliases)\n1863                     if self.objpath[-1] in annotations:\n1864                         self.object = UNINITIALIZED_ATTR\n1865                         self.parent = parent\n1866                         return True\n1867             except ImportError:\n1868                 pass\n1869 \n1870             if raiseerror:\n1871                 raise\n1872             else:\n1873                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1874                 self.env.note_reread()\n1875                 return False\n1876 \n1877     def should_suppress_value_header(self) -> bool:\n1878         return (self.object is UNINITIALIZED_ATTR or\n1879                 super().should_suppress_value_header())\n1880 \n1881     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1882         if self.object is UNINITIALIZED_ATTR:\n1883             return []\n1884         else:\n1885             return super().get_doc(encoding, ignore)  # type: ignore\n1886 \n1887 \n1888 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n1889                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n1890     \"\"\"\n1891     Specialized Documenter subclass for data items.\n1892     \"\"\"\n1893     objtype = 'data'\n1894     member_order = 40\n1895     priority = -10\n1896     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1897     option_spec[\"annotation\"] = annotation_option\n1898     option_spec[\"no-value\"] = bool_option\n1899 \n1900     @classmethod\n1901     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1902                             ) -> bool:\n1903         return isinstance(parent, ModuleDocumenter) and isattr\n1904 \n1905     def update_annotations(self, parent: Any) -> None:\n1906         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n1907         annotations = dict(inspect.getannotations(parent))\n1908         parent.__annotations__ = annotations\n1909 \n1910         try:\n1911             analyzer = ModuleAnalyzer.for_module(self.modname)\n1912             analyzer.analyze()\n1913             for (classname, attrname), annotation in analyzer.annotations.items():\n1914                 if classname == '' and attrname not in annotations:\n1915                     annotations[attrname] = annotation\n1916         except PycodeError:\n1917             pass\n1918 \n1919     def import_object(self, raiseerror: bool = False) -> bool:\n1920         ret = super().import_object(raiseerror)\n1921         if self.parent:\n1922             self.update_annotations(self.parent)\n1923 \n1924         return ret\n1925 \n1926     def should_suppress_value_header(self) -> bool:\n1927         if super().should_suppress_value_header():\n1928             return True\n1929         else:\n1930             doc = self.get_doc()\n1931             metadata = extract_metadata('\\n'.join(sum(doc, [])))\n1932             if 'hide-value' in metadata:\n1933                 return True\n1934 \n1935         return False\n1936 \n1937     def add_directive_header(self, sig: str) -> None:\n1938         super().add_directive_header(sig)\n1939         sourcename = self.get_sourcename()\n1940         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n1941             pass\n1942         elif self.options.annotation:\n1943             self.add_line('   :annotation: %s' % self.options.annotation,\n1944                           sourcename)\n1945         else:\n1946             # obtain annotation for this data\n1947             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n1948             if self.objpath[-1] in annotations:\n1949                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1950                 self.add_line('   :type: ' + objrepr, sourcename)\n1951 \n1952             try:\n1953                 if self.options.no_value or self.should_suppress_value_header():\n1954                     pass\n1955                 else:\n1956                     objrepr = object_description(self.object)\n1957                     self.add_line('   :value: ' + objrepr, sourcename)\n1958             except ValueError:\n1959                 pass\n1960 \n1961     def document_members(self, all_members: bool = False) -> None:\n1962         pass\n1963 \n1964     def get_real_modname(self) -> str:\n1965         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1966             or self.modname\n1967 \n1968     def get_module_comment(self, attrname: str) -> Optional[List[str]]:\n1969         try:\n1970             analyzer = ModuleAnalyzer.for_module(self.modname)\n1971             analyzer.analyze()\n1972             key = ('', attrname)\n1973             if key in analyzer.attr_docs:\n1974                 return list(analyzer.attr_docs[key])\n1975         except PycodeError:\n1976             pass\n1977 \n1978         return None\n1979 \n1980     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1981         # Check the variable has a docstring-comment\n1982         comment = self.get_module_comment(self.objpath[-1])\n1983         if comment:\n1984             return [comment]\n1985         else:\n1986             return super().get_doc(encoding, ignore)\n1987 \n1988     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1989                     ) -> None:\n1990         # Disable analyzing variable comment on Documenter.add_content() to control it on\n1991         # DataDocumenter.add_content()\n1992         self.analyzer = None\n1993 \n1994         if not more_content:\n1995             more_content = StringList()\n1996 \n1997         self.update_content(more_content)\n1998         super().add_content(more_content, no_docstring=no_docstring)\n1999 \n2000 \n2001 class NewTypeDataDocumenter(DataDocumenter):\n2002     \"\"\"\n2003     Specialized Documenter subclass for NewTypes.\n2004 \n2005     Note: This must be invoked before FunctionDocumenter because NewType is a kind of\n2006     function object.\n2007     \"\"\"\n2008 \n2009     objtype = 'newtypedata'\n2010     directivetype = 'data'\n2011     priority = FunctionDocumenter.priority + 1\n2012 \n2013     @classmethod\n2014     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2015                             ) -> bool:\n2016         return inspect.isNewType(member) and isattr\n2017 \n2018 \n2019 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2020     \"\"\"\n2021     Specialized Documenter subclass for methods (normal, static and class).\n2022     \"\"\"\n2023     objtype = 'method'\n2024     directivetype = 'method'\n2025     member_order = 50\n2026     priority = 1  # must be more than FunctionDocumenter\n2027 \n2028     @classmethod\n2029     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2030                             ) -> bool:\n2031         return inspect.isroutine(member) and \\\n2032             not isinstance(parent, ModuleDocumenter)\n2033 \n2034     def import_object(self, raiseerror: bool = False) -> bool:\n2035         ret = super().import_object(raiseerror)\n2036         if not ret:\n2037             return ret\n2038 \n2039         # to distinguish classmethod/staticmethod\n2040         obj = self.parent.__dict__.get(self.object_name)\n2041         if obj is None:\n2042             obj = self.object\n2043 \n2044         if (inspect.isclassmethod(obj) or\n2045                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n2046             # document class and static members before ordinary ones\n2047             self.member_order = self.member_order - 1\n2048 \n2049         return ret\n2050 \n2051     def format_args(self, **kwargs: Any) -> str:\n2052         if self.config.autodoc_typehints in ('none', 'description'):\n2053             kwargs.setdefault('show_annotation', False)\n2054 \n2055         try:\n2056             if self.object == object.__init__ and self.parent != object:\n2057                 # Classes not having own __init__() method are shown as no arguments.\n2058                 #\n2059                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n2060                 #       But it makes users confused.\n2061                 args = '()'\n2062             else:\n2063                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2064                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n2065                     sig = inspect.signature(self.object, bound_method=False,\n2066                                             type_aliases=self.config.autodoc_type_aliases)\n2067                 else:\n2068                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n2069                     sig = inspect.signature(self.object, bound_method=True,\n2070                                             type_aliases=self.config.autodoc_type_aliases)\n2071                 args = stringify_signature(sig, **kwargs)\n2072         except TypeError as exc:\n2073             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2074                            self.fullname, exc)\n2075             return None\n2076         except ValueError:\n2077             args = ''\n2078 \n2079         if self.config.strip_signature_backslash:\n2080             # escape backslashes for reST\n2081             args = args.replace('\\\\', '\\\\\\\\')\n2082         return args\n2083 \n2084     def add_directive_header(self, sig: str) -> None:\n2085         super().add_directive_header(sig)\n2086 \n2087         sourcename = self.get_sourcename()\n2088         obj = self.parent.__dict__.get(self.object_name, self.object)\n2089         if inspect.isabstractmethod(obj):\n2090             self.add_line('   :abstractmethod:', sourcename)\n2091         if inspect.iscoroutinefunction(obj):\n2092             self.add_line('   :async:', sourcename)\n2093         if inspect.isclassmethod(obj):\n2094             self.add_line('   :classmethod:', sourcename)\n2095         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n2096             self.add_line('   :staticmethod:', sourcename)\n2097         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n2098             self.add_line('   :final:', sourcename)\n2099 \n2100     def document_members(self, all_members: bool = False) -> None:\n2101         pass\n2102 \n2103     def format_signature(self, **kwargs: Any) -> str:\n2104         sigs = []\n2105         if (self.analyzer and\n2106                 '.'.join(self.objpath) in self.analyzer.overloads and\n2107                 self.config.autodoc_typehints == 'signature'):\n2108             # Use signatures for overloaded methods instead of the implementation method.\n2109             overloaded = True\n2110         else:\n2111             overloaded = False\n2112             sig = super().format_signature(**kwargs)\n2113             sigs.append(sig)\n2114 \n2115         meth = self.parent.__dict__.get(self.objpath[-1])\n2116         if inspect.is_singledispatch_method(meth):\n2117             # append signature of singledispatch'ed functions\n2118             for typ, func in meth.dispatcher.registry.items():\n2119                 if typ is object:\n2120                     pass  # default implementation. skipped.\n2121                 else:\n2122                     self.annotate_to_first_argument(func, typ)\n2123 \n2124                     documenter = MethodDocumenter(self.directive, '')\n2125                     documenter.parent = self.parent\n2126                     documenter.object = func\n2127                     documenter.objpath = [None]\n2128                     sigs.append(documenter.format_signature())\n2129         if overloaded:\n2130             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2131                 actual = inspect.signature(self.object, bound_method=False,\n2132                                            type_aliases=self.config.autodoc_type_aliases)\n2133             else:\n2134                 actual = inspect.signature(self.object, bound_method=True,\n2135                                            type_aliases=self.config.autodoc_type_aliases)\n2136 \n2137             __globals__ = safe_getattr(self.object, '__globals__', {})\n2138             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n2139                 overload = self.merge_default_value(actual, overload)\n2140                 overload = evaluate_signature(overload, __globals__,\n2141                                               self.config.autodoc_type_aliases)\n2142 \n2143                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n2144                                               name=self.object_name):\n2145                     parameters = list(overload.parameters.values())\n2146                     overload = overload.replace(parameters=parameters[1:])\n2147                 sig = stringify_signature(overload, **kwargs)\n2148                 sigs.append(sig)\n2149 \n2150         return \"\\n\".join(sigs)\n2151 \n2152     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n2153         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n2154         parameters = list(overload.parameters.values())\n2155         for i, param in enumerate(parameters):\n2156             actual_param = actual.parameters.get(param.name)\n2157             if actual_param and param.default == '...':\n2158                 parameters[i] = param.replace(default=actual_param.default)\n2159 \n2160         return overload.replace(parameters=parameters)\n2161 \n2162     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n2163         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n2164         try:\n2165             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n2166         except TypeError as exc:\n2167             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2168                            self.fullname, exc)\n2169             return\n2170         except ValueError:\n2171             return\n2172         if len(sig.parameters) == 1:\n2173             return\n2174 \n2175         params = list(sig.parameters.values())\n2176         if params[1].annotation is Parameter.empty:\n2177             params[1] = params[1].replace(annotation=typ)\n2178             try:\n2179                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n2180             except TypeError:\n2181                 # failed to update signature (ex. built-in or extension types)\n2182                 return\n2183 \n2184 \n2185 class NonDataDescriptorMixin(DataDocumenterMixinBase):\n2186     \"\"\"\n2187     Mixin for AttributeDocumenter to provide the feature for supporting non\n2188     data-descriptors.\n2189 \n2190     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring\n2191               and :value: header will be suppressed unexpectedly.\n2192     \"\"\"\n2193 \n2194     def import_object(self, raiseerror: bool = False) -> bool:\n2195         ret = super().import_object(raiseerror)  # type: ignore\n2196         if ret and not inspect.isattributedescriptor(self.object):\n2197             self.non_data_descriptor = True\n2198         else:\n2199             self.non_data_descriptor = False\n2200 \n2201         return ret\n2202 \n2203     def should_suppress_value_header(self) -> bool:\n2204         return (not getattr(self, 'non_data_descriptor', False) or\n2205                 super().should_suppress_directive_header())\n2206 \n2207     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2208         if getattr(self, 'non_data_descriptor', False):\n2209             # the docstring of non datadescriptor is very probably the wrong thing\n2210             # to display\n2211             return None\n2212         else:\n2213             return super().get_doc(encoding, ignore)  # type: ignore\n2214 \n2215 \n2216 class SlotsMixin(DataDocumenterMixinBase):\n2217     \"\"\"\n2218     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.\n2219     \"\"\"\n2220 \n2221     def isslotsattribute(self) -> bool:\n2222         \"\"\"Check the subject is an attribute in __slots__.\"\"\"\n2223         try:\n2224             __slots__ = inspect.getslots(self.parent)\n2225             if __slots__ and self.objpath[-1] in __slots__:\n2226                 return True\n2227             else:\n2228                 return False\n2229         except (ValueError, TypeError):\n2230             return False\n2231 \n2232     def import_object(self, raiseerror: bool = False) -> bool:\n2233         ret = super().import_object(raiseerror)  # type: ignore\n2234         if self.isslotsattribute():\n2235             self.object = SLOTSATTR\n2236 \n2237         return ret\n2238 \n2239     def should_suppress_directive_header(self) -> bool:\n2240         if self.object is SLOTSATTR:\n2241             self._datadescriptor = True\n2242             return True\n2243         else:\n2244             return super().should_suppress_directive_header()\n2245 \n2246     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2247         if self.object is SLOTSATTR:\n2248             try:\n2249                 __slots__ = inspect.getslots(self.parent)\n2250                 if __slots__ and __slots__.get(self.objpath[-1]):\n2251                     docstring = prepare_docstring(__slots__[self.objpath[-1]])\n2252                     return [docstring]\n2253                 else:\n2254                     return []\n2255             except ValueError as exc:\n2256                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),\n2257                                (self.parent.__qualname__, exc), type='autodoc')\n2258                 return []\n2259         else:\n2260             return super().get_doc(encoding, ignore)  # type: ignore\n2261 \n2262 \n2263 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\n2264     \"\"\"\n2265     Mixin for AttributeDocumenter to provide the feature for supporting runtime\n2266     instance attributes (that are defined in __init__() methods with doc-comments).\n2267 \n2268     Example:\n2269 \n2270         class Foo:\n2271             def __init__(self):\n2272                 self.attr = None  #: This is a target of this mix-in.\n2273     \"\"\"\n2274 \n2275     RUNTIME_INSTANCE_ATTRIBUTE = object()\n2276 \n2277     def is_runtime_instance_attribute(self, parent: Any) -> bool:\n2278         \"\"\"Check the subject is an attribute defined in __init__().\"\"\"\n2279         # An instance variable defined in __init__().\n2280         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore\n2281             return True\n2282         else:\n2283             return False\n2284 \n2285     def import_object(self, raiseerror: bool = False) -> bool:\n2286         \"\"\"Check the existence of runtime instance attribute when failed to import the\n2287         attribute.\"\"\"\n2288         try:\n2289             return super().import_object(raiseerror=True)  # type: ignore\n2290         except ImportError as exc:\n2291             try:\n2292                 with mock(self.config.autodoc_mock_imports):\n2293                     ret = import_object(self.modname, self.objpath[:-1], 'class',\n2294                                         attrgetter=self.get_attr,  # type: ignore\n2295                                         warningiserror=self.config.autodoc_warningiserror)\n2296                     parent = ret[3]\n2297                     if self.is_runtime_instance_attribute(parent):\n2298                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE\n2299                         self.parent = parent\n2300                         return True\n2301             except ImportError:\n2302                 pass\n2303 \n2304             if raiseerror:\n2305                 raise\n2306             else:\n2307                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2308                 self.env.note_reread()\n2309                 return False\n2310 \n2311     def should_suppress_value_header(self) -> bool:\n2312         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or\n2313                 super().should_suppress_value_header())\n2314 \n2315 \n2316 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\n2317     \"\"\"\n2318     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized\n2319     instance attributes (PEP-526 styled, annotation only attributes).\n2320 \n2321     Example:\n2322 \n2323         class Foo:\n2324             attr: int  #: This is a target of this mix-in.\n2325     \"\"\"\n2326 \n2327     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:\n2328         \"\"\"Check the subject is an annotation only attribute.\"\"\"\n2329         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)\n2330         if self.objpath[-1] in annotations:\n2331             return True\n2332         else:\n2333             return False\n2334 \n2335     def import_object(self, raiseerror: bool = False) -> bool:\n2336         \"\"\"Check the exisitence of uninitialized instance attribute when failed to import\n2337         the attribute.\"\"\"\n2338         try:\n2339             return super().import_object(raiseerror=True)  # type: ignore\n2340         except ImportError as exc:\n2341             try:\n2342                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2343                                     attrgetter=self.get_attr,  # type: ignore\n2344                                     warningiserror=self.config.autodoc_warningiserror)\n2345                 parent = ret[3]\n2346                 if self.is_uninitialized_instance_attribute(parent):\n2347                     self.object = UNINITIALIZED_ATTR\n2348                     self.parent = parent\n2349                     return True\n2350             except ImportError:\n2351                 pass\n2352 \n2353             if raiseerror:\n2354                 raise\n2355             else:\n2356                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2357                 self.env.note_reread()\n2358                 return False\n2359 \n2360     def should_suppress_value_header(self) -> bool:\n2361         return (self.object is UNINITIALIZED_ATTR or\n2362                 super().should_suppress_value_header())\n2363 \n2364     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2365         if self.object is UNINITIALIZED_ATTR:\n2366             return None\n2367         else:\n2368             return super().get_doc(encoding, ignore)  # type: ignore\n2369 \n2370 \n2371 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n2372                           TypeVarMixin, RuntimeInstanceAttributeMixin,\n2373                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n2374                           DocstringStripSignatureMixin, ClassLevelDocumenter):\n2375     \"\"\"\n2376     Specialized Documenter subclass for attributes.\n2377     \"\"\"\n2378     objtype = 'attribute'\n2379     member_order = 60\n2380     option_spec = dict(ModuleLevelDocumenter.option_spec)\n2381     option_spec[\"annotation\"] = annotation_option\n2382     option_spec[\"no-value\"] = bool_option\n2383 \n2384     # must be higher than the MethodDocumenter, else it will recognize\n2385     # some non-data descriptors as methods\n2386     priority = 10\n2387 \n2388     @staticmethod\n2389     def is_function_or_method(obj: Any) -> bool:\n2390         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n2391 \n2392     @classmethod\n2393     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2394                             ) -> bool:\n2395         if inspect.isattributedescriptor(member):\n2396             return True\n2397         elif (not isinstance(parent, ModuleDocumenter) and\n2398               not inspect.isroutine(member) and\n2399               not isinstance(member, type)):\n2400             return True\n2401         else:\n2402             return False\n2403 \n2404     def document_members(self, all_members: bool = False) -> None:\n2405         pass\n2406 \n2407     def isinstanceattribute(self) -> bool:\n2408         \"\"\"Check the subject is an instance attribute.\"\"\"\n2409         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n2410                       RemovedInSphinx50Warning)\n2411         # uninitialized instance variable (PEP-526)\n2412         with mock(self.config.autodoc_mock_imports):\n2413             try:\n2414                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2415                                     attrgetter=self.get_attr,\n2416                                     warningiserror=self.config.autodoc_warningiserror)\n2417                 self.parent = ret[3]\n2418                 annotations = get_type_hints(self.parent, None,\n2419                                              self.config.autodoc_type_aliases)\n2420                 if self.objpath[-1] in annotations:\n2421                     self.object = UNINITIALIZED_ATTR\n2422                     return True\n2423             except ImportError:\n2424                 pass\n2425 \n2426         return False\n2427 \n2428     def update_annotations(self, parent: Any) -> None:\n2429         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n2430         try:\n2431             annotations = dict(inspect.getannotations(parent))\n2432             parent.__annotations__ = annotations\n2433 \n2434             for cls in inspect.getmro(parent):\n2435                 try:\n2436                     module = safe_getattr(cls, '__module__')\n2437                     qualname = safe_getattr(cls, '__qualname__')\n2438 \n2439                     analyzer = ModuleAnalyzer.for_module(module)\n2440                     analyzer.analyze()\n2441                     for (classname, attrname), annotation in analyzer.annotations.items():\n2442                         if classname == qualname and attrname not in annotations:\n2443                             annotations[attrname] = annotation\n2444                 except (AttributeError, PycodeError):\n2445                     pass\n2446         except TypeError:\n2447             # Failed to set __annotations__ (built-in, extensions, etc.)\n2448             pass\n2449 \n2450     def import_object(self, raiseerror: bool = False) -> bool:\n2451         ret = super().import_object(raiseerror)\n2452         if inspect.isenumattribute(self.object):\n2453             self.object = self.object.value\n2454         if self.parent:\n2455             self.update_annotations(self.parent)\n2456 \n2457         return ret\n2458 \n2459     def get_real_modname(self) -> str:\n2460         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2461             or self.modname\n2462 \n2463     def should_suppress_value_header(self) -> bool:\n2464         if super().should_suppress_value_header():\n2465             return True\n2466         else:\n2467             doc = self.get_doc()\n2468             if doc:\n2469                 metadata = extract_metadata('\\n'.join(sum(doc, [])))\n2470                 if 'hide-value' in metadata:\n2471                     return True\n2472 \n2473         return False\n2474 \n2475     def add_directive_header(self, sig: str) -> None:\n2476         super().add_directive_header(sig)\n2477         sourcename = self.get_sourcename()\n2478         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n2479             pass\n2480         elif self.options.annotation:\n2481             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2482         else:\n2483             # obtain type annotation for this attribute\n2484             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n2485             if self.objpath[-1] in annotations:\n2486                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2487                 self.add_line('   :type: ' + objrepr, sourcename)\n2488 \n2489             try:\n2490                 if self.options.no_value or self.should_suppress_value_header():\n2491                     pass\n2492                 else:\n2493                     objrepr = object_description(self.object)\n2494                     self.add_line('   :value: ' + objrepr, sourcename)\n2495             except ValueError:\n2496                 pass\n2497 \n2498     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:\n2499         for cls in inspect.getmro(parent):\n2500             try:\n2501                 module = safe_getattr(cls, '__module__')\n2502                 qualname = safe_getattr(cls, '__qualname__')\n2503 \n2504                 analyzer = ModuleAnalyzer.for_module(module)\n2505                 analyzer.analyze()\n2506                 if qualname and self.objpath:\n2507                     key = (qualname, attrname)\n2508                     if key in analyzer.attr_docs:\n2509                         return list(analyzer.attr_docs[key])\n2510             except (AttributeError, PycodeError):\n2511                 pass\n2512 \n2513         return None\n2514 \n2515     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2516         # Check the attribute has a docstring-comment\n2517         comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n2518         if comment:\n2519             return [comment]\n2520 \n2521         try:\n2522             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2523             # a docstring from the value which descriptor returns unexpectedly.\n2524             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2525             orig = self.config.autodoc_inherit_docstrings\n2526             self.config.autodoc_inherit_docstrings = False  # type: ignore\n2527             return super().get_doc(encoding, ignore)\n2528         finally:\n2529             self.config.autodoc_inherit_docstrings = orig  # type: ignore\n2530 \n2531     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n2532                     ) -> None:\n2533         # Disable analyzing attribute comment on Documenter.add_content() to control it on\n2534         # AttributeDocumenter.add_content()\n2535         self.analyzer = None\n2536 \n2537         if more_content is None:\n2538             more_content = StringList()\n2539         self.update_content(more_content)\n2540         super().add_content(more_content, no_docstring)\n2541 \n2542 \n2543 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2544     \"\"\"\n2545     Specialized Documenter subclass for properties.\n2546     \"\"\"\n2547     objtype = 'property'\n2548     directivetype = 'method'\n2549     member_order = 60\n2550 \n2551     # before AttributeDocumenter\n2552     priority = AttributeDocumenter.priority + 1\n2553 \n2554     @classmethod\n2555     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2556                             ) -> bool:\n2557         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n2558 \n2559     def document_members(self, all_members: bool = False) -> None:\n2560         pass\n2561 \n2562     def get_real_modname(self) -> str:\n2563         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2564             or self.modname\n2565 \n2566     def add_directive_header(self, sig: str) -> None:\n2567         super().add_directive_header(sig)\n2568         sourcename = self.get_sourcename()\n2569         if inspect.isabstractmethod(self.object):\n2570             self.add_line('   :abstractmethod:', sourcename)\n2571         self.add_line('   :property:', sourcename)\n2572 \n2573 \n2574 class NewTypeAttributeDocumenter(AttributeDocumenter):\n2575     \"\"\"\n2576     Specialized Documenter subclass for NewTypes.\n2577 \n2578     Note: This must be invoked before MethodDocumenter because NewType is a kind of\n2579     function object.\n2580     \"\"\"\n2581 \n2582     objtype = 'newvarattribute'\n2583     directivetype = 'attribute'\n2584     priority = MethodDocumenter.priority + 1\n2585 \n2586     @classmethod\n2587     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2588                             ) -> bool:\n2589         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)\n2590 \n2591 \n2592 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n2593     \"\"\"Returns registered Documenter classes\"\"\"\n2594     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2595     return app.registry.documenters\n2596 \n2597 \n2598 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2599     \"\"\"Alternative getattr() for types\"\"\"\n2600     for typ, func in app.registry.autodoc_attrgettrs.items():\n2601         if isinstance(obj, typ):\n2602             return func(obj, name, *defargs)\n2603 \n2604     return safe_getattr(obj, name, *defargs)\n2605 \n2606 \n2607 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2608     if config.autodoc_member_order == 'alphabetic':\n2609         # RemovedInSphinx50Warning\n2610         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2611                           'instead of \"alphabetic\". Please update your setting.'))\n2612         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2613 \n2614 \n2615 # for compatibility\n2616 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2617 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2618 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2619 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2620 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2621 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2622 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2623 \n2624 \n2625 def setup(app: Sphinx) -> Dict[str, Any]:\n2626     app.add_autodocumenter(ModuleDocumenter)\n2627     app.add_autodocumenter(ClassDocumenter)\n2628     app.add_autodocumenter(ExceptionDocumenter)\n2629     app.add_autodocumenter(DataDocumenter)\n2630     app.add_autodocumenter(NewTypeDataDocumenter)\n2631     app.add_autodocumenter(FunctionDocumenter)\n2632     app.add_autodocumenter(DecoratorDocumenter)\n2633     app.add_autodocumenter(MethodDocumenter)\n2634     app.add_autodocumenter(AttributeDocumenter)\n2635     app.add_autodocumenter(PropertyDocumenter)\n2636     app.add_autodocumenter(NewTypeAttributeDocumenter)\n2637 \n2638     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2639     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2640                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2641     app.add_config_value('autodoc_default_options', {}, True)\n2642     app.add_config_value('autodoc_docstring_signature', True, True)\n2643     app.add_config_value('autodoc_mock_imports', [], True)\n2644     app.add_config_value('autodoc_typehints', \"signature\", True,\n2645                          ENUM(\"signature\", \"description\", \"none\"))\n2646     app.add_config_value('autodoc_type_aliases', {}, True)\n2647     app.add_config_value('autodoc_warningiserror', True, True)\n2648     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2649     app.add_event('autodoc-before-process-signature')\n2650     app.add_event('autodoc-process-docstring')\n2651     app.add_event('autodoc-process-signature')\n2652     app.add_event('autodoc-skip-member')\n2653 \n2654     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2655 \n2656     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2657     app.setup_extension('sphinx.ext.autodoc.typehints')\n2658 \n2659     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "This method should be adjusted or enhanced to ensure that inherited class attributes, which are annotated and have associated docstrings (either directly via #: docstring syntax or through a more explicit docstring declaration), are not treated as undocumented. The behavior should ensure that annotations on inherited attributes are considered part of the documentation process, correctly including them when :inherited-members: is used without requiring :undoc-members: to be specified. This would preserve existing functionality while ensuring that annotated only inherited members with docstrings are documented as expected."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/directive.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/ext/autodoc/directive.py",
        "start": 1,
        "end": 164,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc.directive\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n6     :license: BSD, see LICENSE for details.\n7 \"\"\"\n8 \n9 import warnings\n10 from typing import Any, Callable, Dict, List, Set\n11 \n12 from docutils import nodes\n13 from docutils.nodes import Element, Node\n14 from docutils.parsers.rst.states import RSTState, Struct\n15 from docutils.statemachine import StringList\n16 from docutils.utils import Reporter, assemble_option_dict\n17 \n18 from sphinx.config import Config\n19 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n20 from sphinx.environment import BuildEnvironment\n21 from sphinx.ext.autodoc import Documenter, Options\n22 from sphinx.util import logging\n23 from sphinx.util.docutils import SphinxDirective, switch_source_input\n24 from sphinx.util.nodes import nested_parse_with_titles\n25 \n26 if False:\n27     # For type annotation\n28     from typing import Type  # for python3.5.1\n29 \n30 \n31 logger = logging.getLogger(__name__)\n32 \n33 \n34 # common option names for autodoc directives\n35 AUTODOC_DEFAULT_OPTIONS = ['members', 'undoc-members', 'inherited-members',\n36                            'show-inheritance', 'private-members', 'special-members',\n37                            'ignore-module-all', 'exclude-members', 'member-order',\n38                            'imported-members']\n39 \n40 \n41 class DummyOptionSpec(dict):\n42     \"\"\"An option_spec allows any options.\"\"\"\n43 \n44     def __bool__(self) -> bool:\n45         \"\"\"Behaves like some options are defined.\"\"\"\n46         return True\n47 \n48     def __getitem__(self, key: str) -> Callable[[str], str]:\n49         return lambda x: x\n50 \n51 \n52 class DocumenterBridge:\n53     \"\"\"A parameters container for Documenters.\"\"\"\n54 \n55     def __init__(self, env: BuildEnvironment, reporter: Reporter, options: Options,\n56                  lineno: int, state: Any = None) -> None:\n57         self.env = env\n58         self._reporter = reporter\n59         self.genopt = options\n60         self.lineno = lineno\n61         self.filename_set = set()  # type: Set[str]\n62         self.result = StringList()\n63 \n64         if state:\n65             self.state = state\n66         else:\n67             # create fake object for self.state.document.settings.tab_width\n68             warnings.warn('DocumenterBridge requires a state object on instantiation.',\n69                           RemovedInSphinx40Warning, stacklevel=2)\n70             settings = Struct(tab_width=8)\n71             document = Struct(settings=settings)\n72             self.state = Struct(document=document)\n73 \n74     def warn(self, msg: str) -> None:\n75         logger.warning(msg, location=(self.env.docname, self.lineno))\n76 \n77     @property\n78     def reporter(self) -> Reporter:\n79         warnings.warn('DocumenterBridge.reporter is deprecated.',\n80                       RemovedInSphinx50Warning, stacklevel=2)\n81         return self._reporter\n82 \n83 \n84 def process_documenter_options(documenter: \"Type[Documenter]\", config: Config, options: Dict\n85                                ) -> Options:\n86     \"\"\"Recognize options of Documenter from user input.\"\"\"\n87     for name in AUTODOC_DEFAULT_OPTIONS:\n88         if name not in documenter.option_spec:\n89             continue\n90         else:\n91             negated = options.pop('no-' + name, True) is None\n92             if name in config.autodoc_default_options and not negated:\n93                 options[name] = config.autodoc_default_options[name]\n94 \n95     return Options(assemble_option_dict(options.items(), documenter.option_spec))\n96 \n97 \n98 def parse_generated_content(state: RSTState, content: StringList, documenter: Documenter\n99                             ) -> List[Node]:\n100     \"\"\"Parse a generated content by Documenter.\"\"\"\n101     with switch_source_input(state, content):\n102         if documenter.titles_allowed:\n103             node = nodes.section()  # type: Element\n104             # necessary so that the child nodes get the right source/line set\n105             node.document = state.document\n106             nested_parse_with_titles(state, content, node)\n107         else:\n108             node = nodes.paragraph()\n109             node.document = state.document\n110             state.nested_parse(content, 0, node)\n111 \n112         return node.children\n113 \n114 \n115 class AutodocDirective(SphinxDirective):\n116     \"\"\"A directive class for all autodoc directives. It works as a dispatcher of Documenters.\n117 \n118     It invokes a Documenter on running. After the processing, it parses and returns\n119     the generated content by Documenter.\n120     \"\"\"\n121     option_spec = DummyOptionSpec()\n122     has_content = True\n123     required_arguments = 1\n124     optional_arguments = 0\n125     final_argument_whitespace = True\n126 \n127     def run(self) -> List[Node]:\n128         reporter = self.state.document.reporter\n129 \n130         try:\n131             source, lineno = reporter.get_source_and_line(self.lineno)  # type: ignore\n132         except AttributeError:\n133             source, lineno = (None, None)\n134         logger.debug('[autodoc] %s:%s: input:\\n%s', source, lineno, self.block_text)\n135 \n136         # look up target Documenter\n137         objtype = self.name[4:]  # strip prefix (auto-).\n138         doccls = self.env.app.registry.documenters[objtype]\n139 \n140         # process the options with the selected documenter's option_spec\n141         try:\n142             documenter_options = process_documenter_options(doccls, self.config, self.options)\n143         except (KeyError, ValueError, TypeError) as exc:\n144             # an option is either unknown or has a wrong type\n145             logger.error('An option to %s is either unknown or has an invalid value: %s' %\n146                          (self.name, exc), location=(self.env.docname, lineno))\n147             return []\n148 \n149         # generate the output\n150         params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)\n151         documenter = doccls(params, self.arguments[0])\n152         documenter.generate(more_content=self.content)\n153         if not params.result:\n154             return []\n155 \n156         logger.debug('[autodoc] output:\\n%s', '\\n'.join(params.result))\n157 \n158         # record all filenames as dependencies -- this will at least\n159         # partially make automatic invalidation possible\n160         for fn in params.filename_set:\n161             self.state.document.settings.record_dependencies.add(fn)\n162 \n163         result = parse_generated_content(self.state, params.result, documenter)\n164         return result\n",
        "intended_behavior": "Enhancements here should focus on ensuring that the directive processing correctly interprets the presence of annotated, documented inherited members, including them as part of the output based on the presence of docstrings rather than explicit value assignment. This would not only maintain existing functionality but also align autocod's behavior with the expectations set forth by Python's typing and documentation conventions."
    }
]